Name,Code,Category
i,"
public static int isPairSum(int A[], int N, int X)
    {
        int i = 0;
        int j = N - 1;
 
        do {
            if (A[i] + A[j] == X) 
                return 1;
            else if (A[i] + A[j] < X)
                i++;
            else
                j--;
        } while (i < j);
        return 0;
    }
",loop_control
j,"
public static int isPairSum(int A[], int N, int X)
    {
        int i = 0;
        int j = N - 1;
 
        do {
            if (A[i] + A[j] == X) 
                return 1;
            else if (A[i] + A[j] < X)
                i++;
            else
                j--;
        } while (i < j);
        return 0;
    }
",loop_control
input,"
final public static void Authification(String input) {
    do {
        System.out.print(""Password? "");
        input = scanner.nextLine().trim();
    } while (!input.equals(VerySafeClass.PASSWORD));
}
",loop_control
number,"
public static void main(String[] args) {
      
    int sum = 0;
    int number = 0;

    Scanner input = new Scanner(System.in);
       
    do {
      sum += number;
      System.out.println(""Enter a number"");
      number = input.nextInt();
    } while(number >= 0); 
   
    System.out.println(""Sum = "" + sum);
    input.close();
  }
",loop_control
num,"
public static void RussianRoulette (String[] args) {
    Scanner input = new Scanner(System.in);
    Random rand = new Random();
    System.out.println(""Enter an integer between 0-9"");
    
    int num = input.nextInt();
    int randomNum = rand.nextInt(10);
    
    do{
        randomNum = rand.nextInt(10);
        System.out.println(""User: "" + num + "" : "" + ""Random number: "" + randomNum);
    } while (num != randomNum);
    
    return num;
}
",loop_control
i,"
    public static int isPairSum(int A[], int N, int X)
    {
        int i = 0;
        int j = N - 1;
 
        while (i < j) {
            if (A[i] + A[j] == X) 
                return 1;
            else if (A[i] + A[j] < X)
                i++;
            else
                j--;
        }
        return 0;
    }
",loop_control
i,"
void BFS(int n)
    {

        boolean nodes[] = new boolean[V];
        int a = 0;
 
        nodes[n]=true;                  
        queue.add(n);
 
        while (queue.size() != 0)
        {
            n = queue.poll();
            System.out.print(n+"" "");
 
            for (int i = 0; i < adj[n].size(); i++)  
            {
                a = adj[n].get(i);
                if (!nodes[a])
                {
                    nodes[a] = true;
                    queue.add(a);
                }
            }  
        }
    }
",loop_control
i,"
public static void main(String args[])  
{  
    int SIZE=10;  
    int i, j, N;  
    int[][] board = new int[SIZE][SIZE];  
    int left, top;  
    left = 0;  
    top = SIZE - 1;  
    N = 1;  
    for(i=1; i<=SIZE/2; i++, left++, top--)  
    {  
        for(j=left; j<=top; j++, N++)  
        {  
            board[left][j] = N;  
        }  
        for(j=left+1; j<=top; j++, N++)  
        {  
            board[j][top] = N;  
        }  
        for(j=top-1; j>=left; j--, N++)  
        {  
            board[top][j] = N;  
        }  
        for(j=top-1; j>=left+1; j--, N++)  
        {  
            board[j][left] = N;  
        }  
    }  
    for(i=0; i<SIZE; i++)  
    {  
        for(j=0; j<SIZE; j++)  
        {  
            System.out.printf(""%-5d"", board[i][j]);  
        }  
    System.out.printf(""
"");  
    }  
}  
",loop_control
j,"
public static void main(String args[])  
{  
    int SIZE=10;  
    int i, j, N;  
    int[][] board = new int[SIZE][SIZE];  
    int left, top;  
    left = 0;  
    top = SIZE - 1;  
    N = 1;  
    for(i=1; i<=SIZE/2; i++, left++, top--)  
    {  
        for(j=left; j<=top; j++, N++)  
        {  
            board[left][j] = N;  
        }  
        for(j=left+1; j<=top; j++, N++)  
        {  
            board[j][top] = N;  
        }  
        for(j=top-1; j>=left; j--, N++)  
        {  
            board[top][j] = N;  
        }  
        for(j=top-1; j>=left+1; j--, N++)  
        {  
            board[j][left] = N;  
        }  
    }  
    for(i=0; i<SIZE; i++)  
    {  
        for(j=0; j<SIZE; j++)  
        {  
            System.out.printf(""%-5d"", board[i][j]);  
        }  
    System.out.printf(""
"");  
    }  
}  
",loop_control
bufSize,"
  private static byte[] toByteArrayInternal(InputStream in, Queue<byte[]> bufs, int totalLen)
      throws IOException {
    int initialBufferSize = min(BUFFER_SIZE, max(128, Integer.highestOneBit(totalLen) * 2));
    
    for (int bufSize = initialBufferSize;
        totalLen < MAX_ARRAY_LEN;
        bufSize = IntMath.saturatedMultiply(bufSize, bufSize < 4096 ? 4 : 2)) {
      byte[] buf = new byte[min(bufSize, MAX_ARRAY_LEN - totalLen)];
      bufs.add(buf);
      int off = 0;
      while (off < buf.length) {
        // always OK to fill buf; its size plus the rest of bufs is never more than MAX_ARRAY_LEN
        int r = in.read(buf, off, buf.length - off);
        if (r == -1) {
          return combineBuffers(bufs, totalLen);
        }
        off += r;
        totalLen += r;
      }
    }

    if (in.read() == -1) {
      return combineBuffers(bufs, MAX_ARRAY_LEN);
    } else {
      throw new OutOfMemoryError(""input is too large to fit in a byte array"");
    }
  }
",loop_control
totalLen,"
  private static byte[] toByteArrayInternal(InputStream in, Queue<byte[]> bufs, int totalLen)
      throws IOException {
    int initialBufferSize = min(BUFFER_SIZE, max(128, Integer.highestOneBit(totalLen) * 2));
    
    for (int bufSize = initialBufferSize;
        totalLen < MAX_ARRAY_LEN;
        bufSize = IntMath.saturatedMultiply(bufSize, bufSize < 4096 ? 4 : 2)) {
      byte[] buf = new byte[min(bufSize, MAX_ARRAY_LEN - totalLen)];
      bufs.add(buf);
      int off = 0;
      while (off < buf.length) {
        // always OK to fill buf; its size plus the rest of bufs is never more than MAX_ARRAY_LEN
        int r = in.read(buf, off, buf.length - off);
        if (r == -1) {
          return combineBuffers(bufs, totalLen);
        }
        off += r;
        totalLen += r;
      }
    }

    if (in.read() == -1) {
      return combineBuffers(bufs, MAX_ARRAY_LEN);
    } else {
      throw new OutOfMemoryError(""input is too large to fit in a byte array"");
    }
  }
",loop_control
off,"
  private static byte[] toByteArrayInternal(InputStream in, Queue<byte[]> bufs, int totalLen)
      throws IOException {
    int initialBufferSize = min(BUFFER_SIZE, max(128, Integer.highestOneBit(totalLen) * 2));
    
    for (int bufSize = initialBufferSize;
        totalLen < MAX_ARRAY_LEN;
        bufSize = IntMath.saturatedMultiply(bufSize, bufSize < 4096 ? 4 : 2)) {
      byte[] buf = new byte[min(bufSize, MAX_ARRAY_LEN - totalLen)];
      bufs.add(buf);
      int off = 0;
      while (off < buf.length) {
        // always OK to fill buf; its size plus the rest of bufs is never more than MAX_ARRAY_LEN
        int r = in.read(buf, off, buf.length - off);
        if (r == -1) {
          return combineBuffers(bufs, totalLen);
        }
        off += r;
        totalLen += r;
      }
    }

    if (in.read() == -1) {
      return combineBuffers(bufs, MAX_ARRAY_LEN);
    } else {
      throw new OutOfMemoryError(""input is too large to fit in a byte array"");
    }
  }
",loop_control
i,"
LLNode insertAtPos(int key,int pos,LLNode head)
{
    LLNode ttmp=new LLNode(key);

    if(pos==1)
    {
        ttmp.next=head;
        head=ttmp;
    }
    else
    {
        LLNode ttmp1=head;
        for(int i=1;ttmp1!=null && i<pos;i++)
            ttmp1=ttmp1.next;
        ttmp.next=ttmp1.next;
        ttmp1.next=ttmp;
    }

    return head;
}
",loop_control
counter,"
public void test_ConstructorLjava_util_Collection() {
    ArrayList al = new ArrayList(Arrays.asList(objArray));
    assertTrue(""arrayList created from collection has incorrect size"", al.size() == objArray.length);
    for (int counter = 0; counter < objArray.length; counter++) 
        assertTrue(""arrayList created from collection has incorrect elements"", 
                   al.get(counter) == objArray[counter]);
    try {
        new ArrayList(null);
        fail(""NullPointerException expected"");
    } 
    catch (NullPointerException e) {}
}
",loop_control
i,"
  protected boolean restoreSketches() throws Exception {
    int count = PreferencesData.getInteger(""last.sketch.count"");
    int opened = 0;
    for (int i = count - 1; i >= 0; i--) {
      String path = PreferencesData.get(""last.sketch"" + i + "".path"");
      if (path == null) {
        continue;
      }
      if (BaseNoGui.getPortableFolder() != null && !new File(path).isAbsolute()) {
        File absolute = new File(BaseNoGui.getPortableFolder(), path);
        try {
          path = absolute.getCanonicalPath();
        } catch (IOException e) {
        }
      }
      int[] location = retrieveSketchLocation("""" + i);
      if (handleOpen(new File(path), location, nextEditorLocation(), false, false) != null) {
        opened++;
      }
    }
    return (opened > 0);
  }
",loop_control
i,"
public static void main(String[] args) {
        ArrayList<Room> hotelRooms = new ArrayList<>();
        for (int i = 0; i < 15; i++) {
            hotelRooms.add(new HostelRoom(new StandardRoom(i + 1, 2, RoomType.ECONOMY)));
        }
        for (int i = 0; i < 15; i++) {
            hotelRooms.add(new ExpandableRoom(new StandardRoom(i + 16, 3, RoomType.LUX)));
        }
        Hotel hotel = new Hotel(hotelRooms);
        RoomManager roomManager = new RoomManager();
        StaffManager staffManager = new StaffManager();
        Human client1 = new Human(""John"", ""Lennon"");
        Human client2 = new Human(""Paul"", ""McCartney"");
        Human client3 = new Human(""Ringo"", ""Starr"");

        Human slave1 = new Human(""George"", ""Harrison"");

        Human slave2 = new Human(""Doctor"", ""Scranton"");

        staffManager.hireStaff(hotel, new PlumberCreator().createStaff(slave1, StaffType.IRREGULAR));
        staffManager.hireStaff(hotel, new SecurityGuardCreator().createStaff(slave2, StaffType.IRREGULAR));
        for (int i = 0; i < hotel.getStaff().size(); i++) {
            System.out.println(hotel.getStaff().get(i).getPersonalInformation().getName());
        }
        staffManager.makeOrder(Plumber.class, hotel, 2, ""Help, our pump was broken :("");
    }
",loop_control
i,"
public void bookRoom(RoomAccess access, Human client, RoomType type, int peopleCount) {
        Room currentRoom;
        for (int i = 0; i < access.getRooms().size(); i++) {
            currentRoom = access.getRooms().get(i);
            if (currentRoom.isOccupied()) {
                continue;
            }
            if (currentRoom.getSize() < peopleCount) {
                continue;
            }
            if (currentRoom.getType() != type) {
                continue;
            }
            currentRoom.checkIn(client, peopleCount);
            break;
        }
    }
",loop_control
e,"
public void replay(ReplaySubscription<T> rs) {
    if (rs.getAndIncrement() != 0) {
        return;
    }

    int missed = 1;
    final Subscriber<? super T> a = rs.downstream;

    Node<T> index = (Node<T>)rs.index;
    if (index == null) {
        index = head;
    }

    long e = rs.emitted;

    for (;;) {

        long r = rs.requested.get();

        while (e != r) {
            if (rs.cancelled) {
                rs.index = null;
                return;
            }

            boolean d = done;
            Node<T> next = index.get();
            boolean empty = next == null;

            if (d && empty) {
                rs.index = null;
                rs.cancelled = true;
                Throwable ex = error;
                if (ex == null) {
                    a.onComplete();
                } else {
                    a.onError(ex);
                }
                return;
            }

            if (empty) {
                break;
            }

            a.onNext(next.value);
            e++;
            index = next;
        }

        if (e == r) {
            if (rs.cancelled) {
                rs.index = null;
                return;
            }

            boolean d = done;

            if (d && index.get() == null) {
                rs.index = null;
                rs.cancelled = true;
                Throwable ex = error;
                if (ex == null) {
                    a.onComplete();
                } else {
                    a.onError(ex);
                }
                return;
            }
        }

        rs.index = index;
        rs.emitted = e;

        missed = rs.addAndGet(-missed);
        if (missed == 0) {
            break;
        }
    }
}
",loop_control
index,"
public void replay(ReplaySubscription<T> rs) {
    if (rs.getAndIncrement() != 0) {
        return;
    }

    int missed = 1;
    final Subscriber<? super T> a = rs.downstream;

    Node<T> index = (Node<T>)rs.index;
    if (index == null) {
        index = head;
    }

    long e = rs.emitted;

    for (;;) {

        long r = rs.requested.get();

        while (e != r) {
            if (rs.cancelled) {
                rs.index = null;
                return;
            }

            boolean d = done;
            Node<T> next = index.get();
            boolean empty = next == null;

            if (d && empty) {
                rs.index = null;
                rs.cancelled = true;
                Throwable ex = error;
                if (ex == null) {
                    a.onComplete();
                } else {
                    a.onError(ex);
                }
                return;
            }

            if (empty) {
                break;
            }

            a.onNext(next.value);
            e++;
            index = next;
        }

        if (e == r) {
            if (rs.cancelled) {
                rs.index = null;
                return;
            }

            boolean d = done;

            if (d && index.get() == null) {
                rs.index = null;
                rs.cancelled = true;
                Throwable ex = error;
                if (ex == null) {
                    a.onComplete();
                } else {
                    a.onError(ex);
                }
                return;
            }
        }

        rs.index = index;
        rs.emitted = e;

        missed = rs.addAndGet(-missed);
        if (missed == 0) {
            break;
        }
    }
}
",loop_control
e,"
void drainRegular(Subscriber<? super T> a) {
    int missed = 1;
    final SpscLinkedArrayQueue<T> q = queue;
    final boolean failFast = !delayError;

    for (;;) {
        long r = requested.get();
        long e = 0L;

        while (r != e) {
            boolean d = done;

            T t = q.poll();
            boolean empty = t == null;

            if (checkTerminated(failFast, d, empty, a, q)) {
                return;
            }
            if (empty) {
                break;
            }
            a.onNext(t);

            e++;
        }
        if (r == e && checkTerminated(failFast, done, q.isEmpty(), a, q)) {
            return;
        }
        if (e != 0 && r != Long.MAX_VALUE) {
            requested.addAndGet(-e);
        }
        missed = wip.addAndGet(-missed);
        if (missed == 0) {
            break;
        }
    }
}
",loop_control
e,"
public void replay(ReplaySubscription<T> rs) {
    if (rs.getAndIncrement() != 0) {
        return;
    }

    int missed = 1;
    final Subscriber<? super T> a = rs.downstream;

    Node<T> index = (Node<T>)rs.index;
    if (index == null) {
        index = head;
    }

    long e = rs.emitted;

    for (;;) {

        long r = rs.requested.get();

        while (e != r) {
            if (rs.cancelled) {
                rs.index = null;
                return;
            }

            boolean d = done;
            Node<T> next = index.get();
            boolean empty = next == null;

            if (d && empty) {
                rs.index = null;
                rs.cancelled = true;
                Throwable ex = error;
                if (ex == null) {
                    a.onComplete();
                } else {
                    a.onError(ex);
                }
                return;
            }

            if (empty) {
                break;
            }

            a.onNext(next.value);
            e++;
            index = next;
        }

        if (e == r) {
            if (rs.cancelled) {
                rs.index = null;
                return;
            }

            boolean d = done;

            if (d && index.get() == null) {
                rs.index = null;
                rs.cancelled = true;
                Throwable ex = error;
                if (ex == null) {
                    a.onComplete();
                } else {
                    a.onError(ex);
                }
                return;
            }
        }

        rs.index = index;
        rs.emitted = e;

        missed = rs.addAndGet(-missed);
        if (missed == 0) {
            break;
        }
    }
}
",loop_control
index,"
public void replay(ReplayDisposable<T> rs) {
    if (rs.getAndIncrement() != 0) {
        return;
    }

    int missed = 1;
    final List<Object> b = buffer;
    final Observer<? super T> a = rs.downstream;

    Integer indexObject = (Integer)rs.index;
    int index;
    if (indexObject != null) {
        index = indexObject;
    } else {
        index = 0;
        rs.index = 0;
    }

    for (;;) {

        if (rs.cancelled) {
            rs.index = null;
            return;
        }

        int s = size;

        while (s != index) {

            if (rs.cancelled) {
                rs.index = null;
                return;
            }

            Object o = b.get(index);

            if (done) {
                if (index + 1 == s) {
                    s = size;
                    if (index + 1 == s) {
                        if (NotificationLite.isComplete(o)) {
                            a.onComplete();
                        } else {
                            a.onError(NotificationLite.getError(o));
                        }
                        rs.index = null;
                        rs.cancelled = true;
                        return;
                    }
                }
            }

            a.onNext((T)o);
            index++;
        }

        if (index != size) {
            continue;
        }

        rs.index = index;

        missed = rs.addAndGet(-missed);
        if (missed == 0) {
            break;
        }
    }
}
",loop_control
i,"
public T[] getValues(T[] array) {
    Node<Object> h = head;
    int s = size();

    if (s == 0) {
        if (array.length != 0) {
            array[0] = null;
        }
    } else {
        if (array.length < s) {
            array = (T[])Array.newInstance(array.getClass().getComponentType(), s);
        }

        int i = 0;
        while (i != s) {
            Node<Object> next = h.get();
            array[i] = (T)next.value;
            i++;
            h = next;
        }
        if (array.length > s) {
            array[s] = null;
        }
    }

    return array;
}
",loop_control
s,"
public int size() {
    int s = 0;
    Node<Object> h = head;
    while (s != Integer.MAX_VALUE) {
        Node<Object> next = h.get();
        if (next == null) {
            Object o = h.value;
            if (NotificationLite.isComplete(o) || NotificationLite.isError(o)) {
                s--;
            }
            break;
        }
        s++;
        h = next;
    }

    return s;
}
",loop_control
pos,"
protected void add(char[] cbuf, int off, int len) throws IOException {
    int pos = off;
    if (sawReturn && len > 0) {
      if (finishLine(cbuf[pos] == '
')) {
        pos++;
      }
    }

    int start = pos;
    for (int end = off + len; pos < end; pos++) {
      switch (cbuf[pos]) {
        case '':
          line.append(cbuf, start, pos - start);
          sawReturn = true;
          if (pos + 1 < end) {
            if (finishLine(cbuf[pos + 1] == '
')) {
              pos++;
            }
          }
          start = pos + 1;
          break;

        case '
':
          line.append(cbuf, start, pos - start);
          finishLine(true);
          start = pos + 1;
          break;

        default:
          
      }
    }
    line.append(cbuf, start, off + len - start);
  }
",loop_control
end,"
protected void add(char[] cbuf, int off, int len) throws IOException {
    int pos = off;
    if (sawReturn && len > 0) {
      if (finishLine(cbuf[pos] == '
')) {
        pos++;
      }
    }

    int start = pos;
    for (int end = off + len; pos < end; pos++) {
      switch (cbuf[pos]) {
        case '':
          line.append(cbuf, start, pos - start);
          sawReturn = true;
          if (pos + 1 < end) {
            if (finishLine(cbuf[pos + 1] == '
')) {
              pos++;
            }
          }
          start = pos + 1;
          break;

        case '
':
          line.append(cbuf, start, pos - start);
          finishLine(true);
          start = pos + 1;
          break;

        default:
          
      }
    }
    line.append(cbuf, start, off + len - start);
  }
",loop_control
i,"
private void filterVisibilityOfSubsequentBoardMenus(List<JMenu> boardsCustomMenus, TargetBoard board,
                                                      int fromIndex) {
    for (int i = fromIndex; i < boardsCustomMenus.size(); i++) {
      JMenu menu = boardsCustomMenus.get(i);
      for (int m = 0; m < menu.getItemCount(); m++) {
        JMenuItem menuItem = menu.getItem(m);
        for (TargetBoard t_board : (List<TargetBoard>)menuItem.getAction().getValue(""board"")) {
          menuItem.setVisible(t_board.equals(board));
        }
      }
      menu.setVisible(ifThereAreVisibleItemsOn(menu));

      if (menu.isVisible()) {
        JMenuItem visibleSelectedOrFirstMenuItem = selectVisibleSelectedOrFirstMenuItem(menu);
        if (!visibleSelectedOrFirstMenuItem.isSelected()) {
          visibleSelectedOrFirstMenuItem.setSelected(true);
          visibleSelectedOrFirstMenuItem.getAction().actionPerformed(null);
        }
      }
    }
  }
",loop_control
m,"
private void filterVisibilityOfSubsequentBoardMenus(List<JMenu> boardsCustomMenus, TargetBoard board,
                                                      int fromIndex) {
    for (int i = fromIndex; i < boardsCustomMenus.size(); i++) {
      JMenu menu = boardsCustomMenus.get(i);
      for (int m = 0; m < menu.getItemCount(); m++) {
        JMenuItem menuItem = menu.getItem(m);
        for (TargetBoard t_board : (List<TargetBoard>)menuItem.getAction().getValue(""board"")) {
          menuItem.setVisible(t_board.equals(board));
        }
      }
      menu.setVisible(ifThereAreVisibleItemsOn(menu));

      if (menu.isVisible()) {
        JMenuItem visibleSelectedOrFirstMenuItem = selectVisibleSelectedOrFirstMenuItem(menu);
        if (!visibleSelectedOrFirstMenuItem.isSelected()) {
          visibleSelectedOrFirstMenuItem.setSelected(true);
          visibleSelectedOrFirstMenuItem.getAction().actionPerformed(null);
        }
      }
    }
  }
",loop_control
suffix,"
public boolean matchesBoard(TargetBoard board) {
    PreferencesMap identificationProps = getIdentificationPrefs();
    PreferencesMap boardProps = board.getPreferences();

    String wildMatcher = identificationProps.get(""."");
    if (wildMatcher != null) {
      if (wildMatcher.equals(board.getId())) {
        return true;
      }
      if (wildMatcher.equals(board.getFQBN())) {
        return true;
      }
    }

    for (int suffix = 0;; suffix++) {
      boolean found = true;
      for (String prop : identificationProps.keySet()) {
        String value = identificationProps.get(prop);
        prop += ""."" + suffix;
        if (!boardProps.containsKey(prop)) {
          return false;
        }
        if (!value.equalsIgnoreCase(boardProps.get(prop))) {
          found = false;
          break;
        }
      }
      if (found) {
        return true;
      }
    }
}
",loop_control
i,"
public synchronized void forceRefresh() {
    Platform platform = BaseNoGui.getPlatform();
    if (platform == null) {
      return;
    }

    List<String> ports = platform.listSerials();
    if (ports.equals(oldPorts)) {
      return;
    }

    oldPorts.clear();
    oldPorts.addAll(ports);

    for (BoardPort board : boardPorts) {
      if (!ports.contains(board.toCompleteString())) {
        board.setOnlineStatus(false);
      }
    }

    for (String newPort : ports) {

      BoardPort oldBoardPort = boardPorts.stream() //
          .filter(bp -> bp.toCompleteString().equalsIgnoreCase(newPort)) //
          .findAny().orElse(null);
      if (oldBoardPort != null) {
        oldBoardPort.setOnlineStatus(true);
        continue;
      }

      String[] parts = newPort.split(""_"");
      if (parts.length < 3) {
        continue;
      }
      if (parts.length > 3) {
        for (int i = 1; i < (parts.length-2); i++) {
          parts[0] += ""_"" + parts[i];
        }
        parts[1] = parts[parts.length-2];
        parts[2] = parts[parts.length-1];
      }
    }
      setSerialBoardPorts(boardPorts);
}
",loop_control
i,"
private void testEqualsUsing(final Invokable<?, ?> factory)
      throws ParameterNotInstantiableException, ParameterHasNoDistinctValueException,
          IllegalAccessException, InvocationTargetException, FactoryMethodReturnsNullException {
    List<Parameter> params = factory.getParameters();
    List<FreshValueGenerator> argGenerators = Lists.newArrayListWithCapacity(params.size());
    List<Object> args = Lists.newArrayListWithCapacity(params.size());
    for (Parameter param : params) {
      FreshValueGenerator generator = newFreshValueGenerator();
      argGenerators.add(generator);
      args.add(generateDummyArg(param, generator));
    }
    Object instance = createInstance(factory, args);
    List<Object> equalArgs = generateEqualFactoryArguments(factory, params, args);
    // Each group is a List of items, each item has a list of factory args.
    final List<List<List<Object>>> argGroups = Lists.newArrayList();
    argGroups.add(ImmutableList.of(args, equalArgs));
    EqualsTester tester =
        new EqualsTester(
            new ItemReporter() {
              @Override
              String reportItem(Item<?> item) {
                List<Object> factoryArgs = argGroups.get(item.groupNumber).get(item.itemNumber);
                return factory.getName()
                    + ""(""
                    + Joiner.on("", "").useForNull(""null"").join(factoryArgs)
                    + "")"";
              }
            });
    tester.addEqualityGroup(instance, createInstance(factory, equalArgs));
    for (int i = 0; i < params.size(); i++) {
      List<Object> newArgs = Lists.newArrayList(args);
      Object newArg = argGenerators.get(i).generateFresh(params.get(i).getType());

      if (newArg == null || Objects.equal(args.get(i), newArg)) {
        if (params.get(i).getType().getRawType().isEnum()) {
          continue; // Nothing better we can do if it's single-value enum
        }
        throw new ParameterHasNoDistinctValueException(params.get(i));
      }
      newArgs.set(i, newArg);
      tester.addEqualityGroup(createInstance(factory, newArgs));
      argGroups.add(ImmutableList.of(newArgs));
    }
    tester.testEquals();
    }
",loop_control
kids,"
public static UIComponent findComponent(UIComponent parent, String id) {
    if (id.equals(parent.getId())) {
        return parent;
    }
    Iterator<UIComponent> kids = parent.getFacetsAndChildren();
    while (kids.hasNext()) {
        UIComponent kid = kids.next();
        UIComponent found = findComponent(kid, id);
        if (found != null) {
            return found;
        }
    }
    return null;
}
",iterator
keyIterator,"
public Object[][] convert(Map<String, Object> mapIn) {
    Object[][] out = new Object[mapIn.size()][2];
    Iterator<String> keyIterator = mapIn.keySet().iterator();
    Iterator<Object> valueIterator = mapIn.values().iterator();
    int row = 0;
    while (keyIterator.hasNext()) {
        //
        String key = keyIterator.next();
        Object value = valueIterator.next();
        out[row][0] = key;
        out[row][1] = value;
        row++;
    }
    return out;
}
",iterator
valueIterator,"
public Object[][] convert(Map<String, Object> mapIn) {
    Object[][] out = new Object[mapIn.size()][2];
    Iterator<String> keyIterator = mapIn.keySet().iterator();
    Iterator<Object> valueIterator = mapIn.values().iterator();
    int row = 0;
    while (keyIterator.hasNext()) {
        //
        String key = keyIterator.next();
        Object value = valueIterator.next();
        out[row][0] = key;
        out[row][1] = value;
        row++;
    }
    return out;
}
",iterator
repositoryIterator,"
public LocalRepository getLocalRepositoryOrFail() {
    Iterator<LocalRepository> repositoryIterator = pm().getExtent(LocalRepository.class).iterator();
    if (!repositoryIterator.hasNext()) {
        throw new IllegalStateException(""LocalRepository entity not found in database."");
    }
    LocalRepository localRepository = repositoryIterator.next();
    if (repositoryIterator.hasNext()) {
        throw new IllegalStateException(""Multiple LocalRepository entities in database."");
    }
    return localRepository;
}
",iterator
iter,"
public String toString() {
    StringBuilder sb = new StringBuilder();
    sb.append(name).append('(');
    Iterator<Object> iter = args.iterator();
    if (iter.hasNext()) {
        sb.append(JsonUtil.toJsonScriptCode(iter.next()));
    }
    for (; iter.hasNext(); ) {
        sb.append(',');
        sb.append(JsonUtil.toJsonScriptCode(iter.next()));
    }
    return sb.toString();
}
",iterator
it,"
public static void main(String[] args) {
    ArrayList<Integer> numbers = new ArrayList<Integer>();
    numbers.add(12);
    numbers.add(8);
    numbers.add(2);
    numbers.add(23);
    Iterator<Integer> it = numbers.iterator();
    while(it.hasNext()) {
      Integer i = it.next();
      if(i < 10) {
        it.remove();
      }
    }
    System.out.println(numbers);
  }
",iterator
i,"
public static void main(String[] args) {
    ArrayList<Integer> numbers = new ArrayList<Integer>();
    numbers.add(12);
    numbers.add(8);
    numbers.add(2);
    numbers.add(23);
    Iterator<Integer> it = numbers.iterator();
    while(it.hasNext()) {
      Integer i = it.next();
      if(i < 10) {
        it.remove();
      }
    }
    System.out.println(numbers);
  }
",iterator
it,"
public void itShouldIterateSequenceUrls() throws Exception {
    Iterator<Sequence> it = new SequenceIterator(Granularity.hour, 999, 1001);
    assertEquals(""http://planet.openstreetmap.org/replication/hour/000/001/000.osc.gz"", it.next().getUrl());
    assertEquals(""http://planet.openstreetmap.org/replication/hour/000/001/001.osc.gz"", it.next().getUrl());
    assertFalse(it.hasNext());
}
",iterator
it,"
public ErrorAggregateValue aggregate(Iterable<ErrorAggregateValue> aggValues) {
    ErrorAggregateValue errorSum = new ErrorAggregateValue();
    Iterator<ErrorAggregateValue> it = aggValues.iterator();
    double errorValue = 0.0;
    while (it.hasNext()) {
        errorValue += Double.parseDouble(it.next().getValue());
    }
    errorSum.setValue(Double.toString(errorValue));
    return errorSum;
}
",iterator
iterator,"
public static String getAccessToken(TreeMap<String, String> map, String app_secret) {
    String toMd5 = """";
    Set<String> keys = map.keySet();
    Iterator<String> iterator = keys.iterator();
    while (iterator.hasNext()) {
        String key = iterator.next();
        toMd5 += key + ""="" + map.get(key) + ""&"";
    }
    toMd5 = toMd5.substring(0, toMd5.length() - 1);
    toMd5 += app_secret;
    return MD5.digest(toMd5);
}
",iterator
i,"
public Object visit(RelationNode node) {
    double num = 0;
    Object data = node.getData();
    if (data instanceof Number) {
        num += ((Number) data).doubleValue();
    }
    for (Iterator i = node.getChildren().iterator(); i.hasNext(); ) {
        Object tmp = ((RelationNode) i.next()).accept(this);
        if (tmp instanceof Number) {
            num += ((Number) tmp).doubleValue();
        }
    }
    return new Double(num);
}
",iterator
iterator,"
public String getMessage() {
    StringBuilder builder = new StringBuilder(""["");
    for (Iterator<ConstraintViolation<Object>> iterator = violations.iterator(); iterator.hasNext(); ) {
        builder.append(iterator.next().getMessage());
        if (iterator.hasNext()) {
            builder.append("", "");
        }
    }
    builder.append(""]"");
    return builder.toString();
}
",iterator
lib,"
public void reload() {
    try {
      parseKeywordsTxt(new File(BaseNoGui.getContentFile(""lib""), ""keywords.txt""));
      TargetPlatform tp = BaseNoGui.getTargetPlatform();
      if (tp != null) {
        File platformKeywords = new File(tp.getFolder(), ""keywords.txt"");
        if (platformKeywords.exists()) parseKeywordsTxt(platformKeywords);
      }
      for (UserLibrary lib : BaseNoGui.librariesIndexer.getInstalledLibraries()) {
        File keywords = new File(lib.getInstalledFolder(), ""keywords.txt"");b        if (keywords.exists()) {
          parseKeywordsTxt(keywords);
        }
      }
    } catch (Exception e) {
      Base.showError(""Problem loading keywords"", ""Could not load keywords.txt,
please re-install Arduino."", e);
      System.exit(1);
    }
  }
",iterator
editor,"
  protected void storeSketches() {

    if (editors.size() == 1) {
      storeSketchLocation(editors.get(0), "".default"");
    }

    String untitledPath = untitledFolder.getAbsolutePath();
    List<Editor> reversedEditors = new LinkedList<>(editors);
    Collections.reverse(reversedEditors);
    int index = 0;
    for (Editor editor : reversedEditors) {
      Sketch sketch = editor.getSketch();
      String path = sketch.getMainFilePath();
    
        if (path.startsWith(untitledPath) && !sketch.isModified()) {
        continue;
      }
      storeSketchLocation(editor, """" + index);
      index++;
    }
    PreferencesData.setInteger(""last.sketch.count"", index);
  }
",iterator
path,"
protected void rebuildRecentSketchesMenuItems() {
    Set<File> recentSketches = new LinkedHashSet<File>() {
        @Override
        public boolean add(File file) {
            if (size() >= RECENT_SKETCHES_MAX_SIZE) {
                return false;
            }
            return super.add(file);
        }
    };

    for (String path : PreferencesData.getCollection(""recent.sketches"")) {
      File file = new File(path);
      if (file.exists()) {
        recentSketches.add(file);
      }
    }

    recentSketchesMenuItems.clear();
    for (final File recentSketch : recentSketches) {
      JMenuItem recentSketchMenuItem = new JMenuItem(recentSketch.getParentFile().getName());
      recentSketchMenuItem.addActionListener(new ActionListener() {
        @Override
        public void actionPerformed(ActionEvent actionEvent) {
          try {
            handleOpen(recentSketch);
          } catch (Exception e) {
            e.printStackTrace();
          }
        }
      });
      recentSketchesMenuItems.add(recentSketchMenuItem);
    }
}
",iterator
recentSketch,"
protected void rebuildRecentSketchesMenuItems() {
    Set<File> recentSketches = new LinkedHashSet<File>() {
        @Override
        public boolean add(File file) {
            if (size() >= RECENT_SKETCHES_MAX_SIZE) {
                return false;
            }
            return super.add(file);
        }
    };

    for (String path : PreferencesData.getCollection(""recent.sketches"")) {
      File file = new File(path);
      if (file.exists()) {
        recentSketches.add(file);
      }
    }

    recentSketchesMenuItems.clear();
    for (final File recentSketch : recentSketches) {
      JMenuItem recentSketchMenuItem = new JMenuItem(recentSketch.getParentFile().getName());
      recentSketchMenuItem.addActionListener(new ActionListener() {
        @Override
        public void actionPerformed(ActionEvent actionEvent) {
          try {
            handleOpen(recentSketch);
          } catch (Exception e) {
            e.printStackTrace();
          }
        }
      });
      recentSketchesMenuItems.add(recentSketchMenuItem);
    }
}
",iterator
editor,"
protected boolean handleQuitEach() {
   for (Editor editor : editors) {
     if (!editor.checkModified()) {
       return false;
     }
   }
   return true;
}
",iterator
t_board,"
private void filterVisibilityOfSubsequentBoardMenus(List<JMenu> boardsCustomMenus, TargetBoard board,
                                                      int fromIndex) {
    for (int i = fromIndex; i < boardsCustomMenus.size(); i++) {
      JMenu menu = boardsCustomMenus.get(i);
      for (int m = 0; m < menu.getItemCount(); m++) {
        JMenuItem menuItem = menu.getItem(m);
        for (TargetBoard t_board : (List<TargetBoard>)menuItem.getAction().getValue(""board"")) {
          menuItem.setVisible(t_board.equals(board));
        }
      }
      menu.setVisible(ifThereAreVisibleItemsOn(menu));

      if (menu.isVisible()) {
        JMenuItem visibleSelectedOrFirstMenuItem = selectVisibleSelectedOrFirstMenuItem(menu);
        if (!visibleSelectedOrFirstMenuItem.isSelected()) {
          visibleSelectedOrFirstMenuItem.setSelected(true);
          visibleSelectedOrFirstMenuItem.getAction().actionPerformed(null);
        }
      }
    }
  }
",iterator
networkService,"
private ListenableFuture<ReconnaissanceReport> fingerprintNetworkServices(
      PortScanningReport portScanningReport) {
    checkNotNull(portScanningReport);

    TargetInfo targetInfo = portScanningReport.getTargetInfo();
    List<PluginMatchingResult<ServiceFingerprinter>> matchedFingerprinters = Lists.newArrayList();
    List<NetworkService> networkServicesToKeep = Lists.newArrayList();
    for (NetworkService networkService : portScanningReport.getNetworkServicesList()) {
      Optional<PluginMatchingResult<ServiceFingerprinter>> matchedFingerprinter =
          pluginManager.getServiceFingerprinter(networkService);
      if (matchedFingerprinter.isPresent()) {
        matchedFingerprinters.add(matchedFingerprinter.get());
      } else {
        networkServicesToKeep.add(networkService);
      }
    }

    executionTracer.startServiceFingerprinting(ImmutableList.copyOf(matchedFingerprinters));
    logger.atInfo().log(
        ""Port scanning phase done, moving to service fingerprinting phase with '%d'""
            + "" fingerprinter(s) selected."",
        matchedFingerprinters.size());

   ImmutableList<ListenableFuture<PluginExecutionResult<FingerprintingReport>>>
        fingerprintingResultFutures =
            matchedFingerprinters.stream()
                .map(fingerprinter -> buildFingerprinterExecutorConfig(targetInfo, fingerprinter))
                .map(executorConfig -> pluginExecutorProvider.get().executeAsync(executorConfig))
                .collect(toImmutableList());
    return FluentFuture.from(Futures.successfulAsList(fingerprintingResultFutures))
        .transform(
            executionResults ->
                ReconnaissanceReport.newBuilder()
                    .setTargetInfo(targetInfo)
                    .addAllNetworkServices(networkServicesToKeep)
                    .addAllNetworkServices(getFingerprintedServices(executionResults))
                    .build(),
            directExecutor());
  }
",iterator
node,"
 private ImmutableSet<N> validate(Iterable<? extends N> startNodes) {
    ImmutableSet<N> copy = ImmutableSet.copyOf(startNodes);
    for (N node : copy) {
      successorFunction.successors(node); // Will throw if node doesn't exist
    }
    return copy;
  }
",iterator
edge,"
  public boolean removeNode(N node) {
    checkNotNull(node, ""node"");

    NetworkConnections<N, E> connections = nodeConnections.get(node);
    if (connections == null) {
      return false;
    }

    for (E edge : ImmutableList.copyOf(connections.incidentEdges())) {
      removeEdge(edge);
    }
    nodeConnections.remove(node);
    return true;
  }
",iterator
source,"
    public long length() throws IOException {
      long result = 0L;
      for (CharSource source : sources) {
        result += source.length();
      }
      return result;
    }
",iterator
e,"
  private static void throwDeleteFailed(Path path, Collection<IOException> exceptions)
      throws FileSystemException {
    NoSuchFileException pathNotFound = pathNotFound(path, exceptions);
    if (pathNotFound != null) {
      throw pathNotFound;
    }
    
    FileSystemException deleteFailed =
        new FileSystemException(
            path.toString(),
            null,
            ""failed to delete one or more files; see suppressed exceptions for details"");
    for (IOException e : exceptions) {
      deleteFailed.addSuppressed(e);
    }
    throw deleteFailed;
  }
",iterator
t_board,"
private void filterVisibilityOfSubsequentBoardMenus(List<JMenu> boardsCustomMenus, TargetBoard board,
                                                      int fromIndex) {
    for (int i = fromIndex; i < boardsCustomMenus.size(); i++) {
      JMenu menu = boardsCustomMenus.get(i);
      for (int m = 0; m < menu.getItemCount(); m++) {
        JMenuItem menuItem = menu.getItem(m);
        for (TargetBoard t_board : (List<TargetBoard>)menuItem.getAction().getValue(""board"")) {
          menuItem.setVisible(t_board.equals(board));
        }
      }
      menu.setVisible(ifThereAreVisibleItemsOn(menu));

      if (menu.isVisible()) {
        JMenuItem visibleSelectedOrFirstMenuItem = selectVisibleSelectedOrFirstMenuItem(menu);
        if (!visibleSelectedOrFirstMenuItem.isSelected()) {
          visibleSelectedOrFirstMenuItem.setSelected(true);
          visibleSelectedOrFirstMenuItem.getAction().actionPerformed(null);
        }
      }
    }
  }
",iterator
prop,"
public boolean matchesBoard(TargetBoard board) {
    PreferencesMap identificationProps = getIdentificationPrefs();
    PreferencesMap boardProps = board.getPreferences();

    String wildMatcher = identificationProps.get(""."");
    if (wildMatcher != null) {
      if (wildMatcher.equals(board.getId())) {
        return true;
      }
      if (wildMatcher.equals(board.getFQBN())) {
        return true;
      }
    }

    for (int suffix = 0;; suffix++) {
      boolean found = true;
      for (String prop : identificationProps.keySet()) {
        String value = identificationProps.get(prop);
        prop += ""."" + suffix;
        if (!boardProps.containsKey(prop)) {
          return false;
        }
        if (!value.equalsIgnoreCase(boardProps.get(prop))) {
          found = false;
          break;
        }
      }
      if (found) {
        return true;
      }
    }
}
",iterator
board,"
public synchronized void forceRefresh() {
    Platform platform = BaseNoGui.getPlatform();
    if (platform == null) {
      return;
    }

    List<String> ports = platform.listSerials();
    if (ports.equals(oldPorts)) {
      return;
    }

    oldPorts.clear();
    oldPorts.addAll(ports);

    for (BoardPort board : boardPorts) {
      if (!ports.contains(board.toCompleteString())) {
        board.setOnlineStatus(false);
      }
    }

    for (String newPort : ports) {

      BoardPort oldBoardPort = boardPorts.stream() //
          .filter(bp -> bp.toCompleteString().equalsIgnoreCase(newPort)) //
          .findAny().orElse(null);
      if (oldBoardPort != null) {
        oldBoardPort.setOnlineStatus(true);
        continue;
      }

      String[] parts = newPort.split(""_"");
      if (parts.length < 3) {
        continue;
      }
      if (parts.length > 3) {
        for (int i = 1; i < (parts.length-2); i++) {
          parts[0] += ""_"" + parts[i];
        }
        parts[1] = parts[parts.length-2];
        parts[2] = parts[parts.length-1];
      }
    }
      setSerialBoardPorts(boardPorts);
}
",iterator
newPort,"
public synchronized void forceRefresh() {
    Platform platform = BaseNoGui.getPlatform();
    if (platform == null) {
      return;
    }

    List<String> ports = platform.listSerials();
    if (ports.equals(oldPorts)) {
      return;
    }

    oldPorts.clear();
    oldPorts.addAll(ports);

    for (BoardPort board : boardPorts) {
      if (!ports.contains(board.toCompleteString())) {
        board.setOnlineStatus(false);
      }
    }

    for (String newPort : ports) {

      BoardPort oldBoardPort = boardPorts.stream() //
          .filter(bp -> bp.toCompleteString().equalsIgnoreCase(newPort)) //
          .findAny().orElse(null);
      if (oldBoardPort != null) {
        oldBoardPort.setOnlineStatus(true);
        continue;
      }

      String[] parts = newPort.split(""_"");
      if (parts.length < 3) {
        continue;
      }
      if (parts.length > 3) {
        for (int i = 1; i < (parts.length-2); i++) {
          parts[0] += ""_"" + parts[i];
        }
        parts[1] = parts[parts.length-2];
        parts[2] = parts[parts.length-1];
      }
    }
      setSerialBoardPorts(boardPorts);
}
",iterator
param,"
private void testEqualsUsing(final Invokable<?, ?> factory)
      throws ParameterNotInstantiableException, ParameterHasNoDistinctValueException,
          IllegalAccessException, InvocationTargetException, FactoryMethodReturnsNullException {
    List<Parameter> params = factory.getParameters();
    List<FreshValueGenerator> argGenerators = Lists.newArrayListWithCapacity(params.size());
    List<Object> args = Lists.newArrayListWithCapacity(params.size());
    for (Parameter param : params) {
      FreshValueGenerator generator = newFreshValueGenerator();
      argGenerators.add(generator);
      args.add(generateDummyArg(param, generator));
    }
    Object instance = createInstance(factory, args);
    List<Object> equalArgs = generateEqualFactoryArguments(factory, params, args);
    // Each group is a List of items, each item has a list of factory args.
    final List<List<List<Object>>> argGroups = Lists.newArrayList();
    argGroups.add(ImmutableList.of(args, equalArgs));
    EqualsTester tester =
        new EqualsTester(
            new ItemReporter() {
              @Override
              String reportItem(Item<?> item) {
                List<Object> factoryArgs = argGroups.get(item.groupNumber).get(item.itemNumber);
                return factory.getName()
                    + ""(""
                    + Joiner.on("", "").useForNull(""null"").join(factoryArgs)
                    + "")"";
              }
            });
    tester.addEqualityGroup(instance, createInstance(factory, equalArgs));
    for (int i = 0; i < params.size(); i++) {
      List<Object> newArgs = Lists.newArrayList(args);
      Object newArg = argGenerators.get(i).generateFresh(params.get(i).getType());

      if (newArg == null || Objects.equal(args.get(i), newArg)) {
        if (params.get(i).getType().getRawType().isEnum()) {
          continue; // Nothing better we can do if it's single-value enum
        }
        throw new ParameterHasNoDistinctValueException(params.get(i));
      }
      newArgs.set(i, newArg);
      tester.addEqualityGroup(createInstance(factory, newArgs));
      argGroups.add(ImmutableList.of(newArgs));
    }
    tester.testEquals();
    }
",loop_control
