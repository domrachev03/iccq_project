Name,Code,Category
i,"for (int i = 0; i < 15; i++) {
            hotelRooms.add(new HostelRoom(new StandardRoom(i + 1, 2, RoomType.ECONOMY)));
        }",loop_control
i,"for (int i = 0; i < 15; i++) {
            hotelRooms.add(new ExpandableRoom(new StandardRoom(i + 16, 3, RoomType.LUX)));
        }",loop_control
i,"for (int i = 0; i < hotel.getStaff().size(); i++) {
            System.out.println(hotel.getStaff().get(i).getPersonalInformation().getName());
        }",loop_control
updatedW,"for (Staff updatedW : updatedStaff) {
                if (updatedW.getPersonalInformation().getId() == w.getPersonalInformation().getId()) {
                    return updatedW;
                }
            }",iterator
deletedW,"for (Staff deletedW : deletedStaff) {
                if (deletedW.getPersonalInformation().getId() == w.getPersonalInformation().getId()) {
                    return false;
                }
            }",iterator
currentStaff,"for (Staff currentStaff : staff) {
                if (currentStaff.getPersonalInformation().getId() == w.getPersonalInformation().getId()) {
                    return false;
                }
            }",iterator
updatedW,"for (Room updatedW : updatedRooms) {
                if (updatedW.getNumber() == w.getNumber()) {
                    return updatedW;
                }
            }",iterator
deletedW,"for (Room deletedW : deletedRooms) {
                if (deletedW.getNumber() == w.getNumber()) {
                    return false;
                }
            }",iterator
i,"for (int i = 0; i < access.getRooms().size(); i++) {
            currentRoom = access.getRooms().get(i);
            if (currentRoom.isOccupied()) {
                continue;
            }
            if (currentRoom.getSize() < peopleCount) {
                continue;
            }
            if (currentRoom.getType() != type) {
                continue;
            }
            currentRoom.checkIn(client, peopleCount);
            break;
        }",loop_control
i,"for (int i = 0; i < size; i++) {
                observables.add(Flowable.just(i));
            }",loop_control
i,"for (int i = 0; i < 1000; i++) {
            unbounded.onNext(1);
        }",loop_control
i,"for (int i = 0; i < 1000000; i++) {
            unbounded.onNext(1);
        }",loop_control
i,"for (int i = 0; i < 1000; i++) {
            bounded.onNext(1);
        }",loop_control
i,"for (int i = 0; i < 1000000; i++) {
            bounded.onNext(1);
        }",loop_control
i,"for (int i = 0; i < 1000; i++) {
            subject.onNext(1);
        }",loop_control
i,"for (int i = 0; i < 1000000; i++) {
            subject.onNext(1);
        }",loop_control
j,"for (int j = 0; j < 15; j++) {
            for (int i = 0; i < 600; i++) {
                o = p.flowable();
            }
            System.out.println(""--- "" + j);
        }",loop_control
i,"for (int i = 0; i < 600; i++) {
                o = p.flowable();
            }",loop_control
items,"{
                int c = count;
                while (items < c) { }
                return 1;
            }",loop_control
items,"{
                int c = count;
                while (items < c) { }
                return 1;
            }",loop_control
c,"{
                int c = count;
                while (items < c) { }
                return 1;
            }",loop_control
c,"{
                int c = count;
                while (items < c) { }
                return 1;
            }",loop_control
i,"for (int i = 0; i < size; i++) {
                s.onNext(i);
            }",loop_control
i,"for (int i = 0; i < TestHelper.RACE_DEFAULT_LOOPS; i++) {
            final FutureSubscriber<Integer> fs = new FutureSubscriber<>();

            Runnable r = new Runnable() {
                @Override
                public void run() {
                    fs.cancel(false);
                }
            };

            TestHelper.race(r, r);
        }",loop_control
i,"for (int i = 0; i < TestHelper.RACE_DEFAULT_LOOPS; i++) {
            final FutureSubscriber<Integer> fs = new FutureSubscriber<>();

            final TestException ex = new TestException();

            Runnable r1 = new Runnable() {
                @Override
                public void run() {
                    fs.cancel(false);
                }
            };

            Runnable r2 = new Runnable() {
                @Override
                public void run() {
                    fs.onError(ex);
                }
            };

            TestHelper.race(r1, r2);
        }",loop_control
i,"for (int i = 0; i < TestHelper.RACE_DEFAULT_LOOPS; i++) {
            final FutureSubscriber<Integer> fs = new FutureSubscriber<>();

            if (i % 3 == 0) {
                fs.onSubscribe(new BooleanSubscription());
            }

            if (i % 2 == 0) {
                fs.onNext(1);
            }

            Runnable r1 = new Runnable() {
                @Override
                public void run() {
                    fs.cancel(false);
                }
            };

            Runnable r2 = new Runnable() {
                @Override
                public void run() {
                    fs.onComplete();
                }
            };

            TestHelper.race(r1, r2);
        }",loop_control
i,"for (int i = 0; i < 10000; i++) {

                final TestSubscriber<Integer> ts = TestSubscriber.create(0L);
                TestingDeferredScalarSubscriber ds = new TestingDeferredScalarSubscriber(ts);
                ds.setupDownstream();
                ds.onNext(1);

                final AtomicInteger ready = new AtomicInteger(2);

                w.schedule(new Runnable() {
                    @Override
                    public void run() {
                        ready.decrementAndGet();
                        while (ready.get() != 0) { }

                        ts.request(1);
                    }
                });

                ready.decrementAndGet();
                while (ready.get() != 0) { }

                ds.onComplete();

                ts.awaitDone(5, TimeUnit.SECONDS);
                ts.assertValues(1);
                ts.assertNoErrors();
                ts.assertComplete();

            }",loop_control
i,"for (int i = 0; i < m; i++) {

                final TestSubscriber<Integer> ts = TestSubscriber.create(0L);
                TestingDeferredScalarSubscriber ds = new TestingDeferredScalarSubscriber(ts);
                ds.setupDownstream();
                ds.onNext(1);

                final AtomicInteger ready = new AtomicInteger(3);

                w.schedule(new Runnable() {
                    @Override
                    public void run() {
                        ready.decrementAndGet();
                        while (ready.get() != 0) { }

                        ts.request(1);
                    }
                });

                w2.schedule(new Runnable() {
                    @Override
                    public void run() {
                        ready.decrementAndGet();
                        while (ready.get() != 0) { }

                        ts.request(1);
                    }
                });

                ready.decrementAndGet();
                while (ready.get() != 0) { }

                ds.onComplete();

                ts.awaitDone(5, TimeUnit.SECONDS);
                ts.assertValues(1);
                ts.assertNoErrors();
                ts.assertComplete();

            }",loop_control
i,"for (int i = 0; i < TestHelper.RACE_LONG_LOOPS; i++) {

            TestSubscriber<Integer> ts = new TestSubscriber<>(1);
            Disposable d = Disposable.empty();
            final QueueDrainSubscriber<Integer, Integer, Integer> qd = createUnordered(ts, d);
            ts.onSubscribe(new BooleanSubscription());

            qd.requested(Long.MAX_VALUE);
            Runnable r1 = new Runnable() {
                @Override
                public void run() {
                    qd.onNext(1);
                }
            };

            TestHelper.race(r1, r1);

            ts.assertValuesOnly(1, 1);
        }",loop_control
i,"for (int i = 0; i < TestHelper.RACE_LONG_LOOPS; i++) {

            TestSubscriber<Integer> ts = new TestSubscriber<>(1);
            Disposable d = Disposable.empty();
            final QueueDrainSubscriber<Integer, Integer, Integer> qd = createOrdered(ts, d);
            ts.onSubscribe(new BooleanSubscription());

            qd.requested(Long.MAX_VALUE);
            Runnable r1 = new Runnable() {
                @Override
                public void run() {
                    qd.onNext(1);
                }
            };

            TestHelper.race(r1, r1);

            ts.assertValuesOnly(1, 1);
        }",loop_control
i,"for (int i = 0; i < TestHelper.RACE_DEFAULT_LOOPS; i++) {
            final TestSubscriber<Integer> ts = new TestSubscriber<>(0L);

            final SinglePostCompleteSubscriber<Integer, Integer> spc = new SinglePostCompleteSubscriber<Integer, Integer>(ts) {
                private static final long serialVersionUID = -2848918821531562637L;

                @Override
                public void onNext(Integer t) {
                }

                @Override
                public void onError(Throwable t) {
                }

                @Override
                public void onComplete() {
                    complete(1);
                }
            };

            spc.onSubscribe(new BooleanSubscription());

            Runnable r1 = new Runnable() {
                @Override
                public void run() {
                    spc.onComplete();
                }
            };

            Runnable r2 = new Runnable() {
                @Override
                public void run() {
                    ts.request(1);
                }
            };

            TestHelper.race(r1, r2);

            ts.assertResult(1);
        }",loop_control
i,"for (int i = 0; i < TestHelper.RACE_LONG_LOOPS; i++) {
            List<Throwable> errors = TestHelper.trackPluginErrors();
            try {
                final PublishProcessor<Integer> pp = PublishProcessor.create();
                final CompletableSubject cs = CompletableSubject.create();

                TestObserver<Void> to = pp.concatMapCompletable(
                        Functions.justFunction(cs)
                )
                .test();

                pp.onNext(1);

                Runnable r1 = new Runnable() {
                    @Override
                    public void run() {
                        pp.onError(ex);
                    }
                };

                Runnable r2 = new Runnable() {
                    @Override
                    public void run() {
                        cs.onError(ex);
                    }
                };

                TestHelper.race(r1, r2);

                to.assertError(new Predicate<Throwable>() {
                    @Override
                    public boolean test(Throwable e) throws Exception {
                        return e instanceof TestException || e instanceof CompositeException;
                    }
                })
                .assertNotComplete();

                if (!errors.isEmpty()) {
                    TestHelper.assertUndeliverable(errors, 0, TestException.class);
                }
            } finally {
                RxJavaPlugins.reset();
            }
        }",loop_control
i,"for (int i = 0; i < TestHelper.RACE_LONG_LOOPS; i++) {
            final PublishProcessor<Integer> pp = PublishProcessor.create();
            final CompletableSubject cs = CompletableSubject.create();

            final TestObserver<Void> to = pp.concatMapCompletable(
                    Functions.justFunction(cs)
            )
            .test();

            pp.onNext(1);

            Runnable r1 = new Runnable() {
                @Override
                public void run() {
                    pp.onNext(2);
                }
            };

            Runnable r2 = new Runnable() {
                @Override
                public void run() {
                    cs.onComplete();
                    to.dispose();
                }
            };

            TestHelper.race(r1, r2);

            to.assertEmpty();
        }",loop_control
i,"for (int i = 0; i < TestHelper.RACE_LONG_LOOPS; i++) {
            List<Throwable> errors = TestHelper.trackPluginErrors();
            try {
                final PublishSubject<Integer> ps = PublishSubject.create();
                final CompletableSubject cs = CompletableSubject.create();

                TestObserver<Void> to = ps.concatMapCompletable(
                        Functions.justFunction(cs)
                )
                .test();

                ps.onNext(1);

                Runnable r1 = new Runnable() {
                    @Override
                    public void run() {
                        ps.onError(ex);
                    }
                };

                Runnable r2 = new Runnable() {
                    @Override
                    public void run() {
                        cs.onError(ex);
                    }
                };

                TestHelper.race(r1, r2);

                to.assertError(new Predicate<Throwable>() {
                    @Override
                    public boolean test(Throwable e) throws Exception {
                        return e instanceof TestException || e instanceof CompositeException;
                    }
                })
                .assertNotComplete();

                if (!errors.isEmpty()) {
                    TestHelper.assertUndeliverable(errors, 0, TestException.class);
                }
            } finally {
                RxJavaPlugins.reset();
            }
        }",loop_control
i,"for (int i = 0; i < TestHelper.RACE_LONG_LOOPS; i++) {
            final PublishSubject<Integer> ps = PublishSubject.create();
            final CompletableSubject cs = CompletableSubject.create();

            final TestObserver<Void> to = ps.concatMapCompletable(
                    Functions.justFunction(cs)
            )
            .test();

            ps.onNext(1);

            Runnable r1 = new Runnable() {
                @Override
                public void run() {
                    ps.onNext(2);
                }
            };

            Runnable r2 = new Runnable() {
                @Override
                public void run() {
                    cs.onComplete();
                    to.dispose();
                }
            };

            TestHelper.race(r1, r2);

            to.assertEmpty();
        }",loop_control
i,"for (int i = 0; i < 512; i ++) {
            to.assertValueAt(i, (i + 1) * 2);
        }",loop_control
i,"for (int i = 0; i < TestHelper.RACE_LONG_LOOPS; i++) {

            final MaybeSubject<Integer> ms = MaybeSubject.create();

            final TestObserver<Integer> to = Observable.just(1)
                    .hide()
                    .concatMapMaybe(Functions.justFunction(ms))
                    .test();

            Runnable r1 = new Runnable() {
                @Override
                public void run() {
                    ms.onSuccess(1);
                }
            };
            Runnable r2 = new Runnable() {
                @Override
                public void run() {
                    to.dispose();
                }
            };

            TestHelper.race(r1, r2);

            to.assertNoErrors();
        }",loop_control
i,"for (int i = 0; i < TestHelper.RACE_LONG_LOOPS; i++) {

            final PublishSubject<Integer> ps = PublishSubject.create();

            final MaybeSubject<Integer> ms = MaybeSubject.create();

            final TestObserver<Integer> to = ps.switchMapMaybeDelayError(new Function<Integer, MaybeSource<Integer>>() {
                @Override
                public MaybeSource<Integer> apply(Integer v)
                        throws Exception {
                            return ms;
                        }
            }).test();

            Runnable r1 = new Runnable() {
                @Override
                public void run() {
                    ps.onNext(1);
                }
            };

            Runnable r2 = new Runnable() {
                @Override
                public void run() {
                    to.dispose();
                }
            };

            TestHelper.race(r1, r2);

            to.assertNoErrors()
            .assertNotComplete();
        }",loop_control
i,"for (int i = 0; i < TestHelper.RACE_LONG_LOOPS; i++) {

            List<Throwable> errors = TestHelper.trackPluginErrors();
            try {
                final PublishSubject<Integer> ps = PublishSubject.create();

                final MaybeSubject<Integer> ms = MaybeSubject.create();

                final TestObserverEx<Integer> to = ps.switchMapMaybeDelayError(new Function<Integer, MaybeSource<Integer>>() {
                    @Override
                    public MaybeSource<Integer> apply(Integer v)
                            throws Exception {
                        if (v == 1) {
                            return ms;
                        }
                        return Maybe.never();
                    }
                }).to(TestHelper.<Integer>testConsumer());

                ps.onNext(1);

                Runnable r1 = new Runnable() {
                    @Override
                    public void run() {
                        ps.onNext(2);
                    }
                };

                Runnable r2 = new Runnable() {
                    @Override
                    public void run() {
                        ms.onError(ex);
                    }
                };

                TestHelper.race(r1, r2);

                if (to.errors().size() != 0) {
                    assertTrue(errors.isEmpty());
                    to.assertFailure(TestException.class);
                } else if (!errors.isEmpty()) {
                    TestHelper.assertUndeliverable(errors, 0, TestException.class);
                }
            } finally {
                RxJavaPlugins.reset();
            }
        }",loop_control
i,"for (int i = 0; i < TestHelper.RACE_LONG_LOOPS; i++) {

            List<Throwable> errors = TestHelper.trackPluginErrors();
            try {
                final PublishSubject<Integer> ps = PublishSubject.create();

                final MaybeSubject<Integer> ms = MaybeSubject.create();

                final TestObserver<Integer> to = ps.switchMapMaybeDelayError(new Function<Integer, MaybeSource<Integer>>() {
                    @Override
                    public MaybeSource<Integer> apply(Integer v)
                            throws Exception {
                        if (v == 1) {
                            return ms;
                        }
                        return Maybe.never();
                    }
                }).test();

                ps.onNext(1);

                Runnable r1 = new Runnable() {
                    @Override
                    public void run() {
                        ps.onError(ex);
                    }
                };

                Runnable r2 = new Runnable() {
                    @Override
                    public void run() {
                        ms.onError(ex2);
                    }
                };

                TestHelper.race(r1, r2);

                to.assertError(new Predicate<Throwable>() {
                    @Override
                    public boolean test(Throwable e) throws Exception {
                        return e instanceof TestException || e instanceof CompositeException;
                    }
                });

                if (!errors.isEmpty()) {
                    TestHelper.assertUndeliverable(errors, 0, TestException.class);
                }
            } finally {
                RxJavaPlugins.reset();
            }
        }",loop_control
i,"for (int i = 0; i < TestHelper.RACE_LONG_LOOPS; i++) {

            final PublishSubject<Integer> ps = PublishSubject.create();

            final MaybeSubject<Integer> ms = MaybeSubject.create();

            final TestObserver<Integer> to = ps.switchMapMaybeDelayError(new Function<Integer, MaybeSource<Integer>>() {
                @Override
                public MaybeSource<Integer> apply(Integer v)
                        throws Exception {
                            return ms;
                        }
            }).test();

            Runnable r1 = new Runnable() {
                @Override
                public void run() {
                    ps.onNext(1);
                }
            };

            Runnable r2 = new Runnable() {
                @Override
                public void run() {
                    to.dispose();
                }
            };

            TestHelper.race(r1, r2);

            to.assertNoErrors()
            .assertNotComplete();
        }",loop_control
i,"for (int i = 0; i < TestHelper.RACE_LONG_LOOPS; i++) {

            List<Throwable> errors = TestHelper.trackPluginErrors();
            try {
                final PublishSubject<Integer> ps = PublishSubject.create();

                final MaybeSubject<Integer> ms = MaybeSubject.create();

                final TestObserverEx<Integer> to = ps.switchMapMaybeDelayError(new Function<Integer, MaybeSource<Integer>>() {
                    @Override
                    public MaybeSource<Integer> apply(Integer v)
                            throws Exception {
                        if (v == 1) {
                            return ms;
                        }
                        return Maybe.never();
                    }
                }).to(TestHelper.<Integer>testConsumer());

                ps.onNext(1);

                Runnable r1 = new Runnable() {
                    @Override
                    public void run() {
                        ps.onNext(2);
                    }
                };

                Runnable r2 = new Runnable() {
                    @Override
                    public void run() {
                        ms.onError(ex);
                    }
                };

                TestHelper.race(r1, r2);

                if (to.errors().size() != 0) {
                    assertTrue(errors.isEmpty());
                    to.assertFailure(TestException.class);
                } else if (!errors.isEmpty()) {
                    TestHelper.assertUndeliverable(errors, 0, TestException.class);
                }
            } finally {
                RxJavaPlugins.reset();
            }
        }",loop_control
i,"for (int i = 0; i < TestHelper.RACE_LONG_LOOPS; i++) {

            List<Throwable> errors = TestHelper.trackPluginErrors();
            try {
                final PublishSubject<Integer> ps = PublishSubject.create();

                final MaybeSubject<Integer> ms = MaybeSubject.create();

                final TestObserver<Integer> to = ps.switchMapMaybeDelayError(new Function<Integer, MaybeSource<Integer>>() {
                    @Override
                    public MaybeSource<Integer> apply(Integer v)
                            throws Exception {
                        if (v == 1) {
                            return ms;
                        }
                        return Maybe.never();
                    }
                }).test();

                ps.onNext(1);

                Runnable r1 = new Runnable() {
                    @Override
                    public void run() {
                        ps.onError(ex);
                    }
                };

                Runnable r2 = new Runnable() {
                    @Override
                    public void run() {
                        ms.onError(ex2);
                    }
                };

                TestHelper.race(r1, r2);

                to.assertError(new Predicate<Throwable>() {
                    @Override
                    public boolean test(Throwable e) throws Exception {
                        return e instanceof TestException || e instanceof CompositeException;
                    }
                });

                if (!errors.isEmpty()) {
                    TestHelper.assertUndeliverable(errors, 0, TestException.class);
                }
            } finally {
                RxJavaPlugins.reset();
            }
        }",loop_control
i,"for (int i = 0; i < TestHelper.RACE_LONG_LOOPS; i++) {

            final PublishSubject<Integer> ps = PublishSubject.create();

            final MaybeSubject<Integer> ms = MaybeSubject.create();

            final TestObserver<Integer> to = ps.switchMapMaybeDelayError(new Function<Integer, MaybeSource<Integer>>() {
                @Override
                public MaybeSource<Integer> apply(Integer v)
                        throws Exception {
                    if (v == 1) {
                            return ms;
                    }
                    return Maybe.empty();
                }
            }).test();

            ps.onNext(1);

            Runnable r1 = new Runnable() {
                @Override
                public void run() {
                    ps.onNext(2);
                }
            };

            Runnable r2 = new Runnable() {
                @Override
                public void run() {
                    ms.onSuccess(3);
                }
            };

            TestHelper.race(r1, r2);

            to.assertNoErrors()
            .assertNotComplete();
        }",loop_control
i,"for (int i = 0; i < TestHelper.RACE_LONG_LOOPS; i++) {

            final PublishProcessor<Integer> pp = PublishProcessor.create();

            final MaybeSubject<Integer> ms = MaybeSubject.create();

            final TestSubscriber<Integer> ts = pp.switchMapMaybeDelayError(new Function<Integer, MaybeSource<Integer>>() {
                @Override
                public MaybeSource<Integer> apply(Integer v)
                        throws Exception {
                            return ms;
                        }
            }).test();

            Runnable r1 = new Runnable() {
                @Override
                public void run() {
                    pp.onNext(1);
                }
            };

            Runnable r2 = new Runnable() {
                @Override
                public void run() {
                    ts.cancel();
                }
            };

            TestHelper.race(r1, r2);

            ts.assertNoErrors()
            .assertNotComplete();
        }",loop_control
i,"for (int i = 0; i < TestHelper.RACE_LONG_LOOPS; i++) {

            List<Throwable> errors = TestHelper.trackPluginErrors();
            try {
                final PublishProcessor<Integer> pp = PublishProcessor.create();

                final MaybeSubject<Integer> ms = MaybeSubject.create();

                final TestSubscriberEx<Integer> ts = pp.switchMapMaybeDelayError(new Function<Integer, MaybeSource<Integer>>() {
                    @Override
                    public MaybeSource<Integer> apply(Integer v)
                            throws Exception {
                        if (v == 1) {
                            return ms;
                        }
                        return Maybe.never();
                    }
                }).to(TestHelper.<Integer>testConsumer());

                pp.onNext(1);

                Runnable r1 = new Runnable() {
                    @Override
                    public void run() {
                        pp.onNext(2);
                    }
                };

                Runnable r2 = new Runnable() {
                    @Override
                    public void run() {
                        ms.onError(ex);
                    }
                };

                TestHelper.race(r1, r2);

                if (ts.errors().size() != 0) {
                    assertTrue(errors.isEmpty());
                    ts.assertFailure(TestException.class);
                } else if (!errors.isEmpty()) {
                    TestHelper.assertUndeliverable(errors, 0, TestException.class);
                }
            } finally {
                RxJavaPlugins.reset();
            }
        }",loop_control
i,"for (int i = 0; i < TestHelper.RACE_LONG_LOOPS; i++) {

            List<Throwable> errors = TestHelper.trackPluginErrors();
            try {
                final PublishProcessor<Integer> pp = PublishProcessor.create();

                final MaybeSubject<Integer> ms = MaybeSubject.create();

                final TestSubscriber<Integer> ts = pp.switchMapMaybeDelayError(new Function<Integer, MaybeSource<Integer>>() {
                    @Override
                    public MaybeSource<Integer> apply(Integer v)
                            throws Exception {
                        if (v == 1) {
                            return ms;
                        }
                        return Maybe.never();
                    }
                }).test();

                pp.onNext(1);

                Runnable r1 = new Runnable() {
                    @Override
                    public void run() {
                        pp.onError(ex);
                    }
                };

                Runnable r2 = new Runnable() {
                    @Override
                    public void run() {
                        ms.onError(ex2);
                    }
                };

                TestHelper.race(r1, r2);

                ts.assertError(new Predicate<Throwable>() {
                    @Override
                    public boolean test(Throwable e) throws Exception {
                        return e instanceof TestException || e instanceof CompositeException;
                    }
                });

                if (!errors.isEmpty()) {
                    TestHelper.assertUndeliverable(errors, 0, TestException.class);
                }
            } finally {
                RxJavaPlugins.reset();
            }
        }",loop_control
i,"for (int i = 0; i < TestHelper.RACE_LONG_LOOPS; i++) {

            final PublishProcessor<Integer> pp = PublishProcessor.create();

            final MaybeSubject<Integer> ms = MaybeSubject.create();

            final TestSubscriber<Integer> ts = pp.switchMapMaybeDelayError(new Function<Integer, MaybeSource<Integer>>() {
                @Override
                public MaybeSource<Integer> apply(Integer v)
                        throws Exception {
                    if (v == 1) {
                            return ms;
                    }
                    return Maybe.empty();
                }
            }).test();

            pp.onNext(1);

            Runnable r1 = new Runnable() {
                @Override
                public void run() {
                    pp.onNext(2);
                }
            };

            Runnable r2 = new Runnable() {
                @Override
                public void run() {
                    ms.onSuccess(3);
                }
            };

            TestHelper.race(r1, r2);

            ts.assertNoErrors()
            .assertNotComplete();
        }",loop_control
i,"for (int i = 1; i <= 1024; i++) {
            ts.assertValueCount(i - 1)
            .assertNoErrors()
            .assertNotComplete()
            .requestMore(1)
            .assertValueCount(i)
            .assertNoErrors();
        }",loop_control
i,"for (int i = 0; i < TestHelper.RACE_LONG_LOOPS; i++) {

            final SingleSubject<Integer> ss = SingleSubject.create();

            final TestSubscriber<Integer> ts = Flowable.just(1)
                    .hide()
                    .concatMapSingle(Functions.justFunction(ss))
                    .test();

            Runnable r1 = new Runnable() {
                @Override
                public void run() {
                    ss.onSuccess(1);
                }
            };
            Runnable r2 = new Runnable() {
                @Override
                public void run() {
                    ts.cancel();
                }
            };

            TestHelper.race(r1, r2);

            ts.assertNoErrors();
        }",loop_control
i,"for (int i = 0; i < TestHelper.RACE_LONG_LOOPS; i++) {

            final PublishProcessor<Integer> pp = PublishProcessor.create();

            final SingleSubject<Integer> ms = SingleSubject.create();

            final TestSubscriber<Integer> ts = pp.switchMapSingleDelayError(new Function<Integer, SingleSource<Integer>>() {
                @Override
                public SingleSource<Integer> apply(Integer v)
                        throws Exception {
                            return ms;
                        }
            }).test();

            Runnable r1 = new Runnable() {
                @Override
                public void run() {
                    pp.onNext(1);
                }
            };

            Runnable r2 = new Runnable() {
                @Override
                public void run() {
                    ts.cancel();
                }
            };

            TestHelper.race(r1, r2);

            ts.assertNoErrors()
            .assertNotComplete();
        }",loop_control
i,"for (int i = 0; i < TestHelper.RACE_LONG_LOOPS; i++) {

            List<Throwable> errors = TestHelper.trackPluginErrors();
            try {
                final PublishProcessor<Integer> pp = PublishProcessor.create();

                final SingleSubject<Integer> ms = SingleSubject.create();

                final TestSubscriberEx<Integer> ts = pp.switchMapSingleDelayError(new Function<Integer, SingleSource<Integer>>() {
                    @Override
                    public SingleSource<Integer> apply(Integer v)
                            throws Exception {
                        if (v == 1) {
                            return ms;
                        }
                        return Single.never();
                    }
                }).to(TestHelper.<Integer>testConsumer());

                pp.onNext(1);

                Runnable r1 = new Runnable() {
                    @Override
                    public void run() {
                        pp.onNext(2);
                    }
                };

                Runnable r2 = new Runnable() {
                    @Override
                    public void run() {
                        ms.onError(ex);
                    }
                };

                TestHelper.race(r1, r2);

                if (ts.errors().size() != 0) {
                    assertTrue(errors.isEmpty());
                    ts.assertFailure(TestException.class);
                } else if (!errors.isEmpty()) {
                    TestHelper.assertUndeliverable(errors, 0, TestException.class);
                }
            } finally {
                RxJavaPlugins.reset();
            }
        }",loop_control
i,"for (int i = 0; i < TestHelper.RACE_LONG_LOOPS; i++) {

            List<Throwable> errors = TestHelper.trackPluginErrors();
            try {
                final PublishProcessor<Integer> pp = PublishProcessor.create();

                final SingleSubject<Integer> ms = SingleSubject.create();

                final TestSubscriber<Integer> ts = pp.switchMapSingleDelayError(new Function<Integer, SingleSource<Integer>>() {
                    @Override
                    public SingleSource<Integer> apply(Integer v)
                            throws Exception {
                        if (v == 1) {
                            return ms;
                        }
                        return Single.never();
                    }
                }).test();

                pp.onNext(1);

                Runnable r1 = new Runnable() {
                    @Override
                    public void run() {
                        pp.onError(ex);
                    }
                };

                Runnable r2 = new Runnable() {
                    @Override
                    public void run() {
                        ms.onError(ex2);
                    }
                };

                TestHelper.race(r1, r2);

                ts.assertError(new Predicate<Throwable>() {
                    @Override
                    public boolean test(Throwable e) throws Exception {
                        return e instanceof TestException || e instanceof CompositeException;
                    }
                });

                if (!errors.isEmpty()) {
                    TestHelper.assertUndeliverable(errors, 0, TestException.class);
                }
            } finally {
                RxJavaPlugins.reset();
            }
        }",loop_control
i,"for (int i = 0; i < TestHelper.RACE_LONG_LOOPS; i++) {

            final PublishProcessor<Integer> pp = PublishProcessor.create();

            final SingleSubject<Integer> ms = SingleSubject.create();

            final TestSubscriber<Integer> ts = pp.switchMapSingleDelayError(new Function<Integer, SingleSource<Integer>>() {
                @Override
                public SingleSource<Integer> apply(Integer v)
                        throws Exception {
                    if (v == 1) {
                            return ms;
                    }
                    return Single.never();
                }
            }).test();

            pp.onNext(1);

            Runnable r1 = new Runnable() {
                @Override
                public void run() {
                    pp.onNext(2);
                }
            };

            Runnable r2 = new Runnable() {
                @Override
                public void run() {
                    ms.onSuccess(3);
                }
            };

            TestHelper.race(r1, r2);

            ts.assertNoErrors()
            .assertNotComplete();
        }",loop_control
i,"for (int i = 0; i < TestHelper.RACE_LONG_LOOPS; i++) {
            final PublishSubject<Integer> ps = PublishSubject.create();
            final CompletableSubject cs = CompletableSubject.create();

            TestObserver<Void> to = ps.switchMapCompletable(Functions.justFunction(cs)).test();

            ps.onNext(1);

            Runnable r1 = new Runnable() {
                @Override
                public void run() {
                    ps.onNext(2);
                }
            };

            Runnable r2 = new Runnable() {
                @Override
                public void run() {
                    cs.onComplete();
                }
            };

            TestHelper.race(r1, r2);

            to.assertEmpty();
        }",loop_control
i,"for (int i = 0; i < TestHelper.RACE_LONG_LOOPS; i++) {
            List<Throwable> errors = TestHelper.trackPluginErrors();
            try {
                final PublishSubject<Integer> ps = PublishSubject.create();
                final CompletableSubject cs = CompletableSubject.create();

                TestObserver<Void> to = ps.switchMapCompletable(Functions.justFunction(cs)).test();

                ps.onNext(1);

                Runnable r1 = new Runnable() {
                    @Override
                    public void run() {
                        ps.onNext(2);
                    }
                };

                Runnable r2 = new Runnable() {
                    @Override
                    public void run() {
                        cs.onError(ex);
                    }
                };

                TestHelper.race(r1, r2);

                to.assertError(new Predicate<Throwable>() {
                    @Override
                    public boolean test(Throwable e) throws Exception {
                        return e instanceof TestException || e instanceof CompositeException;
                    }
                });

                if (!errors.isEmpty()) {
                    TestHelper.assertUndeliverable(errors, 0, TestException.class);
                }
            } finally {
                RxJavaPlugins.reset();
            }
        }",loop_control
i,"for (int i = 0; i < TestHelper.RACE_LONG_LOOPS; i++) {
            List<Throwable> errors = TestHelper.trackPluginErrors();
            try {
                final PublishSubject<Integer> ps = PublishSubject.create();
                final CompletableSubject cs = CompletableSubject.create();

                TestObserver<Void> to = ps.switchMapCompletable(Functions.justFunction(cs)).test();

                ps.onNext(1);

                Runnable r1 = new Runnable() {
                    @Override
                    public void run() {
                        ps.onError(ex0);
                    }
                };

                Runnable r2 = new Runnable() {
                    @Override
                    public void run() {
                        cs.onError(ex);
                    }
                };

                TestHelper.race(r1, r2);

                to.assertError(new Predicate<Throwable>() {
                    @Override
                    public boolean test(Throwable e) throws Exception {
                        return e instanceof TestException || e instanceof CompositeException;
                    }
                });

                if (!errors.isEmpty()) {
                    TestHelper.assertUndeliverable(errors, 0, TestException.class);
                }
            } finally {
                RxJavaPlugins.reset();
            }
        }",loop_control
i,"for (int i = 0; i < TestHelper.RACE_LONG_LOOPS; i++) {

            final PublishSubject<Integer> ps = PublishSubject.create();

            final SingleSubject<Integer> ms = SingleSubject.create();

            final TestObserver<Integer> to = ps.switchMapSingleDelayError(new Function<Integer, SingleSource<Integer>>() {
                @Override
                public SingleSource<Integer> apply(Integer v)
                        throws Exception {
                            return ms;
                        }
            }).test();

            Runnable r1 = new Runnable() {
                @Override
                public void run() {
                    ps.onNext(1);
                }
            };

            Runnable r2 = new Runnable() {
                @Override
                public void run() {
                    to.dispose();
                }
            };

            TestHelper.race(r1, r2);

            to.assertNoErrors()
            .assertNotComplete();
        }",loop_control
i,"for (int i = 0; i < TestHelper.RACE_LONG_LOOPS; i++) {

            List<Throwable> errors = TestHelper.trackPluginErrors();
            try {
                final PublishSubject<Integer> ps = PublishSubject.create();

                final SingleSubject<Integer> ms = SingleSubject.create();

                final TestObserverEx<Integer> to = ps.switchMapSingleDelayError(new Function<Integer, SingleSource<Integer>>() {
                    @Override
                    public SingleSource<Integer> apply(Integer v)
                            throws Exception {
                        if (v == 1) {
                            return ms;
                        }
                        return Single.never();
                    }
                }).to(TestHelper.<Integer>testConsumer());

                ps.onNext(1);

                Runnable r1 = new Runnable() {
                    @Override
                    public void run() {
                        ps.onNext(2);
                    }
                };

                Runnable r2 = new Runnable() {
                    @Override
                    public void run() {
                        ms.onError(ex);
                    }
                };

                TestHelper.race(r1, r2);

                if (to.errors().size() != 0) {
                    assertTrue(errors.isEmpty());
                    to.assertFailure(TestException.class);
                } else if (!errors.isEmpty()) {
                    TestHelper.assertUndeliverable(errors, 0, TestException.class);
                }
            } finally {
                RxJavaPlugins.reset();
            }
        }",loop_control
i,"for (int i = 0; i < TestHelper.RACE_LONG_LOOPS; i++) {

            List<Throwable> errors = TestHelper.trackPluginErrors();
            try {
                final PublishSubject<Integer> ps = PublishSubject.create();

                final SingleSubject<Integer> ms = SingleSubject.create();

                final TestObserver<Integer> to = ps.switchMapSingleDelayError(new Function<Integer, SingleSource<Integer>>() {
                    @Override
                    public SingleSource<Integer> apply(Integer v)
                            throws Exception {
                        if (v == 1) {
                            return ms;
                        }
                        return Single.never();
                    }
                }).test();

                ps.onNext(1);

                Runnable r1 = new Runnable() {
                    @Override
                    public void run() {
                        ps.onError(ex);
                    }
                };

                Runnable r2 = new Runnable() {
                    @Override
                    public void run() {
                        ms.onError(ex2);
                    }
                };

                TestHelper.race(r1, r2);

                to.assertError(new Predicate<Throwable>() {
                    @Override
                    public boolean test(Throwable e) throws Exception {
                        return e instanceof TestException || e instanceof CompositeException;
                    }
                });

                if (!errors.isEmpty()) {
                    TestHelper.assertUndeliverable(errors, 0, TestException.class);
                }
            } finally {
                RxJavaPlugins.reset();
            }
        }",loop_control
i,"for (int i = 0; i < TestHelper.RACE_LONG_LOOPS; i++) {

            final PublishSubject<Integer> ps = PublishSubject.create();

            final SingleSubject<Integer> ms = SingleSubject.create();

            final TestObserver<Integer> to = ps.switchMapSingleDelayError(new Function<Integer, SingleSource<Integer>>() {
                @Override
                public SingleSource<Integer> apply(Integer v)
                        throws Exception {
                    if (v == 1) {
                            return ms;
                    }
                    return Single.never();
                }
            }).test();

            ps.onNext(1);

            Runnable r1 = new Runnable() {
                @Override
                public void run() {
                    ps.onNext(2);
                }
            };

            Runnable r2 = new Runnable() {
                @Override
                public void run() {
                    ms.onSuccess(3);
                }
            };

            TestHelper.race(r1, r2);

            to.assertNoErrors()
            .assertNotComplete();
        }",loop_control
i,"for (int i = 0; i < TestHelper.RACE_LONG_LOOPS; i++) {

            final SingleSubject<Integer> ss = SingleSubject.create();

            final TestObserver<Integer> to = Observable.just(1)
                    .hide()
                    .concatMapSingle(Functions.justFunction(ss))
                    .test();

            Runnable r1 = new Runnable() {
                @Override
                public void run() {
                    ss.onSuccess(1);
                }
            };
            Runnable r2 = new Runnable() {
                @Override
                public void run() {
                    to.dispose();
                }
            };

            TestHelper.race(r1, r2);

            to.assertNoErrors();
        }",loop_control
i,"for (int i = 0; i < TestHelper.RACE_LONG_LOOPS; i++) {
            final PublishProcessor<Integer> pp = PublishProcessor.create();
            final CompletableSubject cs = CompletableSubject.create();

            TestObserver<Void> to = pp.switchMapCompletable(Functions.justFunction(cs)).test();

            pp.onNext(1);

            Runnable r1 = new Runnable() {
                @Override
                public void run() {
                    pp.onNext(2);
                }
            };

            Runnable r2 = new Runnable() {
                @Override
                public void run() {
                    cs.onComplete();
                }
            };

            TestHelper.race(r1, r2);

            to.assertEmpty();
        }",loop_control
i,"for (int i = 0; i < TestHelper.RACE_LONG_LOOPS; i++) {
            List<Throwable> errors = TestHelper.trackPluginErrors();
            try {
                final PublishProcessor<Integer> pp = PublishProcessor.create();
                final CompletableSubject cs = CompletableSubject.create();

                TestObserver<Void> to = pp.switchMapCompletable(Functions.justFunction(cs)).test();

                pp.onNext(1);

                Runnable r1 = new Runnable() {
                    @Override
                    public void run() {
                        pp.onNext(2);
                    }
                };

                Runnable r2 = new Runnable() {
                    @Override
                    public void run() {
                        cs.onError(ex);
                    }
                };

                TestHelper.race(r1, r2);

                to.assertError(new Predicate<Throwable>() {
                    @Override
                    public boolean test(Throwable e) throws Exception {
                        return e instanceof TestException || e instanceof CompositeException;
                    }
                });

                if (!errors.isEmpty()) {
                    TestHelper.assertUndeliverable(errors, 0, TestException.class);
                }
            } finally {
                RxJavaPlugins.reset();
            }
        }",loop_control
i,"for (int i = 0; i < TestHelper.RACE_LONG_LOOPS; i++) {
            List<Throwable> errors = TestHelper.trackPluginErrors();
            try {
                final PublishProcessor<Integer> pp = PublishProcessor.create();
                final CompletableSubject cs = CompletableSubject.create();

                TestObserver<Void> to = pp.switchMapCompletable(Functions.justFunction(cs)).test();

                pp.onNext(1);

                Runnable r1 = new Runnable() {
                    @Override
                    public void run() {
                        pp.onError(ex0);
                    }
                };

                Runnable r2 = new Runnable() {
                    @Override
                    public void run() {
                        cs.onError(ex);
                    }
                };

                TestHelper.race(r1, r2);

                to.assertError(new Predicate<Throwable>() {
                    @Override
                    public boolean test(Throwable e) throws Exception {
                        return e instanceof TestException || e instanceof CompositeException;
                    }
                });

                if (!errors.isEmpty()) {
                    TestHelper.assertUndeliverable(errors, 0, TestException.class);
                }
            } finally {
                RxJavaPlugins.reset();
            }
        }",loop_control
i,"for (int i = 1; i <= 1024; i++) {
            ts.assertValueCount(i - 1)
            .assertNoErrors()
            .assertNotComplete()
            .requestMore(1)
            .assertValueCount(i)
            .assertNoErrors();
        }",loop_control
i,"for (int i = 0; i < 512; i ++) {
            ts.assertValueAt(i, (i + 1) * 2);
        }",loop_control
i,"for (int i = 0; i < TestHelper.RACE_LONG_LOOPS; i++) {

            final MaybeSubject<Integer> ms = MaybeSubject.create();

            final TestSubscriber<Integer> ts = Flowable.just(1)
                    .hide()
                    .concatMapMaybe(Functions.justFunction(ms))
                    .test();

            Runnable r1 = new Runnable() {
                @Override
                public void run() {
                    ms.onSuccess(1);
                }
            };
            Runnable r2 = new Runnable() {
                @Override
                public void run() {
                    ts.cancel();
                }
            };

            TestHelper.race(r1, r2);

            ts.assertNoErrors();
        }",loop_control
i,"for (int i = 0; i < TestHelper.RACE_DEFAULT_LOOPS; i++) {
                            f.onNext(1);
                        }",loop_control
i,"for (int i = 0; i < 1000; i++) {
                            f.onNext(1);
                        }",loop_control
i,"for (int i = 0; i < 100; i++) {
                            f.onNext(1);
                        }",loop_control
i,"for (int i = 0; i < 1000; i++) {
                            f.onNext(1);
                        }",loop_control
i,"for (int i = 0; i < 100; i++) {
                            f.onNext(1);
                        }",loop_control
i,"for (int i = 0; i < TestHelper.RACE_DEFAULT_LOOPS; i++) {
                source
                .test()
                .assertFailure(Throwable.class);
            }",loop_control
i,"for (int i = 0; i < TestHelper.RACE_DEFAULT_LOOPS; i++) {
            source
            .test()
            .assertResult();
        }",loop_control
i,"for (int i = 0; i < TestHelper.RACE_DEFAULT_LOOPS; i++) {
            TestObserver<Integer> to = new TestObserver<>();
            AtomicReference<ObservableEmitter<Integer>> ref = new AtomicReference<>();

            CountDownLatch cdl = new CountDownLatch(1);

            Observable.<Integer>create(emitter -> {
                emitter = emitter.serialize();
                ref.set(emitter);
                emitter.onNext(1);
            })
            .doOnNext(v -> {
                if (v == 1) {
                    TestHelper.raceOther(() -> {
                        ref.get().onNext(2);
                    }, cdl);
                    ref.get().onNext(3);
                }
            })
            .subscribe(to);

            cdl.await();

            to.assertValueCount(3);
        }",loop_control
i,"for (int i = 0; i < TestHelper.RACE_DEFAULT_LOOPS; i++) {
            TestObserver<Integer> to = new TestObserver<>();
            AtomicReference<ObservableEmitter<Integer>> ref = new AtomicReference<>();

            CountDownLatch cdl = new CountDownLatch(1);

            Observable.<Integer>create(emitter -> {
                emitter = emitter.serialize();
                ref.set(emitter);
                emitter.onNext(1);
            })
            .doOnNext(v -> {
                if (v == 1) {
                    TestHelper.raceOther(() -> {
                        ref.get().onNext(2);
                        ref.get().onComplete();
                    }, cdl);
                    ref.get().onNext(3);
                }
            })
            .subscribe(to);

            cdl.await();
        }",loop_control
i,"for (int i = 0; i < TestHelper.RACE_DEFAULT_LOOPS; i++) {
            final PublishSubject<Object> ps1 = PublishSubject.create();
            final PublishSubject<Object> ps2 = PublishSubject.create();

            List<Throwable> errors = TestHelper.trackPluginErrors();

            try {
                TestObserverEx<Observable<Integer>> to = Observable.just(1)
                .groupJoin(
                    Observable.just(2).concatWith(Observable.<Integer>never()),
                    new Function<Integer, ObservableSource<Object>>() {
                        @Override
                        public ObservableSource<Object> apply(Integer left) throws Exception {
                            return ps1;
                        }
                    },
                    new Function<Integer, ObservableSource<Object>>() {
                        @Override
                        public ObservableSource<Object> apply(Integer right) throws Exception {
                            return ps2;
                        }
                    },
                    new BiFunction<Integer, Observable<Integer>, Observable<Integer>>() {
                        @Override
                        public Observable<Integer> apply(Integer r, Observable<Integer> l) throws Exception {
                            return l;
                        }
                    }
                )
                .to(TestHelper.<Observable<Integer>>testConsumer());

                final TestException ex1 = new TestException();
                final TestException ex2 = new TestException();

                Runnable r1 = new Runnable() {
                    @Override
                    public void run() {
                        ps1.onError(ex1);
                    }
                };
                Runnable r2 = new Runnable() {
                    @Override
                    public void run() {
                        ps2.onError(ex2);
                    }
                };

                TestHelper.race(r1, r2);

                to.assertError(Throwable.class).assertSubscribed().assertNotComplete().assertValueCount(1);

                Throwable exc = to.errors().get(0);

                if (exc instanceof CompositeException) {
                    List<Throwable> es = TestHelper.compositeList(exc);
                    TestHelper.assertError(es, 0, TestException.class);
                    TestHelper.assertError(es, 1, TestException.class);
                } else {
                    to.assertError(TestException.class);
                }

                if (!errors.isEmpty()) {
                    TestHelper.assertUndeliverable(errors, 0, TestException.class);
                }
            } finally {
                RxJavaPlugins.reset();
            }
        }",loop_control
i,"for (int i = 0; i < TestHelper.RACE_DEFAULT_LOOPS; i++) {
            final PublishSubject<Object> ps1 = PublishSubject.create();
            final PublishSubject<Object> ps2 = PublishSubject.create();

            List<Throwable> errors = TestHelper.trackPluginErrors();

            try {
                TestObserverEx<Object> to = ps1
                .groupJoin(
                    ps2,
                    new Function<Object, ObservableSource<Object>>() {
                        @Override
                        public ObservableSource<Object> apply(Object left) throws Exception {
                            return Observable.never();
                        }
                    },
                    new Function<Object, ObservableSource<Object>>() {
                        @Override
                        public ObservableSource<Object> apply(Object right) throws Exception {
                            return Observable.never();
                        }
                    },
                    new BiFunction<Object, Observable<Object>, Observable<Object>>() {
                        @Override
                        public Observable<Object> apply(Object r, Observable<Object> l) throws Exception {
                            return l;
                        }
                    }
                )
                .flatMap(Functions.<Observable<Object>>identity())
                .to(TestHelper.<Object>testConsumer());

                final TestException ex1 = new TestException();
                final TestException ex2 = new TestException();

                Runnable r1 = new Runnable() {
                    @Override
                    public void run() {
                        ps1.onError(ex1);
                    }
                };
                Runnable r2 = new Runnable() {
                    @Override
                    public void run() {
                        ps2.onError(ex2);
                    }
                };

                TestHelper.race(r1, r2);

                to.assertError(Throwable.class).assertSubscribed().assertNotComplete().assertNoValues();

                Throwable exc = to.errors().get(0);

                if (exc instanceof CompositeException) {
                    List<Throwable> es = TestHelper.compositeList(exc);
                    TestHelper.assertError(es, 0, TestException.class);
                    TestHelper.assertError(es, 1, TestException.class);
                } else {
                    to.assertError(TestException.class);
                }

                if (!errors.isEmpty()) {
                    TestHelper.assertUndeliverable(errors, 0, TestException.class);
                }
            } finally {
                RxJavaPlugins.reset();
            }
        }",loop_control
i,"for (int i = 0; i < TestHelper.RACE_DEFAULT_LOOPS; i++) {
            final PublishSubject<Integer> ps = PublishSubject.create();

            final TestObserver<Integer> to = ps.takeLast(1, TimeUnit.DAYS).test();

            Runnable r1 = new Runnable() {
                @Override
                public void run() {
                    ps.onComplete();
                }
            };

            Runnable r2 = new Runnable() {
                @Override
                public void run() {
                    to.dispose();
                }
            };

            TestHelper.race(r1, r2);
        }",loop_control
i,"for (int i = 1; i < 3; i++) {
            effectCounter.set(0);
            System.out.printf(""- %d -%n"", i);
            result.subscribe(new Consumer<Integer>() {

                @Override
                public void accept(Integer t1) {
                    System.out.println(t1);
                }

            }, new Consumer<Throwable>() {

                @Override
                public void accept(Throwable t1) {
                    t1.printStackTrace();
                }
            },
            new Action() {
                @Override
                public void run() {
                    System.out.println(""Done"");
                }
            });
            assertEquals(2, effectCounter.get());
        }",loop_control
i,"for (int i = 0; i < 1000; i++) {
            assertEquals((Integer)i, onNextEvents.get(i));
        }",loop_control
i,"for (int i = 0; i < 100; i++) {
            TestObserverEx<Integer> to1 = new TestObserverEx<>();

            Observable<Integer> cached = source.replay().autoConnect();

            cached.observeOn(Schedulers.computation()).subscribe(to1);

            to1.awaitDone(2, TimeUnit.SECONDS);
            to1.assertNoErrors();
            to1.assertTerminated();
            assertEquals(10000, to1.values().size());

            TestObserverEx<Integer> to2 = new TestObserverEx<>();
            cached.observeOn(Schedulers.computation()).subscribe(to2);

            to2.awaitDone(2, TimeUnit.SECONDS);
            to2.assertNoErrors();
            to2.assertTerminated();
            assertEquals(10000, to2.values().size());
        }",loop_control
to,"for (int i = 0; i < 100; i++) {
            TestObserverEx<Long> to = new TestObserverEx<>();
            list.add(to);
            output.skip(i * 10).take(10).subscribe(to);
        }",iterator
to,"for (TestObserverEx<Long> to : list) {
            to.awaitDone(3, TimeUnit.SECONDS);
            to.assertNoErrors();
            to.assertTerminated();

            for (int i = j * 10; i < j * 10 + 10; i++) {
                expected.set(i - j * 10, (long)i);
            }

            to.assertValueSequence(expected);

            j++;
        }",iterator
i,"for (int i = 0; i < 100; i++) {
            TestObserverEx<Long> to = new TestObserverEx<>();
            list.add(to);
            output.skip(i * 10).take(10).subscribe(to);
        }",loop_control
i,"for (int i = 0; i < 10; i++) {
            expected.add((long)(i - 10));
        }",loop_control
i,"for (int i = j * 10; i < j * 10 + 10; i++) {
                expected.set(i - j * 10, (long)i);
            }",loop_control
j,"{
        Observable<Long> source = Observable.interval(1, 1, TimeUnit.MILLISECONDS)
                .take(1000)
                .subscribeOn(Schedulers.io());
        Observable<Long> cached = source.replay().autoConnect();

        Observable<Long> output = cached.observeOn(Schedulers.computation());

        List<TestObserverEx<Long>> list = new ArrayList<>(100);
        for (int i = 0; i < 100; i++) {
            TestObserverEx<Long> to = new TestObserverEx<>();
            list.add(to);
            output.skip(i * 10).take(10).subscribe(to);
        }

        List<Long> expected = new ArrayList<>();
        for (int i = 0; i < 10; i++) {
            expected.add((long)(i - 10));
        }
        int j = 0;
        for (TestObserverEx<Long> to : list) {
            to.awaitDone(3, TimeUnit.SECONDS);
            to.assertNoErrors();
            to.assertTerminated();

            for (int i = j * 10; i < j * 10 + 10; i++) {
                expected.set(i - j * 10, (long)i);
            }

            to.assertValueSequence(expected);

            j++;
        }
    }",loop_control
i,"for (int i = 0; i < m; i++) {
                    t.onNext(i);
                }",loop_control
i,"for (int i = 0; i < TestHelper.RACE_DEFAULT_LOOPS; i++) {
            final ConnectableObservable<Integer> co = Observable.range(1, 3).replay();

            Runnable r = new Runnable() {
                @Override
                public void run() {
                    co.connect();
                }
            };

            TestHelper.race(r, r);
        }",loop_control
i,"for (int i = 0; i < TestHelper.RACE_DEFAULT_LOOPS; i++) {
            final ConnectableObservable<Integer> co = Observable.range(1, 3).replay();

            final TestObserver<Integer> to1 = new TestObserver<>();
            final TestObserver<Integer> to2 = new TestObserver<>();

            Runnable r1 = new Runnable() {
                @Override
                public void run() {
                    co.subscribe(to1);
                }
            };

            Runnable r2 = new Runnable() {
                @Override
                public void run() {
                    co.subscribe(to2);
                }
            };

            TestHelper.race(r1, r2);
        }",loop_control
i,"for (int i = 0; i < TestHelper.RACE_DEFAULT_LOOPS; i++) {
            final ConnectableObservable<Integer> co = Observable.range(1, 3).replay();

            final TestObserver<Integer> to1 = new TestObserver<>();
            final TestObserver<Integer> to2 = new TestObserver<>();

            co.subscribe(to1);

            Runnable r1 = new Runnable() {
                @Override
                public void run() {
                    to1.dispose();
                }
            };

            Runnable r2 = new Runnable() {
                @Override
                public void run() {
                    co.subscribe(to2);
                }
            };

            TestHelper.race(r1, r2);
        }",loop_control
i,"for (int i = 0; i < TestHelper.RACE_DEFAULT_LOOPS; i++) {
            final PublishSubject<Integer> ps = PublishSubject.create();

            final ConnectableObservable<Integer> co = ps.replay();

            final TestObserver<Integer> to1 = new TestObserver<>();

            Runnable r1 = new Runnable() {
                @Override
                public void run() {
                    co.subscribe(to1);
                }
            };

            Runnable r2 = new Runnable() {
                @Override
                public void run() {
                    for (int j = 0; j < 1000; j++) {
                        ps.onNext(j);
                    }
                }
            };

            TestHelper.race(r1, r2);
        }",loop_control
j,"for (int j = 0; j < 1000; j++) {
                        ps.onNext(j);
                    }",loop_control
i,"for (int i = 0; i < TestHelper.RACE_DEFAULT_LOOPS; i++) {
            final PublishSubject<Integer> ps = PublishSubject.create();

            final ConnectableObservable<Integer> co = ps.replay();

            final TestObserver<Integer> to1 = new TestObserver<>();

            co.subscribe(to1);

            Runnable r1 = new Runnable() {
                @Override
                public void run() {
                    to1.dispose();
                }
            };

            Runnable r2 = new Runnable() {
                @Override
                public void run() {
                    for (int j = 0; j < 1000; j++) {
                        ps.onNext(j);
                    }
                }
            };

            TestHelper.race(r1, r2);
        }",loop_control
j,"for (int j = 0; j < 1000; j++) {
                        ps.onNext(j);
                    }",loop_control
i,"for (int i = 0; i < TestHelper.RACE_DEFAULT_LOOPS; i++) {
            final ConnectableObservable<Integer> co = Observable.range(1, 1000).replay();

            final TestObserver<Integer> to1 = new TestObserver<>();

            co.connect();

            Runnable r1 = new Runnable() {
                @Override
                public void run() {
                    co.subscribe(to1);
                }
            };

            Runnable r2 = new Runnable() {
                @Override
                public void run() {
                    to1.dispose();
                }
            };

            TestHelper.race(r1, r2);
        }",loop_control
t,"for (Thread t : Thread.getAllStackTraces().keySet()) {
            if (t.getName().startsWith(""RxNewThread"")) {
                count++;
            }
        }",iterator
t,"for (Thread t : Thread.getAllStackTraces().keySet()) {
            if (t.getName().startsWith(""RxNewThread"")) {
                --count;
            }
        }",iterator
unsubscribed,"{

        final AtomicBoolean unsubscribed = new AtomicBoolean();
        final CountDownLatch latch = new CountDownLatch(1);

        Observable<Observable<Long>> source = Observable.unsafeCreate(new ObservableSource<Observable<Long>>() {

            @Override
            public void subscribe(final Observer<? super Observable<Long>> observer) {
                // verbose on purpose so I can track the inside of it
                final Disposable upstream = Disposable.fromRunnable(new Runnable() {
                    @Override
                    public void run() {
                        System.out.println(""*** unsubscribed"");
                        unsubscribed.set(true);
                    }
                });
                observer.onSubscribe(upstream);

                new Thread(new Runnable() {

                    @Override
                    public void run() {

                        while (!unsubscribed.get()) {
                            observer.onNext(Observable.just(1L, 2L));
                        }
                        System.out.println(""Done looping after unsubscribe: "" + unsubscribed.get());
                        observer.onComplete();

                        // mark that the thread is finished
                        latch.countDown();
                    }
                }).start();
            }

        });

        final AtomicInteger count = new AtomicInteger();
        Observable.merge(source).take(6).blockingForEach(new Consumer<Long>() {

            @Override
            public void accept(Long v) {
                System.out.println(""Value: "" + v);
                int c = count.incrementAndGet();
                if (c > 6) {
                    fail(""Should be only 6"");
                }

            }
        });

        latch.await(1000, TimeUnit.MILLISECONDS);

        System.out.println(""unsubscribed: "" + unsubscribed.get());

        assertTrue(unsubscribed.get());

    }",maybe_loop_control
i,"for (int i = 0; i < 100; i++) {
            System.out.println(""testSynchronizationOfMultipleSequencesLoop > "" + i);
            synchronizationOfMultipleSequences();
        }",loop_control
concurrentCounter,"{
        final TestASynchronousObservable o1 = new TestASynchronousObservable();
        final TestASynchronousObservable o2 = new TestASynchronousObservable();

        // use this latch to cause onNext to wait until we're ready to let it go
        final CountDownLatch endLatch = new CountDownLatch(1);

        final AtomicInteger concurrentCounter = new AtomicInteger();
        final AtomicInteger totalCounter = new AtomicInteger();

        Observable<String> m = Observable.merge(Observable.unsafeCreate(o1), Observable.unsafeCreate(o2));
        m.subscribe(new DefaultObserver<String>() {

            @Override
            public void onComplete() {

            }

            @Override
            public void onError(Throwable e) {
                throw new RuntimeException(""failed"", e);
            }

            @Override
            public void onNext(String v) {
                totalCounter.incrementAndGet();
                concurrentCounter.incrementAndGet();
                try {
                    // avoid deadlocking the main thread
                    if (Thread.currentThread().getName().equals(""TestASynchronousObservable"")) {
                        // wait here until we're done asserting
                        endLatch.await();
                    }
                } catch (InterruptedException e) {
                    e.printStackTrace();
                    throw new RuntimeException(""failed"", e);
                } finally {
                    concurrentCounter.decrementAndGet();
                }
            }

        });

        // wait for both observables to send (one should be blocked)
        o1.onNextBeingSent.await();
        o2.onNextBeingSent.await();

        // I can't think of a way to know for sure that both threads have or are trying to send onNext
        // since I can't use a CountDownLatch for ""after"" onNext since I want to catch during it
        // but I can't know for sure onNext is invoked
        // so I'm unfortunately reverting to using a Thread.sleep to allow the process scheduler time
        // to make sure after o1.onNextBeingSent and o2.onNextBeingSent are hit that the following
        // onNext is invoked.

        int timeout = 20;

        while (timeout-- > 0 && concurrentCounter.get() != 1) {
            Thread.sleep(100);
        }

        try { // in try/finally so threads are released via latch countDown even if assertion fails
            assertEquals(1, concurrentCounter.get());
        } finally {
            // release so it can finish
            endLatch.countDown();
        }

        try {
            o1.t.join();
            o2.t.join();
        } catch (InterruptedException e) {
            throw new RuntimeException(e);
        }

        assertEquals(2, totalCounter.get());
        assertEquals(0, concurrentCounter.get());
    }",maybe_loop_control
s,"for (String s : valuesToReturn) {
                if (s == null) {
                    System.out.println(""throwing exception"");
                    observer.onError(new NullPointerException());
                } else {
                    observer.onNext(s);
                }
            }",iterator
i,"for (int i = 0; i < 10; i++) {
            TestScheduler scheduler1 = new TestScheduler();
            AtomicBoolean os1 = new AtomicBoolean(false);
            Observable<Long> o1 = createObservableOf5IntervalsOf1SecondIncrementsWithSubscriptionHook(scheduler1, os1);

            TestScheduler scheduler2 = new TestScheduler();
            AtomicBoolean os2 = new AtomicBoolean(false);
            Observable<Long> o2 = createObservableOf5IntervalsOf1SecondIncrementsWithSubscriptionHook(scheduler2, os2);

            TestObserver<Long> to = new TestObserver<>();
            Observable.merge(o1, o2).subscribe(to);

            // we haven't incremented time so nothing should be received yet
            to.assertNoValues();

            scheduler1.advanceTimeBy(3, TimeUnit.SECONDS);
            scheduler2.advanceTimeBy(2, TimeUnit.SECONDS);

            to.assertValues(0L, 1L, 2L, 0L, 1L);
            // not unsubscribed yet
            assertFalse(os1.get());
            assertFalse(os2.get());

            // early unsubscribe
            to.dispose();

            assertTrue(os1.get());
            assertTrue(os2.get());

            to.assertValues(0L, 1L, 2L, 0L, 1L);
            // FIXME not happening anymore
//            ts.assertUnsubscribed();
        }",loop_control
i,"for (int i = 0; i < 10; i++) {
            Observable<Integer> merge = Observable.merge(o, o, o);
            TestObserverEx<Integer> to = new TestObserverEx<>();
            merge.subscribe(to);

            to.awaitDone(3, TimeUnit.SECONDS);
            to.assertTerminated();
            to.assertNoErrors();
            to.assertComplete();
            List<Integer> onNextEvents = to.values();
            assertEquals(30000, onNextEvents.size());
            //            System.out.println(""onNext: "" + onNextEvents.size() + "" onComplete: "" + ts.getOnCompletedEvents().size());
        }",loop_control
i,"for (int i = 0; i < 100; i++) {
                                observer.onNext(1);
                                try {
                                    Thread.sleep(1);
                                } catch (InterruptedException e) {
                                    e.printStackTrace();
                                }
                            }",loop_control
i,"for (int i = 0; i < 10; i++) {
            Observable<Integer> merge = Observable.merge(o, o, o);
            TestObserver<Integer> to = new TestObserver<>();
            merge.subscribe(to);

            to.awaitDone(5, TimeUnit.SECONDS);
            to.assertComplete();
            List<Integer> onNextEvents = to.values();
            assertEquals(300, onNextEvents.size());
            //            System.out.println(""onNext: "" + onNextEvents.size() + "" onComplete: "" + ts.getOnCompletedEvents().size());
        }",loop_control
i,"for (int i = 0; i < 10000; i++) {
                                observer.onNext(i);
                            }",loop_control
i,"for (int i = 0; i < 10; i++) {
            Observable<Integer> merge = Observable.merge(o, o, o);
            TestObserver<Integer> to = new TestObserver<>();
            merge.subscribe(to);

            to.awaitDone(5, TimeUnit.SECONDS);
            to.assertNoErrors();
            to.assertComplete();
            List<Integer> onNextEvents = to.values();
            assertEquals(30000, onNextEvents.size());
            //                System.out.println(""onNext: "" + onNextEvents.size() + "" onComplete: "" + ts.getOnCompletedEvents().size());
        }",loop_control
i,"for (int i = 0; i < 1000; i++) {
            System.err.flush();
            System.out.println(""---"");
            System.out.flush();
            backpressureUpstream2();
        }",loop_control
o,"{
        Observable<Integer> o = Observable.fromIterable(new Iterable<Integer>() {
            @Override
            public Iterator<Integer> iterator() {
                return new Iterator<Integer>() {

                    @Override
                    public void remove() {
                    }

                    @Override
                    public Integer next() {
                        return generated.getAndIncrement();
                    }

                    @Override
                    public boolean hasNext() {
                        return true;
                    }
                };
            }
        });
        return o;
    }",iterator
i,"for (int i = 0; i < 1000; i++) {
            list.add(i);
        }",loop_control
req,"for (final int req : new int[] { 16, 32, 64, 128, 256 }) {
            TestObserverEx<Integer> to = new TestObserverEx<Integer>() {
                int remaining = req;

                @Override
                public void onNext(Integer t) {
                    super.onNext(t);
                    if (--remaining == 0) {
                        remaining = req;
                    }
                }
            };
            runMerge(toScalar, to);
        }",iterator
req,"for (final int req : new int[] { 16, 32, 64, 128, 256 }) {
            TestObserverEx<Integer> to = new TestObserverEx<Integer>() {
                int remaining = req;
                @Override
                public void onNext(Integer t) {
                    super.onNext(t);
                    if (--remaining == 0) {
                        remaining = req;
                    }
                }
            };
            runMerge(toHiddenScalar, to);
        }",iterator
i,"for (int i = 0;; i++) {
            //only run this for a max of ten seconds
            if (System.currentTimeMillis() - startTime > TimeUnit.SECONDS.toMillis(durationSeconds)) {
                return;
            }
            if (i % 1000 == 0) {
                System.out.println(""concatMapRangeAsyncLoop > "" + i);
            }
            TestObserverEx<Integer> to = new TestObserverEx<>();
            Observable.range(0, 1000)
            .concatMap(new Function<Integer, Observable<Integer>>() {
                @Override
                public Observable<Integer> apply(Integer t) {
                    return Observable.fromIterable(Arrays.asList(t));
                }
            }, 2, ImmediateThinScheduler.INSTANCE)
            .observeOn(Schedulers.computation()).subscribe(to);

            to.awaitDone(2500, TimeUnit.MILLISECONDS);
            to.assertTerminated();
            to.assertNoErrors();
            assertEquals(1000, to.values().size());
            assertEquals((Integer)999, to.values().get(999));
        }",loop_control
i,"for (int i = 2; i < 10; i++) {
            Observable<Integer>[] obs = new Observable[i];
            Arrays.fill(obs, Observable.just(1));

            Integer[] expected = new Integer[i];
            Arrays.fill(expected, 1);

            Method m = Observable.class.getMethod(""concatArray"", ObservableSource[].class);

            TestObserver<Integer> to = TestObserver.create();

            ((Observable<Integer>)m.invoke(null, new Object[]{obs})).subscribe(to);

            to.assertValues(expected);
            to.assertNoErrors();
            to.assertComplete();
        }",loop_control
i,"for (int i = 2; i < 10; i++) {
            Object[] obs = new Object[i];
            Arrays.fill(obs, 1);

            Integer[] expected = new Integer[i];
            Arrays.fill(expected, 1);

            Method m = Observable.class.getMethod(""startWithArray"", Object[].class);

            TestObserver<Integer> to = TestObserver.create();

            ((Observable<Integer>)m.invoke(Observable.empty(), new Object[]{obs})).subscribe(to);

            to.assertValues(expected);
            to.assertNoErrors();
            to.assertComplete();
        }",loop_control
i,"for (int i = 0; i < TestHelper.RACE_DEFAULT_LOOPS; i++) {
            List<Throwable> errors = TestHelper.trackPluginErrors();
            try {
                final PublishSubject<Integer> ps1 = PublishSubject.create();
                final PublishSubject<Integer> ps2 = PublishSubject.create();

                TestObserver<Void> to = ps1.concatMapCompletable(new Function<Integer, CompletableSource>() {
                    @Override
                    public CompletableSource apply(Integer v) throws Exception {
                        return Completable.fromObservable(ps2);
                    }
                }).test();

                final TestException ex1 = new TestException();
                final TestException ex2 = new TestException();

                Runnable r1 = new Runnable() {
                    @Override
                    public void run() {
                        ps1.onError(ex1);
                    }
                };
                Runnable r2 = new Runnable() {
                    @Override
                    public void run() {
                        ps2.onError(ex2);
                    }
                };

                TestHelper.race(r1, r2);

                to.assertFailure(TestException.class);

                if (!errors.isEmpty()) {
                    TestHelper.assertError(errors, 0, TestException.class);
                }
            } finally {
                RxJavaPlugins.reset();
            }
        }",loop_control
i,"for (int i = 0; i < TestHelper.RACE_DEFAULT_LOOPS; i++) {

                TestObserver<Integer> to = source.take(1)
                .repeatWhen(new Function<Observable<Object>, ObservableSource<Integer>>() {
                    @Override
                    public ObservableSource<Integer> apply(Observable<Object> v)
                            throws Exception {
                        return signaller;
                    }
                }).test();

                Runnable r1 = new Runnable() {
                    @Override
                    public void run() {
                        for (int i = 0; i < TestHelper.RACE_DEFAULT_LOOPS; i++) {
                            source.onNext(1);
                        }
                    }
                };
                Runnable r2 = new Runnable() {
                    @Override
                    public void run() {
                        for (int i = 0; i < TestHelper.RACE_DEFAULT_LOOPS; i++) {
                            signaller.onNext(1);
                        }
                    }
                };

                TestHelper.race(r1, r2);

                to.dispose();
            }",loop_control
e,"for (Throwable e : errors) {
                    e.printStackTrace();
                }",iterator
i,"for (int i = 0; i < TestHelper.RACE_DEFAULT_LOOPS; i++) {
            final PublishSubject<Integer> ps = PublishSubject.create();

            final TestObserver<Integer> to = ps.retry(Functions.alwaysTrue()).test();

            final TestException ex = new TestException();

            Runnable r1 = new Runnable() {
                @Override
                public void run() {
                    ps.onError(ex);
                }
            };

            Runnable r2 = new Runnable() {
                @Override
                public void run() {
                    to.dispose();
                }
            };

            TestHelper.race(r1, r2);

            to.assertEmpty();
        }",loop_control
i,"for (int i = 0; i < TestHelper.RACE_DEFAULT_LOOPS; i++) {
            final PublishSubject<Integer> ps = PublishSubject.create();

            final TestObserver<Integer> to = ps.retry(new BiPredicate<Object, Object>() {
                @Override
                public boolean test(Object t1, Object t2) throws Exception {
                    return true;
                }
            }).test();

            final TestException ex = new TestException();

            Runnable r1 = new Runnable() {
                @Override
                public void run() {
                    ps.onError(ex);
                }
            };

            Runnable r2 = new Runnable() {
                @Override
                public void run() {
                    to.dispose();
                }
            };

            TestHelper.race(r1, r2);

            to.assertEmpty();
        }",loop_control
o,"{
        Observable<Integer> o = Observable.fromIterable(new Iterable<Integer>() {
            @Override
            public Iterator<Integer> iterator() {
                return new Iterator<Integer>() {

                    @Override
                    public void remove() {
                    }

                    @Override
                    public Integer next() {
                        return generated.getAndIncrement();
                    }

                    @Override
                    public boolean hasNext() {
                        return true;
                    }
                };
            }
        });
        return o;
    }",iterator
i,"for (int i = 1; i <= 5; i++) {
                    if (d.isDisposed()) {
                        break;
                    }
                    numEmitted.incrementAndGet();
                    o.onNext(i);
                    Thread.yield();
                }",loop_control
d,"{
                final Disposable d = Disposable.empty();
                o.onSubscribe(d);
                Thread t = new Thread(new Runnable() {

                    @Override
                    public void run() {
                        System.out.println(""-------> subscribe to infinite sequence"");
                        System.out.println(""Starting thread: "" + Thread.currentThread());
                        int i = 1;
                        while (!d.isDisposed()) {
                            o.onNext(i++);
                            Thread.yield();
                        }
                        o.onComplete();
                        latch.countDown();
                        System.out.println(""Ending thread: "" + Thread.currentThread());
                    }
                });
                t.start();

            }",maybe_loop_control
i,"for (int i = 0; i < 1026; i++) {
            expected.add(i * 3);
        }",loop_control
i,"{
        long startTime = System.currentTimeMillis();
        Observable<Integer> src = Observable.just(1).subscribeOn(Schedulers.computation());

        // now try and generate a hang by zipping src with itself repeatedly. A
        // time limit of 9 seconds ( 1 second less than the test timeout) is
        // used so that this test will not timeout on slow machines.
        int i = 0;
        while (System.currentTimeMillis() - startTime < 9000 && i++ < 100000) {
            int value = Observable.zip(src, src, new BiFunction<Integer, Integer, Integer>() {
                @Override
                public Integer apply(Integer t1, Integer t2) {
                    return t1 + t2 * 10;
                }
            }).blockingSingle(0);

            Assert.assertEquals(11, value);
        }
    }",loop_control
i,"for (int i = 0; i < 500; i++) {
            TestObserver<List<Object>> to = Observable.zip(
                    Observable.just(1).observeOn(Schedulers.single()).map(new Function<Integer, Object>() {
                        @Override
                        public Object apply(Integer v) throws Exception {
                            return Thread.currentThread().getName().substring(0, 4);
                        }
                    }),
                    Observable.just(1).observeOn(Schedulers.computation()).map(new Function<Integer, Object>() {
                        @Override
                        public Object apply(Integer v) throws Exception {
                            return Thread.currentThread().getName().substring(0, 4);
                        }
                    }),
                    new BiFunction<Object, Object, List<Object>>() {
                        @Override
                        public List<Object> apply(Object t1, Object t2) throws Exception {
                            return Arrays.asList(t1, t2);
                        }
                    }
            )
            .test()
            .awaitDone(5, TimeUnit.SECONDS)
            .assertValueCount(1);

            List<Object> list = to.values().get(0);

            assertTrue(list.toString(), list.contains(""RxSi""));
            assertTrue(list.toString(), list.contains(""RxCo""));
        }",loop_control
i,"for (int i = 0; i < TestHelper.RACE_DEFAULT_LOOPS; i++) {
            List<Throwable> errors = TestHelper.trackPluginErrors();
            try {
                final PublishSubject<Integer> ps1 = PublishSubject.create();
                final PublishSubject<Integer> ps2 = PublishSubject.create();

                TestObserver<Integer> to = ps1.concatMap(new Function<Integer, ObservableSource<Integer>>() {
                    @Override
                    public ObservableSource<Integer> apply(Integer v) throws Exception {
                        return ps2;
                    }
                }).test();

                final TestException ex1 = new TestException();
                final TestException ex2 = new TestException();

                Runnable r1 = new Runnable() {
                    @Override
                    public void run() {
                        ps1.onError(ex1);
                    }
                };
                Runnable r2 = new Runnable() {
                    @Override
                    public void run() {
                        ps2.onError(ex2);
                    }
                };

                TestHelper.race(r1, r2);

                to.assertFailure(TestException.class);

                if (!errors.isEmpty()) {
                    TestHelper.assertError(errors, 0, TestException.class);
                }
            } finally {
                RxJavaPlugins.reset();
            }
        }",loop_control
i,"for (int i = 1; i < 10; i++) {
                            ps.onNext(i);
                        }",loop_control
i,"for (int i = 1; i < 10; i++) {
                        ps.onNext(i);
                    }",loop_control
i,"for (int i = 0; i < count; i++) {
                            Event e = new Event();
                            e.source = i % groupCount;
                            e.message = ""Event-"" + i;
                            observer.onNext(e);
                        }",loop_control
d,"{
                Disposable d = Disposable.empty();
                op.onSubscribe(d);
                subscribeCounter.incrementAndGet();
                int i = 0;
                while (!d.isDisposed()) {
                    i++;
                    Event e = new Event();
                    e.source = i % numGroups;
                    e.message = ""Event-"" + i;
                    op.onNext(e);
                    sentEventCounter.incrementAndGet();
                }
                op.onComplete();
            }",maybe_loop_control
i,"for (int i = 0; i < TestHelper.RACE_LONG_LOOPS; i++) {

            final TestObserver<Integer> to = new TestObserver<>();

            final PublishSubject<Integer> ps = PublishSubject.create();

            ps.groupBy(new Function<Integer, Integer>() {
                @Override
                public Integer apply(Integer v) throws Throwable {
                    return v % 10;
                }
            })
            .flatMap(new Function<GroupedObservable<Integer, Integer>, ObservableSource<Integer>>() {
                @Override
                public ObservableSource<Integer> apply(GroupedObservable<Integer, Integer> v)
                        throws Throwable {
                    return v;
                }
            })
            .subscribe(to);

            Runnable r1 = new Runnable() {
                @Override
                public void run() {
                    for (int j = 0; j < 1000; j++) {
                        ps.onNext(j);
                    }
                }
            };

            Runnable r2 = new Runnable() {
                @Override
                public void run() {
                    to.dispose();
                }
            };

            TestHelper.race(r1, r2);

            assertFalse(""Round "" + i, ps.hasObservers());
        }",loop_control
j,"for (int j = 0; j < 1000; j++) {
                        ps.onNext(j);
                    }",loop_control
i,"for (int i = 0; i < TestHelper.RACE_LONG_LOOPS; i++) {
            BehaviorSubject<Integer> bs = BehaviorSubject.createDefault(1);
            CountDownLatch cdl = new CountDownLatch(1);

            bs.groupBy(v -> 1)
            .doOnNext(g -> {
                TestHelper.raceOther(() -> {
                    g.test();
                }, cdl);
            })
            .test();

            cdl.await();
        }",loop_control
i,"for (int i = 1; i <= Flowable.bufferSize() * 2 + 1; i++) {
            list.add(i);
        }",loop_control
i,"for (int i = 0; i <= max; i++) {
            try {
                multiThreadedWithNPE();
                return;
            } catch (AssertionError ex) {
                if (i == max) {
                    throw ex;
                }
            }
            Thread.sleep((long)(1000 * Math.random() + 100));
        }",loop_control
i,"for (int i = 0; i <= max; i++) {
            try {
                multiThreadedWithNPEinMiddle();
                return;
            } catch (AssertionError ex) {
                if (i == max) {
                    throw ex;
                }
            }
            Thread.sleep((long)(1000 * Math.random() + 100));
        }",loop_control
i,"for (int i = 0; i < 3; i++) {
            TestMultiThreadedObservable onSubscribe = new TestMultiThreadedObservable(""one"", ""two"", ""three"", null, ""four"", ""five"", ""six"", ""seven"", ""eight"", ""nine"");
            Observable<String> w = Observable.unsafeCreate(onSubscribe);

            BusyObserver busyobserver = new BusyObserver();

            w.serialize().subscribe(busyobserver);
            onSubscribe.waitToFinish();

            System.out.println(""maxConcurrentThreads: "" + onSubscribe.maxConcurrentThreads.get());
            // this should not always be the full number of items since the error should (very often)
            // stop it before it completes all 9
            System.out.println(""onNext count: "" + busyobserver.onNextCount.get());
            if (busyobserver.onNextCount.get() < 9) {
                lessThan9 = true;
            }
            assertTrue(busyobserver.onError);
            // no onComplete because onError was invoked
            assertFalse(busyobserver.onComplete);
            // non-deterministic because unsubscribe happens after 'waitToFinish' releases
            // so commenting out for now as this is not a critical thing to test here
            // verify(s, times(1)).unsubscribe();

            // we can have concurrency ...
            int n = onSubscribe.maxConcurrentThreads.get();
            assertTrue("""" + n, n > 1);
            // ... but the onNext execution should be single threaded
            assertEquals(1, busyobserver.maxConcurrentThreads.get());
        }",loop_control
i,"for (int i = 0; i < numStringsToSend; i++) {
                observer.onNext(""aString"");
            }",loop_control
f,"for (Future<?> f : waitOnThese) {
                    try {
                        f.get();
                    } catch (Throwable e) {
                        System.err.println(""Error while waiting on future in CompletionThread"");
                    }
                }",iterator
i,"for (int i = 0; i <= max; i++) {
            try {
                multiThreadedWithNPE();
                return;
            } catch (AssertionError ex) {
                if (i == max) {
                    throw ex;
                }
            }
            Thread.sleep((long)(1000 * Math.random() + 100));
        }",loop_control
i,"for (int i = 0; i <= max; i++) {
            try {
                multiThreadedWithNPEinMiddle();
                return;
            } catch (AssertionError ex) {
                if (i == max) {
                    throw ex;
                }
            }
            Thread.sleep((long)(1000 * Math.random() + 100));
        }",loop_control
i,"for (int i = 0; i < 3; i++) {
            TestMultiThreadedObservable onSubscribe = new TestMultiThreadedObservable(""one"", ""two"", ""three"", null, ""four"", ""five"", ""six"", ""seven"", ""eight"", ""nine"");
            Observable<String> w = Observable.unsafeCreate(onSubscribe);

            BusyObserver busyobserver = new BusyObserver();

            w.serialize().subscribe(busyobserver);
            onSubscribe.waitToFinish();

            System.out.println(""maxConcurrentThreads: "" + onSubscribe.maxConcurrentThreads.get());
            // this should not always be the full number of items since the error should (very often)
            // stop it before it completes all 9
            System.out.println(""onNext count: "" + busyobserver.onNextCount.get());
            if (busyobserver.onNextCount.get() < 9) {
                lessThan9 = true;
            }
            assertTrue(busyobserver.onError);
            // no onComplete because onError was invoked
            assertFalse(busyobserver.onComplete);
            // non-deterministic because unsubscribe happens after 'waitToFinish' releases
            // so commenting out for now as this is not a critical thing to test here
            // verify(s, times(1)).unsubscribe();

            // we can have concurrency ...
            int n = onSubscribe.maxConcurrentThreads.get();
            assertTrue("""" + n, n > 1);
            // ... but the onNext execution should be single threaded
            assertEquals(1, busyobserver.maxConcurrentThreads.get());
        }",loop_control
i,"for (int i = 0; i < numStringsToSend; i++) {
                observer.onNext(""aString"");
            }",loop_control
f,"for (Future<?> f : waitOnThese) {
                    try {
                        f.get();
                    } catch (Throwable e) {
                        System.err.println(""Error while waiting on future in CompletionThread"");
                    }
                }",iterator
s,"for (String s : values) {
                            System.out.println(""TestSingleThreadedObservable onNext: "" + s);
                            observer.onNext(s);
                        }",iterator
s,"for (final String s : values) {
                            threadPool.execute(new Runnable() {

                                @Override
                                public void run() {
                                    threadsRunning.incrementAndGet();
                                    try {
                                        // perform onNext call
                                        if (s == null) {
                                            System.out.println(""TestMultiThreadedObservable onNext: null"");
                                            // force an error
                                            throw npe;
                                        } else {
                                            System.out.println(""TestMultiThreadedObservable onNext: "" + s);
                                        }
                                        observer.onNext(s);
                                        // capture 'maxThreads'
                                        int concurrentThreads = threadsRunning.get();
                                        int maxThreads = maxConcurrentThreads.get();
                                        if (concurrentThreads > maxThreads) {
                                            maxConcurrentThreads.compareAndSet(maxThreads, concurrentThreads);
                                        }
                                    } catch (Throwable e) {
                                        observer.onError(e);
                                    } finally {
                                        threadsRunning.decrementAndGet();
                                    }
                                }
                            });
                        }",iterator
s,"for (Scheduler s : new Scheduler[] { Schedulers.single(), Schedulers.computation(), Schedulers.newThread(), Schedulers.io(), Schedulers.from(exec) }) {
                final TestObserver<Boolean> observer = TestObserver.create();
                observer.withTag(s.getClass().getSimpleName());

                Observable.<Boolean>create(new ObservableOnSubscribe<Boolean>() {
                    @Override
                    public void subscribe(ObservableEmitter<Boolean> emitter) throws Exception {
                      emitter.onNext(Thread.interrupted());
                      emitter.onComplete();
                    }
                })
                .delaySubscription(100, TimeUnit.MILLISECONDS, s)
                .subscribe(observer);

                observer.awaitDone(5, TimeUnit.SECONDS);
                observer.assertValue(false);
            }",iterator
s,"{

        final String[] values;
        Thread t;

        TestObservable(Subscription s, String... values) {
            this.values = values;
        }

        @Override
        public void subscribe(final Observer<? super String> observer) {
            System.out.println(""TestObservable subscribed to ..."");
            observer.onSubscribe(Disposable.empty());
            t = new Thread(new Runnable() {

                @Override
                public void run() {
                    try {
                        System.out.println(""running TestObservable thread"");
                        for (String s : values) {
                            System.out.println(""TestObservable onNext: "" + s);
                            observer.onNext(s);
                        }
                        throw new RuntimeException(""Forced Failure"");
                    } catch (Throwable e) {
                        observer.onError(e);
                    }
                }

            });
            System.out.println(""starting TestObservable thread"");
            t.start();
            System.out.println(""done starting TestObservable thread"");
        }

    }",iterator
i,"for (int i = 0; !bs.isDisposed(); i++) {
                    System.out.println(""Emit: "" + i);
                    count.incrementAndGet();
                    observer.onNext(i);
                }",loop_control
s,"for (String s : values) {
                            System.out.println(""TestObservable onNext: "" + s);
                            observer.onNext(s);
                        }",iterator
d,"{
            Disposable d = Disposable.empty();
            op.onSubscribe(d);
            long l = 1;
            while (!d.isDisposed()) {
                op.onNext(l++);
            }
            op.onComplete();
        }",maybe_loop_control
i,"for (int i = 0; i < TestHelper.RACE_DEFAULT_LOOPS; i++) {
            final PublishSubject<Integer> ps = PublishSubject.create();

            final TestObserver<Integer> to = ps.skipLast(1, TimeUnit.DAYS, scheduler).test();

            Runnable r1 = new Runnable() {
                @Override
                public void run() {
                    ps.onComplete();
                }
            };

            Runnable r2 = new Runnable() {
                @Override
                public void run() {
                    to.dispose();
                }
            };

            TestHelper.race(r1, r2);
        }",loop_control
i,"for (int i = 0; i < TestHelper.RACE_DEFAULT_LOOPS; i++) {
            final PublishSubject<Integer> ps = PublishSubject.create();

            final TestObserver<Integer> to = ps.skipLast(1, TimeUnit.DAYS, scheduler, true).test();

            Runnable r1 = new Runnable() {
                @Override
                public void run() {
                    ps.onComplete();
                }
            };

            Runnable r2 = new Runnable() {
                @Override
                public void run() {
                    to.dispose();
                }
            };

            TestHelper.race(r1, r2);
        }",loop_control
i,"for (int i = 0; i < TestHelper.RACE_DEFAULT_LOOPS; i++) {
            final PublishSubject<Integer> ps = PublishSubject.create();

            final TestObserver<Integer> to = ps.skipLast(1, TimeUnit.DAYS, scheduler).test();

            Runnable r1 = new Runnable() {
                @Override
                public void run() {
                    ps.onNext(1);
                }
            };

            Runnable r2 = new Runnable() {
                @Override
                public void run() {
                    to.dispose();
                }
            };

            TestHelper.race(r1, r2);
        }",loop_control
i,"for (int i = 0; i < TestHelper.RACE_DEFAULT_LOOPS; i++) {
            final PublishSubject<Integer> ps = PublishSubject.create();

            final TestObserver<Integer> to = ps.skipLast(1, TimeUnit.DAYS, scheduler, true).test();

            Runnable r1 = new Runnable() {
                @Override
                public void run() {
                    ps.onNext(1);
                    ps.onComplete();
                }
            };

            Runnable r2 = new Runnable() {
                @Override
                public void run() {
                    to.dispose();
                }
            };

            TestHelper.race(r1, r2);
        }",loop_control
i,"for (int i = 0; i < expectedCount; i++) {
            Observable
                    .just(Boolean.TRUE, Boolean.FALSE)
                    .takeWhile(new Predicate<Boolean>() {
                        @Override
                        public boolean test(Boolean value) {
                            return value;
                        }
                    })
                    .toList()
                    .doOnSuccess(new Consumer<List<Boolean>>() {
                        @Override
                        public void accept(List<Boolean> booleans) {
                            count.incrementAndGet();
                        }
                    })
                    .subscribe();
        }",loop_control
i,"for (int i = 0; i < expectedCount; i++) {
            Observable
                    .just(Boolean.TRUE, Boolean.FALSE, Boolean.FALSE)
                    .takeWhile(new Predicate<Boolean>() {
                        @Override
                        public boolean test(Boolean value) {
                            return value;
                        }
                    })
                    .toList()
                    .doOnSuccess(new Consumer<List<Boolean>>() {
                        @Override
                        public void accept(List<Boolean> booleans) {
                            count.incrementAndGet();
                        }
                    })
                    .subscribe();
        }",loop_control
i,"for (int i = 2; i < 10; i++) {
            Observable<Integer>[] obs = new Observable[i];
            Arrays.fill(obs, Observable.just(1));

            Integer[] expected = new Integer[i];
            Arrays.fill(expected, 1);

            Method m = Observable.class.getMethod(""concatArrayEager"", ObservableSource[].class);

            TestObserver<Integer> to = TestObserver.create();

            ((Observable<Integer>)m.invoke(null, new Object[]{obs})).subscribe(to);

            to.assertValues(expected);
            to.assertNoErrors();
            to.assertComplete();
        }",loop_control
i,"for (int i = 0; i < TestHelper.RACE_DEFAULT_LOOPS; i++) {
            List<Throwable> errors = TestHelper.trackPluginErrors();
            try {
                final PublishSubject<Integer> ps1 = PublishSubject.create();
                final PublishSubject<Integer> ps2 = PublishSubject.create();

                TestObserverEx<Integer> to = ps1.concatMapEager(new Function<Integer, ObservableSource<Integer>>() {
                    @Override
                    public ObservableSource<Integer> apply(Integer v) throws Exception {
                        return ps2;
                    }
                }).to(TestHelper.<Integer>testConsumer());

                final TestException ex1 = new TestException();
                final TestException ex2 = new TestException();

                ps1.onNext(1);

                Runnable r1 = new Runnable() {
                    @Override
                    public void run() {
                        ps1.onError(ex1);
                    }
                };
                Runnable r2 = new Runnable() {
                    @Override
                    public void run() {
                        ps2.onError(ex2);
                    }
                };

                TestHelper.race(r1, r2);

                to.assertSubscribed().assertNoValues().assertNotComplete();

                Throwable ex = to.errors().get(0);

                if (ex instanceof CompositeException) {
                    List<Throwable> es = TestHelper.errorList(to);
                    TestHelper.assertError(es, 0, TestException.class);
                    TestHelper.assertError(es, 1, TestException.class);
                } else {
                    to.assertError(TestException.class);
                    if (!errors.isEmpty()) {
                        TestHelper.assertUndeliverable(errors, 0, TestException.class);
                    }
                }
            } finally {
                RxJavaPlugins.reset();
            }
        }",loop_control
i,"for (int i = 0; i < TestHelper.RACE_DEFAULT_LOOPS; i++) {
            final PublishSubject<Integer> ps1 = PublishSubject.create();

            final TestObserver<Integer> to = ps1.concatMapEager(new Function<Integer, ObservableSource<Integer>>() {
                @Override
                public ObservableSource<Integer> apply(Integer v) throws Exception {
                    return Observable.never();
                }
            }).test();

            Runnable r1 = new Runnable() {
                @Override
                public void run() {
                    ps1.onNext(1);
                }
            };
            Runnable r2 = new Runnable() {
                @Override
                public void run() {
                    to.dispose();
                }
            };

            TestHelper.race(r1, r2);

            to.assertEmpty();
        }",loop_control
i,"for (int i = 0; i < 100; i++) {
            List<Integer> lst = new ArrayList<>();
            list[i] = lst;
            for (int k = 1; k <= 10; k++) {
                lst.add((i) * 10 + k);
            }
        }",loop_control
k,"for (int k = 1; k <= 10; k++) {
                lst.add((i) * 10 + k);
            }",loop_control
i,"for (int i = 0; i < numbers.length; i++) {
            numbers[i] = i + 1;
        }",loop_control
iters,"for (int iters = 0; iters < NITERS; iters++) {
            final CountDownLatch innerLatch = new CountDownLatch(1);
            final PublishSubject<Void> s = PublishSubject.create();
            final AtomicBoolean completed = new AtomicBoolean();
            Observable.fromArray(numbers)
                    .takeUntil(s)
                    .window(50)
                    .flatMap(new Function<Observable<Integer>, Observable<Object>>() {
                        @Override
                        public Observable<Object> apply(Observable<Integer> integerObservable) {
                                return integerObservable
                                        .subscribeOn(Schedulers.computation())
                                        .map(new Function<Integer, Object>() {
                                            @Override
                                            public Object apply(Integer integer) {
                                                    if (integer >= 5 && completed.compareAndSet(false, true)) {
                                                        s.onComplete();
                                                    }
                                                    // do some work
                                                    Math.pow(Math.random(), Math.random());
                                                    return integer * 2;
                                            }
                                        });
                        }
                    })
                    .toList()
                    .doOnSuccess(new Consumer<List<Object>>() {
                        @Override
                        public void accept(List<Object> integers) {
                                counter.incrementAndGet();
                                latch.countDown();
                                innerLatch.countDown();
                        }
                    })
                    .subscribe();
            if (!innerLatch.await(30, TimeUnit.SECONDS)) {
                Assert.fail(""Failed inner latch wait, iteration "" + iters);
            }
        }",loop_control
it,"{
        TestScheduler scheduler = new TestScheduler();

        Observable<Long> source = Observable.interval(1, TimeUnit.SECONDS, scheduler).take(10);

        Iterable<Long> iter = source.blockingLatest();

        Iterator<Long> it = iter.iterator();

        // only 9 because take(10) will immediately call onComplete when receiving the 10th item
        // which onComplete will overwrite the previous value
        for (int i = 0; i < 9; i++) {
            scheduler.advanceTimeBy(1, TimeUnit.SECONDS);

            Assert.assertTrue(it.hasNext());

            Assert.assertEquals(Long.valueOf(i), it.next());
        }

        scheduler.advanceTimeBy(1, TimeUnit.SECONDS);
        Assert.assertFalse(it.hasNext());
    }",iterator
i,"for (int i = 0; i < 9; i++) {
            scheduler.advanceTimeBy(1, TimeUnit.SECONDS);

            Assert.assertTrue(it.hasNext());

            Assert.assertEquals(Long.valueOf(i), it.next());
        }",loop_control
j,"for (int j = 0; j < 3; j++) {
            Iterator<Long> it = iter.iterator();

            // only 9 because take(10) will immediately call onComplete when receiving the 10th item
            // which onComplete will overwrite the previous value
            for (int i = 0; i < 9; i++) {
                scheduler.advanceTimeBy(1, TimeUnit.SECONDS);

                Assert.assertTrue(it.hasNext());

                Assert.assertEquals(Long.valueOf(i), it.next());
            }

            scheduler.advanceTimeBy(1, TimeUnit.SECONDS);
            Assert.assertFalse(it.hasNext());
        }",loop_control
i,"for (int i = 0; i < 9; i++) {
                scheduler.advanceTimeBy(1, TimeUnit.SECONDS);

                Assert.assertTrue(it.hasNext());

                Assert.assertEquals(Long.valueOf(i), it.next());
            }",loop_control
it,"{
        Observable<Long> source = Observable.<Long> empty();

        Iterable<Long> iter = source.blockingLatest();

        Iterator<Long> it = iter.iterator();

        Assert.assertFalse(it.hasNext());

        it.next();
    }",iterator
it,"{
        TestScheduler scheduler = new TestScheduler();

        Observable<Long> source = Observable.interval(1, TimeUnit.SECONDS, scheduler).take(10);

        Iterable<Long> iter = source.blockingLatest();

        Iterator<Long> it = iter.iterator();

        // only 9 because take(10) will immediately call onComplete when receiving the 10th item
        // which onComplete will overwrite the previous value
        for (int i = 0; i < 10; i++) {
            scheduler.advanceTimeBy(1, TimeUnit.SECONDS);

            Assert.assertEquals(Long.valueOf(i), it.next());
        }
    }",iterator
i,"for (int i = 0; i < 10; i++) {
            scheduler.advanceTimeBy(1, TimeUnit.SECONDS);

            Assert.assertEquals(Long.valueOf(i), it.next());
        }",loop_control
it,"{
        TestScheduler scheduler = new TestScheduler();

        Observable<Long> source = Observable.<Long> error(new RuntimeException(""Forced failure!"")).subscribeOn(scheduler);

        Iterable<Long> iter = source.blockingLatest();

        Iterator<Long> it = iter.iterator();

        scheduler.advanceTimeBy(1, TimeUnit.SECONDS);

        it.hasNext();
    }",iterator
it,"{
        TestScheduler scheduler = new TestScheduler();

        Observable<Long> source = Observable.interval(1, TimeUnit.SECONDS, scheduler).take(10);

        Iterable<Long> iter = source.blockingLatest();

        Iterator<Long> it = iter.iterator();

        // only 9 because take(10) will immediately call onComplete when receiving the 10th item
        // which onComplete will overwrite the previous value
        for (int i = 0; i < 9; i++) {
            scheduler.advanceTimeBy(1, TimeUnit.SECONDS);

            Assert.assertTrue(it.hasNext());

            Assert.assertEquals(Long.valueOf(i), it.next());
        }

        scheduler.advanceTimeBy(1, TimeUnit.SECONDS);
        Assert.assertFalse(it.hasNext());
    }",iterator
i,"for (int i = 0; i < 9; i++) {
            scheduler.advanceTimeBy(1, TimeUnit.SECONDS);

            Assert.assertTrue(it.hasNext());

            Assert.assertEquals(Long.valueOf(i), it.next());
        }",loop_control
j,"for (int j = 0; j < 3; j++) {
            Iterator<Long> it = iter.iterator();

            // only 9 because take(10) will immediately call onComplete when receiving the 10th item
            // which onComplete will overwrite the previous value
            for (int i = 0; i < 9; i++) {
                scheduler.advanceTimeBy(1, TimeUnit.SECONDS);

                Assert.assertTrue(it.hasNext());

                Assert.assertEquals(Long.valueOf(i), it.next());
            }

            scheduler.advanceTimeBy(1, TimeUnit.SECONDS);
            Assert.assertFalse(it.hasNext());
        }",loop_control
i,"for (int i = 0; i < 9; i++) {
                scheduler.advanceTimeBy(1, TimeUnit.SECONDS);

                Assert.assertTrue(it.hasNext());

                Assert.assertEquals(Long.valueOf(i), it.next());
            }",loop_control
it,"{
        Observable<Long> source = Observable.<Long> empty();

        Iterable<Long> iter = source.blockingLatest();

        Iterator<Long> it = iter.iterator();

        Assert.assertFalse(it.hasNext());

        it.next();
    }",iterator
it,"{
        TestScheduler scheduler = new TestScheduler();

        Observable<Long> source = Observable.interval(1, TimeUnit.SECONDS, scheduler).take(10);

        Iterable<Long> iter = source.blockingLatest();

        Iterator<Long> it = iter.iterator();

        // only 9 because take(10) will immediately call onComplete when receiving the 10th item
        // which onComplete will overwrite the previous value
        for (int i = 0; i < 10; i++) {
            scheduler.advanceTimeBy(1, TimeUnit.SECONDS);

            Assert.assertEquals(Long.valueOf(i), it.next());
        }
    }",iterator
i,"for (int i = 0; i < 10; i++) {
            scheduler.advanceTimeBy(1, TimeUnit.SECONDS);

            Assert.assertEquals(Long.valueOf(i), it.next());
        }",loop_control
it,"{
        TestScheduler scheduler = new TestScheduler();

        Observable<Long> source = Observable.<Long> error(new RuntimeException(""Forced failure!"")).subscribeOn(scheduler);

        Iterable<Long> iter = source.blockingLatest();

        Iterator<Long> it = iter.iterator();

        scheduler.advanceTimeBy(1, TimeUnit.SECONDS);

        it.hasNext();
    }",iterator
it,"{
        TestScheduler scheduler = new TestScheduler();

        Observable<Long> source = Observable.<Long> error(new RuntimeException(""Forced failure!"")).subscribeOn(scheduler);

        Iterable<Long> iter = source.blockingLatest();
        Iterator<Long> it = iter.iterator();

        scheduler.advanceTimeBy(1, TimeUnit.SECONDS);

        it.next();
    }",iterator
it,"{
        PublishSubject<Integer> source = PublishSubject.create();
        Observable<Integer> blocker = source;

        Iterable<Integer> iter = blocker.blockingLatest();
        Iterator<Integer> it = iter.iterator();

        source.onNext(1);

        Assert.assertEquals(Integer.valueOf(1), it.next());

        source.onNext(2);
        source.onNext(3);

        Assert.assertEquals(Integer.valueOf(3), it.next());

        source.onNext(4);
        source.onNext(5);
        source.onNext(6);

        Assert.assertEquals(Integer.valueOf(6), it.next());

        source.onNext(7);
        source.onComplete();

        Assert.assertFalse(it.hasNext());
    }",iterator
i,"for (int i = 0; i < 3; i++) {
            try {
                it.hasNext();
                fail(""Should have thrown"");
            } catch (TestException ex) {
                // expected
            }
        }",loop_control
it,"{
        Iterator<Object> it = Observable.error(new TestException()).blockingLatest().iterator();

        for (int i = 0; i < 3; i++) {
            try {
                it.hasNext();
                fail(""Should have thrown"");
            } catch (TestException ex) {
                // expected
            }
        }
    }",iterator
it,"{
        Iterator<Object> it = Observable.never().blockingLatest().iterator();

        Thread.currentThread().interrupt();

        try {
            it.hasNext();
        } catch (RuntimeException ex) {
            assertTrue(ex.toString(), ex.getCause() instanceof InterruptedException);
        }
        Thread.interrupted();
    }",iterator
it,"{
        Iterator<Object> it = Observable.never().blockingLatest().iterator();

        List<Throwable> errors = TestHelper.trackPluginErrors();
        try {
            ((Observer<Object>)it).onError(new TestException());

            TestHelper.assertUndeliverable(errors, 0, TestException.class);
        } finally {
            RxJavaPlugins.reset();
        }
    }",iterator
s,"for (String s : values) {
                            if (""fail"".equals(s)) {
                                throw new RuntimeException(""Forced Failure"");
                            }
                            System.out.println(""TestObservable onNext: "" + s);
                            observer.onNext(s);
                        }",iterator
arg,"for (String arg : args) {
            list.add(arg);
        }",iterator
i,"for (int i = 0; i < TestHelper.RACE_DEFAULT_LOOPS; i++) {
            final TestScheduler scheduler = new TestScheduler();

            final PublishSubject<Object> ps = PublishSubject.create();

            TestObserver<List<Object>> to = ps.buffer(1, TimeUnit.SECONDS, scheduler, 5).test();

            ps.onNext(1);
            ps.onNext(2);
            ps.onNext(3);
            ps.onNext(4);

            Runnable r1 = new Runnable() {
                @Override
                public void run() {
                    ps.onNext(5);
                }
            };

            Runnable r2 = new Runnable() {
                @Override
                public void run() {
                    scheduler.advanceTimeBy(1, TimeUnit.SECONDS);
                }
            };

            TestHelper.race(r1, r2);

            ps.onComplete();

            int items = 0;
            for (List<Object> o : to.values()) {
                items += o.size();
            }

            assertEquals(""Round: "" + i, 5, items);
        }",loop_control
o,"for (List<Object> o : to.values()) {
                items += o.size();
            }",iterator
i,"for (int i = 0; i < TestHelper.RACE_DEFAULT_LOOPS; i++) {
            BehaviorSubject<Integer> bs = BehaviorSubject.createDefault(1);
            PublishSubject<Integer> ps = PublishSubject.create();

            TestObserver<List<Integer>> to = bs
                    .buffer(BehaviorSubject.createDefault(0), v -> ps)
                    .test();

            TestHelper.race(
                    () -> bs.onComplete(),
                    () -> ps.onComplete()
            );

            to.assertResult(Arrays.asList(1));
        }",loop_control
i,"for (int i = 0; i < 100; i++) {
            List<Observable<String>> os = new ArrayList<>();
            os.add(Observable.just(""one"", ""two"", ""three"", ""four"", ""five"").subscribeOn(Schedulers.newThread()));
            os.add(Observable.just(""one"", ""two"", ""three"", ""four"", ""five"").subscribeOn(Schedulers.newThread()));
            os.add(Observable.just(""one"", ""two"", ""three"", ""four"", ""five"").subscribeOn(Schedulers.newThread()));

            List<String> expected = Arrays.asList(""one"", ""two"", ""three"", ""four"", ""five"", ""one"", ""two"", ""three"", ""four"", ""five"", ""one"", ""two"", ""three"", ""four"", ""five"");
            Iterator<String> iter = Observable.merge(os, 1).blockingIterable().iterator();
            List<String> actual = new ArrayList<>();
            while (iter.hasNext()) {
                actual.add(iter.next());
            }
            assertEquals(expected, actual);
        }",loop_control
times,"for (int times = 0; times < 100; times++) {
            int observableCount = 100;
            // Test maxConcurrent from 2 to 12
            int maxConcurrent = 2 + (times % 10);
            AtomicInteger subscriptionCount = new AtomicInteger(0);

            List<Observable<String>> os = new ArrayList<>();
            List<SubscriptionCheckObservable> scos = new ArrayList<>();
            for (int i = 0; i < observableCount; i++) {
                SubscriptionCheckObservable sco = new SubscriptionCheckObservable(subscriptionCount, maxConcurrent);
                scos.add(sco);
                os.add(Observable.unsafeCreate(sco));
            }

            Iterator<String> iter = Observable.merge(os, maxConcurrent).blockingIterable().iterator();
            List<String> actual = new ArrayList<>();
            while (iter.hasNext()) {
                actual.add(iter.next());
            }
            //            System.out.println(""actual: "" + actual);
            assertEquals(5 * observableCount, actual.size());
            for (SubscriptionCheckObservable sco : scos) {
                assertFalse(sco.failed);
            }
        }",loop_control
i,"for (int i = 0; i < observableCount; i++) {
                SubscriptionCheckObservable sco = new SubscriptionCheckObservable(subscriptionCount, maxConcurrent);
                scos.add(sco);
                os.add(Observable.unsafeCreate(sco));
            }",loop_control
sco,"for (int i = 0; i < observableCount; i++) {
                SubscriptionCheckObservable sco = new SubscriptionCheckObservable(subscriptionCount, maxConcurrent);
                scos.add(sco);
                os.add(Observable.unsafeCreate(sco));
            }",iterator
sco,"for (SubscriptionCheckObservable sco : scos) {
                assertFalse(sco.failed);
            }",iterator
i,"for (int i = 0; i < n; i++) {
            sourceList.add(Observable.just(i));
        }",loop_control
it,"{
        int n = 10000;
        List<Observable<Integer>> sourceList = new ArrayList<>(n);
        for (int i = 0; i < n; i++) {
            sourceList.add(Observable.just(i));
        }
        Iterator<Integer> it = Observable.merge(Observable.fromIterable(sourceList), 1).blockingIterable().iterator();
        int j = 0;
        while (it.hasNext()) {
            assertEquals((Integer)j, it.next());
            j++;
        }
        assertEquals(j, n);
    }",iterator
i,"for (int i = 0; i < n; i++) {
            sourceList.add(Observable.just(i));
        }",loop_control
it,"{
        int n = 10000;
        List<Observable<Integer>> sourceList = new ArrayList<>(n);
        for (int i = 0; i < n; i++) {
            sourceList.add(Observable.just(i));
        }
        Iterator<Integer> it = Observable.merge(Observable.fromIterable(sourceList), 1).take(n / 2).blockingIterable().iterator();
        int j = 0;
        while (it.hasNext()) {
            assertEquals((Integer)j, it.next());
            j++;
        }
        assertEquals(j, n / 2);
    }",iterator
i,"for (int i = 1; i < 100; i++) {
            TestObserverEx<Integer> to = new TestObserverEx<>();
            List<Observable<Integer>> sourceList = new ArrayList<>(i);
            List<Integer> result = new ArrayList<>(i);
            for (int j = 1; j <= i; j++) {
                sourceList.add(Observable.just(j));
                result.add(j);
            }

            Observable.merge(sourceList, i).subscribe(to);

            to.assertNoErrors();
            to.assertTerminated();
            to.assertValueSequence(result);
        }",loop_control
j,"for (int j = 1; j <= i; j++) {
                sourceList.add(Observable.just(j));
                result.add(j);
            }",loop_control
i,"for (int i = 2; i < 100; i++) {
            TestObserverEx<Integer> to = new TestObserverEx<>();
            List<Observable<Integer>> sourceList = new ArrayList<>(i);
            List<Integer> result = new ArrayList<>(i);
            for (int j = 1; j <= i; j++) {
                sourceList.add(Observable.just(j));
                result.add(j);
            }

            Observable.merge(sourceList, i - 1).subscribe(to);

            to.assertNoErrors();
            to.assertTerminated();
            to.assertValueSequence(result);
        }",loop_control
j,"for (int j = 1; j <= i; j++) {
                sourceList.add(Observable.just(j));
                result.add(j);
            }",loop_control
i,"for (int i = 0; i < 200; i++) {
            simpleAsync();
            int c1 = ios.size();
            if (c + 60 < c1) {
                throw new AssertionError(""Worker leak: "" + c + "" - "" + c1);
            }
        }",loop_control
i,"for (int i = 1; i < 50; i++) {
            TestObserver<Integer> to = new TestObserver<>();
            List<Observable<Integer>> sourceList = new ArrayList<>(i);
            Set<Integer> expected = new HashSet<>(i);
            for (int j = 1; j <= i; j++) {
                sourceList.add(Observable.just(j).subscribeOn(Schedulers.io()));
                expected.add(j);
            }

            Observable.merge(sourceList, i).subscribe(to);

            to.awaitDone(1, TimeUnit.SECONDS);
            to.assertNoErrors();
            Set<Integer> actual = new HashSet<>(to.values());

            assertEquals(expected, actual);
        }",loop_control
j,"for (int j = 1; j <= i; j++) {
                sourceList.add(Observable.just(j).subscribeOn(Schedulers.io()));
                expected.add(j);
            }",loop_control
i,"for (int i = 0; i < 200; i++) {
            simpleOneLessAsync();
        }",loop_control
i,"for (int i = 2; i < 50; i++) {
            if (System.currentTimeMillis() - t > TimeUnit.SECONDS.toMillis(9)) {
                break;
            }
            TestObserver<Integer> to = new TestObserver<>();
            List<Observable<Integer>> sourceList = new ArrayList<>(i);
            Set<Integer> expected = new HashSet<>(i);
            for (int j = 1; j <= i; j++) {
                sourceList.add(Observable.just(j).subscribeOn(Schedulers.io()));
                expected.add(j);
            }

            Observable.merge(sourceList, i - 1).subscribe(to);

            to.awaitDone(1, TimeUnit.SECONDS);
            to.assertNoErrors();
            Set<Integer> actual = new HashSet<>(to.values());

            assertEquals(expected, actual);
        }",loop_control
j,"for (int j = 1; j <= i; j++) {
                sourceList.add(Observable.just(j).subscribeOn(Schedulers.io()));
                expected.add(j);
            }",loop_control
t,"for (Throwable t : to.errors()) {
                t.printStackTrace();
            }",iterator
j,"for (int j = 0; j < TestHelper.RACE_LONG_LOOPS; j++) {
            List<Throwable> errors = TestHelper.trackPluginErrors();
            try {
                final UnicastSubject<Integer> us = UnicastSubject.create();

                TestObserver<Integer> to = us.hide()
                .observeOn(Schedulers.io())
                .observeOn(Schedulers.single())
                .unsubscribeOn(Schedulers.computation())
                .firstOrError()
                .test();

                for (int i = 0; us.hasObservers() && i < 10000; i++) {
                    us.onNext(i);
                }

                to
                .awaitDone(5, TimeUnit.SECONDS)
                ;

                if (!errors.isEmpty()) {
                    throw new CompositeException(errors);
                }

                to.assertResult(0);
            } finally {
                RxJavaPlugins.reset();
            }
        }",loop_control
i,"for (int i = 0; us.hasObservers() && i < 10000; i++) {
                    us.onNext(i);
                }",loop_control
arg,"for (String arg : args) {
            list.add(arg);
        }",iterator
i,"for (int i = 0; i < TestHelper.RACE_DEFAULT_LOOPS; i++) {
                AtomicReference<Observer<? super Integer>> ref1 = new AtomicReference<>();
                AtomicReference<Observer<? super Integer>> ref2 = new AtomicReference<>();

                Observable<Integer> o1 = Observable.<Integer>unsafeCreate(ref1::set);
                Observable<Integer> o2 = Observable.<Integer>unsafeCreate(ref2::set);

                TestObserver<Observable<Integer>> to = BehaviorSubject.createDefault(1)
                .window(o1, v -> o2)
                .doOnNext(w -> w.test())
                .test();

                ref1.get().onSubscribe(Disposable.empty());
                ref1.get().onNext(1);
                ref2.get().onSubscribe(Disposable.empty());

                TestHelper.race(
                        () -> ref1.get().onError(ex1),
                        () -> ref2.get().onError(ex2)
                );

                to.assertError(RuntimeException.class);

                if (!errors.isEmpty()) {
                    TestHelper.assertUndeliverable(errors, 0, TestException.class);
                }

                errors.clear();
            }",loop_control
i,"for (int i = 0; i < 1000; i++) {
            assertEquals((Integer)i, onNextEvents.get(i));
        }",loop_control
i,"for (int i = 0; i < 100; i++) {
            TestObserver<Integer> to1 = new TestObserver<>();

            ObservableCache<Integer> cached = new ObservableCache<>(source, 16);

            cached.observeOn(Schedulers.computation()).subscribe(to1);

            to1.awaitDone(2, TimeUnit.SECONDS);
            to1.assertNoErrors();
            to1.assertComplete();
            assertEquals(10000, to1.values().size());

            TestObserver<Integer> to2 = new TestObserver<>();
            cached.observeOn(Schedulers.computation()).subscribe(to2);

            to2.awaitDone(2, TimeUnit.SECONDS);
            to2.assertNoErrors();
            to2.assertComplete();
            assertEquals(10000, to2.values().size());
        }",loop_control
i,"for (int i = 0; i < 100; i++) {
            TestObserver<Long> to = new TestObserver<>();
            list.add(to);
            output.skip(i * 10).take(10).subscribe(to);
        }",loop_control
i,"for (int i = 0; i < 10; i++) {
            expected.add((long)(i - 10));
        }",loop_control
i,"for (int i = j * 10; i < j * 10 + 10; i++) {
                expected.set(i - j * 10, (long)i);
            }",loop_control
to,"for (int i = 0; i < 100; i++) {
            TestObserver<Long> to = new TestObserver<>();
            list.add(to);
            output.skip(i * 10).take(10).subscribe(to);
        }",iterator
to,"for (TestObserver<Long> to : list) {
            to.awaitDone(3, TimeUnit.SECONDS);
            to.assertNoErrors();
            to.assertComplete();

            for (int i = j * 10; i < j * 10 + 10; i++) {
                expected.set(i - j * 10, (long)i);
            }

            to.assertValueSequence(expected);

            j++;
        }",iterator
j,"{
        Observable<Long> source = Observable.interval(1, 1, TimeUnit.MILLISECONDS)
                .take(1000)
                .subscribeOn(Schedulers.io());
        ObservableCache<Long> cached = new ObservableCache<>(source, 16);

        Observable<Long> output = cached.observeOn(Schedulers.computation());

        List<TestObserver<Long>> list = new ArrayList<>(100);
        for (int i = 0; i < 100; i++) {
            TestObserver<Long> to = new TestObserver<>();
            list.add(to);
            output.skip(i * 10).take(10).subscribe(to);
        }

        List<Long> expected = new ArrayList<>();
        for (int i = 0; i < 10; i++) {
            expected.add((long)(i - 10));
        }
        int j = 0;
        for (TestObserver<Long> to : list) {
            to.awaitDone(3, TimeUnit.SECONDS);
            to.assertNoErrors();
            to.assertComplete();

            for (int i = j * 10; i < j * 10 + 10; i++) {
                expected.set(i - j * 10, (long)i);
            }

            to.assertValueSequence(expected);

            j++;
        }
    }",loop_control
i,"for (int i = 0; i < m; i++) {
                    t.onNext(i);
                }",loop_control
i,"for (int i = 0; i < TestHelper.RACE_DEFAULT_LOOPS; i++) {
            final PublishSubject<Integer> ps = PublishSubject.<Integer>create();

            final Observable<Integer> cache = ps.cache();

            cache.test();

            final TestObserverEx<Integer> to = new TestObserverEx<>();

            Runnable r1 = new Runnable() {
                @Override
                public void run() {
                    cache.subscribe(to);
                }
            };

            Runnable r2 = new Runnable() {
                @Override
                public void run() {
                    for (int j = 0; j < 500; j++) {
                        ps.onNext(j);
                    }
                    ps.onComplete();
                }
            };

            TestHelper.race(r1, r2);

            to
            .awaitDone(5, TimeUnit.SECONDS)
            .assertSubscribed().assertValueCount(500).assertComplete().assertNoErrors();
        }",loop_control
j,"for (int j = 0; j < 500; j++) {
                        ps.onNext(j);
                    }",loop_control
i,"for (int i = 0; i < TestHelper.RACE_DEFAULT_LOOPS; i++) {
            Observable<Object> o = Observable.never().cache();

            TestObserver<Object> to = o.test();

            TestHelper.race(
                    () -> to.dispose(),
                    () -> o.test()
            );
        }",loop_control
i,"for (int i = 1; i < 3; i++) {
            effectCounter.set(0);
            System.out.printf(""- %d -%n"", i);
            result.subscribe(new Consumer<Integer>() {

                @Override
                public void accept(Integer t1) {
                    System.out.println(t1);
                }

            }, new Consumer<Throwable>() {

                @Override
                public void accept(Throwable t1) {
                    t1.printStackTrace();
                }
            },
            new Action() {
                @Override
                public void run() {
                    System.out.println(""Done"");
                }
            });
            assertEquals(2, effectCounter.get());
        }",loop_control
i,"for (int i = 0; i < 1000; i++) {
            assertEquals((Integer)i, onNextEvents.get(i));
        }",loop_control
i,"for (int i = 0; i < 100; i++) {
            TestObserverEx<Integer> to1 = new TestObserverEx<>();

            Observable<Integer> cached = source.replay().autoConnect();

            cached.observeOn(Schedulers.computation()).subscribe(to1);

            to1.awaitDone(2, TimeUnit.SECONDS);
            to1.assertNoErrors();
            to1.assertTerminated();
            assertEquals(10000, to1.values().size());

            TestObserverEx<Integer> to2 = new TestObserverEx<>();
            cached.observeOn(Schedulers.computation()).subscribe(to2);

            to2.awaitDone(2, TimeUnit.SECONDS);
            to2.assertNoErrors();
            to2.assertTerminated();
            assertEquals(10000, to2.values().size());
        }",loop_control
i,"for (int i = 0; i < 100; i++) {
            TestObserverEx<Long> to = new TestObserverEx<>();
            list.add(to);
            output.skip(i * 10).take(10).subscribe(to);
        }",loop_control
i,"for (int i = 0; i < 10; i++) {
            expected.add((long)(i - 10));
        }",loop_control
i,"for (int i = j * 10; i < j * 10 + 10; i++) {
                expected.set(i - j * 10, (long)i);
            }",loop_control
to,"for (int i = 0; i < 100; i++) {
            TestObserverEx<Long> to = new TestObserverEx<>();
            list.add(to);
            output.skip(i * 10).take(10).subscribe(to);
        }",iterator
to,"for (TestObserverEx<Long> to : list) {
            to.awaitDone(3, TimeUnit.SECONDS);
            to.assertNoErrors();
            to.assertTerminated();

            for (int i = j * 10; i < j * 10 + 10; i++) {
                expected.set(i - j * 10, (long)i);
            }

            to.assertValueSequence(expected);

            j++;
        }",iterator
j,"{
        Observable<Long> source = Observable.interval(1, 1, TimeUnit.MILLISECONDS)
                .take(1000)
                .subscribeOn(Schedulers.io());
        Observable<Long> cached = source.replay().autoConnect();

        Observable<Long> output = cached.observeOn(Schedulers.computation());

        List<TestObserverEx<Long>> list = new ArrayList<>(100);
        for (int i = 0; i < 100; i++) {
            TestObserverEx<Long> to = new TestObserverEx<>();
            list.add(to);
            output.skip(i * 10).take(10).subscribe(to);
        }

        List<Long> expected = new ArrayList<>();
        for (int i = 0; i < 10; i++) {
            expected.add((long)(i - 10));
        }
        int j = 0;
        for (TestObserverEx<Long> to : list) {
            to.awaitDone(3, TimeUnit.SECONDS);
            to.assertNoErrors();
            to.assertTerminated();

            for (int i = j * 10; i < j * 10 + 10; i++) {
                expected.set(i - j * 10, (long)i);
            }

            to.assertValueSequence(expected);

            j++;
        }
    }",loop_control
i,"for (int i = 0; i < m; i++) {
                    t.onNext(i);
                }",loop_control
i,"for (int i = 0; i < TestHelper.RACE_DEFAULT_LOOPS; i++) {
            final ConnectableObservable<Integer> co = Observable.range(1, 3).replay();

            Runnable r = new Runnable() {
                @Override
                public void run() {
                    co.connect();
                }
            };

            TestHelper.race(r, r);
        }",loop_control
i,"for (int i = 0; i < TestHelper.RACE_DEFAULT_LOOPS; i++) {
            final ConnectableObservable<Integer> co = Observable.range(1, 3).replay();

            final TestObserver<Integer> to1 = new TestObserver<>();
            final TestObserver<Integer> to2 = new TestObserver<>();

            Runnable r1 = new Runnable() {
                @Override
                public void run() {
                    co.subscribe(to1);
                }
            };

            Runnable r2 = new Runnable() {
                @Override
                public void run() {
                    co.subscribe(to2);
                }
            };

            TestHelper.race(r1, r2);
        }",loop_control
i,"for (int i = 0; i < TestHelper.RACE_DEFAULT_LOOPS; i++) {
            final ConnectableObservable<Integer> co = Observable.range(1, 3).replay();

            final TestObserver<Integer> to1 = new TestObserver<>();
            final TestObserver<Integer> to2 = new TestObserver<>();

            co.subscribe(to1);

            Runnable r1 = new Runnable() {
                @Override
                public void run() {
                    to1.dispose();
                }
            };

            Runnable r2 = new Runnable() {
                @Override
                public void run() {
                    co.subscribe(to2);
                }
            };

            TestHelper.race(r1, r2);
        }",loop_control
i,"for (int i = 0; i < TestHelper.RACE_DEFAULT_LOOPS; i++) {
            final PublishSubject<Integer> ps = PublishSubject.create();

            final ConnectableObservable<Integer> co = ps.replay();

            final TestObserver<Integer> to1 = new TestObserver<>();

            Runnable r1 = new Runnable() {
                @Override
                public void run() {
                    co.subscribe(to1);
                }
            };

            Runnable r2 = new Runnable() {
                @Override
                public void run() {
                    for (int j = 0; j < 1000; j++) {
                        ps.onNext(j);
                    }
                }
            };

            TestHelper.race(r1, r2);
        }",loop_control
j,"for (int j = 0; j < 1000; j++) {
                        ps.onNext(j);
                    }",loop_control
i,"for (int i = 0; i < TestHelper.RACE_DEFAULT_LOOPS; i++) {
            final PublishSubject<Integer> ps = PublishSubject.create();

            final ConnectableObservable<Integer> co = ps.replay();

            final TestObserver<Integer> to1 = new TestObserver<>();

            co.subscribe(to1);

            Runnable r1 = new Runnable() {
                @Override
                public void run() {
                    to1.dispose();
                }
            };

            Runnable r2 = new Runnable() {
                @Override
                public void run() {
                    for (int j = 0; j < 1000; j++) {
                        ps.onNext(j);
                    }
                }
            };

            TestHelper.race(r1, r2);
        }",loop_control
j,"for (int j = 0; j < 1000; j++) {
                        ps.onNext(j);
                    }",loop_control
i,"for (int i = 0; i < TestHelper.RACE_DEFAULT_LOOPS; i++) {
            final ConnectableObservable<Integer> co = Observable.range(1, 1000).replay();

            final TestObserver<Integer> to1 = new TestObserver<>();

            co.connect();

            Runnable r1 = new Runnable() {
                @Override
                public void run() {
                    co.subscribe(to1);
                }
            };

            Runnable r2 = new Runnable() {
                @Override
                public void run() {
                    to1.dispose();
                }
            };

            TestHelper.race(r1, r2);
        }",loop_control
i,"for (long i = 1; i <= Flowable.bufferSize() * 2 + 1; i++) {
            list.add(i);
        }",loop_control
i,"for (int i = 0; i < TestHelper.RACE_DEFAULT_LOOPS; i++) {
            List<Throwable> errors = TestHelper.trackPluginErrors();
            try {
                final PublishSubject<Integer> ps = PublishSubject.create();

                final Observer<?>[] sub = { null, null };

                final Observable<Integer> pp2 = new Observable<Integer>() {

                    int count;

                    @Override
                    protected void subscribeActual(
                            Observer<? super Integer> observer) {
                        observer.onSubscribe(Disposable.empty());
                        sub[count++] = observer;
                    }
                };

                TestObserver<Integer> to = ps.timeout(Functions.justFunction(pp2)).test();

                ps.onNext(0);

                Runnable r1 = new Runnable() {
                    @Override
                    public void run() {
                        ps.onNext(1);
                    }
                };

                final Throwable ex = new TestException();

                Runnable r2 = new Runnable() {
                    @Override
                    public void run() {
                        sub[0].onError(ex);
                    }
                };

                TestHelper.race(r1, r2);

                to.assertValueAt(0, 0);

                if (!errors.isEmpty()) {
                    TestHelper.assertUndeliverable(errors, 0, TestException.class);
                }
            } finally {
                RxJavaPlugins.reset();
            }
        }",loop_control
i,"for (int i = 0; i < TestHelper.RACE_DEFAULT_LOOPS; i++) {
            List<Throwable> errors = TestHelper.trackPluginErrors();
            try {
                final PublishSubject<Integer> ps = PublishSubject.create();

                final Observer<?>[] sub = { null, null };

                final Observable<Integer> pp2 = new Observable<Integer>() {

                    int count;

                    @Override
                    protected void subscribeActual(
                            Observer<? super Integer> observer) {
                        assertFalse(((Disposable)observer).isDisposed());
                        observer.onSubscribe(Disposable.empty());
                        sub[count++] = observer;
                    }
                };

                TestObserver<Integer> to = ps.timeout(Functions.justFunction(pp2), Observable.<Integer>never()).test();

                ps.onNext(0);

                Runnable r1 = new Runnable() {
                    @Override
                    public void run() {
                        ps.onNext(1);
                    }
                };

                final Throwable ex = new TestException();

                Runnable r2 = new Runnable() {
                    @Override
                    public void run() {
                        sub[0].onError(ex);
                    }
                };

                TestHelper.race(r1, r2);

                to.assertValueAt(0, 0);

                if (!errors.isEmpty()) {
                    TestHelper.assertUndeliverable(errors, 0, TestException.class);
                }
            } finally {
                RxJavaPlugins.reset();
            }
        }",loop_control
i,"for (int i = 0; i < TestHelper.RACE_DEFAULT_LOOPS; i++) {
            List<Throwable> errors = TestHelper.trackPluginErrors();
            try {
                final PublishSubject<Integer> ps = PublishSubject.create();

                final Observer<?>[] sub = { null, null };

                final Observable<Integer> pp2 = new Observable<Integer>() {

                    int count;

                    @Override
                    protected void subscribeActual(
                            Observer<? super Integer> observer) {
                        assertFalse(((Disposable)observer).isDisposed());
                        observer.onSubscribe(Disposable.empty());
                        sub[count++] = observer;
                    }
                };

                TestObserver<Integer> to = ps.timeout(Functions.justFunction(pp2)).test();

                ps.onNext(0);

                final Throwable ex = new TestException();

                Runnable r1 = new Runnable() {
                    @Override
                    public void run() {
                        ps.onError(ex);
                    }
                };

                Runnable r2 = new Runnable() {
                    @Override
                    public void run() {
                        sub[0].onComplete();
                    }
                };

                TestHelper.race(r1, r2);

                to.assertValueAt(0, 0);

                if (!errors.isEmpty()) {
                    TestHelper.assertUndeliverable(errors, 0, TestException.class);
                }
            } finally {
                RxJavaPlugins.reset();
            }
        }",loop_control
i,"for (int i = 0; i < TestHelper.RACE_DEFAULT_LOOPS; i++) {
            List<Throwable> errors = TestHelper.trackPluginErrors();
            try {
                final PublishSubject<Integer> ps = PublishSubject.create();

                final Observer<?>[] sub = { null, null };

                final Observable<Integer> pp2 = new Observable<Integer>() {

                    int count;

                    @Override
                    protected void subscribeActual(
                            Observer<? super Integer> observer) {
                        assertFalse(((Disposable)observer).isDisposed());
                        observer.onSubscribe(Disposable.empty());
                        sub[count++] = observer;
                    }
                };

                TestObserver<Integer> to = ps.timeout(Functions.justFunction(pp2)).test();

                ps.onNext(0);

                Runnable r1 = new Runnable() {
                    @Override
                    public void run() {
                        ps.onComplete();
                    }
                };

                Runnable r2 = new Runnable() {
                    @Override
                    public void run() {
                        sub[0].onComplete();
                    }
                };

                TestHelper.race(r1, r2);

                to.assertValueAt(0, 0);

                if (!errors.isEmpty()) {
                    TestHelper.assertUndeliverable(errors, 0, TestException.class);
                }
            } finally {
                RxJavaPlugins.reset();
            }
        }",loop_control
i,"for (int i = 0; i < TestHelper.RACE_DEFAULT_LOOPS; i++) {
            List<Throwable> errors = TestHelper.trackPluginErrors();
            try {
                final PublishSubject<Integer> ps = PublishSubject.create();

                final Observer<?>[] sub = { null, null };

                final Observable<Integer> pp2 = new Observable<Integer>() {

                    int count;

                    @Override
                    protected void subscribeActual(
                            Observer<? super Integer> observer) {
                        assertFalse(((Disposable)observer).isDisposed());
                        observer.onSubscribe(Disposable.empty());
                        sub[count++] = observer;
                    }
                };

                TestObserver<Integer> to = ps.timeout(Functions.justFunction(pp2), Observable.<Integer>never()).test();

                ps.onNext(0);

                Runnable r1 = new Runnable() {
                    @Override
                    public void run() {
                        ps.onComplete();
                    }
                };

                Runnable r2 = new Runnable() {
                    @Override
                    public void run() {
                        sub[0].onComplete();
                    }
                };

                TestHelper.race(r1, r2);

                to.assertValueAt(0, 0);

                if (!errors.isEmpty()) {
                    TestHelper.assertUndeliverable(errors, 0, TestException.class);
                }
            } finally {
                RxJavaPlugins.reset();
            }
        }",loop_control
item,"for (T item: items) {
            observer.onNext(item);
        }",iterator
item,"{

    final List<T> items;
    final Throwable error;

    Burst(Throwable error, List<T> items) {
        this.error = error;
        this.items = items;
    }

    @Override
    protected void subscribeActual(final Observer<? super T> observer) {
        observer.onSubscribe(Disposable.empty());
        for (T item: items) {
            observer.onNext(item);
        }
        if (error != null) {
            observer.onError(error);
        } else {
            observer.onComplete();
        }
    }

    public static <T> Builder<T> item(T item) {
        return items(item);
    }

    @SafeVarargs
    public static <T> Builder<T> items(T... items) {
        return new Builder<>(Arrays.asList(items));
    }

    public static final class Builder<T> {

        private final List<T> items;
        private Throwable error;

        Builder(List<T> items) {
            this.items = items;
        }

        public Observable<T> error(Throwable e) {
            this.error = e;
            return create();
        }

        public Observable<T> create() {
            return new Burst<>(error, items);
        }

    }

}",iterator
i,"for (int i = 0; i < TestHelper.RACE_DEFAULT_LOOPS; i++) {
            List<Throwable> errors = TestHelper.trackPluginErrors();
            try {

                final PublishSubject<Integer> ps1 = PublishSubject.create();
                final PublishSubject<Integer> ps2 = PublishSubject.create();

                ps1.switchMap(new Function<Integer, ObservableSource<Integer>>() {
                    @Override
                    public ObservableSource<Integer> apply(Integer v) throws Exception {
                        if (v == 1) {
                            return ps2;
                        }
                        return Observable.never();
                    }
                })
                .test();

                Runnable r1 = new Runnable() {
                    @Override
                    public void run() {
                        ps1.onNext(2);
                    }
                };

                final TestException ex = new TestException();

                Runnable r2 = new Runnable() {
                    @Override
                    public void run() {
                        ps2.onError(ex);
                    }
                };

                TestHelper.race(r1, r2);

                for (Throwable e : errors) {
                    assertTrue(e.toString(), e instanceof TestException);
                }
            } finally {
                RxJavaPlugins.reset();
            }
        }",loop_control
e,"for (Throwable e : errors) {
                    assertTrue(e.toString(), e instanceof TestException);
                }",iterator
i,"for (int i = 0; i < TestHelper.RACE_LONG_LOOPS; i++) {
            List<Throwable> errors = TestHelper.trackPluginErrors();
            try {

                final PublishSubject<Integer> ps1 = PublishSubject.create();
                final PublishSubject<Integer> ps2 = PublishSubject.create();

                ps1.switchMap(new Function<Integer, ObservableSource<Integer>>() {
                    @Override
                    public ObservableSource<Integer> apply(Integer v) throws Exception {
                        if (v == 1) {
                            return ps2;
                        }
                        return Observable.never();
                    }
                })
                .test();

                ps1.onNext(1);

                final TestException ex1 = new TestException();

                Runnable r1 = new Runnable() {
                    @Override
                    public void run() {
                        ps1.onError(ex1);
                    }
                };

                final TestException ex2 = new TestException();

                Runnable r2 = new Runnable() {
                    @Override
                    public void run() {
                        ps2.onError(ex2);
                    }
                };

                TestHelper.race(r1, r2);

                for (Throwable e : errors) {
                    assertTrue(e.getCause().toString(), e.getCause() instanceof TestException);
                }
            } finally {
                RxJavaPlugins.reset();
            }
        }",loop_control
e,"for (Throwable e : errors) {
                    assertTrue(e.getCause().toString(), e.getCause() instanceof TestException);
                }",iterator
i,"for (int i = 0; i < TestHelper.RACE_DEFAULT_LOOPS; i++) {
            final PublishSubject<Integer> ps1 = PublishSubject.create();

            final TestObserver<Integer> to = ps1.switchMap(new Function<Integer, ObservableSource<Integer>>() {
                @Override
                public ObservableSource<Integer> apply(Integer v) throws Exception {
                    return Observable.never();
                }
            })
            .test();

            Runnable r1 = new Runnable() {
                @Override
                public void run() {
                    ps1.onNext(2);
                }
            };

            Runnable r2 = new Runnable() {
                @Override
                public void run() {
                    to.dispose();
                }
            };

            TestHelper.race(r1, r2);
        }",loop_control
i,"for (int i = 0; i < TestHelper.RACE_LONG_LOOPS; i++) {
            List<Throwable> errors = TestHelper.trackPluginErrors();
            try {

                final AtomicReference<Observer<? super Integer>> obs1 = new AtomicReference<>();
                final Observable<Integer> ps1 = new Observable<Integer>() {
                    @Override
                    protected void subscribeActual(
                            Observer<? super Integer> observer) {
                        obs1.set(observer);
                    }
                };
                final AtomicReference<Observer<? super Integer>> obs2 = new AtomicReference<>();
                final Observable<Integer> ps2 = new Observable<Integer>() {
                    @Override
                    protected void subscribeActual(
                            Observer<? super Integer> observer) {
                        obs2.set(observer);
                    }
                };

                ps1.switchMap(new Function<Integer, ObservableSource<Integer>>() {
                    @Override
                    public ObservableSource<Integer> apply(Integer v) throws Exception {
                        if (v == 1) {
                            return ps2;
                        }
                        return Observable.never();
                    }
                })
                .test();

                obs1.get().onSubscribe(Disposable.empty());
                obs1.get().onNext(1);

                obs2.get().onSubscribe(Disposable.empty());

                final TestException ex1 = new TestException();

                Runnable r1 = new Runnable() {
                    @Override
                    public void run() {
                        obs1.get().onError(ex1);
                    }
                };

                final TestException ex2 = new TestException();

                Runnable r2 = new Runnable() {
                    @Override
                    public void run() {
                        obs2.get().onError(ex2);
                    }
                };

                TestHelper.race(r1, r2);

                for (Throwable e : errors) {
                    assertTrue(e.toString(), e.getCause() instanceof TestException);
                }
            } finally {
                RxJavaPlugins.reset();
            }
        }",loop_control
e,"for (Throwable e : errors) {
                    assertTrue(e.toString(), e.getCause() instanceof TestException);
                }",iterator
o,"for (Object o : to.values()) {
            assertNotEquals(thread, o);
        }",iterator
i,"for (int i = 0; i < TestHelper.RACE_LONG_LOOPS; i++) {
            AtomicReference<Observer<? super Integer>> ref = new AtomicReference<>();
            Observable<Integer> o = new Observable<Integer>() {
                @Override
                protected void subscribeActual(@NonNull Observer<? super @NonNull Integer> observer) {
                    ref.set(observer);
                }
            };

            TestObserver<Object> to = o.switchMap(v -> Observable.never())
            .test();

            ref.get().onSubscribe(Disposable.empty());

            TestHelper.race(
                    () -> ref.get().onComplete(),
                    () -> to.dispose()
            );
        }",loop_control
i,"for (int i = 0; i < TestHelper.RACE_LONG_LOOPS; i++) {
            AtomicReference<Observer<? super Integer>> ref1 = new AtomicReference<>();
            Observable<Integer> o1 = new Observable<Integer>() {
                @Override
                protected void subscribeActual(@NonNull Observer<? super @NonNull Integer> observer) {
                    ref1.set(observer);
                }
            };
            AtomicReference<Observer<? super Integer>> ref2 = new AtomicReference<>();
            Observable<Integer> o2 = new Observable<Integer>() {
                @Override
                protected void subscribeActual(@NonNull Observer<? super @NonNull Integer> observer) {
                    ref2.set(observer);
                }
            };

            o1.switchMap(v -> o2)
            .test();

            ref1.get().onSubscribe(Disposable.empty());
            ref1.get().onNext(1);
            ref2.get().onSubscribe(Disposable.empty());

            TestHelper.race(
                    () -> ref1.get().onComplete(),
                    () -> ref2.get().onError(ex)
            );
        }",loop_control
i,"for (int i = 0; i < n; i++) {
            Observable.<Integer>create(it -> {
                it.onNext(0);
            })
            .switchMap(v -> createObservable(inner))
            .observeOn(Schedulers.computation())
            .doFinally(() -> {
                outer.incrementAndGet();
            })
            .take(1)
            .blockingSubscribe(v -> { }, Throwable::printStackTrace);
        }",loop_control
i,"for (int i = 0; i < 10; i++) {
            TestObserver<Integer> to = new TestObserver<>();

            o.subscribe(to);

            to.assertValues(1, 2, 3);
            to.assertNoErrors();
            to.assertComplete();
        }",loop_control
iterable,"{
        final AtomicBoolean called = new AtomicBoolean(false);
        Iterable<Integer> iterable = new Iterable<Integer>() {

            @Override
            public Iterator<Integer> iterator() {
                return new Iterator<Integer>() {

                    int count = 1;

                    @Override
                    public void remove() {
                        // ignore
                    }

                    @Override
                    public boolean hasNext() {
                        if (count > 1) {
                            called.set(true);
                            return false;
                        }
                        return true;
                    }

                    @Override
                    public Integer next() {
                        return count++;
                    }

                };
            }
        };
        Observable.fromIterable(iterable).take(1).subscribe();
        assertFalse(called.get());
    }",iterator
iterable,"{
        final AtomicBoolean called = new AtomicBoolean(false);
        Iterable<Integer> iterable = new Iterable<Integer>() {

            @Override
            public Iterator<Integer> iterator() {
                return new Iterator<Integer>() {

                    @Override
                    public void remove() {
                        // ignore
                    }

                    int count = 1;

                    @Override
                    public boolean hasNext() {
                        if (count > 1) {
                            called.set(true);
                            return false;
                        }
                        return true;
                    }

                    @Override
                    public Integer next() {
                        return count++;
                    }

                };
            }
        };
        Observable.fromIterable(iterable).subscribe(new DefaultObserver<Integer>() {

            @Override
            public void onComplete() {

            }

            @Override
            public void onError(Throwable e) {

            }

            @Override
            public void onNext(Integer t) {
                // unsubscribe on first emission
                cancel();
            }
        });
        assertFalse(called.get());
    }",iterator
i,"for (int i = 0; i < 1000; i++) {
            for (int j = 1; j < 6; j++) {
                List<TestObserverEx<Integer>> tos = new ArrayList<>();
                for (int k = 1; k < j; k++) {
                    TestObserverEx<Integer> to = new TestObserverEx<>();
                    tos.add(to);
                    obs.subscribe(to);
                }

                Disposable connection = co.connect();

                for (TestObserverEx<Integer> to : tos) {
                    to.awaitDone(2, TimeUnit.SECONDS);
                    to.assertTerminated();
                    to.assertNoErrors();
                    assertEquals(1000, to.values().size());
                }
                connection.dispose();
            }
        }",loop_control
j,"for (int j = 1; j < 6; j++) {
                List<TestObserverEx<Integer>> tos = new ArrayList<>();
                for (int k = 1; k < j; k++) {
                    TestObserverEx<Integer> to = new TestObserverEx<>();
                    tos.add(to);
                    obs.subscribe(to);
                }

                Disposable connection = co.connect();

                for (TestObserverEx<Integer> to : tos) {
                    to.awaitDone(2, TimeUnit.SECONDS);
                    to.assertTerminated();
                    to.assertNoErrors();
                    assertEquals(1000, to.values().size());
                }
                connection.dispose();
            }",loop_control
k,"for (int k = 1; k < j; k++) {
                    TestObserverEx<Integer> to = new TestObserverEx<>();
                    tos.add(to);
                    obs.subscribe(to);
                }",loop_control
to,"for (int k = 1; k < j; k++) {
                    TestObserverEx<Integer> to = new TestObserverEx<>();
                    tos.add(to);
                    obs.subscribe(to);
                }",iterator
to,"for (TestObserverEx<Integer> to : tos) {
                    to.awaitDone(2, TimeUnit.SECONDS);
                    to.assertTerminated();
                    to.assertNoErrors();
                    assertEquals(1000, to.values().size());
                }",iterator
i,"for (int i = 0; i < TestHelper.RACE_DEFAULT_LOOPS; i++) {

            final ConnectableObservable<Integer> co = Observable.<Integer>empty().publish();

            co.connect();

            Runnable r1 = new Runnable() {
                @Override
                public void run() {
                    co.test();
                }
            };

            TestHelper.race(r1, r1);
        }",loop_control
i,"for (int i = 0; i < TestHelper.RACE_DEFAULT_LOOPS; i++) {

            final ConnectableObservable<Integer> co = Observable.<Integer>empty().publish();

            Runnable r1 = new Runnable() {
                @Override
                public void run() {
                    co.connect();
                }
            };

            TestHelper.race(r1, r1);
        }",loop_control
i,"for (int i = 0; i < TestHelper.RACE_DEFAULT_LOOPS; i++) {

            final ConnectableObservable<Integer> co = Observable.<Integer>empty().publish();

            final TestObserver<Integer> to = co.test();

            final TestObserver<Integer> to2 = new TestObserver<>();

            Runnable r1 = new Runnable() {
                @Override
                public void run() {
                    co.subscribe(to2);
                }
            };

            Runnable r2 = new Runnable() {
                @Override
                public void run() {
                    to.dispose();
                }
            };

            TestHelper.race(r1, r2);
        }",loop_control
i,"for (int i = 0; i < TestHelper.RACE_DEFAULT_LOOPS; i++) {

            final PublishSubject<Integer> ps = PublishSubject.create();

            final ConnectableObservable<Integer> co = ps.publish();

            final TestObserver<Integer> to = co.test();

            Runnable r1 = new Runnable() {
                @Override
                public void run() {
                    ps.onNext(1);
                }
            };

            Runnable r2 = new Runnable() {
                @Override
                public void run() {
                    to.dispose();
                }
            };

            TestHelper.race(r1, r2);
        }",loop_control
i,"for (int i = 0; i < TestHelper.RACE_DEFAULT_LOOPS; i++) {

            final PublishSubject<Integer> ps = PublishSubject.create();

            final ConnectableObservable<Integer> co = ps.publish();

            final Disposable d = co.connect();
            final TestObserver<Integer> to = new TestObserver<>();

            Runnable r1 = new Runnable() {
                @Override
                public void run() {
                    d.dispose();
                }
            };

            Runnable r2 = new Runnable() {
                @Override
                public void run() {
                    co.subscribe(to);
                }
            };

            TestHelper.race(r1, r2);
        }",loop_control
i,"for (int i = 0; i < TestHelper.RACE_LONG_LOOPS; i++) {
            final ConnectableObservable<Integer> co =
                    new ObservablePublish<>(Observable.<Integer>never());

            Runnable r = new Runnable() {
                @Override
                public void run() {
                    co.connect();
                }
            };

            TestHelper.race(r, r);
        }",loop_control
i,"for (int i = 0; i < 1000; i++) {
                Observable.timer(0, TimeUnit.MILLISECONDS).blockingFirst();
            }",loop_control
s,"for (Scheduler s : new Scheduler[] { Schedulers.single(), Schedulers.computation(), Schedulers.newThread(), Schedulers.io(), Schedulers.from(exec, true) }) {
                final AtomicBoolean interrupted = new AtomicBoolean();
                TestObserver<Long> to = Observable.timer(1, TimeUnit.MILLISECONDS, s)
                .map(new Function<Long, Long>() {
                    @Override
                    public Long apply(Long v) throws Exception {
                        try {
                        Thread.sleep(3000);
                        } catch (InterruptedException ex) {
                            interrupted.set(true);
                        }
                        return v;
                    }
                })
                .test();

                Thread.sleep(500);

                to.dispose();

                Thread.sleep(500);

                assertTrue(s.getClass().getSimpleName(), interrupted.get());
            }",iterator
arg,"for (String arg : args) {
            list.add(arg);
        }",iterator
d,"{
                Disposable d = Disposable.empty();
                observer.onSubscribe(d);
                while (!d.isDisposed()) {
                    // burst some number of items
                    for (int i = 0; i < Math.random() * 20; i++) {
                        observer.onNext(i);
                    }
                    try {
                        // sleep for a random amount of time
                        // NOTE: Only using Thread.sleep here as an artificial demo.
                        Thread.sleep((long) (Math.random() * 200));
                    } catch (Exception e) {
                        // do nothing
                    }
                }
                System.out.println(""Hot done."");
            }",maybe_loop_control
i,"for (int i = 0; i < Math.random() * 20; i++) {
                        observer.onNext(i);
                    }",loop_control
i,"for (int i = 0; i < 11; i++) {
            TestHelper.assertError(errors, i, TestException.class);
        }",loop_control
i,"for (int i = 0; i < TestHelper.RACE_DEFAULT_LOOPS; i++) {
            PublishSubject<Integer> ps1 = PublishSubject.create();

            TestObserver<Integer> to = new TestObserver<>();
            CountDownLatch cdl = new CountDownLatch(1);

            ps1.flatMapMaybe(v -> {
                TestHelper.raceOther(() -> {
                    to.dispose();
                }, cdl);
                return Maybe.just(1);
            })
            .subscribe(to);

            ps1.onNext(1);

            cdl.await();
        }",loop_control
i,"for (int i = 0; i < TestHelper.RACE_LONG_LOOPS; i++) {
            MaybeSubject<Integer> ms1 = MaybeSubject.create();
            MaybeSubject<Integer> ms2 = MaybeSubject.create();

            TestObserver<Integer> to = Observable.just(1, 2)
            .flatMapMaybe(v -> v == 1 ? ms1 : ms2)
            .test();

            TestHelper.race(
                    () -> ms1.onComplete(),
                    () -> ms2.onSuccess(1)
            );

            to.assertResult(1);
        }",loop_control
i,"for (int i = 0; i < TestHelper.RACE_LONG_LOOPS; i++) {
            MaybeSubject<Integer> ms1 = MaybeSubject.create();
            MaybeSubject<Integer> ms2 = MaybeSubject.create();

            TestObserver<Integer> to = Observable.just(1, 2)
            .flatMapMaybe(v -> v == 1 ? ms1 : ms2)
            .test();

            TestHelper.race(
                    () -> ms2.onSuccess(1),
                    () -> ms1.onComplete()
            );

            to.assertResult(1);
        }",loop_control
i,"for (int i = 0; i < 11; i++) {
            TestHelper.assertError(errors, i, TestException.class);
        }",loop_control
i,"for (int i = 0; i < 10; i++) {
            TestHelper.assertError(errors, i, TestException.class);
        }",loop_control
i,"for (int i = 0; i < 11; i++) {
            TestHelper.assertError(errors, i, TestException.class);
        }",loop_control
i,"for (int i = 0; i < 10; i++) {
            TestHelper.assertError(errors, i, TestException.class);
        }",loop_control
i,"for (int i = 0; i < TestHelper.RACE_DEFAULT_LOOPS; i++) {
            PublishSubject<Integer> ps1 = PublishSubject.create();

            TestObserver<Object> to = new TestObserver<>();
            CountDownLatch cdl = new CountDownLatch(1);

            ps1.flatMapCompletable(v -> {
                TestHelper.raceOther(() -> {
                    to.dispose();
                }, cdl);
                return Completable.complete();
            })
            .toObservable()
            .subscribe(to);

            ps1.onNext(1);

            cdl.await();
        }",loop_control
i,"for (int i = 0; i < TestHelper.RACE_DEFAULT_LOOPS; i++) {
            PublishSubject<Integer> ps1 = PublishSubject.create();

            TestObserver<Void> to = new TestObserver<>();
            CountDownLatch cdl = new CountDownLatch(1);

            ps1.flatMapCompletable(v -> {
                TestHelper.raceOther(() -> {
                    to.dispose();
                }, cdl);
                return Completable.complete();
            })
            .subscribe(to);

            ps1.onNext(1);

            cdl.await();
        }",loop_control
i,"for (int i = 0; i < TestHelper.RACE_DEFAULT_LOOPS; i++) {
            final PublishSubject<Integer> ps = PublishSubject.create();

            final TestObserver<Boolean> to = Observable.sequenceEqual(Observable.never(), ps).test();

            Runnable r1 = new Runnable() {
                @Override
                public void run() {
                    to.dispose();
                }
            };

            Runnable r2 = new Runnable() {
                @Override
                public void run() {
                    ps.onNext(1);
                }
            };

            TestHelper.race(r1, r2);

            to.assertEmpty();
        }",loop_control
i,"for (int i = 0; i < TestHelper.RACE_DEFAULT_LOOPS; i++) {
            final PublishSubject<Integer> ps = PublishSubject.create();

            final TestObserver<Boolean> to = Observable.sequenceEqual(Observable.never(), ps).toObservable().test();

            Runnable r1 = new Runnable() {
                @Override
                public void run() {
                    to.dispose();
                }
            };

            Runnable r2 = new Runnable() {
                @Override
                public void run() {
                    ps.onNext(1);
                }
            };

            TestHelper.race(r1, r2);

            to.assertEmpty();
        }",loop_control
i,"for (int i = 0; i < n; i++) {
            source.onNext(i);
            if (i % 3 == 2 && i < n - 1) {
                boundary.onNext(i / 3);
            }
        }",loop_control
i,"for (int i = 0; i < 3; i++) {
                verify(mo).onNext(j + i);
            }",loop_control
mo,"{
                final Observer<Object> mo = TestHelper.mockObserver();
                values.add(mo);

                args.subscribe(mo);
            }",iterator
mo,"for (Observer<Object> mo : values) {
            verify(mo, never()).onError(any(Throwable.class));
            for (int i = 0; i < 3; i++) {
                verify(mo).onNext(j + i);
            }
            verify(mo).onComplete();
            j += 3;
        }",iterator
i,"for (int i = 0; i < n; i++) {
            source.onNext(i);
            if (i % 3 == 2 && i < n - 1) {
                boundary.onNext(i / 3);
            }
        }",loop_control
i,"for (int i = 0; i < 3; i++) {
                verify(mo).onNext(j + i);
            }",loop_control
mo,"{
                final Observer<Object> mo = TestHelper.mockObserver();
                values.add(mo);

                args.subscribe(mo);
            }",iterator
mo,"for (Observer<Object> mo : values) {
            for (int i = 0; i < 3; i++) {
                verify(mo).onNext(j + i);
            }
            verify(mo).onComplete();
            verify(mo, never()).onError(any(Throwable.class));
            j += 3;
        }",iterator
i,"for (int i = 0; i < TestHelper.RACE_LONG_LOOPS; i++) {
            List<Throwable> errors = TestHelper.trackPluginErrors();
            try {
                final AtomicReference<Observer<? super Object>> refMain = new AtomicReference<>();
                final AtomicReference<Observer<? super Object>> ref = new AtomicReference<>();

                TestObserverEx<Observable<Object>> to = new Observable<Object>() {
                    @Override
                    protected void subscribeActual(Observer<? super Object> observer) {
                        observer.onSubscribe(Disposable.empty());
                        refMain.set(observer);
                    }
                }
                .window(new Observable<Object>() {
                    @Override
                    protected void subscribeActual(Observer<? super Object> observer) {
                        observer.onSubscribe(Disposable.empty());
                        ref.set(observer);
                    }
                })
                .to(TestHelper.<Observable<Object>>testConsumer());

                Runnable r1 = new Runnable() {
                    @Override
                    public void run() {
                        refMain.get().onComplete();
                    }
                };
                Runnable r2 = new Runnable() {
                    @Override
                    public void run() {
                        ref.get().onError(ex);
                    }
                };

                TestHelper.race(r1, r2);

                to
                .assertValueCount(1)
                .assertTerminated();

                if (!errors.isEmpty()) {
                    TestHelper.assertUndeliverable(errors, 0, TestException.class);
                }
            } finally {
                RxJavaPlugins.reset();
            }
        }",loop_control
i,"for (int i = 0; i < TestHelper.RACE_LONG_LOOPS; i++) {
            final AtomicReference<Observer<? super Object>> refMain = new AtomicReference<>();
            final AtomicReference<Observer<? super Object>> ref = new AtomicReference<>();

            TestObserver<Observable<Object>> to = new Observable<Object>() {
                @Override
                protected void subscribeActual(Observer<? super Object> observer) {
                    observer.onSubscribe(Disposable.empty());
                    refMain.set(observer);
                }
            }
            .window(new Observable<Object>() {
                @Override
                protected void subscribeActual(Observer<? super Object> observer) {
                    observer.onSubscribe(Disposable.empty());
                    ref.set(observer);
                }
            })
            .test();

            Runnable r1 = new Runnable() {
                @Override
                public void run() {
                    refMain.get().onNext(1);
                }
            };
            Runnable r2 = new Runnable() {
                @Override
                public void run() {
                    ref.get().onNext(1);
                }
            };

            TestHelper.race(r1, r2);

            to
            .assertValueCount(2)
            .assertNotComplete()
            .assertNoErrors();
        }",loop_control
i,"for (int i = 0; i < TestHelper.RACE_LONG_LOOPS; i++) {
            final AtomicReference<Observer<? super Object>> refMain = new AtomicReference<>();
            final AtomicReference<Observer<? super Object>> ref = new AtomicReference<>();

            final TestObserver<Observable<Object>> to = new Observable<Object>() {
                 @Override
                 protected void subscribeActual(Observer<? super Object> observer) {
                     observer.onSubscribe(Disposable.empty());
                     refMain.set(observer);
                 }
             }
             .window(new Observable<Object>() {
                 @Override
                 protected void subscribeActual(Observer<? super Object> observer) {
                     final AtomicInteger counter = new AtomicInteger();
                     observer.onSubscribe(new Disposable() {

                         @Override
                         public void dispose() {
                             // about a microsecond
                             for (int i = 0; i < 100; i++) {
                                 counter.incrementAndGet();
                             }
                         }

                         @Override
                         public boolean isDisposed() {
                             return false;
                         }
                      });
                     ref.set(observer);
                 }
             })
             .test();

             Runnable r1 = new Runnable() {
                 @Override
                 public void run() {
                     to.dispose();
                 }
             };
             Runnable r2 = new Runnable() {
                 @Override
                 public void run() {
                     Observer<Object> o = ref.get();
                     o.onNext(1);
                     o.onComplete();
                 }
             };

             TestHelper.race(r1, r2);
        }",loop_control
i,"for (int i = 0; i < TestHelper.RACE_LONG_LOOPS; i++) {
           final AtomicReference<Observer<? super Object>> refMain = new AtomicReference<>();
           final AtomicReference<Observer<? super Object>> ref = new AtomicReference<>();

           final TestObserver<Observable<Object>> to = new Observable<Object>() {
               @Override
               protected void subscribeActual(Observer<? super Object> observer) {
                   observer.onSubscribe(Disposable.empty());
                   refMain.set(observer);
               }
           }
           .window(new Observable<Object>() {
               @Override
               protected void subscribeActual(Observer<? super Object> observer) {
                   final AtomicInteger counter = new AtomicInteger();
                   observer.onSubscribe(new Disposable() {

                       @Override
                       public void dispose() {
                           // about a microsecond
                           for (int i = 0; i < 100; i++) {
                               counter.incrementAndGet();
                           }
                       }

                       @Override
                       public boolean isDisposed() {
                           return false;
                       }
                    });
                   ref.set(observer);
               }
           })
           .test();

            Runnable r1 = new Runnable() {
                @Override
                public void run() {
                    to.dispose();
                }
            };
            Runnable r2 = new Runnable() {
                @Override
                public void run() {
                    Observer<Object> o = ref.get();
                    o.onNext(1);
                    o.onError(ex);
                }
            };

            TestHelper.race(r1, r2);
        }",loop_control
timeout,"{
            final CountDownLatch cdl1 = new CountDownLatch(1);
            final CountDownLatch cdl2 = new CountDownLatch(1);

            TestObserver<Object> to = Observable.fromCompletable(Completable.fromAction(new Action() {
                @Override
                public void run() throws Exception {
                    cdl1.countDown();
                    cdl2.await(5, TimeUnit.SECONDS);
                }
            })).subscribeOn(Schedulers.single()).test();

            assertTrue(cdl1.await(5, TimeUnit.SECONDS));

            to.dispose();

            int timeout = 10;

            while (timeout-- > 0 && errors.isEmpty()) {
                Thread.sleep(100);
            }

            TestHelper.assertUndeliverable(errors, 0, InterruptedException.class);
        }",loop_control
errors,"{
        List<Throwable> errors = TestHelper.trackPluginErrors();
        try {
            final CountDownLatch cdl1 = new CountDownLatch(1);
            final CountDownLatch cdl2 = new CountDownLatch(1);

            TestObserver<Object> to = Observable.fromCompletable(Completable.fromAction(new Action() {
                @Override
                public void run() throws Exception {
                    cdl1.countDown();
                    cdl2.await(5, TimeUnit.SECONDS);
                }
            })).subscribeOn(Schedulers.single()).test();

            assertTrue(cdl1.await(5, TimeUnit.SECONDS));

            to.dispose();

            int timeout = 10;

            while (timeout-- > 0 && errors.isEmpty()) {
                Thread.sleep(100);
            }

            TestHelper.assertUndeliverable(errors, 0, InterruptedException.class);
        } finally {
            RxJavaPlugins.reset();
        }
    }",maybe_loop_control
terminate,"{
            final AtomicBoolean terminate = new AtomicBoolean(false);
            observer.onSubscribe(Disposable.fromRunnable(new Runnable() {
                @Override
                public void run() {
                        terminate.set(true);
                        active.decrementAndGet();
                }
            }));
            efforts.getAndIncrement();
            active.getAndIncrement();
            maxActive.set(Math.max(active.get(), maxActive.get()));
            final Thread thread = new Thread(context) {
                @Override
                public void run() {
                    long nr = 0;
                    try {
                        while (!terminate.get()) {
                            Thread.sleep(emitDelay);
                            if (nextBeforeFailure.getAndDecrement() > 0) {
                                observer.onNext(nr++);
                            } else {
                                active.decrementAndGet();
                                observer.onError(new RuntimeException(""expected-failed""));
                                break;
                            }
                        }
                    } catch (InterruptedException t) {
                    }
                }
            };
            thread.start();
        }",maybe_loop_control
j,"for (int j = 0; j < NUM_LOOPS; j++) {
            final int NUM_RETRIES = Flowable.bufferSize() * 2;
            for (int i = 0; i < 400; i++) {
                Observer<String> observer = TestHelper.mockObserver();
                Observable<String> origin = Observable.unsafeCreate(new FuncWithErrors(NUM_RETRIES));
                TestObserver<String> to = new TestObserver<>(observer);
                origin.retry().observeOn(Schedulers.computation()).subscribe(to);
                to.awaitDone(5, TimeUnit.SECONDS);

                InOrder inOrder = inOrder(observer);
                // should have no errors
                verify(observer, never()).onError(any(Throwable.class));
                // should show NUM_RETRIES attempts
                inOrder.verify(observer, times(NUM_RETRIES + 1)).onNext(""beginningEveryTime"");
                // should have a single success
                inOrder.verify(observer, times(1)).onNext(""onSuccessOnly"");
                // should have a single successful onComplete
                inOrder.verify(observer, times(1)).onComplete();
                inOrder.verifyNoMoreInteractions();
            }
        }",loop_control
i,"for (int i = 0; i < 400; i++) {
                Observer<String> observer = TestHelper.mockObserver();
                Observable<String> origin = Observable.unsafeCreate(new FuncWithErrors(NUM_RETRIES));
                TestObserver<String> to = new TestObserver<>(observer);
                origin.retry().observeOn(Schedulers.computation()).subscribe(to);
                to.awaitDone(5, TimeUnit.SECONDS);

                InOrder inOrder = inOrder(observer);
                // should have no errors
                verify(observer, never()).onError(any(Throwable.class));
                // should show NUM_RETRIES attempts
                inOrder.verify(observer, times(NUM_RETRIES + 1)).onNext(""beginningEveryTime"");
                // should have a single success
                inOrder.verify(observer, times(1)).onNext(""onSuccessOnly"");
                // should have a single successful onComplete
                inOrder.verify(observer, times(1)).onComplete();
                inOrder.verifyNoMoreInteractions();
            }",loop_control
r,"for (int r = 0; r < NUM_LOOPS; r++) {
                if (r % 10 == 0) {
                    System.out.println(""testRetryWithBackpressureParallelLoop -> "" + r);
                }

                final AtomicInteger timeouts = new AtomicInteger();
                final Map<Integer, List<String>> data = new ConcurrentHashMap<>();

                int m = 5000;
                final CountDownLatch cdl = new CountDownLatch(m);
                for (int i = 0; i < m; i++) {
                    final int j = i;
                    exec.execute(new Runnable() {
                        @Override
                        public void run() {
                            final AtomicInteger nexts = new AtomicInteger();
                            try {
                                Observable<String> origin = Observable.unsafeCreate(new FuncWithErrors(NUM_RETRIES));
                                TestObserverEx<String> to = new TestObserverEx<>();
                                origin.retry()
                                .observeOn(Schedulers.computation()).subscribe(to);
                                to.awaitDone(2500, TimeUnit.MILLISECONDS);
                                List<String> onNextEvents = new ArrayList<>(to.values());
                                if (onNextEvents.size() != NUM_RETRIES + 2) {
                                    for (Throwable t : to.errors()) {
                                        onNextEvents.add(t.toString());
                                    }
                                    for (long err = to.completions(); err != 0; err--) {
                                        onNextEvents.add(""onComplete"");
                                    }
                                    data.put(j, onNextEvents);
                                }
                            } catch (Throwable t) {
                                timeouts.incrementAndGet();
                                System.out.println(j + "" | "" + cdl.getCount() + "" !!! "" + nexts.get());
                            }
                            cdl.countDown();
                        }
                    });
                }
                cdl.await();
                assertEquals(0, timeouts.get());
                if (data.size() > 0) {
                    fail(""Data content mismatch: "" + allSequenceFrequency(data));
                }
            }",loop_control
i,"for (int i = 0; i < m; i++) {
                    final int j = i;
                    exec.execute(new Runnable() {
                        @Override
                        public void run() {
                            final AtomicInteger nexts = new AtomicInteger();
                            try {
                                Observable<String> origin = Observable.unsafeCreate(new FuncWithErrors(NUM_RETRIES));
                                TestObserverEx<String> to = new TestObserverEx<>();
                                origin.retry()
                                .observeOn(Schedulers.computation()).subscribe(to);
                                to.awaitDone(2500, TimeUnit.MILLISECONDS);
                                List<String> onNextEvents = new ArrayList<>(to.values());
                                if (onNextEvents.size() != NUM_RETRIES + 2) {
                                    for (Throwable t : to.errors()) {
                                        onNextEvents.add(t.toString());
                                    }
                                    for (long err = to.completions(); err != 0; err--) {
                                        onNextEvents.add(""onComplete"");
                                    }
                                    data.put(j, onNextEvents);
                                }
                            } catch (Throwable t) {
                                timeouts.incrementAndGet();
                                System.out.println(j + "" | "" + cdl.getCount() + "" !!! "" + nexts.get());
                            }
                            cdl.countDown();
                        }
                    });
                }",loop_control
t,"for (Throwable t : to.errors()) {
                                        onNextEvents.add(t.toString());
                                    }",iterator
t,"{
                            final AtomicInteger nexts = new AtomicInteger();
                            try {
                                Observable<String> origin = Observable.unsafeCreate(new FuncWithErrors(NUM_RETRIES));
                                TestObserverEx<String> to = new TestObserverEx<>();
                                origin.retry()
                                .observeOn(Schedulers.computation()).subscribe(to);
                                to.awaitDone(2500, TimeUnit.MILLISECONDS);
                                List<String> onNextEvents = new ArrayList<>(to.values());
                                if (onNextEvents.size() != NUM_RETRIES + 2) {
                                    for (Throwable t : to.errors()) {
                                        onNextEvents.add(t.toString());
                                    }
                                    for (long err = to.completions(); err != 0; err--) {
                                        onNextEvents.add(""onComplete"");
                                    }
                                    data.put(j, onNextEvents);
                                }
                            } catch (Throwable t) {
                                timeouts.incrementAndGet();
                                System.out.println(j + "" | "" + cdl.getCount() + "" !!! "" + nexts.get());
                            }
                            cdl.countDown();
                        }",iterator
err,"for (long err = to.completions(); err != 0; err--) {
                                        onNextEvents.add(""onComplete"");
                                    }",loop_control
e,"for (Map.Entry<Integer, List<T>> e : its.entrySet()) {
            if (b.length() > 0) {
                b.append("", "");
            }
            b.append(e.getKey()).append(""={"");
            b.append(sequenceFrequency(e.getValue()));
            b.append(""}"");
        }",iterator
curr,"for (Object curr : it) {
            if (sb.length() > 0) {
                if (!curr.equals(prev)) {
                    if (cnt > 1) {
                        sb.append("" x "").append(cnt);
                        cnt = 1;
                    }
                    sb.append("", "");
                    sb.append(curr);
                } else {
                    cnt++;
                }
            } else {
                sb.append(curr);
                cnt++;
            }
            prev = curr;
        }",iterator
i,"for (int i = 0; i < NUM_MSG; i++) {
                    o.onNext(""msg:"" + count.incrementAndGet());
                }",loop_control
i,"for (int i = 0; i < TestHelper.RACE_DEFAULT_LOOPS; i++) {

                TestObserver<Integer> to = source.take(1)
                .map(new Function<Integer, Integer>() {
                    @Override
                    public Integer apply(Integer v) throws Exception {
                        throw error;
                    }
                })
                .retryWhen(new Function<Observable<Throwable>, ObservableSource<Integer>>() {
                    @Override
                    public ObservableSource<Integer> apply(Observable<Throwable> v)
                            throws Exception {
                        return signaller;
                    }
                }).test();

                Runnable r1 = new Runnable() {
                    @Override
                    public void run() {
                        for (int i = 0; i < TestHelper.RACE_DEFAULT_LOOPS; i++) {
                            source.onNext(1);
                        }
                    }
                };
                Runnable r2 = new Runnable() {
                    @Override
                    public void run() {
                        for (int i = 0; i < TestHelper.RACE_DEFAULT_LOOPS; i++) {
                            signaller.onNext(1);
                        }
                    }
                };

                TestHelper.race(r1, r2);

                to.dispose();
            }",loop_control
e,"for (Throwable e : errors) {
                    e.printStackTrace();
                }",iterator
i,"for (int i = 0; i < 500; i++) {
            if (i % 10 == 0) {
                System.out.println(""testNestedAsyncConcat >> "" + i);
            }
            nestedAsyncConcat();
        }",loop_control
i,"for (int i = 0; i < n; i++) {
            list.add(i);
        }",loop_control
i,"for (int i = 0; i < n / 2; i++) {
            list.add(i);
        }",loop_control
i,"for (int i = 0;; i++) {
            //only run this for a max of ten seconds
            if (System.currentTimeMillis() - startTime > TimeUnit.SECONDS.toMillis(durationSeconds)) {
                return;
            }
            if (i % 1000 == 0) {
                System.out.println(""concatMapRangeAsyncLoop > "" + i);
            }
            TestObserverEx<Integer> to = new TestObserverEx<>();

            Observable.range(0, 1000)
            .concatMap(new Function<Integer, Observable<Integer>>() {
                @Override
                public Observable<Integer> apply(Integer t) {
                    return Observable.fromIterable(Arrays.asList(t));
                }
            })
            .observeOn(Schedulers.computation())
            .subscribe(to);

            to.awaitDone(2500, TimeUnit.MILLISECONDS);
            to.assertTerminated();
            to.assertNoErrors();
            assertEquals(1000, to.values().size());
            assertEquals((Integer)999, to.values().get(999));
        }",loop_control
r2,"{
        PublishSubject<String> r1 = PublishSubject.create();
        /* define an Observer to receive aggregated events */
        Observer<String> o = TestHelper.mockObserver();
        InOrder io = inOrder(o);

        Iterable<String> r2 = new Iterable<String>() {
            @Override
            public Iterator<String> iterator() {
                throw new TestException();
            }
        };

        r1.zipWith(r2, zipr2).subscribe(o);

        r1.onNext(""one-"");
        r1.onNext(""two-"");
        r1.onError(new TestException());

        io.verify(o).onError(any(TestException.class));

        verify(o, never()).onComplete();
        verify(o, never()).onNext(any(String.class));

    }",iterator
r2,"{
        PublishSubject<String> r1 = PublishSubject.create();
        /* define an Observer to receive aggregated events */
        Observer<String> o = TestHelper.mockObserver();
        InOrder io = inOrder(o);

        Iterable<String> r2 = new Iterable<String>() {

            @Override
            public Iterator<String> iterator() {
                return new Iterator<String>() {
                    int count;

                    @Override
                    public boolean hasNext() {
                        if (count == 0) {
                            return true;
                        }
                        throw new TestException();
                    }

                    @Override
                    public String next() {
                        count++;
                        return ""1"";
                    }

                    @Override
                    public void remove() {
                        throw new UnsupportedOperationException(""Not supported yet."");
                    }

                };
            }

        };

        r1.zipWith(r2, zipr2).subscribe(o);

        r1.onNext(""one-"");
        r1.onError(new TestException());

        io.verify(o).onNext(""one-1"");
        io.verify(o).onError(any(TestException.class));

        verify(o, never()).onComplete();

    }",iterator
r2,"{
        PublishSubject<String> r1 = PublishSubject.create();
        /* define an Observer to receive aggregated events */
        Observer<String> o = TestHelper.mockObserver();
        InOrder io = inOrder(o);

        Iterable<String> r2 = new Iterable<String>() {

            @Override
            public Iterator<String> iterator() {
                return new Iterator<String>() {
                    @Override
                    public boolean hasNext() {
                        return true;
                    }

                    @Override
                    public String next() {
                        throw new TestException();
                    }

                    @Override
                    public void remove() {
                        throw new UnsupportedOperationException(""Not supported yet."");
                    }

                };
            }

        };

        r1.zipWith(r2, zipr2).subscribe(o);

        r1.onError(new TestException());

        io.verify(o).onError(any(TestException.class));

        verify(o, never()).onNext(any(String.class));
        verify(o, never()).onComplete();

    }",iterator
i,"for (int i = 0; i < 50; i++) {
            final TestASynchronous1sDelayedObservable o1 = new TestASynchronous1sDelayedObservable();
            final TestASynchronous1sDelayedObservable o2 = new TestASynchronous1sDelayedObservable();
            Observable<Observable<String>> parentObservable = Observable.unsafeCreate(new ObservableSource<Observable<String>>() {
                @Override
                public void subscribe(Observer<? super Observable<String>> op) {
                    op.onSubscribe(Disposable.empty());
                    op.onNext(Observable.unsafeCreate(o1));
                    op.onNext(Observable.unsafeCreate(o2));
                    op.onError(new NullPointerException(""throwing exception in parent""));
                }
            });

            Observer<String> stringObserver = TestHelper.mockObserver();

            TestObserverEx<String> to = new TestObserverEx<>(stringObserver);
            Observable<String> m = Observable.mergeDelayError(parentObservable);
            m.subscribe(to);
            System.out.println(""testErrorInParentObservableDelayed | "" + i);
            to.awaitDone(2000, TimeUnit.MILLISECONDS);
            to.assertTerminated();

            verify(stringObserver, times(2)).onNext(""hello"");
            verify(stringObserver, times(1)).onError(any(NullPointerException.class));
            verify(stringObserver, never()).onComplete();
        }",loop_control
it,"{
        Subject<String> s = PublishSubject.create();

        Iterator<String> it = mostRecent(s, ""default"").iterator();

        assertTrue(it.hasNext());
        assertEquals(""default"", it.next());
        assertEquals(""default"", it.next());

        s.onNext(""one"");
        assertTrue(it.hasNext());
        assertEquals(""one"", it.next());
        assertEquals(""one"", it.next());

        s.onNext(""two"");
        assertTrue(it.hasNext());
        assertEquals(""two"", it.next());
        assertEquals(""two"", it.next());

        s.onComplete();
        assertFalse(it.hasNext());

    }",iterator
it,"{
        Subject<String> s = PublishSubject.create();

        Iterator<String> it = mostRecent(s, ""default"").iterator();

        assertTrue(it.hasNext());
        assertEquals(""default"", it.next());
        assertEquals(""default"", it.next());

        s.onError(new TestException());
        assertTrue(it.hasNext());

        it.next();
    }",iterator
j,"for (int j = 0; j < 3; j++) {
            Iterator<Long> it = iter.iterator();

            Assert.assertEquals(Long.valueOf(-1), it.next());

            for (int i = 0; i < 9; i++) {
                scheduler.advanceTimeBy(1, TimeUnit.SECONDS);

                Assert.assertTrue(it.hasNext());
                Assert.assertEquals(Long.valueOf(i), it.next());
            }
            scheduler.advanceTimeBy(1, TimeUnit.SECONDS);

            Assert.assertFalse(it.hasNext());
        }",loop_control
i,"for (int i = 0; i < 9; i++) {
                scheduler.advanceTimeBy(1, TimeUnit.SECONDS);

                Assert.assertTrue(it.hasNext());
                Assert.assertEquals(Long.valueOf(i), it.next());
            }",loop_control
it,"for (int j = 0; j < 3; j++) {
            Iterator<Long> it = iter.iterator();

            Assert.assertEquals(Long.valueOf(-1), it.next());

            for (int i = 0; i < 9; i++) {
                scheduler.advanceTimeBy(1, TimeUnit.SECONDS);

                Assert.assertTrue(it.hasNext());
                Assert.assertEquals(Long.valueOf(i), it.next());
            }
            scheduler.advanceTimeBy(1, TimeUnit.SECONDS);

            Assert.assertFalse(it.hasNext());
        }",iterator
it,"{
        Iterator<Integer> it = Observable.<Integer>empty()
        .blockingMostRecent(1)
        .iterator();

        try {
            it.next();
            fail(""Should have thrown"");
        } catch (NoSuchElementException ex) {
            // expected
        }

        try {
            it.remove();
            fail(""Should have thrown"");
        } catch (UnsupportedOperationException ex) {
            // expected
        }
    }",iterator
i,"for (int i = 0; i < 1000; i++) {
            if (i % 100 == 0) {
                System.out.println(""testFlatMapTransformsMaxConcurrentNormalLoop => "" + i);
            }
            flatMapTransformsMaxConcurrentNormal();
        }",loop_control
i,"for (int i = 0; i < 2000; i++) {
            if (i % 10 == 0) {
                System.out.println(""flatMapRangeAsyncLoop > "" + i);
            }
            TestObserverEx<Integer> to = new TestObserverEx<>();
            Observable.range(0, 1000)
            .flatMap(new Function<Integer, Observable<Integer>>() {
                final Random rnd = new Random();
                @Override
                public Observable<Integer> apply(Integer t) {
                    Observable<Integer> r = Observable.just(t);
                    if (rnd.nextBoolean()) {
                        r = r.hide();
                    }
                    return r;
                }
            })
            .observeOn(Schedulers.computation())
            .subscribe(to);

            to.awaitDone(2500, TimeUnit.MILLISECONDS);
            if (to.completions() == 0) {
                System.out.println(to.values().size());
            }
            to.assertTerminated();
            to.assertNoErrors();
            List<Integer> list = to.values();
            if (list.size() < 1000) {
                Set<Integer> set = new HashSet<>(list);
                for (int j = 0; j < 1000; j++) {
                    if (!set.contains(j)) {
                        System.out.println(j + "" missing"");
                    }
                }
            }
            assertEquals(1000, list.size());
        }",loop_control
j,"for (int j = 0; j < 1000; j++) {
                    if (!set.contains(j)) {
                        System.out.println(j + "" missing"");
                    }
                }",loop_control
i,"for (int i = 0; i < 1000; i++) {
            TestObserver<Integer> to = new TestObserver<>();

            Observable.range(1, 1000).flatMap(new Function<Integer, Observable<Integer>>() {
                @Override
                public Observable<Integer> apply(Integer t) {
                    return Observable.just(1).subscribeOn(Schedulers.computation());
                }
            }).subscribe(to);

            to.awaitDone(5, TimeUnit.SECONDS);
            to.assertNoErrors();
            to.assertComplete();
            to.assertValueCount(1000);
        }",loop_control
n,"for (final int n : new int[] { 1, 1000, 1000000 }) {
            TestObserver<Integer> to = new TestObserver<>();

            Observable.just(1, 2).flatMap(new Function<Integer, Observable<Integer>>() {
                @Override
                public Observable<Integer> apply(Integer t) {
                    return Observable.range(1, n);
                }
            }).subscribe(to);

            System.out.println(""flatMapTwoNestedSync >> @ "" + n);
            to.assertNoErrors();
            to.assertComplete();
            to.assertValueCount(n * 2);
        }",iterator
i,"for (int i = 0; i < TestHelper.RACE_DEFAULT_LOOPS; i++) {
            final PublishSubject<Integer> ps = PublishSubject.create();

            final TestObserver<Integer> to = Observable.merge(Observable.just(ps)).test();

            Runnable r1 = new Runnable() {
                @Override
                public void run() {
                    ps.onComplete();
                }
            };

            Runnable r2 = new Runnable() {
                @Override
                public void run() {
                    to.dispose();
                }
            };

            TestHelper.race(r1, r2);
        }",loop_control
i,"for (int i = 0; i < 500; i++) {
            TestObserver<Object> to = Observable.merge(
                    Observable.just(1).observeOn(Schedulers.single()).map(new Function<Integer, Object>() {
                        @Override
                        public Object apply(Integer v) throws Exception {
                            return Thread.currentThread().getName().substring(0, 4);
                        }
                    }),
                    Observable.just(1).observeOn(Schedulers.computation()).map(new Function<Integer, Object>() {
                        @Override
                        public Object apply(Integer v) throws Exception {
                            return Thread.currentThread().getName().substring(0, 4);
                        }
                    })
            )
            .test()
            .awaitDone(5, TimeUnit.SECONDS)
            .assertValueCount(2);

            List<Object> list = to.values();

            assertTrue(list.toString(), list.contains(""RxSi""));
            assertTrue(list.toString(), list.contains(""RxCo""));
        }",loop_control
i,"for (int i = 0; i < TestHelper.RACE_DEFAULT_LOOPS; i++) {
            List<Throwable> errors = TestHelper.trackPluginErrors();
            try {

                final PublishSubject<Observable<Integer>> ps = PublishSubject.create();

                final TestObserver<Integer> to = ps.flatMap(Functions.<Observable<Integer>>identity()).test();

                Runnable r1 = new Runnable() {
                    @Override
                    public void run() {
                        to.dispose();
                    }
                };
                Runnable r2 = new Runnable() {
                    @Override
                    public void run() {
                        ps.onComplete();
                    }
                };

                TestHelper.race(r1, r2);

                assertTrue(errors.toString(), errors.isEmpty());
            } finally {
                RxJavaPlugins.reset();
            }
        }",loop_control
i,"for (int i = 0; i < TestHelper.RACE_DEFAULT_LOOPS; i++) {
            for (int j = 1; j < 50; j += 5) {
                List<Throwable> errors = TestHelper.trackPluginErrors();
                try {

                    final PublishSubject<Observable<Integer>> ps = PublishSubject.create();

                    final TestObserver<Integer> to = ps.flatMap(Functions.<Observable<Integer>>identity()).test();

                    final PublishSubject<Integer> just = PublishSubject.create();
                    final PublishSubject<Integer> just2 = PublishSubject.create();
                    ps.onNext(just);
                    ps.onNext(just2);

                    Runnable r1 = new Runnable() {
                        @Override
                        public void run() {
                            just2.onNext(1);
                            to.dispose();
                        }
                    };
                    Runnable r2 = new Runnable() {
                        @Override
                        public void run() {
                            just.onNext(1);
                        }
                    };

                    TestHelper.race(r1, r2);

                    assertTrue(errors.toString(), errors.isEmpty());
                } finally {
                    RxJavaPlugins.reset();
                }
            }
        }",loop_control
j,"for (int j = 1; j < 50; j += 5) {
                List<Throwable> errors = TestHelper.trackPluginErrors();
                try {

                    final PublishSubject<Observable<Integer>> ps = PublishSubject.create();

                    final TestObserver<Integer> to = ps.flatMap(Functions.<Observable<Integer>>identity()).test();

                    final PublishSubject<Integer> just = PublishSubject.create();
                    final PublishSubject<Integer> just2 = PublishSubject.create();
                    ps.onNext(just);
                    ps.onNext(just2);

                    Runnable r1 = new Runnable() {
                        @Override
                        public void run() {
                            just2.onNext(1);
                            to.dispose();
                        }
                    };
                    Runnable r2 = new Runnable() {
                        @Override
                        public void run() {
                            just.onNext(1);
                        }
                    };

                    TestHelper.race(r1, r2);

                    assertTrue(errors.toString(), errors.isEmpty());
                } finally {
                    RxJavaPlugins.reset();
                }
            }",loop_control
i,"for (int i = 1; i < 10; i++) {
                            ps.onNext(i);
                        }",loop_control
i,"for (int i = 1; i < 10; i++) {
                        ps.onNext(i);
                    }",loop_control
i,"for (int i = 0; i < TestHelper.RACE_DEFAULT_LOOPS; i++) {
            Observable
            .range(0, 20)
            .flatMap(
                    integer -> {
                        if (integer % 5 != 0) {
                            return Observable
                                    .just(integer);
                        }

                        return Observable
                                .just(-integer)
                                .observeOn(Schedulers.computation());
                    },
                    false,
                    1
            )
            .ignoreElements()
            .blockingAwait();
        }",loop_control
i,"for (int i = 0; i < 11; i++) {
            TestHelper.assertError(errors, i, TestException.class);
        }",loop_control
i,"for (int i = 0; i < TestHelper.RACE_DEFAULT_LOOPS; i++) {
            PublishSubject<Integer> ps1 = PublishSubject.create();
            SingleSubject<Integer> ps2 = SingleSubject.create();

            TestObserver<Integer> to = ps1.flatMapSingle(v -> ps2)
            .test();

            ps1.onNext(1);

            TestHelper.race(
                    () -> ps1.onComplete(),
                    () -> ps2.onError(ex)
            );

            to.assertFailure(TestException.class);
        }",loop_control
i,"for (int i = 0; i < TestHelper.RACE_DEFAULT_LOOPS; i++) {
            PublishSubject<Integer> ps1 = PublishSubject.create();

            TestObserver<Integer> to = new TestObserver<>();
            CountDownLatch cdl = new CountDownLatch(1);

            ps1.flatMapSingle(v -> {
                TestHelper.raceOther(() -> {
                    to.dispose();
                }, cdl);
                return Single.just(1);
            })
            .subscribe(to);

            ps1.onNext(1);

            cdl.await();
        }",loop_control
arg,"for (String arg : args) {
            list.add(arg);
        }",iterator
i,"for (int i = 0; i < TestHelper.RACE_DEFAULT_LOOPS; i++) {
            TestScheduler scheduler = new TestScheduler();

            PublishSubject<Integer> ps = PublishSubject.create();

            TestObserver<Observable<Integer>> to = ps.window(1, TimeUnit.MINUTES, scheduler, 1)
            .test();

            TestHelper.race(
                    () -> ps.onNext(1),
                    () -> to.dispose()
            );
        }",loop_control
i,"for (int i = 0; i < n; i++) {
            Observer<Object> o = TestHelper.mockObserver();
            InOrder inOrder = inOrder(o);

            src.subscribe(o);

            for (int j = 5; j < 10; j++) {
                inOrder.verify(o).onNext(j);
            }
            inOrder.verify(o).onComplete();
            verify(o, never()).onError(any(Throwable.class));
        }",loop_control
j,"for (int j = 5; j < 10; j++) {
                inOrder.verify(o).onNext(j);
            }",loop_control
i,"for (int i = 1; i <= n; i++) {
            System.out.println(""test1ToNSources: "" + i + "" sources"");
            List<Observable<Integer>> sources = new ArrayList<>();
            List<Object> values = new ArrayList<>();
            for (int j = 0; j < i; j++) {
                sources.add(Observable.just(j));
                values.add(j);
            }

            Observable<List<Object>> result = Observable.combineLatest(sources, func);

            Observer<List<Object>> o = TestHelper.mockObserver();

            result.subscribe(o);

            verify(o).onNext(values);
            verify(o).onComplete();
            verify(o, never()).onError(any(Throwable.class));
        }",loop_control
j,"for (int j = 0; j < i; j++) {
                sources.add(Observable.just(j));
                values.add(j);
            }",loop_control
i,"for (int i = 1; i <= n; i++) {
            System.out.println(""test1ToNSourcesScheduled: "" + i + "" sources"");
            List<Observable<Integer>> sources = new ArrayList<>();
            List<Object> values = new ArrayList<>();
            for (int j = 0; j < i; j++) {
                sources.add(Observable.just(j).subscribeOn(Schedulers.io()));
                values.add(j);
            }

            Observable<List<Object>> result = Observable.combineLatest(sources, func);

            final Observer<List<Object>> o = TestHelper.mockObserver();

            final CountDownLatch cdl = new CountDownLatch(1);

            Observer<List<Object>> observer = new DefaultObserver<List<Object>>() {

                @Override
                public void onNext(List<Object> t) {
                    o.onNext(t);
                }

                @Override
                public void onError(Throwable e) {
                    o.onError(e);
                    cdl.countDown();
                }

                @Override
                public void onComplete() {
                    o.onComplete();
                    cdl.countDown();
                }
            };

            result.subscribe(observer);

            cdl.await();

            verify(o).onNext(values);
            verify(o).onComplete();
            verify(o, never()).onError(any(Throwable.class));
        }",loop_control
j,"for (int j = 0; j < i; j++) {
                sources.add(Observable.just(j).subscribeOn(Schedulers.io()));
                values.add(j);
            }",loop_control
i,"for (int i = 0; i < TestHelper.RACE_DEFAULT_LOOPS; i++) {
            List<Throwable> errors = TestHelper.trackPluginErrors();
            try {
                final PublishSubject<Integer> ps1 = PublishSubject.create();
                final PublishSubject<Integer> ps2 = PublishSubject.create();

                TestObserverEx<Integer> to = Observable.combineLatest(ps1, ps2, new BiFunction<Integer, Integer, Integer>() {
                    @Override
                    public Integer apply(Integer a, Integer b) throws Exception {
                        return a;
                    }
                }).to(TestHelper.<Integer>testConsumer());

                final TestException ex1 = new TestException();
                final TestException ex2 = new TestException();

                Runnable r1 = new Runnable() {
                    @Override
                    public void run() {
                        ps1.onError(ex1);
                    }
                };
                Runnable r2 = new Runnable() {
                    @Override
                    public void run() {
                        ps2.onError(ex2);
                    }
                };

                TestHelper.race(r1, r2);

                if (to.errors().size() != 0) {
                    if (to.errors().get(0) instanceof CompositeException) {
                        to.assertSubscribed()
                        .assertNotComplete()
                        .assertNoValues();

                        for (Throwable e : TestHelper.errorList(to)) {
                            assertTrue(e.toString(), e instanceof TestException);
                        }

                    } else {
                        to.assertFailure(TestException.class);
                    }
                }

                for (Throwable e : errors) {
                    assertTrue(e.toString(), e.getCause() instanceof TestException);
                }
            } finally {
                RxJavaPlugins.reset();
            }
        }",loop_control
e,"for (Throwable e : TestHelper.errorList(to)) {
                            assertTrue(e.toString(), e instanceof TestException);
                        }",iterator
e,"for (Throwable e : errors) {
                    assertTrue(e.toString(), e.getCause() instanceof TestException);
                }",iterator
i,"for (int i = 0; i < TestHelper.RACE_DEFAULT_LOOPS; i++) {

            TestObserver<Integer> to = new TestObserver<>();
            PublishSubject<Integer> ps = PublishSubject.create();

            Observable.combineLatest(ps, Observable.never(), (a, b) -> a)
            .subscribe(to);

            TestHelper.race(() -> ps.onComplete(), () -> to.dispose());
        }",loop_control
i,"for (int i = 0; i < TestHelper.RACE_DEFAULT_LOOPS; i++) {

                TestObserverEx<Object[]> to = new TestObserverEx<>();
                AtomicReference<Observer<? super Object>> ref = new AtomicReference<>();
                Observable<Object> o = new Observable<Object>() {
                    @Override
                    public void subscribeActual(Observer<? super Object> observer) {
                        ref.set(observer);
                    }
                };

                Observable.combineLatestDelayError(Arrays.asList(o, Observable.never()), (a) -> a)
                .subscribe(to);

                ref.get().onSubscribe(Disposable.empty());

                TestHelper.race(() -> ref.get().onError(ex), () -> to.dispose());

                if (to.errors().isEmpty()) {
                    TestHelper.assertUndeliverable(errors, 0, TestException.class);
                }
            }",loop_control
value,"for (final String value : values) {
                    parentSubscription.add(innerScheduler.schedule(new Runnable() {
                        @Override
                        public void run() {
                            observer.onNext(value);
                        }
                    }
                    , delay, TimeUnit.MILLISECONDS));
                    delay += interval;
                }",iterator
i,"for (int i = 0; i < TestHelper.RACE_DEFAULT_LOOPS; i++) {
            final PublishSubject<Integer> ps1 = PublishSubject.create();
            final PublishSubject<Integer> ps2 = PublishSubject.create();

            TestObserverEx<Integer> to = Observable.ambArray(ps1, ps2).to(TestHelper.<Integer>testConsumer());

            Runnable r1 = new Runnable() {
                @Override
                public void run() {
                    ps1.onNext(1);
                }
            };
            Runnable r2 = new Runnable() {
                @Override
                public void run() {
                    ps2.onNext(1);
                }
            };

            TestHelper.race(r1, r2);

            to.assertSubscribed()
            .assertNoErrors()
            .assertNotComplete()
            .assertValueCount(1);
        }",loop_control
i,"for (int i = 0; i < TestHelper.RACE_DEFAULT_LOOPS; i++) {
            final PublishSubject<Integer> ps1 = PublishSubject.create();
            final PublishSubject<Integer> ps2 = PublishSubject.create();

            TestObserver<Integer> to = Observable.ambArray(ps1, ps2).test();

            Runnable r1 = new Runnable() {
                @Override
                public void run() {
                    ps1.onComplete();
                }
            };
            Runnable r2 = new Runnable() {
                @Override
                public void run() {
                    ps2.onComplete();
                }
            };

            TestHelper.race(r1, r2);

            to.assertResult();
        }",loop_control
i,"for (int i = 0; i < TestHelper.RACE_DEFAULT_LOOPS; i++) {
            final PublishSubject<Integer> ps1 = PublishSubject.create();
            final PublishSubject<Integer> ps2 = PublishSubject.create();

            TestObserver<Integer> to = Observable.ambArray(ps1, ps2).test();

            final Throwable ex = new TestException();

            Runnable r1 = new Runnable() {
                @Override
                public void run() {
                    ps1.onError(ex);
                }
            };
            Runnable r2 = new Runnable() {
                @Override
                public void run() {
                    ps2.onError(ex);
                }
            };

            List<Throwable> errors = TestHelper.trackPluginErrors();
            try {
                TestHelper.race(r1, r2);
            } finally {
                RxJavaPlugins.reset();
            }

            to.assertFailure(TestException.class);
            if (!errors.isEmpty()) {
                TestHelper.assertUndeliverable(errors, 0, TestException.class);
            }
        }",loop_control
i,"for (int i = 0; i < TestHelper.RACE_LONG_LOOPS; i++) {
            final AtomicBoolean interrupted = new AtomicBoolean();
            final CountDownLatch cdl = new CountDownLatch(1);

            Observable.ambArray(
                Observable.just(1)
                    .subscribeOn(Schedulers.single())
                    .observeOn(Schedulers.computation()),
                Observable.never()
            )
            .subscribe(new Consumer<Object>() {
                @Override
                public void accept(Object v) throws Exception {
                    interrupted.set(Thread.currentThread().isInterrupted());
                    cdl.countDown();
                }
            });

            assertTrue(cdl.await(500, TimeUnit.SECONDS));
            assertFalse(""Interrupted!"", interrupted.get());
        }",loop_control
i,"for (int i = 0; i < TestHelper.RACE_LONG_LOOPS; i++) {
            final AtomicBoolean interrupted = new AtomicBoolean();
            final CountDownLatch cdl = new CountDownLatch(1);

            Observable.ambArray(
                Observable.error(ex)
                    .subscribeOn(Schedulers.single())
                    .observeOn(Schedulers.computation()),
                Observable.never()
            )
            .subscribe(Functions.emptyConsumer(), new Consumer<Throwable>() {
                @Override
                public void accept(Throwable e) throws Exception {
                    interrupted.set(Thread.currentThread().isInterrupted());
                    cdl.countDown();
                }
            });

            assertTrue(cdl.await(500, TimeUnit.SECONDS));
            assertFalse(""Interrupted!"", interrupted.get());
        }",loop_control
i,"for (int i = 0; i < TestHelper.RACE_LONG_LOOPS; i++) {
            final AtomicBoolean interrupted = new AtomicBoolean();
            final CountDownLatch cdl = new CountDownLatch(1);

            Observable.ambArray(
                Observable.empty()
                    .subscribeOn(Schedulers.single())
                    .observeOn(Schedulers.computation()),
                Observable.never()
            )
            .subscribe(Functions.emptyConsumer(), Functions.emptyConsumer(), new Action() {
                @Override
                public void run() throws Exception {
                    interrupted.set(Thread.currentThread().isInterrupted());
                    cdl.countDown();
                }
            });

            assertTrue(cdl.await(500, TimeUnit.SECONDS));
            assertFalse(""Interrupted!"", interrupted.get());
        }",loop_control
i,"for (int i = 0; i < 10000; i++) {
            final PublishSubject<Integer> ps = PublishSubject.create();
            final MaybeSubject<Integer> cs = MaybeSubject.create();

            TestObserver<Integer> to = ps.mergeWith(cs).test();

            Runnable r1 = new Runnable() {
                @Override
                public void run() {
                    ps.onNext(1);
                    ps.onComplete();
                }
            };

            Runnable r2 = new Runnable() {
                @Override
                public void run() {
                    cs.onSuccess(1);
                }
            };

            TestHelper.race(r1, r2);

            to.assertResult(1, 1);
        }",loop_control
timeout,"{
            final CountDownLatch cdl1 = new CountDownLatch(1);
            final CountDownLatch cdl2 = new CountDownLatch(1);

            TestObserver<Object> to = Observable.fromRunnable(new Runnable() {
                @Override
                public void run() {
                    cdl1.countDown();
                    try {
                        cdl2.await(5, TimeUnit.SECONDS);
                    } catch (InterruptedException e) {
                        e.printStackTrace();
                        throw new TestException(e);
                    }
                }
            }).subscribeOn(Schedulers.single()).test();

            assertTrue(cdl1.await(5, TimeUnit.SECONDS));

            to.dispose();

            int timeout = 10;

            while (timeout-- > 0 && errors.isEmpty()) {
                Thread.sleep(100);
            }

            TestHelper.assertUndeliverable(errors, 0, TestException.class);
        }",loop_control
errors,"{
        List<Throwable> errors = TestHelper.trackPluginErrors();
        try {
            final CountDownLatch cdl1 = new CountDownLatch(1);
            final CountDownLatch cdl2 = new CountDownLatch(1);

            TestObserver<Object> to = Observable.fromRunnable(new Runnable() {
                @Override
                public void run() {
                    cdl1.countDown();
                    try {
                        cdl2.await(5, TimeUnit.SECONDS);
                    } catch (InterruptedException e) {
                        e.printStackTrace();
                        throw new TestException(e);
                    }
                }
            }).subscribeOn(Schedulers.single()).test();

            assertTrue(cdl1.await(5, TimeUnit.SECONDS));

            to.dispose();

            int timeout = 10;

            while (timeout-- > 0 && errors.isEmpty()) {
                Thread.sleep(100);
            }

            TestHelper.assertUndeliverable(errors, 0, TestException.class);
        } finally {
            RxJavaPlugins.reset();
        }
    }",maybe_loop_control
i,"for (int i = 0; i < TestHelper.RACE_DEFAULT_LOOPS; i++) {
            TestObserver<Integer> to = new TestObserver<>();
            final ScalarDisposable<Integer> sd = new ScalarDisposable<>(to, 1);
            to.onSubscribe(sd);

            Runnable r1 = new Runnable() {
                @Override
                public void run() {
                    sd.run();
                }
            };

            Runnable r2 = new Runnable() {
                @Override
                public void run() {
                    sd.dispose();
                }
            };

            TestHelper.race(r1, r2);
        }",loop_control
it,"{
        Subject<String> obs = PublishSubject.create();
        Iterator<String> it = next(obs).iterator();
        fireOnNextInNewThread(obs, ""one"");
        assertTrue(it.hasNext());
        assertEquals(""one"", it.next());

        fireOnNextInNewThread(obs, ""two"");
        assertTrue(it.hasNext());
        assertEquals(""two"", it.next());

        fireOnNextInNewThread(obs, ""three"");
        try {
            assertEquals(""three"", it.next());
        } catch (NoSuchElementException e) {
            fail(""Calling next() without hasNext() should wait for next fire"");
        }

        obs.onComplete();
        assertFalse(it.hasNext());
        try {
            it.next();
            fail(""At the end of an iterator should throw a NoSuchElementException"");
        } catch (NoSuchElementException e) {
        }

        // If the Observable is completed, hasNext always returns false and next always throw a NoSuchElementException.
        assertFalse(it.hasNext());
        try {
            it.next();
            fail(""At the end of an iterator should throw a NoSuchElementException"");
        } catch (NoSuchElementException e) {
        }
    }",iterator
it,"{
        Subject<String> obs = PublishSubject.create();
        Iterator<String> it = next(obs).iterator();
        fireOnNextInNewThread(obs, ""one"");
        assertTrue(it.hasNext());
        assertEquals(""one"", it.next());

        fireOnErrorInNewThread(obs);
        try {
            it.hasNext();
            fail(""Expected an TestException"");
        } catch (TestException e) {
        }

        assertErrorAfterObservableFail(it);
    }",iterator
it,"{
        Observable<String> obs = Observable.<String> empty().observeOn(Schedulers.newThread());
        Iterator<String> it = next(obs).iterator();

        assertFalse(it.hasNext());
        try {
            it.next();
            fail(""At the end of an iterator should throw a NoSuchElementException"");
        } catch (NoSuchElementException e) {
        }

        // If the Observable is completed, hasNext always returns false and next always throw a NoSuchElementException.
        assertFalse(it.hasNext());
        try {
            it.next();
            fail(""At the end of an iterator should throw a NoSuchElementException"");
        } catch (NoSuchElementException e) {
        }
    }",iterator
it,"{
        Subject<String> obs = PublishSubject.create();
        Iterator<String> it = next(obs).iterator();

        obs.onError(new TestException());
        try {
            it.hasNext();
            fail(""Expected an TestException"");
        } catch (TestException e) {
            // successful
        }

        assertErrorAfterObservableFail(it);
    }",iterator
it,"{
        Subject<String> obs = PublishSubject.create();
        Iterator<String> it = next(obs).iterator();

        fireOnErrorInNewThread(obs);

        try {
            it.hasNext();
            fail(""Expected an TestException"");
        } catch (TestException e) {
            // successful
        }

        assertErrorAfterObservableFail(it);
    }",iterator
it,"{
        Subject<String> obs = PublishSubject.create();
        Iterator<String> it = next(obs).iterator();
        fireOnNextInNewThread(obs, ""one"");
        assertEquals(""one"", it.next());

        fireOnNextInNewThread(obs, ""two"");
        assertEquals(""two"", it.next());

        obs.onComplete();
        try {
            it.next();
            fail(""At the end of an iterator should throw a NoSuchElementException"");
        } catch (NoSuchElementException e) {
        }
    }",iterator
it,"{
        Subject<String> obs = PublishSubject.create();
        Iterator<String> it = next(obs).iterator();
        fireOnNextInNewThread(obs, ""one"");
        assertTrue(it.hasNext());
        assertTrue(it.hasNext());
        assertTrue(it.hasNext());
        assertTrue(it.hasNext());
        assertEquals(""one"", it.next());

        obs.onComplete();
        try {
            it.next();
            fail(""At the end of an iterator should throw a NoSuchElementException"");
        } catch (NoSuchElementException e) {
        }
    }",iterator
running,"{
                final CountDownLatch finished = new CountDownLatch(1);
                final int COUNT = 30;
                final CountDownLatch timeHasPassed = new CountDownLatch(COUNT);
                final AtomicBoolean running = new AtomicBoolean(true);
                final AtomicInteger count = new AtomicInteger(0);
                final Observable<Integer> obs = Observable.unsafeCreate(new ObservableSource<Integer>() {

                    @Override
                    public void subscribe(final Observer<? super Integer> o) {
                        o.onSubscribe(Disposable.empty());
                        task.replace(Schedulers.single().scheduleDirect(new Runnable() {

                            @Override
                            public void run() {
                                try {
                                    while (running.get() && !task.isDisposed()) {
                                        o.onNext(count.incrementAndGet());
                                        timeHasPassed.countDown();
                                    }
                                    o.onComplete();
                                } catch (Throwable e) {
                                    o.onError(e);
                                } finally {
                                    finished.countDown();
                                }
                            }
                        }));
                    }

                });

                Iterator<Integer> it = next(obs).iterator();

                assertTrue(it.hasNext());
                int a = it.next();
                assertTrue(it.hasNext());
                int b = it.next();
                // we should have a different value
                assertTrue(""a and b should be different"", a != b);

                // wait for some time (if times out we are blocked somewhere so fail ... set very high for very slow, constrained machines)
                timeHasPassed.await(8000, TimeUnit.MILLISECONDS);

                assertTrue(it.hasNext());
                int c = it.next();

                assertTrue(""c should not just be the next in sequence"", c != (b + 1));
                assertTrue(""expected that c ["" + c + ""] is higher than or equal to "" + COUNT, c >= COUNT);

                assertTrue(it.hasNext());
                int d = it.next();
                assertTrue(d > c);

                // shut down the thread
                running.set(false);

                finished.await();

                assertFalse(it.hasNext());

                System.out.println(""a: "" + a + "" b: "" + b + "" c: "" + c);
                break;
            }",maybe_loop_control
task,"for (;;) {
            final SerialDisposable task = new SerialDisposable();
            try {
                final CountDownLatch finished = new CountDownLatch(1);
                final int COUNT = 30;
                final CountDownLatch timeHasPassed = new CountDownLatch(COUNT);
                final AtomicBoolean running = new AtomicBoolean(true);
                final AtomicInteger count = new AtomicInteger(0);
                final Observable<Integer> obs = Observable.unsafeCreate(new ObservableSource<Integer>() {

                    @Override
                    public void subscribe(final Observer<? super Integer> o) {
                        o.onSubscribe(Disposable.empty());
                        task.replace(Schedulers.single().scheduleDirect(new Runnable() {

                            @Override
                            public void run() {
                                try {
                                    while (running.get() && !task.isDisposed()) {
                                        o.onNext(count.incrementAndGet());
                                        timeHasPassed.countDown();
                                    }
                                    o.onComplete();
                                } catch (Throwable e) {
                                    o.onError(e);
                                } finally {
                                    finished.countDown();
                                }
                            }
                        }));
                    }

                });

                Iterator<Integer> it = next(obs).iterator();

                assertTrue(it.hasNext());
                int a = it.next();
                assertTrue(it.hasNext());
                int b = it.next();
                // we should have a different value
                assertTrue(""a and b should be different"", a != b);

                // wait for some time (if times out we are blocked somewhere so fail ... set very high for very slow, constrained machines)
                timeHasPassed.await(8000, TimeUnit.MILLISECONDS);

                assertTrue(it.hasNext());
                int c = it.next();

                assertTrue(""c should not just be the next in sequence"", c != (b + 1));
                assertTrue(""expected that c ["" + c + ""] is higher than or equal to "" + COUNT, c >= COUNT);

                assertTrue(it.hasNext());
                int d = it.next();
                assertTrue(d > c);

                // shut down the thread
                running.set(false);

                finished.await();

                assertFalse(it.hasNext());

                System.out.println(""a: "" + a + "" b: "" + b + "" c: "" + c);
                break;
            } catch (AssertionError ex) {
                if (++repeat == 3) {
                    throw ex;
                }
                Thread.sleep((int)(1000 * Math.pow(2, repeat - 1)));
            } finally {
                task.dispose();
            }
        }",maybe_loop_control
it,"{
                final CountDownLatch finished = new CountDownLatch(1);
                final int COUNT = 30;
                final CountDownLatch timeHasPassed = new CountDownLatch(COUNT);
                final AtomicBoolean running = new AtomicBoolean(true);
                final AtomicInteger count = new AtomicInteger(0);
                final Observable<Integer> obs = Observable.unsafeCreate(new ObservableSource<Integer>() {

                    @Override
                    public void subscribe(final Observer<? super Integer> o) {
                        o.onSubscribe(Disposable.empty());
                        task.replace(Schedulers.single().scheduleDirect(new Runnable() {

                            @Override
                            public void run() {
                                try {
                                    while (running.get() && !task.isDisposed()) {
                                        o.onNext(count.incrementAndGet());
                                        timeHasPassed.countDown();
                                    }
                                    o.onComplete();
                                } catch (Throwable e) {
                                    o.onError(e);
                                } finally {
                                    finished.countDown();
                                }
                            }
                        }));
                    }

                });

                Iterator<Integer> it = next(obs).iterator();

                assertTrue(it.hasNext());
                int a = it.next();
                assertTrue(it.hasNext());
                int b = it.next();
                // we should have a different value
                assertTrue(""a and b should be different"", a != b);

                // wait for some time (if times out we are blocked somewhere so fail ... set very high for very slow, constrained machines)
                timeHasPassed.await(8000, TimeUnit.MILLISECONDS);

                assertTrue(it.hasNext());
                int c = it.next();

                assertTrue(""c should not just be the next in sequence"", c != (b + 1));
                assertTrue(""expected that c ["" + c + ""] is higher than or equal to "" + COUNT, c >= COUNT);

                assertTrue(it.hasNext());
                int d = it.next();
                assertTrue(d > c);

                // shut down the thread
                running.set(false);

                finished.await();

                assertFalse(it.hasNext());

                System.out.println(""a: "" + a + "" b: "" + b + "" c: "" + c);
                break;
            }",iterator
repeat,"{
        int repeat = 0;
        for (;;) {
            final SerialDisposable task = new SerialDisposable();
            try {
                final CountDownLatch finished = new CountDownLatch(1);
                final int COUNT = 30;
                final CountDownLatch timeHasPassed = new CountDownLatch(COUNT);
                final AtomicBoolean running = new AtomicBoolean(true);
                final AtomicInteger count = new AtomicInteger(0);
                final Observable<Integer> obs = Observable.unsafeCreate(new ObservableSource<Integer>() {

                    @Override
                    public void subscribe(final Observer<? super Integer> o) {
                        o.onSubscribe(Disposable.empty());
                        task.replace(Schedulers.single().scheduleDirect(new Runnable() {

                            @Override
                            public void run() {
                                try {
                                    while (running.get() && !task.isDisposed()) {
                                        o.onNext(count.incrementAndGet());
                                        timeHasPassed.countDown();
                                    }
                                    o.onComplete();
                                } catch (Throwable e) {
                                    o.onError(e);
                                } finally {
                                    finished.countDown();
                                }
                            }
                        }));
                    }

                });

                Iterator<Integer> it = next(obs).iterator();

                assertTrue(it.hasNext());
                int a = it.next();
                assertTrue(it.hasNext());
                int b = it.next();
                // we should have a different value
                assertTrue(""a and b should be different"", a != b);

                // wait for some time (if times out we are blocked somewhere so fail ... set very high for very slow, constrained machines)
                timeHasPassed.await(8000, TimeUnit.MILLISECONDS);

                assertTrue(it.hasNext());
                int c = it.next();

                assertTrue(""c should not just be the next in sequence"", c != (b + 1));
                assertTrue(""expected that c ["" + c + ""] is higher than or equal to "" + COUNT, c >= COUNT);

                assertTrue(it.hasNext());
                int d = it.next();
                assertTrue(d > c);

                // shut down the thread
                running.set(false);

                finished.await();

                assertFalse(it.hasNext());

                System.out.println(""a: "" + a + "" b: "" + b + "" c: "" + c);
                break;
            } catch (AssertionError ex) {
                if (++repeat == 3) {
                    throw ex;
                }
                Thread.sleep((int)(1000 * Math.pow(2, repeat - 1)));
            } finally {
                task.dispose();
            }
        }
    }",break_loop_control
j,"for (int j = 0; j < 3; j++) {
            BlockingObservableNext.NextIterator<Long> it = (BlockingObservableNext.NextIterator<Long>)iter.iterator();

            for (long i = 0; i < 10; i++) {
                Assert.assertTrue(it.hasNext());
                Assert.assertEquals(j + ""th iteration next"", Long.valueOf(i), it.next());
            }
            terminal.onNext(1);
        }",loop_control
i,"for (long i = 0; i < 10; i++) {
                Assert.assertTrue(it.hasNext());
                Assert.assertEquals(j + ""th iteration next"", Long.valueOf(i), it.next());
            }",loop_control
it,"{
        Iterator<Object> it = Observable.never().blockingNext().iterator();

        try {
            Thread.currentThread().interrupt();
            it.next();
        } catch (RuntimeException ex) {
            assertTrue(ex.toString(), ex.getCause() instanceof InterruptedException);
        }
    }",iterator
i,"for (int i = 0; i < TestHelper.RACE_DEFAULT_LOOPS; i++) {
            final TestScheduler scheduler = new TestScheduler();

            final PublishSubject<Integer> ps = PublishSubject.create();

            TestObserver<Integer> to = ps.sample(1, TimeUnit.SECONDS, scheduler, true)
            .test();

            ps.onNext(1);

            Runnable r1 = new Runnable() {
                @Override
                public void run() {
                    ps.onComplete();
                }
            };

            Runnable r2 = new Runnable() {
                @Override
                public void run() {
                    scheduler.advanceTimeBy(1, TimeUnit.SECONDS);
                }
            };

            TestHelper.race(r1, r2);

            to.assertResult(1);
        }",loop_control
i,"for (int i = 0; i < TestHelper.RACE_DEFAULT_LOOPS; i++) {
            final PublishSubject<Integer> ps = PublishSubject.create();
            final PublishSubject<Integer> sampler = PublishSubject.create();

            TestObserver<Integer> to = ps.sample(sampler, true)
            .test();

            ps.onNext(1);

            Runnable r1 = new Runnable() {
                @Override
                public void run() {
                    ps.onComplete();
                }
            };

            Runnable r2 = new Runnable() {
                @Override
                public void run() {
                    sampler.onNext(1);
                }
            };

            TestHelper.race(r1, r2);

            to.assertResult(1);
        }",loop_control
i,"for (int i = 0; i < TestHelper.RACE_DEFAULT_LOOPS; i++) {
            final PublishSubject<Integer> ps = PublishSubject.create();
            final PublishSubject<Integer> sampler = PublishSubject.create();

            TestObserver<Integer> to = ps.sample(sampler, true).test();

            ps.onNext(1);

            Runnable r1 = new Runnable() {
                @Override
                public void run() {
                    ps.onComplete();
                }
            };

            Runnable r2 = new Runnable() {
                @Override
                public void run() {
                    sampler.onComplete();
                }
            };

            TestHelper.race(r1, r2);

            to.assertResult(1);
        }",loop_control
i,"for (int i = 0; i < TestHelper.RACE_DEFAULT_LOOPS; i++) {
            final TestScheduler sch = new TestScheduler();

            final PublishSubject<Integer> ps = PublishSubject.create();

            TestObserverEx<Integer> to = ps.timeout(1, TimeUnit.SECONDS, sch).to(TestHelper.<Integer>testConsumer());

            Runnable r1 = new Runnable() {
                @Override
                public void run() {
                    ps.onNext(1);
                }
            };

            Runnable r2 = new Runnable() {
                @Override
                public void run() {
                    sch.advanceTimeBy(1, TimeUnit.SECONDS);
                }
            };

            TestHelper.race(r1, r2);

            if (to.values().size() != 0) {
                if (to.errors().size() != 0) {
                    to.assertFailure(TimeoutException.class, 1);
                    to.assertErrorMessage(timeoutMessage(1, TimeUnit.SECONDS));
                } else {
                    to.assertValuesOnly(1);
                }
            } else {
                to.assertFailure(TimeoutException.class);
                to.assertErrorMessage(timeoutMessage(1, TimeUnit.SECONDS));
            }
        }",loop_control
i,"for (int i = 0; i < TestHelper.RACE_DEFAULT_LOOPS; i++) {
            final TestScheduler sch = new TestScheduler();

            final PublishSubject<Integer> ps = PublishSubject.create();

            TestObserverEx<Integer> to = ps.timeout(1, TimeUnit.SECONDS, sch, Observable.just(2)).to(TestHelper.<Integer>testConsumer());

            Runnable r1 = new Runnable() {
                @Override
                public void run() {
                    ps.onNext(1);
                }
            };

            Runnable r2 = new Runnable() {
                @Override
                public void run() {
                    sch.advanceTimeBy(1, TimeUnit.SECONDS);
                }
            };

            TestHelper.race(r1, r2);

            if (to.isTerminated()) {
                int c = to.values().size();
                if (c == 1) {
                    int v = to.values().get(0);
                    assertTrue("""" + v, v == 1 || v == 2);
                } else {
                    to.assertResult(1, 2);
                }
            } else {
                to.assertValuesOnly(1);
            }
        }",loop_control
i,"for (int i = 0; i < n; i++) {
                List<Observable<?>> sources = new ArrayList<>();
                List<String> expected = new ArrayList<>();
                expected.add(val);

                for (int j = 0; j < i; j++) {
                    sources.add(Observable.just(val));
                    expected.add(String.valueOf(val));
                }

                TestObserver<String> to = new TestObserver<>();

                PublishSubject<String> main = PublishSubject.create();

                main.withLatestFrom(sources, toArray).subscribe(to);

                to.assertNoValues();

                main.onNext(val);
                main.onComplete();

                to.assertValue(expected.toString());
                to.assertNoErrors();
                to.assertComplete();
            }",loop_control
j,"for (int j = 0; j < i; j++) {
                    sources.add(Observable.just(val));
                    expected.add(String.valueOf(val));
                }",loop_control
val,"for (String val : new String[] { ""1"" /*, null*/ }) {
            int n = 35;
            for (int i = 0; i < n; i++) {
                List<Observable<?>> sources = new ArrayList<>();
                List<String> expected = new ArrayList<>();
                expected.add(val);

                for (int j = 0; j < i; j++) {
                    sources.add(Observable.just(val));
                    expected.add(String.valueOf(val));
                }

                TestObserver<String> to = new TestObserver<>();

                PublishSubject<String> main = PublishSubject.create();

                main.withLatestFrom(sources, toArray).subscribe(to);

                to.assertNoValues();

                main.onNext(val);
                main.onComplete();

                to.assertValue(expected.toString());
                to.assertNoErrors();
                to.assertComplete();
            }
        }",iterator
i,"for (int i = 0; i < 10; i++) {
            try {
                refCountAsyncActual();
                return;
            } catch (AssertionError ex) {
                if (i == 9) {
                    throw ex;
                }
                Thread.sleep((int)(200 * (Math.random() * 10 + 1)));
            }
        }",loop_control
i,"for (int i = 0; i < 10; i++) {
            TestObserver<Long> to1 = new TestObserver<>();
            TestObserver<Long> to2 = new TestObserver<>();
            r.subscribe(to1);
            r.subscribe(to2);
            try {
                Thread.sleep(50);
            } catch (InterruptedException e) {
            }
            to1.dispose();
            to2.dispose();
            to1.assertNoErrors();
            to2.assertNoErrors();
            assertTrue(to1.values().size() > 0);
            assertTrue(to2.values().size() > 0);
        }",loop_control
i,"for (int i = 0; i < 100; i++) {
            connectUnsubscribeRaceCondition();
        }",loop_control
subUnsubCount,"{
        final AtomicInteger subUnsubCount = new AtomicInteger();
        Observable<Long> o = synchronousInterval()
                .doOnDispose(new Action() {
                    @Override
                    public void run() {
                            System.out.println(""******************************* Unsubscribe received"");
                            // when we are unsubscribed
                            subUnsubCount.decrementAndGet();
                    }
                })
                .doOnSubscribe(new Consumer<Disposable>() {
                    @Override
                    public void accept(Disposable d) {
                            System.out.println(""******************************* SUBSCRIBE received"");
                            subUnsubCount.incrementAndGet();
                    }
                });

        TestObserverEx<Long> observer = new TestObserverEx<>();

        o.publish().refCount().subscribeOn(Schedulers.computation()).subscribe(observer);
        System.out.println(""send unsubscribe"");
        // now immediately unsubscribe while subscribeOn is racing to subscribe
        observer.dispose();

        // this generally will mean it won't even subscribe as it is already unsubscribed by the time connect() gets scheduled
        // give time to the counter to update
        Thread.sleep(10);

        // make sure we wait a bit in case the counter is still nonzero
        int counter = 200;
        while (subUnsubCount.get() != 0 && counter-- != 0) {
            Thread.sleep(10);
        }
        // either we subscribed and then unsubscribed, or we didn't ever even subscribe
        assertEquals(0, subUnsubCount.get());

        System.out.println(""DONE sending unsubscribe ... now waiting"");
        System.out.println(""Errors: "" + observer.errors());
        if (observer.errors().size() > 0) {
            observer.errors().get(0).printStackTrace();
        }
        observer.assertNoErrors();
    }",maybe_loop_control
counter,"{
        final AtomicInteger subUnsubCount = new AtomicInteger();
        Observable<Long> o = synchronousInterval()
                .doOnDispose(new Action() {
                    @Override
                    public void run() {
                            System.out.println(""******************************* Unsubscribe received"");
                            // when we are unsubscribed
                            subUnsubCount.decrementAndGet();
                    }
                })
                .doOnSubscribe(new Consumer<Disposable>() {
                    @Override
                    public void accept(Disposable d) {
                            System.out.println(""******************************* SUBSCRIBE received"");
                            subUnsubCount.incrementAndGet();
                    }
                });

        TestObserverEx<Long> observer = new TestObserverEx<>();

        o.publish().refCount().subscribeOn(Schedulers.computation()).subscribe(observer);
        System.out.println(""send unsubscribe"");
        // now immediately unsubscribe while subscribeOn is racing to subscribe
        observer.dispose();

        // this generally will mean it won't even subscribe as it is already unsubscribed by the time connect() gets scheduled
        // give time to the counter to update
        Thread.sleep(10);

        // make sure we wait a bit in case the counter is still nonzero
        int counter = 200;
        while (subUnsubCount.get() != 0 && counter-- != 0) {
            Thread.sleep(10);
        }
        // either we subscribed and then unsubscribed, or we didn't ever even subscribe
        assertEquals(0, subUnsubCount.get());

        System.out.println(""DONE sending unsubscribe ... now waiting"");
        System.out.println(""Errors: "" + observer.errors());
        if (observer.errors().size() > 0) {
            observer.errors().get(0).printStackTrace();
        }
        observer.assertNoErrors();
    }",loop_control
cancel,"{
                final AtomicBoolean cancel = new AtomicBoolean();
                observer.onSubscribe(Disposable.fromRunnable(new Runnable() {
                    @Override
                    public void run() {
                        cancel.set(true);
                    }
                }));
                for (;;) {
                    if (cancel.get()) {
                        break;
                    }
                    try {
                        Thread.sleep(100);
                    } catch (InterruptedException e) {
                    }
                    observer.onNext(1L);
                }
            }",break_loop_control
emitter,"{
                    @Override
                    public void subscribe(ObservableEmitter<Object> emitter) throws Exception {
                        while (!emitter.isDisposed()) {
                            Thread.sleep(100);
                        }
                        interrupted.set(true);
                    }
                }",maybe_loop_control
i,"for (int i = 0; i < 3; i++) {
            TestObserver<Integer> to1 = source.test();

            to1.withTag(""to1 "" + i);
            to1.assertEmpty();

            TestObserver<Integer> to2 = source.test();

            to2.withTag(""to2 "" + i);

            to1.assertResult(1, 2, 3, 4, 5);
            to2.assertResult(1, 2, 3, 4, 5);
        }",loop_control
i,"for (int i = 0; i < 3; i++) {
            TestObserver<Integer> to2 = source.test();
            to1.dispose();
            to1 = to2;
        }",loop_control
i,"for (int i = 0; i < 1000; i++) {

            final Observable<Integer> source = Observable.range(1, 5)
                    .replay()
                    .refCount(1)
                    ;

            final TestObserver<Integer> to1 = source.test();

            final TestObserver<Integer> to2 = new TestObserver<>();

            Runnable r1 = new Runnable() {
                @Override
                public void run() {
                    to1.dispose();
                }
            };

            Runnable r2 = new Runnable() {
                @Override
                public void run() {
                    source.subscribe(to2);
                }
            };

            TestHelper.race(r1, r2, Schedulers.single());

            to2
            .withTag(""Round: "" + i)
            .assertResult(1, 2, 3, 4, 5);
        }",loop_control
i,"for (int i = 0; i < TestHelper.RACE_LONG_LOOPS; i++) {
            Observable<Integer> observable = Observable.just(1).replay(1).refCount();

            TestObserver<Integer> observer1 = observable
                    .subscribeOn(Schedulers.io())
                    .test();

            TestObserver<Integer> observer2 = observable
                    .subscribeOn(Schedulers.io())
                    .test();

            observer1
            .withTag("""" + i)
            .awaitDone(5, TimeUnit.SECONDS)
            .assertResult(1);

            observer2
            .withTag("""" + i)
            .awaitDone(5, TimeUnit.SECONDS)
            .assertResult(1);
        }",loop_control
i,"for (int i = 0; i < TestHelper.RACE_LONG_LOOPS; i++) {
            Observable<Integer> observable = Observable.just(1).publish().refCount();

            TestObserver<Integer> observer1 = observable
                    .subscribeOn(Schedulers.io())
                    .test();

            TestObserver<Integer> observer2 = observable
                    .subscribeOn(Schedulers.io())
                    .test();

            observer1
            .withTag(""observer1 "" + i)
            .awaitDone(5, TimeUnit.SECONDS)
            .assertNoErrors()
            .assertComplete();

            observer2
            .withTag(""observer2 "" + i)
            .awaitDone(5, TimeUnit.SECONDS)
            .assertNoErrors()
            .assertComplete();
        }",loop_control
timeout,"{
            final CountDownLatch cdl1 = new CountDownLatch(1);
            final CountDownLatch cdl2 = new CountDownLatch(1);

            TestObserver<Object> to = Observable.fromAction(new Action() {
                @Override
                public void run() throws Exception {
                    cdl1.countDown();
                    cdl2.await(5, TimeUnit.SECONDS);
                }
            }).subscribeOn(Schedulers.single()).test();

            assertTrue(cdl1.await(5, TimeUnit.SECONDS));

            to.dispose();

            int timeout = 10;

            while (timeout-- > 0 && errors.isEmpty()) {
                Thread.sleep(100);
            }

            TestHelper.assertUndeliverable(errors, 0, InterruptedException.class);
        }",loop_control
errors,"{
        List<Throwable> errors = TestHelper.trackPluginErrors();
        try {
            final CountDownLatch cdl1 = new CountDownLatch(1);
            final CountDownLatch cdl2 = new CountDownLatch(1);

            TestObserver<Object> to = Observable.fromAction(new Action() {
                @Override
                public void run() throws Exception {
                    cdl1.countDown();
                    cdl2.await(5, TimeUnit.SECONDS);
                }
            }).subscribeOn(Schedulers.single()).test();

            assertTrue(cdl1.await(5, TimeUnit.SECONDS));

            to.dispose();

            int timeout = 10;

            while (timeout-- > 0 && errors.isEmpty()) {
                Thread.sleep(100);
            }

            TestHelper.assertUndeliverable(errors, 0, InterruptedException.class);
        } finally {
            RxJavaPlugins.reset();
        }
    }",maybe_loop_control
i,"for (int i = 0; i < n; i++) {
            PublishSubject<Integer> delay = PublishSubject.create();
            delays.add(delay);
        }",loop_control
i,"for (int i = 0; i < n; i++) {
            source.onNext(i);
            delays.get(i).onNext(i);
            inOrder.verify(o).onNext(i);
        }",loop_control
i,"for (int i = 0; i < n; i++) {
            subjects.add(PublishSubject.<Integer> create());
        }",loop_control
i,"for (int i = 0; i < n; i++) {
            source.onNext(i);
        }",loop_control
i,"for (int i = n - 1; i >= 0; i--) {
            subjects.get(i).onComplete();
            inOrder.verify(o).onNext(i);
        }",loop_control
i,"for (int i = 0; i < 10000; i++) {
            final PublishSubject<Integer> ps = PublishSubject.create();
            final SingleSubject<Integer> cs = SingleSubject.create();

            TestObserver<Integer> to = ps.mergeWith(cs).test();

            Runnable r1 = new Runnable() {
                @Override
                public void run() {
                    ps.onNext(1);
                    ps.onComplete();
                }
            };

            Runnable r2 = new Runnable() {
                @Override
                public void run() {
                    cs.onSuccess(1);
                }
            };

            TestHelper.race(r1, r2);

            to.assertResult(1, 1);
        }",loop_control
it,"{
        Observable<String> obs = Observable.just(""one"", ""two"", ""three"");

        Iterator<String> it = obs.blockingIterable().iterator();

        assertTrue(it.hasNext());
        assertEquals(""one"", it.next());

        assertTrue(it.hasNext());
        assertEquals(""two"", it.next());

        assertTrue(it.hasNext());
        assertEquals(""three"", it.next());

        assertFalse(it.hasNext());

    }",iterator
it,"{
        Observable<String> obs = Observable.unsafeCreate(new ObservableSource<String>() {

            @Override
            public void subscribe(Observer<? super String> observer) {
                observer.onSubscribe(Disposable.empty());
                observer.onNext(""one"");
                observer.onError(new TestException());
            }
        });

        Iterator<String> it = obs.blockingIterable().iterator();

        assertTrue(it.hasNext());
        assertEquals(""one"", it.next());

        assertTrue(it.hasNext());
        it.next();
    }",iterator
it,"{
        BlockingObservableIterator<Integer> it = new BlockingObservableIterator<>(128);

        assertFalse(it.isDisposed());

        it.dispose();

        assertTrue(it.isDisposed());
    }",iterator
it,"{
        BlockingObservableIterator<Integer> it = new BlockingObservableIterator<>(128);

        try {
            Thread.currentThread().interrupt();

            it.hasNext();
        } catch (RuntimeException ex) {
            assertTrue(ex.toString(), ex.getCause() instanceof InterruptedException);
        }
    }",iterator
it,"{
        BlockingObservableIterator<Integer> it = new BlockingObservableIterator<>(128);
        it.onComplete();
        it.next();
    }",iterator
it,"{
        BlockingObservableIterator<Integer> it = new BlockingObservableIterator<>(128);
        it.remove();
    }",iterator
it,"{
        Iterator<Integer> it = PublishSubject.<Integer>create()
                .blockingIterable().iterator();
        ((Disposable)it).dispose();
        assertFalse(it.hasNext());
        it.next();
    }",iterator
it,"{
        final Iterator<Integer> it = PublishSubject.<Integer>create()
                .blockingIterable().iterator();

        Schedulers.single().scheduleDirect(new Runnable() {
            @Override
            public void run() {
                ((Disposable)it).dispose();
            }
        }, 1, TimeUnit.SECONDS);

        assertFalse(it.hasNext());
    }",iterator
it,"{
        Iterator<Object> it = Observable.error(new TestException()).blockingIterable().iterator();

        ((Disposable)it).dispose();

        it.hasNext();
    }",iterator
to,"{
        final TestObserver<Object> to = new TestObserver<>();
        final Observer[] s = { null };

        Schedulers.single().scheduleDirect(new Runnable() {
            @SuppressWarnings(""unchecked"")
            @Override
            public void run() {
                to.dispose();
                s[0].onNext(1);
            }
        }, 200, TimeUnit.MILLISECONDS);

        new Observable<Integer>() {
            @Override
            protected void subscribeActual(Observer<? super Integer> observer) {
                observer.onSubscribe(Disposable.empty());
                s[0] = observer;
            }
        }.blockingSubscribe(to);

        while (!to.isDisposed()) {
            Thread.sleep(100);
        }

        to.assertEmpty();
    }",maybe_loop_control
i,"for (int i = 0; i < 1000; i++) {
            final PublishSubject<Integer> ps = PublishSubject.create();
            final CompletableSubject cs = CompletableSubject.create();

            TestObserver<Integer> to = ps.mergeWith(cs).test();

            Runnable r1 = new Runnable() {
                @Override
                public void run() {
                    ps.onNext(1);
                    ps.onComplete();
                }
            };

            Runnable r2 = new Runnable() {
                @Override
                public void run() {
                    cs.onComplete();
                }
            };

            TestHelper.race(r1, r2);

            to.assertResult(1);
        }",loop_control
i,"for (int i = 0; i < TestHelper.RACE_DEFAULT_LOOPS; i++) {
            List<Throwable> errors = TestHelper.trackPluginErrors();
            try {
                final PublishProcessor<Integer> pp0 = PublishProcessor.create();
                final PublishProcessor<Integer> pp1 = PublishProcessor.create();

                final TestObserver<Object> to = Maybe.zip(
                        Arrays.asList(pp0.singleElement(), pp1.singleElement()), addString)
                .test();

                final TestException ex = new TestException();

                Runnable r1 = new Runnable() {
                    @Override
                    public void run() {
                        pp0.onError(ex);
                    }
                };

                Runnable r2 = new Runnable() {
                    @Override
                    public void run() {
                        pp1.onError(ex);
                    }
                };

                TestHelper.race(r1, r2);

                to.assertFailure(TestException.class);

                if (!errors.isEmpty()) {
                    TestHelper.assertUndeliverable(errors, 0, TestException.class);
                }
            } finally {
                RxJavaPlugins.reset();
            }
        }",loop_control
times,"{
        PublishProcessor<Integer> pp = PublishProcessor.create();

        final String[] name = { null };

        final CountDownLatch cdl = new CountDownLatch(1);

        pp.doOnCancel(new Action() {
            @Override
            public void run() throws Exception {
                name[0] = Thread.currentThread().getName();
                cdl.countDown();
            }
        })
        .singleElement()
        .unsubscribeOn(Schedulers.single())
        .test(true)
        ;

        assertTrue(cdl.await(5, TimeUnit.SECONDS));

        int times = 10;

        while (times-- > 0 && pp.hasSubscribers()) {
            Thread.sleep(100);
        }

        assertFalse(pp.hasSubscribers());

        assertNotEquals(Thread.currentThread().getName(), name[0]);
    }",loop_control
pp,"{
        PublishProcessor<Integer> pp = PublishProcessor.create();

        final String[] name = { null };

        final CountDownLatch cdl = new CountDownLatch(1);

        pp.doOnCancel(new Action() {
            @Override
            public void run() throws Exception {
                name[0] = Thread.currentThread().getName();
                cdl.countDown();
            }
        })
        .singleElement()
        .unsubscribeOn(Schedulers.single())
        .test(true)
        ;

        assertTrue(cdl.await(5, TimeUnit.SECONDS));

        int times = 10;

        while (times-- > 0 && pp.hasSubscribers()) {
            Thread.sleep(100);
        }

        assertFalse(pp.hasSubscribers());

        assertNotEquals(Thread.currentThread().getName(), name[0]);
    }",maybe_loop_control
i,"for (int i = 0; i < TestHelper.RACE_DEFAULT_LOOPS; i++) {
            PublishProcessor<Integer> pp = PublishProcessor.create();

            final Disposable[] ds = { null };
            pp.singleElement().unsubscribeOn(Schedulers.computation())
            .subscribe(new MaybeObserver<Integer>() {
                @Override
                public void onSubscribe(Disposable d) {
                    ds[0] = d;
                }

                @Override
                public void onSuccess(Integer value) {

                }

                @Override
                public void onError(Throwable e) {

                }

                @Override
                public void onComplete() {

                }
            });

            Runnable r = new Runnable() {
                @Override
                public void run() {
                    ds[0].dispose();
                }
            };

            TestHelper.race(r, r);
        }",loop_control
i,"for (int i = 0; i < TestHelper.RACE_DEFAULT_LOOPS; i++) {

            final PublishProcessor<Integer> pp = PublishProcessor.create();

            final TestSubscriber<Integer> ts = Maybe.concat(Arrays.asList(pp.singleElement()))
            .test();

            pp.onNext(1);

            Runnable r1 = new Runnable() {
                @Override
                public void run() {
                    ts.cancel();
                }
            };

            Runnable r2 = new Runnable() {
                @Override
                public void run() {
                    pp.onComplete();
                }
            };

            TestHelper.race(r1, r2);
        }",loop_control
i,"for (int i = 0; i < TestHelper.RACE_DEFAULT_LOOPS; i++) {
            List<Throwable> errors = TestHelper.trackPluginErrors();
            try {
                final PublishProcessor<Integer> pp0 = PublishProcessor.create();
                final PublishProcessor<Integer> pp1 = PublishProcessor.create();

                final TestObserver<Object> to = Maybe.zip(pp0.singleElement(), pp1.singleElement(), addString)
                .test();

                final TestException ex = new TestException();

                Runnable r1 = new Runnable() {
                    @Override
                    public void run() {
                        pp0.onError(ex);
                    }
                };

                Runnable r2 = new Runnable() {
                    @Override
                    public void run() {
                        pp1.onError(ex);
                    }
                };

                TestHelper.race(r1, r2);

                to.assertFailure(TestException.class);

                if (!errors.isEmpty()) {
                    TestHelper.assertUndeliverable(errors, 0, TestException.class);
                }
            } finally {
                RxJavaPlugins.reset();
            }
        }",loop_control
i,"for (int i = 0; i < 32; i++) {
            ms.add(Maybe.<Integer>never());
        }",loop_control
i,"for (int i = 0; i < TestHelper.RACE_DEFAULT_LOOPS; i++) {
            List<Throwable> errors = TestHelper.trackPluginErrors();
            try {
                final PublishProcessor<Integer> pp0 = PublishProcessor.create();
                final PublishProcessor<Integer> pp1 = PublishProcessor.create();

                final TestObserver<Integer> to = Maybe.amb(Arrays.asList(pp0.singleElement(), pp1.singleElement()))
                .test();

                final TestException ex = new TestException();

                Runnable r1 = new Runnable() {
                    @Override
                    public void run() {
                        pp0.onError(ex);
                    }
                };

                Runnable r2 = new Runnable() {
                    @Override
                    public void run() {
                        pp1.onError(ex);
                    }
                };

                TestHelper.race(r1, r2);

                to.assertFailure(TestException.class);

                if (!errors.isEmpty()) {
                    TestHelper.assertUndeliverable(errors, 0, TestException.class);
                }
            } finally {
                RxJavaPlugins.reset();
            }
        }",loop_control
i,"for (int i = 0; i < TestHelper.RACE_LONG_LOOPS; i++) {
            final AtomicBoolean interrupted = new AtomicBoolean();
            final CountDownLatch cdl = new CountDownLatch(1);

            Maybe.ambArray(
                Maybe.just(1)
                    .subscribeOn(Schedulers.single())
                    .observeOn(Schedulers.computation()),
                Maybe.never()
            )
            .subscribe(new Consumer<Object>() {
                @Override
                public void accept(Object v) throws Exception {
                    interrupted.set(Thread.currentThread().isInterrupted());
                    cdl.countDown();
                }
            });

            assertTrue(cdl.await(500, TimeUnit.SECONDS));
            assertFalse(""Interrupted!"", interrupted.get());
        }",loop_control
i,"for (int i = 0; i < TestHelper.RACE_LONG_LOOPS; i++) {
            final AtomicBoolean interrupted = new AtomicBoolean();
            final CountDownLatch cdl = new CountDownLatch(1);

            Maybe.ambArray(
                Maybe.error(ex)
                    .subscribeOn(Schedulers.single())
                    .observeOn(Schedulers.computation()),
                Maybe.never()
            )
            .subscribe(Functions.emptyConsumer(), new Consumer<Throwable>() {
                @Override
                public void accept(Throwable e) throws Exception {
                    interrupted.set(Thread.currentThread().isInterrupted());
                    cdl.countDown();
                }
            });

            assertTrue(cdl.await(500, TimeUnit.SECONDS));
            assertFalse(""Interrupted!"", interrupted.get());
        }",loop_control
i,"for (int i = 0; i < TestHelper.RACE_LONG_LOOPS; i++) {
            final AtomicBoolean interrupted = new AtomicBoolean();
            final CountDownLatch cdl = new CountDownLatch(1);

            Maybe.ambArray(
                Maybe.empty()
                    .subscribeOn(Schedulers.single())
                    .observeOn(Schedulers.computation()),
                Maybe.never()
            )
            .subscribe(Functions.emptyConsumer(), Functions.emptyConsumer(), new Action() {
                @Override
                public void run() throws Exception {
                    interrupted.set(Thread.currentThread().isInterrupted());
                    cdl.countDown();
                }
            });

            assertTrue(cdl.await(500, TimeUnit.SECONDS));
            assertFalse(""Interrupted!"", interrupted.get());
        }",loop_control
i,"for (int i = 0; i < TestHelper.RACE_DEFAULT_LOOPS; i++) {
            List<Throwable> errors = TestHelper.trackPluginErrors();

            try {

                final Subject<Integer> ps = ReplaySubject.create();
                ps.onNext(1);

                final Maybe<Integer> source = Maybe.ambArray(ps.singleElement(),
                        Maybe.<Integer>never(), Maybe.<Integer>never(), null);

                Runnable r1 = new Runnable() {
                    @Override
                    public void run() {
                        source.test();
                    }
                };

                Runnable r2 = new Runnable() {
                    @Override
                    public void run() {
                        ps.onComplete();
                    }
                };

                TestHelper.race(r1, r2);

                if (!errors.isEmpty()) {
                    TestHelper.assertError(errors, 0, NullPointerException.class);
                }
            } finally {
                RxJavaPlugins.reset();
            }
        }",loop_control
i,"for (int i = 0; i < 3; i++) {
            final int j = i + 1;
            sources[i] = Maybe.fromCallable(new Callable<Integer>() {
                @Override
                public Integer call() throws Exception {
                    return count.incrementAndGet() - j;
                }
            })
            .subscribeOn(Schedulers.io());
        }",loop_control
i,"for (int i = 0; i < 1000; i++) {
            count.set(0);
            Maybe.mergeDelayError(
                    Flowable.fromArray(sources), 1)
            .test()
            .awaitDone(5, TimeUnit.SECONDS)
            .assertResult(0, 0, 0);
        }",loop_control
i,"for (int i = 0; i < 3; i++) {
            final int j = i + 1;
            sources[i] = Maybe.fromCallable(new Callable<Integer>() {
                @Override
                public Integer call() throws Exception {
                    return count.incrementAndGet() - j;
                }
            })
            .subscribeOn(Schedulers.io());
        }",loop_control
i,"for (int i = 0; i < 1000; i++) {
            count.set(0);
            Maybe.mergeDelayError(
                    Flowable.fromArray(sources), 1)
            .to(TestHelper.<Integer>testConsumer())
            .awaitDone(5, TimeUnit.SECONDS)
            .assertFailureAndMessage(TestException.class, ""2"", 0, 0);
        }",loop_control
s,"for (Scheduler s : new Scheduler[] { Schedulers.single(), Schedulers.computation(), Schedulers.newThread(), Schedulers.io(), Schedulers.from(exec, true) }) {
                final AtomicBoolean interrupted = new AtomicBoolean();
                TestObserver<Long> to = Maybe.timer(1, TimeUnit.MILLISECONDS, s)
                .map(new Function<Long, Long>() {
                    @Override
                    public Long apply(Long v) throws Exception {
                        try {
                        Thread.sleep(3000);
                        } catch (InterruptedException ex) {
                            interrupted.set(true);
                        }
                        return v;
                    }
                })
                .test();

                Thread.sleep(500);

                to.dispose();

                Thread.sleep(500);

                assertTrue(s.getClass().getSimpleName(), interrupted.get());
            }",iterator
i,"for (int i = 0; i < TestHelper.RACE_DEFAULT_LOOPS; i++) {
            PublishProcessor<Integer> pp = PublishProcessor.create();

            final Maybe<Integer> source = pp.singleElement().cache();

            Runnable r = new Runnable() {
                @Override
                public void run() {
                    source.test();
                }
            };

            TestHelper.race(r, r);
        }",loop_control
i,"for (int i = 0; i < TestHelper.RACE_DEFAULT_LOOPS; i++) {
            PublishProcessor<Integer> pp = PublishProcessor.create();

            final Maybe<Integer> source = pp.singleElement().cache();

            final TestObserver<Integer> to1 = source.test();
            final TestObserver<Integer> to2 = source.test();

            Runnable r1 = new Runnable() {
                @Override
                public void run() {
                    to1.dispose();
                }
            };

            Runnable r2 = new Runnable() {
                @Override
                public void run() {
                    to2.dispose();
                }
            };

            TestHelper.race(r1, r2);
        }",loop_control
timeout,"{
            final CountDownLatch cdl1 = new CountDownLatch(1);
            final CountDownLatch cdl2 = new CountDownLatch(1);

            TestObserver<Object> to = Maybe.fromAction(new Action() {
                @Override
                public void run() throws Exception {
                    cdl1.countDown();
                    cdl2.await(5, TimeUnit.SECONDS);
                }
            }).subscribeOn(Schedulers.single()).test();

            assertTrue(cdl1.await(5, TimeUnit.SECONDS));

            to.dispose();

            int timeout = 10;

            while (timeout-- > 0 && errors.isEmpty()) {
                Thread.sleep(100);
            }

            TestHelper.assertUndeliverable(errors, 0, InterruptedException.class);
        }",loop_control
errors,"{
        List<Throwable> errors = TestHelper.trackPluginErrors();
        try {
            final CountDownLatch cdl1 = new CountDownLatch(1);
            final CountDownLatch cdl2 = new CountDownLatch(1);

            TestObserver<Object> to = Maybe.fromAction(new Action() {
                @Override
                public void run() throws Exception {
                    cdl1.countDown();
                    cdl2.await(5, TimeUnit.SECONDS);
                }
            }).subscribeOn(Schedulers.single()).test();

            assertTrue(cdl1.await(5, TimeUnit.SECONDS));

            to.dispose();

            int timeout = 10;

            while (timeout-- > 0 && errors.isEmpty()) {
                Thread.sleep(100);
            }

            TestHelper.assertUndeliverable(errors, 0, InterruptedException.class);
        } finally {
            RxJavaPlugins.reset();
        }
    }",maybe_loop_control
i,"for (int i = 0; i < TestHelper.RACE_DEFAULT_LOOPS; i++) {
            final PublishProcessor<Integer> pp = PublishProcessor.create();

            final TestObserver<Integer> to = pp.singleElement().switchIfEmpty(Single.just(2)).test();

            Runnable r1 = new Runnable() {
                @Override
                public void run() {
                    pp.onComplete();
                }
            };

            Runnable r2 = new Runnable() {
                @Override
                public void run() {
                    to.dispose();
                }
            };

            TestHelper.race(r1, r2);
        }",loop_control
timeout,"{
            final CountDownLatch cdl1 = new CountDownLatch(1);
            final CountDownLatch cdl2 = new CountDownLatch(1);

            TestObserver<Integer> to = Maybe.fromCallable(new Callable<Integer>() {
                @Override
                public Integer call() throws Exception {
                    cdl1.countDown();
                    cdl2.await(5, TimeUnit.SECONDS);
                    return 1;
                }
            }).subscribeOn(Schedulers.single()).test();

            assertTrue(cdl1.await(5, TimeUnit.SECONDS));

            to.dispose();

            int timeout = 10;

            while (timeout-- > 0 && errors.isEmpty()) {
                Thread.sleep(100);
            }

            TestHelper.assertUndeliverable(errors, 0, InterruptedException.class);
        }",loop_control
errors,"{
        List<Throwable> errors = TestHelper.trackPluginErrors();
        try {
            final CountDownLatch cdl1 = new CountDownLatch(1);
            final CountDownLatch cdl2 = new CountDownLatch(1);

            TestObserver<Integer> to = Maybe.fromCallable(new Callable<Integer>() {
                @Override
                public Integer call() throws Exception {
                    cdl1.countDown();
                    cdl2.await(5, TimeUnit.SECONDS);
                    return 1;
                }
            }).subscribeOn(Schedulers.single()).test();

            assertTrue(cdl1.await(5, TimeUnit.SECONDS));

            to.dispose();

            int timeout = 10;

            while (timeout-- > 0 && errors.isEmpty()) {
                Thread.sleep(100);
            }

            TestHelper.assertUndeliverable(errors, 0, InterruptedException.class);
        } finally {
            RxJavaPlugins.reset();
        }
    }",maybe_loop_control
i,"for (int i = 0; i < TestHelper.RACE_DEFAULT_LOOPS; i++) {
            final PublishProcessor<Integer> pp = PublishProcessor.create();

            final TestObserver<Integer> to = pp.singleElement().switchIfEmpty(Maybe.just(2)).test();

            Runnable r1 = new Runnable() {
                @Override
                public void run() {
                    pp.onComplete();
                }
            };

            Runnable r2 = new Runnable() {
                @Override
                public void run() {
                    to.dispose();
                }
            };

            TestHelper.race(r1, r2);
        }",loop_control
i,"for (int i = 0; i < TestHelper.RACE_DEFAULT_LOOPS; i++) {
            final PublishProcessor<Integer> pp1 = PublishProcessor.create();
            final PublishProcessor<Integer> pp2 = PublishProcessor.create();

            TestObserver<Integer> to = pp1.singleElement().takeUntil(pp2).test();

            final TestException ex1 = new TestException();
            final TestException ex2 = new TestException();

            List<Throwable> errors = TestHelper.trackPluginErrors();
            try {

                Runnable r1 = new Runnable() {
                    @Override
                    public void run() {
                        pp1.onError(ex1);
                    }
                };
                Runnable r2 = new Runnable() {
                    @Override
                    public void run() {
                        pp2.onError(ex2);
                    }
                };

                TestHelper.race(r1, r2);

                to.assertFailure(TestException.class);

                if (!errors.isEmpty()) {
                    TestHelper.assertUndeliverable(errors, 0, TestException.class);
                }

            } finally {
                RxJavaPlugins.reset();
            }

        }",loop_control
i,"for (int i = 0; i < TestHelper.RACE_DEFAULT_LOOPS; i++) {
            final PublishProcessor<Integer> pp1 = PublishProcessor.create();
            final PublishProcessor<Integer> pp2 = PublishProcessor.create();

            TestObserver<Integer> to = pp1.singleElement().takeUntil(pp2).test();

            Runnable r1 = new Runnable() {
                @Override
                public void run() {
                    pp1.onComplete();
                }
            };
            Runnable r2 = new Runnable() {
                @Override
                public void run() {
                    pp2.onComplete();
                }
            };

            TestHelper.race(r1, r2);

            to.assertResult();
        }",loop_control
i,"for (int i = 0; i < TestHelper.RACE_DEFAULT_LOOPS; i++) {
            List<Throwable> errors = TestHelper.trackPluginErrors();

            try {
                final PublishSubject<Integer> ps1 = PublishSubject.create();
                final PublishSubject<Integer> ps2 = PublishSubject.create();

                TestSubscriber<Integer> ts = Maybe.mergeArray(ps1.singleElement(), ps2.singleElement())
                .test();

                final TestException ex = new TestException();

                Runnable r1 = new Runnable() {
                    @Override
                    public void run() {
                        ps1.onError(ex);
                    }
                };

                Runnable r2 = new Runnable() {
                    @Override
                    public void run() {
                        ps2.onError(ex);
                    }
                };

                TestHelper.race(r1, r2);

                ts.assertFailure(Throwable.class);

                if (!errors.isEmpty()) {
                    TestHelper.assertUndeliverable(errors, 0, TestException.class);
                }
            } finally {
                RxJavaPlugins.reset();
            }
        }",loop_control
i,"for (int i = 0; i < TestHelper.RACE_DEFAULT_LOOPS; i++) {
            final PublishProcessor<Integer> pp1 = PublishProcessor.create();
            final PublishProcessor<Integer> pp2 = PublishProcessor.create();

            TestObserver<Integer> to = pp1.singleElement().takeUntil(pp2.singleElement()).test();

            final TestException ex1 = new TestException();
            final TestException ex2 = new TestException();

            List<Throwable> errors = TestHelper.trackPluginErrors();
            try {

                Runnable r1 = new Runnable() {
                    @Override
                    public void run() {
                        pp1.onError(ex1);
                    }
                };
                Runnable r2 = new Runnable() {
                    @Override
                    public void run() {
                        pp2.onError(ex2);
                    }
                };

                TestHelper.race(r1, r2);

                to.assertFailure(TestException.class);

                if (!errors.isEmpty()) {
                    TestHelper.assertUndeliverable(errors, 0, TestException.class);
                }

            } finally {
                RxJavaPlugins.reset();
            }

        }",loop_control
i,"for (int i = 0; i < TestHelper.RACE_DEFAULT_LOOPS; i++) {
            final PublishProcessor<Integer> pp1 = PublishProcessor.create();
            final PublishProcessor<Integer> pp2 = PublishProcessor.create();

            TestObserver<Integer> to = pp1.singleElement().takeUntil(pp2.singleElement()).test();

            Runnable r1 = new Runnable() {
                @Override
                public void run() {
                    pp1.onComplete();
                }
            };
            Runnable r2 = new Runnable() {
                @Override
                public void run() {
                    pp2.onComplete();
                }
            };

            TestHelper.race(r1, r2);

            to.assertResult();
        }",loop_control
i,"for (int i = 0; i < TestHelper.RACE_DEFAULT_LOOPS; i++) {
            final TestSubscriber<Integer> ts = Maybe.concatArray(Maybe.just(1), Maybe.just(2))
                    .test(0L);

            Runnable r1 = new Runnable() {
                @Override
                public void run() {
                    ts.cancel();
                }
            };

            Runnable r2 = new Runnable() {
                @Override
                public void run() {
                    ts.request(1);
                }
            };

            TestHelper.race(r1, r2);
        }",loop_control
i,"for (int i = 0; i < TestHelper.RACE_DEFAULT_LOOPS; i++) {
            final TestSubscriber<Integer> ts = Maybe.concatArrayDelayError(Maybe.just(1), Maybe.just(2))
                    .test(0L);

            Runnable r1 = new Runnable() {
                @Override
                public void run() {
                    ts.cancel();
                }
            };

            Runnable r2 = new Runnable() {
                @Override
                public void run() {
                    ts.request(1);
                }
            };

            TestHelper.race(r1, r2);
        }",loop_control
timeout,"{
            final CountDownLatch cdl1 = new CountDownLatch(1);
            final CountDownLatch cdl2 = new CountDownLatch(1);

            TestObserver<Object> to = Maybe.fromRunnable(new Runnable() {
                @Override
                public void run() {
                    cdl1.countDown();
                    try {
                        cdl2.await(5, TimeUnit.SECONDS);
                    } catch (InterruptedException ex) {
                        throw new RuntimeException(ex);
                    }
                }
            }).subscribeOn(Schedulers.single()).test();

            assertTrue(cdl1.await(5, TimeUnit.SECONDS));

            to.dispose();

            int timeout = 10;

            while (timeout-- > 0 && errors.isEmpty()) {
                Thread.sleep(100);
            }

            TestHelper.assertUndeliverable(errors, 0, RuntimeException.class);

            assertTrue(errors.get(0).toString(), errors.get(0).getCause().getCause() instanceof InterruptedException);
        }",loop_control
errors,"{
        List<Throwable> errors = TestHelper.trackPluginErrors();
        try {
            final CountDownLatch cdl1 = new CountDownLatch(1);
            final CountDownLatch cdl2 = new CountDownLatch(1);

            TestObserver<Object> to = Maybe.fromRunnable(new Runnable() {
                @Override
                public void run() {
                    cdl1.countDown();
                    try {
                        cdl2.await(5, TimeUnit.SECONDS);
                    } catch (InterruptedException ex) {
                        throw new RuntimeException(ex);
                    }
                }
            }).subscribeOn(Schedulers.single()).test();

            assertTrue(cdl1.await(5, TimeUnit.SECONDS));

            to.dispose();

            int timeout = 10;

            while (timeout-- > 0 && errors.isEmpty()) {
                Thread.sleep(100);
            }

            TestHelper.assertUndeliverable(errors, 0, RuntimeException.class);

            assertTrue(errors.get(0).toString(), errors.get(0).getCause().getCause() instanceof InterruptedException);
        } finally {
            RxJavaPlugins.reset();
        }
    }",maybe_loop_control
i,"for (int i = 0; i < TestHelper.RACE_DEFAULT_LOOPS; i++) {

            final PublishSubject<Integer> ps = PublishSubject.create();

            final TestObserver<Integer> to = Maybe.using(new Supplier<Object>() {
                @Override
                public Object get() throws Exception {
                    return 1;
                }
            }, new Function<Object, MaybeSource<Integer>>() {
                @Override
                public MaybeSource<Integer> apply(Object v) throws Exception {
                    return ps.lastElement();
                }
            }, new Consumer<Object>() {
                @Override
                public void accept(Object d) throws Exception {
                }
            }, true)
            .test();

            ps.onNext(1);

            Runnable r1 = new Runnable() {
                @Override
                public void run() {
                    to.dispose();
                }
            };

            Runnable r2 = new Runnable() {
                @Override
                public void run() {
                    ps.onComplete();
                }
            };

            TestHelper.race(r1, r2);
        }",loop_control
i,"for (int i = 0; i < TestHelper.RACE_DEFAULT_LOOPS; i++) {

            final PublishSubject<Integer> ps = PublishSubject.create();

            final TestObserver<Integer> to = Maybe.using(new Supplier<Object>() {
                @Override
                public Object get() throws Exception {
                    return 1;
                }
            }, new Function<Object, MaybeSource<Integer>>() {
                @Override
                public MaybeSource<Integer> apply(Object v) throws Exception {
                    return ps.firstElement();
                }
            }, new Consumer<Object>() {
                @Override
                public void accept(Object d) throws Exception {
                }
            }, true)
            .test();

            final TestException ex = new TestException();

            Runnable r1 = new Runnable() {
                @Override
                public void run() {
                    to.dispose();
                }
            };

            Runnable r2 = new Runnable() {
                @Override
                public void run() {
                    ps.onError(ex);
                }
            };

            TestHelper.race(r1, r2);
        }",loop_control
i,"for (int i = 0; i < TestHelper.RACE_DEFAULT_LOOPS; i++) {

            final PublishSubject<Integer> ps = PublishSubject.create();

            final TestObserver<Integer> to = Maybe.using(new Supplier<Object>() {
                @Override
                public Object get() throws Exception {
                    return 1;
                }
            }, new Function<Object, MaybeSource<Integer>>() {
                @Override
                public MaybeSource<Integer> apply(Object v) throws Exception {
                    return ps.firstElement();
                }
            }, new Consumer<Object>() {
                @Override
                public void accept(Object d) throws Exception {

                }
            }, true)
            .test();

            Runnable r1 = new Runnable() {
                @Override
                public void run() {
                    to.dispose();
                }
            };

            Runnable r2 = new Runnable() {
                @Override
                public void run() {
                    ps.onComplete();
                }
            };

            TestHelper.race(r1, r2);
        }",loop_control
i,"for (int i = 0; i < TestHelper.RACE_DEFAULT_LOOPS; i++) {
            TestHelper.trackPluginErrors();
            try {
                final PublishProcessor<Integer> pp1 = PublishProcessor.create();
                final PublishProcessor<Integer> pp2 = PublishProcessor.create();

                TestObserver<Integer> to = pp1.singleElement().timeout(pp2).test();

                final TestException ex = new TestException();

                Runnable r1 = new Runnable() {
                    @Override
                    public void run() {
                        pp1.onError(ex);
                    }
                };
                Runnable r2 = new Runnable() {
                    @Override
                    public void run() {
                        pp2.onError(ex);
                    }
                };

                TestHelper.race(r1, r2);

                to.assertFailure(TestException.class);
            } finally {
                RxJavaPlugins.reset();
            }
        }",loop_control
i,"for (int i = 0; i < TestHelper.RACE_DEFAULT_LOOPS; i++) {
            final PublishProcessor<Integer> pp1 = PublishProcessor.create();
            final PublishProcessor<Integer> pp2 = PublishProcessor.create();

            TestObserverEx<Integer> to = pp1.singleElement().timeout(pp2).to(TestHelper.<Integer>testConsumer());

            Runnable r1 = new Runnable() {
                @Override
                public void run() {
                    pp1.onComplete();
                }
            };
            Runnable r2 = new Runnable() {
                @Override
                public void run() {
                    pp2.onComplete();
                }
            };

            TestHelper.race(r1, r2);

            to.assertSubscribed().assertNoValues();

            if (to.errors().size() != 0) {
                to.assertError(TimeoutException.class).assertNotComplete();
            } else {
                to.assertNoErrors().assertComplete();
            }
        }",loop_control
i,"for (int i = 0; i < 500; i++) {
            final PublishSubject<Integer> ps = PublishSubject.create();

            ps.singleElement().flattenAsFlowable(
            new Function<Integer, Iterable<Integer>>() {
                @Override
                public Iterable<Integer> apply(Integer v) throws Exception {
                    return Arrays.asList(1, 2, 3);
                }
            })
            .test(5L)
            .assertEmpty();
        }",loop_control
i,"for (int i = 0; i < TestHelper.RACE_DEFAULT_LOOPS; i++) {
            final PublishSubject<Integer> ps = PublishSubject.create();

            ps.onNext(1);

            final TestSubscriber<Integer> ts = ps.singleElement().flattenAsFlowable(
            new Function<Integer, Iterable<Integer>>() {
                @Override
                public Iterable<Integer> apply(Integer v) throws Exception {
                    return Arrays.asList(a);
                }
            })
            .test(0L);

            Runnable r1 = new Runnable() {
                @Override
                public void run() {
                    ps.onComplete();
                    for (int i = 0; i < 500; i++) {
                        ts.request(1);
                    }
                }
            };

            Runnable r2 = new Runnable() {
                @Override
                public void run() {
                    for (int i = 0; i < 500; i++) {
                        ts.request(1);
                    }
                }
            };

            TestHelper.race(r1, r2);
        }",loop_control
i,"for (int i = 0; i < TestHelper.RACE_DEFAULT_LOOPS; i++) {
            final PublishSubject<Integer> ps = PublishSubject.create();

            ps.onNext(1);

            final TestSubscriber<Integer> ts = ps.singleElement().flattenAsFlowable(
            new Function<Integer, Iterable<Integer>>() {
                @Override
                public Iterable<Integer> apply(Integer v) throws Exception {
                    return Arrays.asList(1, 2, 3);
                }
            })
            .test(0L);

            Runnable r1 = new Runnable() {
                @Override
                public void run() {
                    ps.onComplete();
                }
            };

            Runnable r2 = new Runnable() {
                @Override
                public void run() {
                    ts.cancel();
                }
            };

            TestHelper.race(r1, r2);
        }",loop_control
i,"for (int i = 0; i < TestHelper.RACE_DEFAULT_LOOPS; i++) {

            MaybeSubject<Integer> ms = MaybeSubject.create();

            TestSubscriber<Object> ts = ms.flattenAsFlowable(v -> list)
            .test(0L);

            TestHelper.race(
                    () -> ms.onSuccess(1),
                    () -> ts.request(1)
            );

            ts.assertResult(1);
        }",loop_control
i,"for (int i = 0; i < TestHelper.RACE_DEFAULT_LOOPS; i++) {
            TestHelper.trackPluginErrors();
            try {
                final PublishProcessor<Integer> pp1 = PublishProcessor.create();
                final PublishProcessor<Integer> pp2 = PublishProcessor.create();

                TestObserver<Integer> to = pp1.singleElement().timeout(pp2.singleElement()).test();

                final TestException ex = new TestException();

                Runnable r1 = new Runnable() {
                    @Override
                    public void run() {
                        pp1.onError(ex);
                    }
                };
                Runnable r2 = new Runnable() {
                    @Override
                    public void run() {
                        pp2.onError(ex);
                    }
                };

                TestHelper.race(r1, r2);

                to.assertFailure(TestException.class);
            } finally {
                RxJavaPlugins.reset();
            }
        }",loop_control
i,"for (int i = 0; i < TestHelper.RACE_DEFAULT_LOOPS; i++) {
            final PublishProcessor<Integer> pp1 = PublishProcessor.create();
            final PublishProcessor<Integer> pp2 = PublishProcessor.create();

            TestObserverEx<Integer> to = pp1.singleElement().timeout(pp2.singleElement()).to(TestHelper.<Integer>testConsumer());

            Runnable r1 = new Runnable() {
                @Override
                public void run() {
                    pp1.onComplete();
                }
            };
            Runnable r2 = new Runnable() {
                @Override
                public void run() {
                    pp2.onComplete();
                }
            };

            TestHelper.race(r1, r2);

            to.assertSubscribed().assertNoValues();

            if (to.errors().size() != 0) {
                to.assertError(TimeoutException.class).assertNotComplete();
            } else {
                to.assertNoErrors().assertComplete();
            }
        }",loop_control
timeout,"{
            final CountDownLatch cdl1 = new CountDownLatch(1);
            final CountDownLatch cdl2 = new CountDownLatch(1);

            TestObserver<Integer> to = Maybe.fromSupplier(new Supplier<Integer>() {
                @Override
                public Integer get() throws Exception {
                    cdl1.countDown();
                    cdl2.await(5, TimeUnit.SECONDS);
                    return 1;
                }
            }).subscribeOn(Schedulers.single()).test();

            assertTrue(cdl1.await(5, TimeUnit.SECONDS));

            to.dispose();

            int timeout = 10;

            while (timeout-- > 0 && errors.isEmpty()) {
                Thread.sleep(100);
            }

            TestHelper.assertUndeliverable(errors, 0, InterruptedException.class);
        }",loop_control
errors,"{
        List<Throwable> errors = TestHelper.trackPluginErrors();
        try {
            final CountDownLatch cdl1 = new CountDownLatch(1);
            final CountDownLatch cdl2 = new CountDownLatch(1);

            TestObserver<Integer> to = Maybe.fromSupplier(new Supplier<Integer>() {
                @Override
                public Integer get() throws Exception {
                    cdl1.countDown();
                    cdl2.await(5, TimeUnit.SECONDS);
                    return 1;
                }
            }).subscribeOn(Schedulers.single()).test();

            assertTrue(cdl1.await(5, TimeUnit.SECONDS));

            to.dispose();

            int timeout = 10;

            while (timeout-- > 0 && errors.isEmpty()) {
                Thread.sleep(100);
            }

            TestHelper.assertUndeliverable(errors, 0, InterruptedException.class);
        } finally {
            RxJavaPlugins.reset();
        }
    }",maybe_loop_control
i,"for (int i = 1; i < 100; i++) {
            Single<Integer>[] array = new Single[i];

            Arrays.fill(array, Single.just(1));

            Single.concatArray(array)
            .to(TestHelper.<Integer>testConsumer())
            .assertSubscribed()
            .assertValueCount(i)
            .assertNoErrors()
            .assertComplete();
        }",loop_control
i,"for (int i = 1; i < 100; i++) {
            Single<Integer>[] array = new Single[i];

            Arrays.fill(array, Single.just(1));

            Single.concat(Observable.fromArray(array))
            .to(TestHelper.<Integer>testConsumer())
            .assertSubscribed()
            .assertValueCount(i)
            .assertNoErrors()
            .assertComplete();
        }",loop_control
s,"for (Scheduler s : new Scheduler[] { Schedulers.single(), Schedulers.computation(), Schedulers.newThread(), Schedulers.io(), Schedulers.from(exec, true) }) {
                final AtomicBoolean interrupted = new AtomicBoolean();
                TestObserver<Long> to = Single.timer(1, TimeUnit.MILLISECONDS, s)
                .map(new Function<Long, Long>() {
                    @Override
                    public Long apply(Long v) throws Exception {
                        try {
                        Thread.sleep(3000);
                        } catch (InterruptedException ex) {
                            interrupted.set(true);
                        }
                        return v;
                    }
                })
                .test();

                Thread.sleep(500);

                to.dispose();

                Thread.sleep(500);

                assertTrue(s.getClass().getSimpleName(), interrupted.get());
            }",iterator
i,"for (int i = 0; i < TestHelper.RACE_DEFAULT_LOOPS; i++) {
            final SingleSubject<Integer> subj = SingleSubject.create();
            SingleSubject<Integer> fallback = SingleSubject.create();

            final TestScheduler sch = new TestScheduler();

            TestObserver<Integer> to = subj.timeout(1, TimeUnit.MILLISECONDS, sch, fallback).test();

            Runnable r1 = new Runnable() {
                @Override
                public void run() {
                    subj.onSuccess(1);
                }
            };

            Runnable r2 = new Runnable() {
                @Override
                public void run() {
                    sch.advanceTimeBy(1, TimeUnit.MILLISECONDS);
                }
            };

            TestHelper.race(r1, r2);

            if (!fallback.hasObservers()) {
                to.assertResult(1);
            } else {
                to.assertEmpty();
            }
        }",loop_control
i,"for (int i = 0; i < TestHelper.RACE_DEFAULT_LOOPS; i++) {
                final SingleSubject<Integer> subj = SingleSubject.create();
                SingleSubject<Integer> fallback = SingleSubject.create();

                final TestScheduler sch = new TestScheduler();

                TestObserver<Integer> to = subj.timeout(1, TimeUnit.MILLISECONDS, sch, fallback).test();

                Runnable r1 = new Runnable() {
                    @Override
                    public void run() {
                        subj.onError(ex);
                    }
                };

                Runnable r2 = new Runnable() {
                    @Override
                    public void run() {
                        sch.advanceTimeBy(1, TimeUnit.MILLISECONDS);
                    }
                };

                TestHelper.race(r1, r2);

                if (!fallback.hasObservers()) {
                    to.assertFailure(TestException.class);
                } else {
                    to.assertEmpty();
                }
                if (!errors.isEmpty()) {
                    TestHelper.assertUndeliverable(errors, 0, TestException.class);
                }
            }",loop_control
timeout,"{
            final CountDownLatch cdl1 = new CountDownLatch(1);
            final CountDownLatch cdl2 = new CountDownLatch(1);

            TestObserver<Integer> to = Single.fromCallable(new Callable<Integer>() {
                @Override
                public Integer call() throws Exception {
                    cdl1.countDown();
                    cdl2.await(5, TimeUnit.SECONDS);
                    return 1;
                }
            }).subscribeOn(Schedulers.single()).test();

            assertTrue(cdl1.await(5, TimeUnit.SECONDS));

            to.dispose();

            int timeout = 10;

            while (timeout-- > 0 && errors.isEmpty()) {
                Thread.sleep(100);
            }

            TestHelper.assertUndeliverable(errors, 0, InterruptedException.class);
        }",loop_control
errors,"{
        List<Throwable> errors = TestHelper.trackPluginErrors();
        try {
            final CountDownLatch cdl1 = new CountDownLatch(1);
            final CountDownLatch cdl2 = new CountDownLatch(1);

            TestObserver<Integer> to = Single.fromCallable(new Callable<Integer>() {
                @Override
                public Integer call() throws Exception {
                    cdl1.countDown();
                    cdl2.await(5, TimeUnit.SECONDS);
                    return 1;
                }
            }).subscribeOn(Schedulers.single()).test();

            assertTrue(cdl1.await(5, TimeUnit.SECONDS));

            to.dispose();

            int timeout = 10;

            while (timeout-- > 0 && errors.isEmpty()) {
                Thread.sleep(100);
            }

            TestHelper.assertUndeliverable(errors, 0, InterruptedException.class);
        } finally {
            RxJavaPlugins.reset();
        }
    }",maybe_loop_control
i,"for (int i = 0; i < TestHelper.RACE_DEFAULT_LOOPS; i++) {
            List<Throwable> errors = TestHelper.trackPluginErrors();
            try {
                final PublishProcessor<Integer> pp0 = PublishProcessor.create();
                final PublishProcessor<Integer> pp1 = PublishProcessor.create();

                final TestObserver<Object> to = Single.zip(
                        Arrays.asList(pp0.single(0), pp1.single(0)), addString)
                .test();

                final TestException ex = new TestException();

                Runnable r1 = new Runnable() {
                    @Override
                    public void run() {
                        pp0.onError(ex);
                    }
                };

                Runnable r2 = new Runnable() {
                    @Override
                    public void run() {
                        pp1.onError(ex);
                    }
                };

                TestHelper.race(r1, r2);

                to.assertFailure(TestException.class);

                if (!errors.isEmpty()) {
                    TestHelper.assertUndeliverable(errors, 0, TestException.class);
                }
            } finally {
                RxJavaPlugins.reset();
            }
        }",loop_control
i,"for (int i = 0; i < TestHelper.RACE_DEFAULT_LOOPS; i++) {
            List<Throwable> errors = TestHelper.trackPluginErrors();

            try {
                final PublishProcessor<Integer> pp1 = PublishProcessor.create();
                final PublishProcessor<Integer> pp2 = PublishProcessor.create();

                TestObserver<Integer> to = pp1.singleOrError().takeUntil(pp2).test();

                final TestException ex = new TestException();

                Runnable r1 = new Runnable() {
                    @Override
                    public void run() {
                        pp1.onError(ex);
                    }
                };

                Runnable r2 = new Runnable() {
                    @Override
                    public void run() {
                        pp2.onError(ex);
                    }
                };

                TestHelper.race(r1, r2);

                to.assertFailure(TestException.class);

                if (!errors.isEmpty()) {
                    TestHelper.assertUndeliverable(errors, 0, TestException.class);
                }
            } finally {
                RxJavaPlugins.reset();
            }
        }",loop_control
i,"for (int i = 0; i < TestHelper.RACE_DEFAULT_LOOPS; i++) {
            final PublishProcessor<Integer> pp = PublishProcessor.create();

            Disposable d = Disposable.empty();

            final TestObserver<Integer> to = Single.using(Functions.justSupplier(d), new Function<Disposable, SingleSource<Integer>>() {
                @Override
                public SingleSource<Integer> apply(Disposable v) throws Exception {
                    return pp.single(-99);
                }
            }, disposer)
            .test();

            pp.onNext(1);

            Runnable r1 = new Runnable() {
                @Override
                public void run() {
                    pp.onComplete();
                }
            };
            Runnable r2 = new Runnable() {
                @Override
                public void run() {
                    to.dispose();
                }
            };

            TestHelper.race(r1, r2);

            assertTrue(d.isDisposed());
        }",loop_control
i,"for (int i = 0; i < TestHelper.RACE_DEFAULT_LOOPS; i++) {
            final PublishProcessor<Integer> pp = PublishProcessor.create();

            Disposable d = Disposable.empty();

            final TestObserver<Integer> to = Single.using(Functions.justSupplier(d), new Function<Disposable, SingleSource<Integer>>() {
                @Override
                public SingleSource<Integer> apply(Disposable v) throws Exception {
                    return pp.single(-99);
                }
            }, disposer)
            .test();

            final TestException ex = new TestException();

            Runnable r1 = new Runnable() {
                @Override
                public void run() {
                    pp.onError(ex);
                }
            };
            Runnable r2 = new Runnable() {
                @Override
                public void run() {
                    to.dispose();
                }
            };

            TestHelper.race(r1, r2);

            assertTrue(d.isDisposed());
        }",loop_control
i,"for (int i = 1; i < 33; i++) {
            s.test().assertResult(i);
        }",loop_control
i,"for (int i = 0; i < 500; i++) {
            final PublishSubject<Integer> ps = PublishSubject.create();

            ps.singleElement().flattenAsFlowable(
            new Function<Integer, Iterable<Integer>>() {
                @Override
                public Iterable<Integer> apply(Integer v) throws Exception {
                    return Arrays.asList(1, 2, 3);
                }
            })
            .test(5L)
            .assertEmpty();
        }",loop_control
i,"for (int i = 0; i < TestHelper.RACE_DEFAULT_LOOPS; i++) {
            final PublishSubject<Integer> ps = PublishSubject.create();

            ps.onNext(1);

            final TestSubscriber<Integer> ts = ps.singleElement().flattenAsFlowable(
            new Function<Integer, Iterable<Integer>>() {
                @Override
                public Iterable<Integer> apply(Integer v) throws Exception {
                    return Arrays.asList(a);
                }
            })
            .test(0L);

            Runnable r1 = new Runnable() {
                @Override
                public void run() {
                    ps.onComplete();
                    for (int i = 0; i < 500; i++) {
                        ts.request(1);
                    }
                }
            };

            Runnable r2 = new Runnable() {
                @Override
                public void run() {
                    for (int i = 0; i < 500; i++) {
                        ts.request(1);
                    }
                }
            };

            TestHelper.race(r1, r2);
        }",loop_control
i,"for (int i = 0; i < TestHelper.RACE_DEFAULT_LOOPS; i++) {
            final PublishSubject<Integer> ps = PublishSubject.create();

            ps.onNext(1);

            final TestSubscriber<Integer> ts = ps.singleElement().flattenAsFlowable(
            new Function<Integer, Iterable<Integer>>() {
                @Override
                public Iterable<Integer> apply(Integer v) throws Exception {
                    return Arrays.asList(1, 2, 3);
                }
            })
            .test(0L);

            Runnable r1 = new Runnable() {
                @Override
                public void run() {
                    ps.onComplete();
                }
            };

            Runnable r2 = new Runnable() {
                @Override
                public void run() {
                    ts.cancel();
                }
            };

            TestHelper.race(r1, r2);
        }",loop_control
i,"for (int i = 0; i < TestHelper.RACE_DEFAULT_LOOPS; i++) {
            final PublishSubject<Integer> ps = PublishSubject.create();

            final TestSubscriber<Integer> ts = ps.singleOrError().flattenAsFlowable(new Function<Integer, Iterable<Integer>>() {
                @Override
                public Iterable<Integer> apply(Integer v) throws Exception {
                    return Arrays.asList(a);
                }
            }).test();

            Runnable r1 = new Runnable() {
                @Override
                public void run() {
                    for (int i = 0; i < 1000; i++) {
                        ts.request(1);
                    }
                }
            };

            Runnable r2 = new Runnable() {
                @Override
                public void run() {
                    ps.onNext(1);
                    ps.onComplete();
                }
            };

            TestHelper.race(r1, r2);
        }",loop_control
i,"for (int i = 0; i < TestHelper.RACE_DEFAULT_LOOPS; i++) {

            SingleSubject<Integer> ss = SingleSubject.create();

            TestSubscriber<Object> ts = ss.flattenAsFlowable(v -> list)
            .test(0L);

            TestHelper.race(
                    () -> ss.onSuccess(1),
                    () -> ts.request(1)
            );

            ts.assertResult(1);
        }",loop_control
i,"for (int i = 0; i < TestHelper.RACE_DEFAULT_LOOPS; i++) {
            PublishProcessor<Integer> pp = PublishProcessor.create();

            final Single<Integer> cached = pp.single(-99).cache();

            final TestObserver<Integer> to1 = cached.test();

            Runnable r1 = new Runnable() {
                @Override
                public void run() {
                    to1.dispose();
                }
            };

            Runnable r2 = new Runnable() {
                @Override
                public void run() {
                    cached.test();
                }
            };

            TestHelper.race(r1, r2);
        }",loop_control
times,"{
        PublishProcessor<Integer> pp = PublishProcessor.create();

        final String[] name = { null };

        final CountDownLatch cdl = new CountDownLatch(1);

        pp.doOnCancel(new Action() {
            @Override
            public void run() throws Exception {
                name[0] = Thread.currentThread().getName();
                cdl.countDown();
            }
        })
        .single(-99)
        .unsubscribeOn(Schedulers.single())
        .test(true)
        ;

        assertTrue(cdl.await(5, TimeUnit.SECONDS));

        int times = 10;

        while (times-- > 0 && pp.hasSubscribers()) {
            Thread.sleep(100);
        }

        assertFalse(pp.hasSubscribers());

        assertNotEquals(Thread.currentThread().getName(), name[0]);
    }",loop_control
pp,"{
        PublishProcessor<Integer> pp = PublishProcessor.create();

        final String[] name = { null };

        final CountDownLatch cdl = new CountDownLatch(1);

        pp.doOnCancel(new Action() {
            @Override
            public void run() throws Exception {
                name[0] = Thread.currentThread().getName();
                cdl.countDown();
            }
        })
        .single(-99)
        .unsubscribeOn(Schedulers.single())
        .test(true)
        ;

        assertTrue(cdl.await(5, TimeUnit.SECONDS));

        int times = 10;

        while (times-- > 0 && pp.hasSubscribers()) {
            Thread.sleep(100);
        }

        assertFalse(pp.hasSubscribers());

        assertNotEquals(Thread.currentThread().getName(), name[0]);
    }",maybe_loop_control
i,"for (int i = 0; i < TestHelper.RACE_DEFAULT_LOOPS; i++) {
            PublishProcessor<Integer> pp = PublishProcessor.create();

            final Disposable[] ds = { null };
            pp.single(-99).unsubscribeOn(Schedulers.computation())
            .subscribe(new SingleObserver<Integer>() {
                @Override
                public void onSubscribe(Disposable d) {
                    ds[0] = d;
                }

                @Override
                public void onSuccess(Integer value) {

                }

                @Override
                public void onError(Throwable e) {

                }
            });

            Runnable r = new Runnable() {
                @Override
                public void run() {
                    ds[0].dispose();
                }
            };

            TestHelper.race(r, r);
        }",loop_control
i,"for (int i = 0; i < TestHelper.RACE_DEFAULT_LOOPS; i++) {
            List<Throwable> errors = TestHelper.trackPluginErrors();
            try {
                final PublishProcessor<Integer> pp0 = PublishProcessor.create();
                final PublishProcessor<Integer> pp1 = PublishProcessor.create();

                final TestObserver<Object> to = Single.zip(pp0.single(0), pp1.single(0), addString)
                .test();

                final TestException ex = new TestException();

                Runnable r1 = new Runnable() {
                    @Override
                    public void run() {
                        pp0.onError(ex);
                    }
                };

                Runnable r2 = new Runnable() {
                    @Override
                    public void run() {
                        pp1.onError(ex);
                    }
                };

                TestHelper.race(r1, r2);

                to.assertFailure(TestException.class);

                if (!errors.isEmpty()) {
                    TestHelper.assertUndeliverable(errors, 0, TestException.class);
                }
            } finally {
                RxJavaPlugins.reset();
            }
        }",loop_control
i,"for (int i = 0; i < TestHelper.RACE_DEFAULT_LOOPS; i++) {
            List<Throwable> errors = TestHelper.trackPluginErrors();

            try {

                final Subject<Integer> ps = ReplaySubject.create();
                ps.onNext(1);

                final Single<Integer> source = Single.ambArray(ps.singleOrError(), Single.<Integer>never(), Single.<Integer>never(), null);

                Runnable r1 = new Runnable() {
                    @Override
                    public void run() {
                        source.test();
                    }
                };

                Runnable r2 = new Runnable() {
                    @Override
                    public void run() {
                        ps.onComplete();
                    }
                };

                TestHelper.race(r1, r2);

                if (!errors.isEmpty()) {
                    TestHelper.assertError(errors, 0, NullPointerException.class);
                }
            } finally {
                RxJavaPlugins.reset();
            }
        }",loop_control
i,"for (int i = 0; i < TestHelper.RACE_DEFAULT_LOOPS; i++) {
            List<Throwable> errors = TestHelper.trackPluginErrors();

            try {

                final Subject<Integer> ps1 = PublishSubject.create();
                final Subject<Integer> ps2 = PublishSubject.create();

                Single.ambArray(ps1.singleOrError(), ps2.singleOrError()).test();

                final TestException ex = new TestException();

                Runnable r1 = new Runnable() {
                    @Override
                    public void run() {
                        ps1.onError(ex);
                    }
                };

                Runnable r2 = new Runnable() {
                    @Override
                    public void run() {
                        ps2.onError(ex);
                    }
                };

                TestHelper.race(r1, r2);

                if (!errors.isEmpty()) {
                    TestHelper.assertUndeliverable(errors, 0, TestException.class);
                }
            } finally {
                RxJavaPlugins.reset();
            }
        }",loop_control
i,"for (int i = 0; i < TestHelper.RACE_DEFAULT_LOOPS; i++) {
            List<Throwable> errors = TestHelper.trackPluginErrors();

            try {

                final Subject<Integer> ps1 = PublishSubject.create();
                final Subject<Integer> ps2 = PublishSubject.create();

                Single.ambArray(ps1.singleOrError(), ps2.singleOrError()).test();

                final TestException ex = new TestException();

                Runnable r1 = new Runnable() {
                    @Override
                    public void run() {
                        ps1.onNext(1);
                        ps1.onComplete();
                    }
                };

                Runnable r2 = new Runnable() {
                    @Override
                    public void run() {
                        ps2.onError(ex);
                    }
                };

                TestHelper.race(r1, r2);

                if (!errors.isEmpty()) {
                    TestHelper.assertUndeliverable(errors, 0, TestException.class);
                }
            } finally {
                RxJavaPlugins.reset();
            }
        }",loop_control
i,"for (int i = 0; i < TestHelper.RACE_LONG_LOOPS; i++) {
            final AtomicBoolean interrupted = new AtomicBoolean();
            final CountDownLatch cdl = new CountDownLatch(1);

            Single.ambArray(
                Single.just(1)
                    .subscribeOn(Schedulers.single())
                    .observeOn(Schedulers.computation()),
                Single.never()
            )
            .subscribe(new BiConsumer<Object, Throwable>() {
                @Override
                public void accept(Object v, Throwable e) throws Exception {
                    assertNotNull(v);
                    assertNull(e);
                    interrupted.set(Thread.currentThread().isInterrupted());
                    cdl.countDown();
                }
            });

            assertTrue(cdl.await(500, TimeUnit.SECONDS));
            assertFalse(""Interrupted!"", interrupted.get());
        }",loop_control
i,"for (int i = 0; i < TestHelper.RACE_LONG_LOOPS; i++) {
            final AtomicBoolean interrupted = new AtomicBoolean();
            final CountDownLatch cdl = new CountDownLatch(1);

            Single.ambArray(
                Single.error(ex)
                    .subscribeOn(Schedulers.single())
                    .observeOn(Schedulers.computation()),
                Single.never()
            )
            .subscribe(new BiConsumer<Object, Throwable>() {
                @Override
                public void accept(Object v, Throwable e) throws Exception {
                    assertNull(v);
                    assertNotNull(e);
                    interrupted.set(Thread.currentThread().isInterrupted());
                    cdl.countDown();
                }
            });

            assertTrue(cdl.await(500, TimeUnit.SECONDS));
            assertFalse(""Interrupted!"", interrupted.get());
        }",loop_control
timeout,"{
            final CountDownLatch cdl1 = new CountDownLatch(1);
            final CountDownLatch cdl2 = new CountDownLatch(1);

            TestObserver<Integer> to = Single.fromSupplier(new Supplier<Integer>() {
                @Override
                public Integer get() throws Exception {
                    cdl1.countDown();
                    cdl2.await(5, TimeUnit.SECONDS);
                    return 1;
                }
            }).subscribeOn(Schedulers.single()).test();

            assertTrue(cdl1.await(5, TimeUnit.SECONDS));

            to.dispose();

            int timeout = 10;

            while (timeout-- > 0 && errors.isEmpty()) {
                Thread.sleep(100);
            }

            TestHelper.assertUndeliverable(errors, 0, InterruptedException.class);
        }",loop_control
errors,"{
        List<Throwable> errors = TestHelper.trackPluginErrors();
        try {
            final CountDownLatch cdl1 = new CountDownLatch(1);
            final CountDownLatch cdl2 = new CountDownLatch(1);

            TestObserver<Integer> to = Single.fromSupplier(new Supplier<Integer>() {
                @Override
                public Integer get() throws Exception {
                    cdl1.countDown();
                    cdl2.await(5, TimeUnit.SECONDS);
                    return 1;
                }
            }).subscribeOn(Schedulers.single()).test();

            assertTrue(cdl1.await(5, TimeUnit.SECONDS));

            to.dispose();

            int timeout = 10;

            while (timeout-- > 0 && errors.isEmpty()) {
                Thread.sleep(100);
            }

            TestHelper.assertUndeliverable(errors, 0, InterruptedException.class);
        } finally {
            RxJavaPlugins.reset();
        }
    }",maybe_loop_control
i,"for (int i = 0; i < TestHelper.RACE_DEFAULT_LOOPS; i++) {

            final PublishSubject<Integer> ps = PublishSubject.create();

            final TestObserverEx<Void> to = Completable.using(new Supplier<Object>() {
                @Override
                public Object get() throws Exception {
                    return 1;
                }
            }, new Function<Object, CompletableSource>() {
                @Override
                public CompletableSource apply(Object v) throws Exception {
                    return ps.ignoreElements();
                }
            }, new Consumer<Object>() {
                @Override
                public void accept(Object d) throws Exception {
                }
            }, true)
            .to(TestHelper.<Void>testConsumer());

            ps.onNext(1);

            Runnable r1 = new Runnable() {
                @Override
                public void run() {
                    to.dispose();
                }
            };

            Runnable r2 = new Runnable() {
                @Override
                public void run() {
                    ps.onComplete();
                }
            };

            TestHelper.race(r1, r2);
        }",loop_control
i,"for (int i = 0; i < TestHelper.RACE_DEFAULT_LOOPS; i++) {

                final PublishSubject<Integer> ps = PublishSubject.create();

                final TestObserver<Void> to = Completable.using(new Supplier<Object>() {
                    @Override
                    public Object get() throws Exception {
                        return 1;
                    }
                }, new Function<Object, CompletableSource>() {
                    @Override
                    public CompletableSource apply(Object v) throws Exception {
                        return ps.ignoreElements();
                    }
                }, new Consumer<Object>() {
                    @Override
                    public void accept(Object d) throws Exception {
                    }
                }, true)
                .test();

                final TestException ex = new TestException();

                Runnable r1 = new Runnable() {
                    @Override
                    public void run() {
                        to.dispose();
                    }
                };

                Runnable r2 = new Runnable() {
                    @Override
                    public void run() {
                        ps.onError(ex);
                    }
                };

                TestHelper.race(r1, r2);
            }",loop_control
i,"for (int i = 0; i < TestHelper.RACE_DEFAULT_LOOPS; i++) {

            final PublishSubject<Integer> ps = PublishSubject.create();

            final TestObserver<Void> to = Completable.using(new Supplier<Object>() {
                @Override
                public Object get() throws Exception {
                    return 1;
                }
            }, new Function<Object, CompletableSource>() {
                @Override
                public CompletableSource apply(Object v) throws Exception {
                    return ps.ignoreElements();
                }
            }, new Consumer<Object>() {
                @Override
                public void accept(Object d) throws Exception {

                }
            }, true)
            .test();

            Runnable r1 = new Runnable() {
                @Override
                public void run() {
                    to.dispose();
                }
            };

            Runnable r2 = new Runnable() {
                @Override
                public void run() {
                    ps.onComplete();
                }
            };

            TestHelper.race(r1, r2);
        }",loop_control
i,"for (int i = 0; i < TestHelper.RACE_DEFAULT_LOOPS; i++) {
            List<Throwable> errors = TestHelper.trackPluginErrors();
            try {
                final PublishSubject<Integer> ps1 = PublishSubject.create();
                final PublishSubject<Integer> ps2 = PublishSubject.create();

                TestObserver<Void> to = Completable.merge(
                        Arrays.asList(ps1.ignoreElements(), ps2.ignoreElements())).test();

                final TestException ex = new TestException();

                Runnable r1 = new Runnable() {
                    @Override
                    public void run() {
                        ps1.onError(ex);
                    }
                };
                Runnable r2 = new Runnable() {
                    @Override
                    public void run() {
                        ps2.onError(ex);
                    }
                };

                TestHelper.race(r1, r2);

                to.assertFailure(TestException.class);

                if (!errors.isEmpty()) {
                    TestHelper.assertUndeliverable(errors, 0, TestException.class);
                }
            } finally {
                RxJavaPlugins.reset();
            }
        }",loop_control
s,"for (Scheduler s : new Scheduler[] { Schedulers.single(), Schedulers.computation(), Schedulers.newThread(), Schedulers.io(), Schedulers.from(exec, true) }) {
                final AtomicBoolean interrupted = new AtomicBoolean();
                TestObserver<Void> to = Completable.timer(1, TimeUnit.MILLISECONDS, s)
                .doOnComplete(new Action() {
                    @Override
                    public void run() throws Exception {
                        try {
                        Thread.sleep(3000);
                        } catch (InterruptedException ex) {
                            interrupted.set(true);
                        }
                    }
                })
                .test();

                Thread.sleep(500);

                to.dispose();

                Thread.sleep(500);

                assertTrue(s.getClass().getSimpleName(), interrupted.get());
            }",iterator
i,"for (int i = 0; i < TestHelper.RACE_DEFAULT_LOOPS; i++) {
            List<Throwable> errors = TestHelper.trackPluginErrors();
            try {
                final PublishProcessor<Integer> pp1 = PublishProcessor.create();
                final PublishProcessor<Integer> pp2 = PublishProcessor.create();

                TestObserverEx<Void> to = Completable.merge(pp1.map(new Function<Integer, Completable>() {
                    @Override
                    public Completable apply(Integer v) throws Exception {
                        return pp2.ignoreElements();
                    }
                })).to(TestHelper.<Void>testConsumer());

                pp1.onNext(1);

                final Throwable ex1 = new TestException();
                final Throwable ex2 = new TestException();

                Runnable r1 = new Runnable() {
                    @Override
                    public void run() {
                        pp1.onError(ex1);
                    }
                };
                Runnable r2 = new Runnable() {
                    @Override
                    public void run() {
                        pp2.onError(ex2);
                    }
                };

                TestHelper.race(r1, r2);

                Throwable ex = to.errors().get(0);
                if (ex instanceof CompositeException) {
                    to.assertSubscribed().assertNoValues().assertNotComplete();

                    errors = TestHelper.compositeList(ex);
                    TestHelper.assertError(errors, 0, TestException.class);
                    TestHelper.assertError(errors, 1, TestException.class);
                } else {
                    to.assertFailure(TestException.class);

                    if (!errors.isEmpty()) {
                        TestHelper.assertUndeliverable(errors, 0, TestException.class);
                    }
                }
            } finally {
                RxJavaPlugins.reset();
            }
        }",loop_control
i,"for (int i = 0; i < TestHelper.RACE_DEFAULT_LOOPS; i++) {
            final PublishProcessor<Integer> pp1 = PublishProcessor.create();
            final PublishProcessor<Integer> pp2 = PublishProcessor.create();

            TestObserverEx<Void> to = Completable.mergeDelayError(pp1.map(new Function<Integer, Completable>() {
                @Override
                public Completable apply(Integer v) throws Exception {
                    return pp2.ignoreElements();
                }
            })).to(TestHelper.<Void>testConsumer());

            pp1.onNext(1);

            final Throwable ex1 = new TestException();

            Runnable r1 = new Runnable() {
                @Override
                public void run() {
                    pp1.onError(ex1);
                }
            };

            final Throwable ex2 = new TestException();
            Runnable r2 = new Runnable() {
                @Override
                public void run() {
                    pp2.onError(ex2);
                }
            };

            TestHelper.race(r1, r2);

            to.assertFailure(CompositeException.class);

            List<Throwable> errors = TestHelper.compositeList(to.errors().get(0));

            TestHelper.assertError(errors, 0, TestException.class);
            TestHelper.assertError(errors, 1, TestException.class);
        }",loop_control
i,"for (int i = 0; i < TestHelper.RACE_DEFAULT_LOOPS; i++) {
            List<Throwable> errors = TestHelper.trackPluginErrors();
            try {
                final PublishProcessor<Integer> pp1 = PublishProcessor.create();
                final PublishProcessor<Integer> pp2 = PublishProcessor.create();

                TestObserver<Void> to = Completable.mergeArray(pp1.ignoreElements(), pp2.ignoreElements()).test();

                pp1.onNext(1);

                final Throwable ex1 = new TestException();
                final Throwable ex2 = new TestException();

                Runnable r1 = new Runnable() {
                    @Override
                    public void run() {
                        pp1.onError(ex1);
                    }
                };
                Runnable r2 = new Runnable() {
                    @Override
                    public void run() {
                        pp2.onError(ex2);
                    }
                };

                TestHelper.race(r1, r2);

                to.assertFailure(TestException.class);

                if (!errors.isEmpty()) {
                    TestHelper.assertUndeliverable(errors, 0, TestException.class);
                }
            } finally {
                RxJavaPlugins.reset();
            }
        }",loop_control
k,"for (int k = 0; k < 100; k++) {
            final int count = 10;
            final CountDownLatch latch = new CountDownLatch(count);
            final boolean[] interrupted = {false};

            for (int i = 0; i < count; i++) {
                Completable.complete()
                        .subscribeOn(Schedulers.io())
                        .observeOn(Schedulers.io())
                        .andThen(Completable.fromAction(new Action() {
                            @Override
                            public void run() throws Exception {
                                try {
                                    Thread.sleep(30);
                                } catch (InterruptedException e) {
                                    System.out.println(""Interrupted! "" + Thread.currentThread());
                                    interrupted[0] = true;
                                }
                            }
                        }))
                        .subscribe(new Action() {
                            @Override
                            public void run() throws Exception {
                                latch.countDown();
                            }
                        });
            }

            latch.await();
            assertFalse(""The second Completable was interrupted!"", interrupted[0]);
        }",loop_control
i,"for (int i = 0; i < count; i++) {
                Completable.complete()
                        .subscribeOn(Schedulers.io())
                        .observeOn(Schedulers.io())
                        .andThen(Completable.fromAction(new Action() {
                            @Override
                            public void run() throws Exception {
                                try {
                                    Thread.sleep(30);
                                } catch (InterruptedException e) {
                                    System.out.println(""Interrupted! "" + Thread.currentThread());
                                    interrupted[0] = true;
                                }
                            }
                        }))
                        .subscribe(new Action() {
                            @Override
                            public void run() throws Exception {
                                latch.countDown();
                            }
                        });
            }",loop_control
i,"for (int i = 0; i < TestHelper.RACE_DEFAULT_LOOPS; i++) {
            List<Throwable> errors = TestHelper.trackPluginErrors();

            try {
                final TestScheduler scheduler = new TestScheduler();

                final PublishSubject<Integer> ps = PublishSubject.create();

                TestObserverEx<Void> to = ps.ignoreElements()
                        .timeout(1, TimeUnit.MILLISECONDS, scheduler, Completable.complete())
                        .to(TestHelper.<Void>testConsumer());

                final TestException ex = new TestException();

                Runnable r1 = new Runnable() {
                    @Override
                    public void run() {
                        ps.onError(ex);
                    }
                };

                Runnable r2 = new Runnable() {
                    @Override
                    public void run() {
                        scheduler.advanceTimeBy(1, TimeUnit.MILLISECONDS);
                    }
                };

                TestHelper.race(r1, r2);

                to.assertTerminated();

                if (!errors.isEmpty()) {
                    TestHelper.assertUndeliverable(errors, 0, TestException.class);
                }

            } finally {
                RxJavaPlugins.reset();
            }
        }",loop_control
i,"for (int i = 0; i < TestHelper.RACE_DEFAULT_LOOPS; i++) {
            PublishSubject<Integer> ps = PublishSubject.create();

            final Completable c = ps.ignoreElements().cache();

            final TestObserver<Void> to1 = new TestObserver<>();

            final TestObserver<Void> to2 = new TestObserver<>();

            Runnable r1 = new Runnable() {
                @Override
                public void run() {
                    c.subscribe(to1);
                }
            };
            Runnable r2 = new Runnable() {
                @Override
                public void run() {
                    c.subscribe(to2);
                }
            };

            TestHelper.race(r1, r2);

            ps.onComplete();

            to1.assertResult();
            to2.assertResult();
        }",loop_control
i,"for (int i = 0; i < TestHelper.RACE_DEFAULT_LOOPS; i++) {
            PublishSubject<Integer> ps = PublishSubject.create();

            final Completable c = ps.ignoreElements().cache();

            final TestObserver<Void> to1 = c.test();

            final TestObserver<Void> to2 = new TestObserver<>();

            Runnable r1 = new Runnable() {
                @Override
                public void run() {
                    to1.dispose();
                }
            };
            Runnable r2 = new Runnable() {
                @Override
                public void run() {
                    c.subscribe(to2);
                }
            };

            TestHelper.race(r1, r2);

            ps.onComplete();

            to1.assertEmpty();
            to2.assertResult();
        }",loop_control
i,"for (int i = 0; i < TestHelper.RACE_DEFAULT_LOOPS; i++) {
            List<Throwable> errors = TestHelper.trackPluginErrors();

            try {
                final PublishProcessor<Integer> pp1 = PublishProcessor.create();
                final PublishProcessor<Integer> pp2 = PublishProcessor.create();

                TestObserver<Void> to = Completable.concat(pp1.map(new Function<Integer, Completable>() {
                    @Override
                    public Completable apply(Integer v) throws Exception {
                        return pp2.ignoreElements();
                    }
                })).test();

                pp1.onNext(1);

                final TestException ex = new TestException();

                Runnable r1 = new Runnable() {
                    @Override
                    public void run() {
                        pp1.onError(ex);
                    }
                };
                Runnable r2 = new Runnable() {
                    @Override
                    public void run() {
                        pp2.onError(ex);
                    }
                };

                TestHelper.race(r1, r2);

                to.assertFailure(TestException.class);

                if (!errors.isEmpty()) {
                    TestHelper.assertUndeliverable(errors, 0, TestException.class);
                }
            } finally {
                RxJavaPlugins.reset();
            }
        }",loop_control
i,"for (int i = 0; i < TestHelper.RACE_DEFAULT_LOOPS; i++) {

            final Completable c = Completable.concatArray(a);

            final TestObserver<Void> to = new TestObserver<>();

            Runnable r1 = new Runnable() {
                @Override
                public void run() {
                    c.subscribe(to);
                }
            };

            Runnable r2 = new Runnable() {
                @Override
                public void run() {
                    to.dispose();
                }
            };

            TestHelper.race(r1, r2);
        }",loop_control
i,"for (int i = 0; i < TestHelper.RACE_DEFAULT_LOOPS; i++) {

            final Completable c = Completable.concat(Arrays.asList(a));

            final TestObserver<Void> to = new TestObserver<>();

            Runnable r1 = new Runnable() {
                @Override
                public void run() {
                    c.subscribe(to);
                }
            };

            Runnable r2 = new Runnable() {
                @Override
                public void run() {
                    to.dispose();
                }
            };

            TestHelper.race(r1, r2);
        }",loop_control
k,"for (int k = 0; k < 100; k++) {
            final int count = 10;
            final CountDownLatch latch = new CountDownLatch(count);
            final boolean[] interrupted = { false };

            for (int i = 0; i < count; i++) {
                Completable c0 = Completable.fromAction(new Action() {
                    @Override
                    public void run() throws Exception {
                        try {
                            Thread.sleep(30);
                        } catch (InterruptedException e) {
                            System.out.println(""Interrupted! "" + Thread.currentThread());
                            interrupted[0] = true;
                        }
                    }
                });
                Completable.concat(Arrays.asList(Completable.complete()
                    .subscribeOn(Schedulers.io())
                    .observeOn(Schedulers.io()),
                    c0)
                )
                .subscribe(new Action() {
                    @Override
                    public void run() throws Exception {
                        latch.countDown();
                    }
                });
            }

            latch.await();
            assertFalse(""The second Completable was interrupted!"", interrupted[0]);
        }",loop_control
i,"for (int i = 0; i < count; i++) {
                Completable c0 = Completable.fromAction(new Action() {
                    @Override
                    public void run() throws Exception {
                        try {
                            Thread.sleep(30);
                        } catch (InterruptedException e) {
                            System.out.println(""Interrupted! "" + Thread.currentThread());
                            interrupted[0] = true;
                        }
                    }
                });
                Completable.concat(Arrays.asList(Completable.complete()
                    .subscribeOn(Schedulers.io())
                    .observeOn(Schedulers.io()),
                    c0)
                )
                .subscribe(new Action() {
                    @Override
                    public void run() throws Exception {
                        latch.countDown();
                    }
                });
            }",loop_control
i,"for (int i = 0; i < 32; i++) {
            ms.add(Completable.never());
        }",loop_control
i,"for (int i = 0; i < TestHelper.RACE_DEFAULT_LOOPS; i++) {
            List<Throwable> errors = TestHelper.trackPluginErrors();
            try {
                final PublishProcessor<Integer> pp0 = PublishProcessor.create();
                final PublishProcessor<Integer> pp1 = PublishProcessor.create();

                final TestObserver<Void> to = Completable.amb(Arrays.asList(pp0.ignoreElements(), pp1.ignoreElements()))
                .test();

                final TestException ex = new TestException();

                Runnable r1 = new Runnable() {
                    @Override
                    public void run() {
                        pp0.onError(ex);
                    }
                };

                Runnable r2 = new Runnable() {
                    @Override
                    public void run() {
                        pp1.onError(ex);
                    }
                };

                TestHelper.race(r1, r2);

                to.assertFailure(TestException.class);

                if (!errors.isEmpty()) {
                    TestHelper.assertUndeliverable(errors, 0, TestException.class);
                }
            } finally {
                RxJavaPlugins.reset();
            }
        }",loop_control
i,"for (int i = 0; i < TestHelper.RACE_DEFAULT_LOOPS; i++) {
            List<Throwable> errors = TestHelper.trackPluginErrors();

            try {

                final Subject<Integer> ps = ReplaySubject.create();
                ps.onNext(1);

                final Completable source = Completable.ambArray(ps.ignoreElements(), Completable.never(), Completable.never(), null);

                Runnable r1 = new Runnable() {
                    @Override
                    public void run() {
                        source.test();
                    }
                };

                Runnable r2 = new Runnable() {
                    @Override
                    public void run() {
                        ps.onComplete();
                    }
                };

                TestHelper.race(r1, r2);

                if (!errors.isEmpty()) {
                    TestHelper.assertError(errors, 0, NullPointerException.class);
                }
            } finally {
                RxJavaPlugins.reset();
            }
        }",loop_control
i,"for (int i = 0; i < TestHelper.RACE_LONG_LOOPS; i++) {
            final AtomicBoolean interrupted = new AtomicBoolean();
            final CountDownLatch cdl = new CountDownLatch(1);

            Completable.ambArray(
                    Completable.error(ex)
                    .subscribeOn(Schedulers.single())
                    .observeOn(Schedulers.computation()),
                    Completable.never()
            )
            .subscribe(Functions.EMPTY_ACTION, new Consumer<Throwable>() {
                @Override
                public void accept(Throwable e) throws Exception {
                    interrupted.set(Thread.currentThread().isInterrupted());
                    cdl.countDown();
                }
            });

            assertTrue(cdl.await(500, TimeUnit.SECONDS));
            assertFalse(""Interrupted!"", interrupted.get());
        }",loop_control
i,"for (int i = 0; i < TestHelper.RACE_LONG_LOOPS; i++) {
            final AtomicBoolean interrupted = new AtomicBoolean();
            final CountDownLatch cdl = new CountDownLatch(1);

            Completable.ambArray(
                Completable.complete()
                    .subscribeOn(Schedulers.single())
                    .observeOn(Schedulers.computation()),
                Completable.never()
            )
            .subscribe(new Action() {
                @Override
                public void run() throws Exception {
                    interrupted.set(Thread.currentThread().isInterrupted());
                    cdl.countDown();
                }
            });

            assertTrue(cdl.await(500, TimeUnit.SECONDS));
            assertFalse(""Interrupted!"", interrupted.get());
        }",loop_control
arg,"for (String arg : args) {
            list.add(arg);
        }",iterator
timeout,"{
        final AtomicBoolean cancel1 = new AtomicBoolean();
        Flowable.intervalRange(1, 1000, 1, 1, TimeUnit.MILLISECONDS)
        .doOnCancel(new Action() {
            @Override
            public void run() throws Exception {
                cancel1.set(true);
            }
        })
        .window(1, TimeUnit.MILLISECONDS, Schedulers.single(), 2, true)
        .flatMap(Functions.<Flowable<Long>>identity())
        .take(500)
        .to(TestHelper.<Long>testConsumer())
        .awaitDone(5, TimeUnit.SECONDS)
        .assertSubscribed()
        .assertValueCount(500)
        .assertNoErrors()
        .assertComplete();

        int timeout = 20;
        while (timeout-- > 0 && !cancel1.get()) {
            Thread.sleep(100);
        }

        assertTrue(""intervalRange was not cancelled!"", cancel1.get());
    }",loop_control
cancel1,"{
        final AtomicBoolean cancel1 = new AtomicBoolean();
        Flowable.intervalRange(1, 1000, 1, 1, TimeUnit.MILLISECONDS)
        .doOnCancel(new Action() {
            @Override
            public void run() throws Exception {
                cancel1.set(true);
            }
        })
        .window(1, TimeUnit.MILLISECONDS, Schedulers.single(), 2, true)
        .flatMap(Functions.<Flowable<Long>>identity())
        .take(500)
        .to(TestHelper.<Long>testConsumer())
        .awaitDone(5, TimeUnit.SECONDS)
        .assertSubscribed()
        .assertValueCount(500)
        .assertNoErrors()
        .assertComplete();

        int timeout = 20;
        while (timeout-- > 0 && !cancel1.get()) {
            Thread.sleep(100);
        }

        assertTrue(""intervalRange was not cancelled!"", cancel1.get());
    }",maybe_loop_control
i,"for (int i = 0; i < TestHelper.RACE_DEFAULT_LOOPS; i++) {
            TestScheduler scheduler = new TestScheduler();

            PublishProcessor<Integer> pp = PublishProcessor.create();

            TestSubscriber<Flowable<Integer>> ts = pp.window(1, TimeUnit.MINUTES, scheduler, 1)
            .test();

            TestHelper.race(
                    () -> pp.onNext(1),
                    () -> ts.cancel()
            );
        }",loop_control
mode,"for (BackpressureStrategy mode : BackpressureStrategy.values()) {
            Flowable.fromObservable(Observable.range(1, 5), mode)
            .test()
            .withTag(""mode: "" + mode)
            .assertResult(1, 2, 3, 4, 5);
        }",iterator
i,"for (int i = 1; i < 3; i++) {
            effectCounter.set(0);
            System.out.printf(""- %d -%n"", i);
            result.subscribe(new Consumer<Integer>() {

                @Override
                public void accept(Integer t1) {
                    System.out.println(t1);
                }

            }, new Consumer<Throwable>() {

                @Override
                public void accept(Throwable t1) {
                    t1.printStackTrace();
                }
            },
            new Action() {
                @Override
                public void run() {
                    System.out.println(""Done"");
                }
            });
            assertEquals(2, effectCounter.get());
        }",loop_control
i,"for (int i = 0; i < 1000; i++) {
            assertEquals((Integer)i, onNextEvents.get(i));
        }",loop_control
i,"for (int i = 0; i < 10; i++) {
            assertEquals((Integer)i, onNextEvents.get(i));
        }",loop_control
i,"for (int i = 0; i < 100; i++) {
            TestSubscriberEx<Integer> ts1 = new TestSubscriberEx<>();

            Flowable<Integer> cached = source.replay().autoConnect();

            cached.observeOn(Schedulers.computation()).subscribe(ts1);

            ts1.awaitDone(2, TimeUnit.SECONDS);
            ts1.assertNoErrors();
            ts1.assertTerminated();
            assertEquals(10000, ts1.values().size());

            TestSubscriberEx<Integer> ts2 = new TestSubscriberEx<>();
            cached.observeOn(Schedulers.computation()).subscribe(ts2);

            ts2.awaitDone(2, TimeUnit.SECONDS);
            ts2.assertNoErrors();
            ts2.assertTerminated();
            assertEquals(10000, ts2.values().size());
        }",loop_control
i,"for (int i = 0; i < 100; i++) {
            TestSubscriberEx<Long> ts = new TestSubscriberEx<>();
            list.add(ts);
            output.skip(i * 10).take(10).subscribe(ts);
        }",loop_control
i,"for (int i = 0; i < 10; i++) {
            expected.add((long)(i - 10));
        }",loop_control
i,"for (int i = j * 10; i < j * 10 + 10; i++) {
                expected.set(i - j * 10, (long)i);
            }",loop_control
ts,"for (int i = 0; i < 100; i++) {
            TestSubscriberEx<Long> ts = new TestSubscriberEx<>();
            list.add(ts);
            output.skip(i * 10).take(10).subscribe(ts);
        }",iterator
ts,"for (TestSubscriberEx<Long> ts : list) {
            ts.awaitDone(3, TimeUnit.SECONDS);
            ts.assertNoErrors();
            ts.assertTerminated();

            for (int i = j * 10; i < j * 10 + 10; i++) {
                expected.set(i - j * 10, (long)i);
            }

            ts.assertValueSequence(expected);

            j++;
        }",iterator
j,"{
        Flowable<Long> source = Flowable.interval(1, 1, TimeUnit.MILLISECONDS)
                .take(1000)
                .subscribeOn(Schedulers.io());
        Flowable<Long> cached = source.replay().autoConnect();

        Flowable<Long> output = cached.observeOn(Schedulers.computation(), false, 1024);

        List<TestSubscriberEx<Long>> list = new ArrayList<>(100);
        for (int i = 0; i < 100; i++) {
            TestSubscriberEx<Long> ts = new TestSubscriberEx<>();
            list.add(ts);
            output.skip(i * 10).take(10).subscribe(ts);
        }

        List<Long> expected = new ArrayList<>();
        for (int i = 0; i < 10; i++) {
            expected.add((long)(i - 10));
        }
        int j = 0;
        for (TestSubscriberEx<Long> ts : list) {
            ts.awaitDone(3, TimeUnit.SECONDS);
            ts.assertNoErrors();
            ts.assertTerminated();

            for (int i = j * 10; i < j * 10 + 10; i++) {
                expected.set(i - j * 10, (long)i);
            }

            ts.assertValueSequence(expected);

            j++;
        }
    }",maybe_loop_control
i,"for (int i = 0; i < m; i++) {
                    t.onNext(i);
                }",loop_control
i,"for (int i = 0; i < TestHelper.RACE_DEFAULT_LOOPS; i++) {
            final ConnectableFlowable<Integer> cf = Flowable.range(1, 3).replay();

            Runnable r = new Runnable() {
                @Override
                public void run() {
                    cf.connect();
                }
            };

            TestHelper.race(r, r);
        }",loop_control
i,"for (int i = 0; i < TestHelper.RACE_DEFAULT_LOOPS; i++) {
            final ConnectableFlowable<Integer> cf = Flowable.range(1, 3).replay();

            final TestSubscriber<Integer> ts1 = new TestSubscriber<>();
            final TestSubscriber<Integer> ts2 = new TestSubscriber<>();

            Runnable r1 = new Runnable() {
                @Override
                public void run() {
                    cf.subscribe(ts1);
                }
            };

            Runnable r2 = new Runnable() {
                @Override
                public void run() {
                    cf.subscribe(ts2);
                }
            };

            TestHelper.race(r1, r2);
        }",loop_control
i,"for (int i = 0; i < TestHelper.RACE_DEFAULT_LOOPS; i++) {
            final ConnectableFlowable<Integer> cf = Flowable.range(1, 3).replay();

            final TestSubscriber<Integer> ts1 = new TestSubscriber<>();
            final TestSubscriber<Integer> ts2 = new TestSubscriber<>();

            cf.subscribe(ts1);

            Runnable r1 = new Runnable() {
                @Override
                public void run() {
                    ts1.cancel();
                }
            };

            Runnable r2 = new Runnable() {
                @Override
                public void run() {
                    cf.subscribe(ts2);
                }
            };

            TestHelper.race(r1, r2);
        }",loop_control
i,"for (int i = 0; i < TestHelper.RACE_DEFAULT_LOOPS; i++) {
            final PublishProcessor<Integer> pp = PublishProcessor.create();

            final ConnectableFlowable<Integer> cf = pp.replay();

            final TestSubscriber<Integer> ts1 = new TestSubscriber<>();

            Runnable r1 = new Runnable() {
                @Override
                public void run() {
                    cf.subscribe(ts1);
                }
            };

            Runnable r2 = new Runnable() {
                @Override
                public void run() {
                    for (int j = 0; j < 1000; j++) {
                        pp.onNext(j);
                    }
                }
            };

            TestHelper.race(r1, r2);
        }",loop_control
i,"for (int i = 0; i < TestHelper.RACE_DEFAULT_LOOPS; i++) {
            final PublishProcessor<Integer> pp = PublishProcessor.create();

            final ConnectableFlowable<Integer> cf = pp.replay();

            final TestSubscriber<Integer> ts1 = new TestSubscriber<>();

            cf.subscribe(ts1);

            Runnable r1 = new Runnable() {
                @Override
                public void run() {
                    ts1.cancel();
                }
            };

            Runnable r2 = new Runnable() {
                @Override
                public void run() {
                    for (int j = 0; j < 1000; j++) {
                        pp.onNext(j);
                    }
                }
            };

            TestHelper.race(r1, r2);
        }",loop_control
j,"for (int j = 0; j < 1000; j++) {
                        pp.onNext(j);
                    }",loop_control
i,"for (int i = 0; i < TestHelper.RACE_DEFAULT_LOOPS; i++) {
            final ConnectableFlowable<Integer> cf = Flowable.range(1, 1000).replay();

            final TestSubscriber<Integer> ts1 = new TestSubscriber<>();

            cf.connect();

            Runnable r1 = new Runnable() {
                @Override
                public void run() {
                    cf.subscribe(ts1);
                }
            };

            Runnable r2 = new Runnable() {
                @Override
                public void run() {
                    ts1.cancel();
                }
            };

            TestHelper.race(r1, r2);
        }",loop_control
current,"for (Integer current : ts.values()) {
            Assert.assertTrue(""The sequence must be increasing [current value="" + previous +
                    "", previous value="" + current + ""]"", previous <= current);
            previous = current;
        }",iterator
i,"for (Long i : ts.values()) {
            sum += i;
        }",iterator
ts,"{
        final TestSubscriber<Object> ts = new TestSubscriber<>();
        final Subscriber[] s = { null };

        Schedulers.single().scheduleDirect(new Runnable() {
            @SuppressWarnings(""unchecked"")
            @Override
            public void run() {
                ts.cancel();
                s[0].onNext(1);
            }
        }, 200, TimeUnit.MILLISECONDS);

        new Flowable<Integer>() {
            @Override
            protected void subscribeActual(Subscriber<? super Integer> subscriber) {
                subscriber.onSubscribe(new BooleanSubscription());
                s[0] = subscriber;
            }
        }.blockingSubscribe(ts);

        while (!ts.isCancelled()) {
            Thread.sleep(100);
        }

        ts.assertEmpty();
    }",maybe_loop_control
i,"for (int i = 0; i < TestHelper.RACE_DEFAULT_LOOPS; i++) {
            final TestSubscriber<Integer> ts = new TestSubscriber<>();

            final PublishProcessor<Integer> pp = PublishProcessor.create();

            final Runnable r1 = new Runnable() {
                @Override
                public void run() {
                    ts.cancel();
                }
            };

            final Runnable r2 = new Runnable() {
                @Override
                public void run() {
                    pp.onNext(1);
                }
            };

            final AtomicInteger c = new AtomicInteger(2);

            Schedulers.computation().scheduleDirect(new Runnable() {
                @Override
                public void run() {
                    c.decrementAndGet();
                    while (c.get() != 0 && !pp.hasSubscribers()) { }

                    TestHelper.race(r1, r2);
                }
            });

            c.decrementAndGet();
            while (c.get() != 0) { }

            pp
            .blockingSubscribe(ts);
        }",loop_control
c,"for (int i = 0; i < TestHelper.RACE_DEFAULT_LOOPS; i++) {
            final TestSubscriber<Integer> ts = new TestSubscriber<>();

            final PublishProcessor<Integer> pp = PublishProcessor.create();

            final Runnable r1 = new Runnable() {
                @Override
                public void run() {
                    ts.cancel();
                }
            };

            final Runnable r2 = new Runnable() {
                @Override
                public void run() {
                    pp.onNext(1);
                }
            };

            final AtomicInteger c = new AtomicInteger(2);

            Schedulers.computation().scheduleDirect(new Runnable() {
                @Override
                public void run() {
                    c.decrementAndGet();
                    while (c.get() != 0 && !pp.hasSubscribers()) { }

                    TestHelper.race(r1, r2);
                }
            });

            c.decrementAndGet();
            while (c.get() != 0) { }

            pp
            .blockingSubscribe(ts);
        }",maybe_loop_control
pp,"for (int i = 0; i < TestHelper.RACE_DEFAULT_LOOPS; i++) {
            final TestSubscriber<Integer> ts = new TestSubscriber<>();

            final PublishProcessor<Integer> pp = PublishProcessor.create();

            final Runnable r1 = new Runnable() {
                @Override
                public void run() {
                    ts.cancel();
                }
            };

            final Runnable r2 = new Runnable() {
                @Override
                public void run() {
                    pp.onNext(1);
                }
            };

            final AtomicInteger c = new AtomicInteger(2);

            Schedulers.computation().scheduleDirect(new Runnable() {
                @Override
                public void run() {
                    c.decrementAndGet();
                    while (c.get() != 0 && !pp.hasSubscribers()) { }

                    TestHelper.race(r1, r2);
                }
            });

            c.decrementAndGet();
            while (c.get() != 0) { }

            pp
            .blockingSubscribe(ts);
        }",maybe_loop_control
c,"for (int i = 0; i < TestHelper.RACE_DEFAULT_LOOPS; i++) {
            final TestSubscriber<Integer> ts = new TestSubscriber<>();

            final PublishProcessor<Integer> pp = PublishProcessor.create();

            final Runnable r1 = new Runnable() {
                @Override
                public void run() {
                    ts.cancel();
                }
            };

            final Runnable r2 = new Runnable() {
                @Override
                public void run() {
                    pp.onNext(1);
                }
            };

            final AtomicInteger c = new AtomicInteger(2);

            Schedulers.computation().scheduleDirect(new Runnable() {
                @Override
                public void run() {
                    c.decrementAndGet();
                    while (c.get() != 0 && !pp.hasSubscribers()) { }

                    TestHelper.race(r1, r2);
                }
            });

            c.decrementAndGet();
            while (c.get() != 0) { }

            pp
            .blockingSubscribe(ts);
        }",maybe_loop_control
i,"for (int i = 0; i < n; i++) {
            Subscriber<Object> subscriber = TestHelper.mockSubscriber();
            InOrder inOrder = inOrder(subscriber);

            src.subscribe(subscriber);

            for (int j = 5; j < 10; j++) {
                inOrder.verify(subscriber).onNext(j);
            }
            inOrder.verify(subscriber).onComplete();
            verify(subscriber, never()).onError(any(Throwable.class));
        }",loop_control
j,"for (int j = 5; j < 10; j++) {
                inOrder.verify(subscriber).onNext(j);
            }",loop_control
s,"for (Scheduler s : new Scheduler[] { Schedulers.single(), Schedulers.computation(), Schedulers.newThread(), Schedulers.io(), Schedulers.from(exec) }) {
                final TestSubscriber<Boolean> ts = TestSubscriber.create();
                ts.withTag(s.getClass().getSimpleName());

                Flowable.<Boolean>create(new FlowableOnSubscribe<Boolean>() {
                    @Override
                    public void subscribe(FlowableEmitter<Boolean> emitter) throws Exception {
                      emitter.onNext(Thread.interrupted());
                      emitter.onComplete();
                    }
                }, BackpressureStrategy.MISSING)
                .delaySubscription(100, TimeUnit.MILLISECONDS, s)
                .subscribe(ts);

                ts.awaitDone(5, TimeUnit.SECONDS);
                ts.assertValue(false);
            }",iterator
i,"for (int i = 0; i < TestHelper.RACE_DEFAULT_LOOPS; i++) {
            final TestSubscriber<Integer> ts = Flowable.range(1, 10)
                    .take(5)
                    .test(0L);

            Runnable r = new Runnable() {
                @Override
                public void run() {
                    ts.request(3);
                }
            };

            TestHelper.race(r, r);

            ts.assertResult(1, 2, 3, 4, 5);
        }",loop_control
i,"for (int i = 0; i < TestHelper.RACE_LONG_LOOPS; i++) {

            final MulticastProcessor<Integer> mp = new MulticastProcessor<>(128, true);

            final MulticastSubscription<Integer> ms1 = new MulticastSubscription<>(null, mp);
            final MulticastSubscription<Integer> ms2 = new MulticastSubscription<>(null, mp);

            assertTrue(mp.add(ms1));

            Runnable r1 = new Runnable() {
                @Override
                public void run() {
                    mp.remove(ms1);
                }
            };

            Runnable r2 = new Runnable() {
                @Override
                public void run() {
                    mp.add(ms2);
                }
            };

            TestHelper.race(r1, r2);
        }",loop_control
i,"for (int i = 0; i < expectedCount; i++) {
            Flowable
                    .just(Boolean.TRUE, Boolean.FALSE)
                    .takeWhile(new Predicate<Boolean>() {
                        @Override
                        public boolean test(Boolean value) {
                            return value;
                        }
                    })
                    .toList()
                    .doOnSuccess(new Consumer<List<Boolean>>() {
                        @Override
                        public void accept(List<Boolean> booleans) {
                            count.incrementAndGet();
                        }
                    })
                    .subscribe();
        }",loop_control
i,"for (int i = 0; i < expectedCount; i++) {
            Flowable
                    .just(Boolean.TRUE, Boolean.FALSE, Boolean.FALSE)
                    .takeWhile(new Predicate<Boolean>() {
                        @Override
                        public boolean test(Boolean value) {
                            return value;
                        }
                    })
                    .toList()
                    .doOnSuccess(new Consumer<List<Boolean>>() {
                        @Override
                        public void accept(List<Boolean> booleans) {
                            count.incrementAndGet();
                        }
                    })
                    .subscribe();
        }",loop_control
value,"for (final String value : values) {
                    parentSubscription.add(innerScheduler.schedule(new Runnable() {
                        @Override
                        public void run() {
                            subscriber.onNext(value);
                        }
                    }
                    , delay, TimeUnit.MILLISECONDS));
                    delay += interval;
                }",iterator
i,"for (int i = 0; i < TestHelper.RACE_DEFAULT_LOOPS; i++) {
            final PublishProcessor<Integer> pp1 = PublishProcessor.create();
            final PublishProcessor<Integer> pp2 = PublishProcessor.create();

            TestSubscriberEx<Integer> ts = Flowable.ambArray(pp1, pp2).to(TestHelper.<Integer>testConsumer());

            Runnable r1 = new Runnable() {
                @Override
                public void run() {
                    pp1.onNext(1);
                }
            };
            Runnable r2 = new Runnable() {
                @Override
                public void run() {
                    pp2.onNext(1);
                }
            };

            TestHelper.race(r1, r2);

            ts.assertSubscribed().assertNoErrors()
            .assertNotComplete().assertValueCount(1);
        }",loop_control
i,"for (int i = 0; i < TestHelper.RACE_DEFAULT_LOOPS; i++) {
            final PublishProcessor<Integer> pp1 = PublishProcessor.create();
            final PublishProcessor<Integer> pp2 = PublishProcessor.create();

            TestSubscriber<Integer> ts = Flowable.ambArray(pp1, pp2).test();

            Runnable r1 = new Runnable() {
                @Override
                public void run() {
                    pp1.onComplete();
                }
            };
            Runnable r2 = new Runnable() {
                @Override
                public void run() {
                    pp2.onComplete();
                }
            };

            TestHelper.race(r1, r2);

            ts.assertResult();
        }",loop_control
i,"for (int i = 0; i < TestHelper.RACE_DEFAULT_LOOPS; i++) {
            final PublishProcessor<Integer> pp1 = PublishProcessor.create();
            final PublishProcessor<Integer> pp2 = PublishProcessor.create();

            TestSubscriber<Integer> ts = Flowable.ambArray(pp1, pp2).test();

            final Throwable ex = new TestException();

            Runnable r1 = new Runnable() {
                @Override
                public void run() {
                    pp1.onError(ex);
                }
            };
            Runnable r2 = new Runnable() {
                @Override
                public void run() {
                    pp2.onError(ex);
                }
            };

            List<Throwable> errors = TestHelper.trackPluginErrors();
            try {
                TestHelper.race(r1, r2);
            } finally {
                RxJavaPlugins.reset();
            }

            ts.assertFailure(TestException.class);
            if (!errors.isEmpty()) {
                TestHelper.assertUndeliverable(errors, 0, TestException.class);
            }
        }",loop_control
i,"for (int i = 0; i < TestHelper.RACE_LONG_LOOPS; i++) {
            final AtomicBoolean interrupted = new AtomicBoolean();
            final CountDownLatch cdl = new CountDownLatch(1);

            Flowable.ambArray(
                Flowable.just(1)
                    .subscribeOn(Schedulers.single())
                    .observeOn(Schedulers.computation()),
                Flowable.never()
            )
            .subscribe(new Consumer<Object>() {
                @Override
                public void accept(Object v) throws Exception {
                    interrupted.set(Thread.currentThread().isInterrupted());
                    cdl.countDown();
                }
            });

            assertTrue(cdl.await(500, TimeUnit.SECONDS));
            assertFalse(""Interrupted!"", interrupted.get());
        }",loop_control
i,"for (int i = 0; i < TestHelper.RACE_LONG_LOOPS; i++) {
            final AtomicBoolean interrupted = new AtomicBoolean();
            final CountDownLatch cdl = new CountDownLatch(1);

            Flowable.ambArray(
                Flowable.error(ex)
                    .subscribeOn(Schedulers.single())
                    .observeOn(Schedulers.computation()),
                Flowable.never()
            )
            .subscribe(Functions.emptyConsumer(), new Consumer<Throwable>() {
                @Override
                public void accept(Throwable e) throws Exception {
                    interrupted.set(Thread.currentThread().isInterrupted());
                    cdl.countDown();
                }
            });

            assertTrue(cdl.await(500, TimeUnit.SECONDS));
            assertFalse(""Interrupted!"", interrupted.get());
        }",loop_control
i,"for (int i = 0; i < TestHelper.RACE_LONG_LOOPS; i++) {
            final AtomicBoolean interrupted = new AtomicBoolean();
            final CountDownLatch cdl = new CountDownLatch(1);

            Flowable.ambArray(
                Flowable.empty()
                    .subscribeOn(Schedulers.single())
                    .observeOn(Schedulers.computation()),
                Flowable.never()
            )
            .subscribe(Functions.emptyConsumer(), Functions.emptyConsumer(), new Action() {
                @Override
                public void run() throws Exception {
                    interrupted.set(Thread.currentThread().isInterrupted());
                    cdl.countDown();
                }
            });

            assertTrue(cdl.await(500, TimeUnit.SECONDS));
            assertFalse(""Interrupted!"", interrupted.get());
        }",loop_control
i,"for (int i = 0; i < TestHelper.RACE_DEFAULT_LOOPS; i++) {
            final TestScheduler scheduler = new TestScheduler();

            final PublishProcessor<Integer> pp = PublishProcessor.create();

            TestSubscriber<Integer> ts = pp.sample(1, TimeUnit.SECONDS, scheduler, true)
            .test();

            pp.onNext(1);

            Runnable r1 = new Runnable() {
                @Override
                public void run() {
                    pp.onComplete();
                }
            };

            Runnable r2 = new Runnable() {
                @Override
                public void run() {
                    scheduler.advanceTimeBy(1, TimeUnit.SECONDS);
                }
            };

            TestHelper.race(r1, r2);

            ts.assertResult(1);
        }",loop_control
i,"for (int i = 0; i < TestHelper.RACE_DEFAULT_LOOPS; i++) {
            final PublishProcessor<Integer> pp = PublishProcessor.create();
            final PublishProcessor<Integer> sampler = PublishProcessor.create();

            TestSubscriber<Integer> ts = pp.sample(sampler, true)
            .test();

            pp.onNext(1);

            Runnable r1 = new Runnable() {
                @Override
                public void run() {
                    pp.onComplete();
                }
            };

            Runnable r2 = new Runnable() {
                @Override
                public void run() {
                    sampler.onNext(1);
                }
            };

            TestHelper.race(r1, r2);

            ts.assertResult(1);
        }",loop_control
i,"for (int i = 0; i < TestHelper.RACE_DEFAULT_LOOPS; i++) {
            final PublishProcessor<Integer> pp = PublishProcessor.create();
            final PublishProcessor<Integer> sampler = PublishProcessor.create();

            TestSubscriber<Integer> ts = pp.sample(sampler, true).test();

            pp.onNext(1);

            Runnable r1 = new Runnable() {
                @Override
                public void run() {
                    pp.onComplete();
                }
            };

            Runnable r2 = new Runnable() {
                @Override
                public void run() {
                    sampler.onComplete();
                }
            };

            TestHelper.race(r1, r2);

            ts.assertResult(1);
        }",loop_control
i,"for (int i = 0; i < 10000; i++) {
            final PublishProcessor<Integer> pp = PublishProcessor.create();
            final SingleSubject<Integer> cs = SingleSubject.create();

            TestSubscriber<Integer> ts = pp.mergeWith(cs).test();

            Runnable r1 = new Runnable() {
                @Override
                public void run() {
                    pp.onNext(1);
                    pp.onComplete();
                }
            };

            Runnable r2 = new Runnable() {
                @Override
                public void run() {
                    cs.onSuccess(1);
                }
            };

            TestHelper.race(r1, r2);

            ts.assertResult(1, 1);
        }",loop_control
i,"for (int i = 0; i < 10000; i++) {
            final PublishProcessor<Integer> pp = PublishProcessor.create();
            final SingleSubject<Integer> cs = SingleSubject.create();

            final TestSubscriber<Integer> ts = pp.mergeWith(cs).subscribeWith(new TestSubscriber<>(0));

            Runnable r1 = new Runnable() {
                @Override
                public void run() {
                    cs.onSuccess(1);
                }
            };

            Runnable r2 = new Runnable() {
                @Override
                public void run() {
                    ts.request(2);
                }
            };

            TestHelper.race(r1, r2);

            pp.onNext(2);
            pp.onComplete();

            ts.assertResult(1, 2);
        }",loop_control
i,"for (int i = 0; i < 10000; i++) {
            final PublishProcessor<Integer> pp = PublishProcessor.create();
            final SingleSubject<Integer> cs = SingleSubject.create();

            final TestSubscriber<Integer> ts = pp.mergeWith(cs).test(0);

            pp.onNext(0);

            Runnable r1 = new Runnable() {
                @Override
                public void run() {
                    pp.onNext(1);
                }
            };

            Runnable r2 = new Runnable() {
                @Override
                public void run() {
                    ts.request(3);
                }
            };

            TestHelper.race(r1, r2);

            cs.onSuccess(1);
            pp.onComplete();

            ts.assertResult(0, 1, 1);
        }",loop_control
i,"for (int i = 0; i < Flowable.bufferSize() - 1; i++) {
                        pp.onNext(i + 2);
                    }",loop_control
timeout,"{
            final CountDownLatch cdl1 = new CountDownLatch(1);
            final CountDownLatch cdl2 = new CountDownLatch(1);

            TestSubscriber<Object> ts = Flowable.fromCompletable(Completable.fromAction(new Action() {
                @Override
                public void run() throws Exception {
                    cdl1.countDown();
                    cdl2.await(5, TimeUnit.SECONDS);
                }
            }))
            .subscribeOn(Schedulers.single()).test();

            assertTrue(cdl1.await(5, TimeUnit.SECONDS));

            ts.cancel();

            int timeout = 10;

            while (timeout-- > 0 && errors.isEmpty()) {
                Thread.sleep(100);
            }

            TestHelper.assertUndeliverable(errors, 0, InterruptedException.class);
        }",loop_control
errors,"{
        List<Throwable> errors = TestHelper.trackPluginErrors();
        try {
            final CountDownLatch cdl1 = new CountDownLatch(1);
            final CountDownLatch cdl2 = new CountDownLatch(1);

            TestSubscriber<Object> ts = Flowable.fromCompletable(Completable.fromAction(new Action() {
                @Override
                public void run() throws Exception {
                    cdl1.countDown();
                    cdl2.await(5, TimeUnit.SECONDS);
                }
            }))
            .subscribeOn(Schedulers.single()).test();

            assertTrue(cdl1.await(5, TimeUnit.SECONDS));

            ts.cancel();

            int timeout = 10;

            while (timeout-- > 0 && errors.isEmpty()) {
                Thread.sleep(100);
            }

            TestHelper.assertUndeliverable(errors, 0, InterruptedException.class);
        } finally {
            RxJavaPlugins.reset();
        }
    }",maybe_loop_control
i,"for (int i = 0; i < n; i++) {
            PublishProcessor<Integer> delay = PublishProcessor.create();
            delays.add(delay);
        }",loop_control
i,"for (int i = 0; i < n; i++) {
            source.onNext(i);
            delays.get(i).onNext(i);
            inOrder.verify(subscriber).onNext(i);
        }",loop_control
i,"for (int i = 0; i < n; i++) {
            subjects.add(PublishProcessor.<Integer> create());
        }",loop_control
i,"for (int i = 0; i < n; i++) {
            source.onNext(i);
        }",loop_control
i,"for (int i = n - 1; i >= 0; i--) {
            subjects.get(i).onComplete();
            inOrder.verify(subscriber).onNext(i);
        }",loop_control
i,"for (int i = 0; i < n; i++) {
            array[i] = i;
        }",loop_control
i,"for (int i = 0; i < TestHelper.RACE_DEFAULT_LOOPS; i++) {
            PublishProcessor<Flowable<Integer>> source = PublishProcessor.create();

            TestSubscriber<Integer> ts = source
                    .concatMap(v -> v, n + 1)
                    .test(1L);

            TestHelper.race(() -> {
                for (int j = 0; j < n; j++) {
                    source.onNext(just);
                }
            }, () -> {
                for (int j = 0; j < n; j++) {
                    ts.request(1);
                }
            });

            ts.assertValueCount(n);
        }",loop_control
j,"for (int j = 0; j < n; j++) {
                    source.onNext(just);
                }",loop_control
j,"for (int j = 0; j < n; j++) {
                    ts.request(1);
                }",loop_control
i,"for (int i = 0; i < TestHelper.RACE_DEFAULT_LOOPS; i++) {
            PublishProcessor<Flowable<Integer>> source = PublishProcessor.create();

            TestSubscriber<Integer> ts = source
                    .concatMapDelayError(v -> v, true, n + 1)
                    .test(1L);

            TestHelper.race(() -> {
                for (int j = 0; j < n; j++) {
                    source.onNext(just);
                }
            }, () -> {
                for (int j = 0; j < n; j++) {
                    ts.request(1);
                }
            });

            ts.assertValueCount(n);
        }",loop_control
j,"for (int j = 0; j < n; j++) {
                    source.onNext(just);
                }",loop_control
j,"for (int j = 0; j < n; j++) {
                    ts.request(1);
                }",loop_control
i,"for (int i = 0; i < 10000; i++) {
            final PublishProcessor<Integer> pp = PublishProcessor.create();
            final MaybeSubject<Integer> cs = MaybeSubject.create();

            TestSubscriber<Integer> ts = pp.mergeWith(cs).test();

            Runnable r1 = new Runnable() {
                @Override
                public void run() {
                    pp.onNext(1);
                    pp.onComplete();
                }
            };

            Runnable r2 = new Runnable() {
                @Override
                public void run() {
                    cs.onSuccess(1);
                }
            };

            TestHelper.race(r1, r2);

            ts.assertResult(1, 1);
        }",loop_control
i,"for (int i = 0; i < 10000; i++) {
            final PublishProcessor<Integer> pp = PublishProcessor.create();
            final MaybeSubject<Integer> cs = MaybeSubject.create();

            final TestSubscriber<Integer> ts = pp.mergeWith(cs).subscribeWith(new TestSubscriber<>(0));

            Runnable r1 = new Runnable() {
                @Override
                public void run() {
                    cs.onSuccess(1);
                }
            };

            Runnable r2 = new Runnable() {
                @Override
                public void run() {
                    ts.request(2);
                }
            };

            TestHelper.race(r1, r2);

            pp.onNext(2);
            pp.onComplete();

            ts.assertResult(1, 2);
        }",loop_control
i,"for (int i = 0; i < 10000; i++) {
            final PublishProcessor<Integer> pp = PublishProcessor.create();
            final MaybeSubject<Integer> cs = MaybeSubject.create();

            final TestSubscriber<Integer> ts = pp.mergeWith(cs).test(0);

            pp.onNext(0);

            Runnable r1 = new Runnable() {
                @Override
                public void run() {
                    pp.onNext(1);
                }
            };

            Runnable r2 = new Runnable() {
                @Override
                public void run() {
                    ts.request(3);
                }
            };

            TestHelper.race(r1, r2);

            cs.onSuccess(1);
            pp.onComplete();

            ts.assertResult(0, 1, 1);
        }",loop_control
i,"for (int i = 0; i < Flowable.bufferSize() - 1; i++) {
                        pp.onNext(i + 2);
                    }",loop_control
i,"for (int i = 1; i <= Flowable.bufferSize() * 2 + 1; i++) {
            list.add(i);
        }",loop_control
i,"for (int i = 0; i < 100; i++) {
            list.add(i + start);
            ts.request(1);
        }",loop_control
i,"for (int i = 0; i < 100; i++) {
            list.add(i + start);
        }",loop_control
i,"for (int i = 0; i < 100; i++) {
            withBackpressureOneByOne(i);
        }",loop_control
i,"for (int i = 0; i < 100; i++) {
            withBackpressureAllAtOnce(i);
        }",loop_control
i,"for (int i = 0; i < 100; i++) {
            list.add(i + 50);
        }",loop_control
i,"for (int i = 1; i <= 5; i++) {
                    if (bs.isCancelled()) {
                        break;
                    }
                    numEmitted.incrementAndGet();
                    subscriber.onNext(i);
                    Thread.yield();
                }",loop_control
bs,"{
                BooleanSubscription bs = new BooleanSubscription();
                subscriber.onSubscribe(bs);
                for (int i = 1; i <= 5; i++) {
                    if (bs.isCancelled()) {
                        break;
                    }
                    numEmitted.incrementAndGet();
                    subscriber.onNext(i);
                    Thread.yield();
                }
                subscriber.onComplete();
            }",break_loop_control
bs,"{
                final BooleanSubscription bs = new BooleanSubscription();
                subscriber.onSubscribe(bs);
                Thread t = new Thread(new Runnable() {

                    @Override
                    public void run() {
                        System.out.println(""-------> subscribe to infinite sequence"");
                        System.out.println(""Starting thread: "" + Thread.currentThread());
                        int i = 1;
                        while (!bs.isCancelled()) {
                            subscriber.onNext(i++);
                            Thread.yield();
                        }
                        subscriber.onComplete();
                        latch.countDown();
                        System.out.println(""Ending thread: "" + Thread.currentThread());
                    }
                });
                t.start();

            }",maybe_loop_control
i,"for (int i = 0; i < 1026; i++) {
            expected.add(i * 3);
        }",loop_control
i,"{
        long startTime = System.currentTimeMillis();
        Flowable<Integer> src = Flowable.just(1).subscribeOn(Schedulers.computation());

        // now try and generate a hang by zipping src with itself repeatedly. A
        // time limit of 9 seconds ( 1 second less than the test timeout) is
        // used so that this test will not timeout on slow machines.
        int i = 0;
        while (System.currentTimeMillis() - startTime < 9000 && i++ < 100000) {
            int value = Flowable.zip(src, src, new BiFunction<Integer, Integer, Integer>() {
                @Override
                public Integer apply(Integer t1, Integer t2) {
                    return t1 + t2 * 10;
                }
            }).blockingSingle(0);

            Assert.assertEquals(11, value);
        }
    }",loop_control
j,"for (int j = 0; j < i; j++) {
                b.append('1');
            }",loop_control
j,"for (int j = 0; j < params.length; j++) {
                Object[] params0 = params.clone();
                params0[j] = null;

                try {
                    m.invoke(null, params0);
                    fail(""Should have thrown @ "" + m);
                } catch (InvocationTargetException ex) {
                    assertTrue(ex.toString(), ex.getCause() instanceof NullPointerException);

                    if (j < i) {
                        assertEquals(""source"" + (j + 1) + "" is null"", ex.getCause().getMessage());
                    } else {
                        assertEquals(""zipper is null"", ex.getCause().getMessage());
                    }
                }
            }",loop_control
i,"for (int i = 2; i < 10; i++) {
            Class<?>[] types = new Class[i + 1];
            Arrays.fill(types, Publisher.class);
            types[i] = i == 2 ? BiFunction.class : Class.forName(""io.reactivex.rxjava3.functions.Function"" + i);

            Method m = Flowable.class.getMethod(""zip"", types);

            Object[] params = new Object[i + 1];
            Arrays.fill(params, source);
            params[i] = ArgsToString.INSTANCE;

            StringBuilder b = new StringBuilder();
            for (int j = 0; j < i; j++) {
                b.append('1');
            }

            ((Flowable)m.invoke(null, params)).test().assertResult(b.toString());

            for (int j = 0; j < params.length; j++) {
                Object[] params0 = params.clone();
                params0[j] = null;

                try {
                    m.invoke(null, params0);
                    fail(""Should have thrown @ "" + m);
                } catch (InvocationTargetException ex) {
                    assertTrue(ex.toString(), ex.getCause() instanceof NullPointerException);

                    if (j < i) {
                        assertEquals(""source"" + (j + 1) + "" is null"", ex.getCause().getMessage());
                    } else {
                        assertEquals(""zipper is null"", ex.getCause().getMessage());
                    }
                }
            }
        }",loop_control
i,"for (int i = 0; i < 500; i++) {
            TestSubscriber<List<Object>> ts = Flowable.zip(
                    Flowable.just(1).observeOn(Schedulers.single()).map(new Function<Integer, Object>() {
                        @Override
                        public Object apply(Integer v) throws Exception {
                            return Thread.currentThread().getName().substring(0, 4);
                        }
                    }),
                    Flowable.just(1).observeOn(Schedulers.computation()).map(new Function<Integer, Object>() {
                        @Override
                        public Object apply(Integer v) throws Exception {
                            return Thread.currentThread().getName().substring(0, 4);
                        }
                    }),
                    new BiFunction<Object, Object, List<Object>>() {
                        @Override
                        public List<Object> apply(Object t1, Object t2) throws Exception {
                            return Arrays.asList(t1, t2);
                        }
                    }
            )
            .test()
            .awaitDone(5, TimeUnit.SECONDS)
            .assertValueCount(1);

            List<Object> list = ts.values().get(0);

            assertTrue(list.toString(), list.contains(""RxSi""));
            assertTrue(list.toString(), list.contains(""RxCo""));
        }",loop_control
r2,"{
        PublishProcessor<String> r1 = PublishProcessor.create();
        /* define a Subscriber to receive aggregated events */
        Subscriber<String> subscriber = TestHelper.mockSubscriber();
        InOrder io = inOrder(subscriber);

        Iterable<String> r2 = new Iterable<String>() {

            @Override
            public Iterator<String> iterator() {
                return new Iterator<String>() {
                    int count;

                    @Override
                    public boolean hasNext() {
                        if (count == 0) {
                            return true;
                        }
                        throw new TestException();
                    }

                    @Override
                    public String next() {
                        count++;
                        return ""1"";
                    }

                    @Override
                    public void remove() {
                        throw new UnsupportedOperationException(""Not supported yet."");
                    }

                };
            }

        };

        r1.zipWith(r2, zipr2).subscribe(subscriber);

        r1.onNext(""one-"");
        r1.onError(new TestException());

        io.verify(subscriber).onNext(""one-1"");
        io.verify(subscriber).onError(any(TestException.class));

        verify(subscriber, never()).onComplete();

    }",iterator
s,"for (String s : valuesToReturn) {
                        if (s == null) {
                            System.out.println(""throwing exception"");
                            try {
                                Thread.sleep(100);
                            } catch (Throwable e) {

                            }
                            subscriber.onError(new NullPointerException());
                            return;
                        } else {
                            subscriber.onNext(s);
                        }
                    }",iterator
timeout,"{
            final CountDownLatch cdl1 = new CountDownLatch(1);
            final CountDownLatch cdl2 = new CountDownLatch(1);

            TestSubscriber<Object> ts = Flowable.fromRunnable(new Runnable() {
                @Override
                public void run() {
                    cdl1.countDown();
                    try {
                        cdl2.await(5, TimeUnit.SECONDS);
                    } catch (InterruptedException e) {
                        e.printStackTrace();
                        throw new TestException(e);
                    }
                }
            }).subscribeOn(Schedulers.single()).test();

            assertTrue(cdl1.await(5, TimeUnit.SECONDS));

            ts.cancel();

            int timeout = 10;

            while (timeout-- > 0 && errors.isEmpty()) {
                Thread.sleep(100);
            }

            TestHelper.assertUndeliverable(errors, 0, TestException.class);
        }",loop_control
errors,"{
        List<Throwable> errors = TestHelper.trackPluginErrors();
        try {
            final CountDownLatch cdl1 = new CountDownLatch(1);
            final CountDownLatch cdl2 = new CountDownLatch(1);

            TestSubscriber<Object> ts = Flowable.fromRunnable(new Runnable() {
                @Override
                public void run() {
                    cdl1.countDown();
                    try {
                        cdl2.await(5, TimeUnit.SECONDS);
                    } catch (InterruptedException e) {
                        e.printStackTrace();
                        throw new TestException(e);
                    }
                }
            }).subscribeOn(Schedulers.single()).test();

            assertTrue(cdl1.await(5, TimeUnit.SECONDS));

            ts.cancel();

            int timeout = 10;

            while (timeout-- > 0 && errors.isEmpty()) {
                Thread.sleep(100);
            }

            TestHelper.assertUndeliverable(errors, 0, TestException.class);
        } finally {
            RxJavaPlugins.reset();
        }
    }",maybe_loop_control
i,"for (int i = 0; i < TestHelper.RACE_DEFAULT_LOOPS; i++) {
            final TestSubscriber<Long> ts = new TestSubscriber<>();

            final TestScheduler scheduler = new TestScheduler();

            Flowable.timer(1, TimeUnit.SECONDS, scheduler)
            .subscribe(ts);

            Runnable r1 = new Runnable() {
                @Override
                public void run() {
                    scheduler.advanceTimeBy(1, TimeUnit.SECONDS);
                }
            };

            Runnable r2 = new Runnable() {
                @Override
                public void run() {
                    ts.cancel();
                }
            };

            TestHelper.race(r1, r2);
        }",loop_control
i,"for (int i = 0; i < 1000; i++) {
                Flowable.timer(0, TimeUnit.MILLISECONDS).blockingFirst();
            }",loop_control
s,"for (Scheduler s : new Scheduler[] { Schedulers.single(), Schedulers.computation(), Schedulers.newThread(), Schedulers.io(), Schedulers.from(exec, true) }) {
                final AtomicBoolean interrupted = new AtomicBoolean();
                TestSubscriber<Long> ts = Flowable.timer(1, TimeUnit.MILLISECONDS, s)
                .map(new Function<Long, Long>() {
                    @Override
                    public Long apply(Long v) throws Exception {
                        try {
                        Thread.sleep(3000);
                        } catch (InterruptedException ex) {
                            interrupted.set(true);
                        }
                        return v;
                    }
                })
                .test();

                Thread.sleep(500);

                ts.cancel();

                Thread.sleep(500);

                assertTrue(s.getClass().getSimpleName(), interrupted.get());
            }",iterator
it,"{
        TestScheduler scheduler = new TestScheduler();

        Flowable<Long> source = Flowable.interval(1, TimeUnit.SECONDS, scheduler).take(10);

        Iterable<Long> iter = source.blockingLatest();

        Iterator<Long> it = iter.iterator();

        // only 9 because take(10) will immediately call onComplete when receiving the 10th item
        // which onComplete will overwrite the previous value
        for (int i = 0; i < 9; i++) {
            scheduler.advanceTimeBy(1, TimeUnit.SECONDS);

            Assert.assertTrue(it.hasNext());

            Assert.assertEquals(Long.valueOf(i), it.next());
        }

        scheduler.advanceTimeBy(1, TimeUnit.SECONDS);
        Assert.assertFalse(it.hasNext());
    }",iterator
j,"for (int j = 0; j < 3; j++) {
            Iterator<Long> it = iter.iterator();

            // only 9 because take(10) will immediately call onComplete when receiving the 10th item
            // which onComplete will overwrite the previous value
            for (int i = 0; i < 9; i++) {
                scheduler.advanceTimeBy(1, TimeUnit.SECONDS);

                Assert.assertTrue(it.hasNext());

                Assert.assertEquals(Long.valueOf(i), it.next());
            }

            scheduler.advanceTimeBy(1, TimeUnit.SECONDS);
            Assert.assertFalse(it.hasNext());
        }",loop_control
i,"for (int i = 0; i < 9; i++) {
                scheduler.advanceTimeBy(1, TimeUnit.SECONDS);

                Assert.assertTrue(it.hasNext());

                Assert.assertEquals(Long.valueOf(i), it.next());
            }",loop_control
it,"for (int j = 0; j < 3; j++) {
            Iterator<Long> it = iter.iterator();

            // only 9 because take(10) will immediately call onComplete when receiving the 10th item
            // which onComplete will overwrite the previous value
            for (int i = 0; i < 9; i++) {
                scheduler.advanceTimeBy(1, TimeUnit.SECONDS);

                Assert.assertTrue(it.hasNext());

                Assert.assertEquals(Long.valueOf(i), it.next());
            }

            scheduler.advanceTimeBy(1, TimeUnit.SECONDS);
            Assert.assertFalse(it.hasNext());
        }",iterator
it,"{
        Flowable<Long> source = Flowable.<Long> empty();

        Iterable<Long> iter = source.blockingLatest();

        Iterator<Long> it = iter.iterator();

        Assert.assertFalse(it.hasNext());

        it.next();
    }",iterator
i,"for (int i = 0; i < 10; i++) {
            scheduler.advanceTimeBy(1, TimeUnit.SECONDS);

            Assert.assertEquals(Long.valueOf(i), it.next());
        }",loop_control
it,"{
        TestScheduler scheduler = new TestScheduler();

        Flowable<Long> source = Flowable.interval(1, TimeUnit.SECONDS, scheduler).take(10);

        Iterable<Long> iter = source.blockingLatest();

        Iterator<Long> it = iter.iterator();

        // only 9 because take(10) will immediately call onComplete when receiving the 10th item
        // which onComplete will overwrite the previous value
        for (int i = 0; i < 10; i++) {
            scheduler.advanceTimeBy(1, TimeUnit.SECONDS);

            Assert.assertEquals(Long.valueOf(i), it.next());
        }
    }",iterator
it,"{
        TestScheduler scheduler = new TestScheduler();

        Flowable<Long> source = Flowable.<Long> error(new RuntimeException(""Forced failure!"")).subscribeOn(scheduler);

        Iterable<Long> iter = source.blockingLatest();

        Iterator<Long> it = iter.iterator();

        scheduler.advanceTimeBy(1, TimeUnit.SECONDS);

        it.hasNext();
    }",iterator
it,"{
        TestScheduler scheduler = new TestScheduler();

        Flowable<Long> source = Flowable.<Long> error(new RuntimeException(""Forced failure!"")).subscribeOn(scheduler);

        Iterable<Long> iter = source.blockingLatest();
        Iterator<Long> it = iter.iterator();

        scheduler.advanceTimeBy(1, TimeUnit.SECONDS);

        it.next();
    }",iterator
it,"{
        PublishProcessor<Integer> source = PublishProcessor.create();
        Flowable<Integer> blocker = source;

        Iterable<Integer> iter = blocker.blockingLatest();
        Iterator<Integer> it = iter.iterator();

        source.onNext(1);

        Assert.assertEquals(Integer.valueOf(1), it.next());

        source.onNext(2);
        source.onNext(3);

        Assert.assertEquals(Integer.valueOf(3), it.next());

        source.onNext(4);
        source.onNext(5);
        source.onNext(6);

        Assert.assertEquals(Integer.valueOf(6), it.next());

        source.onNext(7);
        source.onComplete();

        Assert.assertFalse(it.hasNext());
    }",iterator
it,"{
        Iterator<Object> it = Flowable.never().blockingLatest().iterator();

        Thread.currentThread().interrupt();

        try {
            it.hasNext();
        } catch (RuntimeException ex) {
            assertTrue(ex.toString(), ex.getCause() instanceof InterruptedException);
        }
        Thread.interrupted();
    }",iterator
it,"{
        Iterator<Object> it = Flowable.error(new TestException()).blockingLatest().iterator();

        for (int i = 0; i < 3; i++) {
            try {
                it.hasNext();
                fail(""Should have thrown"");
            } catch (TestException ex) {
                // expected
            }
        }
    }",iterator
i,"for (int i = 0; i < 3; i++) {
            try {
                it.hasNext();
                fail(""Should have thrown"");
            } catch (TestException ex) {
                // expected
            }
        }",loop_control
it,"{
        Iterator<Object> it = Flowable.never().blockingLatest().iterator();

        List<Throwable> errors = TestHelper.trackPluginErrors();
        try {
            ((Subscriber<Object>)it).onError(new TestException());

            TestHelper.assertUndeliverable(errors, 0, TestException.class);
        } finally {
            RxJavaPlugins.reset();
        }
    }",iterator
s,"for (Scheduler s : new Scheduler[] { Schedulers.single(), Schedulers.computation(), Schedulers.newThread(), Schedulers.io(), Schedulers.from(exec, true) }) {
                final AtomicBoolean interrupted = new AtomicBoolean();
                TestObserver<Void> to = Completable.timer(1, TimeUnit.MILLISECONDS, s)
                .doOnComplete(new Action() {
                    @Override
                    public void run() throws Exception {
                        try {
                        Thread.sleep(3000);
                        } catch (InterruptedException ex) {
                            interrupted.set(true);
                        }
                    }
                })
                .test();

                Thread.sleep(500);

                to.dispose();

                Thread.sleep(500);

                assertTrue(s.getClass().getSimpleName(), interrupted.get());
            }",iterator
i,"for (int i = 0; i < TestHelper.RACE_DEFAULT_LOOPS; i++) {
            List<Throwable> errors = TestHelper.trackPluginErrors();
            try {
                final PublishProcessor<Integer> pp1 = PublishProcessor.create();
                final PublishProcessor<Integer> pp2 = PublishProcessor.create();

                TestObserverEx<Void> to = Completable.merge(pp1.map(new Function<Integer, Completable>() {
                    @Override
                    public Completable apply(Integer v) throws Exception {
                        return pp2.ignoreElements();
                    }
                })).to(TestHelper.<Void>testConsumer());

                pp1.onNext(1);

                final Throwable ex1 = new TestException();
                final Throwable ex2 = new TestException();

                Runnable r1 = new Runnable() {
                    @Override
                    public void run() {
                        pp1.onError(ex1);
                    }
                };
                Runnable r2 = new Runnable() {
                    @Override
                    public void run() {
                        pp2.onError(ex2);
                    }
                };

                TestHelper.race(r1, r2);

                Throwable ex = to.errors().get(0);
                if (ex instanceof CompositeException) {
                    to.assertSubscribed().assertNoValues().assertNotComplete();

                    errors = TestHelper.compositeList(ex);
                    TestHelper.assertError(errors, 0, TestException.class);
                    TestHelper.assertError(errors, 1, TestException.class);
                } else {
                    to.assertFailure(TestException.class);

                    if (!errors.isEmpty()) {
                        TestHelper.assertUndeliverable(errors, 0, TestException.class);
                    }
                }
            } finally {
                RxJavaPlugins.reset();
            }
        }",loop_control
i,"for (int i = 0; i < TestHelper.RACE_DEFAULT_LOOPS; i++) {
            final PublishProcessor<Integer> pp1 = PublishProcessor.create();
            final PublishProcessor<Integer> pp2 = PublishProcessor.create();

            TestObserverEx<Void> to = Completable.mergeDelayError(pp1.map(new Function<Integer, Completable>() {
                @Override
                public Completable apply(Integer v) throws Exception {
                    return pp2.ignoreElements();
                }
            })).to(TestHelper.<Void>testConsumer());

            pp1.onNext(1);

            final Throwable ex1 = new TestException();

            Runnable r1 = new Runnable() {
                @Override
                public void run() {
                    pp1.onError(ex1);
                }
            };

            final Throwable ex2 = new TestException();
            Runnable r2 = new Runnable() {
                @Override
                public void run() {
                    pp2.onError(ex2);
                }
            };

            TestHelper.race(r1, r2);

            to.assertFailure(CompositeException.class);

            List<Throwable> errors = TestHelper.compositeList(to.errors().get(0));

            TestHelper.assertError(errors, 0, TestException.class);
            TestHelper.assertError(errors, 1, TestException.class);
        }",loop_control
i,"for (int i = 0; i < TestHelper.RACE_DEFAULT_LOOPS; i++) {
            List<Throwable> errors = TestHelper.trackPluginErrors();
            try {
                final PublishProcessor<Integer> pp1 = PublishProcessor.create();
                final PublishProcessor<Integer> pp2 = PublishProcessor.create();

                TestObserver<Void> to = Completable.mergeArray(pp1.ignoreElements(), pp2.ignoreElements()).test();

                pp1.onNext(1);

                final Throwable ex1 = new TestException();
                final Throwable ex2 = new TestException();

                Runnable r1 = new Runnable() {
                    @Override
                    public void run() {
                        pp1.onError(ex1);
                    }
                };
                Runnable r2 = new Runnable() {
                    @Override
                    public void run() {
                        pp2.onError(ex2);
                    }
                };

                TestHelper.race(r1, r2);

                to.assertFailure(TestException.class);

                if (!errors.isEmpty()) {
                    TestHelper.assertUndeliverable(errors, 0, TestException.class);
                }
            } finally {
                RxJavaPlugins.reset();
            }
        }",loop_control
k,"for (int k = 0; k < 100; k++) {
            final int count = 10;
            final CountDownLatch latch = new CountDownLatch(count);
            final boolean[] interrupted = {false};

            for (int i = 0; i < count; i++) {
                Completable.complete()
                        .subscribeOn(Schedulers.io())
                        .observeOn(Schedulers.io())
                        .andThen(Completable.fromAction(new Action() {
                            @Override
                            public void run() throws Exception {
                                try {
                                    Thread.sleep(30);
                                } catch (InterruptedException e) {
                                    System.out.println(""Interrupted! "" + Thread.currentThread());
                                    interrupted[0] = true;
                                }
                            }
                        }))
                        .subscribe(new Action() {
                            @Override
                            public void run() throws Exception {
                                latch.countDown();
                            }
                        });
            }

            latch.await();
            assertFalse(""The second Completable was interrupted!"", interrupted[0]);
        }",loop_control
i,"for (int i = 0; i < count; i++) {
                Completable.complete()
                        .subscribeOn(Schedulers.io())
                        .observeOn(Schedulers.io())
                        .andThen(Completable.fromAction(new Action() {
                            @Override
                            public void run() throws Exception {
                                try {
                                    Thread.sleep(30);
                                } catch (InterruptedException e) {
                                    System.out.println(""Interrupted! "" + Thread.currentThread());
                                    interrupted[0] = true;
                                }
                            }
                        }))
                        .subscribe(new Action() {
                            @Override
                            public void run() throws Exception {
                                latch.countDown();
                            }
                        });
            }",loop_control
i,"for (int i = 0; i < TestHelper.RACE_DEFAULT_LOOPS; i++) {
            List<Throwable> errors = TestHelper.trackPluginErrors();

            try {
                final TestScheduler scheduler = new TestScheduler();

                final PublishSubject<Integer> ps = PublishSubject.create();

                TestObserverEx<Void> to = ps.ignoreElements()
                        .timeout(1, TimeUnit.MILLISECONDS, scheduler, Completable.complete())
                        .to(TestHelper.<Void>testConsumer());

                final TestException ex = new TestException();

                Runnable r1 = new Runnable() {
                    @Override
                    public void run() {
                        ps.onError(ex);
                    }
                };

                Runnable r2 = new Runnable() {
                    @Override
                    public void run() {
                        scheduler.advanceTimeBy(1, TimeUnit.MILLISECONDS);
                    }
                };

                TestHelper.race(r1, r2);

                to.assertTerminated();

                if (!errors.isEmpty()) {
                    TestHelper.assertUndeliverable(errors, 0, TestException.class);
                }

            } finally {
                RxJavaPlugins.reset();
            }
        }",loop_control
i,"for (int i = 0; i < TestHelper.RACE_DEFAULT_LOOPS; i++) {
            PublishSubject<Integer> ps = PublishSubject.create();

            final Completable c = ps.ignoreElements().cache();

            final TestObserver<Void> to1 = new TestObserver<>();

            final TestObserver<Void> to2 = new TestObserver<>();

            Runnable r1 = new Runnable() {
                @Override
                public void run() {
                    c.subscribe(to1);
                }
            };
            Runnable r2 = new Runnable() {
                @Override
                public void run() {
                    c.subscribe(to2);
                }
            };

            TestHelper.race(r1, r2);

            ps.onComplete();

            to1.assertResult();
            to2.assertResult();
        }",loop_control
i,"for (int i = 0; i < TestHelper.RACE_DEFAULT_LOOPS; i++) {
            PublishSubject<Integer> ps = PublishSubject.create();

            final Completable c = ps.ignoreElements().cache();

            final TestObserver<Void> to1 = c.test();

            final TestObserver<Void> to2 = new TestObserver<>();

            Runnable r1 = new Runnable() {
                @Override
                public void run() {
                    to1.dispose();
                }
            };
            Runnable r2 = new Runnable() {
                @Override
                public void run() {
                    c.subscribe(to2);
                }
            };

            TestHelper.race(r1, r2);

            ps.onComplete();

            to1.assertEmpty();
            to2.assertResult();
        }",loop_control
i,"for (int i = 0; i < TestHelper.RACE_DEFAULT_LOOPS; i++) {
            List<Throwable> errors = TestHelper.trackPluginErrors();

            try {
                final PublishProcessor<Integer> pp1 = PublishProcessor.create();
                final PublishProcessor<Integer> pp2 = PublishProcessor.create();

                TestObserver<Void> to = Completable.concat(pp1.map(new Function<Integer, Completable>() {
                    @Override
                    public Completable apply(Integer v) throws Exception {
                        return pp2.ignoreElements();
                    }
                })).test();

                pp1.onNext(1);

                final TestException ex = new TestException();

                Runnable r1 = new Runnable() {
                    @Override
                    public void run() {
                        pp1.onError(ex);
                    }
                };
                Runnable r2 = new Runnable() {
                    @Override
                    public void run() {
                        pp2.onError(ex);
                    }
                };

                TestHelper.race(r1, r2);

                to.assertFailure(TestException.class);

                if (!errors.isEmpty()) {
                    TestHelper.assertUndeliverable(errors, 0, TestException.class);
                }
            } finally {
                RxJavaPlugins.reset();
            }
        }",loop_control
i,"for (int i = 0; i < TestHelper.RACE_DEFAULT_LOOPS; i++) {

            final Completable c = Completable.concatArray(a);

            final TestObserver<Void> to = new TestObserver<>();

            Runnable r1 = new Runnable() {
                @Override
                public void run() {
                    c.subscribe(to);
                }
            };

            Runnable r2 = new Runnable() {
                @Override
                public void run() {
                    to.dispose();
                }
            };

            TestHelper.race(r1, r2);
        }",loop_control
i,"for (int i = 0; i < TestHelper.RACE_DEFAULT_LOOPS; i++) {

            final Completable c = Completable.concat(Arrays.asList(a));

            final TestObserver<Void> to = new TestObserver<>();

            Runnable r1 = new Runnable() {
                @Override
                public void run() {
                    c.subscribe(to);
                }
            };

            Runnable r2 = new Runnable() {
                @Override
                public void run() {
                    to.dispose();
                }
            };

            TestHelper.race(r1, r2);
        }",loop_control
k,"for (int k = 0; k < 100; k++) {
            final int count = 10;
            final CountDownLatch latch = new CountDownLatch(count);
            final boolean[] interrupted = { false };

            for (int i = 0; i < count; i++) {
                Completable c0 = Completable.fromAction(new Action() {
                    @Override
                    public void run() throws Exception {
                        try {
                            Thread.sleep(30);
                        } catch (InterruptedException e) {
                            System.out.println(""Interrupted! "" + Thread.currentThread());
                            interrupted[0] = true;
                        }
                    }
                });
                Completable.concat(Arrays.asList(Completable.complete()
                    .subscribeOn(Schedulers.io())
                    .observeOn(Schedulers.io()),
                    c0)
                )
                .subscribe(new Action() {
                    @Override
                    public void run() throws Exception {
                        latch.countDown();
                    }
                });
            }

            latch.await();
            assertFalse(""The second Completable was interrupted!"", interrupted[0]);
        }",loop_control
i,"for (int i = 0; i < count; i++) {
                Completable c0 = Completable.fromAction(new Action() {
                    @Override
                    public void run() throws Exception {
                        try {
                            Thread.sleep(30);
                        } catch (InterruptedException e) {
                            System.out.println(""Interrupted! "" + Thread.currentThread());
                            interrupted[0] = true;
                        }
                    }
                });
                Completable.concat(Arrays.asList(Completable.complete()
                    .subscribeOn(Schedulers.io())
                    .observeOn(Schedulers.io()),
                    c0)
                )
                .subscribe(new Action() {
                    @Override
                    public void run() throws Exception {
                        latch.countDown();
                    }
                });
            }",loop_control
i,"for (int i = 0; i < 32; i++) {
            ms.add(Completable.never());
        }",loop_control
i,"for (int i = 0; i < TestHelper.RACE_DEFAULT_LOOPS; i++) {
            List<Throwable> errors = TestHelper.trackPluginErrors();
            try {
                final PublishProcessor<Integer> pp0 = PublishProcessor.create();
                final PublishProcessor<Integer> pp1 = PublishProcessor.create();

                final TestObserver<Void> to = Completable.amb(Arrays.asList(pp0.ignoreElements(), pp1.ignoreElements()))
                .test();

                final TestException ex = new TestException();

                Runnable r1 = new Runnable() {
                    @Override
                    public void run() {
                        pp0.onError(ex);
                    }
                };

                Runnable r2 = new Runnable() {
                    @Override
                    public void run() {
                        pp1.onError(ex);
                    }
                };

                TestHelper.race(r1, r2);

                to.assertFailure(TestException.class);

                if (!errors.isEmpty()) {
                    TestHelper.assertUndeliverable(errors, 0, TestException.class);
                }
            } finally {
                RxJavaPlugins.reset();
            }
        }",loop_control
i,"for (int i = 0; i < TestHelper.RACE_DEFAULT_LOOPS; i++) {
            List<Throwable> errors = TestHelper.trackPluginErrors();

            try {

                final Subject<Integer> ps = ReplaySubject.create();
                ps.onNext(1);

                final Completable source = Completable.ambArray(ps.ignoreElements(), Completable.never(), Completable.never(), null);

                Runnable r1 = new Runnable() {
                    @Override
                    public void run() {
                        source.test();
                    }
                };

                Runnable r2 = new Runnable() {
                    @Override
                    public void run() {
                        ps.onComplete();
                    }
                };

                TestHelper.race(r1, r2);

                if (!errors.isEmpty()) {
                    TestHelper.assertError(errors, 0, NullPointerException.class);
                }
            } finally {
                RxJavaPlugins.reset();
            }
        }",loop_control
i,"for (int i = 0; i < TestHelper.RACE_LONG_LOOPS; i++) {
            final AtomicBoolean interrupted = new AtomicBoolean();
            final CountDownLatch cdl = new CountDownLatch(1);

            Completable.ambArray(
                    Completable.error(ex)
                    .subscribeOn(Schedulers.single())
                    .observeOn(Schedulers.computation()),
                    Completable.never()
            )
            .subscribe(Functions.EMPTY_ACTION, new Consumer<Throwable>() {
                @Override
                public void accept(Throwable e) throws Exception {
                    interrupted.set(Thread.currentThread().isInterrupted());
                    cdl.countDown();
                }
            });

            assertTrue(cdl.await(500, TimeUnit.SECONDS));
            assertFalse(""Interrupted!"", interrupted.get());
        }",loop_control
i,"for (int i = 0; i < TestHelper.RACE_LONG_LOOPS; i++) {
            final AtomicBoolean interrupted = new AtomicBoolean();
            final CountDownLatch cdl = new CountDownLatch(1);

            Completable.ambArray(
                Completable.complete()
                    .subscribeOn(Schedulers.single())
                    .observeOn(Schedulers.computation()),
                Completable.never()
            )
            .subscribe(new Action() {
                @Override
                public void run() throws Exception {
                    interrupted.set(Thread.currentThread().isInterrupted());
                    cdl.countDown();
                }
            });

            assertTrue(cdl.await(500, TimeUnit.SECONDS));
            assertFalse(""Interrupted!"", interrupted.get());
        }",loop_control
arg,"for (String arg : args) {
            list.add(arg);
        }",iterator
timeout,"{
        final AtomicBoolean cancel1 = new AtomicBoolean();
        Flowable.intervalRange(1, 1000, 1, 1, TimeUnit.MILLISECONDS)
        .doOnCancel(new Action() {
            @Override
            public void run() throws Exception {
                cancel1.set(true);
            }
        })
        .window(1, TimeUnit.MILLISECONDS, Schedulers.single(), 2, true)
        .flatMap(Functions.<Flowable<Long>>identity())
        .take(500)
        .to(TestHelper.<Long>testConsumer())
        .awaitDone(5, TimeUnit.SECONDS)
        .assertSubscribed()
        .assertValueCount(500)
        .assertNoErrors()
        .assertComplete();

        int timeout = 20;
        while (timeout-- > 0 && !cancel1.get()) {
            Thread.sleep(100);
        }

        assertTrue(""intervalRange was not cancelled!"", cancel1.get());
    }",loop_control
cancel1,"{
        final AtomicBoolean cancel1 = new AtomicBoolean();
        Flowable.intervalRange(1, 1000, 1, 1, TimeUnit.MILLISECONDS)
        .doOnCancel(new Action() {
            @Override
            public void run() throws Exception {
                cancel1.set(true);
            }
        })
        .window(1, TimeUnit.MILLISECONDS, Schedulers.single(), 2, true)
        .flatMap(Functions.<Flowable<Long>>identity())
        .take(500)
        .to(TestHelper.<Long>testConsumer())
        .awaitDone(5, TimeUnit.SECONDS)
        .assertSubscribed()
        .assertValueCount(500)
        .assertNoErrors()
        .assertComplete();

        int timeout = 20;
        while (timeout-- > 0 && !cancel1.get()) {
            Thread.sleep(100);
        }

        assertTrue(""intervalRange was not cancelled!"", cancel1.get());
    }",maybe_loop_control
i,"for (int i = 0; i < TestHelper.RACE_DEFAULT_LOOPS; i++) {
            TestScheduler scheduler = new TestScheduler();

            PublishProcessor<Integer> pp = PublishProcessor.create();

            TestSubscriber<Flowable<Integer>> ts = pp.window(1, TimeUnit.MINUTES, scheduler, 1)
            .test();

            TestHelper.race(
                    () -> pp.onNext(1),
                    () -> ts.cancel()
            );
        }",loop_control
mode,"for (BackpressureStrategy mode : BackpressureStrategy.values()) {
            Flowable.fromObservable(Observable.range(1, 5), mode)
            .test()
            .withTag(""mode: "" + mode)
            .assertResult(1, 2, 3, 4, 5);
        }",iterator
i,"for (int i = 1; i < 3; i++) {
            effectCounter.set(0);
            System.out.printf(""- %d -%n"", i);
            result.subscribe(new Consumer<Integer>() {

                @Override
                public void accept(Integer t1) {
                    System.out.println(t1);
                }

            }, new Consumer<Throwable>() {

                @Override
                public void accept(Throwable t1) {
                    t1.printStackTrace();
                }
            },
            new Action() {
                @Override
                public void run() {
                    System.out.println(""Done"");
                }
            });
            assertEquals(2, effectCounter.get());
        }",loop_control
i,"for (int i = 0; i < 1000; i++) {
            assertEquals((Integer)i, onNextEvents.get(i));
        }",loop_control
i,"for (int i = 0; i < 10; i++) {
            assertEquals((Integer)i, onNextEvents.get(i));
        }",loop_control
i,"for (int i = 0; i < 100; i++) {
            TestSubscriberEx<Integer> ts1 = new TestSubscriberEx<>();

            Flowable<Integer> cached = source.replay().autoConnect();

            cached.observeOn(Schedulers.computation()).subscribe(ts1);

            ts1.awaitDone(2, TimeUnit.SECONDS);
            ts1.assertNoErrors();
            ts1.assertTerminated();
            assertEquals(10000, ts1.values().size());

            TestSubscriberEx<Integer> ts2 = new TestSubscriberEx<>();
            cached.observeOn(Schedulers.computation()).subscribe(ts2);

            ts2.awaitDone(2, TimeUnit.SECONDS);
            ts2.assertNoErrors();
            ts2.assertTerminated();
            assertEquals(10000, ts2.values().size());
        }",loop_control
i,"for (int i = 0; i < 100; i++) {
            TestSubscriberEx<Long> ts = new TestSubscriberEx<>();
            list.add(ts);
            output.skip(i * 10).take(10).subscribe(ts);
        }",loop_control
i,"for (int i = 0; i < 10; i++) {
            expected.add((long)(i - 10));
        }",loop_control
i,"for (int i = j * 10; i < j * 10 + 10; i++) {
                expected.set(i - j * 10, (long)i);
            }",loop_control
ts,"for (int i = 0; i < 100; i++) {
            TestSubscriberEx<Long> ts = new TestSubscriberEx<>();
            list.add(ts);
            output.skip(i * 10).take(10).subscribe(ts);
        }",iterator
ts,"for (TestSubscriberEx<Long> ts : list) {
            ts.awaitDone(3, TimeUnit.SECONDS);
            ts.assertNoErrors();
            ts.assertTerminated();

            for (int i = j * 10; i < j * 10 + 10; i++) {
                expected.set(i - j * 10, (long)i);
            }

            ts.assertValueSequence(expected);

            j++;
        }",iterator
j,"{
        Flowable<Long> source = Flowable.interval(1, 1, TimeUnit.MILLISECONDS)
                .take(1000)
                .subscribeOn(Schedulers.io());
        Flowable<Long> cached = source.replay().autoConnect();

        Flowable<Long> output = cached.observeOn(Schedulers.computation(), false, 1024);

        List<TestSubscriberEx<Long>> list = new ArrayList<>(100);
        for (int i = 0; i < 100; i++) {
            TestSubscriberEx<Long> ts = new TestSubscriberEx<>();
            list.add(ts);
            output.skip(i * 10).take(10).subscribe(ts);
        }

        List<Long> expected = new ArrayList<>();
        for (int i = 0; i < 10; i++) {
            expected.add((long)(i - 10));
        }
        int j = 0;
        for (TestSubscriberEx<Long> ts : list) {
            ts.awaitDone(3, TimeUnit.SECONDS);
            ts.assertNoErrors();
            ts.assertTerminated();

            for (int i = j * 10; i < j * 10 + 10; i++) {
                expected.set(i - j * 10, (long)i);
            }

            ts.assertValueSequence(expected);

            j++;
        }
    }",maybe_loop_control
i,"for (int i = 0; i < m; i++) {
                    t.onNext(i);
                }",loop_control
i,"for (int i = 0; i < TestHelper.RACE_DEFAULT_LOOPS; i++) {
            final ConnectableFlowable<Integer> cf = Flowable.range(1, 3).replay();

            Runnable r = new Runnable() {
                @Override
                public void run() {
                    cf.connect();
                }
            };

            TestHelper.race(r, r);
        }",loop_control
i,"for (int i = 0; i < TestHelper.RACE_DEFAULT_LOOPS; i++) {
            final ConnectableFlowable<Integer> cf = Flowable.range(1, 3).replay();

            final TestSubscriber<Integer> ts1 = new TestSubscriber<>();
            final TestSubscriber<Integer> ts2 = new TestSubscriber<>();

            Runnable r1 = new Runnable() {
                @Override
                public void run() {
                    cf.subscribe(ts1);
                }
            };

            Runnable r2 = new Runnable() {
                @Override
                public void run() {
                    cf.subscribe(ts2);
                }
            };

            TestHelper.race(r1, r2);
        }",loop_control
i,"for (int i = 0; i < TestHelper.RACE_DEFAULT_LOOPS; i++) {
            final ConnectableFlowable<Integer> cf = Flowable.range(1, 3).replay();

            final TestSubscriber<Integer> ts1 = new TestSubscriber<>();
            final TestSubscriber<Integer> ts2 = new TestSubscriber<>();

            cf.subscribe(ts1);

            Runnable r1 = new Runnable() {
                @Override
                public void run() {
                    ts1.cancel();
                }
            };

            Runnable r2 = new Runnable() {
                @Override
                public void run() {
                    cf.subscribe(ts2);
                }
            };

            TestHelper.race(r1, r2);
        }",loop_control
i,"for (int i = 0; i < TestHelper.RACE_DEFAULT_LOOPS; i++) {
            final PublishProcessor<Integer> pp = PublishProcessor.create();

            final ConnectableFlowable<Integer> cf = pp.replay();

            final TestSubscriber<Integer> ts1 = new TestSubscriber<>();

            Runnable r1 = new Runnable() {
                @Override
                public void run() {
                    cf.subscribe(ts1);
                }
            };

            Runnable r2 = new Runnable() {
                @Override
                public void run() {
                    for (int j = 0; j < 1000; j++) {
                        pp.onNext(j);
                    }
                }
            };

            TestHelper.race(r1, r2);
        }",loop_control
i,"for (int i = 0; i < TestHelper.RACE_DEFAULT_LOOPS; i++) {
            final PublishProcessor<Integer> pp = PublishProcessor.create();

            final ConnectableFlowable<Integer> cf = pp.replay();

            final TestSubscriber<Integer> ts1 = new TestSubscriber<>();

            cf.subscribe(ts1);

            Runnable r1 = new Runnable() {
                @Override
                public void run() {
                    ts1.cancel();
                }
            };

            Runnable r2 = new Runnable() {
                @Override
                public void run() {
                    for (int j = 0; j < 1000; j++) {
                        pp.onNext(j);
                    }
                }
            };

            TestHelper.race(r1, r2);
        }",loop_control
j,"for (int j = 0; j < 1000; j++) {
                        pp.onNext(j);
                    }",loop_control
i,"for (int i = 0; i < TestHelper.RACE_DEFAULT_LOOPS; i++) {
            final ConnectableFlowable<Integer> cf = Flowable.range(1, 1000).replay();

            final TestSubscriber<Integer> ts1 = new TestSubscriber<>();

            cf.connect();

            Runnable r1 = new Runnable() {
                @Override
                public void run() {
                    cf.subscribe(ts1);
                }
            };

            Runnable r2 = new Runnable() {
                @Override
                public void run() {
                    ts1.cancel();
                }
            };

            TestHelper.race(r1, r2);
        }",loop_control
current,"for (Integer current : ts.values()) {
            Assert.assertTrue(""The sequence must be increasing [current value="" + previous +
                    "", previous value="" + current + ""]"", previous <= current);
            previous = current;
        }",iterator
i,"for (Long i : ts.values()) {
            sum += i;
        }",iterator
ts,"{
        final TestSubscriber<Object> ts = new TestSubscriber<>();
        final Subscriber[] s = { null };

        Schedulers.single().scheduleDirect(new Runnable() {
            @SuppressWarnings(""unchecked"")
            @Override
            public void run() {
                ts.cancel();
                s[0].onNext(1);
            }
        }, 200, TimeUnit.MILLISECONDS);

        new Flowable<Integer>() {
            @Override
            protected void subscribeActual(Subscriber<? super Integer> subscriber) {
                subscriber.onSubscribe(new BooleanSubscription());
                s[0] = subscriber;
            }
        }.blockingSubscribe(ts);

        while (!ts.isCancelled()) {
            Thread.sleep(100);
        }

        ts.assertEmpty();
    }",maybe_loop_control
i,"for (int i = 0; i < TestHelper.RACE_DEFAULT_LOOPS; i++) {
            final TestSubscriber<Integer> ts = new TestSubscriber<>();

            final PublishProcessor<Integer> pp = PublishProcessor.create();

            final Runnable r1 = new Runnable() {
                @Override
                public void run() {
                    ts.cancel();
                }
            };

            final Runnable r2 = new Runnable() {
                @Override
                public void run() {
                    pp.onNext(1);
                }
            };

            final AtomicInteger c = new AtomicInteger(2);

            Schedulers.computation().scheduleDirect(new Runnable() {
                @Override
                public void run() {
                    c.decrementAndGet();
                    while (c.get() != 0 && !pp.hasSubscribers()) { }

                    TestHelper.race(r1, r2);
                }
            });

            c.decrementAndGet();
            while (c.get() != 0) { }

            pp
            .blockingSubscribe(ts);
        }",loop_control
c,"for (int i = 0; i < TestHelper.RACE_DEFAULT_LOOPS; i++) {
            final TestSubscriber<Integer> ts = new TestSubscriber<>();

            final PublishProcessor<Integer> pp = PublishProcessor.create();

            final Runnable r1 = new Runnable() {
                @Override
                public void run() {
                    ts.cancel();
                }
            };

            final Runnable r2 = new Runnable() {
                @Override
                public void run() {
                    pp.onNext(1);
                }
            };

            final AtomicInteger c = new AtomicInteger(2);

            Schedulers.computation().scheduleDirect(new Runnable() {
                @Override
                public void run() {
                    c.decrementAndGet();
                    while (c.get() != 0 && !pp.hasSubscribers()) { }

                    TestHelper.race(r1, r2);
                }
            });

            c.decrementAndGet();
            while (c.get() != 0) { }

            pp
            .blockingSubscribe(ts);
        }",maybe_loop_control
pp,"for (int i = 0; i < TestHelper.RACE_DEFAULT_LOOPS; i++) {
            final TestSubscriber<Integer> ts = new TestSubscriber<>();

            final PublishProcessor<Integer> pp = PublishProcessor.create();

            final Runnable r1 = new Runnable() {
                @Override
                public void run() {
                    ts.cancel();
                }
            };

            final Runnable r2 = new Runnable() {
                @Override
                public void run() {
                    pp.onNext(1);
                }
            };

            final AtomicInteger c = new AtomicInteger(2);

            Schedulers.computation().scheduleDirect(new Runnable() {
                @Override
                public void run() {
                    c.decrementAndGet();
                    while (c.get() != 0 && !pp.hasSubscribers()) { }

                    TestHelper.race(r1, r2);
                }
            });

            c.decrementAndGet();
            while (c.get() != 0) { }

            pp
            .blockingSubscribe(ts);
        }",maybe_loop_control
c,"for (int i = 0; i < TestHelper.RACE_DEFAULT_LOOPS; i++) {
            final TestSubscriber<Integer> ts = new TestSubscriber<>();

            final PublishProcessor<Integer> pp = PublishProcessor.create();

            final Runnable r1 = new Runnable() {
                @Override
                public void run() {
                    ts.cancel();
                }
            };

            final Runnable r2 = new Runnable() {
                @Override
                public void run() {
                    pp.onNext(1);
                }
            };

            final AtomicInteger c = new AtomicInteger(2);

            Schedulers.computation().scheduleDirect(new Runnable() {
                @Override
                public void run() {
                    c.decrementAndGet();
                    while (c.get() != 0 && !pp.hasSubscribers()) { }

                    TestHelper.race(r1, r2);
                }
            });

            c.decrementAndGet();
            while (c.get() != 0) { }

            pp
            .blockingSubscribe(ts);
        }",maybe_loop_control
i,"for (int i = 0; i < n; i++) {
            Subscriber<Object> subscriber = TestHelper.mockSubscriber();
            InOrder inOrder = inOrder(subscriber);

            src.subscribe(subscriber);

            for (int j = 5; j < 10; j++) {
                inOrder.verify(subscriber).onNext(j);
            }
            inOrder.verify(subscriber).onComplete();
            verify(subscriber, never()).onError(any(Throwable.class));
        }",loop_control
j,"for (int j = 5; j < 10; j++) {
                inOrder.verify(subscriber).onNext(j);
            }",loop_control
s,"for (Scheduler s : new Scheduler[] { Schedulers.single(), Schedulers.computation(), Schedulers.newThread(), Schedulers.io(), Schedulers.from(exec) }) {
                final TestSubscriber<Boolean> ts = TestSubscriber.create();
                ts.withTag(s.getClass().getSimpleName());

                Flowable.<Boolean>create(new FlowableOnSubscribe<Boolean>() {
                    @Override
                    public void subscribe(FlowableEmitter<Boolean> emitter) throws Exception {
                      emitter.onNext(Thread.interrupted());
                      emitter.onComplete();
                    }
                }, BackpressureStrategy.MISSING)
                .delaySubscription(100, TimeUnit.MILLISECONDS, s)
                .subscribe(ts);

                ts.awaitDone(5, TimeUnit.SECONDS);
                ts.assertValue(false);
            }",iterator
i,"for (int i = 0; i < TestHelper.RACE_DEFAULT_LOOPS; i++) {
            final TestSubscriber<Integer> ts = Flowable.range(1, 10)
                    .take(5)
                    .test(0L);

            Runnable r = new Runnable() {
                @Override
                public void run() {
                    ts.request(3);
                }
            };

            TestHelper.race(r, r);

            ts.assertResult(1, 2, 3, 4, 5);
        }",loop_control
i,"for (int i = 0; i < TestHelper.RACE_LONG_LOOPS; i++) {

            final MulticastProcessor<Integer> mp = new MulticastProcessor<>(128, true);

            final MulticastSubscription<Integer> ms1 = new MulticastSubscription<>(null, mp);
            final MulticastSubscription<Integer> ms2 = new MulticastSubscription<>(null, mp);

            assertTrue(mp.add(ms1));

            Runnable r1 = new Runnable() {
                @Override
                public void run() {
                    mp.remove(ms1);
                }
            };

            Runnable r2 = new Runnable() {
                @Override
                public void run() {
                    mp.add(ms2);
                }
            };

            TestHelper.race(r1, r2);
        }",loop_control
i,"for (int i = 0; i < expectedCount; i++) {
            Flowable
                    .just(Boolean.TRUE, Boolean.FALSE)
                    .takeWhile(new Predicate<Boolean>() {
                        @Override
                        public boolean test(Boolean value) {
                            return value;
                        }
                    })
                    .toList()
                    .doOnSuccess(new Consumer<List<Boolean>>() {
                        @Override
                        public void accept(List<Boolean> booleans) {
                            count.incrementAndGet();
                        }
                    })
                    .subscribe();
        }",loop_control
i,"for (int i = 0; i < expectedCount; i++) {
            Flowable
                    .just(Boolean.TRUE, Boolean.FALSE, Boolean.FALSE)
                    .takeWhile(new Predicate<Boolean>() {
                        @Override
                        public boolean test(Boolean value) {
                            return value;
                        }
                    })
                    .toList()
                    .doOnSuccess(new Consumer<List<Boolean>>() {
                        @Override
                        public void accept(List<Boolean> booleans) {
                            count.incrementAndGet();
                        }
                    })
                    .subscribe();
        }",loop_control
value,"for (final String value : values) {
                    parentSubscription.add(innerScheduler.schedule(new Runnable() {
                        @Override
                        public void run() {
                            subscriber.onNext(value);
                        }
                    }
                    , delay, TimeUnit.MILLISECONDS));
                    delay += interval;
                }",iterator
i,"for (int i = 0; i < TestHelper.RACE_DEFAULT_LOOPS; i++) {
            final PublishProcessor<Integer> pp1 = PublishProcessor.create();
            final PublishProcessor<Integer> pp2 = PublishProcessor.create();

            TestSubscriberEx<Integer> ts = Flowable.ambArray(pp1, pp2).to(TestHelper.<Integer>testConsumer());

            Runnable r1 = new Runnable() {
                @Override
                public void run() {
                    pp1.onNext(1);
                }
            };
            Runnable r2 = new Runnable() {
                @Override
                public void run() {
                    pp2.onNext(1);
                }
            };

            TestHelper.race(r1, r2);

            ts.assertSubscribed().assertNoErrors()
            .assertNotComplete().assertValueCount(1);
        }",loop_control
i,"for (int i = 0; i < TestHelper.RACE_DEFAULT_LOOPS; i++) {
            final PublishProcessor<Integer> pp1 = PublishProcessor.create();
            final PublishProcessor<Integer> pp2 = PublishProcessor.create();

            TestSubscriber<Integer> ts = Flowable.ambArray(pp1, pp2).test();

            Runnable r1 = new Runnable() {
                @Override
                public void run() {
                    pp1.onComplete();
                }
            };
            Runnable r2 = new Runnable() {
                @Override
                public void run() {
                    pp2.onComplete();
                }
            };

            TestHelper.race(r1, r2);

            ts.assertResult();
        }",loop_control
i,"for (int i = 0; i < TestHelper.RACE_DEFAULT_LOOPS; i++) {
            final PublishProcessor<Integer> pp1 = PublishProcessor.create();
            final PublishProcessor<Integer> pp2 = PublishProcessor.create();

            TestSubscriber<Integer> ts = Flowable.ambArray(pp1, pp2).test();

            final Throwable ex = new TestException();

            Runnable r1 = new Runnable() {
                @Override
                public void run() {
                    pp1.onError(ex);
                }
            };
            Runnable r2 = new Runnable() {
                @Override
                public void run() {
                    pp2.onError(ex);
                }
            };

            List<Throwable> errors = TestHelper.trackPluginErrors();
            try {
                TestHelper.race(r1, r2);
            } finally {
                RxJavaPlugins.reset();
            }

            ts.assertFailure(TestException.class);
            if (!errors.isEmpty()) {
                TestHelper.assertUndeliverable(errors, 0, TestException.class);
            }
        }",loop_control
i,"for (int i = 0; i < TestHelper.RACE_LONG_LOOPS; i++) {
            final AtomicBoolean interrupted = new AtomicBoolean();
            final CountDownLatch cdl = new CountDownLatch(1);

            Flowable.ambArray(
                Flowable.just(1)
                    .subscribeOn(Schedulers.single())
                    .observeOn(Schedulers.computation()),
                Flowable.never()
            )
            .subscribe(new Consumer<Object>() {
                @Override
                public void accept(Object v) throws Exception {
                    interrupted.set(Thread.currentThread().isInterrupted());
                    cdl.countDown();
                }
            });

            assertTrue(cdl.await(500, TimeUnit.SECONDS));
            assertFalse(""Interrupted!"", interrupted.get());
        }",loop_control
i,"for (int i = 0; i < TestHelper.RACE_LONG_LOOPS; i++) {
            final AtomicBoolean interrupted = new AtomicBoolean();
            final CountDownLatch cdl = new CountDownLatch(1);

            Flowable.ambArray(
                Flowable.error(ex)
                    .subscribeOn(Schedulers.single())
                    .observeOn(Schedulers.computation()),
                Flowable.never()
            )
            .subscribe(Functions.emptyConsumer(), new Consumer<Throwable>() {
                @Override
                public void accept(Throwable e) throws Exception {
                    interrupted.set(Thread.currentThread().isInterrupted());
                    cdl.countDown();
                }
            });

            assertTrue(cdl.await(500, TimeUnit.SECONDS));
            assertFalse(""Interrupted!"", interrupted.get());
        }",loop_control
i,"for (int i = 0; i < TestHelper.RACE_LONG_LOOPS; i++) {
            final AtomicBoolean interrupted = new AtomicBoolean();
            final CountDownLatch cdl = new CountDownLatch(1);

            Flowable.ambArray(
                Flowable.empty()
                    .subscribeOn(Schedulers.single())
                    .observeOn(Schedulers.computation()),
                Flowable.never()
            )
            .subscribe(Functions.emptyConsumer(), Functions.emptyConsumer(), new Action() {
                @Override
                public void run() throws Exception {
                    interrupted.set(Thread.currentThread().isInterrupted());
                    cdl.countDown();
                }
            });

            assertTrue(cdl.await(500, TimeUnit.SECONDS));
            assertFalse(""Interrupted!"", interrupted.get());
        }",loop_control
i,"for (int i = 0; i < TestHelper.RACE_DEFAULT_LOOPS; i++) {
            final TestScheduler scheduler = new TestScheduler();

            final PublishProcessor<Integer> pp = PublishProcessor.create();

            TestSubscriber<Integer> ts = pp.sample(1, TimeUnit.SECONDS, scheduler, true)
            .test();

            pp.onNext(1);

            Runnable r1 = new Runnable() {
                @Override
                public void run() {
                    pp.onComplete();
                }
            };

            Runnable r2 = new Runnable() {
                @Override
                public void run() {
                    scheduler.advanceTimeBy(1, TimeUnit.SECONDS);
                }
            };

            TestHelper.race(r1, r2);

            ts.assertResult(1);
        }",loop_control
i,"for (int i = 0; i < TestHelper.RACE_DEFAULT_LOOPS; i++) {
            final PublishProcessor<Integer> pp = PublishProcessor.create();
            final PublishProcessor<Integer> sampler = PublishProcessor.create();

            TestSubscriber<Integer> ts = pp.sample(sampler, true)
            .test();

            pp.onNext(1);

            Runnable r1 = new Runnable() {
                @Override
                public void run() {
                    pp.onComplete();
                }
            };

            Runnable r2 = new Runnable() {
                @Override
                public void run() {
                    sampler.onNext(1);
                }
            };

            TestHelper.race(r1, r2);

            ts.assertResult(1);
        }",loop_control
i,"for (int i = 0; i < TestHelper.RACE_DEFAULT_LOOPS; i++) {
            final PublishProcessor<Integer> pp = PublishProcessor.create();
            final PublishProcessor<Integer> sampler = PublishProcessor.create();

            TestSubscriber<Integer> ts = pp.sample(sampler, true).test();

            pp.onNext(1);

            Runnable r1 = new Runnable() {
                @Override
                public void run() {
                    pp.onComplete();
                }
            };

            Runnable r2 = new Runnable() {
                @Override
                public void run() {
                    sampler.onComplete();
                }
            };

            TestHelper.race(r1, r2);

            ts.assertResult(1);
        }",loop_control
i,"for (int i = 0; i < 10000; i++) {
            final PublishProcessor<Integer> pp = PublishProcessor.create();
            final SingleSubject<Integer> cs = SingleSubject.create();

            TestSubscriber<Integer> ts = pp.mergeWith(cs).test();

            Runnable r1 = new Runnable() {
                @Override
                public void run() {
                    pp.onNext(1);
                    pp.onComplete();
                }
            };

            Runnable r2 = new Runnable() {
                @Override
                public void run() {
                    cs.onSuccess(1);
                }
            };

            TestHelper.race(r1, r2);

            ts.assertResult(1, 1);
        }",loop_control
i,"for (int i = 0; i < 10000; i++) {
            final PublishProcessor<Integer> pp = PublishProcessor.create();
            final SingleSubject<Integer> cs = SingleSubject.create();

            final TestSubscriber<Integer> ts = pp.mergeWith(cs).subscribeWith(new TestSubscriber<>(0));

            Runnable r1 = new Runnable() {
                @Override
                public void run() {
                    cs.onSuccess(1);
                }
            };

            Runnable r2 = new Runnable() {
                @Override
                public void run() {
                    ts.request(2);
                }
            };

            TestHelper.race(r1, r2);

            pp.onNext(2);
            pp.onComplete();

            ts.assertResult(1, 2);
        }",loop_control
i,"for (int i = 0; i < 10000; i++) {
            final PublishProcessor<Integer> pp = PublishProcessor.create();
            final SingleSubject<Integer> cs = SingleSubject.create();

            final TestSubscriber<Integer> ts = pp.mergeWith(cs).test(0);

            pp.onNext(0);

            Runnable r1 = new Runnable() {
                @Override
                public void run() {
                    pp.onNext(1);
                }
            };

            Runnable r2 = new Runnable() {
                @Override
                public void run() {
                    ts.request(3);
                }
            };

            TestHelper.race(r1, r2);

            cs.onSuccess(1);
            pp.onComplete();

            ts.assertResult(0, 1, 1);
        }",loop_control
i,"for (int i = 0; i < Flowable.bufferSize() - 1; i++) {
                        pp.onNext(i + 2);
                    }",loop_control
timeout,"{
            final CountDownLatch cdl1 = new CountDownLatch(1);
            final CountDownLatch cdl2 = new CountDownLatch(1);

            TestSubscriber<Object> ts = Flowable.fromCompletable(Completable.fromAction(new Action() {
                @Override
                public void run() throws Exception {
                    cdl1.countDown();
                    cdl2.await(5, TimeUnit.SECONDS);
                }
            }))
            .subscribeOn(Schedulers.single()).test();

            assertTrue(cdl1.await(5, TimeUnit.SECONDS));

            ts.cancel();

            int timeout = 10;

            while (timeout-- > 0 && errors.isEmpty()) {
                Thread.sleep(100);
            }

            TestHelper.assertUndeliverable(errors, 0, InterruptedException.class);
        }",loop_control
errors,"{
        List<Throwable> errors = TestHelper.trackPluginErrors();
        try {
            final CountDownLatch cdl1 = new CountDownLatch(1);
            final CountDownLatch cdl2 = new CountDownLatch(1);

            TestSubscriber<Object> ts = Flowable.fromCompletable(Completable.fromAction(new Action() {
                @Override
                public void run() throws Exception {
                    cdl1.countDown();
                    cdl2.await(5, TimeUnit.SECONDS);
                }
            }))
            .subscribeOn(Schedulers.single()).test();

            assertTrue(cdl1.await(5, TimeUnit.SECONDS));

            ts.cancel();

            int timeout = 10;

            while (timeout-- > 0 && errors.isEmpty()) {
                Thread.sleep(100);
            }

            TestHelper.assertUndeliverable(errors, 0, InterruptedException.class);
        } finally {
            RxJavaPlugins.reset();
        }
    }",maybe_loop_control
i,"for (int i = 0; i < n; i++) {
            PublishProcessor<Integer> delay = PublishProcessor.create();
            delays.add(delay);
        }",loop_control
i,"for (int i = 0; i < n; i++) {
            source.onNext(i);
            delays.get(i).onNext(i);
            inOrder.verify(subscriber).onNext(i);
        }",loop_control
i,"for (int i = 0; i < n; i++) {
            subjects.add(PublishProcessor.<Integer> create());
        }",loop_control
i,"for (int i = 0; i < n; i++) {
            source.onNext(i);
        }",loop_control
i,"for (int i = n - 1; i >= 0; i--) {
            subjects.get(i).onComplete();
            inOrder.verify(subscriber).onNext(i);
        }",loop_control
i,"for (int i = 0; i < n; i++) {
            array[i] = i;
        }",loop_control
i,"for (int i = 0; i < TestHelper.RACE_DEFAULT_LOOPS; i++) {
            PublishProcessor<Flowable<Integer>> source = PublishProcessor.create();

            TestSubscriber<Integer> ts = source
                    .concatMap(v -> v, n + 1)
                    .test(1L);

            TestHelper.race(() -> {
                for (int j = 0; j < n; j++) {
                    source.onNext(just);
                }
            }, () -> {
                for (int j = 0; j < n; j++) {
                    ts.request(1);
                }
            });

            ts.assertValueCount(n);
        }",loop_control
j,"for (int j = 0; j < n; j++) {
                    source.onNext(just);
                }",loop_control
j,"for (int j = 0; j < n; j++) {
                    ts.request(1);
                }",loop_control
i,"for (int i = 0; i < TestHelper.RACE_DEFAULT_LOOPS; i++) {
            PublishProcessor<Flowable<Integer>> source = PublishProcessor.create();

            TestSubscriber<Integer> ts = source
                    .concatMapDelayError(v -> v, true, n + 1)
                    .test(1L);

            TestHelper.race(() -> {
                for (int j = 0; j < n; j++) {
                    source.onNext(just);
                }
            }, () -> {
                for (int j = 0; j < n; j++) {
                    ts.request(1);
                }
            });

            ts.assertValueCount(n);
        }",loop_control
j,"for (int j = 0; j < n; j++) {
                    source.onNext(just);
                }",loop_control
j,"for (int j = 0; j < n; j++) {
                    ts.request(1);
                }",loop_control
i,"for (int i = 0; i < 10000; i++) {
            final PublishProcessor<Integer> pp = PublishProcessor.create();
            final MaybeSubject<Integer> cs = MaybeSubject.create();

            TestSubscriber<Integer> ts = pp.mergeWith(cs).test();

            Runnable r1 = new Runnable() {
                @Override
                public void run() {
                    pp.onNext(1);
                    pp.onComplete();
                }
            };

            Runnable r2 = new Runnable() {
                @Override
                public void run() {
                    cs.onSuccess(1);
                }
            };

            TestHelper.race(r1, r2);

            ts.assertResult(1, 1);
        }",loop_control
i,"for (int i = 0; i < 10000; i++) {
            final PublishProcessor<Integer> pp = PublishProcessor.create();
            final MaybeSubject<Integer> cs = MaybeSubject.create();

            final TestSubscriber<Integer> ts = pp.mergeWith(cs).subscribeWith(new TestSubscriber<>(0));

            Runnable r1 = new Runnable() {
                @Override
                public void run() {
                    cs.onSuccess(1);
                }
            };

            Runnable r2 = new Runnable() {
                @Override
                public void run() {
                    ts.request(2);
                }
            };

            TestHelper.race(r1, r2);

            pp.onNext(2);
            pp.onComplete();

            ts.assertResult(1, 2);
        }",loop_control
i,"for (int i = 0; i < 10000; i++) {
            final PublishProcessor<Integer> pp = PublishProcessor.create();
            final MaybeSubject<Integer> cs = MaybeSubject.create();

            final TestSubscriber<Integer> ts = pp.mergeWith(cs).test(0);

            pp.onNext(0);

            Runnable r1 = new Runnable() {
                @Override
                public void run() {
                    pp.onNext(1);
                }
            };

            Runnable r2 = new Runnable() {
                @Override
                public void run() {
                    ts.request(3);
                }
            };

            TestHelper.race(r1, r2);

            cs.onSuccess(1);
            pp.onComplete();

            ts.assertResult(0, 1, 1);
        }",loop_control
i,"for (int i = 0; i < Flowable.bufferSize() - 1; i++) {
                        pp.onNext(i + 2);
                    }",loop_control
i,"for (int i = 1; i <= Flowable.bufferSize() * 2 + 1; i++) {
            list.add(i);
        }",loop_control
i,"for (int i = 0; i < 100; i++) {
            list.add(i + start);
            ts.request(1);
        }",loop_control
i,"for (int i = 0; i < 100; i++) {
            list.add(i + start);
        }",loop_control
i,"for (int i = 0; i < 100; i++) {
            withBackpressureOneByOne(i);
        }",loop_control
i,"for (int i = 0; i < 100; i++) {
            withBackpressureAllAtOnce(i);
        }",loop_control
i,"for (int i = 0; i < 100; i++) {
            list.add(i + 50);
        }",loop_control
i,"for (int i = 1; i <= 5; i++) {
                    if (bs.isCancelled()) {
                        break;
                    }
                    numEmitted.incrementAndGet();
                    subscriber.onNext(i);
                    Thread.yield();
                }",loop_control
bs,"{
                BooleanSubscription bs = new BooleanSubscription();
                subscriber.onSubscribe(bs);
                for (int i = 1; i <= 5; i++) {
                    if (bs.isCancelled()) {
                        break;
                    }
                    numEmitted.incrementAndGet();
                    subscriber.onNext(i);
                    Thread.yield();
                }
                subscriber.onComplete();
            }",break_loop_control
bs,"{
                final BooleanSubscription bs = new BooleanSubscription();
                subscriber.onSubscribe(bs);
                Thread t = new Thread(new Runnable() {

                    @Override
                    public void run() {
                        System.out.println(""-------> subscribe to infinite sequence"");
                        System.out.println(""Starting thread: "" + Thread.currentThread());
                        int i = 1;
                        while (!bs.isCancelled()) {
                            subscriber.onNext(i++);
                            Thread.yield();
                        }
                        subscriber.onComplete();
                        latch.countDown();
                        System.out.println(""Ending thread: "" + Thread.currentThread());
                    }
                });
                t.start();

            }",maybe_loop_control
i,"for (int i = 0; i < 1026; i++) {
            expected.add(i * 3);
        }",loop_control
i,"{
        long startTime = System.currentTimeMillis();
        Flowable<Integer> src = Flowable.just(1).subscribeOn(Schedulers.computation());

        // now try and generate a hang by zipping src with itself repeatedly. A
        // time limit of 9 seconds ( 1 second less than the test timeout) is
        // used so that this test will not timeout on slow machines.
        int i = 0;
        while (System.currentTimeMillis() - startTime < 9000 && i++ < 100000) {
            int value = Flowable.zip(src, src, new BiFunction<Integer, Integer, Integer>() {
                @Override
                public Integer apply(Integer t1, Integer t2) {
                    return t1 + t2 * 10;
                }
            }).blockingSingle(0);

            Assert.assertEquals(11, value);
        }
    }",loop_control
j,"for (int j = 0; j < i; j++) {
                b.append('1');
            }",loop_control
j,"for (int j = 0; j < params.length; j++) {
                Object[] params0 = params.clone();
                params0[j] = null;

                try {
                    m.invoke(null, params0);
                    fail(""Should have thrown @ "" + m);
                } catch (InvocationTargetException ex) {
                    assertTrue(ex.toString(), ex.getCause() instanceof NullPointerException);

                    if (j < i) {
                        assertEquals(""source"" + (j + 1) + "" is null"", ex.getCause().getMessage());
                    } else {
                        assertEquals(""zipper is null"", ex.getCause().getMessage());
                    }
                }
            }",loop_control
i,"for (int i = 2; i < 10; i++) {
            Class<?>[] types = new Class[i + 1];
            Arrays.fill(types, Publisher.class);
            types[i] = i == 2 ? BiFunction.class : Class.forName(""io.reactivex.rxjava3.functions.Function"" + i);

            Method m = Flowable.class.getMethod(""zip"", types);

            Object[] params = new Object[i + 1];
            Arrays.fill(params, source);
            params[i] = ArgsToString.INSTANCE;

            StringBuilder b = new StringBuilder();
            for (int j = 0; j < i; j++) {
                b.append('1');
            }

            ((Flowable)m.invoke(null, params)).test().assertResult(b.toString());

            for (int j = 0; j < params.length; j++) {
                Object[] params0 = params.clone();
                params0[j] = null;

                try {
                    m.invoke(null, params0);
                    fail(""Should have thrown @ "" + m);
                } catch (InvocationTargetException ex) {
                    assertTrue(ex.toString(), ex.getCause() instanceof NullPointerException);

                    if (j < i) {
                        assertEquals(""source"" + (j + 1) + "" is null"", ex.getCause().getMessage());
                    } else {
                        assertEquals(""zipper is null"", ex.getCause().getMessage());
                    }
                }
            }
        }",loop_control
i,"for (int i = 0; i < 500; i++) {
            TestSubscriber<List<Object>> ts = Flowable.zip(
                    Flowable.just(1).observeOn(Schedulers.single()).map(new Function<Integer, Object>() {
                        @Override
                        public Object apply(Integer v) throws Exception {
                            return Thread.currentThread().getName().substring(0, 4);
                        }
                    }),
                    Flowable.just(1).observeOn(Schedulers.computation()).map(new Function<Integer, Object>() {
                        @Override
                        public Object apply(Integer v) throws Exception {
                            return Thread.currentThread().getName().substring(0, 4);
                        }
                    }),
                    new BiFunction<Object, Object, List<Object>>() {
                        @Override
                        public List<Object> apply(Object t1, Object t2) throws Exception {
                            return Arrays.asList(t1, t2);
                        }
                    }
            )
            .test()
            .awaitDone(5, TimeUnit.SECONDS)
            .assertValueCount(1);

            List<Object> list = ts.values().get(0);

            assertTrue(list.toString(), list.contains(""RxSi""));
            assertTrue(list.toString(), list.contains(""RxCo""));
        }",loop_control
r2,"{
        PublishProcessor<String> r1 = PublishProcessor.create();
        /* define a Subscriber to receive aggregated events */
        Subscriber<String> subscriber = TestHelper.mockSubscriber();
        InOrder io = inOrder(subscriber);

        Iterable<String> r2 = new Iterable<String>() {

            @Override
            public Iterator<String> iterator() {
                return new Iterator<String>() {
                    int count;

                    @Override
                    public boolean hasNext() {
                        if (count == 0) {
                            return true;
                        }
                        throw new TestException();
                    }

                    @Override
                    public String next() {
                        count++;
                        return ""1"";
                    }

                    @Override
                    public void remove() {
                        throw new UnsupportedOperationException(""Not supported yet."");
                    }

                };
            }

        };

        r1.zipWith(r2, zipr2).subscribe(subscriber);

        r1.onNext(""one-"");
        r1.onError(new TestException());

        io.verify(subscriber).onNext(""one-1"");
        io.verify(subscriber).onError(any(TestException.class));

        verify(subscriber, never()).onComplete();

    }",iterator
s,"for (String s : valuesToReturn) {
                        if (s == null) {
                            System.out.println(""throwing exception"");
                            try {
                                Thread.sleep(100);
                            } catch (Throwable e) {

                            }
                            subscriber.onError(new NullPointerException());
                            return;
                        } else {
                            subscriber.onNext(s);
                        }
                    }",iterator
timeout,"{
            final CountDownLatch cdl1 = new CountDownLatch(1);
            final CountDownLatch cdl2 = new CountDownLatch(1);

            TestSubscriber<Object> ts = Flowable.fromRunnable(new Runnable() {
                @Override
                public void run() {
                    cdl1.countDown();
                    try {
                        cdl2.await(5, TimeUnit.SECONDS);
                    } catch (InterruptedException e) {
                        e.printStackTrace();
                        throw new TestException(e);
                    }
                }
            }).subscribeOn(Schedulers.single()).test();

            assertTrue(cdl1.await(5, TimeUnit.SECONDS));

            ts.cancel();

            int timeout = 10;

            while (timeout-- > 0 && errors.isEmpty()) {
                Thread.sleep(100);
            }

            TestHelper.assertUndeliverable(errors, 0, TestException.class);
        }",loop_control
errors,"{
        List<Throwable> errors = TestHelper.trackPluginErrors();
        try {
            final CountDownLatch cdl1 = new CountDownLatch(1);
            final CountDownLatch cdl2 = new CountDownLatch(1);

            TestSubscriber<Object> ts = Flowable.fromRunnable(new Runnable() {
                @Override
                public void run() {
                    cdl1.countDown();
                    try {
                        cdl2.await(5, TimeUnit.SECONDS);
                    } catch (InterruptedException e) {
                        e.printStackTrace();
                        throw new TestException(e);
                    }
                }
            }).subscribeOn(Schedulers.single()).test();

            assertTrue(cdl1.await(5, TimeUnit.SECONDS));

            ts.cancel();

            int timeout = 10;

            while (timeout-- > 0 && errors.isEmpty()) {
                Thread.sleep(100);
            }

            TestHelper.assertUndeliverable(errors, 0, TestException.class);
        } finally {
            RxJavaPlugins.reset();
        }
    }",maybe_loop_control
i,"for (int i = 0; i < TestHelper.RACE_DEFAULT_LOOPS; i++) {
            final TestSubscriber<Long> ts = new TestSubscriber<>();

            final TestScheduler scheduler = new TestScheduler();

            Flowable.timer(1, TimeUnit.SECONDS, scheduler)
            .subscribe(ts);

            Runnable r1 = new Runnable() {
                @Override
                public void run() {
                    scheduler.advanceTimeBy(1, TimeUnit.SECONDS);
                }
            };

            Runnable r2 = new Runnable() {
                @Override
                public void run() {
                    ts.cancel();
                }
            };

            TestHelper.race(r1, r2);
        }",loop_control
i,"for (int i = 0; i < 1000; i++) {
                Flowable.timer(0, TimeUnit.MILLISECONDS).blockingFirst();
            }",loop_control
s,"for (Scheduler s : new Scheduler[] { Schedulers.single(), Schedulers.computation(), Schedulers.newThread(), Schedulers.io(), Schedulers.from(exec, true) }) {
                final AtomicBoolean interrupted = new AtomicBoolean();
                TestSubscriber<Long> ts = Flowable.timer(1, TimeUnit.MILLISECONDS, s)
                .map(new Function<Long, Long>() {
                    @Override
                    public Long apply(Long v) throws Exception {
                        try {
                        Thread.sleep(3000);
                        } catch (InterruptedException ex) {
                            interrupted.set(true);
                        }
                        return v;
                    }
                })
                .test();

                Thread.sleep(500);

                ts.cancel();

                Thread.sleep(500);

                assertTrue(s.getClass().getSimpleName(), interrupted.get());
            }",iterator
it,"{
        TestScheduler scheduler = new TestScheduler();

        Flowable<Long> source = Flowable.interval(1, TimeUnit.SECONDS, scheduler).take(10);

        Iterable<Long> iter = source.blockingLatest();

        Iterator<Long> it = iter.iterator();

        // only 9 because take(10) will immediately call onComplete when receiving the 10th item
        // which onComplete will overwrite the previous value
        for (int i = 0; i < 9; i++) {
            scheduler.advanceTimeBy(1, TimeUnit.SECONDS);

            Assert.assertTrue(it.hasNext());

            Assert.assertEquals(Long.valueOf(i), it.next());
        }

        scheduler.advanceTimeBy(1, TimeUnit.SECONDS);
        Assert.assertFalse(it.hasNext());
    }",iterator
j,"for (int j = 0; j < 3; j++) {
            Iterator<Long> it = iter.iterator();

            // only 9 because take(10) will immediately call onComplete when receiving the 10th item
            // which onComplete will overwrite the previous value
            for (int i = 0; i < 9; i++) {
                scheduler.advanceTimeBy(1, TimeUnit.SECONDS);

                Assert.assertTrue(it.hasNext());

                Assert.assertEquals(Long.valueOf(i), it.next());
            }

            scheduler.advanceTimeBy(1, TimeUnit.SECONDS);
            Assert.assertFalse(it.hasNext());
        }",loop_control
i,"for (int i = 0; i < 9; i++) {
                scheduler.advanceTimeBy(1, TimeUnit.SECONDS);

                Assert.assertTrue(it.hasNext());

                Assert.assertEquals(Long.valueOf(i), it.next());
            }",loop_control
it,"for (int j = 0; j < 3; j++) {
            Iterator<Long> it = iter.iterator();

            // only 9 because take(10) will immediately call onComplete when receiving the 10th item
            // which onComplete will overwrite the previous value
            for (int i = 0; i < 9; i++) {
                scheduler.advanceTimeBy(1, TimeUnit.SECONDS);

                Assert.assertTrue(it.hasNext());

                Assert.assertEquals(Long.valueOf(i), it.next());
            }

            scheduler.advanceTimeBy(1, TimeUnit.SECONDS);
            Assert.assertFalse(it.hasNext());
        }",iterator
it,"{
        Flowable<Long> source = Flowable.<Long> empty();

        Iterable<Long> iter = source.blockingLatest();

        Iterator<Long> it = iter.iterator();

        Assert.assertFalse(it.hasNext());

        it.next();
    }",iterator
i,"for (int i = 0; i < 10; i++) {
            scheduler.advanceTimeBy(1, TimeUnit.SECONDS);

            Assert.assertEquals(Long.valueOf(i), it.next());
        }",loop_control
it,"{
        TestScheduler scheduler = new TestScheduler();

        Flowable<Long> source = Flowable.interval(1, TimeUnit.SECONDS, scheduler).take(10);

        Iterable<Long> iter = source.blockingLatest();

        Iterator<Long> it = iter.iterator();

        // only 9 because take(10) will immediately call onComplete when receiving the 10th item
        // which onComplete will overwrite the previous value
        for (int i = 0; i < 10; i++) {
            scheduler.advanceTimeBy(1, TimeUnit.SECONDS);

            Assert.assertEquals(Long.valueOf(i), it.next());
        }
    }",iterator
it,"{
        TestScheduler scheduler = new TestScheduler();

        Flowable<Long> source = Flowable.<Long> error(new RuntimeException(""Forced failure!"")).subscribeOn(scheduler);

        Iterable<Long> iter = source.blockingLatest();

        Iterator<Long> it = iter.iterator();

        scheduler.advanceTimeBy(1, TimeUnit.SECONDS);

        it.hasNext();
    }",iterator
it,"{
        TestScheduler scheduler = new TestScheduler();

        Flowable<Long> source = Flowable.<Long> error(new RuntimeException(""Forced failure!"")).subscribeOn(scheduler);

        Iterable<Long> iter = source.blockingLatest();
        Iterator<Long> it = iter.iterator();

        scheduler.advanceTimeBy(1, TimeUnit.SECONDS);

        it.next();
    }",iterator
it,"{
        PublishProcessor<Integer> source = PublishProcessor.create();
        Flowable<Integer> blocker = source;

        Iterable<Integer> iter = blocker.blockingLatest();
        Iterator<Integer> it = iter.iterator();

        source.onNext(1);

        Assert.assertEquals(Integer.valueOf(1), it.next());

        source.onNext(2);
        source.onNext(3);

        Assert.assertEquals(Integer.valueOf(3), it.next());

        source.onNext(4);
        source.onNext(5);
        source.onNext(6);

        Assert.assertEquals(Integer.valueOf(6), it.next());

        source.onNext(7);
        source.onComplete();

        Assert.assertFalse(it.hasNext());
    }",iterator
it,"{
        Iterator<Object> it = Flowable.never().blockingLatest().iterator();

        Thread.currentThread().interrupt();

        try {
            it.hasNext();
        } catch (RuntimeException ex) {
            assertTrue(ex.toString(), ex.getCause() instanceof InterruptedException);
        }
        Thread.interrupted();
    }",iterator
it,"{
        Iterator<Object> it = Flowable.error(new TestException()).blockingLatest().iterator();

        for (int i = 0; i < 3; i++) {
            try {
                it.hasNext();
                fail(""Should have thrown"");
            } catch (TestException ex) {
                // expected
            }
        }
    }",iterator
i,"for (int i = 0; i < 3; i++) {
            try {
                it.hasNext();
                fail(""Should have thrown"");
            } catch (TestException ex) {
                // expected
            }
        }",loop_control
it,"{
        Iterator<Object> it = Flowable.never().blockingLatest().iterator();

        List<Throwable> errors = TestHelper.trackPluginErrors();
        try {
            ((Subscriber<Object>)it).onError(new TestException());

            TestHelper.assertUndeliverable(errors, 0, TestException.class);
        } finally {
            RxJavaPlugins.reset();
        }
    }",iterator
t,"for (Throwable t : ts.errors()) {
                t.printStackTrace();
            }",iterator
i,"for (int i = 0; i < Flowable.bufferSize() + 10; i++) {
                    subscriber.onNext(i);
                }",loop_control
i,"for (int i = 0; i < 50; i++) {
            final PublishProcessor<Long> processor = PublishProcessor.create();

            final AtomicLong counter = new AtomicLong();
            TestSubscriberEx<Long> ts = new TestSubscriberEx<>(new DefaultSubscriber<Long>() {

                @Override
                public void onComplete() {

                }

                @Override
                public void onError(Throwable e) {

                }

                @Override
                public void onNext(Long t) {
                    // simulate slow consumer to force backpressure failure
                    try {
                        Thread.sleep(1);
                    } catch (InterruptedException e) {
                    }
                }

            });
            processor.observeOn(Schedulers.computation()).subscribe(ts);

            // this will blow up with backpressure
            while (counter.get() < 102400) {
                processor.onNext(counter.get());
                counter.incrementAndGet();
            }

            ts.awaitDone(5, TimeUnit.SECONDS);
            assertEquals(1, ts.errors().size());
            ts.assertError(MissingBackpressureException.class);
            // assert that the values are sequential, that cutting in didn't allow skipping some but emitting others.
            // example [0, 1, 2] not [0, 1, 4]
            List<Long> onNextEvents = ts.values();
            assertTrue(onNextEvents.isEmpty() || onNextEvents.size() == onNextEvents.get(onNextEvents.size() - 1) + 1);
            // we should emit the error without emitting the full buffer size
            assertTrue(onNextEvents.size() < Flowable.bufferSize());
        }",loop_control
counter,"for (int i = 0; i < 50; i++) {
            final PublishProcessor<Long> processor = PublishProcessor.create();

            final AtomicLong counter = new AtomicLong();
            TestSubscriberEx<Long> ts = new TestSubscriberEx<>(new DefaultSubscriber<Long>() {

                @Override
                public void onComplete() {

                }

                @Override
                public void onError(Throwable e) {

                }

                @Override
                public void onNext(Long t) {
                    // simulate slow consumer to force backpressure failure
                    try {
                        Thread.sleep(1);
                    } catch (InterruptedException e) {
                    }
                }

            });
            processor.observeOn(Schedulers.computation()).subscribe(ts);

            // this will blow up with backpressure
            while (counter.get() < 102400) {
                processor.onNext(counter.get());
                counter.incrementAndGet();
            }

            ts.awaitDone(5, TimeUnit.SECONDS);
            assertEquals(1, ts.errors().size());
            ts.assertError(MissingBackpressureException.class);
            // assert that the values are sequential, that cutting in didn't allow skipping some but emitting others.
            // example [0, 1, 2] not [0, 1, 4]
            List<Long> onNextEvents = ts.values();
            assertTrue(onNextEvents.isEmpty() || onNextEvents.size() == onNextEvents.get(onNextEvents.size() - 1) + 1);
            // we should emit the error without emitting the full buffer size
            assertTrue(onNextEvents.size() < Flowable.bufferSize());
        }",maybe_loop_control
i,"for (int i = 1; i <= 1024; i = i * 2) {
            TestSubscriber<Integer> ts = TestSubscriber.create();

            Flowable.range(1, 1000 * 1000).observeOn(Schedulers.computation(), false, i)
            .subscribe(ts);

            ts.awaitDone(5, TimeUnit.SECONDS);
            ts.assertValueCount(1000 * 1000);
            ts.assertComplete();
            ts.assertNoErrors();
        }",loop_control
i,"for (int i = 0; i < TestHelper.RACE_DEFAULT_LOOPS; i++) {
            final TestSubscriberEx<Integer> ts = new TestSubscriberEx<Integer>().setInitialFusionMode(QueueFuseable.ANY);

            final TestScheduler scheduler = new TestScheduler();

            Flowable.just(1).hide()
            .observeOn(scheduler)
            .filter(Functions.alwaysTrue())
            .subscribe(ts);

            Runnable r1 = new Runnable() {
                @Override
                public void run() {
                    ts.cancel();
                }
            };

            Runnable r2 = new Runnable() {
                @Override
                public void run() {
                    scheduler.triggerActions();
                }
            };

            TestHelper.race(r1, r2);

            ts.assertFusionMode(QueueFuseable.ASYNC);

            if (ts.values().size() != 0) {
                ts.assertResult(1);
            }
        }",loop_control
j,"for (int j = 0; j < TestHelper.RACE_LONG_LOOPS; j++) {
            List<Throwable> errors = TestHelper.trackPluginErrors();
            try {
                final UnicastProcessor<Integer> up = UnicastProcessor.create();

                TestObserver<Integer> to = up.hide()
                .observeOn(Schedulers.io())
                .observeOn(Schedulers.single())
                .unsubscribeOn(Schedulers.computation())
                .firstOrError()
                .test();

                for (int i = 0; up.hasSubscribers() && i < 10000; i++) {
                    up.onNext(i);
                }

                to
                .awaitDone(5, TimeUnit.SECONDS)
                ;

                if (!errors.isEmpty()) {
                    throw new CompositeException(errors);
                }

                to.assertResult(0);
            } finally {
                RxJavaPlugins.reset();
            }
        }",loop_control
i,"for (int i = 0; up.hasSubscribers() && i < 10000; i++) {
                    up.onNext(i);
                }",loop_control
i,"for (int i = 0; i < 1000; i++) {
            assertEquals((Integer)i, onNextEvents.get(i));
        }",loop_control
i,"for (int i = 0; i < 10; i++) {
            assertEquals((Integer)i, onNextEvents.get(i));
        }",loop_control
i,"for (int i = 0; i < 100; i++) {
            TestSubscriber<Integer> ts1 = new TestSubscriber<>();

            FlowableCache<Integer> cached = new FlowableCache<>(source, 16);

            cached.observeOn(Schedulers.computation()).subscribe(ts1);

            ts1.awaitDone(2, TimeUnit.SECONDS);
            ts1.assertNoErrors();
            ts1.assertComplete();
            assertEquals(10000, ts1.values().size());

            TestSubscriber<Integer> ts2 = new TestSubscriber<>();
            cached.observeOn(Schedulers.computation()).subscribe(ts2);

            ts2.awaitDone(2, TimeUnit.SECONDS);
            ts2.assertNoErrors();
            ts2.assertComplete();
            assertEquals(10000, ts2.values().size());
        }",loop_control
i,"for (int i = 0; i < 100; i++) {
            TestSubscriber<Long> ts = new TestSubscriber<>();
            list.add(ts);
            output.skip(i * 10).take(10).subscribe(ts);
        }",loop_control
i,"for (int i = 0; i < 10; i++) {
            expected.add((long)(i - 10));
        }",loop_control
i,"for (int i = j * 10; i < j * 10 + 10; i++) {
                expected.set(i - j * 10, (long)i);
            }",loop_control
ts,"for (int i = 0; i < 100; i++) {
            TestSubscriber<Long> ts = new TestSubscriber<>();
            list.add(ts);
            output.skip(i * 10).take(10).subscribe(ts);
        }",iterator
ts,"for (TestSubscriber<Long> ts : list) {
            ts.awaitDone(3, TimeUnit.SECONDS);
            ts.assertNoErrors();
            ts.assertComplete();

            for (int i = j * 10; i < j * 10 + 10; i++) {
                expected.set(i - j * 10, (long)i);
            }

            ts.assertValueSequence(expected);

            j++;
        }",iterator
j,"{
        Flowable<Long> source = Flowable.interval(1, 1, TimeUnit.MILLISECONDS)
                .take(1000)
                .subscribeOn(Schedulers.io());
        FlowableCache<Long> cached = new FlowableCache<>(source, 16);

        Flowable<Long> output = cached.observeOn(Schedulers.computation());

        List<TestSubscriber<Long>> list = new ArrayList<>(100);
        for (int i = 0; i < 100; i++) {
            TestSubscriber<Long> ts = new TestSubscriber<>();
            list.add(ts);
            output.skip(i * 10).take(10).subscribe(ts);
        }

        List<Long> expected = new ArrayList<>();
        for (int i = 0; i < 10; i++) {
            expected.add((long)(i - 10));
        }
        int j = 0;
        for (TestSubscriber<Long> ts : list) {
            ts.awaitDone(3, TimeUnit.SECONDS);
            ts.assertNoErrors();
            ts.assertComplete();

            for (int i = j * 10; i < j * 10 + 10; i++) {
                expected.set(i - j * 10, (long)i);
            }

            ts.assertValueSequence(expected);

            j++;
        }
    }",maybe_loop_control
i,"for (int i = 0; i < m; i++) {
                    t.onNext(i);
                }",loop_control
i,"for (int i = 0; i < TestHelper.RACE_DEFAULT_LOOPS; i++) {
            final PublishProcessor<Integer> pp = PublishProcessor.<Integer>create();

            final Flowable<Integer> cache = pp.cache();

            cache.test();

            final TestSubscriberEx<Integer> ts = new TestSubscriberEx<>();

            Runnable r1 = new Runnable() {
                @Override
                public void run() {
                    cache.subscribe(ts);
                }
            };

            Runnable r2 = new Runnable() {
                @Override
                public void run() {
                    for (int j = 0; j < 500; j++) {
                        pp.onNext(j);
                    }
                    pp.onComplete();
                }
            };

            TestHelper.race(r1, r2);

            ts
            .awaitDone(5, TimeUnit.SECONDS)
            .assertSubscribed().assertValueCount(500).assertComplete().assertNoErrors();
        }",loop_control
j,"for (int j = 0; j < 500; j++) {
                        pp.onNext(j);
                    }",loop_control
i,"for (int i = 0; i < TestHelper.RACE_DEFAULT_LOOPS; i++) {
            final Flowable<Integer> cache = Flowable.range(1, 500).cache();

            final TestSubscriberEx<Integer> ts1 = new TestSubscriberEx<>();
            final TestSubscriberEx<Integer> ts2 = new TestSubscriberEx<>();

            Runnable r1 = new Runnable() {
                @Override
                public void run() {
                    cache.subscribe(ts1);
                }
            };

            Runnable r2 = new Runnable() {
                @Override
                public void run() {
                    cache.subscribe(ts2);
                }
            };

            TestHelper.race(r1, r2);

            ts1
            .awaitDone(5, TimeUnit.SECONDS)
            .assertSubscribed()
            .assertValueCount(500)
            .assertComplete()
            .assertNoErrors();

            ts2
            .awaitDone(5, TimeUnit.SECONDS)
            .assertSubscribed()
            .assertValueCount(500)
            .assertComplete()
            .assertNoErrors();
        }",loop_control
i,"for (int i = 0; i < TestHelper.RACE_DEFAULT_LOOPS; i++) {
            final PublishProcessor<Integer> pp = PublishProcessor.<Integer>create();

            final Flowable<Integer> cache = pp.cache();

            cache.test();

            final TestSubscriber<Integer> ts = new TestSubscriber<>();

            Runnable r1 = new Runnable() {
                @Override
                public void run() {
                    cache.subscribe(ts);
                }
            };

            Runnable r2 = new Runnable() {
                @Override
                public void run() {
                    pp.onComplete();
                }
            };

            TestHelper.race(r1, r2);

            ts
            .awaitDone(5, TimeUnit.SECONDS)
            .assertResult();
        }",loop_control
i,"for (int i = 0; i < TestHelper.RACE_DEFAULT_LOOPS; i++) {
            Flowable<Object> f = Flowable.never().cache();

            TestSubscriber<Object> ts = f.test();

            TestHelper.race(
                    () -> ts.cancel(),
                    () -> f.test()
            );
        }",loop_control
it,"{
        FlowableProcessor<String> obs = PublishProcessor.create();
        Iterator<String> it = obs.blockingNext().iterator();
        fireOnNextInNewThread(obs, ""one"");
        assertTrue(it.hasNext());
        assertEquals(""one"", it.next());

        fireOnNextInNewThread(obs, ""two"");
        assertTrue(it.hasNext());
        assertEquals(""two"", it.next());

        fireOnNextInNewThread(obs, ""three"");
        try {
            assertEquals(""three"", it.next());
        } catch (NoSuchElementException e) {
            fail(""Calling next() without hasNext() should wait for next fire"");
        }

        obs.onComplete();
        assertFalse(it.hasNext());
        try {
            it.next();
            fail(""At the end of an iterator should throw a NoSuchElementException"");
        } catch (NoSuchElementException e) {
        }

        // If the observable is completed, hasNext always returns false and next always throw a NoSuchElementException.
        assertFalse(it.hasNext());
        try {
            it.next();
            fail(""At the end of an iterator should throw a NoSuchElementException"");
        } catch (NoSuchElementException e) {
        }
    }",iterator
it,"{
        FlowableProcessor<String> obs = PublishProcessor.create();
        Iterator<String> it = obs.blockingNext().iterator();
        fireOnNextInNewThread(obs, ""one"");
        assertTrue(it.hasNext());
        assertEquals(""one"", it.next());

        fireOnErrorInNewThread(obs);
        try {
            it.hasNext();
            fail(""Expected an TestException"");
        } catch (TestException e) {
        }

        assertErrorAfterObservableFail(it);
    }",iterator
it,"{
        Flowable<String> obs = Flowable.<String> empty().observeOn(Schedulers.newThread());
        Iterator<String> it = obs.blockingNext().iterator();

        assertFalse(it.hasNext());
        try {
            it.next();
            fail(""At the end of an iterator should throw a NoSuchElementException"");
        } catch (NoSuchElementException e) {
        }

        // If the observable is completed, hasNext always returns false and next always throw a NoSuchElementException.
        assertFalse(it.hasNext());
        try {
            it.next();
            fail(""At the end of an iterator should throw a NoSuchElementException"");
        } catch (NoSuchElementException e) {
        }
    }",iterator
it,"{
        FlowableProcessor<String> obs = PublishProcessor.create();
        Iterator<String> it = obs.blockingNext().iterator();

        obs.onError(new TestException());
        try {
            it.hasNext();
            fail(""Expected an TestException"");
        } catch (TestException e) {
            // successful
        }

        assertErrorAfterObservableFail(it);
    }",iterator
it,"{
        FlowableProcessor<String> obs = PublishProcessor.create();
        Iterator<String> it = obs.blockingNext().iterator();

        fireOnErrorInNewThread(obs);

        try {
            it.hasNext();
            fail(""Expected an TestException"");
        } catch (TestException e) {
            // successful
        }

        assertErrorAfterObservableFail(it);
    }",iterator
it,"{
        FlowableProcessor<String> obs = PublishProcessor.create();
        Iterator<String> it = obs.blockingNext().iterator();
        fireOnNextInNewThread(obs, ""one"");
        assertEquals(""one"", it.next());

        fireOnNextInNewThread(obs, ""two"");
        assertEquals(""two"", it.next());

        obs.onComplete();
        try {
            it.next();
            fail(""At the end of an iterator should throw a NoSuchElementException"");
        } catch (NoSuchElementException e) {
        }
    }",iterator
it,"{
        FlowableProcessor<String> obs = PublishProcessor.create();
        Iterator<String> it = obs.blockingNext().iterator();
        fireOnNextInNewThread(obs, ""one"");
        assertTrue(it.hasNext());
        assertTrue(it.hasNext());
        assertTrue(it.hasNext());
        assertTrue(it.hasNext());
        assertEquals(""one"", it.next());

        obs.onComplete();
        try {
            it.next();
            fail(""At the end of an iterator should throw a NoSuchElementException"");
        } catch (NoSuchElementException e) {
        }
    }",iterator
running,"{
                final CountDownLatch finished = new CountDownLatch(1);
                final int COUNT = 30;
                final CountDownLatch timeHasPassed = new CountDownLatch(COUNT);
                final AtomicBoolean running = new AtomicBoolean(true);
                final AtomicInteger count = new AtomicInteger(0);
                final Flowable<Integer> obs = Flowable.unsafeCreate(new Publisher<Integer>() {

                    @Override
                    public void subscribe(final Subscriber<? super Integer> subscriber) {
                        subscriber.onSubscribe(new BooleanSubscription());
                        task.replace(Schedulers.single().scheduleDirect(new Runnable() {

                            @Override
                            public void run() {
                                try {
                                    while (running.get() && !task.isDisposed()) {
                                        subscriber.onNext(count.incrementAndGet());
                                        timeHasPassed.countDown();
                                    }
                                    subscriber.onComplete();
                                } catch (Throwable e) {
                                    subscriber.onError(e);
                                } finally {
                                    finished.countDown();
                                }
                            }
                        }));
                    }

                });

                Iterator<Integer> it = obs.blockingNext().iterator();

                assertTrue(it.hasNext());
                int a = it.next();
                assertTrue(it.hasNext());
                int b = it.next();
                // we should have a different value
                assertTrue(""a and b should be different"", a != b);

                // wait for some time (if times out we are blocked somewhere so fail ... set very high for very slow, constrained machines)
                timeHasPassed.await(8000, TimeUnit.MILLISECONDS);

                assertTrue(it.hasNext());
                int c = it.next();

                assertTrue(""c should not just be the next in sequence"", c != (b + 1));
                assertTrue(""expected that c ["" + c + ""] is higher than or equal to "" + COUNT, c >= COUNT);

                assertTrue(it.hasNext());
                int d = it.next();
                assertTrue(d > c);

                // shut down the thread
                running.set(false);

                finished.await();

                assertFalse(it.hasNext());

                System.out.println(""a: "" + a + "" b: "" + b + "" c: "" + c);
                break;
            }",maybe_loop_control
task,"for (;;) {
            final SerialDisposable task = new SerialDisposable();
            try {
                final CountDownLatch finished = new CountDownLatch(1);
                final int COUNT = 30;
                final CountDownLatch timeHasPassed = new CountDownLatch(COUNT);
                final AtomicBoolean running = new AtomicBoolean(true);
                final AtomicInteger count = new AtomicInteger(0);
                final Flowable<Integer> obs = Flowable.unsafeCreate(new Publisher<Integer>() {

                    @Override
                    public void subscribe(final Subscriber<? super Integer> subscriber) {
                        subscriber.onSubscribe(new BooleanSubscription());
                        task.replace(Schedulers.single().scheduleDirect(new Runnable() {

                            @Override
                            public void run() {
                                try {
                                    while (running.get() && !task.isDisposed()) {
                                        subscriber.onNext(count.incrementAndGet());
                                        timeHasPassed.countDown();
                                    }
                                    subscriber.onComplete();
                                } catch (Throwable e) {
                                    subscriber.onError(e);
                                } finally {
                                    finished.countDown();
                                }
                            }
                        }));
                    }

                });

                Iterator<Integer> it = obs.blockingNext().iterator();

                assertTrue(it.hasNext());
                int a = it.next();
                assertTrue(it.hasNext());
                int b = it.next();
                // we should have a different value
                assertTrue(""a and b should be different"", a != b);

                // wait for some time (if times out we are blocked somewhere so fail ... set very high for very slow, constrained machines)
                timeHasPassed.await(8000, TimeUnit.MILLISECONDS);

                assertTrue(it.hasNext());
                int c = it.next();

                assertTrue(""c should not just be the next in sequence"", c != (b + 1));
                assertTrue(""expected that c ["" + c + ""] is higher than or equal to "" + COUNT, c >= COUNT);

                assertTrue(it.hasNext());
                int d = it.next();
                assertTrue(d > c);

                // shut down the thread
                running.set(false);

                finished.await();

                assertFalse(it.hasNext());

                System.out.println(""a: "" + a + "" b: "" + b + "" c: "" + c);
                break;
            } catch (AssertionError ex) {
                if (++repeat == 3) {
                    throw ex;
                }
                Thread.sleep((int)(1000 * Math.pow(2, repeat - 1)));
            } finally {
                task.dispose();
            }
        }",maybe_loop_control
it,"{
                final CountDownLatch finished = new CountDownLatch(1);
                final int COUNT = 30;
                final CountDownLatch timeHasPassed = new CountDownLatch(COUNT);
                final AtomicBoolean running = new AtomicBoolean(true);
                final AtomicInteger count = new AtomicInteger(0);
                final Flowable<Integer> obs = Flowable.unsafeCreate(new Publisher<Integer>() {

                    @Override
                    public void subscribe(final Subscriber<? super Integer> subscriber) {
                        subscriber.onSubscribe(new BooleanSubscription());
                        task.replace(Schedulers.single().scheduleDirect(new Runnable() {

                            @Override
                            public void run() {
                                try {
                                    while (running.get() && !task.isDisposed()) {
                                        subscriber.onNext(count.incrementAndGet());
                                        timeHasPassed.countDown();
                                    }
                                    subscriber.onComplete();
                                } catch (Throwable e) {
                                    subscriber.onError(e);
                                } finally {
                                    finished.countDown();
                                }
                            }
                        }));
                    }

                });

                Iterator<Integer> it = obs.blockingNext().iterator();

                assertTrue(it.hasNext());
                int a = it.next();
                assertTrue(it.hasNext());
                int b = it.next();
                // we should have a different value
                assertTrue(""a and b should be different"", a != b);

                // wait for some time (if times out we are blocked somewhere so fail ... set very high for very slow, constrained machines)
                timeHasPassed.await(8000, TimeUnit.MILLISECONDS);

                assertTrue(it.hasNext());
                int c = it.next();

                assertTrue(""c should not just be the next in sequence"", c != (b + 1));
                assertTrue(""expected that c ["" + c + ""] is higher than or equal to "" + COUNT, c >= COUNT);

                assertTrue(it.hasNext());
                int d = it.next();
                assertTrue(d > c);

                // shut down the thread
                running.set(false);

                finished.await();

                assertFalse(it.hasNext());

                System.out.println(""a: "" + a + "" b: "" + b + "" c: "" + c);
                break;
            }",iterator
j,"for (int j = 0; j < 3; j++) {
            BlockingFlowableNext.NextIterator<Long> it = (BlockingFlowableNext.NextIterator<Long>)iter.iterator();

            for (long i = 0; i < 10; i++) {
                Assert.assertTrue(it.hasNext());
                Assert.assertEquals(j + ""th iteration next"", Long.valueOf(i), it.next());
            }
            terminal.onNext(1);
        }",loop_control
i,"for (long i = 0; i < 10; i++) {
                Assert.assertTrue(it.hasNext());
                Assert.assertEquals(j + ""th iteration next"", Long.valueOf(i), it.next());
            }",loop_control
it,"{
        Iterator<Object> it = Flowable.never().blockingNext().iterator();

        try {
            Thread.currentThread().interrupt();
            it.next();
        } catch (RuntimeException ex) {
            assertTrue(ex.toString(), ex.getCause() instanceof InterruptedException);
        }
    }",iterator
s,"for (Integer s : source) {
            for (Integer v : list) {
                verify(subscriber).onNext(s | v);
            }
        }",iterator
v,"for (Integer v : list) {
                verify(subscriber).onNext(s | v);
            }",iterator
i,"for (int i = 0; i < 1000; i++) {
            if (i % 100 == 0) {
                System.out.println(""testFlatMapTransformsMaxConcurrentNormalLoop => "" + i);
            }
            flatMapTransformsMaxConcurrentNormal();
        }",loop_control
i,"for (int i = 0; i < 2000; i++) {
            if (i % 10 == 0) {
                System.out.println(""flatMapRangeAsyncLoop > "" + i);
            }
            TestSubscriberEx<Integer> ts = new TestSubscriberEx<>();
            Flowable.range(0, 1000)
            .flatMap(new Function<Integer, Flowable<Integer>>() {
                final Random rnd = new Random();
                @Override
                public Flowable<Integer> apply(Integer t) {
                    Flowable<Integer> r = Flowable.just(t);
                    if (rnd.nextBoolean()) {
                        r = r.hide();
                    }
                    return r;
                }
            })
            .observeOn(Schedulers.computation())
            .subscribe(ts);

            ts.awaitDone(2500, TimeUnit.MILLISECONDS);
            if (ts.completions() == 0) {
                System.out.println(ts.values().size());
            }
            ts.assertTerminated();
            ts.assertNoErrors();
            List<Integer> list = ts.values();
            if (list.size() < 1000) {
                Set<Integer> set = new HashSet<>(list);
                for (int j = 0; j < 1000; j++) {
                    if (!set.contains(j)) {
                        System.out.println(j + "" missing"");
                    }
                }
            }
            assertEquals(1000, list.size());
        }",loop_control
j,"for (int j = 0; j < 1000; j++) {
                    if (!set.contains(j)) {
                        System.out.println(j + "" missing"");
                    }
                }",loop_control
i,"for (int i = 0; i < 1000; i++) {
            TestSubscriber<Integer> ts = new TestSubscriber<>();

            Flowable.range(1, 1000).flatMap(new Function<Integer, Flowable<Integer>>() {
                @Override
                public Flowable<Integer> apply(Integer t) {
                    return Flowable.just(1).subscribeOn(Schedulers.computation());
                }
            }).subscribe(ts);

            ts.awaitDone(5, TimeUnit.SECONDS);
            ts.assertNoErrors();
            ts.assertComplete();
            ts.assertValueCount(1000);
        }",loop_control
n,"for (final int n : new int[] { 1, 1000, 1000000 }) {
            TestSubscriber<Integer> ts = new TestSubscriber<>();

            Flowable.just(1, 2).flatMap(new Function<Integer, Flowable<Integer>>() {
                @Override
                public Flowable<Integer> apply(Integer t) {
                    return Flowable.range(1, n);
                }
            }).subscribe(ts);

            System.out.println(""flatMapTwoNestedSync >> @ "" + n);
            ts.assertNoErrors();
            ts.assertComplete();
            ts.assertValueCount(n * 2);
        }",iterator
v,"{
            @Override
            public Flowable<Integer> apply(Integer v) {
                return (v & 1) == 0 ? Flowable.<Integer>empty() : Flowable.just(v);
            }
        }",iterator
v,"for (Integer v : ts.values()) {
            Assert.assertEquals(j, v.intValue());

            j += 2;
        }",iterator
i,"for (int i = 0; i < list.size(); i += 2) {
            Assert.assertEquals(j, list.get(i).intValue());
            Assert.assertEquals(j + 1, list.get(i + 1).intValue());

            j += 2;
        }",loop_control
v,"{
            @Override
            public Flowable<Integer> apply(Integer v) {
                return (v & 1) == 0 ? Flowable.<Integer>empty() : Flowable.just(v);
            }
        }",iterator
v,"for (Integer v : ts.values()) {
            Assert.assertEquals(j, v.intValue());

            j += 2;
        }",iterator
i,"for (int i = 0; i < list.size(); i += 2) {
            Assert.assertEquals(j, list.get(i).intValue());
            Assert.assertEquals(j + 1, list.get(i + 1).intValue());

            j += 2;
        }",loop_control
i,"for (int i = 0; i < TestHelper.RACE_DEFAULT_LOOPS; i++) {
            final PublishProcessor<Integer> pp = PublishProcessor.create();

            final TestSubscriber<Integer> ts = Flowable.merge(Flowable.just(pp)).test();

            Runnable r1 = new Runnable() {
                @Override
                public void run() {
                    pp.onComplete();
                }
            };

            Runnable r2 = new Runnable() {
                @Override
                public void run() {
                    ts.cancel();
                }
            };

            TestHelper.race(r1, r2);
        }",loop_control
i,"for (int i = 0; i < 500; i++) {
            TestSubscriber<Object> ts = Flowable.merge(
                    Flowable.just(1).observeOn(Schedulers.single()).map(new Function<Integer, Object>() {
                        @Override
                        public Object apply(Integer v) throws Exception {
                            return Thread.currentThread().getName().substring(0, 4);
                        }
                    }),
                    Flowable.just(1).observeOn(Schedulers.computation()).map(new Function<Integer, Object>() {
                        @Override
                        public Object apply(Integer v) throws Exception {
                            return Thread.currentThread().getName().substring(0, 4);
                        }
                    })
            )
            .test()
            .awaitDone(5, TimeUnit.SECONDS)
            .assertValueCount(2);

            List<Object> list = ts.values();

            assertTrue(list.toString(), list.contains(""RxSi""));
            assertTrue(list.toString(), list.contains(""RxCo""));
        }",loop_control
i,"for (int i = 0; i < TestHelper.RACE_DEFAULT_LOOPS; i++) {
            List<Throwable> errors = TestHelper.trackPluginErrors();
            try {

                final PublishProcessor<Flowable<Integer>> pp = PublishProcessor.create();

                final TestSubscriber<Integer> ts = pp.flatMap(Functions.<Flowable<Integer>>identity()).test(0);

                Runnable r1 = new Runnable() {
                    @Override
                    public void run() {
                        ts.cancel();
                    }
                };
                Runnable r2 = new Runnable() {
                    @Override
                    public void run() {
                        pp.onComplete();
                    }
                };

                TestHelper.race(r1, r2);

                assertTrue(errors.toString(), errors.isEmpty());
            } finally {
                RxJavaPlugins.reset();
            }
        }",loop_control
i,"for (int i = 0; i < TestHelper.RACE_DEFAULT_LOOPS; i++) {
            for (int j = 1; j < 50; j += 5) {
                List<Throwable> errors = TestHelper.trackPluginErrors();
                try {

                    final PublishProcessor<Flowable<Integer>> pp = PublishProcessor.create();

                    final TestSubscriber<Integer> ts = pp.flatMap(Functions.<Flowable<Integer>>identity()).test(0);

                    final PublishProcessor<Integer> just = PublishProcessor.create();
                    pp.onNext(just);

                    Runnable r1 = new Runnable() {
                        @Override
                        public void run() {
                            ts.request(1);
                            ts.cancel();
                        }
                    };
                    Runnable r2 = new Runnable() {
                        @Override
                        public void run() {
                            just.onNext(1);
                        }
                    };

                    TestHelper.race(r1, r2);

                    assertTrue(errors.toString(), errors.isEmpty());
                } finally {
                    RxJavaPlugins.reset();
                }
            }
        }",loop_control
j,"for (int j = 1; j < 50; j += 5) {
                List<Throwable> errors = TestHelper.trackPluginErrors();
                try {

                    final PublishProcessor<Flowable<Integer>> pp = PublishProcessor.create();

                    final TestSubscriber<Integer> ts = pp.flatMap(Functions.<Flowable<Integer>>identity()).test(0);

                    final PublishProcessor<Integer> just = PublishProcessor.create();
                    pp.onNext(just);

                    Runnable r1 = new Runnable() {
                        @Override
                        public void run() {
                            ts.request(1);
                            ts.cancel();
                        }
                    };
                    Runnable r2 = new Runnable() {
                        @Override
                        public void run() {
                            just.onNext(1);
                        }
                    };

                    TestHelper.race(r1, r2);

                    assertTrue(errors.toString(), errors.isEmpty());
                } finally {
                    RxJavaPlugins.reset();
                }
            }",loop_control
i,"for (int i = 0; i < TestHelper.RACE_DEFAULT_LOOPS; i++) {
            Flowable
            .range(0, 20)
            .flatMap(
                    integer -> {
                        if (integer % 5 != 0) {
                            return Flowable
                                    .just(integer);
                        }

                        return Flowable
                                .just(-integer)
                                .observeOn(Schedulers.computation());
                    },
                    false,
                    1
            )
            .ignoreElements()
            .blockingAwait();
        }",loop_control
timeout,"{
            final CountDownLatch cdl1 = new CountDownLatch(1);
            final CountDownLatch cdl2 = new CountDownLatch(1);

            TestSubscriber<Object> ts = Flowable.fromAction(new Action() {
                @Override
                public void run() throws Exception {
                    cdl1.countDown();
                    cdl2.await(5, TimeUnit.SECONDS);
                }
            }).subscribeOn(Schedulers.single()).test();

            assertTrue(cdl1.await(5, TimeUnit.SECONDS));

            ts.cancel();

            int timeout = 10;

            while (timeout-- > 0 && errors.isEmpty()) {
                Thread.sleep(100);
            }

            TestHelper.assertUndeliverable(errors, 0, InterruptedException.class);
        }",loop_control
errors,"{
        List<Throwable> errors = TestHelper.trackPluginErrors();
        try {
            final CountDownLatch cdl1 = new CountDownLatch(1);
            final CountDownLatch cdl2 = new CountDownLatch(1);

            TestSubscriber<Object> ts = Flowable.fromAction(new Action() {
                @Override
                public void run() throws Exception {
                    cdl1.countDown();
                    cdl2.await(5, TimeUnit.SECONDS);
                }
            }).subscribeOn(Schedulers.single()).test();

            assertTrue(cdl1.await(5, TimeUnit.SECONDS));

            ts.cancel();

            int timeout = 10;

            while (timeout-- > 0 && errors.isEmpty()) {
                Thread.sleep(100);
            }

            TestHelper.assertUndeliverable(errors, 0, InterruptedException.class);
        } finally {
            RxJavaPlugins.reset();
        }
    }",maybe_loop_control
arg,"for (String arg : args) {
            list.add(arg);
        }",iterator
i,"for (int i = 0; i < Math.random() * 20; i++) {
                        s.onNext(i);
                    }",loop_control
i,"for (int i = 0; i < TestHelper.RACE_DEFAULT_LOOPS; i++) {
            PublishProcessor<Flowable<Integer>> source = PublishProcessor.create();

            TestSubscriber<Integer> ts = source
                    .concatMap(v -> v, n + 1, ImmediateThinScheduler.INSTANCE)
                    .test(1L);

            TestHelper.race(() -> {
                for (int j = 0; j < n; j++) {
                    source.onNext(just);
                }
            }, () -> {
                for (int j = 0; j < n; j++) {
                    ts.request(1);
                }
            });

            ts.assertValueCount(n);
        }",loop_control
j,"for (int j = 0; j < n; j++) {
                    source.onNext(just);
                }",loop_control
j,"for (int j = 0; j < n; j++) {
                    ts.request(1);
                }",loop_control
i,"for (int i = 0; i < TestHelper.RACE_DEFAULT_LOOPS; i++) {
            PublishProcessor<Flowable<Integer>> source = PublishProcessor.create();

            TestSubscriber<Integer> ts = source
                    .concatMapDelayError(v -> v, true, n + 1, ImmediateThinScheduler.INSTANCE)
                    .test(1L);

            TestHelper.race(() -> {
                for (int j = 0; j < n; j++) {
                    source.onNext(just);
                }
            }, () -> {
                for (int j = 0; j < n; j++) {
                    ts.request(1);
                }
            });

            ts.assertValueCount(n);
        }",loop_control
j,"for (int j = 0; j < n; j++) {
                    source.onNext(just);
                }",loop_control
j,"for (int j = 0; j < n; j++) {
                    ts.request(1);
                }",loop_control
i,"for (int i = 0;; i++) {
            //only run this for a max of ten seconds
            if (System.currentTimeMillis() - startTime > TimeUnit.SECONDS.toMillis(durationSeconds)) {
                return;
            }
            if (i % 1000 == 0) {
                System.out.println(""concatMapRangeAsyncLoop > "" + i);
            }
            TestSubscriberEx<Integer> ts = new TestSubscriberEx<>();
            Flowable.range(0, 1000)
            .concatMap(new Function<Integer, Flowable<Integer>>() {
                @Override
                public Flowable<Integer> apply(Integer t) {
                    return Flowable.fromIterable(Arrays.asList(t));
                }
            }, 2, ImmediateThinScheduler.INSTANCE)
            .observeOn(Schedulers.computation()).subscribe(ts);

            ts.awaitDone(2500, TimeUnit.MILLISECONDS);
            ts.assertTerminated();
            ts.assertNoErrors();
            assertEquals(1000, ts.values().size());
            assertEquals((Integer)999, ts.values().get(999));
        }",loop_control
i,"for (int i = 2; i < 10; i++) {
            Flowable<Integer>[] obs = new Flowable[i];
            Arrays.fill(obs, Flowable.just(1));

            Integer[] expected = new Integer[i];
            Arrays.fill(expected, 1);

            Method m = Flowable.class.getMethod(""concatArray"",  Publisher[].class);

            TestSubscriber<Integer> ts = TestSubscriber.create();

            ((Flowable<Integer>)m.invoke(null, new Object[]{obs})).subscribe(ts);

            ts.assertValues(expected);
            ts.assertNoErrors();
            ts.assertComplete();
        }",loop_control
i,"for (int i = 2; i < 10; i++) {
            Object[] obs = new Object[i];
            Arrays.fill(obs, 1);

            Integer[] expected = new Integer[i];
            Arrays.fill(expected, 1);

            Method m = Flowable.class.getMethod(""startWithArray"", Object[].class);

            TestSubscriber<Integer> ts = TestSubscriber.create();

            ((Flowable<Integer>)m.invoke(Flowable.empty(), new Object[]{obs})).subscribe(ts);

            ts.assertValues(expected);
            ts.assertNoErrors();
            ts.assertComplete();
        }",loop_control
i,"for (int i = 0; i < 10; i++) {
                    s.onNext(i);
                }",loop_control
i,"for (int i = 0; i < TestHelper.RACE_DEFAULT_LOOPS; i++) {
                AtomicReference<Subscriber<? super Integer>> ref1 = new AtomicReference<>();
                AtomicReference<Subscriber<? super Integer>> ref2 = new AtomicReference<>();

                TestSubscriber<Integer> ts = Flowable.<Integer>fromPublisher(ref1::set)
                .concatMap(v -> Flowable.<Integer>fromPublisher(ref2::set), 2, ImmediateThinScheduler.INSTANCE)
                .test();

                ref1.get().onSubscribe(new BooleanSubscription());
                ref1.get().onNext(1);
                ref2.get().onSubscribe(new BooleanSubscription());

                TestHelper.race(() -> ref1.get().onError(ex1), () -> ref2.get().onError(ex2));

                ts.assertError(RuntimeException.class);
                errors.clear();
            }",loop_control
i,"for (long i = 1; i <= Flowable.bufferSize() * 2 + 1; i++) {
            list.add(i);
        }",loop_control
i,"for (long i = 0; i < 100; i++) {
            list.add(i + start);
            ts.request(1);
        }",loop_control
i,"for (long i = 0; i < 100; i++) {
            list.add(i + start);
        }",loop_control
i,"for (long i = 0; i < 100; i++) {
            withBackpressureOneByOne(i);
        }",loop_control
i,"for (long i = 0; i < 100; i++) {
            withBackpressureAllAtOnce(i);
        }",loop_control
i,"for (long i = 0; i < 100; i++) {
            list.add(i + 50);
        }",loop_control
i,"for (int i = 0; i <= max; i++) {
            try {
                multiThreadedWithNPE();
                return;
            } catch (AssertionError ex) {
                if (i == max) {
                    throw ex;
                }
            }
            Thread.sleep((long)(1000 * Math.random() + 100));
        }",loop_control
i,"for (int i = 0; i <= max; i++) {
            try {
                multiThreadedWithNPEinMiddle();
                return;
            } catch (AssertionError ex) {
                if (i == max) {
                    throw ex;
                }
            }
            Thread.sleep((long)(1000 * Math.random() + 100));
        }",loop_control
i,"for (int i = 0; i < 3; i++) {
            TestMultiThreadedObservable onSubscribe = new TestMultiThreadedObservable(""one"", ""two"", ""three"", null, ""four"", ""five"", ""six"", ""seven"", ""eight"", ""nine"");
            Flowable<String> w = Flowable.unsafeCreate(onSubscribe);

            BusyObserver busyobserver = new BusyObserver();

            w.serialize().subscribe(busyobserver);
            onSubscribe.waitToFinish();

            System.out.println(""maxConcurrentThreads: "" + onSubscribe.maxConcurrentThreads.get());
            // this should not always be the full number of items since the error should (very often)
            // stop it before it completes all 9
            System.out.println(""onNext count: "" + busyobserver.onNextCount.get());
            if (busyobserver.onNextCount.get() < 9) {
                lessThan9 = true;
            }
            assertTrue(busyobserver.onError);
            // no onComplete because onError was invoked
            assertFalse(busyobserver.onComplete);
            // non-deterministic because unsubscribe happens after 'waitToFinish' releases
            // so commenting out for now as this is not a critical thing to test here
            // verify(s, times(1)).unsubscribe();

            // we can have concurrency ...
            assertTrue(onSubscribe.maxConcurrentThreads.get() > 1);
            // ... but the onNext execution should be single threaded
            assertEquals(1, busyobserver.maxConcurrentThreads.get());
        }",loop_control
f,"for (Future<?> f : waitOnThese) {
                    try {
                        f.get();
                    } catch (Throwable e) {
                        System.err.println(""Error while waiting on future in CompletionThread"");
                    }
                }",iterator
i,"for (int i = 0; i < TestHelper.RACE_DEFAULT_LOOPS; i++) {
            List<Throwable> errors = TestHelper.trackPluginErrors();
            try {
                final PublishProcessor<Integer> pp = PublishProcessor.create();

                final Subscriber<?>[] sub = { null, null };

                final Flowable<Integer> pp2 = new Flowable<Integer>() {

                    int count;

                    @Override
                    protected void subscribeActual(
                            Subscriber<? super Integer> s) {
                        s.onSubscribe(new BooleanSubscription());
                        sub[count++] = s;
                    }
                };

                TestSubscriber<Integer> ts = pp.timeout(Functions.justFunction(pp2)).test();

                pp.onNext(0);

                Runnable r1 = new Runnable() {
                    @Override
                    public void run() {
                        pp.onNext(1);
                    }
                };

                final Throwable ex = new TestException();

                Runnable r2 = new Runnable() {
                    @Override
                    public void run() {
                        sub[0].onError(ex);
                    }
                };

                TestHelper.race(r1, r2);

                ts.assertValueAt(0, 0);

                if (!errors.isEmpty()) {
                    TestHelper.assertUndeliverable(errors, 0, TestException.class);
                }
            } finally {
                RxJavaPlugins.reset();
            }
        }",loop_control
i,"for (int i = 0; i < TestHelper.RACE_DEFAULT_LOOPS; i++) {
            List<Throwable> errors = TestHelper.trackPluginErrors();
            try {
                final PublishProcessor<Integer> pp = PublishProcessor.create();

                final Subscriber<?>[] sub = { null, null };

                final Flowable<Integer> pp2 = new Flowable<Integer>() {

                    int count;

                    @Override
                    protected void subscribeActual(
                            Subscriber<? super Integer> s) {
                        assertFalse(((Disposable)s).isDisposed());
                        s.onSubscribe(new BooleanSubscription());
                        sub[count++] = s;
                    }
                };

                TestSubscriber<Integer> ts = pp.timeout(Functions.justFunction(pp2), Flowable.<Integer>never()).test();

                pp.onNext(0);

                Runnable r1 = new Runnable() {
                    @Override
                    public void run() {
                        pp.onNext(1);
                    }
                };

                final Throwable ex = new TestException();

                Runnable r2 = new Runnable() {
                    @Override
                    public void run() {
                        sub[0].onError(ex);
                    }
                };

                TestHelper.race(r1, r2);

                ts.assertValueAt(0, 0);

                if (!errors.isEmpty()) {
                    TestHelper.assertUndeliverable(errors, 0, TestException.class);
                }
            } finally {
                RxJavaPlugins.reset();
            }
        }",loop_control
i,"for (int i = 0; i < TestHelper.RACE_DEFAULT_LOOPS; i++) {
            List<Throwable> errors = TestHelper.trackPluginErrors();
            try {
                final PublishProcessor<Integer> pp = PublishProcessor.create();

                final Subscriber<?>[] sub = { null, null };

                final Flowable<Integer> pp2 = new Flowable<Integer>() {

                    int count;

                    @Override
                    protected void subscribeActual(
                            Subscriber<? super Integer> s) {
                        assertFalse(((Disposable)s).isDisposed());
                        s.onSubscribe(new BooleanSubscription());
                        sub[count++] = s;
                    }
                };

                TestSubscriber<Integer> ts = pp.timeout(Functions.justFunction(pp2)).test();

                pp.onNext(0);

                final Throwable ex = new TestException();

                Runnable r1 = new Runnable() {
                    @Override
                    public void run() {
                        pp.onError(ex);
                    }
                };

                Runnable r2 = new Runnable() {
                    @Override
                    public void run() {
                        sub[0].onComplete();
                    }
                };

                TestHelper.race(r1, r2);

                ts.assertValueAt(0, 0);

                if (!errors.isEmpty()) {
                    TestHelper.assertUndeliverable(errors, 0, TestException.class);
                }
            } finally {
                RxJavaPlugins.reset();
            }
        }",loop_control
i,"for (int i = 0; i < TestHelper.RACE_DEFAULT_LOOPS; i++) {
            List<Throwable> errors = TestHelper.trackPluginErrors();
            try {
                final PublishProcessor<Integer> pp = PublishProcessor.create();

                final Subscriber<?>[] sub = { null, null };

                final Flowable<Integer> pp2 = new Flowable<Integer>() {

                    int count;

                    @Override
                    protected void subscribeActual(
                            Subscriber<? super Integer> s) {
                        assertFalse(((Disposable)s).isDisposed());
                        s.onSubscribe(new BooleanSubscription());
                        sub[count++] = s;
                    }
                };

                TestSubscriber<Integer> ts = pp.timeout(Functions.justFunction(pp2)).test();

                pp.onNext(0);

                Runnable r1 = new Runnable() {
                    @Override
                    public void run() {
                        pp.onComplete();
                    }
                };

                Runnable r2 = new Runnable() {
                    @Override
                    public void run() {
                        sub[0].onComplete();
                    }
                };

                TestHelper.race(r1, r2);

                ts.assertValueAt(0, 0);

                if (!errors.isEmpty()) {
                    TestHelper.assertUndeliverable(errors, 0, TestException.class);
                }
            } finally {
                RxJavaPlugins.reset();
            }
        }",loop_control
i,"for (int i = 0; i < TestHelper.RACE_DEFAULT_LOOPS; i++) {
            List<Throwable> errors = TestHelper.trackPluginErrors();
            try {
                final PublishProcessor<Integer> pp = PublishProcessor.create();

                final Subscriber<?>[] sub = { null, null };

                final Flowable<Integer> pp2 = new Flowable<Integer>() {

                    int count;

                    @Override
                    protected void subscribeActual(
                            Subscriber<? super Integer> s) {
                        assertFalse(((Disposable)s).isDisposed());
                        s.onSubscribe(new BooleanSubscription());
                        sub[count++] = s;
                    }
                };

                TestSubscriber<Integer> ts = pp.timeout(Functions.justFunction(pp2), Flowable.<Integer>never()).test();

                pp.onNext(0);

                Runnable r1 = new Runnable() {
                    @Override
                    public void run() {
                        pp.onComplete();
                    }
                };

                Runnable r2 = new Runnable() {
                    @Override
                    public void run() {
                        sub[0].onComplete();
                    }
                };

                TestHelper.race(r1, r2);

                ts.assertValueAt(0, 0);

                if (!errors.isEmpty()) {
                    TestHelper.assertUndeliverable(errors, 0, TestException.class);
                }
            } finally {
                RxJavaPlugins.reset();
            }
        }",loop_control
j,"for (int j = 0; j < NUM_LOOPS; j++) {
            final int numRetries = Flowable.bufferSize() * 2;
            for (int i = 0; i < 400; i++) {
                Subscriber<String> subscriber = TestHelper.mockSubscriber();
                Flowable<String> origin = Flowable.unsafeCreate(new FuncWithErrors(numRetries));
                TestSubscriberEx<String> ts = new TestSubscriberEx<>(subscriber);
                origin.retry().observeOn(Schedulers.computation()).subscribe(ts);
                ts.awaitDone(5, TimeUnit.SECONDS);

                InOrder inOrder = inOrder(subscriber);
                // should have no errors
                verify(subscriber, never()).onError(any(Throwable.class));
                // should show numRetries attempts
                inOrder.verify(subscriber, times(numRetries + 1)).onNext(""beginningEveryTime"");
                // should have a single success
                inOrder.verify(subscriber, times(1)).onNext(""onSuccessOnly"");
                // should have a single successful onComplete
                inOrder.verify(subscriber, times(1)).onComplete();
                inOrder.verifyNoMoreInteractions();
            }
        }",loop_control
i,"for (int i = 0; i < 400; i++) {
                Subscriber<String> subscriber = TestHelper.mockSubscriber();
                Flowable<String> origin = Flowable.unsafeCreate(new FuncWithErrors(numRetries));
                TestSubscriberEx<String> ts = new TestSubscriberEx<>(subscriber);
                origin.retry().observeOn(Schedulers.computation()).subscribe(ts);
                ts.awaitDone(5, TimeUnit.SECONDS);

                InOrder inOrder = inOrder(subscriber);
                // should have no errors
                verify(subscriber, never()).onError(any(Throwable.class));
                // should show numRetries attempts
                inOrder.verify(subscriber, times(numRetries + 1)).onNext(""beginningEveryTime"");
                // should have a single success
                inOrder.verify(subscriber, times(1)).onNext(""onSuccessOnly"");
                // should have a single successful onComplete
                inOrder.verify(subscriber, times(1)).onComplete();
                inOrder.verifyNoMoreInteractions();
            }",loop_control
r,"for (int r = 0; r < NUM_LOOPS; r++) {
                if (r % 10 == 0) {
                    System.out.println(""testRetryWithBackpressureParallelLoop -> "" + r);
                }

                final AtomicInteger timeouts = new AtomicInteger();
                final Map<Integer, List<String>> data = new ConcurrentHashMap<>();

                int m = 5000;
                final CountDownLatch cdl = new CountDownLatch(m);
                for (int i = 0; i < m; i++) {
                    final int j = i;
                    exec.execute(new Runnable() {
                        @Override
                        public void run() {
                            final AtomicInteger nexts = new AtomicInteger();
                            try {
                                Flowable<String> origin = Flowable.unsafeCreate(new FuncWithErrors(numRetries));
                                TestSubscriberEx<String> ts = new TestSubscriberEx<>();
                                origin.retry()
                                .observeOn(Schedulers.computation()).subscribe(ts);
                                ts.awaitDone(2500, TimeUnit.MILLISECONDS);
                                List<String> onNextEvents = new ArrayList<>(ts.values());
                                if (onNextEvents.size() != numRetries + 2) {
                                    for (Throwable t : ts.errors()) {
                                        onNextEvents.add(t.toString());
                                    }
                                    for (long err = ts.completions(); err != 0; err--) {
                                        onNextEvents.add(""onComplete"");
                                    }
                                    data.put(j, onNextEvents);
                                }
                            } catch (Throwable t) {
                                timeouts.incrementAndGet();
                                System.out.println(j + "" | "" + cdl.getCount() + "" !!! "" + nexts.get());
                            }
                            cdl.countDown();
                        }
                    });
                }
                cdl.await();
                assertEquals(0, timeouts.get());
                if (data.size() > 0) {
                    fail(""Data content mismatch: "" + allSequenceFrequency(data));
                }
            }",loop_control
i,"for (int i = 0; i < m; i++) {
                    final int j = i;
                    exec.execute(new Runnable() {
                        @Override
                        public void run() {
                            final AtomicInteger nexts = new AtomicInteger();
                            try {
                                Flowable<String> origin = Flowable.unsafeCreate(new FuncWithErrors(numRetries));
                                TestSubscriberEx<String> ts = new TestSubscriberEx<>();
                                origin.retry()
                                .observeOn(Schedulers.computation()).subscribe(ts);
                                ts.awaitDone(2500, TimeUnit.MILLISECONDS);
                                List<String> onNextEvents = new ArrayList<>(ts.values());
                                if (onNextEvents.size() != numRetries + 2) {
                                    for (Throwable t : ts.errors()) {
                                        onNextEvents.add(t.toString());
                                    }
                                    for (long err = ts.completions(); err != 0; err--) {
                                        onNextEvents.add(""onComplete"");
                                    }
                                    data.put(j, onNextEvents);
                                }
                            } catch (Throwable t) {
                                timeouts.incrementAndGet();
                                System.out.println(j + "" | "" + cdl.getCount() + "" !!! "" + nexts.get());
                            }
                            cdl.countDown();
                        }
                    });
                }",loop_control
t,"for (Throwable t : ts.errors()) {
                                        onNextEvents.add(t.toString());
                                    }",iterator
t,"{
                            final AtomicInteger nexts = new AtomicInteger();
                            try {
                                Flowable<String> origin = Flowable.unsafeCreate(new FuncWithErrors(numRetries));
                                TestSubscriberEx<String> ts = new TestSubscriberEx<>();
                                origin.retry()
                                .observeOn(Schedulers.computation()).subscribe(ts);
                                ts.awaitDone(2500, TimeUnit.MILLISECONDS);
                                List<String> onNextEvents = new ArrayList<>(ts.values());
                                if (onNextEvents.size() != numRetries + 2) {
                                    for (Throwable t : ts.errors()) {
                                        onNextEvents.add(t.toString());
                                    }
                                    for (long err = ts.completions(); err != 0; err--) {
                                        onNextEvents.add(""onComplete"");
                                    }
                                    data.put(j, onNextEvents);
                                }
                            } catch (Throwable t) {
                                timeouts.incrementAndGet();
                                System.out.println(j + "" | "" + cdl.getCount() + "" !!! "" + nexts.get());
                            }
                            cdl.countDown();
                        }",iterator
err,"for (long err = ts.completions(); err != 0; err--) {
                                        onNextEvents.add(""onComplete"");
                                    }",loop_control
e,"for (Map.Entry<Integer, List<T>> e : its.entrySet()) {
            if (b.length() > 0) {
                b.append("", "");
            }
            b.append(e.getKey()).append(""={"");
            b.append(sequenceFrequency(e.getValue()));
            b.append(""}"");
        }",iterator
curr,"for (Object curr : it) {
            if (sb.length() > 0) {
                if (!curr.equals(prev)) {
                    if (cnt > 1) {
                        sb.append("" x "").append(cnt);
                        cnt = 1;
                    }
                    sb.append("", "");
                    sb.append(curr);
                } else {
                    cnt++;
                }
            } else {
                sb.append(curr);
                cnt++;
            }
            prev = curr;
        }",iterator
i,"for (int i = 0; i < NUM_MSG; i++) {
                    subscriber.onNext(""msg:"" + count.incrementAndGet());
                }",loop_control
i,"for (int i = 0; i < TestHelper.RACE_DEFAULT_LOOPS; i++) {

                TestSubscriber<Integer> ts = source.take(1)
                .map(new Function<Integer, Integer>() {
                    @Override
                    public Integer apply(Integer v) throws Exception {
                        throw error;
                    }
                })
                .retryWhen(new Function<Flowable<Throwable>, Flowable<Integer>>() {
                    @Override
                    public Flowable<Integer> apply(Flowable<Throwable> v)
                            throws Exception {
                        return signaller;
                    }
                }).test();

                Runnable r1 = new Runnable() {
                    @Override
                    public void run() {
                        for (int i = 0; i < TestHelper.RACE_DEFAULT_LOOPS; i++) {
                            source.onNext(1);
                        }
                    }
                };
                Runnable r2 = new Runnable() {
                    @Override
                    public void run() {
                        for (int i = 0; i < TestHelper.RACE_DEFAULT_LOOPS; i++) {
                            signaller.offer(1);
                        }
                    }
                };

                TestHelper.race(r1, r2);

                ts.cancel();
            }",loop_control
s,"{

        final Subscription upstream;
        final String[] values;
        Thread t;

        TestObservable(Subscription s, String... values) {
            this.upstream = s;
            this.values = values;
        }

        @Override
        public void subscribe(final Subscriber<? super String> subscriber) {
            System.out.println(""TestObservable subscribed to ..."");
            subscriber.onSubscribe(upstream);
            t = new Thread(new Runnable() {

                @Override
                public void run() {
                    try {
                        System.out.println(""running TestObservable thread"");
                        for (String s : values) {
                            if (""fail"".equals(s)) {
                                throw new RuntimeException(""Forced Failure"");
                            }
                            System.out.println(""TestObservable onNext: "" + s);
                            subscriber.onNext(s);
                        }
                        System.out.println(""TestObservable onComplete"");
                        subscriber.onComplete();
                    } catch (Throwable e) {
                        System.out.println(""TestObservable onError: "" + e);
                        subscriber.onError(e);
                    }
                }

            });
            System.out.println(""starting TestObservable thread"");
            t.start();
            System.out.println(""done starting TestObservable thread"");
        }
    }",iterator
i,"for (int i = 0; i < 11; i++) {
            TestHelper.assertError(errors, i, TestException.class);
        }",loop_control
i,"for (int i = 0; i < TestHelper.RACE_DEFAULT_LOOPS; i++) {
            final TestSubscriber<Integer> ts = Flowable.just(1).concatWith(Flowable.<Integer>never())
            .flatMapMaybe(Functions.justFunction(Maybe.just(2))).test(0);

            Runnable r1 = new Runnable() {
                @Override
                public void run() {
                    ts.request(1);
                }
            };
            Runnable r2 = new Runnable() {
                @Override
                public void run() {
                    ts.cancel();
                }
            };

            TestHelper.race(r1, r2);
        }",loop_control
i,"for (int i = 0; i < TestHelper.RACE_DEFAULT_LOOPS; i++) {
            MaybeSubject<Integer> ss1 = MaybeSubject.create();
            MaybeSubject<Integer> ss2 = MaybeSubject.create();

            TestSubscriber<Integer> ts = Flowable.just(ss1, ss2).flatMapMaybe(v -> v)
            .test();

            TestHelper.race(
                    () -> ss1.onSuccess(1),
                    () -> ss2.onSuccess(1)
            );

            ts.assertResult(1, 1);
        }",loop_control
i,"for (int i = 0; i < TestHelper.RACE_DEFAULT_LOOPS; i++) {
            MaybeSubject<Integer> ss1 = MaybeSubject.create();
            MaybeSubject<Integer> ss2 = MaybeSubject.create();

            TestSubscriber<Integer> ts = Flowable.just(ss1, ss2).flatMapMaybe(v -> v)
            .test();

            TestHelper.race(
                    () -> ss1.onSuccess(1),
                    () -> ss2.onComplete()
            );

            ts.assertResult(1);
        }",loop_control
arg,"for (String arg : args) {
            list.add(arg);
        }",iterator
i,"for (int i = 0; i < TestHelper.RACE_DEFAULT_LOOPS; i++) {
                AtomicReference<Subscriber<? super Integer>> ref1 = new AtomicReference<>();
                AtomicReference<Subscriber<? super Integer>> ref2 = new AtomicReference<>();

                Flowable<Integer> f1 = Flowable.<Integer>fromPublisher(ref1::set);
                Flowable<Integer> f2 = Flowable.<Integer>fromPublisher(ref2::set);

                TestSubscriber<Flowable<Integer>> ts = BehaviorProcessor.createDefault(1)
                .window(f1, v -> f2)
                .doOnNext(w -> w.test())
                .test();

                ref1.get().onSubscribe(new BooleanSubscription());
                ref1.get().onNext(1);
                ref2.get().onSubscribe(new BooleanSubscription());

                TestHelper.race(
                        () -> ref1.get().onError(ex1),
                        () -> ref2.get().onError(ex2)
                );

                ts.assertError(RuntimeException.class);

                if (!errors.isEmpty()) {
                    TestHelper.assertUndeliverable(errors, 0, TestException.class);
                }

                errors.clear();
            }",loop_control
i,"for (int i = 0; i < TestHelper.RACE_DEFAULT_LOOPS; i++) {
            List<Throwable> errors = TestHelper.trackPluginErrors();
            try {
                final PublishProcessor<Integer> pp1 = PublishProcessor.create();
                final PublishProcessor<Integer> pp2 = PublishProcessor.create();

                TestSubscriberEx<Integer> ts = pp1.concatMapEager(new Function<Integer, Flowable<Integer>>() {
                    @Override
                    public Flowable<Integer> apply(Integer v) throws Exception {
                        return pp2;
                    }
                }).to(TestHelper.<Integer>testConsumer());

                final TestException ex1 = new TestException();
                final TestException ex2 = new TestException();

                pp1.onNext(1);

                Runnable r1 = new Runnable() {
                    @Override
                    public void run() {
                        pp1.onError(ex1);
                    }
                };
                Runnable r2 = new Runnable() {
                    @Override
                    public void run() {
                        pp2.onError(ex2);
                    }
                };

                TestHelper.race(r1, r2);

                ts.assertSubscribed().assertNoValues().assertNotComplete();

                Throwable ex = ts.errors().get(0);

                if (ex instanceof CompositeException) {
                    List<Throwable> es = TestHelper.errorList(ts);
                    TestHelper.assertError(es, 0, TestException.class);
                    TestHelper.assertError(es, 1, TestException.class);
                } else {
                    ts.assertError(TestException.class);
                    if (!errors.isEmpty()) {
                        TestHelper.assertUndeliverable(errors, 0, TestException.class);
                    }
                }
            } finally {
                RxJavaPlugins.reset();
            }
        }",loop_control
i,"for (int i = 0; i < TestHelper.RACE_DEFAULT_LOOPS; i++) {
            final PublishProcessor<Integer> pp1 = PublishProcessor.create();

            final TestSubscriber<Integer> ts = pp1.concatMapEager(new Function<Integer, Flowable<Integer>>() {
                @Override
                public Flowable<Integer> apply(Integer v) throws Exception {
                    return Flowable.never();
                }
            }).test();

            Runnable r1 = new Runnable() {
                @Override
                public void run() {
                    pp1.onNext(1);
                }
            };
            Runnable r2 = new Runnable() {
                @Override
                public void run() {
                    ts.cancel();
                }
            };

            TestHelper.race(r1, r2);

            ts.assertEmpty();
        }",loop_control
i,"for (int i = 0; i < TestHelper.RACE_DEFAULT_LOOPS; i++) {
            final PublishProcessor<Integer> pp = PublishProcessor.create();

            final TestSubscriber<Integer> ts = new TestSubscriber<>(0L);

            Flowable.just(1)
            .concatMapEager(Functions.justFunction(pp))
            .subscribe(ts);

            Runnable r1 = new Runnable() {
                @Override
                public void run() {
                    pp.onComplete();
                }
            };

            Runnable r2 = new Runnable() {
                @Override
                public void run() {
                    ts.cancel();
                }
            };

            TestHelper.race(r1, r2);
        }",loop_control
i,"for (int i = 0; i < 100; i++) {
            List<Integer> lst = new ArrayList<>();
            list[i] = lst;
            for (int k = 1; k <= 10; k++) {
                lst.add((i) * 10 + k);
            }
        }",loop_control
i,"for (int i = 0; i < 1000; i++) {
            final PublishProcessor<Integer> pp = PublishProcessor.create();
            final CompletableSubject cs = CompletableSubject.create();

            TestSubscriber<Integer> ts = pp.mergeWith(cs).test();

            Runnable r1 = new Runnable() {
                @Override
                public void run() {
                    pp.onNext(1);
                    pp.onComplete();
                }
            };

            Runnable r2 = new Runnable() {
                @Override
                public void run() {
                    cs.onComplete();
                }
            };

            TestHelper.race(r1, r2);

            ts.assertResult(1);
        }",loop_control
i,"for (int i = 0; i < n; i++) {
            source.onNext(i);
            if (i % 3 == 2 && i < n - 1) {
                boundary.onNext(i / 3);
            }
        }",loop_control
i,"for (int i = 0; i < 3; i++) {
                verify(mo).onNext(j + i);
            }",loop_control
mo,"{
                final Subscriber<Object> mo = TestHelper.mockSubscriber();
                values.add(mo);

                args.subscribe(mo);
            }",iterator
mo,"for (Subscriber<Object> mo : values) {
            verify(mo, never()).onError(any(Throwable.class));
            for (int i = 0; i < 3; i++) {
                verify(mo).onNext(j + i);
            }
            verify(mo).onComplete();
            j += 3;
        }",iterator
mo,"{
                final Subscriber<Object> mo = TestHelper.mockSubscriber();
                values.add(mo);

                args.subscribe(mo);
            }",iterator
mo,"for (Subscriber<Object> mo : values) {
            for (int i = 0; i < 3; i++) {
                verify(mo).onNext(j + i);
            }
            verify(mo).onComplete();
            verify(mo, never()).onError(any(Throwable.class));
            j += 3;
        }",iterator
i,"for (int i = 0; i < n; i++) {
            source.onNext(i);
            if (i % 3 == 2 && i < n - 1) {
                boundary.onNext(i / 3);
            }
        }",loop_control
i,"for (int i = 0; i < 3; i++) {
                verify(mo).onNext(j + i);
            }",loop_control
i,"for (int i = 0; i < TestHelper.RACE_LONG_LOOPS; i++) {
            List<Throwable> errors = TestHelper.trackPluginErrors();
            try {
                final AtomicReference<Subscriber<? super Object>> refMain = new AtomicReference<>();
                final AtomicReference<Subscriber<? super Object>> ref = new AtomicReference<>();

                TestSubscriberEx<Flowable<Object>> ts = new Flowable<Object>() {
                    @Override
                    protected void subscribeActual(Subscriber<? super Object> subscriber) {
                        subscriber.onSubscribe(new BooleanSubscription());
                        refMain.set(subscriber);
                    }
                }
                .window(new Flowable<Object>() {
                    @Override
                    protected void subscribeActual(Subscriber<? super Object> subscriber) {
                        subscriber.onSubscribe(new BooleanSubscription());
                        ref.set(subscriber);
                    }
                })
                .to(TestHelper.<Flowable<Object>>testConsumer());

                Runnable r1 = new Runnable() {
                    @Override
                    public void run() {
                        refMain.get().onComplete();
                    }
                };
                Runnable r2 = new Runnable() {
                    @Override
                    public void run() {
                        ref.get().onError(ex);
                    }
                };

                TestHelper.race(r1, r2);

                ts
                .assertValueCount(1)
                .assertTerminated();

                if (!errors.isEmpty()) {
                    TestHelper.assertUndeliverable(errors, 0, TestException.class);
                }
            } finally {
                RxJavaPlugins.reset();
            }
        }",loop_control
i,"for (int i = 0; i < TestHelper.RACE_LONG_LOOPS; i++) {
            final AtomicReference<Subscriber<? super Object>> refMain = new AtomicReference<>();
            final AtomicReference<Subscriber<? super Object>> ref = new AtomicReference<>();

            TestSubscriber<Flowable<Object>> ts = new Flowable<Object>() {
                @Override
                protected void subscribeActual(Subscriber<? super Object> subscriber) {
                    subscriber.onSubscribe(new BooleanSubscription());
                    refMain.set(subscriber);
                }
            }
            .window(new Flowable<Object>() {
                @Override
                protected void subscribeActual(Subscriber<? super Object> subscriber) {
                    subscriber.onSubscribe(new BooleanSubscription());
                    ref.set(subscriber);
                }
            })
            .test();

            Runnable r1 = new Runnable() {
                @Override
                public void run() {
                    refMain.get().onNext(1);
                }
            };
            Runnable r2 = new Runnable() {
                @Override
                public void run() {
                    ref.get().onNext(1);
                }
            };

            TestHelper.race(r1, r2);

            ts
            .assertValueCount(2)
            .assertNotComplete()
            .assertNoErrors();
        }",loop_control
i,"for (int i = 0; i < TestHelper.RACE_LONG_LOOPS; i++) {
            final AtomicReference<Subscriber<? super Object>> refMain = new AtomicReference<>();
            final AtomicReference<Subscriber<? super Object>> ref = new AtomicReference<>();

            final TestSubscriber<Flowable<Object>> ts = new Flowable<Object>() {
                 @Override
                 protected void subscribeActual(Subscriber<? super Object> subscriber) {
                     subscriber.onSubscribe(new BooleanSubscription());
                     refMain.set(subscriber);
                 }
             }
             .window(new Flowable<Object>() {
                 @Override
                 protected void subscribeActual(Subscriber<? super Object> subscriber) {
                     final AtomicInteger counter = new AtomicInteger();
                     subscriber.onSubscribe(new Subscription() {

                         @Override
                         public void cancel() {
                             // about a microsecond
                             for (int i = 0; i < 100; i++) {
                                 counter.incrementAndGet();
                             }
                         }

                         @Override
                        public void request(long n) {
                        }
                     });
                     ref.set(subscriber);
                 }
             })
             .test();

             Runnable r1 = new Runnable() {
                 @Override
                 public void run() {
                     ts.cancel();
                 }
             };
             Runnable r2 = new Runnable() {
                 @Override
                 public void run() {
                     Subscriber<Object> subscriber = ref.get();
                     subscriber.onNext(1);
                     subscriber.onComplete();
                 }
             };

             TestHelper.race(r1, r2);
        }",loop_control
i,"for (int i = 0; i < TestHelper.RACE_LONG_LOOPS; i++) {
           final AtomicReference<Subscriber<? super Object>> refMain = new AtomicReference<>();
           final AtomicReference<Subscriber<? super Object>> ref = new AtomicReference<>();

           final TestSubscriber<Flowable<Object>> ts = new Flowable<Object>() {
               @Override
               protected void subscribeActual(Subscriber<? super Object> subscriber) {
                   subscriber.onSubscribe(new BooleanSubscription());
                   refMain.set(subscriber);
               }
           }
           .window(new Flowable<Object>() {
               @Override
               protected void subscribeActual(Subscriber<? super Object> subscriber) {
                   final AtomicInteger counter = new AtomicInteger();
                   subscriber.onSubscribe(new Subscription() {

                       @Override
                       public void cancel() {
                           // about a microsecond
                           for (int i = 0; i < 100; i++) {
                               counter.incrementAndGet();
                           }
                       }

                       @Override
                      public void request(long n) {
                      }
                   });
                   ref.set(subscriber);
               }
           })
           .test();

            Runnable r1 = new Runnable() {
                @Override
                public void run() {
                    ts.cancel();
                }
            };
            Runnable r2 = new Runnable() {
                @Override
                public void run() {
                    Subscriber<Object> subscriber = ref.get();
                    subscriber.onNext(1);
                    subscriber.onError(ex);
                }
            };

            TestHelper.race(r1, r2);
        }",loop_control
i,"for (int i = 0; i < n; i++) {
                List<Flowable<?>> sources = new ArrayList<>();
                List<String> expected = new ArrayList<>();
                expected.add(val);

                for (int j = 0; j < i; j++) {
                    sources.add(Flowable.just(val));
                    expected.add(String.valueOf(val));
                }

                TestSubscriber<String> ts = new TestSubscriber<>();

                PublishProcessor<String> main = PublishProcessor.create();

                main.withLatestFrom(sources, toArray).subscribe(ts);

                ts.assertNoValues();

                main.onNext(val);
                main.onComplete();

                ts.assertValue(expected.toString());
                ts.assertNoErrors();
                ts.assertComplete();
            }",loop_control
j,"for (int j = 0; j < i; j++) {
                    sources.add(Flowable.just(val));
                    expected.add(String.valueOf(val));
                }",loop_control
i,"for (int i = 0; i < TestHelper.RACE_DEFAULT_LOOPS; i++) {
            final PublishProcessor<Integer> pp0 = PublishProcessor.create();
            final PublishProcessor<Integer> pp1 = PublishProcessor.create();
            final PublishProcessor<Integer> pp2 = PublishProcessor.create();
            final PublishProcessor<Integer> pp3 = PublishProcessor.create();

            final Flowable<Object> source = pp0.withLatestFrom(pp1, pp2, pp3, new Function4<Object, Integer, Integer, Integer, Object>() {
                @Override
                public Object apply(Object a, Integer b, Integer c, Integer d)
                        throws Exception {
                    return a;
                }
            });

            final TestSubscriber<Object> ts = new TestSubscriber<>();

            Runnable r1 = new Runnable() {
                @Override
                public void run() {
                    source.subscribe(ts);
                }
            };

            Runnable r2 = new Runnable() {
                @Override
                public void run() {
                    ts.cancel();
                }
            };

            TestHelper.race(r1, r2);

            ts.assertEmpty();

            assertFalse(pp0.hasSubscribers());
            assertFalse(pp1.hasSubscribers());
            assertFalse(pp2.hasSubscribers());
            assertFalse(pp3.hasSubscribers());
        }",loop_control
i,"for (int i = 0; i < TestHelper.RACE_DEFAULT_LOOPS; i++) {
            final PublishProcessor<Integer> pp0 = PublishProcessor.create();
            final PublishProcessor<Integer> pp1 = PublishProcessor.create();
            final PublishProcessor<Integer> pp2 = PublishProcessor.create();
            final PublishProcessor<Integer> pp3 = PublishProcessor.create();

            final Flowable<Object> source = pp0.withLatestFrom(pp1, pp2, pp3, new Function4<Object, Integer, Integer, Integer, Object>() {
                @Override
                public Object apply(Object a, Integer b, Integer c, Integer d)
                        throws Exception {
                    return a;
                }
            });

            final TestSubscriber<Object> ts = new TestSubscriber<>();

            Runnable r1 = new Runnable() {
                @Override
                public void run() {
                    source.subscribe(ts);
                }
            };

            Runnable r2 = new Runnable() {
                @Override
                public void run() {
                    pp1.onComplete();
                }
            };

            TestHelper.race(r1, r2);

            ts.assertResult();

            assertFalse(pp0.hasSubscribers());
            assertFalse(pp1.hasSubscribers());
            assertFalse(pp2.hasSubscribers());
            assertFalse(pp3.hasSubscribers());
        }",loop_control
i,"for (int i = 0; i < TestHelper.RACE_DEFAULT_LOOPS; i++) {
            final TestScheduler sch = new TestScheduler();

            final PublishProcessor<Integer> pp = PublishProcessor.create();

            TestSubscriberEx<Integer> ts = pp.timeout(1, TimeUnit.SECONDS, sch).to(TestHelper.<Integer>testConsumer());

            Runnable r1 = new Runnable() {
                @Override
                public void run() {
                    pp.onNext(1);
                }
            };

            Runnable r2 = new Runnable() {
                @Override
                public void run() {
                    sch.advanceTimeBy(1, TimeUnit.SECONDS);
                }
            };

            TestHelper.race(r1, r2);

            if (ts.values().size() != 0) {
                if (ts.errors().size() != 0) {
                    ts.assertFailure(TimeoutException.class, 1);
                    ts.assertErrorMessage(timeoutMessage(1, TimeUnit.SECONDS));
                } else {
                    ts.assertValuesOnly(1);
                }
            } else {
                ts.assertFailure(TimeoutException.class);
                ts.assertErrorMessage(timeoutMessage(1, TimeUnit.SECONDS));
            }
        }",loop_control
i,"for (int i = 0; i < TestHelper.RACE_DEFAULT_LOOPS; i++) {
            final TestScheduler sch = new TestScheduler();

            final PublishProcessor<Integer> pp = PublishProcessor.create();

            TestSubscriberEx<Integer> ts = pp.timeout(1, TimeUnit.SECONDS, sch, Flowable.just(2)).to(TestHelper.<Integer>testConsumer());

            Runnable r1 = new Runnable() {
                @Override
                public void run() {
                    pp.onNext(1);
                }
            };

            Runnable r2 = new Runnable() {
                @Override
                public void run() {
                    sch.advanceTimeBy(1, TimeUnit.SECONDS);
                }
            };

            TestHelper.race(r1, r2);

            if (ts.isTerminated()) {
                int c = ts.values().size();
                if (c == 1) {
                    int v = ts.values().get(0);
                    assertTrue("""" + v, v == 1 || v == 2);
                } else {
                    ts.assertResult(1, 2);
                }
            } else {
                ts.assertValuesOnly(1);
            }
        }",loop_control
bs,"{
            BooleanSubscription bs = new BooleanSubscription();
            s.onSubscribe(bs);
            long i = 0;
            while (!bs.isCancelled()) {
                s.onNext(i++);
            }
        }",maybe_loop_control
j,"for (int j = 0; j < TestHelper.RACE_LONG_LOOPS; j++) {
            List<Throwable> errors = TestHelper.trackPluginErrors();
            try {
                final PublishProcessor<Integer> pp = PublishProcessor.create();

                TestObserver<Integer> to = pp.onBackpressureBuffer(4, false, true)
                .observeOn(Schedulers.io())
                .map(Functions.<Integer>identity())
                .observeOn(Schedulers.single())
                .firstOrError()
                .test();

                for (int i = 0; pp.hasSubscribers(); i++) {
                    pp.onNext(i);
                }

                to
                .awaitDone(5, TimeUnit.SECONDS)
                ;

                if (!errors.isEmpty()) {
                    throw new CompositeException(errors);
                }

                to.assertResult(0);
            } finally {
                RxJavaPlugins.reset();
            }
        }",loop_control
i,"for (int i = 0; pp.hasSubscribers(); i++) {
                    pp.onNext(i);
                }",loop_control
i,"for (int i = 0; i < count; i++) {
                            Event e = new Event();
                            e.source = i % groupCount;
                            e.message = ""Event-"" + i;
                            subscriber.onNext(e);
                        }",loop_control
bs,"{
                BooleanSubscription bs = new BooleanSubscription();
                op.onSubscribe(bs);
                subscribeCounter.incrementAndGet();
                int i = 0;
                while (!bs.isCancelled()) {
                    i++;
                    Event e = new Event();
                    e.source = i % numGroups;
                    e.message = ""Event-"" + i;
                    op.onNext(e);
                    sentEventCounter.incrementAndGet();
                }
                op.onComplete();
            }",maybe_loop_control
j,"for (int j = 0; j < 1000; j++) {
            Flowable.merge(
                    Flowable.range(0, n)
                    .groupBy(new Function<Integer, Object>() {
                        @Override
                        public Object apply(Integer i) {
                            return i % (Flowable.bufferSize() + 2);
                        }
                    })
                    .observeOn(Schedulers.computation(), false, n)
            , n)
            .blockingLast();
        }",loop_control
j,"for (int j = 0; j < 1000; j++) {
            Flowable.merge(
                    Flowable.range(0, 500)
                    .groupBy(new Function<Integer, Object>() {
                        @Override
                        public Object apply(Integer i) {
                            return i % (Flowable.bufferSize() + 2);
                        }
                    })
                    .observeOn(Schedulers.computation())
            ).blockingLast();
        }",loop_control
i,"for (int i = 0; i < TestHelper.RACE_LONG_LOOPS; i++) {

            final TestSubscriber<Integer> ts = new TestSubscriber<>();

            final PublishProcessor<Integer> pp = PublishProcessor.create();

            pp.groupBy(new Function<Integer, Integer>() {
                @Override
                public Integer apply(Integer v) throws Throwable {
                    return v % 10;
                }
            }, Functions.<Integer>identity(), false, 2048)
            .flatMap(new Function<GroupedFlowable<Integer, Integer>, GroupedFlowable<Integer, Integer>>() {
                @Override
                public GroupedFlowable<Integer, Integer> apply(GroupedFlowable<Integer, Integer> v)
                        throws Throwable {
                    return v;
                }
            })
            .subscribe(ts);

            Runnable r1 = new Runnable() {
                @Override
                public void run() {
                    for (int j = 0; j < 1000; j++) {
                        pp.onNext(j);
                    }
                }
            };

            Runnable r2 = new Runnable() {
                @Override
                public void run() {
                    ts.cancel();
                }
            };

            TestHelper.race(r1, r2);

            assertFalse(""Round "" + i, pp.hasSubscribers());
        }",loop_control
j,"for (int j = 0; j < 1000; j++) {
                        pp.onNext(j);
                    }",loop_control
done,"{
        final List<TestSubscriber<Integer>> tss = new ArrayList<>();
        final AtomicInteger counter = new AtomicInteger();
        final AtomicBoolean done = new AtomicBoolean();
        Flowable.range(1, 1000)
                .doOnNext(new Consumer<Integer>() {
                    @Override
                    public void accept(Integer v) throws Exception {
                        counter.getAndIncrement();
                    }
                })
                .groupBy(Functions.justFunction(1))
                .subscribe(new Consumer<GroupedFlowable<Integer, Integer>>() {
                    @Override
                    public void accept(GroupedFlowable<Integer, Integer> v) throws Exception {
                        TestSubscriber<Integer> ts = TestSubscriber.create(0L);
                        tss.add(ts);
                        v.subscribe(ts);
                    }
                }, Functions.emptyConsumer(), new Action() {
                    @Override
                    public void run() throws Exception {
                        done.set(true);
                    }
                });

        while (!done.get()) {
            tss.remove(0).cancel();
        }

        assertEquals(1000, counter.get());
    }",maybe_loop_control
i,"for (int i = 0; i < TestHelper.RACE_DEFAULT_LOOPS; i++) {
            PublishProcessor<Integer> pp = PublishProcessor.create();

            TestSubscriber<Integer> ts = TestSubscriber.create();

            CountDownLatch cdl = new CountDownLatch(1);

            pp.groupBy(v -> 1)
            .doOnNext(g -> {
                TestHelper.raceOther(() -> {
                    g.subscribe(ts);
                }, cdl);
            })
            .test();

            pp.onNext(1);

            cdl.await();

            ts.assertValueCount(1);
        }",loop_control
i,"for (int i = 0; i < 1000; i++) {
            issue6974Part2Case2();
        }",loop_control
i,"for (int i = 0; i < 1000; i++) {
            issue6974Part2Case1NoEvict();
        }",loop_control
i,"for (int i = 0; i < 100; i++) {
            issue6974Part2Case1ObserveOnNoCapHide();
        }",loop_control
i,"for (int i = 0; i < 100; i++) {
            issue6974Part2Case1ObserveOnHide();
        }",loop_control
i,"for (int i = 0; i < 200; i++) {
            System.out.println(""issue6982Case1Loop ""  + i);
            issue6982Case1();
        }",loop_control
i,"for (int i = 0; i < 200; i++) {
            System.out.println(""issue6982Case2Loop ""  + i);
            issue6982Case2();
        }",loop_control
bs,"{
            BooleanSubscription bs = new BooleanSubscription();
            s.onSubscribe(bs);
            long i = 0;
            while (!bs.isCancelled() && i < 500) {
                s.onNext(i++);
            }
            if (!bs.isCancelled()) {
                s.onComplete();
            }
        }",maybe_loop_control
i,"{
            BooleanSubscription bs = new BooleanSubscription();
            s.onSubscribe(bs);
            long i = 0;
            while (!bs.isCancelled() && i < 500) {
                s.onNext(i++);
            }
            if (!bs.isCancelled()) {
                s.onComplete();
            }
        }",loop_control
t,"for (Thread t : Thread.getAllStackTraces().keySet()) {
            if (t.getName().startsWith(""RxNewThread"")) {
                count++;
            }
        }",iterator
t,"for (Thread t : Thread.getAllStackTraces().keySet()) {
            if (t.getName().startsWith(""RxNewThread"")) {
                --count;
            }
        }",iterator
unsubscribed,"{

        final AtomicBoolean unsubscribed = new AtomicBoolean();
        final CountDownLatch latch = new CountDownLatch(1);

        Flowable<Flowable<Long>> source = Flowable.unsafeCreate(new Publisher<Flowable<Long>>() {

            @Override
            public void subscribe(final Subscriber<? super Flowable<Long>> subscriber) {
                // verbose on purpose so I can track the inside of it
                final Subscription s = new Subscription() {

                    @Override
                    public void request(long n) {

                    }

                    @Override
                    public void cancel() {
                        System.out.println(""*** unsubscribed"");
                        unsubscribed.set(true);
                    }

                };
                subscriber.onSubscribe(s);

                new Thread(new Runnable() {

                    @Override
                    public void run() {

                        while (!unsubscribed.get()) {
                            subscriber.onNext(Flowable.just(1L, 2L));
                        }
                        System.out.println(""Done looping after unsubscribe: "" + unsubscribed.get());
                        subscriber.onComplete();

                        // mark that the thread is finished
                        latch.countDown();
                    }
                }).start();
            }

        });

        final AtomicInteger count = new AtomicInteger();
        Flowable.merge(source).take(6).blockingForEach(new Consumer<Long>() {

            @Override
            public void accept(Long v) {
                System.out.println(""Value: "" + v);
                int c = count.incrementAndGet();
                if (c > 6) {
                    fail(""Should be only 6"");
                }

            }
        });

        latch.await(1000, TimeUnit.MILLISECONDS);

        System.out.println(""unsubscribed: "" + unsubscribed.get());

        assertTrue(unsubscribed.get());

    }",maybe_loop_control
i,"for (int i = 0; i < 100; i++) {
            System.out.println(""testSynchronizationOfMultipleSequencesLoop > "" + i);
            synchronizationOfMultipleSequences();
        }",loop_control
timeout,"{
        final TestASynchronousFlowable f1 = new TestASynchronousFlowable();
        final TestASynchronousFlowable f2 = new TestASynchronousFlowable();

        // use this latch to cause onNext to wait until we're ready to let it go
        final CountDownLatch endLatch = new CountDownLatch(1);

        final AtomicInteger concurrentCounter = new AtomicInteger();
        final AtomicInteger totalCounter = new AtomicInteger();

        final AtomicReference<Throwable> error = new AtomicReference<>();

        Flowable<String> m = Flowable.merge(Flowable.unsafeCreate(f1), Flowable.unsafeCreate(f2));
        m.subscribe(new DefaultSubscriber<String>() {

            @Override
            public void onComplete() {

            }

            @Override
            public void onError(Throwable e) {
                error.set(e);
            }

            @Override
            public void onNext(String v) {
                totalCounter.incrementAndGet();
                concurrentCounter.incrementAndGet();
                try {
                    // avoid deadlocking the main thread
                    if (Thread.currentThread().getName().equals(""TestASynchronousFlowable"")) {
                        // wait here until we're done asserting
                        endLatch.await();
                    }
                } catch (InterruptedException e) {
                    e.printStackTrace();
                    throw new RuntimeException(""failed"", e);
                } finally {
                    concurrentCounter.decrementAndGet();
                }
            }

        });

        // wait for both Flowables to send (one should be blocked)
        f1.onNextBeingSent.await();
        f2.onNextBeingSent.await();

        // I can't think of a way to know for sure that both threads have or are trying to send onNext
        // since I can't use a CountDownLatch for ""after"" onNext since I want to catch during it
        // but I can't know for sure onNext is invoked
        // so I'm unfortunately reverting to using a Thread.sleep to allow the process scheduler time
        // to make sure after o1.onNextBeingSent and o2.onNextBeingSent are hit that the following
        // onNext is invoked.

        int timeout = 20;

        while (timeout-- > 0 && concurrentCounter.get() != 1) {
            Thread.sleep(100);
        }

        try { // in try/finally so threads are released via latch countDown even if assertion fails
            if (error.get() != null) {
                throw ExceptionHelper.wrapOrThrow(error.get());
            }

            assertEquals(1, concurrentCounter.get());
        } finally {
            // release so it can finish
            endLatch.countDown();
        }

        try {
            f1.t.join();
            f2.t.join();
        } catch (InterruptedException e) {
            throw new RuntimeException(e);
        }

        assertEquals(2, totalCounter.get());
        assertEquals(0, concurrentCounter.get());
    }",loop_control
concurrentCounter,"{
        final TestASynchronousFlowable f1 = new TestASynchronousFlowable();
        final TestASynchronousFlowable f2 = new TestASynchronousFlowable();

        // use this latch to cause onNext to wait until we're ready to let it go
        final CountDownLatch endLatch = new CountDownLatch(1);

        final AtomicInteger concurrentCounter = new AtomicInteger();
        final AtomicInteger totalCounter = new AtomicInteger();

        final AtomicReference<Throwable> error = new AtomicReference<>();

        Flowable<String> m = Flowable.merge(Flowable.unsafeCreate(f1), Flowable.unsafeCreate(f2));
        m.subscribe(new DefaultSubscriber<String>() {

            @Override
            public void onComplete() {

            }

            @Override
            public void onError(Throwable e) {
                error.set(e);
            }

            @Override
            public void onNext(String v) {
                totalCounter.incrementAndGet();
                concurrentCounter.incrementAndGet();
                try {
                    // avoid deadlocking the main thread
                    if (Thread.currentThread().getName().equals(""TestASynchronousFlowable"")) {
                        // wait here until we're done asserting
                        endLatch.await();
                    }
                } catch (InterruptedException e) {
                    e.printStackTrace();
                    throw new RuntimeException(""failed"", e);
                } finally {
                    concurrentCounter.decrementAndGet();
                }
            }

        });

        // wait for both Flowables to send (one should be blocked)
        f1.onNextBeingSent.await();
        f2.onNextBeingSent.await();

        // I can't think of a way to know for sure that both threads have or are trying to send onNext
        // since I can't use a CountDownLatch for ""after"" onNext since I want to catch during it
        // but I can't know for sure onNext is invoked
        // so I'm unfortunately reverting to using a Thread.sleep to allow the process scheduler time
        // to make sure after o1.onNextBeingSent and o2.onNextBeingSent are hit that the following
        // onNext is invoked.

        int timeout = 20;

        while (timeout-- > 0 && concurrentCounter.get() != 1) {
            Thread.sleep(100);
        }

        try { // in try/finally so threads are released via latch countDown even if assertion fails
            if (error.get() != null) {
                throw ExceptionHelper.wrapOrThrow(error.get());
            }

            assertEquals(1, concurrentCounter.get());
        } finally {
            // release so it can finish
            endLatch.countDown();
        }

        try {
            f1.t.join();
            f2.t.join();
        } catch (InterruptedException e) {
            throw new RuntimeException(e);
        }

        assertEquals(2, totalCounter.get());
        assertEquals(0, concurrentCounter.get());
    }",maybe_loop_control
s,"for (String s : valuesToReturn) {
                if (s == null) {
                    System.out.println(""throwing exception"");
                    subscriber.onError(new NullPointerException());
                } else {
                    subscriber.onNext(s);
                }
            }",iterator
i,"for (int i = 0; i < 10; i++) {
            TestScheduler scheduler1 = new TestScheduler();
            AtomicBoolean os1 = new AtomicBoolean(false);
            Flowable<Long> f1 = createFlowableOf5IntervalsOf1SecondIncrementsWithSubscriptionHook(scheduler1, os1);

            TestScheduler scheduler2 = new TestScheduler();
            AtomicBoolean os2 = new AtomicBoolean(false);
            Flowable<Long> f2 = createFlowableOf5IntervalsOf1SecondIncrementsWithSubscriptionHook(scheduler2, os2);

            TestSubscriber<Long> ts = new TestSubscriber<>();
            Flowable.merge(f1, f2).subscribe(ts);

            // we haven't incremented time so nothing should be received yet
            ts.assertNoValues();

            scheduler1.advanceTimeBy(3, TimeUnit.SECONDS);
            scheduler2.advanceTimeBy(2, TimeUnit.SECONDS);

            ts.assertValues(0L, 1L, 2L, 0L, 1L);
            // not unsubscribed yet
            assertFalse(os1.get());
            assertFalse(os2.get());

            // early unsubscribe
            ts.cancel();

            assertTrue(os1.get());
            assertTrue(os2.get());

            ts.assertValues(0L, 1L, 2L, 0L, 1L);
        }",loop_control
i,"for (int i = 0; i < 10; i++) {
            Flowable<Integer> merge = Flowable.merge(f.onBackpressureBuffer(), f.onBackpressureBuffer(), f.onBackpressureBuffer());
            TestSubscriberEx<Integer> ts = new TestSubscriberEx<>();
            merge.subscribe(ts);

            ts.awaitDone(3, TimeUnit.SECONDS);
            ts.assertTerminated();
            ts.assertNoErrors();
            ts.assertComplete();
            List<Integer> onNextEvents = ts.values();
            assertEquals(30000, onNextEvents.size());
            //            System.out.println(""onNext: "" + onNextEvents.size() + "" onComplete: "" + ts.getOnCompletedEvents().size());
        }",loop_control
i,"for (int i = 0; i < 100; i++) {
                                s.onNext(1);
                                try {
                                    Thread.sleep(1);
                                } catch (InterruptedException e) {
                                    e.printStackTrace();
                                }
                            }",loop_control
i,"for (int i = 0; i < 10; i++) {
            Flowable<Integer> merge = Flowable.merge(f, f, f);
            TestSubscriber<Integer> ts = new TestSubscriber<>();
            merge.subscribe(ts);

            ts.awaitDone(10, TimeUnit.SECONDS);
            ts.assertComplete();
            List<Integer> onNextEvents = ts.values();
            assertEquals(300, onNextEvents.size());
            //            System.out.println(""onNext: "" + onNextEvents.size() + "" onComplete: "" + ts.getOnCompletedEvents().size());
        }",loop_control
i,"for (int i = 0; i < 10000; i++) {
                                s.onNext(i);
                            }",loop_control
i,"for (int i = 0; i < 10; i++) {
            Flowable<Integer> merge = Flowable.merge(f.onBackpressureBuffer(), f.onBackpressureBuffer(), f.onBackpressureBuffer());
            TestSubscriber<Integer> ts = new TestSubscriber<>();
            merge.subscribe(ts);

            ts.awaitDone(10, TimeUnit.SECONDS);
            ts.assertNoErrors();
            ts.assertComplete();
            List<Integer> onNextEvents = ts.values();
            assertEquals(30000, onNextEvents.size());
            //                System.out.println(""onNext: "" + onNextEvents.size() + "" onComplete: "" + ts.getOnCompletedEvents().size());
        }",loop_control
i,"for (int i = 0; i < 1000; i++) {
            System.err.flush();
            System.out.println(""---"");
            System.out.flush();
            backpressureUpstream2();
        }",loop_control
s,"for (String s : messages) {
                    System.out.println(""DEBUG => "" + s);
                }",iterator
i,"for (int i = 0; i < 1000; i++) {
            list.add(i);
        }",loop_control
req,"for (final int req : new int[] { 16, 32, 64, 128, 256 }) {
            TestSubscriberEx<Integer> ts = new TestSubscriberEx<Integer>(req) {
                int remaining = req;

                @Override
                public void onNext(Integer t) {
                    super.onNext(t);
                    if (--remaining == 0) {
                        remaining = req;
                        request(req);
                    }
                }
            };
            runMerge(toScalar, ts);
        }",iterator
req,"for (final int req : new int[] { 16, 32, 64, 128, 256 }) {
            TestSubscriberEx<Integer> ts = new TestSubscriberEx<Integer>(req) {
                int remaining = req;
                @Override
                public void onNext(Integer t) {
                    super.onNext(t);
                    if (--remaining == 0) {
                        remaining = req;
                        request(req);
                    }
                }
            };
            runMerge(toHiddenScalar, ts);
        }",iterator
i,"for (int i = 1; i < 100; i++) {

            @SuppressWarnings(""unchecked"")
            Flowable<Integer>[] sources = new Flowable[i];
            Arrays.fill(sources, Flowable.just(1));
            Integer[] expected = new Integer[i];
            for (int j = 0; j < i; j++) {
                expected[j] = 1;
            }

            Flowable.mergeArray(sources)
            .test()
            .assertResult(expected);
        }",loop_control
j,"for (int j = 0; j < i; j++) {
                expected[j] = 1;
            }",loop_control
s,"{

        final Subscription upstream;
        final String[] values;
        Thread t;

        TestFlowable(Subscription s, String... values) {
            this.upstream = s;
            this.values = values;
        }

        @Override
        public void subscribe(final Subscriber<? super String> subscriber) {
            System.out.println(""TestFlowable subscribed to ..."");
            subscriber.onSubscribe(upstream);
            t = new Thread(new Runnable() {

                @Override
                public void run() {
                    try {
                        System.out.println(""running TestFlowable thread"");
                        for (String s : values) {
                            System.out.println(""TestFlowable onNext: "" + s);
                            subscriber.onNext(s);
                        }
                        subscriber.onComplete();
                    } catch (Throwable e) {
                        throw new RuntimeException(e);
                    }
                }

            });
            System.out.println(""starting TestFlowable thread"");
            t.start();
            System.out.println(""done starting TestFlowable thread"");
        }
    }",iterator
i,"for (int i = 1; i < 3; i++) {
            effectCounter.set(0);
            System.out.printf(""- %d -%n"", i);
            result.subscribe(new Consumer<Integer>() {

                @Override
                public void accept(Integer t1) {
                    System.out.println(t1);
                }

            }, new Consumer<Throwable>() {

                @Override
                public void accept(Throwable t1) {
                    t1.printStackTrace();
                }
            },
            new Action() {
                @Override
                public void run() {
                    System.out.println(""Done"");
                }
            });
            assertEquals(2, effectCounter.get());
        }",loop_control
i,"for (int i = 0; i < 1000; i++) {
            assertEquals((Integer)i, onNextEvents.get(i));
        }",loop_control
i,"for (int i = 0; i < 10; i++) {
            assertEquals((Integer)i, onNextEvents.get(i));
        }",loop_control
i,"for (int i = 0; i < 100; i++) {
            TestSubscriberEx<Integer> ts1 = new TestSubscriberEx<>();

            Flowable<Integer> cached = source.replay().autoConnect();

            cached.observeOn(Schedulers.computation()).subscribe(ts1);

            ts1.awaitDone(2, TimeUnit.SECONDS);
            ts1.assertNoErrors();
            ts1.assertTerminated();
            assertEquals(10000, ts1.values().size());

            TestSubscriberEx<Integer> ts2 = new TestSubscriberEx<>();
            cached.observeOn(Schedulers.computation()).subscribe(ts2);

            ts2.awaitDone(2, TimeUnit.SECONDS);
            ts2.assertNoErrors();
            ts2.assertTerminated();
            assertEquals(10000, ts2.values().size());
        }",loop_control
i,"for (int i = 0; i < 100; i++) {
            TestSubscriberEx<Long> ts = new TestSubscriberEx<>();
            list.add(ts);
            output.skip(i * 10).take(10).subscribe(ts);
        }",loop_control
i,"for (int i = 0; i < 10; i++) {
            expected.add((long)(i - 10));
        }",loop_control
i,"for (int i = j * 10; i < j * 10 + 10; i++) {
                expected.set(i - j * 10, (long)i);
            }",loop_control
ts,"for (int i = 0; i < 100; i++) {
            TestSubscriberEx<Long> ts = new TestSubscriberEx<>();
            list.add(ts);
            output.skip(i * 10).take(10).subscribe(ts);
        }",iterator
ts,"for (TestSubscriberEx<Long> ts : list) {
            ts.awaitDone(3, TimeUnit.SECONDS);
            ts.assertNoErrors();
            ts.assertTerminated();

            for (int i = j * 10; i < j * 10 + 10; i++) {
                expected.set(i - j * 10, (long)i);
            }

            ts.assertValueSequence(expected);

            j++;
        }",iterator
j,"{
        Flowable<Long> source = Flowable.interval(1, 1, TimeUnit.MILLISECONDS)
                .take(1000)
                .subscribeOn(Schedulers.io());
        Flowable<Long> cached = source.replay().autoConnect();

        Flowable<Long> output = cached.observeOn(Schedulers.computation(), false, 1024);

        List<TestSubscriberEx<Long>> list = new ArrayList<>(100);
        for (int i = 0; i < 100; i++) {
            TestSubscriberEx<Long> ts = new TestSubscriberEx<>();
            list.add(ts);
            output.skip(i * 10).take(10).subscribe(ts);
        }

        List<Long> expected = new ArrayList<>();
        for (int i = 0; i < 10; i++) {
            expected.add((long)(i - 10));
        }
        int j = 0;
        for (TestSubscriberEx<Long> ts : list) {
            ts.awaitDone(3, TimeUnit.SECONDS);
            ts.assertNoErrors();
            ts.assertTerminated();

            for (int i = j * 10; i < j * 10 + 10; i++) {
                expected.set(i - j * 10, (long)i);
            }

            ts.assertValueSequence(expected);

            j++;
        }
    }",maybe_loop_control
i,"for (int i = 0; i < m; i++) {
                    t.onNext(i);
                }",loop_control
i,"for (int i = 0; i < TestHelper.RACE_DEFAULT_LOOPS; i++) {
            final ConnectableFlowable<Integer> cf = Flowable.range(1, 3).replay();

            Runnable r = new Runnable() {
                @Override
                public void run() {
                    cf.connect();
                }
            };

            TestHelper.race(r, r);
        }",loop_control
i,"for (int i = 0; i < TestHelper.RACE_DEFAULT_LOOPS; i++) {
            final ConnectableFlowable<Integer> cf = Flowable.range(1, 3).replay();

            final TestSubscriber<Integer> ts1 = new TestSubscriber<>();
            final TestSubscriber<Integer> ts2 = new TestSubscriber<>();

            Runnable r1 = new Runnable() {
                @Override
                public void run() {
                    cf.subscribe(ts1);
                }
            };

            Runnable r2 = new Runnable() {
                @Override
                public void run() {
                    cf.subscribe(ts2);
                }
            };

            TestHelper.race(r1, r2);
        }",loop_control
i,"for (int i = 0; i < TestHelper.RACE_DEFAULT_LOOPS; i++) {
            final ConnectableFlowable<Integer> cf = Flowable.range(1, 3).replay();

            final TestSubscriber<Integer> ts1 = new TestSubscriber<>();
            final TestSubscriber<Integer> ts2 = new TestSubscriber<>();

            cf.subscribe(ts1);

            Runnable r1 = new Runnable() {
                @Override
                public void run() {
                    ts1.cancel();
                }
            };

            Runnable r2 = new Runnable() {
                @Override
                public void run() {
                    cf.subscribe(ts2);
                }
            };

            TestHelper.race(r1, r2);
        }",loop_control
i,"for (int i = 0; i < TestHelper.RACE_DEFAULT_LOOPS; i++) {
            final PublishProcessor<Integer> pp = PublishProcessor.create();

            final ConnectableFlowable<Integer> cf = pp.replay();

            final TestSubscriber<Integer> ts1 = new TestSubscriber<>();

            Runnable r1 = new Runnable() {
                @Override
                public void run() {
                    cf.subscribe(ts1);
                }
            };

            Runnable r2 = new Runnable() {
                @Override
                public void run() {
                    for (int j = 0; j < 1000; j++) {
                        pp.onNext(j);
                    }
                }
            };

            TestHelper.race(r1, r2);
        }",loop_control
j,"for (int j = 0; j < 1000; j++) {
                        pp.onNext(j);
                    }",loop_control
i,"for (int i = 0; i < TestHelper.RACE_DEFAULT_LOOPS; i++) {
            final PublishProcessor<Integer> pp = PublishProcessor.create();

            final ConnectableFlowable<Integer> cf = pp.replay();

            final TestSubscriber<Integer> ts1 = new TestSubscriber<>();

            cf.subscribe(ts1);

            Runnable r1 = new Runnable() {
                @Override
                public void run() {
                    ts1.cancel();
                }
            };

            Runnable r2 = new Runnable() {
                @Override
                public void run() {
                    for (int j = 0; j < 1000; j++) {
                        pp.onNext(j);
                    }
                }
            };

            TestHelper.race(r1, r2);
        }",loop_control
j,"for (int j = 0; j < 1000; j++) {
                        pp.onNext(j);
                    }",loop_control
i,"for (int i = 0; i < TestHelper.RACE_DEFAULT_LOOPS; i++) {
            final ConnectableFlowable<Integer> cf = Flowable.range(1, 1000).replay();

            final TestSubscriber<Integer> ts1 = new TestSubscriber<>();

            cf.connect();

            Runnable r1 = new Runnable() {
                @Override
                public void run() {
                    cf.subscribe(ts1);
                }
            };

            Runnable r2 = new Runnable() {
                @Override
                public void run() {
                    ts1.cancel();
                }
            };

            TestHelper.race(r1, r2);
        }",loop_control
i,"for (int i = 0; i < TestHelper.RACE_DEFAULT_LOOPS; i++) {
            final PublishProcessor<Integer> pp = PublishProcessor.create();

            final TestSubscriber<Integer> ts = pp.skipLast(1, TimeUnit.DAYS, scheduler).test();

            Runnable r1 = new Runnable() {
                @Override
                public void run() {
                    pp.onComplete();
                }
            };

            Runnable r2 = new Runnable() {
                @Override
                public void run() {
                    ts.cancel();
                }
            };

            TestHelper.race(r1, r2);
        }",loop_control
i,"for (int i = 0; i < TestHelper.RACE_DEFAULT_LOOPS; i++) {
                final PublishProcessor<Integer> pp = PublishProcessor.create();

                final TestSubscriber<Integer> ts = pp.retry(Functions.alwaysTrue()).test();

                Runnable r1 = new Runnable() {
                    @Override
                    public void run() {
                        pp.onError(ex);
                    }
                };

                Runnable r2 = new Runnable() {
                    @Override
                    public void run() {
                        ts.cancel();
                    }
                };

                TestHelper.race(r1, r2);

                ts.assertEmpty();
            }",loop_control
i,"for (int i = 0; i < TestHelper.RACE_DEFAULT_LOOPS; i++) {
                final PublishProcessor<Integer> pp = PublishProcessor.create();

                final TestSubscriber<Integer> ts = pp.retry(new BiPredicate<Object, Object>() {
                    @Override
                    public boolean test(Object t1, Object t2) throws Exception {
                        return true;
                    }
                }).test();

                final TestException ex = new TestException();

                Runnable r1 = new Runnable() {
                    @Override
                    public void run() {
                        pp.onError(ex);
                    }
                };

                Runnable r2 = new Runnable() {
                    @Override
                    public void run() {
                        ts.cancel();
                    }
                };

                TestHelper.race(r1, r2);

                ts.assertEmpty();
            }",loop_control
it,"{
        FlowableProcessor<String> s = PublishProcessor.create();

        Iterator<String> it = s.blockingMostRecent(""default"").iterator();

        assertTrue(it.hasNext());
        assertEquals(""default"", it.next());
        assertEquals(""default"", it.next());

        s.onNext(""one"");
        assertTrue(it.hasNext());
        assertEquals(""one"", it.next());
        assertEquals(""one"", it.next());

        s.onNext(""two"");
        assertTrue(it.hasNext());
        assertEquals(""two"", it.next());
        assertEquals(""two"", it.next());

        s.onComplete();
        assertFalse(it.hasNext());

    }",iterator
it,"{
        FlowableProcessor<String> s = PublishProcessor.create();

        Iterator<String> it = s.blockingMostRecent(""default"").iterator();

        assertTrue(it.hasNext());
        assertEquals(""default"", it.next());
        assertEquals(""default"", it.next());

        s.onError(new TestException());
        assertTrue(it.hasNext());

        it.next();
    }",iterator
j,"for (int j = 0; j < 3; j++) {
            Iterator<Long> it = iter.iterator();

            Assert.assertEquals(Long.valueOf(-1), it.next());

            for (int i = 0; i < 9; i++) {
                scheduler.advanceTimeBy(1, TimeUnit.SECONDS);

                Assert.assertTrue(it.hasNext());
                Assert.assertEquals(Long.valueOf(i), it.next());
            }
            scheduler.advanceTimeBy(1, TimeUnit.SECONDS);

            Assert.assertFalse(it.hasNext());
        }",loop_control
i,"for (int i = 0; i < 9; i++) {
                scheduler.advanceTimeBy(1, TimeUnit.SECONDS);

                Assert.assertTrue(it.hasNext());
                Assert.assertEquals(Long.valueOf(i), it.next());
            }",loop_control
i,"for (int i = 0; i < TestHelper.RACE_DEFAULT_LOOPS; i++) {
            final PublishProcessor<Integer> pp = PublishProcessor.create();

            final TestSubscriber<Integer> ts = pp.takeLast(1, TimeUnit.DAYS).test();

            Runnable r1 = new Runnable() {
                @Override
                public void run() {
                    pp.onComplete();
                }
            };

            Runnable r2 = new Runnable() {
                @Override
                public void run() {
                    ts.cancel();
                }
            };

            TestHelper.race(r1, r2);
        }",loop_control
i,"for (int i = 0; i < numbers.length; i++) {
            numbers[i] = i + 1;
        }",loop_control
iters,"for (int iters = 0; iters < NITERS; iters++) {
            final CountDownLatch innerLatch = new CountDownLatch(1);
            final PublishProcessor<Void> s = PublishProcessor.create();
            final AtomicBoolean completed = new AtomicBoolean();
            Flowable.fromArray(numbers)
                    .takeUntil(s)
                    .window(50)
                    .flatMap(new Function<Flowable<Integer>, Publisher<Object>>() {
                        @Override
                        public Publisher<Object> apply(Flowable<Integer> integerObservable) {
                                return integerObservable
                                        .subscribeOn(Schedulers.computation())
                                        .map(new Function<Integer, Object>() {
                                            @Override
                                            public Object apply(Integer integer) {
                                                    if (integer >= 5 && completed.compareAndSet(false, true)) {
                                                        s.onComplete();
                                                    }
                                                    // do some work
                                                    Math.pow(Math.random(), Math.random());
                                                    return integer * 2;
                                            }
                                        });
                        }
                    })
                    .toList()
                    .doOnSuccess(new Consumer<List<Object>>() {
                        @Override
                        public void accept(List<Object> integers) {
                                counter.incrementAndGet();
                                latch.countDown();
                                innerLatch.countDown();
                        }
                    })
                    .subscribe();
            if (!innerLatch.await(30, TimeUnit.SECONDS)) {
                Assert.fail(""Failed inner latch wait, iteration "" + iters);
            }
        }",loop_control
i,"for (int i = 0; i < 1000; i++) {
            for (int j = 1; j < 6; j++) {
                List<TestSubscriberEx<Integer>> tss = new ArrayList<>();
                for (int k = 1; k < j; k++) {
                    TestSubscriberEx<Integer> ts = new TestSubscriberEx<>();
                    tss.add(ts);
                    obs.subscribe(ts);
                }

                Disposable connection = cf.connect();

                for (TestSubscriberEx<Integer> ts : tss) {
                    ts.awaitDone(5, TimeUnit.SECONDS)
                    .assertSubscribed()
                    .assertValueCount(1000)
                    .assertNoErrors()
                    .assertComplete();
                }
                connection.dispose();
            }
        }",loop_control
j,"for (int j = 1; j < 6; j++) {
                List<TestSubscriberEx<Integer>> tss = new ArrayList<>();
                for (int k = 1; k < j; k++) {
                    TestSubscriberEx<Integer> ts = new TestSubscriberEx<>();
                    tss.add(ts);
                    obs.subscribe(ts);
                }

                Disposable connection = cf.connect();

                for (TestSubscriberEx<Integer> ts : tss) {
                    ts.awaitDone(5, TimeUnit.SECONDS)
                    .assertSubscribed()
                    .assertValueCount(1000)
                    .assertNoErrors()
                    .assertComplete();
                }
                connection.dispose();
            }",loop_control
k,"for (int k = 1; k < j; k++) {
                    TestSubscriberEx<Integer> ts = new TestSubscriberEx<>();
                    tss.add(ts);
                    obs.subscribe(ts);
                }",loop_control
ts,"for (int k = 1; k < j; k++) {
                    TestSubscriberEx<Integer> ts = new TestSubscriberEx<>();
                    tss.add(ts);
                    obs.subscribe(ts);
                }",iterator
ts,"for (TestSubscriberEx<Integer> ts : tss) {
                    ts.awaitDone(5, TimeUnit.SECONDS)
                    .assertSubscribed()
                    .assertValueCount(1000)
                    .assertNoErrors()
                    .assertComplete();
                }",iterator
i,"for (int i = 0; i < 1000; i++) {
            for (int j = 1; j < 6; j++) {
                List<TestSubscriberEx<Integer>> tss = new ArrayList<>();
                for (int k = 1; k < j; k++) {
                    TestSubscriberEx<Integer> ts = new TestSubscriberEx<>();
                    tss.add(ts);
                    obs.subscribe(ts);
                }

                Disposable connection = cf.connect();

                for (TestSubscriberEx<Integer> ts : tss) {
                    ts.awaitDone(5, TimeUnit.SECONDS)
                    .assertSubscribed()
                    .assertValueCount(1000)
                    .assertNoErrors()
                    .assertComplete();
                }
                connection.dispose();
            }
        }",loop_control
j,"for (int j = 1; j < 6; j++) {
                List<TestSubscriberEx<Integer>> tss = new ArrayList<>();
                for (int k = 1; k < j; k++) {
                    TestSubscriberEx<Integer> ts = new TestSubscriberEx<>();
                    tss.add(ts);
                    obs.subscribe(ts);
                }

                Disposable connection = cf.connect();

                for (TestSubscriberEx<Integer> ts : tss) {
                    ts.awaitDone(5, TimeUnit.SECONDS)
                    .assertSubscribed()
                    .assertValueCount(1000)
                    .assertNoErrors()
                    .assertComplete();
                }
                connection.dispose();
            }",loop_control
k,"for (int k = 1; k < j; k++) {
                    TestSubscriberEx<Integer> ts = new TestSubscriberEx<>();
                    tss.add(ts);
                    obs.subscribe(ts);
                }",loop_control
ts,"for (int k = 1; k < j; k++) {
                    TestSubscriberEx<Integer> ts = new TestSubscriberEx<>();
                    tss.add(ts);
                    obs.subscribe(ts);
                }",iterator
ts,"for (TestSubscriberEx<Integer> ts : tss) {
                    ts.awaitDone(5, TimeUnit.SECONDS)
                    .assertSubscribed()
                    .assertValueCount(1000)
                    .assertNoErrors()
                    .assertComplete();
                }",iterator
i,"for (int i = 0; i < 1000; i++) {
            for (int j = 1; j < 6; j++) {
                List<TestSubscriberEx<Integer>> tss = new ArrayList<>();
                for (int k = 1; k < j; k++) {
                    TestSubscriberEx<Integer> ts = new TestSubscriberEx<>();
                    tss.add(ts);
                    cf.subscribe(ts);
                }

                Disposable connection = cf.connect();

                for (TestSubscriberEx<Integer> ts : tss) {
                    ts.awaitDone(5, TimeUnit.SECONDS)
                    .assertSubscribed()
                    .assertValueCount(1000)
                    .assertNoErrors()
                    .assertComplete();
                }
                connection.dispose();
            }
        }",loop_control
j,"for (int j = 1; j < 6; j++) {
                List<TestSubscriberEx<Integer>> tss = new ArrayList<>();
                for (int k = 1; k < j; k++) {
                    TestSubscriberEx<Integer> ts = new TestSubscriberEx<>();
                    tss.add(ts);
                    cf.subscribe(ts);
                }

                Disposable connection = cf.connect();

                for (TestSubscriberEx<Integer> ts : tss) {
                    ts.awaitDone(5, TimeUnit.SECONDS)
                    .assertSubscribed()
                    .assertValueCount(1000)
                    .assertNoErrors()
                    .assertComplete();
                }
                connection.dispose();
            }",loop_control
k,"for (int k = 1; k < j; k++) {
                    TestSubscriberEx<Integer> ts = new TestSubscriberEx<>();
                    tss.add(ts);
                    cf.subscribe(ts);
                }",loop_control
ts,"for (int k = 1; k < j; k++) {
                    TestSubscriberEx<Integer> ts = new TestSubscriberEx<>();
                    tss.add(ts);
                    cf.subscribe(ts);
                }",iterator
ts,"for (TestSubscriberEx<Integer> ts : tss) {
                    ts.awaitDone(5, TimeUnit.SECONDS)
                    .assertSubscribed()
                    .assertValueCount(1000)
                    .assertNoErrors()
                    .assertComplete();
                }",iterator
i,"for (int i = 0; i < 1000; i++) {
            for (int j = 1; j < 6; j++) {
                List<TestSubscriberEx<Integer>> tss = new ArrayList<>();
                for (int k = 1; k < j; k++) {
                    TestSubscriberEx<Integer> ts = new TestSubscriberEx<>();
                    tss.add(ts);
                    obs.subscribe(ts);
                }

                Disposable connection = cf.connect();

                for (TestSubscriberEx<Integer> ts : tss) {
                    ts.awaitDone(5, TimeUnit.SECONDS)
                    .assertSubscribed()
                    .assertValueCount(1000)
                    .assertNoErrors()
                    .assertComplete();
                }
                connection.dispose();
            }
        }",loop_control
j,"for (int j = 1; j < 6; j++) {
                List<TestSubscriberEx<Integer>> tss = new ArrayList<>();
                for (int k = 1; k < j; k++) {
                    TestSubscriberEx<Integer> ts = new TestSubscriberEx<>();
                    tss.add(ts);
                    obs.subscribe(ts);
                }

                Disposable connection = cf.connect();

                for (TestSubscriberEx<Integer> ts : tss) {
                    ts.awaitDone(5, TimeUnit.SECONDS)
                    .assertSubscribed()
                    .assertValueCount(1000)
                    .assertNoErrors()
                    .assertComplete();
                }
                connection.dispose();
            }",loop_control
k,"for (int k = 1; k < j; k++) {
                    TestSubscriberEx<Integer> ts = new TestSubscriberEx<>();
                    tss.add(ts);
                    obs.subscribe(ts);
                }",loop_control
ts,"for (int k = 1; k < j; k++) {
                    TestSubscriberEx<Integer> ts = new TestSubscriberEx<>();
                    tss.add(ts);
                    obs.subscribe(ts);
                }",iterator
ts,"for (TestSubscriberEx<Integer> ts : tss) {
                    ts.awaitDone(5, TimeUnit.SECONDS)
                    .assertSubscribed()
                    .assertValueCount(1000)
                    .assertNoErrors()
                    .assertComplete();
                }",iterator
i,"for (int i = 0; i < TestHelper.RACE_DEFAULT_LOOPS; i++) {

            final ConnectableFlowable<Integer> cf = Flowable.<Integer>empty().publish();

            final TestSubscriber<Integer> ts = cf.test();

            final TestSubscriber<Integer> ts2 = new TestSubscriber<>();

            Runnable r1 = new Runnable() {
                @Override
                public void run() {
                    cf.subscribe(ts2);
                }
            };

            Runnable r2 = new Runnable() {
                @Override
                public void run() {
                    ts.cancel();
                }
            };

            TestHelper.race(r1, r2);
        }",loop_control
i,"for (int i = 0; i < TestHelper.RACE_DEFAULT_LOOPS; i++) {

            final PublishProcessor<Integer> pp = PublishProcessor.create();

            final ConnectableFlowable<Integer> cf = pp.publish();

            final TestSubscriber<Integer> ts = cf.test();

            Runnable r1 = new Runnable() {
                @Override
                public void run() {
                    pp.onNext(1);
                }
            };

            Runnable r2 = new Runnable() {
                @Override
                public void run() {
                    ts.cancel();
                }
            };

            TestHelper.race(r1, r2);
        }",loop_control
i,"for (int i = 0; i < TestHelper.RACE_DEFAULT_LOOPS; i++) {

            final PublishProcessor<Integer> pp = PublishProcessor.create();

            final ConnectableFlowable<Integer> cf = pp.publish();

            final Disposable d = cf.connect();
            final TestSubscriber<Integer> ts = new TestSubscriber<>();

            Runnable r1 = new Runnable() {
                @Override
                public void run() {
                    d.dispose();
                }
            };

            Runnable r2 = new Runnable() {
                @Override
                public void run() {
                    cf.subscribe(ts);
                }
            };

            TestHelper.race(r1, r2);
        }",loop_control
i,"for (int i = 0; i < TestHelper.RACE_DEFAULT_LOOPS; i++) {

            final ConnectableFlowable<Integer> cf = Flowable.<Integer>empty().publish();

            cf.connect();

            Runnable r1 = new Runnable() {
                @Override
                public void run() {
                    cf.test();
                }
            };

            TestHelper.race(r1, r1);
        }",loop_control
i,"for (int i = 0; i < TestHelper.RACE_DEFAULT_LOOPS; i++) {

            final ConnectableFlowable<Integer> cf = Flowable.<Integer>empty().publish();

            Runnable r1 = new Runnable() {
                @Override
                public void run() {
                    cf.connect();
                }
            };

            TestHelper.race(r1, r1);
        }",loop_control
i,"for (int i = 0; i < 10; i++) {
                        s.onNext(i);
                    }",loop_control
i,"for (int i = 0; i < TestHelper.RACE_DEFAULT_LOOPS; i++) {

            final AtomicReference<Disposable> ref = new AtomicReference<>();

            final ConnectableFlowable<Integer> cf = new Flowable<Integer>() {
                @Override
                protected void subscribeActual(Subscriber<? super Integer> s) {
                    s.onSubscribe(new BooleanSubscription());
                    ref.set((Disposable)s);
                }
            }.publish();

            cf.connect();

            Runnable r1 = new Runnable() {
                @Override
                public void run() {
                    ref.get().dispose();
                }
            };

            TestHelper.race(r1, r1);
        }",loop_control
i,"for (int i = 0; i < TestHelper.RACE_LONG_LOOPS; i++) {

            final PublishProcessor<Integer> pp = PublishProcessor.create();

            final AtomicReference<Flowable<Integer>> ref = new AtomicReference<>();

            pp.publish(new Function<Flowable<Integer>, Publisher<Integer>>() {
                @Override
                public Publisher<Integer> apply(Flowable<Integer> f) throws Exception {
                    ref.set(f);
                    return Flowable.never();
                }
            }).test();

            final TestSubscriber<Integer> ts1 = ref.get().test();
            TestSubscriber<Integer> ts2 = ref.get().test();

            Runnable r1 = new Runnable() {
                @Override
                public void run() {
                    pp.onNext(1);
                }
            };

            Runnable r2 = new Runnable() {
                @Override
                public void run() {
                    ts1.cancel();
                }
            };

            TestHelper.race(r1, r2);

            ts2.assertValuesOnly(1);
        }",loop_control
i,"for (int i = 0; i < TestHelper.RACE_LONG_LOOPS; i++) {
            final ConnectableFlowable<Integer> cf =
                    new FlowablePublish<>(Flowable.<Integer>never(), 128);

            Runnable r = new Runnable() {
                @Override
                public void run() {
                    cf.connect();
                }
            };

            TestHelper.race(r, r);
        }",loop_control
m,"for (BackpressureStrategy m : BackpressureStrategy.values()) {
            Flowable<Object> source = Flowable.create(new FlowableOnSubscribe<Object>() {
                @Override
                public void subscribe(FlowableEmitter<Object> e) throws Exception {
                    final FlowableEmitter<Object> f = e.serialize();

                    final TestException ex = new TestException();

                    Runnable r1 = new Runnable() {
                        @Override
                        public void run() {
                            f.onError(null);
                        }
                    };

                    Runnable r2 = new Runnable() {
                        @Override
                        public void run() {
                            f.onError(ex);
                        }
                    };

                    TestHelper.race(r1, r2);
                }
            }, m);

            List<Throwable> errors = TestHelper.trackPluginErrors();

            try {
                for (int i = 0; i < TestHelper.RACE_DEFAULT_LOOPS; i++) {
                    source
                    .test()
                    .assertFailure(Throwable.class);
                }
            } finally {
                RxJavaPlugins.reset();
            }
            assertFalse(errors.isEmpty());
        }",iterator
i,"for (int i = 0; i < TestHelper.RACE_DEFAULT_LOOPS; i++) {
                    source
                    .test()
                    .assertFailure(Throwable.class);
                }",loop_control
m,"for (BackpressureStrategy m : BackpressureStrategy.values()) {
            Flowable<Object> source = Flowable.create(new FlowableOnSubscribe<Object>() {
                @Override
                public void subscribe(FlowableEmitter<Object> e) throws Exception {
                    final FlowableEmitter<Object> f = e.serialize();

                    Runnable r1 = new Runnable() {
                        @Override
                        public void run() {
                            f.onComplete();
                        }
                    };

                    Runnable r2 = new Runnable() {
                        @Override
                        public void run() {
                            f.onComplete();
                        }
                    };

                    TestHelper.race(r1, r2);
                }
            }, m);

            for (int i = 0; i < TestHelper.RACE_DEFAULT_LOOPS; i++) {
                source
                .test()
                .assertResult();
            }
        }",iterator
i,"for (int i = 0; i < TestHelper.RACE_DEFAULT_LOOPS; i++) {
                source
                .test()
                .assertResult();
            }",loop_control
m,"for (BackpressureStrategy m : BackpressureStrategy.values()) {
            Flowable.create(new FlowableOnSubscribe<Object>() {
                @Override
                public void subscribe(FlowableEmitter<Object> e) throws Exception {
                    e.onNext(null);
                }
            }, m)
            .test()
            .assertFailure(NullPointerException.class);
        }",iterator
m,"for (BackpressureStrategy m : BackpressureStrategy.values()) {
            System.out.println(m);
            Flowable.create(new FlowableOnSubscribe<Object>() {
                @Override
                public void subscribe(FlowableEmitter<Object> e) throws Exception {
                    e.onError(null);
                }
            }, m)
            .test()
            .assertFailure(NullPointerException.class);
        }",iterator
m,"for (BackpressureStrategy m : BackpressureStrategy.values()) {
            Flowable.create(new FlowableOnSubscribe<Object>() {
                @Override
                public void subscribe(FlowableEmitter<Object> e) throws Exception {
                    final FlowableEmitter<Object> f = e.serialize();

                    Runnable r1 = new Runnable() {
                        @Override
                        public void run() {
                            for (int i = 0; i < 1000; i++) {
                                f.onNext(1);
                            }
                        }
                    };

                    Runnable r2 = new Runnable() {
                        @Override
                        public void run() {
                            for (int i = 0; i < 100; i++) {
                                f.onNext(1);
                            }
                            f.onError(new TestException());
                        }
                    };

                    TestHelper.race(r1, r2);
                }
            }, m)
            .to(TestHelper.<Object>testConsumer())
            .assertSubscribed()
            .assertNotComplete()
            .assertError(TestException.class);
        }",iterator
i,"for (int i = 0; i < 1000; i++) {
                                f.onNext(1);
                            }",loop_control
i,"for (int i = 0; i < 100; i++) {
                                f.onNext(1);
                            }",loop_control
m,"for (BackpressureStrategy m : BackpressureStrategy.values()) {
            Flowable.create(new FlowableOnSubscribe<Object>() {
                @Override
                public void subscribe(FlowableEmitter<Object> e) throws Exception {
                    throw new TestException();
                }
            }, m)
            .test()
            .assertFailure(TestException.class);
        }",iterator
m,"for (BackpressureStrategy m : BackpressureStrategy.values()) {
            Flowable.create(new FlowableOnSubscribe<Object>() {
                @Override
                public void subscribe(FlowableEmitter<Object> e) throws Exception {
                    e.serialize().onNext(null);
                }
            }, m)
            .test()
            .assertFailure(NullPointerException.class);
        }",iterator
m,"for (BackpressureStrategy m : BackpressureStrategy.values()) {
            List<Throwable> errors = TestHelper.trackPluginErrors();
            try {
                final Throwable[] error = { null };

                Flowable.create(new FlowableOnSubscribe<Integer>() {
                    @Override
                    public void subscribe(FlowableEmitter<Integer> e) throws Exception {
                        try {
                            e.onNext(null);
                            e.onNext(1);
                            e.onError(new TestException());
                            e.onComplete();
                        } catch (Throwable ex) {
                            error[0] = ex;
                        }
                    }
                }, m)
                .test()
                .assertFailure(NullPointerException.class);

                assertNull(error[0]);

                TestHelper.assertUndeliverable(errors, 0, TestException.class);
            } finally {
                RxJavaPlugins.reset();
            }
        }",iterator
m,"for (BackpressureStrategy m : BackpressureStrategy.values()) {
            Flowable.create(new FlowableOnSubscribe<Object>() {
                @Override
                public void subscribe(FlowableEmitter<Object> e) throws Exception {
                    Disposable d = Disposable.empty();
                    e.setDisposable(d);
                    try {
                        e.onError(new IOException());
                        fail(""Should have thrown"");
                    } catch (TestException ex) {
                        // expected
                    }
                    assertTrue(d.isDisposed());
                }
            }, m)
            .subscribe(new FlowableSubscriber<Object>() {
                @Override
                public void onSubscribe(Subscription s) {
                }

                @Override
                public void onNext(Object value) {
                }

                @Override
                public void onError(Throwable e) {
                    throw new TestException();
                }

                @Override
                public void onComplete() {
                }
            });
        }",iterator
m,"for (BackpressureStrategy m : BackpressureStrategy.values()) {
            Flowable.create(new FlowableOnSubscribe<Object>() {
                @Override
                public void subscribe(FlowableEmitter<Object> e) throws Exception {
                    Disposable d = Disposable.empty();
                    e.setDisposable(d);
                    try {
                        e.onComplete();
                        fail(""Should have thrown"");
                    } catch (TestException ex) {
                        // expected
                    }
                    assertTrue(d.isDisposed());
                }
            }, m)
            .subscribe(new FlowableSubscriber<Object>() {
                @Override
                public void onSubscribe(Subscription s) {
                }

                @Override
                public void onNext(Object value) {
                }

                @Override
                public void onError(Throwable e) {
                }

                @Override
                public void onComplete() {
                    throw new TestException();
                }
            });
        }",iterator
m,"for (BackpressureStrategy m : BackpressureStrategy.values()) {
            List<Throwable> errors = TestHelper.trackPluginErrors();
            try {
                final Throwable[] error = { null };

                Flowable.create(new FlowableOnSubscribe<Integer>() {
                    @Override
                    public void subscribe(FlowableEmitter<Integer> e) throws Exception {
                        e = e.serialize();
                        try {
                            e.onNext(null);
                            e.onNext(1);
                            e.onError(new TestException());
                            e.onComplete();
                        } catch (Throwable ex) {
                            error[0] = ex;
                        }
                    }
                }, m)
                .test()
                .assertFailure(NullPointerException.class);

                assertNull(error[0]);

                TestHelper.assertUndeliverable(errors, 0, TestException.class);
            } finally {
                RxJavaPlugins.reset();
            }
        }",iterator
m,"for (BackpressureStrategy m : BackpressureStrategy.values()) {
            Flowable.create(new FlowableOnSubscribe<Object>() {
                @Override
                public void subscribe(FlowableEmitter<Object> e) throws Exception {
                    e.serialize().onError(null);
                }
            }, m)
            .test()
            .assertFailure(NullPointerException.class);
        }",iterator
m,"for (BackpressureStrategy m : BackpressureStrategy.values()) {
            Flowable.create(new FlowableOnSubscribe<Object>() {
                @Override
                public void subscribe(FlowableEmitter<Object> e) throws Exception {
                    final FlowableEmitter<Object> f = e.serialize();

                    Runnable r1 = new Runnable() {
                        @Override
                        public void run() {
                            for (int i = 0; i < TestHelper.RACE_DEFAULT_LOOPS; i++) {
                                f.onNext(1);
                            }
                        }
                    };

                    TestHelper.race(r1, r1);
                }
            }, m)
            .take(TestHelper.RACE_DEFAULT_LOOPS)
            .to(TestHelper.<Object>testConsumer())
            .assertSubscribed()
            .assertValueCount(TestHelper.RACE_DEFAULT_LOOPS)
            .assertComplete()
            .assertNoErrors();
        }",iterator
i,"for (int i = 0; i < TestHelper.RACE_DEFAULT_LOOPS; i++) {
                                f.onNext(1);
                            }",loop_control
m,"for (BackpressureStrategy m : BackpressureStrategy.values()) {
            TestSubscriberEx<Object> ts = Flowable.create(new FlowableOnSubscribe<Object>() {
                @Override
                public void subscribe(FlowableEmitter<Object> e) throws Exception {
                    final FlowableEmitter<Object> f = e.serialize();

                    Runnable r1 = new Runnable() {
                        @Override
                        public void run() {
                            for (int i = 0; i < 1000; i++) {
                                f.onNext(1);
                            }
                        }
                    };

                    Runnable r2 = new Runnable() {
                        @Override
                        public void run() {
                            for (int i = 0; i < 100; i++) {
                                f.onNext(1);
                            }
                            f.onComplete();
                        }
                    };

                    TestHelper.race(r1, r2);
                }
            }, m)
            .to(TestHelper.<Object>testConsumer())
            .assertSubscribed()
            .assertComplete()
            .assertNoErrors();

            int c = ts.values().size();
            assertTrue("""" + c, c >= 100);
        }",iterator
i,"for (int i = 0; i < 1000; i++) {
                                f.onNext(1);
                            }",loop_control
i,"for (int i = 0; i < 100; i++) {
                                f.onNext(1);
                            }",loop_control
m,"for (BackpressureStrategy m : BackpressureStrategy.values()) {
            List<Throwable> errors = TestHelper.trackPluginErrors();
            try {
                Flowable.create(new FlowableOnSubscribe<Object>() {
                    @Override
                    public void subscribe(FlowableEmitter<Object> e) throws Exception {
                        FlowableEmitter<Object> f = e.serialize();

                        assertSame(f, f.serialize());

                        assertFalse(f.isCancelled());

                        final int[] calls = { 0 };

                        f.setCancellable(new Cancellable() {
                            @Override
                            public void cancel() throws Exception {
                                calls[0]++;
                            }
                        });

                        e.onComplete();

                        assertTrue(f.isCancelled());

                        assertEquals(1, calls[0]);
                    }
                }, m)
                .test()
                .assertResult();

                assertTrue(errors.toString(), errors.isEmpty());
            } finally {
                RxJavaPlugins.reset();
            }
        }",iterator
strategy,"for (BackpressureStrategy strategy : BackpressureStrategy.values()) {
            List<Throwable> errors = TestHelper.trackPluginErrors();
            try {
                final Boolean[] response = { null };
                Flowable.create(new FlowableOnSubscribe<Object>() {
                    @Override
                    public void subscribe(FlowableEmitter<Object> e) throws Exception {
                        e.onNext(1);
                        response[0] = e.tryOnError(new TestException());
                    }
                }, strategy)
                .take(1)
                .test()
                .withTag(strategy.toString())
                .assertResult(1);

                assertFalse(response[0]);

                assertTrue(strategy + "": "" + errors.toString(), errors.isEmpty());
            } finally {
                RxJavaPlugins.reset();
            }
        }",iterator
strategy,"for (BackpressureStrategy strategy : BackpressureStrategy.values()) {
            List<Throwable> errors = TestHelper.trackPluginErrors();
            try {
                final Boolean[] response = { null };
                Flowable.create(new FlowableOnSubscribe<Object>() {
                    @Override
                    public void subscribe(FlowableEmitter<Object> e) throws Exception {
                        e = e.serialize();
                        e.onNext(1);
                        response[0] = e.tryOnError(new TestException());
                    }
                }, strategy)
                .take(1)
                .test()
                .withTag(strategy.toString())
                .assertResult(1);

                assertFalse(response[0]);

                assertTrue(strategy + "": "" + errors.toString(), errors.isEmpty());
            } finally {
                RxJavaPlugins.reset();
            }
        }",iterator
entry,"for (final Map.Entry<BackpressureStrategy, Class<? extends FlowableEmitter>> entry : emitterMap.entrySet()) {
            Flowable.create(new FlowableOnSubscribe<Object>() {
                @Override
                public void subscribe(FlowableEmitter<Object> emitter) throws Exception {
                    assertTrue(emitter.toString().contains(entry.getValue().getSimpleName()));
                    assertTrue(emitter.serialize().toString().contains(entry.getValue().getSimpleName()));
                }
            }, entry.getKey()).test().assertEmpty();
        }",iterator
i,"for (int i = 0; i < Flowable.bufferSize() * 2; i++) {
            pp.onNext(i);
        }",loop_control
i,"for (int i = 0; i < Flowable.bufferSize() * 2; i++) {
            pp.onNext(i);
        }",loop_control
i,"for (int i = 0; i < 9; i++) {
                    s.onNext(i);
                }",loop_control
i,"for (int i = 0; i < 500; i++) {
            source.test()
            .awaitDone(5, TimeUnit.SECONDS)
            .assertResult(1);
        }",loop_control
i,"for (int i = 0; i < 500; i++) {
            source.test()
            .awaitDone(5, TimeUnit.SECONDS)
            .assertResult(1);
        }",loop_control
i,"for (int i = 0; i < TestHelper.RACE_DEFAULT_LOOPS; i++) {
            final TestSubscriber<Integer> ts1 = new TestSubscriber<>(0L);

            Flowable.just(1)
                    .publish(f -> {
                        Runnable r1 = () -> f.subscribe(ts1);

                        Runnable r2 = () -> {
                            for (int j = 0; j < 100; j++) {
                                ts1.request(1);
                            }
                        };

                        TestHelper.race(r1, r2);
                        return f;
                    }).test()
                    .assertResult(1);

            ts1.assertResult(1);
        }",loop_control
j,"for (int j = 0; j < 100; j++) {
                                ts1.request(1);
                            }",loop_control
i,"for (int i = 0; i < 100; i++) {
            List<Flowable<String>> os = new ArrayList<>();
            os.add(Flowable.just(""one"", ""two"", ""three"", ""four"", ""five"").subscribeOn(Schedulers.newThread()));
            os.add(Flowable.just(""one"", ""two"", ""three"", ""four"", ""five"").subscribeOn(Schedulers.newThread()));
            os.add(Flowable.just(""one"", ""two"", ""three"", ""four"", ""five"").subscribeOn(Schedulers.newThread()));

            List<String> expected = Arrays.asList(""one"", ""two"", ""three"", ""four"", ""five"", ""one"", ""two"", ""three"", ""four"", ""five"", ""one"", ""two"", ""three"", ""four"", ""five"");
            Iterator<String> iter = Flowable.merge(os, 1).blockingIterable().iterator();
            List<String> actual = new ArrayList<>();
            while (iter.hasNext()) {
                actual.add(iter.next());
            }
            assertEquals(expected, actual);
        }",loop_control
i,"for (int i = 0; i < 100; i++) {
            List<Flowable<String>> os = new ArrayList<>();
            os.add(Flowable.just(""one"", ""two"", ""three"", ""four"", ""five"").subscribeOn(Schedulers.newThread()));
            os.add(Flowable.just(""one"", ""two"", ""three"", ""four"", ""five"").subscribeOn(Schedulers.newThread()));
            os.add(Flowable.just(""one"", ""two"", ""three"", ""four"", ""five"").subscribeOn(Schedulers.newThread()));

            List<String> expected = Arrays.asList(""one"", ""two"", ""three"", ""four"", ""five"", ""one"", ""two"", ""three"", ""four"", ""five"", ""one"", ""two"", ""three"", ""four"", ""five"");
            Iterator<String> iter = Flowable.merge(os, 1).blockingIterable().iterator();
            List<String> actual = new ArrayList<>();
            while (iter.hasNext()) {
                actual.add(iter.next());
            }
            assertEquals(expected, actual);
        }",loop_control
times,"for (int times = 0; times < 100; times++) {
            int observableCount = 100;
            // Test maxConcurrent from 2 to 12
            int maxConcurrent = 2 + (times % 10);
            AtomicInteger subscriptionCount = new AtomicInteger(0);

            List<Flowable<String>> os = new ArrayList<>();
            List<SubscriptionCheckObservable> scos = new ArrayList<>();
            for (int i = 0; i < observableCount; i++) {
                SubscriptionCheckObservable sco = new SubscriptionCheckObservable(subscriptionCount, maxConcurrent);
                scos.add(sco);
                os.add(Flowable.unsafeCreate(sco));
            }

            Iterator<String> iter = Flowable.merge(os, maxConcurrent).blockingIterable().iterator();
            List<String> actual = new ArrayList<>();
            while (iter.hasNext()) {
                actual.add(iter.next());
            }
            //            System.out.println(""actual: "" + actual);
            assertEquals(5 * observableCount, actual.size());
            for (SubscriptionCheckObservable sco : scos) {
                assertFalse(sco.failed);
            }
        }",loop_control
i,"for (int i = 0; i < observableCount; i++) {
                SubscriptionCheckObservable sco = new SubscriptionCheckObservable(subscriptionCount, maxConcurrent);
                scos.add(sco);
                os.add(Flowable.unsafeCreate(sco));
            }",loop_control
iter,"for (int times = 0; times < 100; times++) {
            int observableCount = 100;
            // Test maxConcurrent from 2 to 12
            int maxConcurrent = 2 + (times % 10);
            AtomicInteger subscriptionCount = new AtomicInteger(0);

            List<Flowable<String>> os = new ArrayList<>();
            List<SubscriptionCheckObservable> scos = new ArrayList<>();
            for (int i = 0; i < observableCount; i++) {
                SubscriptionCheckObservable sco = new SubscriptionCheckObservable(subscriptionCount, maxConcurrent);
                scos.add(sco);
                os.add(Flowable.unsafeCreate(sco));
            }

            Iterator<String> iter = Flowable.merge(os, maxConcurrent).blockingIterable().iterator();
            List<String> actual = new ArrayList<>();
            while (iter.hasNext()) {
                actual.add(iter.next());
            }
            //            System.out.println(""actual: "" + actual);
            assertEquals(5 * observableCount, actual.size());
            for (SubscriptionCheckObservable sco : scos) {
                assertFalse(sco.failed);
            }
        }",iterator
sco,"for (int i = 0; i < observableCount; i++) {
                SubscriptionCheckObservable sco = new SubscriptionCheckObservable(subscriptionCount, maxConcurrent);
                scos.add(sco);
                os.add(Flowable.unsafeCreate(sco));
            }",iterator
sco,"for (SubscriptionCheckObservable sco : scos) {
                assertFalse(sco.failed);
            }",iterator
i,"for (int i = 0; i < n; i++) {
            sourceList.add(Flowable.just(i));
        }",loop_control
it,"{
        int n = 10000;
        List<Flowable<Integer>> sourceList = new ArrayList<>(n);
        for (int i = 0; i < n; i++) {
            sourceList.add(Flowable.just(i));
        }
        Iterator<Integer> it = Flowable.merge(Flowable.fromIterable(sourceList), 1).blockingIterable().iterator();
        int j = 0;
        while (it.hasNext()) {
            assertEquals((Integer)j, it.next());
            j++;
        }
        assertEquals(j, n);
    }",iterator
it,"{
        int n = 10000;
        List<Flowable<Integer>> sourceList = new ArrayList<>(n);
        for (int i = 0; i < n; i++) {
            sourceList.add(Flowable.just(i));
        }
        Iterator<Integer> it = Flowable.merge(Flowable.fromIterable(sourceList), 1).take(n / 2).blockingIterable().iterator();
        int j = 0;
        while (it.hasNext()) {
            assertEquals((Integer)j, it.next());
            j++;
        }
        assertEquals(j, n / 2);
    }",iterator
i,"for (int i = 0; i < n; i++) {
            sourceList.add(Flowable.just(i));
        }",loop_control
i,"for (int i = 1; i < 100; i++) {
            TestSubscriberEx<Integer> ts = new TestSubscriberEx<>();
            List<Flowable<Integer>> sourceList = new ArrayList<>(i);
            List<Integer> result = new ArrayList<>(i);
            for (int j = 1; j <= i; j++) {
                sourceList.add(Flowable.just(j));
                result.add(j);
            }

            Flowable.merge(sourceList, i).subscribe(ts);

            ts.assertNoErrors();
            ts.assertTerminated();
            ts.assertValueSequence(result);
        }",loop_control
j,"for (int j = 1; j <= i; j++) {
                sourceList.add(Flowable.just(j));
                result.add(j);
            }",loop_control
i,"for (int i = 2; i < 100; i++) {
            TestSubscriberEx<Integer> ts = new TestSubscriberEx<>();
            List<Flowable<Integer>> sourceList = new ArrayList<>(i);
            List<Integer> result = new ArrayList<>(i);
            for (int j = 1; j <= i; j++) {
                sourceList.add(Flowable.just(j));
                result.add(j);
            }

            Flowable.merge(sourceList, i - 1).subscribe(ts);

            ts.assertNoErrors();
            ts.assertTerminated();
            ts.assertValueSequence(result);
        }",loop_control
j,"for (int j = 1; j <= i; j++) {
                sourceList.add(Flowable.just(j));
                result.add(j);
            }",loop_control
i,"for (int i = 0; i < 200; i++) {
            simpleAsync();
            int c1 = ios.size();
            if (c + 60 < c1) {
                throw new AssertionError(""Worker leak: "" + c + "" - "" + c1);
            }
        }",loop_control
i,"for (int i = 1; i < 50; i++) {
            TestSubscriber<Integer> ts = new TestSubscriber<>();
            List<Flowable<Integer>> sourceList = new ArrayList<>(i);
            Set<Integer> expected = new HashSet<>(i);
            for (int j = 1; j <= i; j++) {
                sourceList.add(Flowable.just(j).subscribeOn(Schedulers.io()));
                expected.add(j);
            }

            Flowable.merge(sourceList, i).subscribe(ts);

            ts.awaitDone(1, TimeUnit.SECONDS);
            ts.assertNoErrors();
            Set<Integer> actual = new HashSet<>(ts.values());

            assertEquals(expected, actual);
        }",loop_control
j,"for (int j = 1; j <= i; j++) {
                sourceList.add(Flowable.just(j).subscribeOn(Schedulers.io()));
                expected.add(j);
            }",loop_control
i,"for (int i = 0; i < 200; i++) {
            simpleOneLessAsync();
        }",loop_control
i,"for (int i = 2; i < 50; i++) {
            if (System.currentTimeMillis() - t > TimeUnit.SECONDS.toMillis(9)) {
                break;
            }
            TestSubscriber<Integer> ts = new TestSubscriber<>();
            List<Flowable<Integer>> sourceList = new ArrayList<>(i);
            Set<Integer> expected = new HashSet<>(i);
            for (int j = 1; j <= i; j++) {
                sourceList.add(Flowable.just(j).subscribeOn(Schedulers.io()));
                expected.add(j);
            }

            Flowable.merge(sourceList, i - 1).subscribe(ts);

            ts.awaitDone(1, TimeUnit.SECONDS);
            ts.assertNoErrors();
            Set<Integer> actual = new HashSet<>(ts.values());

            assertEquals(expected, actual);
        }",loop_control
t,"{
        long t = System.currentTimeMillis();
        for (int i = 2; i < 50; i++) {
            if (System.currentTimeMillis() - t > TimeUnit.SECONDS.toMillis(9)) {
                break;
            }
            TestSubscriber<Integer> ts = new TestSubscriber<>();
            List<Flowable<Integer>> sourceList = new ArrayList<>(i);
            Set<Integer> expected = new HashSet<>(i);
            for (int j = 1; j <= i; j++) {
                sourceList.add(Flowable.just(j).subscribeOn(Schedulers.io()));
                expected.add(j);
            }

            Flowable.merge(sourceList, i - 1).subscribe(ts);

            ts.awaitDone(1, TimeUnit.SECONDS);
            ts.assertNoErrors();
            Set<Integer> actual = new HashSet<>(ts.values());

            assertEquals(expected, actual);
        }
    }",break_loop_control
j,"for (int j = 1; j <= i; j++) {
                sourceList.add(Flowable.just(j).subscribeOn(Schedulers.io()));
                expected.add(j);
            }",loop_control
i,"for (int i = 1; i <= Flowable.bufferSize() + 1; i++) {
            list.add(i);
        }",loop_control
i,"for (int i = 0; i < 10; i++) {
            TestSubscriber<Integer> ts = new TestSubscriber<>();

            f.subscribe(ts);

            ts.assertValues(1, 2, 3);
            ts.assertNoErrors();
            ts.assertComplete();
        }",loop_control
i,"for (int i = 0; i < TestHelper.RACE_DEFAULT_LOOPS; i++) {
            final TestSubscriber<Integer> ts = new TestSubscriber<>(0L);

            Runnable r = new Runnable() {
                @Override
                public void run() {
                    ts.request(1);
                }
            };

            Flowable.fromIterable(Arrays.asList(1, 2, 3, 4))
            .filter(Functions.alwaysTrue())
            .subscribe(ts);

            TestHelper.race(r, r);
        }",loop_control
i,"for (int i = 0; i < TestHelper.RACE_DEFAULT_LOOPS; i++) {
            final TestSubscriber<Integer> ts = new TestSubscriber<>(0L);

            Runnable r = new Runnable() {
                @Override
                public void run() {
                    ts.request(1);
                }
            };

            Flowable.fromIterable(Arrays.asList(1, 2, 3, 4))
            .filter(Functions.alwaysFalse())
            .subscribe(ts);

            TestHelper.race(r, r);
        }",loop_control
i,"for (int i = 0; i < TestHelper.RACE_DEFAULT_LOOPS; i++) {
            final TestSubscriber<Integer> ts = new TestSubscriber<>(0L);

            Runnable r1 = new Runnable() {
                @Override
                public void run() {
                    ts.request(1);
                }
            };

            Runnable r2 = new Runnable() {
                @Override
                public void run() {
                    ts.cancel();
                }
            };

            Flowable.fromIterable(Arrays.asList(1, 2, 3, 4))
            .filter(Functions.alwaysTrue())
            .subscribe(ts);

            TestHelper.race(r1, r2);
        }",loop_control
i,"for (int i = 0; i < TestHelper.RACE_DEFAULT_LOOPS; i++) {
            final TestSubscriber<Integer> ts = new TestSubscriber<>(0L);

            Runnable r1 = new Runnable() {
                @Override
                public void run() {
                    ts.request(Long.MAX_VALUE);
                }
            };

            Runnable r2 = new Runnable() {
                @Override
                public void run() {
                    ts.cancel();
                }
            };

            Flowable.fromIterable(Arrays.asList(1, 2, 3, 4))
            .filter(Functions.alwaysTrue())
            .subscribe(ts);

            TestHelper.race(r1, r2);
        }",loop_control
i,"for (int i = 0; i < TestHelper.RACE_DEFAULT_LOOPS; i++) {
            final TestSubscriber<Integer> ts = new TestSubscriber<>(0L);

            Runnable r1 = new Runnable() {
                @Override
                public void run() {
                    ts.request(1);
                }
            };

            Runnable r2 = new Runnable() {
                @Override
                public void run() {
                    ts.cancel();
                }
            };

            Flowable.fromIterable(Arrays.asList(1, 2, 3, 4))
            .subscribe(ts);

            TestHelper.race(r1, r2);
        }",loop_control
i,"for (int i = 0; i < TestHelper.RACE_DEFAULT_LOOPS; i++) {
            final TestSubscriber<Integer> ts = new TestSubscriber<>(0L);

            Runnable r1 = new Runnable() {
                @Override
                public void run() {
                    ts.request(Long.MAX_VALUE);
                }
            };

            Runnable r2 = new Runnable() {
                @Override
                public void run() {
                    ts.cancel();
                }
            };

            Flowable.fromIterable(Arrays.asList(1, 2, 3, 4))
            .subscribe(ts);

            TestHelper.race(r1, r2);
        }",loop_control
i,"for (int i = 0; i < TestHelper.RACE_DEFAULT_LOOPS; i++) {
            final PublishProcessor<Integer> pp = PublishProcessor.create();
            final TestObserver<List<Integer>> to = pp.toList().test();

            Runnable r1 = new Runnable() {
                @Override
                public void run() {
                    pp.onNext(1);
                }
            };
            Runnable r2 = new Runnable() {
                @Override
                public void run() {
                    to.dispose();
                }
            };

            TestHelper.race(r1, r2);
        }",loop_control
i,"for (int i = 0; i < TestHelper.RACE_DEFAULT_LOOPS; i++) {
            final PublishProcessor<Integer> pp = PublishProcessor.create();
            final TestSubscriber<List<Integer>> ts = pp.toList().toFlowable().test();

            Runnable r1 = new Runnable() {
                @Override
                public void run() {
                    pp.onNext(1);
                }
            };
            Runnable r2 = new Runnable() {
                @Override
                public void run() {
                    ts.cancel();
                }
            };

            TestHelper.race(r1, r2);
        }",loop_control
i,"for (int i = 0; i < TestHelper.RACE_DEFAULT_LOOPS; i++) {
            final PublishProcessor<Integer> pp = PublishProcessor.create();
            final TestSubscriber<List<Integer>> ts = pp.toList().toFlowable().test();

            pp.onNext(1);

            Runnable r1 = new Runnable() {
                @Override
                public void run() {
                    pp.onComplete();
                }
            };
            Runnable r2 = new Runnable() {
                @Override
                public void run() {
                    ts.cancel();
                }
            };

            TestHelper.race(r1, r2);

            if (ts.values().size() != 0) {
                ts.assertValue(Arrays.asList(1))
                .assertNoErrors();
            }
        }",loop_control
current,"for (Integer current : ts.values()) {
            Assert.assertTrue(""The sequence must be increasing [current value="" + previous +
                    "", previous value="" + current + ""]"", previous <= current);
            previous = current;
        }",iterator
current,"for (Integer current : ts.values()) {
            Assert.assertTrue(""The sequence must be increasing [current value="" + previous +
                    "", previous value="" + current + ""]"", previous <= current);
            previous = current;
        }",iterator
i,"for (Long i : ts.values()) {
            sum += i;
        }",iterator
bs,"{
            BooleanSubscription bs = new BooleanSubscription();
            s.onSubscribe(bs);
            long i = 0;
            while (!bs.isCancelled()) {
                s.onNext(i++);
            }
        }",maybe_loop_control
i,"for (long i = 0; i < n; i++) {
                    if (bs.isCancelled()) {
                        break;
                    }
                    s.onNext(i);
                }",loop_control
bs,"{
                BooleanSubscription bs = new BooleanSubscription();
                s.onSubscribe(bs);
                for (long i = 0; i < n; i++) {
                    if (bs.isCancelled()) {
                        break;
                    }
                    s.onNext(i);
                }
                s.onComplete();
            }",break_loop_control
bs,"{
                BooleanSubscription bs = new BooleanSubscription();
                s.onSubscribe(bs);
                for (int i = 0; !bs.isCancelled(); i++) {
                    System.out.println(""Emit: "" + i);
                    count.incrementAndGet();
                    s.onNext(i);
                }
            }",maybe_loop_control
s,"for (String s : values) {
                            System.out.println(""TestFlowable onNext: "" + s);
                            subscriber.onNext(s);
                        }",iterator
bs,"{
            BooleanSubscription bs = new BooleanSubscription();
            op.onSubscribe(bs);
            long l = 1;
            while (!bs.isCancelled()) {
                op.onNext(l++);
            }
            op.onComplete();
        }",maybe_loop_control
i,"for (int i = 0; i < TestHelper.RACE_LONG_LOOPS; i++) {

            final TestSubscriber<Integer> ts = Flowable.range(1, 2).take(2).test(0L);

            Runnable r1 = new Runnable() {
                @Override
                public void run() {
                    ts.request(1);
                }
            };

            TestHelper.race(r1, r1);

            ts.assertResult(1, 2);
        }",loop_control
s,"for (String s : valuesToReturn) {
                if (s == null) {
                    System.out.println(""throwing exception"");
                    subscriber.onError(new NullPointerException());
                    errorThrown = true;
                    // purposefully not returning here so it will continue calling onNext
                    // so that we also test that we handle bad sequences like this
                } else {
                    subscriber.onNext(s);
                }
            }",iterator
s,"for (String s : valuesToReturn) {
                        if (s == null) {
                            System.out.println(""throwing exception"");
                            try {
                                Thread.sleep(100);
                            } catch (Throwable e) {

                            }
                            subscriber.onError(new NullPointerException());
                            return;
                        } else {
                            subscriber.onNext(s);
                        }
                    }",iterator
i,"for (int i = 0; i < 50; i++) {
            final TestASynchronous1sDelayedFlowable f1 = new TestASynchronous1sDelayedFlowable();
            final TestASynchronous1sDelayedFlowable f2 = new TestASynchronous1sDelayedFlowable();
            Flowable<Flowable<String>> parentFlowable = Flowable.unsafeCreate(new Publisher<Flowable<String>>() {
                @Override
                public void subscribe(Subscriber<? super Flowable<String>> op) {
                    op.onSubscribe(new BooleanSubscription());
                    op.onNext(Flowable.unsafeCreate(f1));
                    op.onNext(Flowable.unsafeCreate(f2));
                    op.onError(new NullPointerException(""throwing exception in parent""));
                }
            });

            stringSubscriber = TestHelper.mockSubscriber();

            TestSubscriberEx<String> ts = new TestSubscriberEx<>(stringSubscriber);
            Flowable<String> m = Flowable.mergeDelayError(parentFlowable);
            m.subscribe(ts);
            System.out.println(""testErrorInParentFlowableDelayed | "" + i);
            ts.awaitDone(2000, TimeUnit.MILLISECONDS);
            ts.assertTerminated();

            verify(stringSubscriber, times(2)).onNext(""hello"");
            verify(stringSubscriber, times(1)).onError(any(NullPointerException.class));
            verify(stringSubscriber, never()).onComplete();
        }",loop_control
i,"for (int i = 1; i < 100; i++) {

            @SuppressWarnings(""unchecked"")
            Flowable<Integer>[] sources = new Flowable[i];
            Arrays.fill(sources, Flowable.just(1));
            Integer[] expected = new Integer[i];
            for (int j = 0; j < i; j++) {
                expected[j] = 1;
            }

            Flowable.mergeArrayDelayError(sources)
            .test()
            .assertResult(expected);
        }",loop_control
j,"for (int j = 0; j < i; j++) {
                expected[j] = 1;
            }",loop_control
it,"{
        Flowable<String> obs = Flowable.just(""one"", ""two"", ""three"");

        Iterator<String> it = obs.blockingIterable().iterator();

        assertTrue(it.hasNext());
        assertEquals(""one"", it.next());

        assertTrue(it.hasNext());
        assertEquals(""two"", it.next());

        assertTrue(it.hasNext());
        assertEquals(""three"", it.next());

        assertFalse(it.hasNext());

    }",iterator
it,"{
        Flowable<String> obs = Flowable.unsafeCreate(new Publisher<String>() {

            @Override
            public void subscribe(Subscriber<? super String> subscriber) {
                subscriber.onSubscribe(new BooleanSubscription());
                subscriber.onNext(""one"");
                subscriber.onError(new TestException());
            }
        });

        Iterator<String> it = obs.blockingIterable().iterator();

        assertTrue(it.hasNext());
        assertEquals(""one"", it.next());

        assertTrue(it.hasNext());
        it.next();
    }",iterator
it,"{
        final Counter src = new Counter();

        Flowable<Integer> obs = Flowable.fromIterable(new Iterable<Integer>() {
            @Override
            public Iterator<Integer> iterator() {
                return src;
            }
        });

        Iterator<Integer> it = obs.blockingIterable().iterator();
        while (it.hasNext()) {
            // Correct backpressure should cause this interleaved behavior.
            // We first request RxRingBuffer.SIZE. Then in increments of
            // SubscriberIterator.LIMIT.
            int i = it.next();
            int expected = i - (i % (Flowable.bufferSize() - (Flowable.bufferSize() >> 2))) + Flowable.bufferSize();
            expected = Math.min(expected, Counter.MAX);

            assertEquals(expected, src.count);
        }
    }",iterator
it,"{
        BlockingFlowableIterator<Integer> it = new BlockingFlowableIterator<>(128);
        it.remove();
    }",iterator
it,"{
        BlockingFlowableIterator<Integer> it = new BlockingFlowableIterator<>(128);

        assertFalse(it.isDisposed());

        it.dispose();

        assertTrue(it.isDisposed());
    }",iterator
it,"{
        BlockingFlowableIterator<Integer> it = new BlockingFlowableIterator<>(128);

        try {
            Thread.currentThread().interrupt();

            it.hasNext();
        } catch (RuntimeException ex) {
            assertTrue(ex.toString(), ex.getCause() instanceof InterruptedException);
        }
    }",iterator
it,"{
        BlockingFlowableIterator<Integer> it = new BlockingFlowableIterator<>(128);
        it.onComplete();
        it.next();
    }",iterator
it,"{
        Iterator<Integer> it = new Flowable<Integer>() {
            @Override
            protected void subscribeActual(Subscriber<? super Integer> s) {
                s.onSubscribe(new BooleanSubscription());
                s.onNext(1);
                s.onNext(2);
            }
        }
        .blockingIterable(1)
        .iterator();

        it.next();
    }",iterator
it,"{
        Iterator<Integer> it = PublishProcessor.<Integer>create()
                .blockingIterable().iterator();
        ((Disposable)it).dispose();
        assertFalse(it.hasNext());
        it.next();
    }",iterator
it,"{
        final Iterator<Integer> it = PublishProcessor.<Integer>create()
                .blockingIterable().iterator();

        Schedulers.single().scheduleDirect(new Runnable() {
            @Override
            public void run() {
                ((Disposable)it).dispose();
            }
        }, 1, TimeUnit.SECONDS);

        assertFalse(it.hasNext());
    }",iterator
i,"for (int i = 0; i < TestHelper.RACE_DEFAULT_LOOPS; i++) {
            final PublishProcessor<Integer> pp = PublishProcessor.create();

            final TestObserver<Boolean> to = Flowable.sequenceEqual(Flowable.never(), pp).test();

            Runnable r1 = new Runnable() {
                @Override
                public void run() {
                    to.dispose();
                }
            };

            Runnable r2 = new Runnable() {
                @Override
                public void run() {
                    pp.onNext(1);
                }
            };

            TestHelper.race(r1, r2);

            to.assertEmpty();
        }",loop_control
i,"for (int i = 0; i < TestHelper.RACE_DEFAULT_LOOPS; i++) {
            final PublishProcessor<Integer> pp = PublishProcessor.create();

            final TestSubscriber<Boolean> ts = Flowable.sequenceEqual(Flowable.never(), pp).toFlowable().test();

            Runnable r1 = new Runnable() {
                @Override
                public void run() {
                    ts.cancel();
                }
            };

            Runnable r2 = new Runnable() {
                @Override
                public void run() {
                    pp.onNext(1);
                }
            };

            TestHelper.race(r1, r2);

            ts.assertEmpty();
        }",loop_control
i,"for (int i = 0; i < TestHelper.RACE_DEFAULT_LOOPS; i++) {
            final TestSubscriber<Boolean> ts = new TestSubscriber<>();

            final PublishProcessor<Integer> pp = PublishProcessor.create();

            boolean swap = (i & 1) == 0;

            Flowable.sequenceEqual(swap ? pp : neverNever, swap ? neverNever : pp)
            .toFlowable()
            .subscribe(ts);

            Runnable r1 = new Runnable() {
                @Override
                public void run() {
                    pp.onNext(1);
                }
            };

            Runnable r2 = new Runnable() {
                @Override
                public void run() {
                    ts.cancel();
                }
            };

            TestHelper.race(r1, r2);

            ts.assertEmpty();
        }",loop_control
i,"for (int i = 0; i < 10; i++) {
                    s.onNext(i);
                }",loop_control
i,"for (int i = 0; i < TestHelper.RACE_DEFAULT_LOOPS; i++) {
            final TestObserver<Boolean> to = new TestObserver<>();

            final PublishProcessor<Integer> pp = PublishProcessor.create();

            boolean swap = (i & 1) == 0;

            Flowable.sequenceEqual(swap ? pp : neverNever, swap ? neverNever : pp)
            .subscribe(to);

            Runnable r1 = new Runnable() {
                @Override
                public void run() {
                    pp.onNext(1);
                }
            };

            Runnable r2 = new Runnable() {
                @Override
                public void run() {
                    to.dispose();
                }
            };

            TestHelper.race(r1, r2);

            to.assertEmpty();
        }",loop_control
i,"for (int i = 0; i < 10; i++) {
                    s.onNext(i);
                }",loop_control
i,"for (int i = 1; i <= n; i++) {
            System.out.println(""test1ToNSources: "" + i + "" sources"");
            List<Flowable<Integer>> sources = new ArrayList<>();
            List<Object> values = new ArrayList<>();
            for (int j = 0; j < i; j++) {
                sources.add(Flowable.just(j));
                values.add(j);
            }

            Flowable<List<Object>> result = Flowable.combineLatest(sources, func);

            Subscriber<List<Object>> subscriber = TestHelper.mockSubscriber();

            result.subscribe(subscriber);

            verify(subscriber).onNext(values);
            verify(subscriber).onComplete();
            verify(subscriber, never()).onError(any(Throwable.class));
        }",loop_control
j,"for (int j = 0; j < i; j++) {
                sources.add(Flowable.just(j));
                values.add(j);
            }",loop_control
i,"for (int i = 1; i <= n; i++) {
            System.out.println(""test1ToNSourcesScheduled: "" + i + "" sources"");
            List<Flowable<Integer>> sources = new ArrayList<>();
            List<Object> values = new ArrayList<>();
            for (int j = 0; j < i; j++) {
                sources.add(Flowable.just(j).subscribeOn(Schedulers.io()));
                values.add(j);
            }

            Flowable<List<Object>> result = Flowable.combineLatest(sources, func);

            final Subscriber<List<Object>> subscriber = TestHelper.mockSubscriber();

            final CountDownLatch cdl = new CountDownLatch(1);

            Subscriber<List<Object>> s = new DefaultSubscriber<List<Object>>() {

                @Override
                public void onNext(List<Object> t) {
                    subscriber.onNext(t);
                }

                @Override
                public void onError(Throwable e) {
                    subscriber.onError(e);
                    cdl.countDown();
                }

                @Override
                public void onComplete() {
                    subscriber.onComplete();
                    cdl.countDown();
                }
            };

            result.subscribe(s);

            cdl.await();

            verify(subscriber).onNext(values);
            verify(subscriber).onComplete();
            verify(subscriber, never()).onError(any(Throwable.class));
        }",loop_control
j,"for (int j = 0; j < i; j++) {
                sources.add(Flowable.just(j).subscribeOn(Schedulers.io()));
                values.add(j);
            }",loop_control
i,"for (int i = 0; i < 5000; i++) {
            backpressure();
        }",loop_control
i,"for (int i = 0; i < n; i++) {
            sources.add(Flowable.just(i));
            expected.append(i);
        }",loop_control
o,"for (Object o : args) {
                    b.append(o);
                }",iterator
i,"for (int i = 2; i < 10; i++) {
            Class<?>[] types = new Class[i + 1];
            Arrays.fill(types, Publisher.class);
            types[i] = i == 2 ? BiFunction.class : Class.forName(""io.reactivex.rxjava3.functions.Function"" + i);

            Method m = Flowable.class.getMethod(""combineLatest"", types);

            Object[] params = new Object[i + 1];
            Arrays.fill(params, source);
            params[i] = ArgsToString.INSTANCE;

            StringBuilder b = new StringBuilder();
            for (int j = 0; j < i; j++) {
                b.append('1');
            }

            ((Flowable)m.invoke(null, params)).test().assertResult(b.toString());

            for (int j = 0; j < params.length; j++) {
                Object[] params0 = params.clone();
                params0[j] = null;

                try {
                    m.invoke(null, params0);
                    fail(""Should have thrown @ "" + m);
                } catch (InvocationTargetException ex) {
                    assertTrue(ex.toString(), ex.getCause() instanceof NullPointerException);

                    if (j < i) {
                        assertEquals(""source"" + (j + 1) + "" is null"", ex.getCause().getMessage());
                    } else {
                        assertEquals(""combiner is null"", ex.getCause().getMessage());
                    }
                }
            }
        }",loop_control
j,"for (int j = 0; j < i; j++) {
                b.append('1');
            }",loop_control
j,"for (int j = 0; j < params.length; j++) {
                Object[] params0 = params.clone();
                params0[j] = null;

                try {
                    m.invoke(null, params0);
                    fail(""Should have thrown @ "" + m);
                } catch (InvocationTargetException ex) {
                    assertTrue(ex.toString(), ex.getCause() instanceof NullPointerException);

                    if (j < i) {
                        assertEquals(""source"" + (j + 1) + "" is null"", ex.getCause().getMessage());
                    } else {
                        assertEquals(""combiner is null"", ex.getCause().getMessage());
                    }
                }
            }",loop_control
i,"for (int i = 1; i < 100; i++) {
            Flowable<Integer>[] sources = new Flowable[i];
            Arrays.fill(sources, Flowable.just(1));
            List<Object> expected = new ArrayList<>(i);
            for (int j = 1; j <= i; j++) {
                expected.add(1);
            }

            Flowable.combineLatestArray(sources, new Function<Object[], List<Object>>() {
                @Override
                public List<Object> apply(Object[] t) throws Exception {
                    return Arrays.asList(t);
                }
            })
            .test()
            .assertResult(expected);

            Flowable.combineLatestArrayDelayError(sources, new Function<Object[], List<Object>>() {
                @Override
                public List<Object> apply(Object[] t) throws Exception {
                    return Arrays.asList(t);
                }
            })
            .test()
            .assertResult(expected);
        }",loop_control
j,"for (int j = 1; j <= i; j++) {
                expected.add(1);
            }",loop_control
i,"for (int i = 0; i < TestHelper.RACE_DEFAULT_LOOPS; i++) {
            List<Throwable> errors = TestHelper.trackPluginErrors();
            try {
                final PublishProcessor<Integer> pp1 = PublishProcessor.create();
                final PublishProcessor<Integer> pp2 = PublishProcessor.create();

                TestSubscriberEx<Integer> ts = Flowable.combineLatest(pp1, pp2, new BiFunction<Integer, Integer, Integer>() {
                    @Override
                    public Integer apply(Integer a, Integer b) throws Exception {
                        return a;
                    }
                }).to(TestHelper.<Integer>testConsumer());

                final TestException ex1 = new TestException();
                final TestException ex2 = new TestException();

                Runnable r1 = new Runnable() {
                    @Override
                    public void run() {
                        pp1.onError(ex1);
                    }
                };
                Runnable r2 = new Runnable() {
                    @Override
                    public void run() {
                        pp2.onError(ex2);
                    }
                };

                TestHelper.race(r1, r2);

                if (ts.errors().size() != 0) {
                    if (ts.errors().get(0) instanceof CompositeException) {
                        ts.assertSubscribed()
                        .assertNotComplete()
                        .assertNoValues();

                        for (Throwable e : TestHelper.errorList(ts)) {
                            assertTrue(e.toString(), e instanceof TestException);
                        }

                    } else {
                        ts.assertFailure(TestException.class);
                    }
                }

                for (Throwable e : errors) {
                    assertTrue(e.toString(), e.getCause() instanceof TestException);
                }
            } finally {
                RxJavaPlugins.reset();
            }
        }",loop_control
e,"for (Throwable e : TestHelper.errorList(ts)) {
                            assertTrue(e.toString(), e instanceof TestException);
                        }",iterator
e,"for (Throwable e : errors) {
                    assertTrue(e.toString(), e.getCause() instanceof TestException);
                }",iterator
i,"for (int i = 0; i < TestHelper.RACE_DEFAULT_LOOPS; i++) {

            TestSubscriber<Integer> ts = new TestSubscriber<>();
            PublishProcessor<Integer> pp = PublishProcessor.create();

            Flowable.combineLatest(pp, Flowable.never(), (a, b) -> a)
            .subscribe(ts);

            TestHelper.race(() -> pp.onComplete(), () -> ts.cancel());
        }",loop_control
i,"for (int i = 0; i < TestHelper.RACE_DEFAULT_LOOPS; i++) {

                TestSubscriberEx<Object[]> ts = new TestSubscriberEx<>();
                AtomicReference<Subscriber<? super Object>> ref = new AtomicReference<>();
                Flowable<Object> f = new Flowable<Object>() {
                    @Override
                    public void subscribeActual(Subscriber<? super Object> s) {
                        ref.set(s);
                    }
                };

                Flowable.combineLatestDelayError(Arrays.asList(f, Flowable.never()), (a) -> a)
                .subscribe(ts);

                ref.get().onSubscribe(new BooleanSubscription());

                TestHelper.race(() -> ref.get().onError(ex), () -> ts.cancel());

                if (ts.errors().isEmpty()) {
                    TestHelper.assertUndeliverable(errors, 0, TestException.class);
                }
            }",loop_control
i,"for (int i = 0; i < TestHelper.RACE_DEFAULT_LOOPS; i++) {
            final TestSubscriber<Object> ts = source.test(0L);

            Runnable r = new Runnable() {
                @Override
                public void run() {
                    for (int j = 0; j < 500; j++) {
                        ts.request(1);
                    }
                }
            };

            TestHelper.race(r, r);

            ts.assertValueCount(1000);
        }",loop_control
j,"for (int j = 0; j < 500; j++) {
                        ts.request(1);
                    }",loop_control
i,"for (int i = 0; i < TestHelper.RACE_DEFAULT_LOOPS; i++) {
            final PublishProcessor<Object> pp1 = PublishProcessor.create();
            final PublishProcessor<Object> pp2 = PublishProcessor.create();

            List<Throwable> errors = TestHelper.trackPluginErrors();

            try {
                TestSubscriberEx<Flowable<Integer>> ts = Flowable.just(1)
                .groupJoin(
                    Flowable.just(2).concatWith(Flowable.<Integer>never()),
                    new Function<Integer, Flowable<Object>>() {
                        @Override
                        public Flowable<Object> apply(Integer left) throws Exception {
                            return pp1;
                        }
                    },
                    new Function<Integer, Flowable<Object>>() {
                        @Override
                        public Flowable<Object> apply(Integer right) throws Exception {
                            return pp2;
                        }
                    },
                    new BiFunction<Integer, Flowable<Integer>, Flowable<Integer>>() {
                        @Override
                        public Flowable<Integer> apply(Integer r, Flowable<Integer> l) throws Exception {
                            return l;
                        }
                    }
                )
                .to(TestHelper.<Flowable<Integer>>testConsumer());

                final TestException ex1 = new TestException();
                final TestException ex2 = new TestException();

                Runnable r1 = new Runnable() {
                    @Override
                    public void run() {
                        pp1.onError(ex1);
                    }
                };
                Runnable r2 = new Runnable() {
                    @Override
                    public void run() {
                        pp2.onError(ex2);
                    }
                };

                TestHelper.race(r1, r2);

                ts.assertError(Throwable.class).assertSubscribed().assertNotComplete().assertValueCount(1);

                Throwable exc = ts.errors().get(0);

                if (exc instanceof CompositeException) {
                    List<Throwable> es = TestHelper.compositeList(exc);
                    TestHelper.assertError(es, 0, TestException.class);
                    TestHelper.assertError(es, 1, TestException.class);
                } else {
                    ts.assertError(TestException.class);
                }

                if (!errors.isEmpty()) {
                    TestHelper.assertUndeliverable(errors, 0, TestException.class);
                }
            } finally {
                RxJavaPlugins.reset();
            }
        }",loop_control
i,"for (int i = 0; i < TestHelper.RACE_DEFAULT_LOOPS; i++) {
            final PublishProcessor<Object> pp1 = PublishProcessor.create();
            final PublishProcessor<Object> pp2 = PublishProcessor.create();

            List<Throwable> errors = TestHelper.trackPluginErrors();

            try {
                TestSubscriberEx<Object> ts = pp1
                .groupJoin(
                    pp2,
                    new Function<Object, Flowable<Object>>() {
                        @Override
                        public Flowable<Object> apply(Object left) throws Exception {
                            return Flowable.never();
                        }
                    },
                    new Function<Object, Flowable<Object>>() {
                        @Override
                        public Flowable<Object> apply(Object right) throws Exception {
                            return Flowable.never();
                        }
                    },
                    new BiFunction<Object, Flowable<Object>, Flowable<Object>>() {
                        @Override
                        public Flowable<Object> apply(Object r, Flowable<Object> l) throws Exception {
                            return l;
                        }
                    }
                )
                .flatMap(Functions.<Flowable<Object>>identity())
                .to(TestHelper.<Object>testConsumer());

                final TestException ex1 = new TestException();
                final TestException ex2 = new TestException();

                Runnable r1 = new Runnable() {
                    @Override
                    public void run() {
                        pp1.onError(ex1);
                    }
                };
                Runnable r2 = new Runnable() {
                    @Override
                    public void run() {
                        pp2.onError(ex2);
                    }
                };

                TestHelper.race(r1, r2);

                ts.assertError(Throwable.class).assertSubscribed().assertNotComplete().assertNoValues();

                Throwable exc = ts.errors().get(0);

                if (exc instanceof CompositeException) {
                    List<Throwable> es = TestHelper.compositeList(exc);
                    TestHelper.assertError(es, 0, TestException.class);
                    TestHelper.assertError(es, 1, TestException.class);
                } else {
                    ts.assertError(TestException.class);
                }

                if (!errors.isEmpty()) {
                    TestHelper.assertUndeliverable(errors, 0, TestException.class);
                }
            } finally {
                RxJavaPlugins.reset();
            }
        }",loop_control
i,"for (int i = 0; i < TestHelper.RACE_DEFAULT_LOOPS; i++) {
            TestSubscriber<Integer> ts = new TestSubscriber<>();
            final ScalarSubscription<Integer> sd = new ScalarSubscription<>(ts, 1);
            ts.onSubscribe(sd);

            Runnable r1 = new Runnable() {
                @Override
                public void run() {
                    sd.request(1);
                }
            };

            Runnable r2 = new Runnable() {
                @Override
                public void run() {
                    sd.cancel();
                }
            };

            TestHelper.race(r1, r2);
        }",loop_control
i,"for (int i = 0; i < 5; i++) {
            Flowable<Integer> f = Flowable.just(it, it)
            .flatMapIterable(Functions.<Iterable<Integer>>identity());

            for (int j = 0; j < i; j++) {
                f = f.share();
            }

            f
            .count()
            .test()
            .withTag(""Share: "" + i)
            .assertResult(600L);
        }",loop_control
j,"for (int j = 0; j < i; j++) {
                f = f.share();
            }",loop_control
i,"for (int i = 0; i < 5; i++) {
            Flowable<Integer> f = Flowable.just(it, it)
            .flatMapIterable(Functions.<Iterable<Integer>>identity())
            .hide();

            for (int j = 0; j < i; j++) {
                f = f.share();
            }

            f
            .count()
            .test()
            .withTag(""Share: "" + i)
            .assertResult(600L);
        }",loop_control
j,"for (int j = 0; j < i; j++) {
                f = f.share();
            }",loop_control
i,"for (int i = 0; i < 10; i++) {
            publishNext(o1, i * 5, ""a"" + (i + 1));
            publishNext(o2, 5 + i * 5, ""b"" + (i + 1));
            publishNext(o3, 10 + i * 5, ""c"" + (i + 1));
        }",loop_control
i,"for (int i = 0; i < TestHelper.RACE_DEFAULT_LOOPS; i++) {
            List<Throwable> errors = TestHelper.trackPluginErrors();
            try {

                final PublishProcessor<Integer> pp1 = PublishProcessor.create();
                final PublishProcessor<Integer> pp2 = PublishProcessor.create();

                pp1.switchMap(new Function<Integer, Flowable<Integer>>() {
                    @Override
                    public Flowable<Integer> apply(Integer v) throws Exception {
                        if (v == 1) {
                            return pp2;
                        }
                        return Flowable.never();
                    }
                })
                .test();

                Runnable r1 = new Runnable() {
                    @Override
                    public void run() {
                        pp1.onNext(2);
                    }
                };

                final TestException ex = new TestException();

                Runnable r2 = new Runnable() {
                    @Override
                    public void run() {
                        pp2.onError(ex);
                    }
                };

                TestHelper.race(r1, r2);

                for (Throwable e : errors) {
                    assertTrue(e.toString(), e instanceof TestException);
                }
            } finally {
                RxJavaPlugins.reset();
            }
        }",loop_control
e,"for (Throwable e : errors) {
                    assertTrue(e.toString(), e instanceof TestException);
                }",iterator
i,"for (int i = 0; i < TestHelper.RACE_DEFAULT_LOOPS; i++) {
            List<Throwable> errors = TestHelper.trackPluginErrors();
            try {

                final PublishProcessor<Integer> pp1 = PublishProcessor.create();
                final PublishProcessor<Integer> pp2 = PublishProcessor.create();

                pp1.switchMap(new Function<Integer, Flowable<Integer>>() {
                    @Override
                    public Flowable<Integer> apply(Integer v) throws Exception {
                        if (v == 1) {
                            return pp2;
                        }
                        return Flowable.never();
                    }
                })
                .test();

                final TestException ex1 = new TestException();

                Runnable r1 = new Runnable() {
                    @Override
                    public void run() {
                        pp1.onError(ex1);
                    }
                };

                final TestException ex2 = new TestException();

                Runnable r2 = new Runnable() {
                    @Override
                    public void run() {
                        pp2.onError(ex2);
                    }
                };

                TestHelper.race(r1, r2);

                for (Throwable e : errors) {
                    assertTrue(e.toString(), e instanceof TestException);
                }
            } finally {
                RxJavaPlugins.reset();
            }
        }",loop_control
e,"for (Throwable e : errors) {
                    assertTrue(e.toString(), e instanceof TestException);
                }",iterator
i,"for (int i = 0; i < TestHelper.RACE_DEFAULT_LOOPS; i++) {
            final PublishProcessor<Integer> pp1 = PublishProcessor.create();

            final TestSubscriber<Integer> ts = pp1.switchMap(new Function<Integer, Flowable<Integer>>() {
                @Override
                public Flowable<Integer> apply(Integer v) throws Exception {
                    return Flowable.never();
                }
            })
            .test();

            Runnable r1 = new Runnable() {
                @Override
                public void run() {
                    pp1.onNext(2);
                }
            };

            Runnable r2 = new Runnable() {
                @Override
                public void run() {
                    ts.cancel();
                }
            };

            TestHelper.race(r1, r2);
        }",loop_control
i,"for (int i = 0; i < 10; i++) {
                    s.onNext(i);
                }",loop_control
i,"for (int i = 0; i < TestHelper.RACE_DEFAULT_LOOPS; i++) {
            final TestSubscriber<Integer> ts = new TestSubscriber<>();

            final PublishProcessor<Integer> pp = PublishProcessor.create();

            Flowable.just(1).hide()
            .switchMap(Functions.justFunction(pp))
            .subscribe(ts);

            Runnable r1 = new Runnable() {
                @Override
                public void run() {
                    ts.cancel();
                }
            };

            Runnable r2 = new Runnable() {
                @Override
                public void run() {
                    pp.onNext(1);
                }
            };

            TestHelper.race(r1, r2);
        }",loop_control
i,"for (int i = 0; i < n; i++) {
            Flowable.<Integer>create(it -> {
                it.onNext(0);
            }, BackpressureStrategy.MISSING)
            .switchMap(v -> createFlowable(inner))
            .observeOn(Schedulers.computation())
            .doFinally(() -> {
                outer.incrementAndGet();
            })
            .take(1)
            .blockingSubscribe(v -> { }, Throwable::printStackTrace);
        }",loop_control
i,"for (int i = 0; i < 11; i++) {
            TestHelper.assertError(errors, i, TestException.class);
        }",loop_control
i,"for (int i = 0; i < TestHelper.RACE_DEFAULT_LOOPS; i++) {
            final TestSubscriber<Integer> ts = Flowable.just(1).concatWith(Flowable.<Integer>never())
            .flatMapSingle(Functions.justFunction(Single.just(2))).test(0);

            Runnable r1 = new Runnable() {
                @Override
                public void run() {
                    ts.request(1);
                }
            };
            Runnable r2 = new Runnable() {
                @Override
                public void run() {
                    ts.cancel();
                }
            };

            TestHelper.race(r1, r2);
        }",loop_control
i,"for (int i = 0; i < TestHelper.RACE_DEFAULT_LOOPS; i++) {
            SingleSubject<Integer> ss1 = SingleSubject.create();
            SingleSubject<Integer> ss2 = SingleSubject.create();

            TestSubscriber<Integer> ts = Flowable.just(ss1, ss2).flatMapSingle(v -> v)
            .test();

            TestHelper.race(
                    () -> ss1.onSuccess(1),
                    () -> ss2.onSuccess(1)
            );

            ts.assertResult(1, 1);
        }",loop_control
i,"for (int i = 0; i < 500; i++) {
            if (i % 10 == 0) {
                System.out.println(""testNestedAsyncConcat >> "" + i);
            }
            nestedAsyncConcat();
        }",loop_control
i,"for (int i = 0; i < n; i++) {
            list.add(i);
        }",loop_control
i,"for (int i = 0; i < n / 2; i++) {
            list.add(i);
        }",loop_control
i,"for (int i = 2; i < 10; i++) {
            Flowable<Integer>[] obs = new Flowable[i];
            Arrays.fill(obs, Flowable.just(1));

            Integer[] expected = new Integer[i];
            Arrays.fill(expected, 1);

            Method m = Flowable.class.getMethod(""concatArray"", Publisher[].class);

            TestSubscriber<Integer> ts = TestSubscriber.create();

            ((Flowable<Integer>)m.invoke(null, new Object[]{obs})).subscribe(ts);

            ts.assertValues(expected);
            ts.assertNoErrors();
            ts.assertComplete();
        }",loop_control
i,"for (int i = 0; i < 10; i++) {
                    s.onNext(i);
                }",loop_control
b,"for (int b = 1; b <= n; b *= 2) {
            List<Integer> list = Flowable.range(1, n)
            .scan(0, new BiFunction<Integer, Integer, Integer>() {
                @Override
                public Integer apply(Integer a, Integer b) throws Exception {
                    return b;
                }
            })
            .rebatchRequests(b)
            .toList()
            .blockingGet();

            for (int i = 0; i <= n; i++) {
                assertEquals(i, list.get(i).intValue());
            }
        }",loop_control
i,"for (int i = 0; i <= n; i++) {
                assertEquals(i, list.get(i).intValue());
            }",loop_control
s,"for (String s : values) {
                            System.out.println(""TestFlowable onNext: "" + s);
                            subscriber.onNext(s);
                        }",iterator
i,"for (int i = 0; i < TestHelper.RACE_DEFAULT_LOOPS; i++) {

                TestSubscriber<Integer> ts = source.take(1)
                .repeatWhen(new Function<Flowable<Object>, Flowable<Integer>>() {
                    @Override
                    public Flowable<Integer> apply(Flowable<Object> v)
                            throws Exception {
                        return signaller;
                    }
                }).test();

                Runnable r1 = new Runnable() {
                    @Override
                    public void run() {
                        for (int i = 0; i < TestHelper.RACE_DEFAULT_LOOPS; i++) {
                            source.onNext(1);
                        }
                    }
                };
                Runnable r2 = new Runnable() {
                    @Override
                    public void run() {
                        for (int i = 0; i < TestHelper.RACE_DEFAULT_LOOPS; i++) {
                            signaller.offer(1);
                        }
                    }
                };

                TestHelper.race(r1, r2);

                ts.cancel();
            }",loop_control
e,"for (Throwable e : errors) {
                    e.printStackTrace();
                }",iterator
i,"for (int i = 0; i < 11; i++) {
            TestHelper.assertError(errors, i, TestException.class);
        }",loop_control
i,"for (int i = 0; i < 10; i++) {
            TestHelper.assertError(errors, i, TestException.class);
        }",loop_control
i,"for (int i = 0; i < 11; i++) {
            TestHelper.assertError(errors, i, TestException.class);
        }",loop_control
i,"for (int i = 0; i < 10; i++) {
            TestHelper.assertError(errors, i, TestException.class);
        }",loop_control
itemCount,"for (int itemCount = 1; itemCount <= 100000; itemCount *= 10) {
            for (int concurrency = 1; concurrency <= 256; concurrency *= 2) {
                Flowable.range(1, itemCount)
                .flatMapCompletable(
                        Functions.justFunction(Completable.complete()
                        .subscribeOn(Schedulers.computation()))
                        , false, concurrency)
                .test()
                .withTag(""itemCount="" + itemCount + "", concurrency="" + concurrency)
                .awaitDone(5, TimeUnit.SECONDS)
                .assertResult();
            }
        }",iterator
concurrency,"for (int concurrency = 1; concurrency <= 256; concurrency *= 2) {
                Flowable.range(1, itemCount)
                .flatMapCompletable(
                        Functions.justFunction(Completable.complete()
                        .subscribeOn(Schedulers.computation()))
                        , false, concurrency)
                .test()
                .withTag(""itemCount="" + itemCount + "", concurrency="" + concurrency)
                .awaitDone(5, TimeUnit.SECONDS)
                .assertResult();
            }",iterator
i,"for (int i = 0; i < TestHelper.RACE_DEFAULT_LOOPS; i++) {
            PublishProcessor<Integer> pp1 = PublishProcessor.create();

            TestSubscriber<Object> ts = new TestSubscriber<>();
            CountDownLatch cdl = new CountDownLatch(1);

            pp1.flatMapCompletable(v -> {
                TestHelper.raceOther(() -> {
                    ts.cancel();
                }, cdl);
                return Completable.complete();
            })
            .toFlowable()
            .subscribe(ts);

            pp1.onNext(1);

            cdl.await();
        }",loop_control
i,"for (int i = 0; i < TestHelper.RACE_DEFAULT_LOOPS; i++) {
            PublishProcessor<Integer> pp1 = PublishProcessor.create();

            TestObserver<Void> to = new TestObserver<>();
            CountDownLatch cdl = new CountDownLatch(1);

            pp1.flatMapCompletable(v -> {
                TestHelper.raceOther(() -> {
                    to.dispose();
                }, cdl);
                return Completable.complete();
            })
            .subscribe(to);

            pp1.onNext(1);

            cdl.await();
        }",loop_control
arg,"for (String arg : args) {
            list.add(arg);
        }",iterator
i,"for (int i = 0; i < TestHelper.RACE_DEFAULT_LOOPS; i++) {
            final TestScheduler scheduler = new TestScheduler();

            final PublishProcessor<Object> pp = PublishProcessor.create();

            TestSubscriber<List<Object>> ts = pp.buffer(1, TimeUnit.SECONDS, scheduler, 5).test();

            pp.onNext(1);
            pp.onNext(2);
            pp.onNext(3);
            pp.onNext(4);

            Runnable r1 = new Runnable() {
                @Override
                public void run() {
                    pp.onNext(5);
                }
            };

            Runnable r2 = new Runnable() {
                @Override
                public void run() {
                    scheduler.advanceTimeBy(1, TimeUnit.SECONDS);
                }
            };

            TestHelper.race(r1, r2);

            pp.onComplete();

            int items = 0;
            for (List<Object> o : ts.values()) {
                items += o.size();
            }

            assertEquals(""Round: "" + i, 5, items);
        }",loop_control
o,"for (List<Object> o : ts.values()) {
                items += o.size();
            }",iterator
i,"for (int i = 0; i < TestHelper.RACE_DEFAULT_LOOPS; i++) {
            BehaviorProcessor<Integer> bp = BehaviorProcessor.createDefault(1);
            PublishProcessor<Integer> pp = PublishProcessor.create();

            TestSubscriber<List<Integer>> ts = bp
                    .buffer(BehaviorProcessor.createDefault(0), v -> pp)
                    .test();

            TestHelper.race(
                    () -> bp.onComplete(),
                    () -> pp.onComplete()
            );

            ts.assertResult(Arrays.asList(1));
        }",loop_control
i,"for (int i = 0; i < 10; i++) {
            try {
                refCountAsyncActual();
                return;
            } catch (AssertionError ex) {
                if (i == 9) {
                    throw ex;
                }
                Thread.sleep((int)(200 * (Math.random() * 10 + 1)));
            }
        }",loop_control
a,"for (;;) {
            int a = nextCount.get();
            int b = receivedCount.get();
            if (a > 10 && a < 20 && a == b) {
                break;
            }
            if (a >= 20) {
                break;
            }
            try {
                Thread.sleep(20);
            } catch (InterruptedException e) {
            }
        }",break_loop_control
b,"for (;;) {
            int a = nextCount.get();
            int b = receivedCount.get();
            if (a > 10 && a < 20 && a == b) {
                break;
            }
            if (a >= 20) {
                break;
            }
            try {
                Thread.sleep(20);
            } catch (InterruptedException e) {
            }
        }",maybe_loop_control
i,"for (int i = 0; i < 10; i++) {
            TestSubscriber<Long> ts1 = new TestSubscriber<>();
            TestSubscriber<Long> ts2 = new TestSubscriber<>();
            r.subscribe(ts1);
            r.subscribe(ts2);
            try {
                Thread.sleep(50);
            } catch (InterruptedException e) {
            }
            ts1.cancel();
            ts2.cancel();
            ts1.assertNoErrors();
            ts2.assertNoErrors();
            assertTrue(ts1.values().size() > 0);
            assertTrue(ts2.values().size() > 0);
        }",loop_control
i,"for (int i = 0; i < 100; i++) {
            connectUnsubscribeRaceCondition();
        }",loop_control
cancel,"{
                final AtomicBoolean cancel = new AtomicBoolean();
                subscriber.onSubscribe(new Subscription() {
                    @Override
                    public void request(long n) {

                    }

                    @Override
                    public void cancel() {
                        cancel.set(true);
                    }

                });
                for (;;) {
                    if (cancel.get()) {
                        break;
                    }
                    try {
                        Thread.sleep(100);
                    } catch (InterruptedException e) {
                    }
                    subscriber.onNext(1L);
                }
            }",break_loop_control
emitter,"{
                    @Override
                    public void subscribe(FlowableEmitter<Object> emitter) throws Exception {
                        while (!emitter.isCancelled()) {
                            Thread.sleep(100);
                        }
                        interrupted.set(true);
                    }
                }",maybe_loop_control
i,"for (int i = 0; i < 3; i++) {
            TestSubscriber<Integer> ts1 = source.test();

            ts1.assertEmpty();

            TestSubscriber<Integer> ts2 = source.test();

            ts1.assertResult(1, 2, 3, 4, 5);
            ts2.assertResult(1, 2, 3, 4, 5);
        }",loop_control
i,"for (int i = 0; i < 3; i++) {
            TestSubscriber<Integer> ts2 = source.test();
            ts1.cancel();
            ts1 = ts2;
        }",loop_control
i,"for (int i = 0; i < 1000; i++) {

            final Flowable<Integer> source = Flowable.range(1, 5)
                    .replay()
                    .refCount(1)
                    ;

            final TestSubscriber<Integer> ts1 = source.test(0);

            final TestSubscriber<Integer> ts2 = new TestSubscriber<>(0);

            Runnable r1 = new Runnable() {
                @Override
                public void run() {
                    ts1.cancel();
                }
            };

            Runnable r2 = new Runnable() {
                @Override
                public void run() {
                    source.subscribe(ts2);
                }
            };

            TestHelper.race(r1, r2, Schedulers.single());

            ts2.requestMore(6) // FIXME RxJava replay() doesn't issue onComplete without request
            .withTag(""Round: "" + i)
            .assertResult(1, 2, 3, 4, 5);
        }",loop_control
i,"for (int i = 0; i < TestHelper.RACE_LONG_LOOPS; i++) {
            Flowable<Integer> flowable = Flowable.just(1).replay(1).refCount();

            TestSubscriber<Integer> ts1 = flowable
                    .subscribeOn(Schedulers.io())
                    .test();

            TestSubscriber<Integer> ts2 = flowable
                    .subscribeOn(Schedulers.io())
                    .test();

            ts1
            .withTag("""" + i)
            .awaitDone(5, TimeUnit.SECONDS)
            .assertResult(1);

            ts2
            .withTag("""" + i)
            .awaitDone(5, TimeUnit.SECONDS)
            .assertResult(1);
        }",loop_control
i,"for (int i = 0; i < TestHelper.RACE_LONG_LOOPS; i++) {
            Flowable<Integer> flowable = Flowable.just(1).publish().refCount();

            TestSubscriber<Integer> subscriber1 = flowable
                    .subscribeOn(Schedulers.io())
                    .test();

            TestSubscriber<Integer> subscriber2 = flowable
                    .subscribeOn(Schedulers.io())
                    .test();

            subscriber1
            .withTag(""subscriber1 "" + i)
            .awaitDone(5, TimeUnit.SECONDS)
            .assertNoErrors()
            .assertComplete();

            subscriber2
            .withTag(""subscriber2 "" + i)
            .awaitDone(5, TimeUnit.SECONDS)
            .assertNoErrors()
            .assertComplete();
        }",loop_control
i,"for (int i = 1; !bs.isCancelled(); i++) {
                    count.incrementAndGet();
                    sub.onNext(i);
                }",loop_control
i,"for (int i = 0; i < TestHelper.RACE_DEFAULT_LOOPS; i++) {

            final TestSubscriber<Integer> ts = new TestSubscriber<>(0L);

            Worker w = Schedulers.computation().createWorker();

            final SubscribeOnSubscriber<Integer> so = new SubscribeOnSubscriber<>(ts, w, Flowable.<Integer>never(), true);
            ts.onSubscribe(so);

            final BooleanSubscription bs = new BooleanSubscription();

            try {
                Runnable r1 = new Runnable() {
                    @Override
                    public void run() {
                        so.onSubscribe(bs);
                    }
                };

                Runnable r2 = new Runnable() {
                    @Override
                    public void run() {
                        so.request(1);
                    }
                };

                TestHelper.race(r1, r2);
            } finally {
                w.dispose();
            }
        }",loop_control
i,"for (int i = 1; i < 1001; i++) {
                    s.onNext(i);
                    Thread.sleep(1);
                }",loop_control
i,"for (int i = 1; i < 1001; i++) {
                    s.onNext(i);
                    Thread.sleep(1);
                }",loop_control
i,"for (int i = 1; i < 1001; i++) {
                    s.onNext(i);
                    Thread.sleep(1);
                }",loop_control
i,"for (int i = 1; i < 1001; i++) {
                    s.onNext(i);
                    Thread.sleep(1);
                }",loop_control
i,"for (int i = 0; i < TestHelper.RACE_DEFAULT_LOOPS; i++) {
            final AtomicInteger count = new AtomicInteger();

            Cancellable c = new Cancellable() {
                @Override
                public void cancel() throws Exception {
                    count.getAndIncrement();
                }
            };

            final CancellableDisposable cd = new CancellableDisposable(c);

            Runnable r = new Runnable() {
                @Override
                public void run() {
                    cd.dispose();
                }
            };

            TestHelper.race(r, r);

            assertEquals(1, count.get());
        }",loop_control
i,"for (int i = 0; i < TestHelper.RACE_DEFAULT_LOOPS; i++) {
            final ListCompositeDisposable cd = new ListCompositeDisposable();

            Runnable run = new Runnable() {
                @Override
                public void run() {
                    cd.dispose();
                }
            };

            TestHelper.race(run, run);
        }",loop_control
i,"for (int i = 0; i < TestHelper.RACE_DEFAULT_LOOPS; i++) {
            final ListCompositeDisposable cd = new ListCompositeDisposable();

            Runnable run = new Runnable() {
                @Override
                public void run() {
                    cd.add(Disposable.empty());
                }
            };

            TestHelper.race(run, run);
        }",loop_control
i,"for (int i = 0; i < TestHelper.RACE_DEFAULT_LOOPS; i++) {
            final ListCompositeDisposable cd = new ListCompositeDisposable();

            Runnable run = new Runnable() {
                @Override
                public void run() {
                    cd.addAll(Disposable.empty());
                }
            };

            TestHelper.race(run, run);
        }",loop_control
i,"for (int i = 0; i < TestHelper.RACE_DEFAULT_LOOPS; i++) {
            final ListCompositeDisposable cd = new ListCompositeDisposable();

            final Disposable d1 = Disposable.empty();

            cd.add(d1);

            Runnable run = new Runnable() {
                @Override
                public void run() {
                    cd.remove(d1);
                }
            };

            TestHelper.race(run, run);
        }",loop_control
i,"for (int i = 0; i < TestHelper.RACE_DEFAULT_LOOPS; i++) {
            final ListCompositeDisposable cd = new ListCompositeDisposable();

            final Disposable d1 = Disposable.empty();

            cd.add(d1);

            Runnable run = new Runnable() {
                @Override
                public void run() {
                    cd.delete(d1);
                }
            };

            TestHelper.race(run, run);
        }",loop_control
i,"for (int i = 0; i < TestHelper.RACE_DEFAULT_LOOPS; i++) {
            final ListCompositeDisposable cd = new ListCompositeDisposable();

            final Disposable d1 = Disposable.empty();

            cd.add(d1);

            Runnable run = new Runnable() {
                @Override
                public void run() {
                    cd.clear();
                }
            };

            TestHelper.race(run, run);
        }",loop_control
i,"for (int i = 0; i < TestHelper.RACE_DEFAULT_LOOPS; i++) {
            final ListCompositeDisposable cd = new ListCompositeDisposable();

            Runnable run = new Runnable() {
                @Override
                public void run() {
                    cd.dispose();
                }
            };

            Runnable run2 = new Runnable() {
                @Override
                public void run() {
                    cd.add(Disposable.empty());
                }
            };

            TestHelper.race(run, run2);
        }",loop_control
i,"for (int i = 0; i < TestHelper.RACE_DEFAULT_LOOPS; i++) {
            final ListCompositeDisposable cd = new ListCompositeDisposable();

            Runnable run = new Runnable() {
                @Override
                public void run() {
                    cd.dispose();
                }
            };

            Runnable run2 = new Runnable() {
                @Override
                public void run() {
                    cd.addAll(Disposable.empty());
                }
            };

            TestHelper.race(run, run2);
        }",loop_control
i,"for (int i = 0; i < TestHelper.RACE_DEFAULT_LOOPS; i++) {
            final ListCompositeDisposable cd = new ListCompositeDisposable();

            final Disposable d1 = Disposable.empty();

            cd.add(d1);

            Runnable run = new Runnable() {
                @Override
                public void run() {
                    cd.dispose();
                }
            };

            Runnable run2 = new Runnable() {
                @Override
                public void run() {
                    cd.remove(d1);
                }
            };

            TestHelper.race(run, run2);
        }",loop_control
i,"for (int i = 0; i < TestHelper.RACE_DEFAULT_LOOPS; i++) {
            final ListCompositeDisposable cd = new ListCompositeDisposable();

            final Disposable d1 = Disposable.empty();

            cd.add(d1);

            Runnable run = new Runnable() {
                @Override
                public void run() {
                    cd.dispose();
                }
            };

            Runnable run2 = new Runnable() {
                @Override
                public void run() {
                    cd.delete(d1);
                }
            };

            TestHelper.race(run, run2);
        }",loop_control
i,"for (int i = 0; i < TestHelper.RACE_DEFAULT_LOOPS; i++) {
            final ListCompositeDisposable cd = new ListCompositeDisposable();

            final Disposable d1 = Disposable.empty();

            cd.add(d1);

            Runnable run = new Runnable() {
                @Override
                public void run() {
                    cd.dispose();
                }
            };

            Runnable run2 = new Runnable() {
                @Override
                public void run() {
                    cd.clear();
                }
            };

            TestHelper.race(run, run2);
        }",loop_control
i,"for (int i = 0; i < TestHelper.RACE_DEFAULT_LOOPS; i++) {
            final AtomicReference<Disposable> d = new AtomicReference<>();

            Runnable r = new Runnable() {
                @Override
                public void run() {
                    DisposableHelper.dispose(d);
                }
            };

            TestHelper.race(r, r);
        }",loop_control
i,"for (int i = 0; i < TestHelper.RACE_DEFAULT_LOOPS; i++) {
            final AtomicReference<Disposable> d = new AtomicReference<>();

            Runnable r = new Runnable() {
                @Override
                public void run() {
                    DisposableHelper.replace(d, Disposable.empty());
                }
            };

            TestHelper.race(r, r);
        }",loop_control
i,"for (int i = 0; i < TestHelper.RACE_DEFAULT_LOOPS; i++) {
            final AtomicReference<Disposable> d = new AtomicReference<>();

            Runnable r = new Runnable() {
                @Override
                public void run() {
                    DisposableHelper.set(d, Disposable.empty());
                }
            };

            TestHelper.race(r, r);
        }",loop_control
i,"for (int i = 0; i < TestHelper.RACE_DEFAULT_LOOPS; i++) {
            final ArrayCompositeDisposable acd = new ArrayCompositeDisposable(2);

            Runnable r = new Runnable() {
                @Override
                public void run() {
                    acd.dispose();
                }
            };

            TestHelper.race(r, r);
        }",loop_control
i,"for (int i = 0; i < TestHelper.RACE_DEFAULT_LOOPS; i++) {
            final ArrayCompositeDisposable acd = new ArrayCompositeDisposable(2);

            Runnable r = new Runnable() {
                @Override
                public void run() {
                    acd.replaceResource(0, Disposable.empty());
                }
            };

            TestHelper.race(r, r);
        }",loop_control
i,"for (int i = 0; i < TestHelper.RACE_DEFAULT_LOOPS; i++) {
            final ArrayCompositeDisposable acd = new ArrayCompositeDisposable(2);

            Runnable r = new Runnable() {
                @Override
                public void run() {
                    acd.setResource(0, Disposable.empty());
                }
            };

            TestHelper.race(r, r);
        }",loop_control
o,"for (Enum<HashSetSupplier> o : (Enum<HashSetSupplier>[])m.invoke(null)) {
                assertSame(o, e.invoke(null, o.name()));
            }",iterator
o,"for (Enum<NaturalComparator> o : (Enum<NaturalComparator>[])m.invoke(null)) {
                assertSame(o, e.invoke(null, o.name()));
            }",iterator
i,"for (int i = 0; i < TestHelper.RACE_DEFAULT_LOOPS; i++) {
            final Future<?> f = Single.never().toFuture();

            Runnable r = new Runnable() {
                @Override
                public void run() {
                    f.cancel(true);
                }
            };

            TestHelper.race(r, r);
        }",loop_control
i,"for (int i = 0; i < TestHelper.RACE_DEFAULT_LOOPS; i++) {
            final PublishSubject<Integer> ps = PublishSubject.create();

            final Future<?> f = ps.single(-99).toFuture();

            ps.onNext(1);

            Runnable r1 = new Runnable() {
                @Override
                public void run() {
                    f.cancel(true);
                }
            };

            Runnable r2 = new Runnable() {
                @Override
                public void run() {
                    ps.onComplete();
                }
            };

            TestHelper.race(r1, r2);
        }",loop_control
i,"for (int i = 0; i < TestHelper.RACE_DEFAULT_LOOPS; i++) {
                final PublishSubject<Integer> ps = PublishSubject.create();

                final Future<?> f = ps.single(-99).toFuture();

                final TestException ex = new TestException();

                Runnable r1 = new Runnable() {
                    @Override
                    public void run() {
                        f.cancel(true);
                    }
                };

                Runnable r2 = new Runnable() {
                    @Override
                    public void run() {
                        ps.onError(ex);
                    }
                };

                TestHelper.race(r1, r2);
            }",loop_control
i,"for (int i = 0; i < 2; i++) {
            fo.cancel(i == 0);

            assertTrue(fo.isCancelled());
            assertTrue(fo.isDisposed());
            assertTrue(fo.isDone());
        }",loop_control
i,"for (int i = 0; i < TestHelper.RACE_DEFAULT_LOOPS; i++) {
            final FutureObserver<Integer> fo = new FutureObserver<>();

            Runnable r = new Runnable() {
                @Override
                public void run() {
                    fo.cancel(false);
                }
            };

            TestHelper.race(r, r);
        }",loop_control
i,"for (int i = 0; i < TestHelper.RACE_DEFAULT_LOOPS; i++) {
                final FutureObserver<Integer> fo = new FutureObserver<>();

                final TestException ex = new TestException();

                Runnable r1 = new Runnable() {
                    @Override
                    public void run() {
                        fo.cancel(false);
                    }
                };

                Runnable r2 = new Runnable() {
                    @Override
                    public void run() {
                        fo.onError(ex);
                    }
                };

                TestHelper.race(r1, r2);
            }",loop_control
i,"for (int i = 0; i < TestHelper.RACE_DEFAULT_LOOPS; i++) {
                final FutureObserver<Integer> fo = new FutureObserver<>();

                if (i % 3 == 0) {
                    fo.onSubscribe(Disposable.empty());
                }

                if (i % 2 == 0) {
                    fo.onNext(1);
                }

                Runnable r1 = new Runnable() {
                    @Override
                    public void run() {
                        fo.cancel(false);
                    }
                };

                Runnable r2 = new Runnable() {
                    @Override
                    public void run() {
                        fo.onComplete();
                    }
                };

                TestHelper.race(r1, r2);
            }",loop_control
i,"for (int i = 0; i < TestHelper.RACE_DEFAULT_LOOPS; i++) {
            final FutureObserver<Integer> fo = new FutureObserver<>();

            Runnable r = new Runnable() {
                @Override
                public void run() {
                    fo.cancel(false);
                }
            };

            Disposable d = Disposable.empty();

            TestHelper.race(r, () -> fo.onSubscribe(d));
        }",loop_control
i,"for (int i = 0; i < TestHelper.RACE_LONG_LOOPS; i++) {

            TestObserver<Integer> to = new TestObserver<>();
            Disposable d = Disposable.empty();
            final QueueDrainObserver<Integer, Integer, Integer> qd = createUnordered(to, d);
            to.onSubscribe(Disposable.empty());

            Runnable r1 = new Runnable() {
                @Override
                public void run() {
                    qd.onNext(1);
                }
            };

            TestHelper.race(r1, r1);

            to.assertValuesOnly(1, 1);
        }",loop_control
i,"for (int i = 0; i < TestHelper.RACE_LONG_LOOPS; i++) {

            TestObserver<Integer> to = new TestObserver<>();
            Disposable d = Disposable.empty();
            final QueueDrainObserver<Integer, Integer, Integer> qd = createOrdered(to, d);
            to.onSubscribe(Disposable.empty());

            Runnable r1 = new Runnable() {
                @Override
                public void run() {
                    qd.onNext(1);
                }
            };

            TestHelper.race(r1, r1);

            to.assertValuesOnly(1, 1);
        }",loop_control
i,"for (int i = 1; i < 32; i++) {
            Flowable.range(1, 1000)
            .parallel(i)
            .flatMapStream(v -> Stream.of(v, v + 1))
            .sequential()
            .test()
            .withTag(""Parallelism: "" + i)
            .assertValueCount(2000)
            .assertNoErrors()
            .assertComplete();
        }",loop_control
i,"for (int i = 1; i < 32; i++) {
            Flowable.range(1, 1000)
            .parallel(i)
            .flatMapStream(v -> Stream.of())
            .sequential()
            .test()
            .withTag(""Parallelism: "" + i)
            .assertResult();
        }",loop_control
i,"for (int i = 1; i < 32; i++) {
            Flowable.range(1, 1000)
            .parallel(i)
            .flatMapStream(v -> v % 2 == 0 ? Stream.of(v) : Stream.of())
            .sequential()
            .test()
            .withTag(""Parallelism: "" + i)
            .assertValueCount(500)
            .assertNoErrors()
            .assertComplete();
        }",loop_control
i,"for (int i = 0; i < TestHelper.RACE_LONG_LOOPS; i++) {
            MaybeSubject<Integer> ms = MaybeSubject.create();

            TestSubscriber<Integer> ts = new TestSubscriber<>(0L);

            ms.flattenStreamAsFlowable(Stream::of)
            .subscribe(ts);

            Runnable r1 = () -> ms.onSuccess(1);
            Runnable r2 = () -> ts.request(1);

            TestHelper.race(r1, r2);

            ts.assertResult(1);
        }",loop_control
i,"for (int i = 1; i < 32; i++) {
            TestSubscriber<List<Integer>> ts = Flowable.range(1, 1000)
            .parallel(i)
            .runOn(Schedulers.computation())
            .collect(Collectors.toList())
            .test()
            .withTag(""Parallelism: "" + i)
            .awaitDone(5, TimeUnit.SECONDS)
            .assertValueCount(1)
            .assertNoErrors()
            .assertComplete();

            assertEquals(1000, ts.values().get(0).size());

            assertTrue(ts.values().get(0).containsAll(set(1000)));
        }",loop_control
i,"for (int i = 1; i < 32; i++) {
            TestSubscriber<List<Integer>> ts = Flowable.range(1, 1000)
            .hide()
            .parallel(i)
            .runOn(Schedulers.computation())
            .collect(Collectors.toList())
            .test()
            .withTag(""Parallelism: "" + i)
            .awaitDone(5, TimeUnit.SECONDS)
            .assertValueCount(1)
            .assertNoErrors()
            .assertComplete();

            assertEquals(1000, ts.values().get(0).size());

            assertTrue(ts.values().get(0).containsAll(set(1000)));
        }",loop_control
ex,"for (Throwable ex : errors) {
                assertTrue(ex.toString(), ex.getCause() instanceof TestException);
            }",iterator
i,"for (int i = 1; i < 32; i++) {
            Flowable.rangeLong(1, n)
            .parallel(i)
            .runOn(Schedulers.computation())
            .collect(Collectors.summingLong(v -> v))
            .test()
            .withTag(""Parallelism: "" + i)
            .awaitDone(5, TimeUnit.SECONDS)
            .assertResult(n * (n + 1) / 2);
        }",loop_control
i,"for (int i = 0; i < TestHelper.RACE_LONG_LOOPS; i++) {
            MaybeSubject<Integer> ms = MaybeSubject.create();

            TestObserver<Integer> to = new TestObserver<>();

            ms.flattenStreamAsObservable(Stream::of)
            .subscribe(to);

            Runnable r1 = () -> ms.onSuccess(1);
            Runnable r2 = () -> to.dispose();

            TestHelper.race(r1, r2);
        }",loop_control
i,"for (int i = 1; i <= 1000; i++) {
                assertEquals(i, list.get(i - 1).intValue());
            }",loop_control
i,"for (int i = 1; i <= 1000; i++) {
                assertEquals(i, list.get(i - 1).intValue());
            }",loop_control
n,"for (int n = 1; n < 2048; n *= 2) {
            Flowable.range(1, 1000)
            .hide()
            .flatMapStream(v -> IntStream.range(v * 1000, v * 1000 + 1000).boxed())
            .rebatchRequests(n)
            .test()
            .withTag(""rebatch: "" + n)
            .assertValueCount(1_000_000)
            .assertNoErrors()
            .assertComplete();
        }",loop_control
i,"for (int i = 0; i < TestHelper.RACE_LONG_LOOPS; i++) {
            SingleSubject<Integer> ss = SingleSubject.create();

            TestSubscriber<Integer> ts = new TestSubscriber<>(0L);

            ss.flattenStreamAsFlowable(Stream::of)
            .subscribe(ts);

            Runnable r1 = () -> ss.onSuccess(1);
            Runnable r2 = () -> ts.request(1);

            TestHelper.race(r1, r2);

            ts.assertResult(1);
        }",loop_control
ex,"for (Throwable ex : errors) {
                assertTrue(ex.toString(), ex.getCause() instanceof TestException);
            }",iterator
ex,"for (Throwable ex : errors) {
                assertTrue(ex.toString(), ex.getCause() instanceof TestException);
            }",iterator
i,"for (int i = 0; i < TestHelper.RACE_DEFAULT_LOOPS; i++) {

                AtomicInteger counter = new AtomicInteger();

                int max = 100;

                Flowable<Integer> source = Flowable.fromStream(IntStream.rangeClosed(1, max).boxed());
                if (conditional) {
                    source = source.filter(v -> true);
                }

                CountDownLatch cdl = new CountDownLatch(1);

                source
                .subscribe(new FlowableSubscriber<Integer>() {

                    @NonNull Subscription upstream;

                    @Override
                    public void onSubscribe(@NonNull Subscription s) {

                        this.upstream = s;
                        s.request(1);

                    }

                    @Override
                    public void onNext(Integer t) {
                        counter.getAndIncrement();

                        AtomicInteger sync = new AtomicInteger(2);
                        exec.submit(() -> {
                            if (sync.decrementAndGet() != 0) {
                                while (sync.get() != 0) { }
                            }
                            upstream.request(1);
                        });

                        if (sync.decrementAndGet() != 0) {
                            while (sync.get() != 0) { }
                        }
                    }

                    @Override
                    public void onError(Throwable t) {
                        t.printStackTrace();
                        cdl.countDown();
                    }

                    @Override
                    public void onComplete() {
                        counter.getAndIncrement();
                        cdl.countDown();
                    }
                });

                assertTrue(cdl.await(60, TimeUnit.SECONDS));

                assertEquals(max + 1, counter.get());
            }",loop_control
sync,"{
                        counter.getAndIncrement();

                        AtomicInteger sync = new AtomicInteger(2);
                        exec.submit(() -> {
                            if (sync.decrementAndGet() != 0) {
                                while (sync.get() != 0) { }
                            }
                            upstream.request(1);
                        });

                        if (sync.decrementAndGet() != 0) {
                            while (sync.get() != 0) { }
                        }
                    }",maybe_loop_control
i,"for (int i = 1; i <= 1000; i++) {
                assertEquals(i, list.get(i - 1).intValue());
            }",loop_control
i,"for (int i = 1; i <= 1000; i++) {
                assertEquals(i, list.get(i - 1).intValue());
            }",loop_control
i,"for (int i = 0; i < TestHelper.RACE_LONG_LOOPS; i++) {
            SingleSubject<Integer> ss = SingleSubject.create();

            TestObserver<Integer> to = new TestObserver<>();

            ss.flattenStreamAsObservable(Stream::of)
            .subscribe(to);

            Runnable r1 = () -> ss.onSuccess(1);
            Runnable r2 = () -> to.dispose();

            TestHelper.race(r1, r2);
        }",loop_control
e,"for (ParallelFailureHandling e : ParallelFailureHandling.values()) {
            Flowable.just(1)
            .parallel(1)
            .mapOptional(Optional::of, e)
            .sequential()
            .test()
            .assertResult(1);
        }",iterator
e,"for (ParallelFailureHandling e : ParallelFailureHandling.values()) {
            Flowable.<Integer>error(new TestException())
            .parallel(1)
            .mapOptional(Optional::of, e)
            .sequential()
            .test()
            .assertFailure(TestException.class);
        }",iterator
e,"for (ParallelFailureHandling e : ParallelFailureHandling.values()) {
            Flowable.just(1)
            .parallel(1)
            .mapOptional(Optional::of, e)
            .filter(Functions.alwaysTrue())
            .sequential()
            .test()
            .assertResult(1);
        }",iterator
e,"for (ParallelFailureHandling e : ParallelFailureHandling.values()) {
            Flowable.<Integer>error(new TestException())
            .parallel(1)
            .mapOptional(Optional::of, e)
            .filter(Functions.alwaysTrue())
            .sequential()
            .test()
            .assertFailure(TestException.class);
        }",iterator
i,"for (int i = 0; i < TestHelper.RACE_DEFAULT_LOOPS; i++) {
            final DeferredScalarSubscription<Integer> ds = new DeferredScalarSubscription<>(new TestSubscriber<>());

            Runnable r1 = new Runnable() {
                @Override
                public void run() {
                    ds.complete(1);
                }
            };

            Runnable r2 = new Runnable() {
                @Override
                public void run() {
                    ds.cancel();
                }
            };

            TestHelper.race(r1, r2);
        }",loop_control
i,"for (int i = 0; i < TestHelper.RACE_LONG_LOOPS; i++) {
            TestSubscriber<Integer> ts = new TestSubscriber<>(0L);

            final DeferredScalarSubscription<Integer> ds = new DeferredScalarSubscription<>(ts);
            ts.onSubscribe(ds);
            ds.complete(1);

            Runnable r1 = new Runnable() {
                @Override
                public void run() {
                    ds.request(1);
                }
            };

            Runnable r2 = new Runnable() {
                @Override
                public void run() {
                    ds.value = null;
                }
            };

            TestHelper.race(r1, r2);

            if (ts.values().size() >= 1) {
                ts.assertValue(1);
            }
        }",loop_control
i,"for (int i = 0; i < TestHelper.RACE_LONG_LOOPS; i++) {
            TestSubscriber<Integer> ts = new TestSubscriber<>(0L);

            final DeferredScalarSubscription<Integer> ds = new DeferredScalarSubscription<>(ts);
            ts.onSubscribe(ds);
            ds.complete(1);

            Runnable r1 = new Runnable() {
                @Override
                public void run() {
                    ds.request(1);
                }
            };

            Runnable r2 = new Runnable() {
                @Override
                public void run() {
                    ds.cancel();
                }
            };

            TestHelper.race(r1, r2);

            if (ts.values().size() >= 1) {
                ts.assertValue(1);
            }
        }",loop_control
i,"for (int i = 0; i < TestHelper.RACE_DEFAULT_LOOPS; i++) {
            final AtomicReference<Subscription> atomicSubscription = new AtomicReference<>();

            Runnable r = new Runnable() {
                @Override
                public void run() {
                    SubscriptionHelper.cancel(atomicSubscription);
                }
            };

            TestHelper.race(r, r);
        }",loop_control
i,"for (int i = 0; i < TestHelper.RACE_DEFAULT_LOOPS; i++) {
            final AtomicReference<Subscription> atomicSubscription = new AtomicReference<>();

            final BooleanSubscription bs1 = new BooleanSubscription();
            final BooleanSubscription bs2 = new BooleanSubscription();

            Runnable r1 = new Runnable() {
                @Override
                public void run() {
                    SubscriptionHelper.set(atomicSubscription, bs1);
                }
            };

            Runnable r2 = new Runnable() {
                @Override
                public void run() {
                    SubscriptionHelper.set(atomicSubscription, bs2);
                }
            };

            TestHelper.race(r1, r2);

            assertTrue(bs1.isCancelled() ^ bs2.isCancelled());
        }",loop_control
i,"for (int i = 0; i < TestHelper.RACE_DEFAULT_LOOPS; i++) {
            final AtomicReference<Subscription> atomicSubscription = new AtomicReference<>();

            final BooleanSubscription bs1 = new BooleanSubscription();
            final BooleanSubscription bs2 = new BooleanSubscription();

            Runnable r1 = new Runnable() {
                @Override
                public void run() {
                    SubscriptionHelper.replace(atomicSubscription, bs1);
                }
            };

            Runnable r2 = new Runnable() {
                @Override
                public void run() {
                    SubscriptionHelper.replace(atomicSubscription, bs2);
                }
            };

            TestHelper.race(r1, r2);

            assertFalse(bs1.isCancelled());
            assertFalse(bs2.isCancelled());
        }",loop_control
i,"for (int i = 0; i < TestHelper.RACE_DEFAULT_LOOPS; i++) {
            final AtomicReference<Subscription> atomicSubscription = new AtomicReference<>();
            final AtomicLong r = new AtomicLong();

            final AtomicLong q = new AtomicLong();

            final Subscription a = new Subscription() {
                @Override
                public void request(long n) {
                    q.addAndGet(n);
                }

                @Override
                public void cancel() {

                }
            };

            Runnable r1 = new Runnable() {
                @Override
                public void run() {
                    SubscriptionHelper.deferredSetOnce(atomicSubscription, r, a);
                }
            };

            Runnable r2 = new Runnable() {
                @Override
                public void run() {
                    SubscriptionHelper.deferredRequest(atomicSubscription, r, 1);
                }
            };

            TestHelper.race(r1, r2);

            assertSame(a, atomicSubscription.get());
            assertEquals(1, q.get());
            assertEquals(0, r.get());
        }",loop_control
i,"for (int i = 0; i < TestHelper.RACE_DEFAULT_LOOPS; i++) {
            final ArrayCompositeSubscription ac = new ArrayCompositeSubscription(1000);

            Runnable r = new Runnable() {
                @Override
                public void run() {
                    ac.dispose();
                }
            };

            TestHelper.race(r, r);
        }",loop_control
i,"for (int i = 0; i < TestHelper.RACE_DEFAULT_LOOPS; i++) {
            final ArrayCompositeSubscription ac = new ArrayCompositeSubscription(1);

            final BooleanSubscription s1 = new BooleanSubscription();
            final BooleanSubscription s2 = new BooleanSubscription();

            Runnable r1 = new Runnable() {
                @Override
                public void run() {
                    ac.setResource(0, s1);
                }
            };

            Runnable r2 = new Runnable() {
                @Override
                public void run() {
                    ac.replaceResource(0, s2);
                }
            };

            TestHelper.race(r1, r2);
        }",loop_control
i,"for (int i = 0; i < TestHelper.RACE_DEFAULT_LOOPS; i++) {
            CompositeDisposable set = new CompositeDisposable();
            final ScheduledRunnable run = new ScheduledRunnable(Functions.EMPTY_RUNNABLE, set);
            set.add(run);

            final FutureTask<Object> ft = new FutureTask<>(Functions.EMPTY_RUNNABLE, 0);

            Runnable r1 = new Runnable() {
                @Override
                public void run() {
                    run.setFuture(ft);
                }
            };

            Runnable r2 = new Runnable() {
                @Override
                public void run() {
                    run.dispose();
                }
            };

            TestHelper.race(r1, r2);

            assertEquals(0, set.size());
        }",loop_control
i,"for (int i = 0; i < TestHelper.RACE_DEFAULT_LOOPS; i++) {
            CompositeDisposable set = new CompositeDisposable();
            final ScheduledRunnable run = new ScheduledRunnable(Functions.EMPTY_RUNNABLE, set);
            set.add(run);

            final FutureTask<Object> ft = new FutureTask<>(Functions.EMPTY_RUNNABLE, 0);

            Runnable r1 = new Runnable() {
                @Override
                public void run() {
                    run.setFuture(ft);
                }
            };

            Runnable r2 = new Runnable() {
                @Override
                public void run() {
                    run.run();
                }
            };

            TestHelper.race(r1, r2);

            assertEquals(0, set.size());
        }",loop_control
i,"for (int i = 0; i < TestHelper.RACE_DEFAULT_LOOPS; i++) {
            CompositeDisposable set = new CompositeDisposable();
            final ScheduledRunnable run = new ScheduledRunnable(Functions.EMPTY_RUNNABLE, set);
            set.add(run);

            Runnable r1 = new Runnable() {
                @Override
                public void run() {
                    run.dispose();
                }
            };

            TestHelper.race(r1, r1);

            assertEquals(0, set.size());
        }",loop_control
i,"for (int i = 0; i < TestHelper.RACE_DEFAULT_LOOPS; i++) {
            CompositeDisposable set = new CompositeDisposable();
            final ScheduledRunnable run = new ScheduledRunnable(Functions.EMPTY_RUNNABLE, set);
            set.add(run);

            Runnable r1 = new Runnable() {
                @Override
                public void run() {
                    run.call();
                }
            };

            Runnable r2 = new Runnable() {
                @Override
                public void run() {
                    run.dispose();
                }
            };

            TestHelper.race(r1, r2);

            assertEquals(0, set.size());
        }",loop_control
i,"for (int i = 0; i < TestHelper.RACE_DEFAULT_LOOPS; i++) {
            CompositeDisposable set = new CompositeDisposable();
            final ScheduledRunnable run = new ScheduledRunnable(Functions.EMPTY_RUNNABLE, set);
            set.add(run);

            final FutureTask<Void> ft = new FutureTask<>(Functions.EMPTY_RUNNABLE, null);

            Runnable r1 = new Runnable() {
                @Override
                public void run() {
                    run.call();
                }
            };

            Runnable r2 = new Runnable() {
                @Override
                public void run() {
                    run.setFuture(ft);
                }
            };

            TestHelper.race(r1, r2);
        }",loop_control
i,"for (int i = 0; i < TestHelper.RACE_LONG_LOOPS; i++) {
            final CompositeDisposable set = new CompositeDisposable();
            final AtomicBoolean interrupted = new AtomicBoolean();
            final AtomicInteger sync = new AtomicInteger(2);
            final AtomicInteger syncb = new AtomicInteger(2);

            Runnable r0 = new Runnable() {
                @Override
                public void run() {
                    set.dispose();
                    if (sync.decrementAndGet() != 0) {
                        while (sync.get() != 0) { }
                    }
                    if (syncb.decrementAndGet() != 0) {
                        while (syncb.get() != 0) { }
                    }
                    for (int j = 0; j < 1000; j++) {
                        if (Thread.currentThread().isInterrupted()) {
                            interrupted.set(true);
                            break;
                        }
                    }
                }
            };

            final ScheduledRunnable run = new ScheduledRunnable(r0, set);
            set.add(run);

            final FutureTask<Void> ft = new FutureTask<>(run, null);

            Runnable r2 = new Runnable() {
                @Override
                public void run() {
                    if (sync.decrementAndGet() != 0) {
                        while (sync.get() != 0) { }
                    }
                    run.setFuture(ft);
                    if (syncb.decrementAndGet() != 0) {
                        while (syncb.get() != 0) { }
                    }
                }
            };

            TestHelper.race(ft, r2);

            assertFalse(""The task was interrupted"", interrupted.get());
        }",loop_control
sync,"for (int i = 0; i < TestHelper.RACE_LONG_LOOPS; i++) {
            final CompositeDisposable set = new CompositeDisposable();
            final AtomicBoolean interrupted = new AtomicBoolean();
            final AtomicInteger sync = new AtomicInteger(2);
            final AtomicInteger syncb = new AtomicInteger(2);

            Runnable r0 = new Runnable() {
                @Override
                public void run() {
                    set.dispose();
                    if (sync.decrementAndGet() != 0) {
                        while (sync.get() != 0) { }
                    }
                    if (syncb.decrementAndGet() != 0) {
                        while (syncb.get() != 0) { }
                    }
                    for (int j = 0; j < 1000; j++) {
                        if (Thread.currentThread().isInterrupted()) {
                            interrupted.set(true);
                            break;
                        }
                    }
                }
            };

            final ScheduledRunnable run = new ScheduledRunnable(r0, set);
            set.add(run);

            final FutureTask<Void> ft = new FutureTask<>(run, null);

            Runnable r2 = new Runnable() {
                @Override
                public void run() {
                    if (sync.decrementAndGet() != 0) {
                        while (sync.get() != 0) { }
                    }
                    run.setFuture(ft);
                    if (syncb.decrementAndGet() != 0) {
                        while (syncb.get() != 0) { }
                    }
                }
            };

            TestHelper.race(ft, r2);

            assertFalse(""The task was interrupted"", interrupted.get());
        }",maybe_loop_control
syncb,"for (int i = 0; i < TestHelper.RACE_LONG_LOOPS; i++) {
            final CompositeDisposable set = new CompositeDisposable();
            final AtomicBoolean interrupted = new AtomicBoolean();
            final AtomicInteger sync = new AtomicInteger(2);
            final AtomicInteger syncb = new AtomicInteger(2);

            Runnable r0 = new Runnable() {
                @Override
                public void run() {
                    set.dispose();
                    if (sync.decrementAndGet() != 0) {
                        while (sync.get() != 0) { }
                    }
                    if (syncb.decrementAndGet() != 0) {
                        while (syncb.get() != 0) { }
                    }
                    for (int j = 0; j < 1000; j++) {
                        if (Thread.currentThread().isInterrupted()) {
                            interrupted.set(true);
                            break;
                        }
                    }
                }
            };

            final ScheduledRunnable run = new ScheduledRunnable(r0, set);
            set.add(run);

            final FutureTask<Void> ft = new FutureTask<>(run, null);

            Runnable r2 = new Runnable() {
                @Override
                public void run() {
                    if (sync.decrementAndGet() != 0) {
                        while (sync.get() != 0) { }
                    }
                    run.setFuture(ft);
                    if (syncb.decrementAndGet() != 0) {
                        while (syncb.get() != 0) { }
                    }
                }
            };

            TestHelper.race(ft, r2);

            assertFalse(""The task was interrupted"", interrupted.get());
        }",maybe_loop_control
j,"for (int j = 0; j < 1000; j++) {
                        if (Thread.currentThread().isInterrupted()) {
                            interrupted.set(true);
                            break;
                        }
                    }",loop_control
i,"for (int i = 0; i < TestHelper.RACE_LONG_LOOPS; i++) {
            final ScheduledAction sa = new ScheduledAction() {

                private static final long serialVersionUID = -672980251643733156L;

                @Override
                protected Disposable callActual(Worker actualWorker,
                        CompletableObserver actionCompletable) {
                    return Disposable.empty();
                }

            };

            assertFalse(sa.isDisposed());

            Runnable r1 = new Runnable() {
                @Override
                public void run() {
                    sa.dispose();
                }
            };

            TestHelper.race(r1, r1);

            assertTrue(sa.isDisposed());
        }",loop_control
i,"for (int i = 0; i < TestHelper.RACE_DEFAULT_LOOPS; i++) {
            s.shutdown();

            Runnable r1 = new Runnable() {
                @Override
                public void run() {
                    s.start();
                }
            };

            TestHelper.race(r1, r1);
        }",loop_control
d,"{
        final Scheduler s = Schedulers.single();
        Disposable d = s.scheduleDirect(Functions.EMPTY_RUNNABLE);

        while (!d.isDisposed()) {
            Thread.sleep(1);
        }
    }",maybe_loop_control
d,"{
        final Scheduler s = Schedulers.single();

        Disposable d = s.scheduleDirect(new Runnable() {
            @Override
            public void run() {
                throw new IllegalStateException();
            }
        });

        while (!d.isDisposed()) {
            Thread.sleep(1);
        }
    }",maybe_loop_control
d,"{
        final Scheduler s = Schedulers.single();

        Disposable d = s.scheduleDirect(Functions.EMPTY_RUNNABLE, 1, TimeUnit.MILLISECONDS);

        while (!d.isDisposed()) {
            Thread.sleep(1);
        }
    }",maybe_loop_control
i,"for (int i = 0; i < TestHelper.RACE_DEFAULT_LOOPS; i++) {
            expire.add(tw);
            cd.add(tw);

            TestHelper.race(
                    () -> CachedWorkerPool.evictExpiredWorkers(expire, cd),
                    () -> expire.remove(tw)
            );
        }",loop_control
i,"for (int i = 0; i < TestHelper.RACE_DEFAULT_LOOPS; i++) {
            Runnable run = mock(Runnable.class);

            AtomicInteger sync = new AtomicInteger(2);

            w.schedule(() -> {
                Disposable d = w.schedule(run);

                Schedulers.single().scheduleDirect(() -> {
                    if (sync.decrementAndGet() != 0) {
                        while (sync.get() != 0) { }
                    }
                    d.dispose();
                });
                if (sync.decrementAndGet() != 0) {
                    while (sync.get() != 0) { }
                }
            });
        }",loop_control
sync,"for (int i = 0; i < TestHelper.RACE_DEFAULT_LOOPS; i++) {
            Runnable run = mock(Runnable.class);

            AtomicInteger sync = new AtomicInteger(2);

            w.schedule(() -> {
                Disposable d = w.schedule(run);

                Schedulers.single().scheduleDirect(() -> {
                    if (sync.decrementAndGet() != 0) {
                        while (sync.get() != 0) { }
                    }
                    d.dispose();
                });
                if (sync.decrementAndGet() != 0) {
                    while (sync.get() != 0) { }
                }
            });
        }",maybe_loop_control
i,"for (int i = 0; i < TestHelper.RACE_LONG_LOOPS; i++) {
                final InstantPeriodicTask task = new InstantPeriodicTask(new Runnable() {
                    @Override
                    public void run() {
                        throw new TestException();
                    }
                }, exec);

                final FutureTask<Void> f1 = new FutureTask<>(Functions.EMPTY_RUNNABLE, null);
                Runnable r1 = new Runnable() {
                    @Override
                    public void run() {
                        task.setFirst(f1);
                    }
                };
                Runnable r2 = new Runnable() {
                    @Override
                    public void run() {
                        task.dispose();
                    }
                };

                TestHelper.race(r1, r2);

                assertTrue(f1.isCancelled());
                assertTrue(task.isDisposed());
            }",loop_control
i,"for (int i = 0; i < TestHelper.RACE_LONG_LOOPS; i++) {
                final InstantPeriodicTask task = new InstantPeriodicTask(new Runnable() {
                    @Override
                    public void run() {
                        throw new TestException();
                    }
                }, exec);

                final FutureTask<Void> f1 = new FutureTask<>(Functions.EMPTY_RUNNABLE, null);
                Runnable r1 = new Runnable() {
                    @Override
                    public void run() {
                        task.setRest(f1);
                    }
                };
                Runnable r2 = new Runnable() {
                    @Override
                    public void run() {
                        task.dispose();
                    }
                };

                TestHelper.race(r1, r2);

                assertTrue(f1.isCancelled());
                assertTrue(task.isDisposed());
            }",loop_control
w,"{
            @Override
            public void onWorker(int i, Worker w) {
                list.add(w);
            }
        }",iterator
w,"for (Worker w : list) {
            assertEquals(ComputationScheduler.SHUTDOWN_WORKER, w);
        }",iterator
i,"for (int i = 0; i < TestHelper.RACE_DEFAULT_LOOPS; i++) {

            final CompositeDisposable composite = new CompositeDisposable();

            try {
                final CountDownLatch cdl = new CountDownLatch(max * 2);

                final Set<String> threads1 = Collections.synchronizedSet(new HashSet<>());

                final Set<String> threads2 = Collections.synchronizedSet(new HashSet<>());

                Runnable parallel1 = new Runnable() {
                    @Override
                    public void run() {
                        final List<Worker> list1 = new ArrayList<>();

                        SchedulerMultiWorkerSupport mws = (SchedulerMultiWorkerSupport)Schedulers.computation();

                        mws.createWorkers(max, new WorkerCallback() {
                            @Override
                            public void onWorker(int i, Worker w) {
                                list1.add(w);
                                composite.add(w);
                            }
                        });

                        Runnable run = new Runnable() {
                            @Override
                            public void run() {
                                threads1.add(Thread.currentThread().getName());
                                cdl.countDown();
                            }
                        };

                        for (Worker w : list1) {
                            w.schedule(run);
                        }
                    }
                };

                Runnable parallel2 = new Runnable() {
                    @Override
                    public void run() {
                        final List<Worker> list2 = new ArrayList<>();

                        SchedulerMultiWorkerSupport mws = (SchedulerMultiWorkerSupport)Schedulers.computation();

                        mws.createWorkers(max, new WorkerCallback() {
                            @Override
                            public void onWorker(int i, Worker w) {
                                list2.add(w);
                                composite.add(w);
                            }
                        });

                        Runnable run = new Runnable() {
                            @Override
                            public void run() {
                                threads2.add(Thread.currentThread().getName());
                                cdl.countDown();
                            }
                        };

                        for (Worker w : list2) {
                            w.schedule(run);
                        }
                    }
                };

                TestHelper.race(parallel1, parallel2);

                assertTrue(cdl.await(5, TimeUnit.SECONDS));

                assertEquals(threads1.toString(), max, threads1.size());
                assertEquals(threads2.toString(), max, threads2.size());
            } finally {
                composite.dispose();
            }
        }",loop_control
w,"{
                            @Override
                            public void onWorker(int i, Worker w) {
                                list1.add(w);
                                composite.add(w);
                            }
                        }",iterator
w,"for (Worker w : list1) {
                            w.schedule(run);
                        }",iterator
w,"{
                            @Override
                            public void onWorker(int i, Worker w) {
                                list2.add(w);
                                composite.add(w);
                            }
                        }",iterator
w,"for (Worker w : list2) {
                            w.schedule(run);
                        }",iterator
i,"for (int i = 0; i < TestHelper.RACE_DEFAULT_LOOPS; i++) {
            final AbstractDirectTask task = new AbstractDirectTask(Functions.EMPTY_RUNNABLE, true) {
                private static final long serialVersionUID = 208585707945686116L;
            };

            final Boolean[] interrupted = { null };
            final FutureTask<Void> ft = new FutureTask<Void>(Functions.EMPTY_RUNNABLE, null) {
                @Override
                public boolean cancel(boolean mayInterruptIfRunning) {
                    interrupted[0] = mayInterruptIfRunning;
                    return super.cancel(mayInterruptIfRunning);
                }
            };

            Runnable r1 = new Runnable() {
                @Override
                public void run() {
                    task.dispose();
                }
            };

            Runnable r2 = new Runnable() {
                @Override
                public void run() {
                    task.setFuture(ft);
                }
            };

            TestHelper.race(r1, r2);
        }",loop_control
i,"for (int i = 0; i < 50; i++) {
                            Completable.complete()
                                    .observeOn(Schedulers.io())
                                    .blockingAwait();
                        }",loop_control
i,"for (int i = 0; i < TestHelper.RACE_DEFAULT_LOOPS; i++) {

            final AtomicInteger wip = new AtomicInteger();
            final AtomicThrowable error = new AtomicThrowable();

            final TestSubscriber<Integer> ts = new TestSubscriber<>();
            ts.onSubscribe(new BooleanSubscription());

            Runnable r1 = new Runnable() {
                @Override
                public void run() {
                    HalfSerializer.onNext(ts, 1, wip, error);
                }
            };

            Runnable r2 = new Runnable() {
                @Override
                public void run() {
                    HalfSerializer.onComplete(ts, wip, error);
                }
            };

            TestHelper.race(r1, r2);

            ts.assertComplete().assertNoErrors();

            assertTrue(ts.values().size() <= 1);
        }",loop_control
i,"for (int i = 0; i < TestHelper.RACE_DEFAULT_LOOPS; i++) {

            final AtomicInteger wip = new AtomicInteger();
            final AtomicThrowable error = new AtomicThrowable();

            final TestSubscriberEx<Integer> ts = new TestSubscriberEx<>();

            ts.onSubscribe(new BooleanSubscription());

            final TestException ex = new TestException();

            Runnable r1 = new Runnable() {
                @Override
                public void run() {
                    HalfSerializer.onError(ts, ex, wip, error);
                }
            };

            Runnable r2 = new Runnable() {
                @Override
                public void run() {
                    HalfSerializer.onComplete(ts, wip, error);
                }
            };

            TestHelper.race(r1, r2);

            if (ts.completions() != 0) {
                ts.assertResult();
            } else {
                ts.assertFailure(TestException.class);
            }
        }",loop_control
i,"for (int i = 1; i > 0; i *= 2) {
            assertTrue(Pow2.isPowerOfTwo(i));
        }",loop_control
clazz,"for (Class<?> clazz : CLASSES) {
            String clazzName = clazz.getSimpleName();
            String packageName = clazz.getPackage().getName();
            File f = TestHelper.findSource(clazzName, packageName);

            List<String> lines = Files.readAllLines(f.toPath());

            for (int i = 1; i < lines.size(); i++) {
                String line = lines.get(i).trim();

                if (line.startsWith(""/**"")) {
                    boolean found = false;
                    for (int j = i + 1; j < lines.size(); j++) {

                        String line2 = lines.get(j).trim();
                        if (line2.startsWith(""public"")) {
                            if (line2.endsWith(""() {"")) {
                                found = true;
                            }
                            break;
                        }
                        if (line2.startsWith(""* @throws"")) {
                            found = true;
                            break;
                        }
                    }

                    if (!found) {
                        System.out.printf("" at %s.%s.method(%s.java:%s)%n%n"", packageName, clazzName, clazzName, i + 1);
                    }
                }
            }
        }",iterator
i,"for (int i = 1; i < lines.size(); i++) {
                String line = lines.get(i).trim();

                if (line.startsWith(""/**"")) {
                    boolean found = false;
                    for (int j = i + 1; j < lines.size(); j++) {

                        String line2 = lines.get(j).trim();
                        if (line2.startsWith(""public"")) {
                            if (line2.endsWith(""() {"")) {
                                found = true;
                            }
                            break;
                        }
                        if (line2.startsWith(""* @throws"")) {
                            found = true;
                            break;
                        }
                    }

                    if (!found) {
                        System.out.printf("" at %s.%s.method(%s.java:%s)%n%n"", packageName, clazzName, clazzName, i + 1);
                    }
                }
            }",loop_control
j,"for (int j = i + 1; j < lines.size(); j++) {

                        String line2 = lines.get(j).trim();
                        if (line2.startsWith(""public"")) {
                            if (line2.endsWith(""() {"")) {
                                found = true;
                            }
                            break;
                        }
                        if (line2.startsWith(""* @throws"")) {
                            found = true;
                            break;
                        }
                    }",loop_control
i,"for (int i = 0; i < TestHelper.RACE_DEFAULT_LOOPS; i++) {
            final TestSubscriber<Integer> ts = new TestSubscriber<>();
            final ArrayDeque<Integer> queue = new ArrayDeque<>();
            final AtomicLong state = new AtomicLong();
            final BooleanSupplier isCancelled = new BooleanSupplier() {
                @Override
                public boolean getAsBoolean() throws Exception {
                    return false;
                }
            };

            ts.onSubscribe(new BooleanSubscription());
            queue.offer(1);

            Runnable r1 = new Runnable() {
                @Override
                public void run() {
                    QueueDrainHelper.postCompleteRequest(1, ts, queue, state, isCancelled);
                }
            };

            Runnable r2 = new Runnable() {
                @Override
                public void run() {
                    QueueDrainHelper.postComplete(ts, queue, state, isCancelled);
                }
            };

            TestHelper.race(r1, r2);

            ts.assertResult(1);
        }",loop_control
clazz,"for (Class<?> clazz : CLASSES) {
            String simpleName = clazz.getSimpleName();
            System.out.println(simpleName);
            System.out.println(""----"");
            String packageName = clazz.getPackage().getName();

            File f = TestHelper.findSource(clazz.getSimpleName(), packageName);
            if (f == null) {
                System.err.println(""Unable to locate "" + clazz);
                continue;
            }

            List<String> lines = Files.readAllLines(f.toPath());

            for (int i = 0; i < lines.size(); i++) {
                Matcher m = p.matcher(lines.get(i));
                if (m.matches()) {
                    int width = Integer.parseInt(m.group(2));
                    int height = Integer.parseInt(m.group(5));
                    String url = m.group(8);

                    Integer[] imageDim = dimensions.get(url);
                    if (imageDim == null) {
                        Thread.sleep(SLEEP_PER_IMAGE_MILLIS);

                        try {
                            BufferedImage bimg = ImageIO.read(new URL(url));

                            if (bimg == null) {
                                throw new IOException(""not found"");
                            }
                            imageDim = new Integer[] { 0, 0 };
                            imageDim[0] = bimg.getWidth();
                            imageDim[1] = bimg.getHeight();

                            dimensions.put(url, imageDim);
                        } catch (IOException ex) {
                            System.err.printf(""%s => %s%n"", url, ex);
                            System.err.printf("" at %s.%s.method(%s.java:%d)%n"", packageName, simpleName, simpleName, i + 1);
                        }
                    }

                    if (imageDim != null) {
                        int expectedHeight = (int)Math.round(1.0 * width / imageDim[0] * imageDim[1]);

                        if (expectedHeight != height) {
                            System.out.printf(""    %d => %d%n"", height, expectedHeight);
                            System.out.printf("" at %s.%s.method(%s.java:%d)%n"", packageName, simpleName, simpleName, i + 1);
                        }
                    }
                    // System.out.printf(""%d: %d x %d => %s%n"", i + 1, width, height, url);
                }
            }
        }",iterator
i,"for (int i = 0; i < lines.size(); i++) {
                Matcher m = p.matcher(lines.get(i));
                if (m.matches()) {
                    int width = Integer.parseInt(m.group(2));
                    int height = Integer.parseInt(m.group(5));
                    String url = m.group(8);

                    Integer[] imageDim = dimensions.get(url);
                    if (imageDim == null) {
                        Thread.sleep(SLEEP_PER_IMAGE_MILLIS);

                        try {
                            BufferedImage bimg = ImageIO.read(new URL(url));

                            if (bimg == null) {
                                throw new IOException(""not found"");
                            }
                            imageDim = new Integer[] { 0, 0 };
                            imageDim[0] = bimg.getWidth();
                            imageDim[1] = bimg.getHeight();

                            dimensions.put(url, imageDim);
                        } catch (IOException ex) {
                            System.err.printf(""%s => %s%n"", url, ex);
                            System.err.printf("" at %s.%s.method(%s.java:%d)%n"", packageName, simpleName, simpleName, i + 1);
                        }
                    }

                    if (imageDim != null) {
                        int expectedHeight = (int)Math.round(1.0 * width / imageDim[0] * imageDim[1]);

                        if (expectedHeight != height) {
                            System.out.printf(""    %d => %d%n"", height, expectedHeight);
                            System.out.printf("" at %s.%s.method(%s.java:%d)%n"", packageName, simpleName, simpleName, i + 1);
                        }
                    }
                    // System.out.printf(""%d: %d x %d => %s%n"", i + 1, width, height, url);
                }
            }",loop_control
clazz,"for (Class<?> clazz : CLASSES) {
            Map<String, List<List<ArgumentNameAndType>>> classMethods = map.computeIfAbsent(clazz.getSimpleName(), v -> new HashMap<>());
            for (Method method : clazz.getDeclaredMethods()) {
                if (method.getDeclaringClass() == clazz && method.getParameterCount() != 0) {
                    List<List<ArgumentNameAndType>> overloads = classMethods.computeIfAbsent(method.getName(), v -> new ArrayList<>());

                    List<ArgumentNameAndType> overload = new ArrayList<>();
                    overloads.add(overload);

                    for (Parameter param : method.getParameters()) {
                        String typeName;
                        Class<?> type = param.getType();
                        if (type.isArray()) {
                            Class<?> componentType = type.getComponentType();
                            if (BASE_TYPE_SET.contains(componentType)) {
                                typeName = ""BaseType"";
                            } else {
                                typeName = type.getComponentType().getSimpleName() + ""[]"";
                            }
                        } else
                        if (BASE_TYPE_SET.contains(type)) {
                            typeName = ""BaseType"";
                        } else {
                            typeName = type.getSimpleName();
                        }
                        String name = param.getName();
                        if (name.equals(""bufferSize"") || name.equals(""prefetch"") || name.equals(""capacityHint"")) {
                            name = ""bufferSize|prefetch|capacityHint"";
                        }
                        if (name.equals(""subscriber"") || name.equals(""observer"")) {
                            name = ""subscriber|observer"";
                        }
                        if (name.contains(""onNext"")) {
                            name = name.replace(""onNext"", ""onNext|onSuccess"");
                        } else
                        if (name.contains(""onSuccess"")) {
                            name = name.replace(""onSuccess"", ""onNext|onSuccess"");
                        }
                        overload.add(new ArgumentNameAndType(typeName, name));
                    }
                }
            }
        }",iterator
method,"for (Method method : clazz.getDeclaredMethods()) {
                if (method.getDeclaringClass() == clazz && method.getParameterCount() != 0) {
                    List<List<ArgumentNameAndType>> overloads = classMethods.computeIfAbsent(method.getName(), v -> new ArrayList<>());

                    List<ArgumentNameAndType> overload = new ArrayList<>();
                    overloads.add(overload);

                    for (Parameter param : method.getParameters()) {
                        String typeName;
                        Class<?> type = param.getType();
                        if (type.isArray()) {
                            Class<?> componentType = type.getComponentType();
                            if (BASE_TYPE_SET.contains(componentType)) {
                                typeName = ""BaseType"";
                            } else {
                                typeName = type.getComponentType().getSimpleName() + ""[]"";
                            }
                        } else
                        if (BASE_TYPE_SET.contains(type)) {
                            typeName = ""BaseType"";
                        } else {
                            typeName = type.getSimpleName();
                        }
                        String name = param.getName();
                        if (name.equals(""bufferSize"") || name.equals(""prefetch"") || name.equals(""capacityHint"")) {
                            name = ""bufferSize|prefetch|capacityHint"";
                        }
                        if (name.equals(""subscriber"") || name.equals(""observer"")) {
                            name = ""subscriber|observer"";
                        }
                        if (name.contains(""onNext"")) {
                            name = name.replace(""onNext"", ""onNext|onSuccess"");
                        } else
                        if (name.contains(""onSuccess"")) {
                            name = name.replace(""onSuccess"", ""onNext|onSuccess"");
                        }
                        overload.add(new ArgumentNameAndType(typeName, name));
                    }
                }
            }",iterator
param,"for (Parameter param : method.getParameters()) {
                        String typeName;
                        Class<?> type = param.getType();
                        if (type.isArray()) {
                            Class<?> componentType = type.getComponentType();
                            if (BASE_TYPE_SET.contains(componentType)) {
                                typeName = ""BaseType"";
                            } else {
                                typeName = type.getComponentType().getSimpleName() + ""[]"";
                            }
                        } else
                        if (BASE_TYPE_SET.contains(type)) {
                            typeName = ""BaseType"";
                        } else {
                            typeName = type.getSimpleName();
                        }
                        String name = param.getName();
                        if (name.equals(""bufferSize"") || name.equals(""prefetch"") || name.equals(""capacityHint"")) {
                            name = ""bufferSize|prefetch|capacityHint"";
                        }
                        if (name.equals(""subscriber"") || name.equals(""observer"")) {
                            name = ""subscriber|observer"";
                        }
                        if (name.contains(""onNext"")) {
                            name = name.replace(""onNext"", ""onNext|onSuccess"");
                        } else
                        if (name.contains(""onSuccess"")) {
                            name = name.replace(""onSuccess"", ""onNext|onSuccess"");
                        }
                        overload.add(new ArgumentNameAndType(typeName, name));
                    }",iterator
i,"for (int i = 0; i < CLASSES.length - 1; i++) {
            String firstName = CLASSES[i].getSimpleName();
            Map<String, List<List<ArgumentNameAndType>>> firstClassMethods = map.get(firstName);
            for (int j = i + 1; j < CLASSES.length; j++) {
                String secondName = CLASSES[j].getSimpleName();
                Map<String, List<List<ArgumentNameAndType>>> secondClassMethods = map.get(secondName);

                for (Map.Entry<String, List<List<ArgumentNameAndType>>> methodOverloadsFirst : firstClassMethods.entrySet()) {

                    List<List<ArgumentNameAndType>> methodOverloadsSecond = secondClassMethods.get(methodOverloadsFirst.getKey());

                    if (methodOverloadsSecond != null) {
                        for (List<ArgumentNameAndType> overloadFirst : methodOverloadsFirst.getValue()) {
                            for (List<ArgumentNameAndType> overloadSecond : methodOverloadsSecond) {
                                if (overloadFirst.size() == overloadSecond.size()) {
                                    // Argument types match?
                                    boolean match = true;
                                    for (int k = 0; k < overloadFirst.size(); k++) {
                                        if (!overloadFirst.get(k).type.equals(overloadSecond.get(k).type)) {
                                            match = false;
                                            break;
                                        }
                                    }
                                    // Argument names match?
                                    if (match) {
                                        for (int k = 0; k < overloadFirst.size(); k++) {
                                            if (!overloadFirst.get(k).name.equals(overloadSecond.get(k).name)) {
                                                System.out.print(""Argument naming mismatch #"");
                                                System.out.println(++counter);

                                                System.out.print(""  "");
                                                System.out.print(Strings.padEnd(firstName, Math.max(firstName.length(), secondName.length()) + 1, ' '));
                                                System.out.print(methodOverloadsFirst.getKey());
                                                System.out.print(""  "");
                                                System.out.println(overloadFirst);

                                                System.out.print(""  "");
                                                System.out.print(Strings.padEnd(secondName, Math.max(firstName.length(), secondName.length()) + 1, ' '));
                                                System.out.print(methodOverloadsFirst.getKey());
                                                System.out.print(""  "");
                                                System.out.println(overloadSecond);
                                                System.out.println();
                                                break;
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
            }
        }",loop_control
j,"for (int j = i + 1; j < CLASSES.length; j++) {
                String secondName = CLASSES[j].getSimpleName();
                Map<String, List<List<ArgumentNameAndType>>> secondClassMethods = map.get(secondName);

                for (Map.Entry<String, List<List<ArgumentNameAndType>>> methodOverloadsFirst : firstClassMethods.entrySet()) {

                    List<List<ArgumentNameAndType>> methodOverloadsSecond = secondClassMethods.get(methodOverloadsFirst.getKey());

                    if (methodOverloadsSecond != null) {
                        for (List<ArgumentNameAndType> overloadFirst : methodOverloadsFirst.getValue()) {
                            for (List<ArgumentNameAndType> overloadSecond : methodOverloadsSecond) {
                                if (overloadFirst.size() == overloadSecond.size()) {
                                    // Argument types match?
                                    boolean match = true;
                                    for (int k = 0; k < overloadFirst.size(); k++) {
                                        if (!overloadFirst.get(k).type.equals(overloadSecond.get(k).type)) {
                                            match = false;
                                            break;
                                        }
                                    }
                                    // Argument names match?
                                    if (match) {
                                        for (int k = 0; k < overloadFirst.size(); k++) {
                                            if (!overloadFirst.get(k).name.equals(overloadSecond.get(k).name)) {
                                                System.out.print(""Argument naming mismatch #"");
                                                System.out.println(++counter);

                                                System.out.print(""  "");
                                                System.out.print(Strings.padEnd(firstName, Math.max(firstName.length(), secondName.length()) + 1, ' '));
                                                System.out.print(methodOverloadsFirst.getKey());
                                                System.out.print(""  "");
                                                System.out.println(overloadFirst);

                                                System.out.print(""  "");
                                                System.out.print(Strings.padEnd(secondName, Math.max(firstName.length(), secondName.length()) + 1, ' '));
                                                System.out.print(methodOverloadsFirst.getKey());
                                                System.out.print(""  "");
                                                System.out.println(overloadSecond);
                                                System.out.println();
                                                break;
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
            }",loop_control
methodOverloadsFirst,"for (Map.Entry<String, List<List<ArgumentNameAndType>>> methodOverloadsFirst : firstClassMethods.entrySet()) {

                    List<List<ArgumentNameAndType>> methodOverloadsSecond = secondClassMethods.get(methodOverloadsFirst.getKey());

                    if (methodOverloadsSecond != null) {
                        for (List<ArgumentNameAndType> overloadFirst : methodOverloadsFirst.getValue()) {
                            for (List<ArgumentNameAndType> overloadSecond : methodOverloadsSecond) {
                                if (overloadFirst.size() == overloadSecond.size()) {
                                    // Argument types match?
                                    boolean match = true;
                                    for (int k = 0; k < overloadFirst.size(); k++) {
                                        if (!overloadFirst.get(k).type.equals(overloadSecond.get(k).type)) {
                                            match = false;
                                            break;
                                        }
                                    }
                                    // Argument names match?
                                    if (match) {
                                        for (int k = 0; k < overloadFirst.size(); k++) {
                                            if (!overloadFirst.get(k).name.equals(overloadSecond.get(k).name)) {
                                                System.out.print(""Argument naming mismatch #"");
                                                System.out.println(++counter);

                                                System.out.print(""  "");
                                                System.out.print(Strings.padEnd(firstName, Math.max(firstName.length(), secondName.length()) + 1, ' '));
                                                System.out.print(methodOverloadsFirst.getKey());
                                                System.out.print(""  "");
                                                System.out.println(overloadFirst);

                                                System.out.print(""  "");
                                                System.out.print(Strings.padEnd(secondName, Math.max(firstName.length(), secondName.length()) + 1, ' '));
                                                System.out.print(methodOverloadsFirst.getKey());
                                                System.out.print(""  "");
                                                System.out.println(overloadSecond);
                                                System.out.println();
                                                break;
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    }
                }",iterator
overloadFirst,"for (List<ArgumentNameAndType> overloadFirst : methodOverloadsFirst.getValue()) {
                            for (List<ArgumentNameAndType> overloadSecond : methodOverloadsSecond) {
                                if (overloadFirst.size() == overloadSecond.size()) {
                                    // Argument types match?
                                    boolean match = true;
                                    for (int k = 0; k < overloadFirst.size(); k++) {
                                        if (!overloadFirst.get(k).type.equals(overloadSecond.get(k).type)) {
                                            match = false;
                                            break;
                                        }
                                    }
                                    // Argument names match?
                                    if (match) {
                                        for (int k = 0; k < overloadFirst.size(); k++) {
                                            if (!overloadFirst.get(k).name.equals(overloadSecond.get(k).name)) {
                                                System.out.print(""Argument naming mismatch #"");
                                                System.out.println(++counter);

                                                System.out.print(""  "");
                                                System.out.print(Strings.padEnd(firstName, Math.max(firstName.length(), secondName.length()) + 1, ' '));
                                                System.out.print(methodOverloadsFirst.getKey());
                                                System.out.print(""  "");
                                                System.out.println(overloadFirst);

                                                System.out.print(""  "");
                                                System.out.print(Strings.padEnd(secondName, Math.max(firstName.length(), secondName.length()) + 1, ' '));
                                                System.out.print(methodOverloadsFirst.getKey());
                                                System.out.print(""  "");
                                                System.out.println(overloadSecond);
                                                System.out.println();
                                                break;
                                            }
                                        }
                                    }
                                }
                            }
                        }",iterator
overloadSecond,"for (List<ArgumentNameAndType> overloadSecond : methodOverloadsSecond) {
                                if (overloadFirst.size() == overloadSecond.size()) {
                                    // Argument types match?
                                    boolean match = true;
                                    for (int k = 0; k < overloadFirst.size(); k++) {
                                        if (!overloadFirst.get(k).type.equals(overloadSecond.get(k).type)) {
                                            match = false;
                                            break;
                                        }
                                    }
                                    // Argument names match?
                                    if (match) {
                                        for (int k = 0; k < overloadFirst.size(); k++) {
                                            if (!overloadFirst.get(k).name.equals(overloadSecond.get(k).name)) {
                                                System.out.print(""Argument naming mismatch #"");
                                                System.out.println(++counter);

                                                System.out.print(""  "");
                                                System.out.print(Strings.padEnd(firstName, Math.max(firstName.length(), secondName.length()) + 1, ' '));
                                                System.out.print(methodOverloadsFirst.getKey());
                                                System.out.print(""  "");
                                                System.out.println(overloadFirst);

                                                System.out.print(""  "");
                                                System.out.print(Strings.padEnd(secondName, Math.max(firstName.length(), secondName.length()) + 1, ' '));
                                                System.out.print(methodOverloadsFirst.getKey());
                                                System.out.print(""  "");
                                                System.out.println(overloadSecond);
                                                System.out.println();
                                                break;
                                            }
                                        }
                                    }
                                }
                            }",iterator
k,"for (int k = 0; k < overloadFirst.size(); k++) {
                                        if (!overloadFirst.get(k).type.equals(overloadSecond.get(k).type)) {
                                            match = false;
                                            break;
                                        }
                                    }",loop_control
k,"for (int k = 0; k < overloadFirst.size(); k++) {
                                            if (!overloadFirst.get(k).name.equals(overloadSecond.get(k).name)) {
                                                System.out.print(""Argument naming mismatch #"");
                                                System.out.println(++counter);

                                                System.out.print(""  "");
                                                System.out.print(Strings.padEnd(firstName, Math.max(firstName.length(), secondName.length()) + 1, ' '));
                                                System.out.print(methodOverloadsFirst.getKey());
                                                System.out.print(""  "");
                                                System.out.println(overloadFirst);

                                                System.out.print(""  "");
                                                System.out.print(Strings.padEnd(secondName, Math.max(firstName.length(), secondName.length()) + 1, ' '));
                                                System.out.print(methodOverloadsFirst.getKey());
                                                System.out.print(""  "");
                                                System.out.println(overloadSecond);
                                                System.out.println();
                                                break;
                                            }
                                        }",loop_control
overloadFirst,"for (List<ArgumentNameAndType> overloadFirst : methodOverloadsFirst.getValue()) {
                            for (List<ArgumentNameAndType> overloadSecond : methodOverloadsSecond) {
                                if (overloadFirst.size() == overloadSecond.size()) {
                                    // Argument types match?
                                    boolean match = true;
                                    for (int k = 0; k < overloadFirst.size(); k++) {
                                        if (!overloadFirst.get(k).type.equals(overloadSecond.get(k).type)) {
                                            match = false;
                                            break;
                                        }
                                    }
                                    // Argument names match?
                                    if (match) {
                                        for (int k = 0; k < overloadFirst.size(); k++) {
                                            if (!overloadFirst.get(k).name.equals(overloadSecond.get(k).name)) {
                                                System.out.print(""Argument naming mismatch #"");
                                                System.out.println(++counter);

                                                System.out.print(""  "");
                                                System.out.print(Strings.padEnd(firstName, Math.max(firstName.length(), secondName.length()) + 1, ' '));
                                                System.out.print(methodOverloadsFirst.getKey());
                                                System.out.print(""  "");
                                                System.out.println(overloadFirst);

                                                System.out.print(""  "");
                                                System.out.print(Strings.padEnd(secondName, Math.max(firstName.length(), secondName.length()) + 1, ' '));
                                                System.out.print(methodOverloadsFirst.getKey());
                                                System.out.print(""  "");
                                                System.out.println(overloadSecond);
                                                System.out.println();
                                                break;
                                            }
                                        }
                                    }
                                }
                            }
                        }",break_loop_control
line,"{
                String line;

                while ((line = in.readLine()) != null) {
                    result.add(line);
                }
            }",maybe_loop_control
f,"for (File f : observables) {
            if (!f.getName().endsWith("".java"")) {
                continue;
            }
            Class<?> clazz = Class.forName(basepackage + ""observable."" + f.getName().replace("".java"", """"));

            String cn = f.getName().replace("".java"", """").replace(""Observable"", ""Flowable"");

            File f2 = new File(basepath + ""/flowable/"" + cn + "".java"");

            if (!f2.exists()) {
                continue;
            }

            Class<?> clazz2 = Class.forName(basepackage + ""flowable."" + cn);

            Set<String> methods2 = new HashSet<>();

            for (Method m : clazz2.getMethods()) {
                methods2.add(m.getName());
            }

            for (Method m : clazz.getMethods()) {
                if (!methods2.contains(m.getName()) && !methods2.contains(m.getName().replace(""Observable"", ""Flowable""))) {
                    count++;
                    System.out.println();
                    System.out.print(""java.lang.RuntimeException: missing > "");
                    System.out.println(m.getName());
                    System.out.print("" at "");
                    System.out.print(clazz.getName());
                    System.out.print("" ("");
                    System.out.print(clazz.getSimpleName());
                    System.out.print("".java:"");

                    List<String> lines = readAllLines(f);

                    int j = 1;
                    for (int i = 1; i <= lines.size(); i++) {
                        if (lines.get(i - 1).contains(""public void "" + m.getName() + ""("")) {
                            j = i;
                        }
                    }
                    System.out.print(j);
                    System.out.println("")"");

                    System.out.print("" at "");
                    System.out.print(clazz2.getName());
                    System.out.print("" ("");
                    System.out.print(clazz2.getSimpleName());

                    lines = readAllLines(f2);

                    System.out.print("".java:"");
                    System.out.print(lines.size() - 1);
                    System.out.println("")"");
                }
            }
        }",iterator
m,"for (Method m : clazz2.getMethods()) {
                methods2.add(m.getName());
            }",iterator
m,"for (Method m : clazz.getMethods()) {
                if (!methods2.contains(m.getName()) && !methods2.contains(m.getName().replace(""Observable"", ""Flowable""))) {
                    count++;
                    System.out.println();
                    System.out.print(""java.lang.RuntimeException: missing > "");
                    System.out.println(m.getName());
                    System.out.print("" at "");
                    System.out.print(clazz.getName());
                    System.out.print("" ("");
                    System.out.print(clazz.getSimpleName());
                    System.out.print("".java:"");

                    List<String> lines = readAllLines(f);

                    int j = 1;
                    for (int i = 1; i <= lines.size(); i++) {
                        if (lines.get(i - 1).contains(""public void "" + m.getName() + ""("")) {
                            j = i;
                        }
                    }
                    System.out.print(j);
                    System.out.println("")"");

                    System.out.print("" at "");
                    System.out.print(clazz2.getName());
                    System.out.print("" ("");
                    System.out.print(clazz2.getSimpleName());

                    lines = readAllLines(f2);

                    System.out.print("".java:"");
                    System.out.print(lines.size() - 1);
                    System.out.println("")"");
                }
            }",iterator
i,"for (int i = 1; i <= lines.size(); i++) {
                        if (lines.get(i - 1).contains(""public void "" + m.getName() + ""("")) {
                            j = i;
                        }
                    }",loop_control
i,"for (int i = 1; i < 8; i++) {
            assertEquals(i, it.next().intValue());
        }",loop_control
i,"for (int i = 1; i < 8; i++) {
            assertEquals(i, list.get(i - 1).intValue());
        }",loop_control
i,"for (int i = 1; i < 8; i++) {
            assertEquals(i, list.set(i - 1, i).intValue());
        }",loop_control
i,"for (int i = 7; i > 0; i--) {
            assertEquals(i, lit.previous().intValue());
        }",loop_control
it,"{
        List<Integer> list = new VolatileSizeArrayList<>();

        assertTrue(list.isEmpty());
        assertEquals(0, list.size());
        assertFalse(list.contains(1));
        assertFalse(list.remove((Integer)1));

        list = new VolatileSizeArrayList<>(16);
        assertTrue(list.add(1));
        assertTrue(list.addAll(Arrays.asList(3, 4, 7)));
        list.add(1, 2);
        assertTrue(list.addAll(4, Arrays.asList(5, 6)));

        assertTrue(list.contains(2));
        assertFalse(list.remove((Integer)10));

        assertEquals(Arrays.asList(1, 2, 3, 4, 5, 6, 7), list);
        assertFalse(list.isEmpty());
        assertEquals(7, list.size());

        Iterator<Integer> it = list.iterator();
        for (int i = 1; i < 8; i++) {
            assertEquals(i, it.next().intValue());
        }

        assertArrayEquals(new Object[] { 1, 2, 3, 4, 5, 6, 7 }, list.toArray());
        assertArrayEquals(new Integer[] { 1, 2, 3, 4, 5, 6, 7 }, list.toArray(new Integer[7]));

        assertTrue(list.containsAll(Arrays.asList(2, 4, 6)));
        assertFalse(list.containsAll(Arrays.asList(2, 4, 6, 10)));

        assertFalse(list.removeAll(Arrays.asList(10, 11, 12)));

        assertFalse(list.retainAll(Arrays.asList(1, 2, 3, 4, 5, 6, 7)));

        assertEquals(7, list.size());

        for (int i = 1; i < 8; i++) {
            assertEquals(i, list.get(i - 1).intValue());
        }

        for (int i = 1; i < 8; i++) {
            assertEquals(i, list.set(i - 1, i).intValue());
        }

        assertEquals(2, list.indexOf(3));

        assertEquals(5, list.lastIndexOf(6));

        ListIterator<Integer> lit = list.listIterator(7);
        for (int i = 7; i > 0; i--) {
            assertEquals(i, lit.previous().intValue());
        }

        assertEquals(Arrays.asList(3, 4, 5), list.subList(2, 5));

        VolatileSizeArrayList<Integer> list2 = new VolatileSizeArrayList<>();
        list2.addAll(Arrays.asList(1, 2, 3, 4, 5, 6));

        assertNotEquals(list2, list);
        assertNotEquals(list, list2);

        list2.add(7);
        assertEquals(list2, list);
        assertEquals(list, list2);

        List<Integer> list3 = new ArrayList<>();
        list3.addAll(Arrays.asList(1, 2, 3, 4, 5, 6));

        assertNotEquals(list3, list);
        assertNotEquals(list, list3);

        list3.add(7);
        assertEquals(list3, list);
        assertEquals(list, list3);

        assertEquals(list.hashCode(), list3.hashCode());
        assertEquals(list.toString(), list3.toString());

        list.remove(0);
        assertEquals(6, list.size());

        list.clear();
        assertEquals(0, list.size());
        assertTrue(list.isEmpty());
    }",iterator
lit,"{
        List<Integer> list = new VolatileSizeArrayList<>();

        assertTrue(list.isEmpty());
        assertEquals(0, list.size());
        assertFalse(list.contains(1));
        assertFalse(list.remove((Integer)1));

        list = new VolatileSizeArrayList<>(16);
        assertTrue(list.add(1));
        assertTrue(list.addAll(Arrays.asList(3, 4, 7)));
        list.add(1, 2);
        assertTrue(list.addAll(4, Arrays.asList(5, 6)));

        assertTrue(list.contains(2));
        assertFalse(list.remove((Integer)10));

        assertEquals(Arrays.asList(1, 2, 3, 4, 5, 6, 7), list);
        assertFalse(list.isEmpty());
        assertEquals(7, list.size());

        Iterator<Integer> it = list.iterator();
        for (int i = 1; i < 8; i++) {
            assertEquals(i, it.next().intValue());
        }

        assertArrayEquals(new Object[] { 1, 2, 3, 4, 5, 6, 7 }, list.toArray());
        assertArrayEquals(new Integer[] { 1, 2, 3, 4, 5, 6, 7 }, list.toArray(new Integer[7]));

        assertTrue(list.containsAll(Arrays.asList(2, 4, 6)));
        assertFalse(list.containsAll(Arrays.asList(2, 4, 6, 10)));

        assertFalse(list.removeAll(Arrays.asList(10, 11, 12)));

        assertFalse(list.retainAll(Arrays.asList(1, 2, 3, 4, 5, 6, 7)));

        assertEquals(7, list.size());

        for (int i = 1; i < 8; i++) {
            assertEquals(i, list.get(i - 1).intValue());
        }

        for (int i = 1; i < 8; i++) {
            assertEquals(i, list.set(i - 1, i).intValue());
        }

        assertEquals(2, list.indexOf(3));

        assertEquals(5, list.lastIndexOf(6));

        ListIterator<Integer> lit = list.listIterator(7);
        for (int i = 7; i > 0; i--) {
            assertEquals(i, lit.previous().intValue());
        }

        assertEquals(Arrays.asList(3, 4, 5), list.subList(2, 5));

        VolatileSizeArrayList<Integer> list2 = new VolatileSizeArrayList<>();
        list2.addAll(Arrays.asList(1, 2, 3, 4, 5, 6));

        assertNotEquals(list2, list);
        assertNotEquals(list, list2);

        list2.add(7);
        assertEquals(list2, list);
        assertEquals(list, list2);

        List<Integer> list3 = new ArrayList<>();
        list3.addAll(Arrays.asList(1, 2, 3, 4, 5, 6));

        assertNotEquals(list3, list);
        assertNotEquals(list, list3);

        list3.add(7);
        assertEquals(list3, list);
        assertEquals(list, list3);

        assertEquals(list.hashCode(), list3.hashCode());
        assertEquals(list.toString(), list3.toString());

        list.remove(0);
        assertEquals(6, list.size());

        list.clear();
        assertEquals(0, list.size());
        assertTrue(list.isEmpty());
    }",iterator
i,"for (int i = 0; i < TestHelper.RACE_DEFAULT_LOOPS; i++) {

            final AtomicInteger wip = new AtomicInteger();
            final AtomicThrowable error = new AtomicThrowable();

            final TestObserver<Integer> to = new TestObserver<>();
            to.onSubscribe(Disposable.empty());

            Runnable r1 = new Runnable() {
                @Override
                public void run() {
                    HalfSerializer.onNext(to, 1, wip, error);
                }
            };

            Runnable r2 = new Runnable() {
                @Override
                public void run() {
                    HalfSerializer.onComplete(to, wip, error);
                }
            };

            TestHelper.race(r1, r2);

            to.assertComplete().assertNoErrors();

            assertTrue(to.values().size() <= 1);
        }",loop_control
i,"for (int i = 0; i < TestHelper.RACE_DEFAULT_LOOPS; i++) {

            final AtomicInteger wip = new AtomicInteger();
            final AtomicThrowable error = new AtomicThrowable();

            final TestObserverEx<Integer> to = new TestObserverEx<>();

            to.onSubscribe(Disposable.empty());

            final TestException ex = new TestException();

            Runnable r1 = new Runnable() {
                @Override
                public void run() {
                    HalfSerializer.onError(to, ex, wip, error);
                }
            };

            Runnable r2 = new Runnable() {
                @Override
                public void run() {
                    HalfSerializer.onComplete(to, wip, error);
                }
            };

            TestHelper.race(r1, r2);

            if (to.completions() != 0) {
                to.assertResult();
            } else {
                to.assertFailure(TestException.class);
            }
        }",loop_control
i,"for (int i = 0; i < TestHelper.RACE_DEFAULT_LOOPS; i++) {

            final AtomicReference<Throwable> error = new AtomicReference<>();

            final TestException ex = new TestException();

            Runnable r = new Runnable() {
                @Override
                public void run() {
                    assertTrue(ExceptionHelper.addThrowable(error, ex));
                }
            };

            TestHelper.race(r, r);
        }",loop_control
argCount,"for (int argCount = 1; argCount < 10; argCount++) {
            for (int argNull = 1; argNull <= argCount; argNull++) {
                Class<?>[] params = new Class[argCount];
                Arrays.fill(params, Object.class);

                Object[] values = new Object[argCount];
                Arrays.fill(values, 1);
                values[argNull - 1] = null;

                Method m = clazz.getMethod(""just"", params);

                try {
                    m.invoke(null, values);
                    Assert.fail(""No exception for argCount "" + argCount + "" / argNull "" + argNull);
                } catch (InvocationTargetException ex) {
                    if (!(ex.getCause() instanceof NullPointerException)) {
                        Assert.fail(""Unexpected exception for argCount "" + argCount + "" / argNull "" + argNull + "": "" + ex);
                    }
                }
            }
        }",loop_control
argNull,"for (int argNull = 1; argNull <= argCount; argNull++) {
                Class<?>[] params = new Class[argCount];
                Arrays.fill(params, Object.class);

                Object[] values = new Object[argCount];
                Arrays.fill(values, 1);
                values[argNull - 1] = null;

                Method m = clazz.getMethod(""just"", params);

                try {
                    m.invoke(null, values);
                    Assert.fail(""No exception for argCount "" + argCount + "" / argNull "" + argNull);
                } catch (InvocationTargetException ex) {
                    if (!(ex.getCause() instanceof NullPointerException)) {
                        Assert.fail(""Unexpected exception for argCount "" + argCount + "" / argNull "" + argNull + "": "" + ex);
                    }
                }
            }",loop_control
old,"for (@SuppressWarnings(""unused"") Movie old : oldList) {
                    delta.add(new Movie());
                }",iterator
i,"for (int i = 0; i < expectedCount; i++) {
            Observable
                    .just(Boolean.TRUE, Boolean.FALSE)
                    .takeWhile(new Predicate<Boolean>() {
                        @Override
                        public boolean test(Boolean v) {
                            return v;
                        }
                    })
                    .toList()
                    .doOnSuccess(new Consumer<List<Boolean>>() {
                        @Override
                        public void accept(List<Boolean> booleans) {
                            count.incrementAndGet();
                        }
                    })
                    .subscribe();
        }",loop_control
i,"for (Object i : o) {
                    sum += (Integer) i;
                }",iterator
i,"for (Object i : o) {
                    sum *= (Integer) i;
                }",iterator
root,"{
        Throwable root = ex.getCause();
        if (root == null) {
            return null;
        } else {
            while (true) {
                if (root.getCause() == null) {
                    return root;
                } else {
                    root = root.getCause();
                }
            }
        }
    }",break_loop_control
i,"for (int i = 0; i < n; i++) {
            TestMultiThreadedObservable onSubscribe = new TestMultiThreadedObservable(""one"", ""two"", ""three"", null,
                    ""four"", ""five"", ""six"", ""seven"", ""eight"", ""nine"");
            Flowable<String> w = Flowable.unsafeCreate(onSubscribe);

            BusySubscriber busySubscriber = new BusySubscriber();
            Subscriber<String> aw = serializedSubscriber(busySubscriber);

            w.subscribe(aw);
            onSubscribe.waitToFinish();

            System.out.println(""OnSubscribe maxConcurrentThreads: "" + onSubscribe.maxConcurrentThreads.get() + ""  Subscriber maxConcurrentThreads: "" + busySubscriber.maxConcurrentThreads.get());

            // we can have concurrency ...
            assertTrue(onSubscribe.maxConcurrentThreads.get() > 1);
            // ... but the onNext execution should be single threaded
            assertEquals(1, busySubscriber.maxConcurrentThreads.get());

            // this should not be the full number of items since the error should stop it before it completes all 9
            System.out.println(""onNext count: "" + busySubscriber.onNextCount.get());
            assertFalse(busySubscriber.onComplete);
            assertTrue(busySubscriber.onError);
            assertTrue(busySubscriber.onNextCount.get() < 9);
            // no onComplete because onError was invoked
            // non-deterministic because unsubscribe happens after 'waitToFinish' releases
            // so commenting out for now as this is not a critical thing to test here
            // verify(s, times(1)).unsubscribe();
        }",loop_control
i,"for (int i = 0; i < errors.size(); i++) {
                TestHelper.assertUndeliverable(errors, i, RuntimeException.class);
            }",loop_control
i,"for (int i = 0; i < n; i++) {
                final CountDownLatch firstOnNext = new CountDownLatch(1);
                final CountDownLatch onNextCount = new CountDownLatch(2);
                final CountDownLatch latch = new CountDownLatch(1);
                final CountDownLatch running = new CountDownLatch(2);

                TestSubscriberEx<String> ts = new TestSubscriberEx<>(new DefaultSubscriber<String>() {

                    @Override
                    public void onComplete() {

                    }

                    @Override
                    public void onError(Throwable e) {

                    }

                    @Override
                    public void onNext(String t) {
                        firstOnNext.countDown();
                        // force it to take time when delivering so the second one is enqueued
                        try {
                            latch.await();
                        } catch (InterruptedException e) {
                        }
                    }

                });
                Subscriber<String> subscriber = serializedSubscriber(ts);

                Future<?> f1 = tp1.submit(new OnNextThread(subscriber, 1, onNextCount, running));
                Future<?> f2 = tp2.submit(new OnNextThread(subscriber, 1, onNextCount, running));

                running.await(); // let one of the OnNextThread actually run before proceeding

                firstOnNext.await();

                Thread t1 = ts.lastThread();
                System.out.println(""first onNext on thread: "" + t1);

                latch.countDown();

                waitOnThreads(f1, f2);
                // not completed yet

                assertEquals(2, ts.values().size());

                Thread t2 = ts.lastThread();
                System.out.println(""second onNext on thread: "" + t2);

                assertSame(t1, t2);

                System.out.println(ts.values());
                subscriber.onComplete();
                System.out.println(ts.values());
            }",loop_control
f,"for (Future<?> f : futures) {
            try {
                f.get(20, TimeUnit.SECONDS);
            } catch (Throwable e) {
                System.err.println(""Failed while waiting on future."");
                e.printStackTrace();
            }
        }",iterator
bs,"{
                BooleanSubscription bs = new BooleanSubscription();
                s.onSubscribe(bs);
                while (!bs.isCancelled()) {
                    s.onNext(""onNext"");
                    produced.incrementAndGet();
                }
            }",maybe_loop_control
s,"for (final String s : values) {
                            final int fj = ++j;
                            threadPool.execute(new Runnable() {

                                @Override
                                public void run() {
                                    threadsRunning.incrementAndGet();
                                    try {
                                        // perform onNext call
                                        System.out.println(""TestMultiThreadedObservable onNext: "" + s + "" on thread "" + Thread.currentThread().getName());
                                        if (s == null) {
                                            // force an error
                                            throw npe;
                                        } else {
                                             // allow the exception to queue up
                                            int sleep = (fj % 3) * 10;
                                            if (sleep != 0) {
                                                Thread.sleep(sleep);
                                            }
                                        }
                                        subscriber.onNext(s);
                                        // capture 'maxThreads'
                                        int concurrentThreads = threadsRunning.get();
                                        int maxThreads = maxConcurrentThreads.get();
                                        if (concurrentThreads > maxThreads) {
                                            maxConcurrentThreads.compareAndSet(maxThreads, concurrentThreads);
                                        }
                                    } catch (Throwable e) {
                                        subscriber.onError(e);
                                    } finally {
                                        threadsRunning.decrementAndGet();
                                    }
                                }
                            });
                        }",iterator
i,"for (int i = 0; i < TestHelper.RACE_DEFAULT_LOOPS; i++) {
            TestSubscriber<Integer> ts = new TestSubscriber<>();

            final SerializedSubscriber<Integer> so = new SerializedSubscriber<>(ts);

            BooleanSubscription bs = new BooleanSubscription();

            so.onSubscribe(bs);

            Runnable r = new Runnable() {
                @Override
                public void run() {
                    so.onComplete();
                }
            };

            TestHelper.race(r, r);

            ts.awaitDone(5, TimeUnit.SECONDS)
            .assertResult();
        }",loop_control
i,"for (int i = 0; i < TestHelper.RACE_DEFAULT_LOOPS; i++) {
            TestSubscriber<Integer> ts = new TestSubscriber<>();

            final SerializedSubscriber<Integer> so = new SerializedSubscriber<>(ts);

            BooleanSubscription bs = new BooleanSubscription();

            so.onSubscribe(bs);

            Runnable r1 = new Runnable() {
                @Override
                public void run() {
                    so.onComplete();
                }
            };

            Runnable r2 = new Runnable() {
                @Override
                public void run() {
                    so.onNext(1);
                }
            };

            TestHelper.race(r1, r2);

            ts.awaitDone(5, TimeUnit.SECONDS)
            .assertNoErrors()
            .assertComplete();

            assertTrue(ts.values().size() <= 1);
        }",loop_control
i,"for (int i = 0; i < TestHelper.RACE_DEFAULT_LOOPS; i++) {
            TestSubscriber<Integer> ts = new TestSubscriber<>();

            final SerializedSubscriber<Integer> so = new SerializedSubscriber<>(ts);

            BooleanSubscription bs = new BooleanSubscription();

            so.onSubscribe(bs);

            final Throwable ex = new TestException();

            Runnable r1 = new Runnable() {
                @Override
                public void run() {
                    so.onError(ex);
                }
            };

            Runnable r2 = new Runnable() {
                @Override
                public void run() {
                    so.onNext(1);
                }
            };

            TestHelper.race(r1, r2);

            ts.awaitDone(5, TimeUnit.SECONDS)
            .assertError(ex)
            .assertNotComplete();

            assertTrue(ts.values().size() <= 1);
        }",loop_control
i,"for (int i = 0; i < TestHelper.RACE_DEFAULT_LOOPS; i++) {
            TestSubscriber<Integer> ts = new TestSubscriber<>();

            final SerializedSubscriber<Integer> so = new SerializedSubscriber<>(ts, true);

            BooleanSubscription bs = new BooleanSubscription();

            so.onSubscribe(bs);

            final Throwable ex = new TestException();

            Runnable r1 = new Runnable() {
                @Override
                public void run() {
                    so.onError(ex);
                }
            };

            Runnable r2 = new Runnable() {
                @Override
                public void run() {
                    so.onNext(1);
                }
            };

            TestHelper.race(r1, r2);

            ts.awaitDone(5, TimeUnit.SECONDS)
            .assertError(ex)
            .assertNotComplete();

            assertTrue(ts.values().size() <= 1);
        }",loop_control
i,"for (int i = 0; i < TestHelper.RACE_DEFAULT_LOOPS; i++) {
            List<Throwable> errors = TestHelper.trackPluginErrors();
            try {
                TestSubscriberEx<Integer> ts = new TestSubscriberEx<>();

                final SerializedSubscriber<Integer> so = new SerializedSubscriber<>(ts);

                BooleanSubscription bs = new BooleanSubscription();

                so.onSubscribe(bs);

                final Throwable ex = new TestException();

                Runnable r1 = new Runnable() {
                    @Override
                    public void run() {
                        so.onError(ex);
                    }
                };

                Runnable r2 = new Runnable() {
                    @Override
                    public void run() {
                        so.onComplete();
                    }
                };

                TestHelper.race(r1, r2);

                ts.awaitDone(5, TimeUnit.SECONDS);

                if (ts.completions() != 0) {
                    ts.assertResult();
                    TestHelper.assertUndeliverable(errors, 0, TestException.class);
                } else {
                    ts.assertFailure(TestException.class).assertError(ex);
                    assertTrue("""" + errors, errors.isEmpty());
                }
            } finally {
                RxJavaPlugins.reset();
            }
        }",loop_control
i,"for (int i = 1; i < 3; i++) {
                Flowable.just(i)
                .test()
                .withTag(""testing with item="" + i)
                .assertResult(1)
                ;
            }",loop_control
i,"for (int i = 0; i < 128; i++) {
            source.test().assertResult(i);
        }",loop_control
i,"for (int i = 0; i < TestHelper.RACE_DEFAULT_LOOPS; i++) {
            final PublishProcessor<Integer> pp1 = PublishProcessor.create();
            final PublishProcessor<Integer> pp2 = PublishProcessor.create();

            TestSubscriberEx<Integer> ts = new TestSubscriberEx<Integer>().setInitialFusionMode(QueueFuseable.ANY);

            Maybe.mergeArray(pp1.singleElement(), pp2.singleElement()).subscribe(ts);

            ts.assertSubscribed()
            .assertFuseable()
            .assertFusionMode(QueueFuseable.ASYNC)
            ;

            TestHelper.race(new Runnable() {
                @Override
                public void run() {
                    pp1.onNext(1);
                    pp1.onComplete();
                }
            }, new Runnable() {
                @Override
                public void run() {
                    pp2.onNext(1);
                    pp2.onComplete();
                }
            });

            ts
            .awaitDone(5, TimeUnit.SECONDS)
            .assertResult(1, 1);
        }",loop_control
i,"for (Object i : o) {
                    sum += (Integer) i;
                }",iterator
m,"for (Method m : RxJavaPlugins.class.getMethods()) {
                if (m.getName().startsWith(""set"")) {

                    Method getter;

                    Class<?> paramType = m.getParameterTypes()[0];

                    if (paramType == Boolean.TYPE) {
                        getter = RxJavaPlugins.class.getMethod(""is"" + m.getName().substring(3));
                    } else {
                        getter = RxJavaPlugins.class.getMethod(""get"" + m.getName().substring(3));
                    }

                    Object before = getter.invoke(null);

                    try {
                        if (paramType.isAssignableFrom(Boolean.TYPE)) {
                            m.invoke(null, true);
                        } else
                        if (paramType.isAssignableFrom(Supplier.class)) {
                            m.invoke(null, f0);
                        } else
                        if (paramType.isAssignableFrom(Function.class)) {
                            m.invoke(null, f1);
                        } else
                        if (paramType.isAssignableFrom(Consumer.class)) {
                            m.invoke(null, a1);
                        } else
                        if (paramType.isAssignableFrom(BooleanSupplier.class)) {
                            m.invoke(null, bs);
                        } else {
                            m.invoke(null, f2);
                        }
                        fail(""Should have thrown InvocationTargetException(IllegalStateException)"");
                    } catch (InvocationTargetException ex) {
                        if (ex.getCause() instanceof IllegalStateException) {
                            assertEquals(""Plugins can't be changed anymore"", ex.getCause().getMessage());
                        } else {
                            fail(""Should have thrown InvocationTargetException(IllegalStateException)"");
                        }
                    }

                    Object after = getter.invoke(null);

                    if (paramType.isPrimitive()) {
                        assertEquals(m.toString(), before, after);
                    } else {
                        assertSame(m.toString(), before, after);
                    }
                }
            }",iterator
argCount,"for (int argCount = 2; argCount <= maxArgs; argCount++) {
            for (int argNull = 1; argNull <= argCount; argNull++) {
                Class<?>[] params = new Class[argCount];
                Arrays.fill(params, SingleSource.class);

                Object[] values = new Object[argCount];
                Arrays.fill(values, just1);
                values[argNull - 1] = null;

                Method m = clazz.getMethod(""concat"", params);

                try {
                    m.invoke(null, values);
                    Assert.fail(""No exception for argCount "" + argCount + "" / argNull "" + argNull);
                } catch (InvocationTargetException ex) {
                    if (!(ex.getCause() instanceof NullPointerException)) {
                        Assert.fail(""Unexpected exception for argCount "" + argCount + "" / argNull "" + argNull + "": "" + ex);
                    }
                }
            }
        }",loop_control
argNull,"for (int argNull = 1; argNull <= argCount; argNull++) {
                Class<?>[] params = new Class[argCount];
                Arrays.fill(params, SingleSource.class);

                Object[] values = new Object[argCount];
                Arrays.fill(values, just1);
                values[argNull - 1] = null;

                Method m = clazz.getMethod(""concat"", params);

                try {
                    m.invoke(null, values);
                    Assert.fail(""No exception for argCount "" + argCount + "" / argNull "" + argNull);
                } catch (InvocationTargetException ex) {
                    if (!(ex.getCause() instanceof NullPointerException)) {
                        Assert.fail(""Unexpected exception for argCount "" + argCount + "" / argNull "" + argNull + "": "" + ex);
                    }
                }
            }",loop_control
argCount,"for (int argCount = 2; argCount <= maxArgs; argCount++) {
            for (int argNull = 1; argNull <= argCount; argNull++) {
                Class<?>[] params = new Class[argCount];
                Arrays.fill(params, SingleSource.class);

                Object[] values = new Object[argCount];
                Arrays.fill(values, just1);
                values[argNull - 1] = null;

                Method m = clazz.getMethod(""merge"", params);

                try {
                    m.invoke(null, values);
                    Assert.fail(""No exception for argCount "" + argCount + "" / argNull "" + argNull);
                } catch (InvocationTargetException ex) {
                    if (!(ex.getCause() instanceof NullPointerException)) {
                        Assert.fail(""Unexpected exception for argCount "" + argCount + "" / argNull "" + argNull + "": "" + ex);
                    }
                }
            }
        }",loop_control
argNull,"for (int argNull = 1; argNull <= argCount; argNull++) {
                Class<?>[] params = new Class[argCount];
                Arrays.fill(params, SingleSource.class);

                Object[] values = new Object[argCount];
                Arrays.fill(values, just1);
                values[argNull - 1] = null;

                Method m = clazz.getMethod(""merge"", params);

                try {
                    m.invoke(null, values);
                    Assert.fail(""No exception for argCount "" + argCount + "" / argNull "" + argNull);
                } catch (InvocationTargetException ex) {
                    if (!(ex.getCause() instanceof NullPointerException)) {
                        Assert.fail(""Unexpected exception for argCount "" + argCount + "" / argNull "" + argNull + "": "" + ex);
                    }
                }
            }",loop_control
argCount,"for (int argCount = 3; argCount < 10; argCount++) {
            for (int argNull = 1; argNull <= argCount; argNull++) {
                Class<?>[] params = new Class[argCount + 1];
                Arrays.fill(params, SingleSource.class);
                Class<?> fniClass = Class.forName(""io.reactivex.rxjava3.functions.Function"" + argCount);
                params[argCount] = fniClass;

                Object[] values = new Object[argCount + 1];
                Arrays.fill(values, just1);
                values[argNull - 1] = null;
                values[argCount] = Proxy.newProxyInstance(getClass().getClassLoader(), new Class[] { fniClass }, new InvocationHandler() {
                    @Override
                    public Object invoke(Object o, Method m, Object[] a) throws Throwable {
                        return 1;
                    }
                });

                Method m = clazz.getMethod(""zip"", params);

                try {
                    m.invoke(null, values);
                    Assert.fail(""No exception for argCount "" + argCount + "" / argNull "" + argNull);
                } catch (InvocationTargetException ex) {
                    if (!(ex.getCause() instanceof NullPointerException)) {
                        Assert.fail(""Unexpected exception for argCount "" + argCount + "" / argNull "" + argNull + "": "" + ex);
                    }
                }

                values[argCount] = Proxy.newProxyInstance(getClass().getClassLoader(), new Class[] { fniClass }, new InvocationHandler() {
                    @Override
                    public Object invoke(Object o, Method m1, Object[] a) throws Throwable {
                        return null;
                    }
                });
                try {
                    ((Single<Object>)m.invoke(null, values)).blockingGet();
                    Assert.fail(""No exception for argCount "" + argCount + "" / argNull "" + argNull);
                } catch (InvocationTargetException ex) {
                    if (!(ex.getCause() instanceof NullPointerException)) {
                        Assert.fail(""Unexpected exception for argCount "" + argCount + "" / argNull "" + argNull + "": "" + ex);
                    }
                }

            }

            Class<?>[] params = new Class[argCount + 1];
            Arrays.fill(params, SingleSource.class);
            Class<?> fniClass = Class.forName(""io.reactivex.rxjava3.functions.Function"" + argCount);
            params[argCount] = fniClass;

            Object[] values = new Object[argCount + 1];
            Arrays.fill(values, just1);
            values[argCount] = null;

            Method m = clazz.getMethod(""zip"", params);

            try {
                m.invoke(null, values);
                Assert.fail(""No exception for argCount "" + argCount + "" / zipper function "");
            } catch (InvocationTargetException ex) {
                if (!(ex.getCause() instanceof NullPointerException)) {
                    Assert.fail(""Unexpected exception for argCount "" + argCount + "" / zipper function: "" + ex);
                }
            }
        }",loop_control
argNull,"for (int argNull = 1; argNull <= argCount; argNull++) {
                Class<?>[] params = new Class[argCount + 1];
                Arrays.fill(params, SingleSource.class);
                Class<?> fniClass = Class.forName(""io.reactivex.rxjava3.functions.Function"" + argCount);
                params[argCount] = fniClass;

                Object[] values = new Object[argCount + 1];
                Arrays.fill(values, just1);
                values[argNull - 1] = null;
                values[argCount] = Proxy.newProxyInstance(getClass().getClassLoader(), new Class[] { fniClass }, new InvocationHandler() {
                    @Override
                    public Object invoke(Object o, Method m, Object[] a) throws Throwable {
                        return 1;
                    }
                });

                Method m = clazz.getMethod(""zip"", params);

                try {
                    m.invoke(null, values);
                    Assert.fail(""No exception for argCount "" + argCount + "" / argNull "" + argNull);
                } catch (InvocationTargetException ex) {
                    if (!(ex.getCause() instanceof NullPointerException)) {
                        Assert.fail(""Unexpected exception for argCount "" + argCount + "" / argNull "" + argNull + "": "" + ex);
                    }
                }

                values[argCount] = Proxy.newProxyInstance(getClass().getClassLoader(), new Class[] { fniClass }, new InvocationHandler() {
                    @Override
                    public Object invoke(Object o, Method m1, Object[] a) throws Throwable {
                        return null;
                    }
                });
                try {
                    ((Single<Object>)m.invoke(null, values)).blockingGet();
                    Assert.fail(""No exception for argCount "" + argCount + "" / argNull "" + argNull);
                } catch (InvocationTargetException ex) {
                    if (!(ex.getCause() instanceof NullPointerException)) {
                        Assert.fail(""Unexpected exception for argCount "" + argCount + "" / argNull "" + argNull + "": "" + ex);
                    }
                }

            }",loop_control
iterator,"{
        Iterable<? extends Flowable<Integer>> f = SingleInternalHelper.iterableToFlowable(Arrays.asList(Single.just(1)));

        Iterator<? extends Flowable<Integer>> iterator = f.iterator();
        iterator.next();
        iterator.remove();
    }",iterator
i,"for (Object i : o) {
                    sum += (Integer) i;
                }",iterator
i,"for (int i = 0; i < 8; i++) {
            assertEquals(i + 1, q.peek().intValue());
            assertEquals(i + 1, q.poll().intValue());
        }",loop_control
c,"{
        final MpscLinkedQueue<Integer> q = new MpscLinkedQueue<>();

        final AtomicInteger c = new AtomicInteger(3);

        Thread t1 = new Thread(new Runnable() {
            int i;
            @Override
            public void run() {
                c.decrementAndGet();
                while (c.get() != 0) { }

                while (i++ < 10000) {
                    q.offer(i);
                }
            }
        });
        t1.start();

        Thread t2 = new Thread(new Runnable() {
            int i = 10000;
            @Override
            public void run() {
                c.decrementAndGet();
                while (c.get() != 0) { }

                while (i++ < 10000) {
                    q.offer(i);
                }
            }
        });
        t2.start();

        Runnable r3 = new Runnable() {
            int i = 20000;
            @Override
            public void run() {
                c.decrementAndGet();
                while (c.get() != 0) { }

                while (--i > 0) {
                    q.poll();
                }
            }
        };

        r3.run();

        t1.join();
        t2.join();
    }",maybe_loop_control
i,"{
            int i;
            @Override
            public void run() {
                c.decrementAndGet();
                while (c.get() != 0) { }

                while (i++ < 10000) {
                    q.offer(i);
                }
            }
        }",loop_control
i,"{
            int i = 10000;
            @Override
            public void run() {
                c.decrementAndGet();
                while (c.get() != 0) { }

                while (i++ < 10000) {
                    q.offer(i);
                }
            }
        }",loop_control
i,"{
            int i = 20000;
            @Override
            public void run() {
                c.decrementAndGet();
                while (c.get() != 0) { }

                while (--i > 0) {
                    q.poll();
                }
            }
        }",loop_control
i,"for (int i = 0; i < 20; i++) {
            q.offer(i);
        }",loop_control
i,"for (int i = 0; i < 20; i++) {
            assertEquals(i, q.poll().intValue());
        }",loop_control
i,"for (int i = 0; i < count; i++) {
            final Thread t = new Thread() {
                @Override
                public void run() {
                    try {
                        start.await();
                        serialDisposable.dispose();
                    } catch (InterruptedException e) {
                        fail(e.getMessage());
                    } finally {
                        end.countDown();
                    }
                }
            };
            t.start();
            threads.add(t);
        }",loop_control
t,"for (int i = 0; i < count; i++) {
            final Thread t = new Thread() {
                @Override
                public void run() {
                    try {
                        start.await();
                        serialDisposable.dispose();
                    } catch (InterruptedException e) {
                        fail(e.getMessage());
                    } finally {
                        end.countDown();
                    }
                }
            };
            t.start();
            threads.add(t);
        }",iterator
t,"for (final Thread t : threads) {
            t.join();
        }",iterator
i,"for (int i = 0; i < count; i++) {
            final Disposable subscription = mock(Disposable.class);
            subscriptions.add(subscription);

            final Thread t = new Thread() {
                @Override
                public void run() {
                    try {
                        start.await();
                        serialDisposable.update(subscription);
                    } catch (InterruptedException e) {
                        fail(e.getMessage());
                    } finally {
                        end.countDown();
                    }
                }
            };
            t.start();
            threads.add(t);
        }",loop_control
t,"for (int i = 0; i < count; i++) {
            final Disposable subscription = mock(Disposable.class);
            subscriptions.add(subscription);

            final Thread t = new Thread() {
                @Override
                public void run() {
                    try {
                        start.await();
                        serialDisposable.update(subscription);
                    } catch (InterruptedException e) {
                        fail(e.getMessage());
                    } finally {
                        end.countDown();
                    }
                }
            };
            t.start();
            threads.add(t);
        }",iterator
t,"for (final Thread t : threads) {
            t.join();
        }",iterator
i,"for (int i = 0; i < count; i++) {
            cd.add(Disposable.fromRunnable(new Runnable() {

                @Override
                public void run() {
                    counter.incrementAndGet();
                }
            }));
        }",loop_control
i,"for (int i = 0; i < count; i++) {
            final Thread t = new Thread() {
                @Override
                public void run() {
                    try {
                        start.await();
                        cd.dispose();
                    } catch (final InterruptedException e) {
                        fail(e.getMessage());
                    }
                }
            };
            t.start();
            threads.add(t);
        }",loop_control
t,"for (int i = 0; i < count; i++) {
            final Thread t = new Thread() {
                @Override
                public void run() {
                    try {
                        start.await();
                        cd.dispose();
                    } catch (final InterruptedException e) {
                        fail(e.getMessage());
                    }
                }
            };
            t.start();
            threads.add(t);
        }",iterator
t,"for (final Thread t : threads) {
            t.join();
        }",iterator
i,"for (int i = 0; i < count; i++) {
            final Thread t = new Thread() {
                @Override
                public void run() {
                    try {
                        start.await();
                        cd.dispose();
                    } catch (final InterruptedException e) {
                        fail(e.getMessage());
                    }
                }
            };
            t.start();
            threads.add(t);
        }",loop_control
t,"for (int i = 0; i < count; i++) {
            final Thread t = new Thread() {
                @Override
                public void run() {
                    try {
                        start.await();
                        cd.dispose();
                    } catch (final InterruptedException e) {
                        fail(e.getMessage());
                    }
                }
            };
            t.start();
            threads.add(t);
        }",iterator
t,"for (final Thread t : threads) {
            t.join();
        }",iterator
i,"for (int i = 0; i < TestHelper.RACE_DEFAULT_LOOPS; i++) {
            final CompositeDisposable cd = new CompositeDisposable();

            Runnable run = new Runnable() {
                @Override
                public void run() {
                    cd.dispose();
                }
            };

            TestHelper.race(run, run);
        }",loop_control
i,"for (int i = 0; i < TestHelper.RACE_DEFAULT_LOOPS; i++) {
            final CompositeDisposable cd = new CompositeDisposable();

            Runnable run = new Runnable() {
                @Override
                public void run() {
                    cd.add(Disposable.empty());
                }
            };

            TestHelper.race(run, run);
        }",loop_control
i,"for (int i = 0; i < TestHelper.RACE_DEFAULT_LOOPS; i++) {
            final CompositeDisposable cd = new CompositeDisposable();

            Runnable run = new Runnable() {
                @Override
                public void run() {
                    cd.addAll(Disposable.empty());
                }
            };

            TestHelper.race(run, run);
        }",loop_control
i,"for (int i = 0; i < TestHelper.RACE_DEFAULT_LOOPS; i++) {
            final CompositeDisposable cd = new CompositeDisposable();

            final Disposable d1 = Disposable.empty();

            cd.add(d1);

            Runnable run = new Runnable() {
                @Override
                public void run() {
                    cd.remove(d1);
                }
            };

            TestHelper.race(run, run);
        }",loop_control
i,"for (int i = 0; i < TestHelper.RACE_DEFAULT_LOOPS; i++) {
            final CompositeDisposable cd = new CompositeDisposable();

            final Disposable d1 = Disposable.empty();

            cd.add(d1);

            Runnable run = new Runnable() {
                @Override
                public void run() {
                    cd.delete(d1);
                }
            };

            TestHelper.race(run, run);
        }",loop_control
i,"for (int i = 0; i < TestHelper.RACE_DEFAULT_LOOPS; i++) {
            final CompositeDisposable cd = new CompositeDisposable();

            final Disposable d1 = Disposable.empty();

            cd.add(d1);

            Runnable run = new Runnable() {
                @Override
                public void run() {
                    cd.clear();
                }
            };

            TestHelper.race(run, run);
        }",loop_control
i,"for (int i = 0; i < TestHelper.RACE_DEFAULT_LOOPS; i++) {
            final CompositeDisposable cd = new CompositeDisposable();

            Runnable run = new Runnable() {
                @Override
                public void run() {
                    cd.dispose();
                }
            };

            Runnable run2 = new Runnable() {
                @Override
                public void run() {
                    cd.add(Disposable.empty());
                }
            };

            TestHelper.race(run, run2);
        }",loop_control
i,"for (int i = 0; i < TestHelper.RACE_DEFAULT_LOOPS; i++) {
            final CompositeDisposable cd = new CompositeDisposable();

            Runnable run = new Runnable() {
                @Override
                public void run() {
                    cd.dispose();
                }
            };

            Runnable run2 = new Runnable() {
                @Override
                public void run() {
                    cd.addAll(Disposable.empty());
                }
            };

            TestHelper.race(run, run2);
        }",loop_control
i,"for (int i = 0; i < TestHelper.RACE_DEFAULT_LOOPS; i++) {
            final CompositeDisposable cd = new CompositeDisposable();

            final Disposable d1 = Disposable.empty();

            cd.add(d1);

            Runnable run = new Runnable() {
                @Override
                public void run() {
                    cd.dispose();
                }
            };

            Runnable run2 = new Runnable() {
                @Override
                public void run() {
                    cd.remove(d1);
                }
            };

            TestHelper.race(run, run2);
        }",loop_control
i,"for (int i = 0; i < TestHelper.RACE_DEFAULT_LOOPS; i++) {
            final CompositeDisposable cd = new CompositeDisposable();

            final Disposable d1 = Disposable.empty();

            cd.add(d1);

            Runnable run = new Runnable() {
                @Override
                public void run() {
                    cd.dispose();
                }
            };

            Runnable run2 = new Runnable() {
                @Override
                public void run() {
                    cd.delete(d1);
                }
            };

            TestHelper.race(run, run2);
        }",loop_control
i,"for (int i = 0; i < TestHelper.RACE_DEFAULT_LOOPS; i++) {
            final CompositeDisposable cd = new CompositeDisposable();

            final Disposable d1 = Disposable.empty();

            cd.add(d1);

            Runnable run = new Runnable() {
                @Override
                public void run() {
                    cd.dispose();
                }
            };

            Runnable run2 = new Runnable() {
                @Override
                public void run() {
                    cd.clear();
                }
            };

            TestHelper.race(run, run2);
        }",loop_control
i,"for (int i = 0; i < TestHelper.RACE_DEFAULT_LOOPS; i++) {
            final CompositeDisposable cd = new CompositeDisposable();

            final Disposable d1 = Disposable.empty();

            cd.add(d1);

            Runnable run = new Runnable() {
                @Override
                public void run() {
                    cd.dispose();
                }
            };

            Runnable run2 = new Runnable() {
                @Override
                public void run() {
                    cd.size();
                }
            };

            TestHelper.race(run, run2);
        }",loop_control
i,"for (int i = 0; i < TestHelper.RACE_DEFAULT_LOOPS; i++) {
            final Disposable d = Disposable.empty();

            Runnable r = new Runnable() {
                @Override
                public void run() {
                    d.dispose();
                }
            };

            TestHelper.race(r, r);
        }",loop_control
i,"for (int i = 0; i < count; i++) {
            final Thread t = new Thread() {
                @Override
                public void run() {
                    try {
                        start.await();
                        serialDisposable.dispose();
                    } catch (InterruptedException e) {
                        fail(e.getMessage());
                    } finally {
                        end.countDown();
                    }
                }
            };
            t.start();
            threads.add(t);
        }",loop_control
t,"for (int i = 0; i < count; i++) {
            final Thread t = new Thread() {
                @Override
                public void run() {
                    try {
                        start.await();
                        serialDisposable.dispose();
                    } catch (InterruptedException e) {
                        fail(e.getMessage());
                    } finally {
                        end.countDown();
                    }
                }
            };
            t.start();
            threads.add(t);
        }",iterator
t,"for (final Thread t : threads) {
            t.join();
        }",iterator
i,"for (int i = 0; i < count; i++) {
            final Disposable subscription = mock(Disposable.class);
            subscriptions.add(subscription);

            final Thread t = new Thread() {
                @Override
                public void run() {
                    try {
                        start.await();
                        serialDisposable.set(subscription);
                    } catch (InterruptedException e) {
                        fail(e.getMessage());
                    } finally {
                        end.countDown();
                    }
                }
            };
            t.start();
            threads.add(t);
        }",loop_control
t,"for (int i = 0; i < count; i++) {
            final Disposable subscription = mock(Disposable.class);
            subscriptions.add(subscription);

            final Thread t = new Thread() {
                @Override
                public void run() {
                    try {
                        start.await();
                        serialDisposable.set(subscription);
                    } catch (InterruptedException e) {
                        fail(e.getMessage());
                    } finally {
                        end.countDown();
                    }
                }
            };
            t.start();
            threads.add(t);
        }",iterator
t,"for (final Thread t : threads) {
            t.join();
        }",iterator
n,"for (int n = 1; n < 10000; n *= 10) {
            Completable c = Completable.fromPublisher(Flowable.range(1, n));

            c.blockingAwait();
        }",loop_control
n,"for (int n = 1; n < 10000; n *= 10) {
            Completable c = Completable.fromObservable(Observable.range(1, n));

            c.blockingAwait();
        }",loop_control
timeout,"{
        Completable c = normal.completable.delay(250, TimeUnit.MILLISECONDS);

        final AtomicBoolean done = new AtomicBoolean();
        final AtomicReference<Throwable> error = new AtomicReference<>();

        c.subscribe(new CompletableObserver() {
            @Override
            public void onSubscribe(Disposable d) {

            }

            @Override
            public void onError(Throwable e) {
                error.set(e);
            }

            @Override
            public void onComplete() {
                done.set(true);
            }
        });

        Thread.sleep(100);

        Assert.assertFalse(""Already done"", done.get());

        int timeout = 10;

        while (timeout-- > 0 && !done.get()) {
            Thread.sleep(100);
        }

        Assert.assertTrue(""Not done"", done.get());

        Assert.assertNull(error.get());
    }",loop_control
done,"{
        Completable c = normal.completable.delay(250, TimeUnit.MILLISECONDS);

        final AtomicBoolean done = new AtomicBoolean();
        final AtomicReference<Throwable> error = new AtomicReference<>();

        c.subscribe(new CompletableObserver() {
            @Override
            public void onSubscribe(Disposable d) {

            }

            @Override
            public void onError(Throwable e) {
                error.set(e);
            }

            @Override
            public void onComplete() {
                done.set(true);
            }
        });

        Thread.sleep(100);

        Assert.assertFalse(""Already done"", done.get());

        int timeout = 10;

        while (timeout-- > 0 && !done.get()) {
            Thread.sleep(100);
        }

        Assert.assertTrue(""Not done"", done.get());

        Assert.assertNull(error.get());
    }",maybe_loop_control
i,"for (int i = 0; i < 10; i++) {
            c.blockingAwait();
        }",loop_control
caught,"{
            action.run();
            assertEquals(""Should have received exactly 1 exception"", 1, handler.count);
            Throwable caught = handler.caught;
            while (caught != null) {
                if (caught instanceof TestException) { break; }
                if (caught == caught.getCause()) { break; }
                caught = caught.getCause();
            }
            assertTrue(""A TestException should have been delivered to the handler"",
                    caught instanceof TestException);
        }",maybe_loop_control
caught,"{
            action.run();
            assertEquals(""Should have received exactly 1 exception"", 1, handler.count);
            Throwable caught = handler.caught;
            while (caught != null) {
                if (caught instanceof TestException) { break; }
                if (caught == caught.getCause()) { break; }
                caught = caught.getCause();
            }
            assertTrue(""A TestException should have been delivered to the handler"",
                    caught instanceof TestException);
        }",break_loop_control
i,"for (int i = 0; i < 10; i++) {
            final Observer<Object> o = TestHelper.mockObserver();
            InOrder inOrder = inOrder(o);
            String v = """" + i;
            src.onNext(v);
            System.out.printf(""Turn: %d%n"", i);
            src.firstElement()
                .toObservable()
                .flatMap(new Function<String, Observable<String>>() {

                    @Override
                    public Observable<String> apply(String t1) {
                        return Observable.just(t1 + "", "" + t1);
                    }
                })
                .subscribe(new DefaultObserver<String>() {
                    @Override
                    public void onNext(String t) {
                        System.out.println(t);
                        o.onNext(t);
                    }

                    @Override
                    public void onError(Throwable e) {
                        o.onError(e);
                    }

                    @Override
                    public void onComplete() {
                        o.onComplete();
                    }
                });
            inOrder.verify(o).onNext(""0, 0"");
            inOrder.verify(o).onComplete();
            verify(o, never()).onError(any(Throwable.class));
        }",loop_control
i,"for (int i = 0; i < 1; i++) {
            Observer<Integer> o = TestHelper.mockObserver();

            source.subscribe(o);

            verify(o, never()).onNext(1);
            verify(o).onNext(2);
            verify(o).onComplete();
            verify(o, never()).onError(any(Throwable.class));
        }",loop_control
i,"for (int i = 0; i < 1000; i++) {
            rs.onNext(i);

            assertEquals(1, rs.size());
            assertTrue(rs.hasValue());
        }",loop_control
i,"for (int i = 0; i < 1000; i++) {
            rs.onNext(i);
            assertEquals(1, rs.size());
            assertTrue(rs.hasValue());
            to.advanceTimeBy(2, TimeUnit.SECONDS);
            assertEquals(0, rs.size());
            assertFalse(rs.hasValue());
        }",loop_control
i,"for (int i = 0; i < expected.length; i++) {
            expected[i] = i;
            rs.onNext(i);
            assertArrayEquals(Arrays.copyOf(expected, i + 1), rs.getValues());
        }",loop_control
i,"for (int i = 0; i < expected.length; i++) {
            expected[i] = i;
            rs.onNext(i);
            assertArrayEquals(Arrays.copyOf(expected, i + 1), rs.getValues());
        }",loop_control
i,"for (int i = 0; i < 15; i++) {
            rp.onNext(i);
        }",loop_control
i,"for (int i = 0; i < TestHelper.RACE_DEFAULT_LOOPS; i++) {
            final TestObserver<Integer> to = new TestObserver<>();

            final ReplaySubject<Integer> rp = ReplaySubject.create();

            Runnable r1 = new Runnable() {
                @Override
                public void run() {
                    rp.subscribe(to);
                }
            };

            Runnable r2 = new Runnable() {
                @Override
                public void run() {
                    to.dispose();
                }
            };

            TestHelper.race(r1, r2);
        }",loop_control
i,"for (int i = 0; i < TestHelper.RACE_DEFAULT_LOOPS; i++) {
            final ReplaySubject<Integer> rp = ReplaySubject.create();

            Runnable r1 = new Runnable() {
                @Override
                public void run() {
                    rp.test();
                }
            };

            TestHelper.race(r1, r1);
        }",loop_control
i,"for (int i = 0; i < TestHelper.RACE_DEFAULT_LOOPS; i++) {

            final ReplaySubject<Integer> rp = ReplaySubject.create();
            final TestObserver<Integer> to1 = rp.test();
            final TestObserver<Integer> to2 = rp.test();

            Runnable r1 = new Runnable() {
                @Override
                public void run() {
                    to1.dispose();
                }
            };

            Runnable r2 = new Runnable() {
                @Override
                public void run() {
                    to2.dispose();
                }
            };

            TestHelper.race(r1, r2);

            assertFalse(rp.hasObservers());
        }",loop_control
i,"for (int i = 0; i < 10; i++) {
            s.onNext(i);
        }",loop_control
i,"for (int i = 0; i < 10; i++) {
            final Observer<Object> o = TestHelper.mockObserver();
            InOrder inOrder = inOrder(o);
            String v = """" + i;
            System.out.printf(""Turn: %d%n"", i);
            src.firstElement()
                .toObservable()
                .flatMap(new Function<String, Observable<String>>() {

                    @Override
                    public Observable<String> apply(String t1) {
                        return Observable.just(t1 + "", "" + t1);
                    }
                })
                .subscribe(new DefaultObserver<String>() {
                    @Override
                    public void onNext(String t) {
                        o.onNext(t);
                    }

                    @Override
                    public void onError(Throwable e) {
                        o.onError(e);
                    }

                    @Override
                    public void onComplete() {
                        o.onComplete();
                    }
                });
            src.onNext(v);

            inOrder.verify(o).onNext(v + "", "" + v);
            inOrder.verify(o).onComplete();
            verify(o, never()).onError(any(Throwable.class));
        }",loop_control
i,"for (int i = 0; i < TestHelper.RACE_DEFAULT_LOOPS; i++) {
            final PublishSubject<Integer> ps = PublishSubject.create();

            TestObserver<Integer> to = ps.test();

            Runnable task = new Runnable() {
                @Override
                public void run() {
                    ps.onComplete();
                }
            };

            TestHelper.race(task, task);

            to
            .awaitDone(5, TimeUnit.SECONDS)
            .assertResult();
        }",loop_control
i,"for (int i = 0; i < TestHelper.RACE_DEFAULT_LOOPS; i++) {
            final PublishSubject<Integer> ps = PublishSubject.create();

            final TestObserver<Integer> to = ps.test();

            Runnable r1 = new Runnable() {
                @Override
                public void run() {
                    ps.subscribe();
                }
            };
            Runnable r2 = new Runnable() {
                @Override
                public void run() {
                    to.dispose();
                }
            };

            TestHelper.race(r1, r2);
        }",loop_control
i,"for (int i = 0; i < TestHelper.RACE_DEFAULT_LOOPS; i++) {
            final PublishSubject<Integer> ps = PublishSubject.create();

            Runnable r1 = new Runnable() {
                @Override
                public void run() {
                    ps.subscribe();
                }
            };
            Runnable r2 = new Runnable() {
                @Override
                public void run() {
                    ps.onComplete();
                }
            };

            TestHelper.race(r1, r2);
        }",loop_control
i,"for (int i = 0; i < TestHelper.RACE_DEFAULT_LOOPS; i++) {
            final PublishSubject<Integer> ps = PublishSubject.create();

            final TestObserver<Integer> to = new TestObserver<>();

            Runnable r1 = new Runnable() {
                @Override
                public void run() {
                    ps.subscribe(to);
                }
            };
            Runnable r2 = new Runnable() {
                @Override
                public void run() {
                    ps.onComplete();
                }
            };

            TestHelper.race(r1, r2);

            to.awaitDone(5, TimeUnit.SECONDS)
            .assertResult();
        }",loop_control
i,"for (int i = 0; i < 50; i++) {
            final AsyncSubject<String> subject = AsyncSubject.create();
            final AtomicReference<String> value1 = new AtomicReference<>();

            subject.subscribe(new Consumer<String>() {

                @Override
                public void accept(String t1) {
                    try {
                        // simulate a slow observer
                        Thread.sleep(50);
                    } catch (InterruptedException e) {
                        e.printStackTrace();
                    }
                    value1.set(t1);
                }

            });

            Thread t1 = new Thread(new Runnable() {

                @Override
                public void run() {
                    subject.onNext(""value"");
                    subject.onComplete();
                }
            });

            SubjectSubscriberThread t2 = new SubjectSubscriberThread(subject);
            SubjectSubscriberThread t3 = new SubjectSubscriberThread(subject);
            SubjectSubscriberThread t4 = new SubjectSubscriberThread(subject);
            SubjectSubscriberThread t5 = new SubjectSubscriberThread(subject);

            t2.start();
            t3.start();
            t1.start();
            t4.start();
            t5.start();
            try {
                t1.join();
                t2.join();
                t3.join();
                t4.join();
                t5.join();
            } catch (InterruptedException e) {
                throw new RuntimeException(e);
            }

            assertEquals(""value"", value1.get());
            assertEquals(""value"", t2.value.get());
            assertEquals(""value"", t3.value.get());
            assertEquals(""value"", t4.value.get());
            assertEquals(""value"", t5.value.get());
        }",loop_control
i,"for (int i = 0; i < TestHelper.RACE_DEFAULT_LOOPS; i++) {
            final TestObserver<Object> to1 = p.test();
            final TestObserver<Object> to2 = p.test();

            Runnable r1 = new Runnable() {
                @Override
                public void run() {
                    to1.dispose();
                }
            };

            Runnable r2 = new Runnable() {
                @Override
                public void run() {
                    to2.dispose();
                }
            };

            TestHelper.race(r1, r2);
        }",loop_control
i,"for (int i = 0; i < TestHelper.RACE_DEFAULT_LOOPS; i++) {
            final AsyncSubject<Object> p = AsyncSubject.create();

            final TestObserverEx<Object> to1 = p.to(TestHelper.testConsumer());

            Runnable r1 = new Runnable() {
                @Override
                public void run() {
                    to1.dispose();
                }
            };

            final TestException ex = new TestException();

            Runnable r2 = new Runnable() {
                @Override
                public void run() {
                    p.onError(ex);
                }
            };

            TestHelper.race(r1, r2);

            if (to1.errors().size() != 0) {
                to1.assertFailure(TestException.class);
            } else {
                to1.assertEmpty();
            }
        }",loop_control
i,"for (int i = 0; i < TestHelper.RACE_DEFAULT_LOOPS; i++) {
            final Subject<Integer> s = PublishSubject.<Integer>create().toSerialized();

            TestObserverEx<Integer> to = s.to(TestHelper.<Integer>testConsumer());

            Runnable r1 = new Runnable() {
                @Override
                public void run() {
                    s.onNext(1);
                }
            };

            Runnable r2 = new Runnable() {
                @Override
                public void run() {
                    s.onNext(2);
                }
            };

            TestHelper.race(r1, r2);

            to.assertSubscribed()
            .assertNoErrors()
            .assertNotComplete()
            .assertValueCount(2)
            ;

            Set<Integer> actualSet = new HashSet<>(to.values());
            assertEquals("""" + actualSet, expectedSet, actualSet);
        }",loop_control
i,"for (int i = 0; i < TestHelper.RACE_DEFAULT_LOOPS; i++) {
            final Subject<Integer> s = PublishSubject.<Integer>create().toSerialized();

            TestObserver<Integer> to = s.test();

            final TestException ex = new TestException();

            Runnable r1 = new Runnable() {
                @Override
                public void run() {
                    s.onNext(1);
                }
            };

            Runnable r2 = new Runnable() {
                @Override
                public void run() {
                    s.onError(ex);
                }
            };

            TestHelper.race(r1, r2);

            to.assertError(ex).assertNotComplete();

            if (to.values().size() != 0) {
                to.assertValue(1);
            }
        }",loop_control
i,"for (int i = 0; i < TestHelper.RACE_DEFAULT_LOOPS; i++) {
            final Subject<Integer> s = PublishSubject.<Integer>create().toSerialized();

            TestObserver<Integer> to = s.test();

            Runnable r1 = new Runnable() {
                @Override
                public void run() {
                    s.onNext(1);
                }
            };

            Runnable r2 = new Runnable() {
                @Override
                public void run() {
                    s.onComplete();
                }
            };

            TestHelper.race(r1, r2);

            to.assertComplete().assertNoErrors();

            if (to.values().size() != 0) {
                to.assertValue(1);
            }
        }",loop_control
i,"for (int i = 0; i < TestHelper.RACE_DEFAULT_LOOPS; i++) {
            final Subject<Integer> s = PublishSubject.<Integer>create().toSerialized();

            TestObserver<Integer> to = s.test();

            final Disposable bs = Disposable.empty();

            Runnable r1 = new Runnable() {
                @Override
                public void run() {
                    s.onNext(1);
                }
            };

            Runnable r2 = new Runnable() {
                @Override
                public void run() {
                    s.onSubscribe(bs);
                }
            };

            TestHelper.race(r1, r2);

            to.assertValue(1).assertNotComplete().assertNoErrors();
        }",loop_control
i,"for (int i = 0; i < TestHelper.RACE_DEFAULT_LOOPS; i++) {
            final Subject<Integer> s = PublishSubject.<Integer>create().toSerialized();

            TestObserver<Integer> to = s.test();

            final Disposable bs = Disposable.empty();

            Runnable r1 = new Runnable() {
                @Override
                public void run() {
                    s.onComplete();
                }
            };

            Runnable r2 = new Runnable() {
                @Override
                public void run() {
                    s.onSubscribe(bs);
                }
            };

            TestHelper.race(r1, r2);

            to.assertResult();
        }",loop_control
i,"for (int i = 0; i < TestHelper.RACE_DEFAULT_LOOPS; i++) {
            final Subject<Integer> s = PublishSubject.<Integer>create().toSerialized();

            TestObserver<Integer> to = s.test();

            Runnable r1 = new Runnable() {
                @Override
                public void run() {
                    s.onComplete();
                }
            };

            Runnable r2 = new Runnable() {
                @Override
                public void run() {
                    s.onComplete();
                }
            };

            TestHelper.race(r1, r2);

            to.assertResult();
        }",loop_control
i,"for (int i = 0; i < TestHelper.RACE_DEFAULT_LOOPS; i++) {
            final Subject<Integer> s = PublishSubject.<Integer>create().toSerialized();

            TestObserver<Integer> to = s.test();

            final TestException ex = new TestException();

            List<Throwable> errors = TestHelper.trackPluginErrors();
            try {
                Runnable r1 = new Runnable() {
                    @Override
                    public void run() {
                        s.onError(ex);
                    }
                };

                Runnable r2 = new Runnable() {
                    @Override
                    public void run() {
                        s.onError(ex);
                    }
                };

                TestHelper.race(r1, r2);

                to.assertFailure(TestException.class);

                TestHelper.assertUndeliverable(errors, 0, TestException.class);
            } finally {
                RxJavaPlugins.reset();
            }
        }",loop_control
i,"for (int i = 0; i < TestHelper.RACE_DEFAULT_LOOPS; i++) {
            final Subject<Integer> s = PublishSubject.<Integer>create().toSerialized();

            TestObserver<Integer> to = s.test();

            final Disposable bs1 = Disposable.empty();
            final Disposable bs2 = Disposable.empty();

            Runnable r1 = new Runnable() {
                @Override
                public void run() {
                    s.onSubscribe(bs1);
                }
            };

            Runnable r2 = new Runnable() {
                @Override
                public void run() {
                    s.onSubscribe(bs2);
                }
            };

            TestHelper.race(r1, r2);

            to.assertEmpty();
        }",loop_control
i,"for (int i = 0; i < TestHelper.RACE_DEFAULT_LOOPS; i++) {
            final MaybeSubject<Integer> ms = MaybeSubject.create();

            final TestObserver<Integer> to = ms.test();

            Runnable r1 = new Runnable() {
                @Override
                public void run() {
                    ms.test();
                }
            };

            Runnable r2 = new Runnable() {
                @Override
                public void run() {
                    to.dispose();
                }
            };
            TestHelper.race(r1, r2);
        }",loop_control
l,"for (long l = 1; l <= 10000; l++) {
                            o.onNext(l);
                        }",loop_control
l,"for (long l = 1; l <= 10000; l++) {
                            o.onNext(l);
                        }",loop_control
l,"for (long l : values) {
                v += l;
            }",loop_control
l,"for (long l : sums) {
            if (l != expected) {
                success = false;
                System.out.println(""FAILURE => Expected "" + expected + "" but got: "" + l);
            }
        }",loop_control
i,"for (int i = 1; i <= 200; i++) {
            final int count = i;
            if (count == 20) {
                // start source data after we have some already subscribed
                // and while others are in process of subscribing
                source.start();
            }
            if (count == 100) {
                // wait for source to finish then keep adding after it's done
                source.join();
            }
            Thread t = new Thread(new Runnable() {

                @Override
                public void run() {
                    List<Long> values = replay.toList().blockingGet();
                    listOfListsOfValues.add(values);
                    System.out.println(""Finished thread: "" + count);
                }
            });
            t.start();
            System.out.println(""Started thread: "" + i);
            threads.add(t);
        }",loop_control
t,"for (int i = 1; i <= 200; i++) {
            final int count = i;
            if (count == 20) {
                // start source data after we have some already subscribed
                // and while others are in process of subscribing
                source.start();
            }
            if (count == 100) {
                // wait for source to finish then keep adding after it's done
                source.join();
            }
            Thread t = new Thread(new Runnable() {

                @Override
                public void run() {
                    List<Long> values = replay.toList().blockingGet();
                    listOfListsOfValues.add(values);
                    System.out.println(""Finished thread: "" + count);
                }
            });
            t.start();
            System.out.println(""Started thread: "" + i);
            threads.add(t);
        }",iterator
t,"for (Thread t : threads) {
            t.join();
        }",iterator
values,"{
                    List<Long> values = replay.toList().blockingGet();
                    listOfListsOfValues.add(values);
                    System.out.println(""Finished thread: "" + count);
                }",iterator
values,"for (List<Long> values : listOfListsOfValues) {
            long v = 0;
            for (long l : values) {
                v += l;
            }
            sums.add(v);
        }",iterator
i,"for (int i = 0; i < 50; i++) {
            final ReplaySubject<String> subject = ReplaySubject.createUnbounded();
            final AtomicReference<String> value1 = new AtomicReference<>();

            subject.subscribe(new Consumer<String>() {

                @Override
                public void accept(String t1) {
                    try {
                        // simulate a slow observer
                        Thread.sleep(50);
                    } catch (InterruptedException e) {
                        e.printStackTrace();
                    }
                    value1.set(t1);
                }

            });

            Thread t1 = new Thread(new Runnable() {

                @Override
                public void run() {
                    subject.onNext(""value"");
                    subject.onComplete();
                }
            });

            SubjectObserverThread t2 = new SubjectObserverThread(subject);
            SubjectObserverThread t3 = new SubjectObserverThread(subject);
            SubjectObserverThread t4 = new SubjectObserverThread(subject);
            SubjectObserverThread t5 = new SubjectObserverThread(subject);

            t2.start();
            t3.start();
            t1.start();
            t4.start();
            t5.start();
            try {
                t1.join();
                t2.join();
                t3.join();
                t4.join();
                t5.join();
            } catch (InterruptedException e) {
                throw new RuntimeException(e);
            }

            assertEquals(""value"", value1.get());
            assertEquals(""value"", t2.value.get());
            assertEquals(""value"", t3.value.get());
            assertEquals(""value"", t4.value.get());
            assertEquals(""value"", t5.value.get());
        }",loop_control
i,"for (int i = 0; i < 100000; i++) {
            TestObserverEx<Integer> to = new TestObserverEx<>();
            Observable.just(1).subscribeOn(Schedulers.computation()).cache().subscribe(to);
            to.awaitDone(5, TimeUnit.SECONDS);
            to.assertValueSequence(expected);
            to.assertTerminated();
        }",loop_control
i,"for (int i = 0; i < 50000; i++) {
                if (i % 1000 == 0) {
                    System.out.println(i);
                }
                final ReplaySubject<Object> rs = ReplaySubject.createWithSize(2);

                final CountDownLatch finish = new CountDownLatch(1);
                final CountDownLatch start = new CountDownLatch(1);

//                int j = i;

                worker.schedule(new Runnable() {
                    @Override
                    public void run() {
                        try {
                            start.await();
                        } catch (Exception e1) {
                            e1.printStackTrace();
                        }
//                        System.out.println(""> "" + j);
                        rs.onNext(1);
                    }
                });

                final AtomicReference<Object> o = new AtomicReference<>();

                rs
//                .doOnSubscribe(v -> System.out.println(""!! "" + j))
//                .doOnNext(e -> System.out.println("">> "" + j))
                .subscribeOn(s)
                .observeOn(Schedulers.io())
//                .doOnNext(e -> System.out.println("">>> "" + j))
                .subscribe(new DefaultObserver<Object>() {

                    @Override
                    protected void onStart() {
                        super.onStart();
                    }

                    @Override
                    public void onComplete() {
                        o.set(-1);
                        finish.countDown();
                    }

                    @Override
                    public void onError(Throwable e) {
                        o.set(e);
                        finish.countDown();
                    }

                    @Override
                    public void onNext(Object t) {
                        o.set(t);
                        finish.countDown();
                    }

                });
                start.countDown();

                if (!finish.await(5, TimeUnit.SECONDS)) {
                    System.out.println(o.get());
                    System.out.println(rs.hasObservers());
                    rs.onComplete();
                    Assert.fail(""Timeout @ "" + i);
                    break;
                } else {
                    Assert.assertEquals(1, o.get());
                    worker.schedule(new Runnable() {
                        @Override
                        public void run() {
                            rs.onComplete();
                        }
                    });
                }
            }",loop_control
finish,"for (int i = 0; i < 50000; i++) {
                if (i % 1000 == 0) {
                    System.out.println(i);
                }
                final ReplaySubject<Object> rs = ReplaySubject.createWithSize(2);

                final CountDownLatch finish = new CountDownLatch(1);
                final CountDownLatch start = new CountDownLatch(1);

//                int j = i;

                worker.schedule(new Runnable() {
                    @Override
                    public void run() {
                        try {
                            start.await();
                        } catch (Exception e1) {
                            e1.printStackTrace();
                        }
//                        System.out.println(""> "" + j);
                        rs.onNext(1);
                    }
                });

                final AtomicReference<Object> o = new AtomicReference<>();

                rs
//                .doOnSubscribe(v -> System.out.println(""!! "" + j))
//                .doOnNext(e -> System.out.println("">> "" + j))
                .subscribeOn(s)
                .observeOn(Schedulers.io())
//                .doOnNext(e -> System.out.println("">>> "" + j))
                .subscribe(new DefaultObserver<Object>() {

                    @Override
                    protected void onStart() {
                        super.onStart();
                    }

                    @Override
                    public void onComplete() {
                        o.set(-1);
                        finish.countDown();
                    }

                    @Override
                    public void onError(Throwable e) {
                        o.set(e);
                        finish.countDown();
                    }

                    @Override
                    public void onNext(Object t) {
                        o.set(t);
                        finish.countDown();
                    }

                });
                start.countDown();

                if (!finish.await(5, TimeUnit.SECONDS)) {
                    System.out.println(o.get());
                    System.out.println(rs.hasObservers());
                    rs.onComplete();
                    Assert.fail(""Timeout @ "" + i);
                    break;
                } else {
                    Assert.assertEquals(1, o.get());
                    worker.schedule(new Runnable() {
                        @Override
                        public void run() {
                            rs.onComplete();
                        }
                    });
                }
            }",break_loop_control
i,"for (int i = 0; i < 1000000; i++) {
                    rs.onNext(i);
                }",loop_control
i,"for (int i = 0; i < values.length - 1; i++) {
                Integer v1 = (Integer)values[i];
                Integer v2 = (Integer)values[i + 1];
                assertEquals(1, v2 - v1);
            }",loop_control
rs,"{
        final ReplaySubject<Object> rs = ReplaySubject.createUnbounded();
        final CyclicBarrier cb = new CyclicBarrier(2);

        Thread t = new Thread(new Runnable() {
            @Override
            public void run() {
                try {
                    cb.await();
                } catch (InterruptedException e) {
                    return;
                } catch (BrokenBarrierException e) {
                    return;
                }
                for (int i = 0; i < 1000000; i++) {
                    rs.onNext(i);
                }
                rs.onComplete();
                System.out.println(""Replay fill Thread finished!"");
            }
        });
        t.start();
        try {
            cb.await();
        } catch (InterruptedException e) {
            return;
        } catch (BrokenBarrierException e) {
            return;
        }
        int lastSize = 0;
        for (; !rs.hasThrowable() && !rs.hasComplete();) {
            int size = rs.size();
            boolean hasAny = rs.hasValue();
            Object[] values = rs.getValues();
            if (size < lastSize) {
                Assert.fail(""Size decreased! "" + lastSize + "" -> "" + size);
            }
            if ((size > 0) && !hasAny) {
                Assert.fail(""hasAnyValue reports emptyness but size doesn't"");
            }
            if (size > values.length) {
                Assert.fail(""Got fewer values than size! "" + size + "" -> "" + values.length);
            }
            for (int i = 0; i < values.length - 1; i++) {
                Integer v1 = (Integer)values[i];
                Integer v2 = (Integer)values[i + 1];
                assertEquals(1, v2 - v1);
            }
            lastSize = size;
        }

        t.join();
    }",maybe_loop_control
i,"for (int i = 0; i < 1000000; i++) {
                    rs.onNext(i);
                }",loop_control
i,"for (int i = 0; i < values.length - 1; i++) {
                Integer v1 = (Integer)values[i];
                Integer v2 = (Integer)values[i + 1];
                assertEquals(1, v2 - v1);
            }",loop_control
rs,"{
        final ReplaySubject<Object> rs = ReplaySubject.createWithSize(3);
        final CyclicBarrier cb = new CyclicBarrier(2);

        Thread t = new Thread(new Runnable() {
            @Override
            public void run() {
                try {
                    cb.await();
                } catch (InterruptedException e) {
                    return;
                } catch (BrokenBarrierException e) {
                    return;
                }
                for (int i = 0; i < 1000000; i++) {
                    rs.onNext(i);
                }
                rs.onComplete();
                System.out.println(""Replay fill Thread finished!"");
            }
        });
        t.start();
        try {
            cb.await();
        } catch (InterruptedException e) {
            return;
        } catch (BrokenBarrierException e) {
            return;
        }
        for (; !rs.hasThrowable() && !rs.hasComplete();) {
            rs.size(); // can't use value so just call to detect hangs
            rs.hasValue(); // can't use value so just call to detect hangs
            Object[] values = rs.getValues();
            for (int i = 0; i < values.length - 1; i++) {
                Integer v1 = (Integer)values[i];
                Integer v2 = (Integer)values[i + 1];
                assertEquals(1, v2 - v1);
            }
        }

        t.join();
    }",maybe_loop_control
i,"for (int i = 0; i < 1000000; i++) {
                    rs.onNext(i);
                    if (i % 10000 == 0) {
                        try {
                            Thread.sleep(1);
                        } catch (InterruptedException e) {
                            return;
                        }
                    }
                }",loop_control
i,"for (int i = 0; i < values.length - 1; i++) {
                Integer v1 = (Integer)values[i];
                Integer v2 = (Integer)values[i + 1];
                assertEquals(1, v2 - v1);
            }",loop_control
rs,"{
        final ReplaySubject<Object> rs = ReplaySubject.createWithTime(1, TimeUnit.MILLISECONDS, Schedulers.computation());
        final CyclicBarrier cb = new CyclicBarrier(2);

        Thread t = new Thread(new Runnable() {
            @Override
            public void run() {
                try {
                    cb.await();
                } catch (InterruptedException e) {
                    return;
                } catch (BrokenBarrierException e) {
                    return;
                }
                for (int i = 0; i < 1000000; i++) {
                    rs.onNext(i);
                    if (i % 10000 == 0) {
                        try {
                            Thread.sleep(1);
                        } catch (InterruptedException e) {
                            return;
                        }
                    }
                }
                rs.onComplete();
                System.out.println(""Replay fill Thread finished!"");
            }
        });
        t.start();
        try {
            cb.await();
        } catch (InterruptedException e) {
            return;
        } catch (BrokenBarrierException e) {
            return;
        }
        for (; !rs.hasThrowable() && !rs.hasComplete();) {
            rs.size(); // can't use value so just call to detect hangs
            rs.hasValue(); // can't use value so just call to detect hangs
            Object[] values = rs.getValues();
            for (int i = 0; i < values.length - 1; i++) {
                Integer v1 = (Integer)values[i];
                Integer v2 = (Integer)values[i + 1];
                assertEquals(1, v2 - v1);
            }
        }

        t.join();
    }",maybe_loop_control
l,"for (long l = 1; l <= 10000; l++) {
                            o.onNext(l);
                        }",loop_control
l,"for (long l = 1; l <= 10000; l++) {
                            o.onNext(l);
                        }",loop_control
l,"for (long l : values) {
                v += l;
            }",loop_control
l,"for (long l : sums) {
            if (l != expected) {
                success = false;
                System.out.println(""FAILURE => Expected "" + expected + "" but got: "" + l);
            }
        }",loop_control
i,"for (int i = 1; i <= 200; i++) {
            final int count = i;
            if (count == 20) {
                // start source data after we have some already subscribed
                // and while others are in process of subscribing
                source.start();
            }
            if (count == 100) {
                // wait for source to finish then keep adding after it's done
                source.join();
            }
            Thread t = new Thread(new Runnable() {

                @Override
                public void run() {
                    List<Long> values = replay.toList().blockingGet();
                    listOfListsOfValues.add(values);
                    System.out.println(""Finished thread: "" + count);
                }
            });
            t.start();
            System.out.println(""Started thread: "" + i);
            threads.add(t);
        }",loop_control
t,"for (int i = 1; i <= 200; i++) {
            final int count = i;
            if (count == 20) {
                // start source data after we have some already subscribed
                // and while others are in process of subscribing
                source.start();
            }
            if (count == 100) {
                // wait for source to finish then keep adding after it's done
                source.join();
            }
            Thread t = new Thread(new Runnable() {

                @Override
                public void run() {
                    List<Long> values = replay.toList().blockingGet();
                    listOfListsOfValues.add(values);
                    System.out.println(""Finished thread: "" + count);
                }
            });
            t.start();
            System.out.println(""Started thread: "" + i);
            threads.add(t);
        }",iterator
t,"for (Thread t : threads) {
            t.join();
        }",iterator
i,"for (int i = 0; i < 50; i++) {
            final ReplaySubject<String> subject = ReplaySubject.create();
            final AtomicReference<String> value1 = new AtomicReference<>();

            subject.subscribe(new Consumer<String>() {

                @Override
                public void accept(String t1) {
                    try {
                        // simulate a slow observer
                        Thread.sleep(50);
                    } catch (InterruptedException e) {
                        e.printStackTrace();
                    }
                    value1.set(t1);
                }

            });

            Thread t1 = new Thread(new Runnable() {

                @Override
                public void run() {
                    subject.onNext(""value"");
                    subject.onComplete();
                }
            });

            SubjectObserverThread t2 = new SubjectObserverThread(subject);
            SubjectObserverThread t3 = new SubjectObserverThread(subject);
            SubjectObserverThread t4 = new SubjectObserverThread(subject);
            SubjectObserverThread t5 = new SubjectObserverThread(subject);

            t2.start();
            t3.start();
            t1.start();
            t4.start();
            t5.start();
            try {
                t1.join();
                t2.join();
                t3.join();
                t4.join();
                t5.join();
            } catch (InterruptedException e) {
                throw new RuntimeException(e);
            }

            assertEquals(""value"", value1.get());
            assertEquals(""value"", t2.value.get());
            assertEquals(""value"", t3.value.get());
            assertEquals(""value"", t4.value.get());
            assertEquals(""value"", t5.value.get());
        }",loop_control
i,"for (int i = 0; i < 100000; i++) {
            TestObserverEx<Integer> to = new TestObserverEx<>();
            Observable.just(1).subscribeOn(Schedulers.computation()).cache().subscribe(to);
            to.awaitDone(5, TimeUnit.SECONDS);
            to.assertValueSequence(expected);
            to.assertTerminated();
        }",loop_control
i,"for (int i = 0; i < 50000; i++) {
                if (i % 1000 == 0) {
                    System.out.println(i);
                }
                final ReplaySubject<Object> rs = ReplaySubject.create();

                final CountDownLatch finish = new CountDownLatch(1);
                final CountDownLatch start = new CountDownLatch(1);

                worker.schedule(new Runnable() {
                    @Override
                    public void run() {
                        try {
                            start.await();
                        } catch (Exception e1) {
                            e1.printStackTrace();
                        }
                        rs.onNext(1);
                    }
                });

                final AtomicReference<Object> o = new AtomicReference<>();

                rs.subscribeOn(s).observeOn(Schedulers.io())
                .subscribe(new DefaultObserver<Object>() {

                    @Override
                    public void onComplete() {
                        o.set(-1);
                        finish.countDown();
                    }

                    @Override
                    public void onError(Throwable e) {
                        o.set(e);
                        finish.countDown();
                    }

                    @Override
                    public void onNext(Object t) {
                        o.set(t);
                        finish.countDown();
                    }

                });
                start.countDown();

                if (!finish.await(5, TimeUnit.SECONDS)) {
                    System.out.println(o.get());
                    System.out.println(rs.hasObservers());
                    rs.onComplete();
                    Assert.fail(""Timeout @ "" + i);
                    break;
                } else {
                    Assert.assertEquals(1, o.get());
                    worker.schedule(new Runnable() {
                        @Override
                        public void run() {
                            rs.onComplete();
                        }
                    });

                }
            }",loop_control
finish,"for (int i = 0; i < 50000; i++) {
                if (i % 1000 == 0) {
                    System.out.println(i);
                }
                final ReplaySubject<Object> rs = ReplaySubject.create();

                final CountDownLatch finish = new CountDownLatch(1);
                final CountDownLatch start = new CountDownLatch(1);

                worker.schedule(new Runnable() {
                    @Override
                    public void run() {
                        try {
                            start.await();
                        } catch (Exception e1) {
                            e1.printStackTrace();
                        }
                        rs.onNext(1);
                    }
                });

                final AtomicReference<Object> o = new AtomicReference<>();

                rs.subscribeOn(s).observeOn(Schedulers.io())
                .subscribe(new DefaultObserver<Object>() {

                    @Override
                    public void onComplete() {
                        o.set(-1);
                        finish.countDown();
                    }

                    @Override
                    public void onError(Throwable e) {
                        o.set(e);
                        finish.countDown();
                    }

                    @Override
                    public void onNext(Object t) {
                        o.set(t);
                        finish.countDown();
                    }

                });
                start.countDown();

                if (!finish.await(5, TimeUnit.SECONDS)) {
                    System.out.println(o.get());
                    System.out.println(rs.hasObservers());
                    rs.onComplete();
                    Assert.fail(""Timeout @ "" + i);
                    break;
                } else {
                    Assert.assertEquals(1, o.get());
                    worker.schedule(new Runnable() {
                        @Override
                        public void run() {
                            rs.onComplete();
                        }
                    });

                }
            }",break_loop_control
i,"for (int i = 0; i < 1000000; i++) {
                    rs.onNext(i);
                }",loop_control
rs,"{
        final ReplaySubject<Object> rs = ReplaySubject.create();
        final CyclicBarrier cb = new CyclicBarrier(2);

        Thread t = new Thread(new Runnable() {
            @Override
            public void run() {
                try {
                    cb.await();
                } catch (InterruptedException e) {
                    return;
                } catch (BrokenBarrierException e) {
                    return;
                }
                for (int i = 0; i < 1000000; i++) {
                    rs.onNext(i);
                }
                rs.onComplete();
                System.out.println(""Replay fill Thread finished!"");
            }
        });
        t.start();
        try {
            cb.await();
        } catch (InterruptedException e) {
            return;
        } catch (BrokenBarrierException e) {
            return;
        }
        int lastSize = 0;
        for (; !rs.hasThrowable() && !rs.hasComplete();) {
            int size = rs.size();
            boolean hasAny = rs.hasValue();
            Object[] values = rs.getValues();
            if (size < lastSize) {
                Assert.fail(""Size decreased! "" + lastSize + "" -> "" + size);
            }
            if ((size > 0) && !hasAny) {
                Assert.fail(""hasAnyValue reports emptyness but size doesn't"");
            }
            if (size > values.length) {
                Assert.fail(""Got fewer values than size! "" + size + "" -> "" + values.length);
            }
            lastSize = size;
        }

        t.join();
    }",maybe_loop_control
i,"for (int i = 0; i < 10; i++) {
            final Observer<Object> o = TestHelper.mockObserver();
            InOrder inOrder = inOrder(o);
            String v = """" + i;
            src.onNext(v);
            System.out.printf(""Turn: %d%n"", i);
            src.firstElement()
                .toObservable()
                .flatMap(new Function<String, Observable<String>>() {

                    @Override
                    public Observable<String> apply(String t1) {
                        return Observable.just(t1 + "", "" + t1);
                    }
                })
                .subscribe(new DefaultObserver<String>() {
                    @Override
                    public void onNext(String t) {
                        o.onNext(t);
                    }

                    @Override
                    public void onError(Throwable e) {
                        o.onError(e);
                    }

                    @Override
                    public void onComplete() {
                        o.onComplete();
                    }
                });
            inOrder.verify(o).onNext(v + "", "" + v);
            inOrder.verify(o).onComplete();
            verify(o, never()).onError(any(Throwable.class));
        }",loop_control
i,"for (int i = 0; i < 50000; i++) {
                if (i % 1000 == 0) {
                    System.out.println(i);
                }
                final BehaviorSubject<Object> rs = BehaviorSubject.create();

                final CountDownLatch finish = new CountDownLatch(1);
                final CountDownLatch start = new CountDownLatch(1);

                worker.schedule(new Runnable() {
                    @Override
                    public void run() {
                        try {
                            start.await();
                        } catch (Exception e1) {
                            e1.printStackTrace();
                        }
                        rs.onNext(1);
                    }
                });

                final AtomicReference<Object> o = new AtomicReference<>();

                rs.subscribeOn(s).observeOn(Schedulers.io())
                .subscribe(new DefaultObserver<Object>() {

                    @Override
                    public void onComplete() {
                        o.set(-1);
                        finish.countDown();
                    }

                    @Override
                    public void onError(Throwable e) {
                        o.set(e);
                        finish.countDown();
                    }

                    @Override
                    public void onNext(Object t) {
                        o.set(t);
                        finish.countDown();
                    }

                });
                start.countDown();

                if (!finish.await(5, TimeUnit.SECONDS)) {
                    System.out.println(o.get());
                    System.out.println(rs.hasObservers());
                    rs.onComplete();
                    Assert.fail(""Timeout @ "" + i);
                    break;
                } else {
                    Assert.assertEquals(1, o.get());
                    worker.schedule(new Runnable() {
                        @Override
                        public void run() {
                            rs.onComplete();
                        }
                    });
                }
            }",loop_control
finish,"for (int i = 0; i < 50000; i++) {
                if (i % 1000 == 0) {
                    System.out.println(i);
                }
                final BehaviorSubject<Object> rs = BehaviorSubject.create();

                final CountDownLatch finish = new CountDownLatch(1);
                final CountDownLatch start = new CountDownLatch(1);

                worker.schedule(new Runnable() {
                    @Override
                    public void run() {
                        try {
                            start.await();
                        } catch (Exception e1) {
                            e1.printStackTrace();
                        }
                        rs.onNext(1);
                    }
                });

                final AtomicReference<Object> o = new AtomicReference<>();

                rs.subscribeOn(s).observeOn(Schedulers.io())
                .subscribe(new DefaultObserver<Object>() {

                    @Override
                    public void onComplete() {
                        o.set(-1);
                        finish.countDown();
                    }

                    @Override
                    public void onError(Throwable e) {
                        o.set(e);
                        finish.countDown();
                    }

                    @Override
                    public void onNext(Object t) {
                        o.set(t);
                        finish.countDown();
                    }

                });
                start.countDown();

                if (!finish.await(5, TimeUnit.SECONDS)) {
                    System.out.println(o.get());
                    System.out.println(rs.hasObservers());
                    rs.onComplete();
                    Assert.fail(""Timeout @ "" + i);
                    break;
                } else {
                    Assert.assertEquals(1, o.get());
                    worker.schedule(new Runnable() {
                        @Override
                        public void run() {
                            rs.onComplete();
                        }
                    });
                }
            }",break_loop_control
i,"for (int i = 0; i < TestHelper.RACE_DEFAULT_LOOPS; i++) {
            final BehaviorSubject<Object> p = BehaviorSubject.create();

            final TestObserver<Object> to = p.test();

            Runnable r1 = new Runnable() {
                @Override
                public void run() {
                    p.test();
                }
            };

            Runnable r2 = new Runnable() {
                @Override
                public void run() {
                    to.dispose();
                }
            };

            TestHelper.race(r1, r2);
        }",loop_control
i,"for (int i = 0; i < TestHelper.RACE_DEFAULT_LOOPS; i++) {
            final BehaviorSubject<Object> p = BehaviorSubject.createDefault((Object)1);

            final TestObserver[] to = { null };

            Runnable r1 = new Runnable() {
                @Override
                public void run() {
                    to[0] = p.test();
                }
            };

            Runnable r2 = new Runnable() {
                @Override
                public void run() {
                    p.onNext(2);
                }
            };

            TestHelper.race(r1, r2);

            if (to[0].values().size() == 1) {
                to[0].assertValue(2).assertNoErrors().assertNotComplete();
            } else {
                to[0].assertValues(1, 2).assertNoErrors().assertNotComplete();
            }
        }",loop_control
i,"for (int i = 0; i < TestHelper.RACE_DEFAULT_LOOPS; i++) {
            final BehaviorSubject<Object> p = BehaviorSubject.create();

            final TestObserver<Object> to = new TestObserver<>();

            Runnable r1 = new Runnable() {
                @Override
                public void run() {
                    p.subscribe(to);
                }
            };

            Runnable r2 = new Runnable() {
                @Override
                public void run() {
                    p.onComplete();
                }
            };

            TestHelper.race(r1, r2);

            to.assertResult();
        }",loop_control
i,"for (int i = 0; i < TestHelper.RACE_DEFAULT_LOOPS; i++) {
            final BehaviorSubject<Object> p = BehaviorSubject.create();

            final TestObserver<Object> to = new TestObserver<>();

            final TestException ex = new TestException();

            Runnable r1 = new Runnable() {
                @Override
                public void run() {
                    p.subscribe(to);
                }
            };

            Runnable r2 = new Runnable() {
                @Override
                public void run() {
                    p.onError(ex);
                }
            };

            TestHelper.race(r1, r2);

            to.assertFailure(TestException.class);
        }",loop_control
i,"for (int i = 0; i < TestHelper.RACE_LONG_LOOPS; i++) {

            BehaviorSubject<Integer> bs = BehaviorSubject.create();
            bs.onNext(1);

            TestObserver<Integer> to = new TestObserver<>();

            final BehaviorDisposable<Integer> bd = new BehaviorDisposable<>(to, bs);
            to.onSubscribe(bd);

            Runnable r1 = new Runnable() {
                @Override
                public void run() {
                    bd.emitFirst();
                }
            };
            Runnable r2 = new Runnable() {
                @Override
                public void run() {
                    bd.dispose();
                }
            };

            TestHelper.race(r1, r2);
        }",loop_control
i,"for (int i = 0; i < TestHelper.RACE_LONG_LOOPS; i++) {

            BehaviorSubject<Integer> bs = BehaviorSubject.create();
            bs.onNext(1);

            TestObserver<Integer> to = new TestObserver<>();

            final BehaviorDisposable<Integer> bd = new BehaviorDisposable<>(to, bs);
            to.onSubscribe(bd);

            Runnable r1 = new Runnable() {
                @Override
                public void run() {
                    bd.emitNext(2, 0);
                }
            };
            Runnable r2 = new Runnable() {
                @Override
                public void run() {
                    bd.dispose();
                }
            };

            TestHelper.race(r1, r2);
        }",loop_control
i,"for (int i = 0; i < TestHelper.RACE_DEFAULT_LOOPS; i++) {
            final SingleSubject<Integer> ss = SingleSubject.create();

            final TestObserver<Integer> to = ss.test();

            Runnable r1 = new Runnable() {
                @Override
                public void run() {
                    ss.test();
                }
            };

            Runnable r2 = new Runnable() {
                @Override
                public void run() {
                    to.dispose();
                }
            };
            TestHelper.race(r1, r2);
        }",loop_control
i,"for (int i = 0; i < TestHelper.RACE_DEFAULT_LOOPS; i++) {
            final int[] calls = { 0 };
            final UnicastSubject<Object> us = UnicastSubject.create(100, new Runnable() {
                @Override
                public void run() {
                    calls[0]++;
                }
            });

            final TestObserver<Object> to = us.test();

            Runnable r1 = new Runnable() {
                @Override
                public void run() {
                    to.dispose();
                }
            };

            Runnable r2 = new Runnable() {
                @Override
                public void run() {
                    us.onComplete();
                }
            };

            TestHelper.race(r1, r2);

            assertEquals(1, calls[0]);
        }",loop_control
i,"for (int i = 0; i < TestHelper.RACE_DEFAULT_LOOPS; i++) {
            final UnicastSubject<Object> p = UnicastSubject.create();

            final TestObserverEx<Object> to = new TestObserverEx<>(QueueFuseable.ANY);

            p.subscribe(to);

            Runnable r1 = new Runnable() {
                @Override
                public void run() {
                    p.onNext(1);
                }
            };

            Runnable r2 = new Runnable() {
                @Override
                public void run() {
                    to.dispose();
                }
            };

            TestHelper.race(r1, r2);
        }",loop_control
i,"for (int i = 0; i < TestHelper.RACE_DEFAULT_LOOPS; i++) {
            final UnicastSubject<Integer> us = UnicastSubject.create();

            final TestObserverEx<Integer> to1 = new TestObserverEx<>();
            final TestObserverEx<Integer> to2 = new TestObserverEx<>();

            Runnable r1 = new Runnable() {
                @Override
                public void run() {
                    us.subscribe(to1);
                }
            };

            Runnable r2 = new Runnable() {
                @Override
                public void run() {
                    us.subscribe(to2);
                }
            };

            TestHelper.race(r1, r2);

            if (to1.errors().size() == 0) {
                to2.assertFailure(IllegalStateException.class);
            } else
            if (to2.errors().size() == 0) {
                to1.assertFailure(IllegalStateException.class);
            } else {
                fail(""Neither TestObserver failed"");
            }
        }",loop_control
j,"for (int j = 0; j < TestHelper.RACE_LONG_LOOPS; j++) {
            List<Throwable> errors = TestHelper.trackPluginErrors();
            try {
                final UnicastSubject<Integer> us = UnicastSubject.create();

                TestObserver<Integer> to = us
                .observeOn(Schedulers.io())
                .map(Functions.<Integer>identity())
                .observeOn(Schedulers.single())
                .firstOrError()
                .test();

                for (int i = 0; us.hasObservers(); i++) {
                    us.onNext(i);
                }

                to.awaitDone(10, TimeUnit.SECONDS);

                if (!errors.isEmpty()) {
                    throw new CompositeException(errors);
                }

                to.assertResult(0);
            } finally {
                RxJavaPlugins.reset();
            }
        }",loop_control
i,"for (int i = 0; us.hasObservers(); i++) {
                    us.onNext(i);
                }",loop_control
i,"for (int i = 0; i < 256; i++) {
            us.onNext(i);
        }",loop_control
i,"for (int i = 0; i < TestHelper.RACE_DEFAULT_LOOPS; i++) {
            final CompletableSubject cs = CompletableSubject.create();

            final TestObserver<Void> to = cs.test();

            Runnable r1 = new Runnable() {
                @Override
                public void run() {
                    cs.test();
                }
            };

            Runnable r2 = new Runnable() {
                @Override
                public void run() {
                    to.dispose();
                }
            };
            TestHelper.race(r1, r2);
        }",loop_control
pp,"{
        final ReplayProcessor<Integer> pp = ReplayProcessor.createWithTime(1, TimeUnit.MINUTES, Schedulers.computation());

        Schedulers.io().scheduleDirect(new Runnable() {
            @Override
            public void run() {
                long start = System.currentTimeMillis();
                while (!pp.hasSubscribers()) {
                    try {
                        Thread.sleep(1);
                    } catch (InterruptedException ex) {
                        return;
                    }

                    if (System.currentTimeMillis() - start > 200) {
                        return;
                    }
                }

                for (int i = 0; i < elements; i++) {
                    pp.onNext(i);
                }
                pp.onComplete();
            }
        });
        return pp;
    }",maybe_loop_control
i,"for (int i = 0; i < elements; i++) {
                    pp.onNext(i);
                }",loop_control
i,"for (int i = 0; i < elements; i++) {
                    pp.onNext(i);
                }",loop_control
pp,"{
        final AsyncProcessor<Integer> pp = AsyncProcessor.create();

        Schedulers.io().scheduleDirect(new Runnable() {
            @Override
            public void run() {
                long start = System.currentTimeMillis();
                while (!pp.hasSubscribers()) {
                    try {
                        Thread.sleep(1);
                    } catch (InterruptedException ex) {
                        return;
                    }

                    if (System.currentTimeMillis() - start > 200) {
                        return;
                    }
                }

                for (int i = 0; i < elements; i++) {
                    pp.onNext(i);
                }
                pp.onComplete();
            }
        });
        return pp;
    }",maybe_loop_control
i,"for (int i = 0; i < elements; i++) {
                    while (!mp.offer(i)) {
                        Thread.yield();
                        if (System.currentTimeMillis() - start > 1000) {
                            return;
                        }
                    }
                }",loop_control
mp,"{
        final MulticastProcessor<Integer> mp = MulticastProcessor.create();
        mp.start();

        Schedulers.io().scheduleDirect(new Runnable() {
            @Override
            public void run() {
                long start = System.currentTimeMillis();
                while (!mp.hasSubscribers()) {
                    try {
                        Thread.sleep(1);
                    } catch (InterruptedException ex) {
                        return;
                    }

                    if (System.currentTimeMillis() - start > 200) {
                        return;
                    }
                }

                for (int i = 0; i < elements; i++) {
                    while (!mp.offer(i)) {
                        Thread.yield();
                        if (System.currentTimeMillis() - start > 1000) {
                            return;
                        }
                    }
                }
                mp.onComplete();
            }
        });
        return mp;
    }",maybe_loop_control
i,"for (int i = 0; i < elements; i++) {
                    while (!pp.offer(i)) {
                        Thread.yield();
                        if (System.currentTimeMillis() - start > 1000) {
                            return;
                        }
                    }
                }",loop_control
pp,"{
        final BehaviorProcessor<Integer> pp = BehaviorProcessor.create();

        Schedulers.io().scheduleDirect(new Runnable() {
            @Override
            public void run() {
                long start = System.currentTimeMillis();
                while (!pp.hasSubscribers()) {
                    try {
                        Thread.sleep(1);
                    } catch (InterruptedException ex) {
                        return;
                    }

                    if (System.currentTimeMillis() - start > 200) {
                        return;
                    }
                }

                for (int i = 0; i < elements; i++) {
                    while (!pp.offer(i)) {
                        Thread.yield();
                        if (System.currentTimeMillis() - start > 1000) {
                            return;
                        }
                    }
                }
                pp.onComplete();
            }
        });
        return pp;
    }",maybe_loop_control
i,"for (int i = 0; i < elements; i++) {
                    pp.onNext(i);
                }",loop_control
pp,"{
        final ReplayProcessor<Integer> pp = ReplayProcessor.createWithSize((int)elements + 10);

        Schedulers.io().scheduleDirect(new Runnable() {
            @Override
            public void run() {
                long start = System.currentTimeMillis();
                while (!pp.hasSubscribers()) {
                    try {
                        Thread.sleep(1);
                    } catch (InterruptedException ex) {
                        return;
                    }

                    if (System.currentTimeMillis() - start > 200) {
                        return;
                    }
                }

                for (int i = 0; i < elements; i++) {
                    pp.onNext(i);
                }
                pp.onComplete();
            }
        });
        return pp;
    }",maybe_loop_control
a,"for (;;) {
            RefCountSubscriber<T>[] a = subscribers.get();
            if (a == TERMINATED) {
                return false;
            }
            int n = a.length;
            @SuppressWarnings(""unchecked"")
            RefCountSubscriber<T>[] b = new RefCountSubscriber[n + 1];
            System.arraycopy(a, 0, b, 0, n);
            b[n] = rcs;
            if (subscribers.compareAndSet(a, b)) {
                return true;
            }
        }",break_loop_control
subscribers,"for (;;) {
            RefCountSubscriber<T>[] a = subscribers.get();
            if (a == TERMINATED) {
                return false;
            }
            int n = a.length;
            @SuppressWarnings(""unchecked"")
            RefCountSubscriber<T>[] b = new RefCountSubscriber[n + 1];
            System.arraycopy(a, 0, b, 0, n);
            b[n] = rcs;
            if (subscribers.compareAndSet(a, b)) {
                return true;
            }
        }",break_loop_control
n,"for (;;) {
            RefCountSubscriber<T>[] a = subscribers.get();
            int n = a.length;
            if (n == 0) {
                break;
            }
            int j = -1;

            for (int i = 0; i < n; i++) {
                if (rcs == a[i]) {
                    j = i;
                    break;
                }
            }

            if (j < 0) {
                break;
            }

            RefCountSubscriber<T>[] b;
            if (n == 1) {
                b = TERMINATED;
            } else {
                b = new RefCountSubscriber[n - 1];
                System.arraycopy(a, 0, b, 0, j);
                System.arraycopy(a, j + 1, b, j, n - j - 1);
            }
            if (subscribers.compareAndSet(a, b)) {
                if (b == TERMINATED) {
                    cancel();
                }
                break;
            }
        }",break_loop_control
i,"for (int i = 0; i < n; i++) {
                if (rcs == a[i]) {
                    j = i;
                    break;
                }
            }",loop_control
rcs,"for (int i = 0; i < n; i++) {
                if (rcs == a[i]) {
                    j = i;
                    break;
                }
            }",break_loop_control
j,"for (;;) {
            RefCountSubscriber<T>[] a = subscribers.get();
            int n = a.length;
            if (n == 0) {
                break;
            }
            int j = -1;

            for (int i = 0; i < n; i++) {
                if (rcs == a[i]) {
                    j = i;
                    break;
                }
            }

            if (j < 0) {
                break;
            }

            RefCountSubscriber<T>[] b;
            if (n == 1) {
                b = TERMINATED;
            } else {
                b = new RefCountSubscriber[n - 1];
                System.arraycopy(a, 0, b, 0, j);
                System.arraycopy(a, j + 1, b, j, n - j - 1);
            }
            if (subscribers.compareAndSet(a, b)) {
                if (b == TERMINATED) {
                    cancel();
                }
                break;
            }
        }",break_loop_control
subscribers,"for (;;) {
            RefCountSubscriber<T>[] a = subscribers.get();
            int n = a.length;
            if (n == 0) {
                break;
            }
            int j = -1;

            for (int i = 0; i < n; i++) {
                if (rcs == a[i]) {
                    j = i;
                    break;
                }
            }

            if (j < 0) {
                break;
            }

            RefCountSubscriber<T>[] b;
            if (n == 1) {
                b = TERMINATED;
            } else {
                b = new RefCountSubscriber[n - 1];
                System.arraycopy(a, 0, b, 0, j);
                System.arraycopy(a, j + 1, b, j, n - j - 1);
            }
            if (subscribers.compareAndSet(a, b)) {
                if (b == TERMINATED) {
                    cancel();
                }
                break;
            }
        }",break_loop_control
i,"for (int i = 0; i < elements; i++) {
            a[i] = (long)i;
        }",loop_control
i,"for (long i = 0; i < elements && !e.isCancelled(); i++) {
                        e.onNext(i);
                    }",loop_control
e,"{
                @Override
                public void subscribe(FlowableEmitter<Long> e) throws Exception {
                    for (long i = 0; i < elements && !e.isCancelled(); i++) {
                        e.onNext(i);
                    }
                    e.onComplete();
                }
            }",maybe_loop_control
pp,"{
        final PublishProcessor<Integer> pp = PublishProcessor.create();

        Schedulers.io().scheduleDirect(new Runnable() {
            @Override
            public void run() {
                long start = System.currentTimeMillis();
                while (!pp.hasSubscribers()) {
                    try {
                        Thread.sleep(1);
                    } catch (InterruptedException ex) {
                        return;
                    }

                    if (System.currentTimeMillis() - start > 200) {
                        return;
                    }
                }

                for (int i = 0; i < elements; i++) {
                    while (!pp.offer(i)) {
                        Thread.yield();
                        if (System.currentTimeMillis() - start > 1000) {
                            return;
                        }
                    }
                }
                pp.onComplete();
            }
        });
        return pp;
    }",maybe_loop_control
i,"for (int i = 0; i < elements; i++) {
                    while (!pp.offer(i)) {
                        Thread.yield();
                        if (System.currentTimeMillis() - start > 1000) {
                            return;
                        }
                    }
                }",loop_control
i,"for (int i = 0; i < elements; i++) {
                    pp.onNext(i);
                }",loop_control
pp,"{
        final UnicastProcessor<Integer> pp = UnicastProcessor.create();

        Schedulers.io().scheduleDirect(new Runnable() {
            @Override
            public void run() {
                long start = System.currentTimeMillis();
                while (!pp.hasSubscribers()) {
                    try {
                        Thread.sleep(1);
                    } catch (InterruptedException ex) {
                        return;
                    }

                    if (System.currentTimeMillis() - start > 200) {
                        return;
                    }
                }

                for (int i = 0; i < elements; i++) {
                    pp.onNext(i);
                }
                pp.onComplete();
            }
        });
        return pp;
    }",maybe_loop_control
pp,"{
        final ReplayProcessor<Integer> pp = ReplayProcessor.create();

        Schedulers.io().scheduleDirect(new Runnable() {
            @Override
            public void run() {
                long start = System.currentTimeMillis();
                while (!pp.hasSubscribers()) {
                    try {
                        Thread.sleep(1);
                    } catch (InterruptedException ex) {
                        return;
                    }

                    if (System.currentTimeMillis() - start > 200) {
                        return;
                    }
                }

                for (int i = 0; i < elements; i++) {
                    pp.onNext(i);
                }
                pp.onComplete();
            }
        });
        return pp;
    }",maybe_loop_control
i,"for (int i = 0; i < elements; i++) {
                    pp.onNext(i);
                }",loop_control
old,"for (@SuppressWarnings(""unused"") Movie old : oldList) {
                    delta.add(new Movie());
                }",iterator
i,"for (int i = 0; i < 500; i++) {
            if (i % 10 == 0) {
                System.out.println(""testMergeAsyncThenObserveOnLoop >> "" + i);
            }
            // Verify there is no MissingBackpressureException
            int num = (int) (Flowable.bufferSize() * 4.1);
            AtomicInteger c1 = new AtomicInteger();
            AtomicInteger c2 = new AtomicInteger();

            TestSubscriber<Integer> ts = new TestSubscriber<>();
            Flowable<Integer> merged = Flowable.merge(
                    incrementingIntegers(c1).subscribeOn(Schedulers.computation()),
                    incrementingIntegers(c2).subscribeOn(Schedulers.computation()));

            merged
            .observeOn(Schedulers.io())
            .take(num)
            .subscribe(ts);

            ts.awaitDone(5, TimeUnit.SECONDS);
            ts.assertComplete();
            ts.assertNoErrors();
            System.out.println(""testMergeAsyncThenObserveOn => Received: "" + ts.values().size() + ""  Emitted: "" + c1.get() + "" / "" + c2.get());
            assertEquals(num, ts.values().size());
        }",loop_control
i,"for (int i = 0; i < 100; i++) {
            int num = (int) (Flowable.bufferSize() * 2.1);
            AtomicInteger c = new AtomicInteger();
            ConcurrentLinkedQueue<Thread> threads = new ConcurrentLinkedQueue<>();
            TestSubscriber<Integer> ts = new TestSubscriber<>();
            // observeOn is there to make it async and need backpressure
            incrementingIntegers(c, threads).subscribeOn(Schedulers.computation()).observeOn(Schedulers.computation()).take(num).subscribe(ts);
            ts.awaitDone(5, TimeUnit.SECONDS);
            ts.assertNoErrors();
            System.out.println(""testSubscribeOnScheduling => Received: "" + ts.values().size() + ""  Emitted: "" + c.get());
            assertEquals(num, ts.values().size());
            assertTrue(c.get() < Flowable.bufferSize() * 4);
            Thread first = null;
            for (Thread t : threads) {
                System.out.println(""testSubscribeOnScheduling => thread: "" + t);
                if (first == null) {
                    first = t;
                } else {
                    if (!first.equals(t)) {
                        fail(""Expected to see the same thread"");
                    }
                }
            }
            System.out.println(""testSubscribeOnScheduling => Number of batch requests seen: "" + threads.size());
            assertTrue(threads.size() > 1);
            System.out.println(""-------------------------------------------------------------------------------------------"");
        }",loop_control
t,"for (Thread t : threads) {
                System.out.println(""testSubscribeOnScheduling => thread: "" + t);
                if (first == null) {
                    first = t;
                } else {
                    if (!first.equals(t)) {
                        fail(""Expected to see the same thread"");
                    }
                }
            }",iterator
i,"for (int i = 0; i < 100; i++) {
            firehoseFailsAsExpected();
        }",loop_control
i,"for (int i = 0; i < 100; i++) {
            // stop the test if we are getting close to the timeout because slow machines
            // may not get through 100 iterations
            if (System.currentTimeMillis() - t > TimeUnit.SECONDS.toMillis(9)) {
                break;
            }
            int num = (int) (Flowable.bufferSize() * 1.1); // > 1 so that take doesn't prevent buffer overflow
            AtomicInteger c = new AtomicInteger();
            TestSubscriber<Integer> ts = new TestSubscriber<>();
            firehose(c).onBackpressureDrop()
            .observeOn(Schedulers.computation())
            .map(SLOW_PASS_THRU).take(num).subscribe(ts);
            ts.awaitDone(5, TimeUnit.SECONDS);
            ts.assertNoErrors();

            List<Integer> onNextEvents = ts.values();
            assertEquals(num, onNextEvents.size());

            Integer lastEvent = onNextEvents.get(num - 1);

            System.out.println(""testOnBackpressureDrop => Received: "" + onNextEvents.size() + ""  Emitted: "" + c.get() + "" Last value: "" + lastEvent);
            // it drop, so we should get some number far higher than what would have sequentially incremented
            assertTrue(num - 1 <= lastEvent.intValue());
        }",loop_control
i,"for (int i = 0; i < 100; i++) {
            final AtomicInteger emitCount = new AtomicInteger();
            final AtomicInteger dropCount = new AtomicInteger();
            final AtomicInteger passCount = new AtomicInteger();
            final int num = Flowable.bufferSize() * 3; // > 1 so that take doesn't prevent buffer overflow
            TestSubscriber<Integer> ts = new TestSubscriber<>();

            firehose(emitCount)
            .onBackpressureDrop(new Consumer<Integer>() {
                @Override
                public void accept(Integer v) {
                    dropCount.incrementAndGet();
                }
            })
            .doOnNext(new Consumer<Integer>() {
                @Override
                public void accept(Integer v) {
                    passCount.incrementAndGet();
                }
            })
            .observeOn(Schedulers.computation())
            .map(SLOW_PASS_THRU)
            .take(num).subscribe(ts);

            ts.awaitDone(5, TimeUnit.SECONDS);
            ts.assertNoErrors();

            List<Integer> onNextEvents = ts.values();
            Integer lastEvent = onNextEvents.get(num - 1);
            System.out.println(testName.getMethodName() + "" => Received: "" + onNextEvents.size() + "" Passed: "" + passCount.get() + "" Dropped: "" + dropCount.get() + ""  Emitted: "" + emitCount.get() + "" Last value: "" + lastEvent);
            assertEquals(num, onNextEvents.size());
            // in reality, num < passCount
            assertTrue(num <= passCount.get());
            // it drop, so we should get some number far higher than what would have sequentially incremented
            assertTrue(num - 1 <= lastEvent.intValue());
            assertTrue(0 < dropCount.get());
            assertEquals(emitCount.get(), passCount.get() + dropCount.get());
        }",loop_control
i,"for (int i = 0; i < 100; i++) {
            int num = (int) (Flowable.bufferSize() * 1.1); // > 1 so that take doesn't prevent buffer overflow
            AtomicInteger c = new AtomicInteger();
            TestSubscriber<Integer> ts = new TestSubscriber<>();
            firehose(c).onBackpressureDrop()
            .map(SLOW_PASS_THRU).take(num).subscribe(ts);
            ts.awaitDone(5, TimeUnit.SECONDS);
            ts.assertNoErrors();

            List<Integer> onNextEvents = ts.values();
            assertEquals(num, onNextEvents.size());

            Integer lastEvent = onNextEvents.get(num - 1);

            System.out.println(""testOnBackpressureDrop => Received: "" + onNextEvents.size() + ""  Emitted: "" + c.get() + "" Last value: "" + lastEvent);
            // it drop, so we should get some number far higher than what would have sequentially incremented
            assertTrue(num - 1 <= lastEvent.intValue());
        }",loop_control
i,"for (int i = 0; i < 100; i++) {
            final AtomicInteger dropCount = new AtomicInteger();
            int num = (int) (Flowable.bufferSize() * 1.1); // > 1 so that take doesn't prevent buffer overflow
            AtomicInteger c = new AtomicInteger();
            TestSubscriber<Integer> ts = new TestSubscriber<>();
            firehose(c).onBackpressureDrop(new Consumer<Integer>() {
                @Override
                public void accept(Integer j) {
                    dropCount.incrementAndGet();
                }
            })
            .map(SLOW_PASS_THRU).take(num).subscribe(ts);
            ts.awaitDone(5, TimeUnit.SECONDS);
            ts.assertNoErrors();

            List<Integer> onNextEvents = ts.values();
            assertEquals(num, onNextEvents.size());

            Integer lastEvent = onNextEvents.get(num - 1);

            System.out.println(""testOnBackpressureDrop => Received: "" + onNextEvents.size() + "" Dropped: "" + dropCount.get() + ""  Emitted: "" + c.get() + "" Last value: "" + lastEvent);
            // it drop, so we should get some number far higher than what would have sequentially incremented
            assertTrue(num - 1 <= lastEvent.intValue());
            // no drop in synchronous mode
            assertEquals(0, dropCount.get());
            assertEquals(c.get(), onNextEvents.size());
        }",loop_control
cancelled,"{
                    int i;

                    volatile boolean cancelled;

                    final AtomicLong requested = new AtomicLong();

                    @Override
                    public void request(long n) {
                        if (!SubscriptionHelper.validate(n)) {
                            return;
                        }
                        if (threadsSeen != null) {
                            threadsSeen.offer(Thread.currentThread());
                        }
                        long c = BackpressureHelper.add(requested, n);
                        if (c == 0) {
                            while (!cancelled) {
                                counter.incrementAndGet();
                                s.onNext(i++);
                                if (requested.decrementAndGet() == 0) {
                                    // we're done emitting the number requested so return
                                    return;
                                }
                            }
                        }
                    }

                    @Override
                    public void cancel() {
                        cancelled = true;
                    }
                }",maybe_loop_control
requested,"{
                    int i;

                    volatile boolean cancelled;

                    final AtomicLong requested = new AtomicLong();

                    @Override
                    public void request(long n) {
                        if (!SubscriptionHelper.validate(n)) {
                            return;
                        }
                        if (threadsSeen != null) {
                            threadsSeen.offer(Thread.currentThread());
                        }
                        long c = BackpressureHelper.add(requested, n);
                        if (c == 0) {
                            while (!cancelled) {
                                counter.incrementAndGet();
                                s.onNext(i++);
                                if (requested.decrementAndGet() == 0) {
                                    // we're done emitting the number requested so return
                                    return;
                                }
                            }
                        }
                    }

                    @Override
                    public void cancel() {
                        cancelled = true;
                    }
                }",break_loop_control
i,"for (int i = 2000; i >= 0; i--) {
                t = String.valueOf(i + t.hashCode() + s);
            }",loop_control
isFinished,"{
        final AtomicReference<Throwable> thrown = new AtomicReference<>(null);
        final AtomicBoolean isFinished = new AtomicBoolean(false);
        ConcurrentLinkedQueue<? extends Integer> queue = Flowable.range(0, 5)
                .flatMap(new Function<Integer, Publisher<Integer>>() {
                    @Override
                    public Publisher<Integer> apply(final Integer i) {
                        return Flowable.range(0, 5)
                                .observeOn(Schedulers.io())
                                .map(new Function<Integer, Integer>() {
                                    @Override
                                    public Integer apply(Integer k) {
                                        try {
                                            Thread.sleep(System.currentTimeMillis() % 100);
                                        } catch (InterruptedException e) {
                                            e.printStackTrace();
                                        }
                                        return i + k;
                                    }
                                });
                    }
                })
                    .to(new FlowableConverter<Integer, ConcurrentLinkedQueue<Integer>>() {
                        @Override
                        public ConcurrentLinkedQueue<Integer> apply(Flowable<Integer> onSubscribe) {
                            final ConcurrentLinkedQueue<Integer> q = new ConcurrentLinkedQueue<>();
                            onSubscribe.subscribe(new DefaultSubscriber<Integer>() {
                                @Override
                                public void onComplete() {
                                    isFinished.set(true);
                                }

                                @Override
                                public void onError(Throwable e) {
                                    thrown.set(e);
                                }

                                @Override
                                public void onNext(Integer t) {
                                    q.add(t);
                                }});
                            return q;
                        }
                    });

        int x = 0;
        while (!isFinished.get()) {
            Integer i = queue.poll();
            if (i != null) {
                x++;
                System.out.println(x + "" item: "" + i);
            }
        }
        Assert.assertNull(thrown.get());
    }",maybe_loop_control
item,"for (T item : items) {
            if (item == null) {
                throw new IllegalArgumentException(""items cannot include null"");
            }
        }",iterator
item,"{

    final List<T> items;
    final Throwable error;

    Burst(Throwable error, List<T> items) {
        if (items.isEmpty()) {
            throw new IllegalArgumentException(""items cannot be empty"");
        }
        for (T item : items) {
            if (item == null) {
                throw new IllegalArgumentException(""items cannot include null"");
            }
        }
        this.error = error;
        this.items = items;
    }

    @Override
    protected void subscribeActual(final Subscriber<? super T> subscriber) {
        subscriber.onSubscribe(new BurstSubscription(subscriber));

    }

    public static <T> Builder<T> item(T item) {
        return items(item);
    }

    @SafeVarargs
    public static <T> Builder<T> items(T... items) {
        return new Builder<>(Arrays.asList(items));
    }

    final class BurstSubscription implements Subscription {
        private final Subscriber<? super T> subscriber;
        final Queue<T> q = new ConcurrentLinkedQueue<>(items);
        final AtomicLong requested = new AtomicLong();
        volatile boolean cancelled;

        BurstSubscription(Subscriber<? super T> subscriber) {
            this.subscriber = subscriber;
        }

        @Override
        public void request(long n) {
            if (cancelled) {
                // required by reactive-streams-jvm 3.6
                return;
            }
            if (SubscriptionHelper.validate(n)) {
                // just for testing, don't care about perf
                // so no attempt made to reduce volatile reads
                if (BackpressureHelper.add(requested, n) == 0) {
                    if (q.isEmpty()) {
                        return;
                    }
                    while (!q.isEmpty() && requested.get() > 0) {
                        T item = q.poll();
                        requested.decrementAndGet();
                        subscriber.onNext(item);
                    }
                    if (q.isEmpty()) {
                        if (error != null) {
                            subscriber.onError(error);
                        } else {
                            subscriber.onComplete();
                        }
                    }
                }
            }
        }

        @Override
        public void cancel() {
            cancelled = true;
        }
    }

    public static final class Builder<T> {

        private final List<T> items;
        private Throwable error;

        Builder(List<T> items) {
            this.items = items;
        }

        public Flowable<T> error(Throwable e) {
            this.error = e;
            return create();
        }

        public Flowable<T> create() {
            return new Burst<>(error, items);
        }

    }

}",iterator
q,"{
        private final Subscriber<? super T> subscriber;
        final Queue<T> q = new ConcurrentLinkedQueue<>(items);
        final AtomicLong requested = new AtomicLong();
        volatile boolean cancelled;

        BurstSubscription(Subscriber<? super T> subscriber) {
            this.subscriber = subscriber;
        }

        @Override
        public void request(long n) {
            if (cancelled) {
                // required by reactive-streams-jvm 3.6
                return;
            }
            if (SubscriptionHelper.validate(n)) {
                // just for testing, don't care about perf
                // so no attempt made to reduce volatile reads
                if (BackpressureHelper.add(requested, n) == 0) {
                    if (q.isEmpty()) {
                        return;
                    }
                    while (!q.isEmpty() && requested.get() > 0) {
                        T item = q.poll();
                        requested.decrementAndGet();
                        subscriber.onNext(item);
                    }
                    if (q.isEmpty()) {
                        if (error != null) {
                            subscriber.onError(error);
                        } else {
                            subscriber.onComplete();
                        }
                    }
                }
            }
        }

        @Override
        public void cancel() {
            cancelled = true;
        }
    }",maybe_loop_control
requested,"{
        private final Subscriber<? super T> subscriber;
        final Queue<T> q = new ConcurrentLinkedQueue<>(items);
        final AtomicLong requested = new AtomicLong();
        volatile boolean cancelled;

        BurstSubscription(Subscriber<? super T> subscriber) {
            this.subscriber = subscriber;
        }

        @Override
        public void request(long n) {
            if (cancelled) {
                // required by reactive-streams-jvm 3.6
                return;
            }
            if (SubscriptionHelper.validate(n)) {
                // just for testing, don't care about perf
                // so no attempt made to reduce volatile reads
                if (BackpressureHelper.add(requested, n) == 0) {
                    if (q.isEmpty()) {
                        return;
                    }
                    while (!q.isEmpty() && requested.get() > 0) {
                        T item = q.poll();
                        requested.decrementAndGet();
                        subscriber.onNext(item);
                    }
                    if (q.isEmpty()) {
                        if (error != null) {
                            subscriber.onError(error);
                        } else {
                            subscriber.onComplete();
                        }
                    }
                }
            }
        }

        @Override
        public void cancel() {
            cancelled = true;
        }
    }",maybe_loop_control
argCount,"for (int argCount = 1; argCount < 10; argCount++) {
            for (int argNull = 1; argNull <= argCount; argNull++) {
                Class<?>[] params = new Class[argCount];
                Arrays.fill(params, Object.class);

                Object[] values = new Object[argCount];
                Arrays.fill(values, 1);
                values[argNull - 1] = null;

                Method m = clazz.getMethod(""just"", params);

                try {
                    m.invoke(null, values);
                    Assert.fail(""No exception for argCount "" + argCount + "" / argNull "" + argNull);
                } catch (InvocationTargetException ex) {
                    if (!(ex.getCause() instanceof NullPointerException)) {
                        Assert.fail(""Unexpected exception for argCount "" + argCount + "" / argNull "" + argNull + "": "" + ex);
                    }
                }
            }
        }",loop_control
argNull,"for (int argNull = 1; argNull <= argCount; argNull++) {
                Class<?>[] params = new Class[argCount];
                Arrays.fill(params, Object.class);

                Object[] values = new Object[argCount];
                Arrays.fill(values, 1);
                values[argNull - 1] = null;

                Method m = clazz.getMethod(""just"", params);

                try {
                    m.invoke(null, values);
                    Assert.fail(""No exception for argCount "" + argCount + "" / argNull "" + argNull);
                } catch (InvocationTargetException ex) {
                    if (!(ex.getCause() instanceof NullPointerException)) {
                        Assert.fail(""Unexpected exception for argCount "" + argCount + "" / argNull "" + argNull + "": "" + ex);
                    }
                }
            }",loop_control
i,"for (int i = 0; i < expectedCount; i++) {
            Flowable
                    .just(Boolean.TRUE, Boolean.FALSE)
                    .takeWhile(new Predicate<Boolean>() {
                        @Override
                        public boolean test(Boolean v) {
                            return v;
                        }
                    })
                    .toList()
                    .doOnSuccess(new Consumer<List<Boolean>>() {
                        @Override
                        public void accept(List<Boolean> booleans) {
                            count.incrementAndGet();
                        }
                    })
                    .subscribe();
        }",loop_control
i,"for (Object i : o) {
                    sum += (Integer) i;
                }",iterator
i,"for (Object i : o) {
                    sum *= (Integer) i;
                }",iterator
i,"for (int i = 0; i < 10; i++) {
            final Subscriber<Object> subscriber = TestHelper.mockSubscriber();
            InOrder inOrder = inOrder(subscriber);
            String v = """" + i;
            src.onNext(v);
            System.out.printf(""Turn: %d%n"", i);
            src.firstElement().toFlowable()
                .flatMap(new Function<String, Flowable<String>>() {

                    @Override
                    public Flowable<String> apply(String t1) {
                        return Flowable.just(t1 + "", "" + t1);
                    }
                })
                .subscribe(new DefaultSubscriber<String>() {
                    @Override
                    public void onNext(String t) {
                        System.out.println(t);
                        subscriber.onNext(t);
                    }

                    @Override
                    public void onError(Throwable e) {
                        subscriber.onError(e);
                    }

                    @Override
                    public void onComplete() {
                        subscriber.onComplete();
                    }
                });
            inOrder.verify(subscriber).onNext(""0, 0"");
            inOrder.verify(subscriber).onComplete();
            verify(subscriber, never()).onError(any(Throwable.class));
        }",loop_control
i,"for (int i = 0; i < 1; i++) {
            Subscriber<Integer> subscriber = TestHelper.mockSubscriber();

            source.subscribe(subscriber);

            verify(subscriber, never()).onNext(1);
            verify(subscriber).onNext(2);
            verify(subscriber).onComplete();
            verify(subscriber, never()).onError(any(Throwable.class));
        }",loop_control
i,"for (int i = 0; i < 1000; i++) {
            rs.onNext(i);

            assertEquals(1, rs.size());
            assertTrue(rs.hasValue());
        }",loop_control
i,"for (int i = 0; i < 1000; i++) {
            rs.onNext(i);
            assertEquals(1, rs.size());
            assertTrue(rs.hasValue());
            ts.advanceTimeBy(2, TimeUnit.SECONDS);
            assertEquals(0, rs.size());
            assertFalse(rs.hasValue());
        }",loop_control
i,"for (int i = 0; i < expected.length; i++) {
            expected[i] = i;
            rs.onNext(i);
            assertArrayEquals(Arrays.copyOf(expected, i + 1), rs.getValues());
        }",loop_control
i,"for (int i = 0; i < expected.length; i++) {
            expected[i] = i;
            rs.onNext(i);
            assertArrayEquals(Arrays.copyOf(expected, i + 1), rs.getValues());
        }",loop_control
i,"for (int i = 0; i < 15; i++) {
            rp.onNext(i);
        }",loop_control
i,"for (int i = 0; i < TestHelper.RACE_DEFAULT_LOOPS; i++) {
            final TestSubscriber<Integer> ts = new TestSubscriber<>();

            final ReplayProcessor<Integer> rp = ReplayProcessor.create();

            Runnable r1 = new Runnable() {
                @Override
                public void run() {
                    rp.subscribe(ts);
                }
            };

            Runnable r2 = new Runnable() {
                @Override
                public void run() {
                    ts.cancel();
                }
            };

            TestHelper.race(r1, r2);
        }",loop_control
i,"for (int i = 0; i < TestHelper.RACE_DEFAULT_LOOPS; i++) {
            final ReplayProcessor<Integer> rp = ReplayProcessor.create();

            Runnable r1 = new Runnable() {
                @Override
                public void run() {
                    rp.test();
                }
            };

            TestHelper.race(r1, r1);
        }",loop_control
i,"for (int i = 0; i < TestHelper.RACE_DEFAULT_LOOPS; i++) {

            final ReplayProcessor<Integer> rp = ReplayProcessor.create();
            final TestSubscriber<Integer> ts1 = rp.test();
            final TestSubscriber<Integer> ts2 = rp.test();

            Runnable r1 = new Runnable() {
                @Override
                public void run() {
                    ts1.cancel();
                }
            };

            Runnable r2 = new Runnable() {
                @Override
                public void run() {
                    ts2.cancel();
                }
            };

            TestHelper.race(r1, r2);

            assertFalse(rp.hasSubscribers());
        }",loop_control
i,"for (int i = 0; i < TestHelper.RACE_DEFAULT_LOOPS; i++) {

            final ReplayProcessor<Integer> rp = ReplayProcessor.createWithTimeAndSize(1, TimeUnit.DAYS, Schedulers.single(), 2);
            final TestSubscriber<Integer> ts = rp.test(0L);

            Runnable r1 = new Runnable() {
                @Override
                public void run() {
                    ts.request(1);
                }
            };

            Runnable r2 = new Runnable() {
                @Override
                public void run() {
                    rp.onNext(1);
                }
            };

            TestHelper.race(r1, r2);
        }",loop_control
i,"for (int i = 0; i < TestHelper.RACE_LONG_LOOPS; i++) {
            final ReplayProcessor<Integer> source = ReplayProcessor.create();

            final TestSubscriber<Integer> ts = source.test(0);

            Runnable r1 = new Runnable() {
                @Override
                public void run() {
                    source.onComplete();
                }
            };

            Runnable r2 = new Runnable() {
                @Override
                public void run() {
                    ts.request(1);
                }
            };

            TestHelper.race(r1, r2);

            ts.assertResult();
        }",loop_control
i,"for (int i = 0; i < TestHelper.RACE_LONG_LOOPS; i++) {
            final ReplayProcessor<Integer> source = ReplayProcessor.createWithSize(10);

            final TestSubscriber<Integer> ts = source.test(0);

            Runnable r1 = new Runnable() {
                @Override
                public void run() {
                    source.onComplete();
                }
            };

            Runnable r2 = new Runnable() {
                @Override
                public void run() {
                    ts.request(1);
                }
            };

            TestHelper.race(r1, r2);

            ts.assertResult();
        }",loop_control
i,"for (int i = 0; i < TestHelper.RACE_LONG_LOOPS; i++) {
            final ReplayProcessor<Integer> source = ReplayProcessor.createWithTime(2, TimeUnit.HOURS, Schedulers.single());

            final TestSubscriber<Integer> ts = source.test(0);

            Runnable r1 = new Runnable() {
                @Override
                public void run() {
                    source.onComplete();
                }
            };

            Runnable r2 = new Runnable() {
                @Override
                public void run() {
                    ts.request(1);
                }
            };

            TestHelper.race(r1, r2);

            ts.assertResult();
        }",loop_control
i,"for (int i = 0; i < TestHelper.RACE_LONG_LOOPS; i++) {
            final ReplayProcessor<Integer> source = ReplayProcessor.createWithTimeAndSize(2, TimeUnit.HOURS, Schedulers.single(), 100);

            final TestSubscriber<Integer> ts = source.test(0);

            Runnable r1 = new Runnable() {
                @Override
                public void run() {
                    source.onComplete();
                }
            };

            Runnable r2 = new Runnable() {
                @Override
                public void run() {
                    ts.request(1);
                }
            };

            TestHelper.race(r1, r2);

            ts.assertResult();
        }",loop_control
i,"for (int i = 0; i < TestHelper.RACE_DEFAULT_LOOPS; i++) {
            final FlowableProcessor<Integer> s = PublishProcessor.<Integer>create().toSerialized();

            TestSubscriberEx<Integer> ts = s.to(TestHelper.<Integer>testConsumer());

            Runnable r1 = new Runnable() {
                @Override
                public void run() {
                    s.onNext(1);
                }
            };

            Runnable r2 = new Runnable() {
                @Override
                public void run() {
                    s.onNext(2);
                }
            };

            TestHelper.race(r1, r2);

            ts.assertSubscribed()
            .assertNoErrors()
            .assertNotComplete()
            .assertValueCount(2)
            ;

            Set<Integer> actualSet = new HashSet<>(ts.values());
            assertEquals("""" + actualSet, expectedSet, actualSet);
        }",loop_control
i,"for (int i = 0; i < TestHelper.RACE_DEFAULT_LOOPS; i++) {
            final FlowableProcessor<Integer> s = PublishProcessor.<Integer>create().toSerialized();

            TestSubscriber<Integer> ts = s.test();

            final TestException ex = new TestException();

            Runnable r1 = new Runnable() {
                @Override
                public void run() {
                    s.onNext(1);
                }
            };

            Runnable r2 = new Runnable() {
                @Override
                public void run() {
                    s.onError(ex);
                }
            };

            TestHelper.race(r1, r2);

            ts.assertError(ex).assertNotComplete();

            if (ts.values().size() != 0) {
                ts.assertValue(1);
            }
        }",loop_control
i,"for (int i = 0; i < TestHelper.RACE_DEFAULT_LOOPS; i++) {
            final FlowableProcessor<Integer> s = PublishProcessor.<Integer>create().toSerialized();

            TestSubscriber<Integer> ts = s.test();

            Runnable r1 = new Runnable() {
                @Override
                public void run() {
                    s.onNext(1);
                }
            };

            Runnable r2 = new Runnable() {
                @Override
                public void run() {
                    s.onComplete();
                }
            };

            TestHelper.race(r1, r2);

            ts.assertComplete().assertNoErrors();

            if (ts.values().size() != 0) {
                ts.assertValue(1);
            }
        }",loop_control
i,"for (int i = 0; i < TestHelper.RACE_DEFAULT_LOOPS; i++) {
            final FlowableProcessor<Integer> s = PublishProcessor.<Integer>create().toSerialized();

            TestSubscriber<Integer> ts = s.test();

            final BooleanSubscription bs = new BooleanSubscription();

            Runnable r1 = new Runnable() {
                @Override
                public void run() {
                    s.onNext(1);
                }
            };

            Runnable r2 = new Runnable() {
                @Override
                public void run() {
                    s.onSubscribe(bs);
                }
            };

            TestHelper.race(r1, r2);

            ts.assertValue(1).assertNotComplete().assertNoErrors();
        }",loop_control
i,"for (int i = 0; i < TestHelper.RACE_DEFAULT_LOOPS; i++) {
            final FlowableProcessor<Integer> s = PublishProcessor.<Integer>create().toSerialized();

            TestSubscriber<Integer> ts = s.test();

            final BooleanSubscription bs = new BooleanSubscription();

            Runnable r1 = new Runnable() {
                @Override
                public void run() {
                    s.onComplete();
                }
            };

            Runnable r2 = new Runnable() {
                @Override
                public void run() {
                    s.onSubscribe(bs);
                }
            };

            TestHelper.race(r1, r2);

            ts.assertResult();
        }",loop_control
i,"for (int i = 0; i < TestHelper.RACE_DEFAULT_LOOPS; i++) {
            final FlowableProcessor<Integer> s = PublishProcessor.<Integer>create().toSerialized();

            TestSubscriber<Integer> ts = s.test();

            Runnable r1 = new Runnable() {
                @Override
                public void run() {
                    s.onComplete();
                }
            };

            Runnable r2 = new Runnable() {
                @Override
                public void run() {
                    s.onComplete();
                }
            };

            TestHelper.race(r1, r2);

            ts.assertResult();
        }",loop_control
i,"for (int i = 0; i < TestHelper.RACE_DEFAULT_LOOPS; i++) {
            final FlowableProcessor<Integer> s = PublishProcessor.<Integer>create().toSerialized();

            TestSubscriber<Integer> ts = s.test();

            final TestException ex = new TestException();

            List<Throwable> errors = TestHelper.trackPluginErrors();
            try {
                Runnable r1 = new Runnable() {
                    @Override
                    public void run() {
                        s.onError(ex);
                    }
                };

                Runnable r2 = new Runnable() {
                    @Override
                    public void run() {
                        s.onError(ex);
                    }
                };

                TestHelper.race(r1, r2);

                ts.assertFailure(TestException.class);

                TestHelper.assertUndeliverable(errors, 0, TestException.class);
            } finally {
                RxJavaPlugins.reset();
            }
        }",loop_control
i,"for (int i = 0; i < TestHelper.RACE_DEFAULT_LOOPS; i++) {
            final FlowableProcessor<Integer> s = PublishProcessor.<Integer>create().toSerialized();

            TestSubscriber<Integer> ts = s.test();

            final BooleanSubscription bs1 = new BooleanSubscription();
            final BooleanSubscription bs2 = new BooleanSubscription();

            Runnable r1 = new Runnable() {
                @Override
                public void run() {
                    s.onSubscribe(bs1);
                }
            };

            Runnable r2 = new Runnable() {
                @Override
                public void run() {
                    s.onSubscribe(bs2);
                }
            };

            TestHelper.race(r1, r2);

            ts.assertEmpty();
        }",loop_control
i,"for (int i = 0; i < 10; i++) {
            mp.onNext(i);
        }",loop_control
i,"for (int i = 0; i < 10; i++) {
            assertTrue(mp.offer(i));
        }",loop_control
i,"for (int i = 0; i < 10; i++) {
            up.onNext(i);
        }",loop_control
i,"for (int i = 0; i < TestHelper.RACE_LONG_LOOPS; i++) {
            final MulticastProcessor<Integer> mp = MulticastProcessor.create();

            final TestSubscriber<Integer> ts = mp.test();
            final TestSubscriber<Integer> ts2 = new TestSubscriber<>();

            Runnable r1 = new Runnable() {
                @Override
                public void run() {
                    ts.cancel();
                }
            };

            Runnable r2 = new Runnable() {
                @Override
                public void run() {
                    mp.subscribe(ts2);
                }
            };

            TestHelper.race(r1, r2);

            assertTrue(mp.hasSubscribers());
        }",loop_control
i,"for (int i = 0; i < TestHelper.RACE_LONG_LOOPS; i++) {
            final MulticastProcessor<Integer> mp = MulticastProcessor.create();

            mp.test();
            final TestSubscriber<Integer> ts = mp.test();
            final TestSubscriber<Integer> ts2 = new TestSubscriber<>();

            Runnable r1 = new Runnable() {
                @Override
                public void run() {
                    ts.cancel();
                }
            };

            Runnable r2 = new Runnable() {
                @Override
                public void run() {
                    mp.subscribe(ts2);
                }
            };

            TestHelper.race(r1, r2);

            assertTrue(mp.hasSubscribers());
        }",loop_control
i,"for (int i = 0; i < TestHelper.RACE_LONG_LOOPS; i++) {
            final MulticastProcessor<Integer> mp = MulticastProcessor.create(true);

            final TestSubscriber<Integer> ts = mp.test();
            final TestSubscriber<Integer> ts2 = new TestSubscriber<>();

            Runnable r1 = new Runnable() {
                @Override
                public void run() {
                    ts.cancel();
                }
            };

            Runnable r2 = new Runnable() {
                @Override
                public void run() {
                    mp.subscribe(ts2);
                }
            };

            TestHelper.race(r1, r2);
        }",loop_control
i,"for (int i = 0; i < TestHelper.RACE_LONG_LOOPS; i++) {
            final MulticastProcessor<Integer> mp = MulticastProcessor.create(true);
            mp.startUnbounded();
            mp.onNext(1);
            mp.onNext(2);

            final TestSubscriber<Integer> ts = mp.test();

            Runnable r1 = new Runnable() {
                @Override
                public void run() {
                    ts.request(1);
                }
            };

            Runnable r2 = new Runnable() {
                @Override
                public void run() {
                    ts.request(1);
                }
            };

            TestHelper.race(r1, r2);

            ts.assertValuesOnly(1, 2);
        }",loop_control
i,"for (int i = 0; i < TestHelper.RACE_LONG_LOOPS; i++) {
            final MulticastProcessor<Integer> mp = MulticastProcessor.create(true);

            final Flowable<Integer> source = Flowable.range(1, 5);

            final TestSubscriber<Integer> ts = mp.test();

            Runnable r1 = new Runnable() {
                @Override
                public void run() {
                    ts.request(5);
                }
            };

            Runnable r2 = new Runnable() {
                @Override
                public void run() {
                    source.subscribe(mp);
                }
            };

            TestHelper.race(r1, r2);

            ts
            .awaitDone(5, TimeUnit.SECONDS)
            .assertResult(1, 2, 3, 4, 5);
        }",loop_control
i,"for (int i = 0; i < TestHelper.RACE_LONG_LOOPS; i++) {
            final MulticastProcessor<Integer> mp = MulticastProcessor.create(true);
            mp.startUnbounded();

            final TestSubscriber<Integer> ts = mp.test();

            Runnable r1 = new Runnable() {
                @Override
                public void run() {
                    ts.cancel();
                }
            };

            Runnable r2 = new Runnable() {
                @Override
                public void run() {
                    mp.onNext(1);
                }
            };

            TestHelper.race(r1, r2);
        }",loop_control
i,"for (int i = 0; i < TestHelper.RACE_LONG_LOOPS; i++) {
            final MulticastProcessor<Integer> mp = MulticastProcessor.create(true);

            final TestSubscriber<Integer> ts1 = mp.test();
            final TestSubscriber<Integer> ts2 = mp.test();

            mp.test();

            Runnable r1 = new Runnable() {
                @Override
                public void run() {
                    ts1.cancel();
                }
            };

            Runnable r2 = new Runnable() {
                @Override
                public void run() {
                    ts2.cancel();
                }
            };

            TestHelper.race(r1, r2);
        }",loop_control
i,"for (int i = 0; i < TestHelper.RACE_LONG_LOOPS; i++) {
            final MulticastProcessor<Integer> mp = MulticastProcessor.create(true);

            final TestSubscriber<Integer> ts1 = mp.test();

            Runnable r1 = new Runnable() {
                @Override
                public void run() {
                    ts1.cancel();
                }
            };

            Runnable r2 = new Runnable() {
                @Override
                public void run() {
                    ts1.request(1);
                }
            };

            TestHelper.race(r1, r2);
        }",loop_control
j,"for (int j = 1; j < 12; j++) {
            MulticastProcessor<Integer> mp = MulticastProcessor.create(j, true);

            TestSubscriber<Integer> ts = mp.test(0).withTag(""Prefetch: "" + j);

            Flowable.range(1, 10).hide().subscribe(mp);

            ts.assertEmpty()
            .requestMore(3)
            .assertValuesOnly(1, 2, 3)
            .requestMore(3)
            .assertValuesOnly(1, 2, 3, 4, 5, 6)
            .requestMore(4)
            .assertResult(1, 2, 3, 4, 5, 6, 7, 8, 9, 10);
        }",loop_control
j,"for (int j = 1; j < 12; j++) {
            MulticastProcessor<Integer> mp = MulticastProcessor.create(j, true);

            TestSubscriber<Integer> ts = mp.test(0).withTag(""Prefetch: "" + j);

            Flowable.range(1, 10).hide().subscribe(mp);

            ts.assertEmpty()
            .requestMore(2)
            .assertValuesOnly(1, 2)
            .requestMore(2)
            .assertValuesOnly(1, 2, 3, 4)
            .requestMore(6)
            .assertResult(1, 2, 3, 4, 5, 6, 7, 8, 9, 10);
        }",loop_control
l,"for (long l = 1; l <= 10000; l++) {
                            subscriber.onNext(l);
                        }",loop_control
l,"for (long l = 1; l <= 10000; l++) {
                            subscriber.onNext(l);
                        }",loop_control
l,"for (long l : values) {
                v += l;
            }",loop_control
l,"for (long l : sums) {
            if (l != expected) {
                success = false;
                System.out.println(""FAILURE => Expected "" + expected + "" but got: "" + l);
            }
        }",loop_control
t,"for (int i = 1; i <= 200; i++) {
            final int count = i;
            if (count == 20) {
                // start source data after we have some already subscribed
                // and while others are in process of subscribing
                source.start();
            }
            if (count == 100) {
                // wait for source to finish then keep adding after it's done
                source.join();
            }
            Thread t = new Thread(new Runnable() {

                @Override
                public void run() {
                    List<Long> values = replay.toList().blockingGet();
                    listOfListsOfValues.add(values);
                    System.out.println(""Finished thread: "" + count);
                }
            });
            t.start();
            System.out.println(""Started thread: "" + i);
            threads.add(t);
        }",iterator
t,"for (Thread t : threads) {
            t.join();
        }",iterator
i,"for (int i = 1; i <= 200; i++) {
            final int count = i;
            if (count == 20) {
                // start source data after we have some already subscribed
                // and while others are in process of subscribing
                source.start();
            }
            if (count == 100) {
                // wait for source to finish then keep adding after it's done
                source.join();
            }
            Thread t = new Thread(new Runnable() {

                @Override
                public void run() {
                    List<Long> values = replay.toList().blockingGet();
                    listOfListsOfValues.add(values);
                    System.out.println(""Finished thread: "" + count);
                }
            });
            t.start();
            System.out.println(""Started thread: "" + i);
            threads.add(t);
        }",loop_control
i,"for (int i = 0; i < 100000; i++) {
            TestSubscriberEx<Integer> ts = new TestSubscriberEx<>();
            Flowable.just(1).subscribeOn(Schedulers.computation()).cache().subscribe(ts);
            ts.awaitDone(5, TimeUnit.SECONDS);
            ts.assertValueSequence(expected);
            ts.assertTerminated();
        }",loop_control
i,"for (int i = 0; i < 50000; i++) {
                if (i % 1000 == 0) {
                    System.out.println(i);
                }
                final ReplayProcessor<Object> rs = ReplayProcessor.createWithSize(2);

                final CountDownLatch finish = new CountDownLatch(1);
                final CountDownLatch start = new CountDownLatch(1);

//                int j = i;

                worker.schedule(new Runnable() {
                    @Override
                    public void run() {
                        try {
                            start.await();
                        } catch (Exception e1) {
                            e1.printStackTrace();
                        }
//                        System.out.println(""> "" + j);
                        rs.onNext(1);
                    }
                });

                final AtomicReference<Object> o = new AtomicReference<>();

                rs
//                .doOnSubscribe(v -> System.out.println(""!! "" + j))
//                .doOnNext(e -> System.out.println("">> "" + j))
                .subscribeOn(s)
                .observeOn(Schedulers.io())
//                .doOnNext(e -> System.out.println("">>> "" + j))
                .subscribe(new DefaultSubscriber<Object>() {

                    @Override
                    protected void onStart() {
                        super.onStart();
                    }

                    @Override
                    public void onComplete() {
                        o.set(-1);
                        finish.countDown();
                    }

                    @Override
                    public void onError(Throwable e) {
                        o.set(e);
                        finish.countDown();
                    }

                    @Override
                    public void onNext(Object t) {
                        o.set(t);
                        finish.countDown();
                    }

                });
                start.countDown();

                if (!finish.await(5, TimeUnit.SECONDS)) {
                    System.out.println(o.get());
                    System.out.println(rs.hasSubscribers());
                    rs.onComplete();
                    Assert.fail(""Timeout @ "" + i);
                    break;
                } else {
                    Assert.assertEquals(1, o.get());
                    worker.schedule(new Runnable() {
                        @Override
                        public void run() {
                            rs.onComplete();
                        }
                    });
                }
            }",loop_control
finish,"for (int i = 0; i < 50000; i++) {
                if (i % 1000 == 0) {
                    System.out.println(i);
                }
                final ReplayProcessor<Object> rs = ReplayProcessor.createWithSize(2);

                final CountDownLatch finish = new CountDownLatch(1);
                final CountDownLatch start = new CountDownLatch(1);

//                int j = i;

                worker.schedule(new Runnable() {
                    @Override
                    public void run() {
                        try {
                            start.await();
                        } catch (Exception e1) {
                            e1.printStackTrace();
                        }
//                        System.out.println(""> "" + j);
                        rs.onNext(1);
                    }
                });

                final AtomicReference<Object> o = new AtomicReference<>();

                rs
//                .doOnSubscribe(v -> System.out.println(""!! "" + j))
//                .doOnNext(e -> System.out.println("">> "" + j))
                .subscribeOn(s)
                .observeOn(Schedulers.io())
//                .doOnNext(e -> System.out.println("">>> "" + j))
                .subscribe(new DefaultSubscriber<Object>() {

                    @Override
                    protected void onStart() {
                        super.onStart();
                    }

                    @Override
                    public void onComplete() {
                        o.set(-1);
                        finish.countDown();
                    }

                    @Override
                    public void onError(Throwable e) {
                        o.set(e);
                        finish.countDown();
                    }

                    @Override
                    public void onNext(Object t) {
                        o.set(t);
                        finish.countDown();
                    }

                });
                start.countDown();

                if (!finish.await(5, TimeUnit.SECONDS)) {
                    System.out.println(o.get());
                    System.out.println(rs.hasSubscribers());
                    rs.onComplete();
                    Assert.fail(""Timeout @ "" + i);
                    break;
                } else {
                    Assert.assertEquals(1, o.get());
                    worker.schedule(new Runnable() {
                        @Override
                        public void run() {
                            rs.onComplete();
                        }
                    });
                }
            }",break_loop_control
i,"for (int i = 0; i < 1000000; i++) {
                    rs.onNext(i);
                }",loop_control
i,"for (int i = 0; i < values.length - 1; i++) {
                Integer v1 = (Integer)values[i];
                Integer v2 = (Integer)values[i + 1];
                assertEquals(1, v2 - v1);
            }",loop_control
rs,"{
        final ReplayProcessor<Object> rs = ReplayProcessor.createUnbounded();
        final CyclicBarrier cb = new CyclicBarrier(2);

        Thread t = new Thread(new Runnable() {
            @Override
            public void run() {
                try {
                    cb.await();
                } catch (InterruptedException e) {
                    return;
                } catch (BrokenBarrierException e) {
                    return;
                }
                for (int i = 0; i < 1000000; i++) {
                    rs.onNext(i);
                }
                rs.onComplete();
                System.out.println(""Replay fill Thread finished!"");
            }
        });
        t.start();
        try {
            cb.await();
        } catch (InterruptedException e) {
            return;
        } catch (BrokenBarrierException e) {
            return;
        }
        int lastSize = 0;
        for (; !rs.hasThrowable() && !rs.hasComplete();) {
            int size = rs.size();
            boolean hasAny = rs.hasValue();
            Object[] values = rs.getValues();
            if (size < lastSize) {
                Assert.fail(""Size decreased! "" + lastSize + "" -> "" + size);
            }
            if ((size > 0) && !hasAny) {
                Assert.fail(""hasAnyValue reports emptyness but size doesn't"");
            }
            if (size > values.length) {
                Assert.fail(""Got fewer values than size! "" + size + "" -> "" + values.length);
            }
            for (int i = 0; i < values.length - 1; i++) {
                Integer v1 = (Integer)values[i];
                Integer v2 = (Integer)values[i + 1];
                assertEquals(1, v2 - v1);
            }
            lastSize = size;
        }

        t.join();
    }",maybe_loop_control
rs,"{
        final ReplayProcessor<Object> rs = ReplayProcessor.createWithSize(3);
        final CyclicBarrier cb = new CyclicBarrier(2);

        Thread t = new Thread(new Runnable() {
            @Override
            public void run() {
                try {
                    cb.await();
                } catch (InterruptedException e) {
                    return;
                } catch (BrokenBarrierException e) {
                    return;
                }
                for (int i = 0; i < 1000000; i++) {
                    rs.onNext(i);
                }
                rs.onComplete();
                System.out.println(""Replay fill Thread finished!"");
            }
        });
        t.start();
        try {
            cb.await();
        } catch (InterruptedException e) {
            return;
        } catch (BrokenBarrierException e) {
            return;
        }
        for (; !rs.hasThrowable() && !rs.hasComplete();) {
            rs.size(); // can't use value so just call to detect hangs
            rs.hasValue(); // can't use value so just call to detect hangs
            Object[] values = rs.getValues();
            for (int i = 0; i < values.length - 1; i++) {
                Integer v1 = (Integer)values[i];
                Integer v2 = (Integer)values[i + 1];
                assertEquals(1, v2 - v1);
            }
        }

        t.join();
    }",maybe_loop_control
i,"for (int i = 0; i < 1000000; i++) {
                    rs.onNext(i);
                }",loop_control
i,"for (int i = 0; i < values.length - 1; i++) {
                Integer v1 = (Integer)values[i];
                Integer v2 = (Integer)values[i + 1];
                assertEquals(1, v2 - v1);
            }",loop_control
i,"for (int i = 0; i < 1000000; i++) {
                    rs.onNext(i);
                    if (i % 10000 == 0) {
                        try {
                            Thread.sleep(1);
                        } catch (InterruptedException e) {
                            return;
                        }
                    }
                }",loop_control
i,"for (int i = 0; i < values.length - 1; i++) {
                Integer v1 = (Integer)values[i];
                Integer v2 = (Integer)values[i + 1];
                assertEquals(1, v2 - v1);
            }",loop_control
rs,"{
        final ReplayProcessor<Object> rs = ReplayProcessor.createWithTime(1, TimeUnit.MILLISECONDS, Schedulers.computation());
        final CyclicBarrier cb = new CyclicBarrier(2);

        Thread t = new Thread(new Runnable() {
            @Override
            public void run() {
                try {
                    cb.await();
                } catch (InterruptedException e) {
                    return;
                } catch (BrokenBarrierException e) {
                    return;
                }
                for (int i = 0; i < 1000000; i++) {
                    rs.onNext(i);
                    if (i % 10000 == 0) {
                        try {
                            Thread.sleep(1);
                        } catch (InterruptedException e) {
                            return;
                        }
                    }
                }
                rs.onComplete();
                System.out.println(""Replay fill Thread finished!"");
            }
        });
        t.start();
        try {
            cb.await();
        } catch (InterruptedException e) {
            return;
        } catch (BrokenBarrierException e) {
            return;
        }
        for (; !rs.hasThrowable() && !rs.hasComplete();) {
            rs.size(); // can't use value so just call to detect hangs
            rs.hasValue(); // can't use value so just call to detect hangs
            Object[] values = rs.getValues();
            for (int i = 0; i < values.length - 1; i++) {
                Integer v1 = (Integer)values[i];
                Integer v2 = (Integer)values[i + 1];
                assertEquals(1, v2 - v1);
            }
        }

        t.join();
    }",maybe_loop_control
i,"for (int i = 0; i < 50; i++) {
            final AsyncProcessor<String> processor = AsyncProcessor.create();
            final AtomicReference<String> value1 = new AtomicReference<>();

            processor.subscribe(new Consumer<String>() {

                @Override
                public void accept(String t1) {
                    try {
                        // simulate a slow observer
                        Thread.sleep(50);
                    } catch (InterruptedException e) {
                        e.printStackTrace();
                    }
                    value1.set(t1);
                }

            });

            Thread t1 = new Thread(new Runnable() {

                @Override
                public void run() {
                    processor.onNext(""value"");
                    processor.onComplete();
                }
            });

            SubjectSubscriberThread t2 = new SubjectSubscriberThread(processor);
            SubjectSubscriberThread t3 = new SubjectSubscriberThread(processor);
            SubjectSubscriberThread t4 = new SubjectSubscriberThread(processor);
            SubjectSubscriberThread t5 = new SubjectSubscriberThread(processor);

            t2.start();
            t3.start();
            t1.start();
            t4.start();
            t5.start();
            try {
                t1.join();
                t2.join();
                t3.join();
                t4.join();
                t5.join();
            } catch (InterruptedException e) {
                throw new RuntimeException(e);
            }

            assertEquals(""value"", value1.get());
            assertEquals(""value"", t2.value.get());
            assertEquals(""value"", t3.value.get());
            assertEquals(""value"", t4.value.get());
            assertEquals(""value"", t5.value.get());
        }",loop_control
i,"for (int i = 0; i < TestHelper.RACE_DEFAULT_LOOPS; i++) {
            final TestSubscriber<Object> ts1 = p.test();
            final TestSubscriber<Object> ts2 = p.test();

            Runnable r1 = new Runnable() {
                @Override
                public void run() {
                    ts1.cancel();
                }
            };

            Runnable r2 = new Runnable() {
                @Override
                public void run() {
                    ts2.cancel();
                }
            };

            TestHelper.race(r1, r2);
        }",loop_control
i,"for (int i = 0; i < TestHelper.RACE_DEFAULT_LOOPS; i++) {
            final AsyncProcessor<Object> p = AsyncProcessor.create();

            final TestSubscriberEx<Object> ts1 = p.to(TestHelper.<Object>testConsumer());

            Runnable r1 = new Runnable() {
                @Override
                public void run() {
                    ts1.cancel();
                }
            };

            final TestException ex = new TestException();

            Runnable r2 = new Runnable() {
                @Override
                public void run() {
                    p.onError(ex);
                }
            };

            TestHelper.race(r1, r2);

            if (ts1.errors().size() != 0) {
                ts1.assertFailure(TestException.class);
            } else {
                ts1.assertEmpty();
            }
        }",loop_control
l,"for (long l = 1; l <= 10000; l++) {
                            subscriber.onNext(l);
                        }",loop_control
l,"for (long l = 1; l <= 10000; l++) {
                            subscriber.onNext(l);
                        }",loop_control
l,"for (long l : values) {
                v += l;
            }",loop_control
l,"for (long l : sums) {
            if (l != expected) {
                success = false;
                System.out.println(""FAILURE => Expected "" + expected + "" but got: "" + l);
            }
        }",loop_control
i,"for (int i = 1; i <= 200; i++) {
            final int count = i;
            if (count == 20) {
                // start source data after we have some already subscribed
                // and while others are in process of subscribing
                source.start();
            }
            if (count == 100) {
                // wait for source to finish then keep adding after it's done
                source.join();
            }
            Thread t = new Thread(new Runnable() {

                @Override
                public void run() {
                    List<Long> values = replay.toList().blockingGet();
                    listOfListsOfValues.add(values);
                    System.out.println(""Finished thread: "" + count);
                }
            });
            t.start();
            System.out.println(""Started thread: "" + i);
            threads.add(t);
        }",loop_control
values,"{
                    List<Long> values = replay.toList().blockingGet();
                    listOfListsOfValues.add(values);
                    System.out.println(""Finished thread: "" + count);
                }",iterator
values,"for (List<Long> values : listOfListsOfValues) {
            long v = 0;
            for (long l : values) {
                v += l;
            }
            sums.add(v);
        }",iterator
t,"for (int i = 1; i <= 200; i++) {
            final int count = i;
            if (count == 20) {
                // start source data after we have some already subscribed
                // and while others are in process of subscribing
                source.start();
            }
            if (count == 100) {
                // wait for source to finish then keep adding after it's done
                source.join();
            }
            Thread t = new Thread(new Runnable() {

                @Override
                public void run() {
                    List<Long> values = replay.toList().blockingGet();
                    listOfListsOfValues.add(values);
                    System.out.println(""Finished thread: "" + count);
                }
            });
            t.start();
            System.out.println(""Started thread: "" + i);
            threads.add(t);
        }",iterator
t,"for (Thread t : threads) {
            t.join();
        }",iterator
i,"for (int i = 0; i < 50; i++) {
            final ReplayProcessor<String> processor = ReplayProcessor.create();
            final AtomicReference<String> value1 = new AtomicReference<>();

            processor.subscribe(new Consumer<String>() {

                @Override
                public void accept(String t1) {
                    try {
                        // simulate a slow observer
                        Thread.sleep(50);
                    } catch (InterruptedException e) {
                        e.printStackTrace();
                    }
                    value1.set(t1);
                }

            });

            Thread t1 = new Thread(new Runnable() {

                @Override
                public void run() {
                    processor.onNext(""value"");
                    processor.onComplete();
                }
            });

            SubjectObserverThread t2 = new SubjectObserverThread(processor);
            SubjectObserverThread t3 = new SubjectObserverThread(processor);
            SubjectObserverThread t4 = new SubjectObserverThread(processor);
            SubjectObserverThread t5 = new SubjectObserverThread(processor);

            t2.start();
            t3.start();
            t1.start();
            t4.start();
            t5.start();
            try {
                t1.join();
                t2.join();
                t3.join();
                t4.join();
                t5.join();
            } catch (InterruptedException e) {
                throw new RuntimeException(e);
            }

            assertEquals(""value"", value1.get());
            assertEquals(""value"", t2.value.get());
            assertEquals(""value"", t3.value.get());
            assertEquals(""value"", t4.value.get());
            assertEquals(""value"", t5.value.get());
        }",loop_control
i,"for (int i = 0; i < 100000; i++) {
            TestSubscriberEx<Integer> ts = new TestSubscriberEx<>();
            Flowable.just(1).subscribeOn(Schedulers.computation()).cache().subscribe(ts);
            ts.awaitDone(5, TimeUnit.SECONDS);
            ts.assertValueSequence(expected);
            ts.assertTerminated();
        }",loop_control
i,"for (int i = 0; i < 50000; i++) {
                if (i % 1000 == 0) {
                    System.out.println(i);
                }
                final ReplayProcessor<Object> rs = ReplayProcessor.create();

                final CountDownLatch finish = new CountDownLatch(1);
                final CountDownLatch start = new CountDownLatch(1);

                worker.schedule(new Runnable() {
                    @Override
                    public void run() {
                        try {
                            start.await();
                        } catch (Exception e1) {
                            e1.printStackTrace();
                        }
                        rs.onNext(1);
                    }
                });

                final AtomicReference<Object> o = new AtomicReference<>();

                rs.subscribeOn(s).observeOn(Schedulers.io())
                .subscribe(new DefaultSubscriber<Object>() {

                    @Override
                    public void onComplete() {
                        o.set(-1);
                        finish.countDown();
                    }

                    @Override
                    public void onError(Throwable e) {
                        o.set(e);
                        finish.countDown();
                    }

                    @Override
                    public void onNext(Object t) {
                        o.set(t);
                        finish.countDown();
                    }

                });
                start.countDown();

                if (!finish.await(5, TimeUnit.SECONDS)) {
                    System.out.println(o.get());
                    System.out.println(rs.hasSubscribers());
                    rs.onComplete();
                    Assert.fail(""Timeout @ "" + i);
                    break;
                } else {
                    Assert.assertEquals(1, o.get());
                    worker.schedule(new Runnable() {
                        @Override
                        public void run() {
                            rs.onComplete();
                        }
                    });

                }
            }",loop_control
finish,"for (int i = 0; i < 50000; i++) {
                if (i % 1000 == 0) {
                    System.out.println(i);
                }
                final ReplayProcessor<Object> rs = ReplayProcessor.create();

                final CountDownLatch finish = new CountDownLatch(1);
                final CountDownLatch start = new CountDownLatch(1);

                worker.schedule(new Runnable() {
                    @Override
                    public void run() {
                        try {
                            start.await();
                        } catch (Exception e1) {
                            e1.printStackTrace();
                        }
                        rs.onNext(1);
                    }
                });

                final AtomicReference<Object> o = new AtomicReference<>();

                rs.subscribeOn(s).observeOn(Schedulers.io())
                .subscribe(new DefaultSubscriber<Object>() {

                    @Override
                    public void onComplete() {
                        o.set(-1);
                        finish.countDown();
                    }

                    @Override
                    public void onError(Throwable e) {
                        o.set(e);
                        finish.countDown();
                    }

                    @Override
                    public void onNext(Object t) {
                        o.set(t);
                        finish.countDown();
                    }

                });
                start.countDown();

                if (!finish.await(5, TimeUnit.SECONDS)) {
                    System.out.println(o.get());
                    System.out.println(rs.hasSubscribers());
                    rs.onComplete();
                    Assert.fail(""Timeout @ "" + i);
                    break;
                } else {
                    Assert.assertEquals(1, o.get());
                    worker.schedule(new Runnable() {
                        @Override
                        public void run() {
                            rs.onComplete();
                        }
                    });

                }
            }",break_loop_control
i,"for (int i = 0; i < 1000000; i++) {
                    rs.onNext(i);
                }",loop_control
rs,"{
        final ReplayProcessor<Object> rs = ReplayProcessor.create();
        final CyclicBarrier cb = new CyclicBarrier(2);

        Thread t = new Thread(new Runnable() {
            @Override
            public void run() {
                try {
                    cb.await();
                } catch (InterruptedException e) {
                    return;
                } catch (BrokenBarrierException e) {
                    return;
                }
                for (int i = 0; i < 1000000; i++) {
                    rs.onNext(i);
                }
                rs.onComplete();
                System.out.println(""Replay fill Thread finished!"");
            }
        });
        t.start();
        try {
            cb.await();
        } catch (InterruptedException e) {
            return;
        } catch (BrokenBarrierException e) {
            return;
        }
        int lastSize = 0;
        for (; !rs.hasThrowable() && !rs.hasComplete();) {
            int size = rs.size();
            boolean hasAny = rs.hasValue();
            Object[] values = rs.getValues();
            if (size < lastSize) {
                Assert.fail(""Size decreased! "" + lastSize + "" -> "" + size);
            }
            if ((size > 0) && !hasAny) {
                Assert.fail(""hasAnyValue reports emptyness but size doesn't"");
            }
            if (size > values.length) {
                Assert.fail(""Got fewer values than size! "" + size + "" -> "" + values.length);
            }
            lastSize = size;
        }

        t.join();
    }",maybe_loop_control
i,"for (int i = 0; i < 10; i++) {
            s.onNext(i);
        }",loop_control
i,"for (int i = 0; i < 10; i++) {
            final Subscriber<Object> subscriber = TestHelper.mockSubscriber();
            InOrder inOrder = inOrder(subscriber);
            String v = """" + i;
            System.out.printf(""Turn: %d%n"", i);
            src.firstElement().toFlowable()
                .flatMap(new Function<String, Flowable<String>>() {

                    @Override
                    public Flowable<String> apply(String t1) {
                        return Flowable.just(t1 + "", "" + t1);
                    }
                })
                .subscribe(new DefaultSubscriber<String>() {
                    @Override
                    public void onNext(String t) {
                        subscriber.onNext(t);
                    }

                    @Override
                    public void onError(Throwable e) {
                        subscriber.onError(e);
                    }

                    @Override
                    public void onComplete() {
                        subscriber.onComplete();
                    }
                });
            src.onNext(v);

            inOrder.verify(subscriber).onNext(v + "", "" + v);
            inOrder.verify(subscriber).onComplete();
            verify(subscriber, never()).onError(any(Throwable.class));
        }",loop_control
i,"for (int i = 0; i < TestHelper.RACE_DEFAULT_LOOPS; i++) {
            final PublishProcessor<Integer> pp = PublishProcessor.create();

            TestSubscriber<Integer> ts = pp.test();

            Runnable task = new Runnable() {
                @Override
                public void run() {
                    pp.onComplete();
                }
            };

            TestHelper.race(task, task);

            ts
            .awaitDone(5, TimeUnit.SECONDS)
            .assertResult();
        }",loop_control
i,"for (int i = 0; i < TestHelper.RACE_DEFAULT_LOOPS; i++) {
            final PublishProcessor<Integer> pp = PublishProcessor.create();

            final TestSubscriber<Integer> ts = pp.test();

            Runnable r1 = new Runnable() {
                @Override
                public void run() {
                    pp.subscribe();
                }
            };
            Runnable r2 = new Runnable() {
                @Override
                public void run() {
                    ts.cancel();
                }
            };

            TestHelper.race(r1, r2);
        }",loop_control
pp,"{
        final PublishProcessor<Integer> pp = PublishProcessor.create();

        Schedulers.single().scheduleDirect(new Runnable() {
            @Override
            public void run() {
                while (!pp.hasSubscribers()) {
                    try {
                        Thread.sleep(1);
                    } catch (InterruptedException ex) {
                        return;
                    }
                }

                for (int i = 1; i <= 10; i++) {
                    while (!pp.offer(i)) { }
                }
                pp.onComplete();
            }
        });

        Thread.sleep(1);

        pp.test()
        .awaitDone(5, TimeUnit.SECONDS)
        .assertResult(1, 2, 3, 4, 5, 6, 7, 8, 9, 10);
    }",maybe_loop_control
i,"for (int i = 1; i <= 10; i++) {
                    while (!pp.offer(i)) { }
                }",loop_control
i,"for (int i = 0; i < TestHelper.RACE_DEFAULT_LOOPS; i++) {
            final PublishProcessor<Integer> pp = PublishProcessor.create();

            final TestSubscriber<Integer> ts = pp.test(1);

            Runnable r1 = new Runnable() {
                @Override
                public void run() {
                    for (int i = 0; i < 2; i++) {
                        while (!pp.offer(i)) { }
                    }
                }
            };

            Runnable r2 = new Runnable() {
                @Override
                public void run() {
                    ts.cancel();
                }
            };

            TestHelper.race(r1, r2);

            if (ts.values().size() > 0) {
                ts.assertValuesOnly(0);
            } else {
                ts.assertEmpty();
            }
        }",loop_control
pp,"for (int i = 0; i < TestHelper.RACE_DEFAULT_LOOPS; i++) {
            final PublishProcessor<Integer> pp = PublishProcessor.create();

            final TestSubscriber<Integer> ts = pp.test(1);

            Runnable r1 = new Runnable() {
                @Override
                public void run() {
                    for (int i = 0; i < 2; i++) {
                        while (!pp.offer(i)) { }
                    }
                }
            };

            Runnable r2 = new Runnable() {
                @Override
                public void run() {
                    ts.cancel();
                }
            };

            TestHelper.race(r1, r2);

            if (ts.values().size() > 0) {
                ts.assertValuesOnly(0);
            } else {
                ts.assertEmpty();
            }
        }",maybe_loop_control
i,"for (int i = 0; i < 10; i++) {
            final Subscriber<Object> subscriber = TestHelper.mockSubscriber();
            InOrder inOrder = inOrder(subscriber);
            String v = """" + i;
            src.onNext(v);
            System.out.printf(""Turn: %d%n"", i);
            src.firstElement().toFlowable()
                .flatMap(new Function<String, Flowable<String>>() {

                    @Override
                    public Flowable<String> apply(String t1) {
                        return Flowable.just(t1 + "", "" + t1);
                    }
                })
                .subscribe(new DefaultSubscriber<String>() {
                    @Override
                    public void onNext(String t) {
                        subscriber.onNext(t);
                    }

                    @Override
                    public void onError(Throwable e) {
                        subscriber.onError(e);
                    }

                    @Override
                    public void onComplete() {
                        subscriber.onComplete();
                    }
                });
            inOrder.verify(subscriber).onNext(v + "", "" + v);
            inOrder.verify(subscriber).onComplete();
            verify(subscriber, never()).onError(any(Throwable.class));
        }",loop_control
i,"for (int i = 0; i < 50000; i++) {
                if (i % 1000 == 0) {
                    System.out.println(i);
                }
                final BehaviorProcessor<Object> rs = BehaviorProcessor.create();

                final CountDownLatch finish = new CountDownLatch(1);
                final CountDownLatch start = new CountDownLatch(1);

                worker.schedule(new Runnable() {
                    @Override
                    public void run() {
                        try {
                            start.await();
                        } catch (Exception e1) {
                            e1.printStackTrace();
                        }
                        rs.onNext(1);
                    }
                });

                final AtomicReference<Object> o = new AtomicReference<>();

                rs.subscribeOn(s).observeOn(Schedulers.io())
                .subscribe(new DefaultSubscriber<Object>() {

                    @Override
                    public void onComplete() {
                        o.set(-1);
                        finish.countDown();
                    }

                    @Override
                    public void onError(Throwable e) {
                        o.set(e);
                        finish.countDown();
                    }

                    @Override
                    public void onNext(Object t) {
                        o.set(t);
                        finish.countDown();
                    }

                });
                start.countDown();

                if (!finish.await(5, TimeUnit.SECONDS)) {
                    System.out.println(o.get());
                    System.out.println(rs.hasSubscribers());
                    rs.onComplete();
                    Assert.fail(""Timeout @ "" + i);
                    break;
                } else {
                    Assert.assertEquals(1, o.get());
                    worker.schedule(new Runnable() {
                        @Override
                        public void run() {
                            rs.onComplete();
                        }
                    });
                }
            }",loop_control
finish,"for (int i = 0; i < 50000; i++) {
                if (i % 1000 == 0) {
                    System.out.println(i);
                }
                final BehaviorProcessor<Object> rs = BehaviorProcessor.create();

                final CountDownLatch finish = new CountDownLatch(1);
                final CountDownLatch start = new CountDownLatch(1);

                worker.schedule(new Runnable() {
                    @Override
                    public void run() {
                        try {
                            start.await();
                        } catch (Exception e1) {
                            e1.printStackTrace();
                        }
                        rs.onNext(1);
                    }
                });

                final AtomicReference<Object> o = new AtomicReference<>();

                rs.subscribeOn(s).observeOn(Schedulers.io())
                .subscribe(new DefaultSubscriber<Object>() {

                    @Override
                    public void onComplete() {
                        o.set(-1);
                        finish.countDown();
                    }

                    @Override
                    public void onError(Throwable e) {
                        o.set(e);
                        finish.countDown();
                    }

                    @Override
                    public void onNext(Object t) {
                        o.set(t);
                        finish.countDown();
                    }

                });
                start.countDown();

                if (!finish.await(5, TimeUnit.SECONDS)) {
                    System.out.println(o.get());
                    System.out.println(rs.hasSubscribers());
                    rs.onComplete();
                    Assert.fail(""Timeout @ "" + i);
                    break;
                } else {
                    Assert.assertEquals(1, o.get());
                    worker.schedule(new Runnable() {
                        @Override
                        public void run() {
                            rs.onComplete();
                        }
                    });
                }
            }",break_loop_control
i,"for (int i = 0; i < TestHelper.RACE_DEFAULT_LOOPS; i++) {
            final BehaviorProcessor<Object> p = BehaviorProcessor.create();

            final TestSubscriber<Object> ts = p.test();

            Runnable r1 = new Runnable() {
                @Override
                public void run() {
                    p.test();
                }
            };

            Runnable r2 = new Runnable() {
                @Override
                public void run() {
                    ts.cancel();
                }
            };

            TestHelper.race(r1, r2);
        }",loop_control
i,"for (int i = 0; i < TestHelper.RACE_DEFAULT_LOOPS; i++) {
            final BehaviorProcessor<Object> p = BehaviorProcessor.create();

            final TestSubscriber<Object> ts1 = p.test();
            final TestSubscriber<Object> ts2 = p.test();
            final TestSubscriber<Object> ts3 = p.test();

            Runnable r1 = new Runnable() {
                @Override
                public void run() {
                    ts1.cancel();
                }
            };

            Runnable r2 = new Runnable() {
                @Override
                public void run() {
                    ts2.cancel();
                }
            };

            TestHelper.race(r1, r2);

            p.onNext(1);
            ts3.assertValuesOnly(1);
        }",loop_control
i,"for (int i = 0; i < TestHelper.RACE_DEFAULT_LOOPS; i++) {
            final BehaviorProcessor<Object> p = BehaviorProcessor.createDefault((Object)1);

            final TestSubscriber[] ts = { null };

            Runnable r1 = new Runnable() {
                @Override
                public void run() {
                    ts[0] = p.test();
                }
            };

            Runnable r2 = new Runnable() {
                @Override
                public void run() {
                    p.onNext(2);
                }
            };

            TestHelper.race(r1, r2);

            if (ts[0].values().size() == 1) {
                ts[0].assertValue(2).assertNoErrors().assertNotComplete();
            } else {
                ts[0].assertValues(1, 2).assertNoErrors().assertNotComplete();
            }
        }",loop_control
pp,"{
        final BehaviorProcessor<Integer> pp = BehaviorProcessor.create();

        Schedulers.single().scheduleDirect(new Runnable() {
            @Override
            public void run() {
                while (!pp.hasSubscribers()) {
                    try {
                        Thread.sleep(1);
                    } catch (InterruptedException ex) {
                        return;
                    }
                }

                for (int i = 1; i <= 10; i++) {
                    while (!pp.offer(i)) { }
                }
                pp.onComplete();
            }
        });

        Thread.sleep(1);

        pp.test()
        .awaitDone(5, TimeUnit.SECONDS)
        .assertResult(1, 2, 3, 4, 5, 6, 7, 8, 9, 10);
    }",maybe_loop_control
i,"for (int i = 1; i <= 10; i++) {
                    while (!pp.offer(i)) { }
                }",loop_control
i,"for (int i = 0; i < TestHelper.RACE_DEFAULT_LOOPS; i++) {
            final BehaviorProcessor<Object> p = BehaviorProcessor.create();

            final TestSubscriber<Object> ts = new TestSubscriber<>();

            Runnable r1 = new Runnable() {
                @Override
                public void run() {
                    p.subscribe(ts);
                }
            };

            Runnable r2 = new Runnable() {
                @Override
                public void run() {
                    p.onComplete();
                }
            };

            TestHelper.race(r1, r2);

            ts.assertResult();
        }",loop_control
i,"for (int i = 0; i < TestHelper.RACE_DEFAULT_LOOPS; i++) {
            final BehaviorProcessor<Object> p = BehaviorProcessor.create();

            final TestSubscriber<Object> ts = new TestSubscriber<>();

            final TestException ex = new TestException();

            Runnable r1 = new Runnable() {
                @Override
                public void run() {
                    p.subscribe(ts);
                }
            };

            Runnable r2 = new Runnable() {
                @Override
                public void run() {
                    p.onError(ex);
                }
            };

            TestHelper.race(r1, r2);

            ts.assertFailure(TestException.class);
        }",loop_control
i,"for (int i = 0; i < TestHelper.RACE_DEFAULT_LOOPS; i++) {
            final BehaviorProcessor<Integer> pp = BehaviorProcessor.create();

            final TestSubscriber<Integer> ts = pp.test(1);

            Runnable r1 = new Runnable() {
                @Override
                public void run() {
                    for (int i = 0; i < 2; i++) {
                        while (!pp.offer(i)) { }
                    }
                }
            };

            Runnable r2 = new Runnable() {
                @Override
                public void run() {
                    ts.cancel();
                }
            };

            TestHelper.race(r1, r2);

            if (ts.values().size() > 0) {
                ts.assertValuesOnly(0);
            } else {
                ts.assertEmpty();
            }
        }",loop_control
pp,"for (int i = 0; i < TestHelper.RACE_DEFAULT_LOOPS; i++) {
            final BehaviorProcessor<Integer> pp = BehaviorProcessor.create();

            final TestSubscriber<Integer> ts = pp.test(1);

            Runnable r1 = new Runnable() {
                @Override
                public void run() {
                    for (int i = 0; i < 2; i++) {
                        while (!pp.offer(i)) { }
                    }
                }
            };

            Runnable r2 = new Runnable() {
                @Override
                public void run() {
                    ts.cancel();
                }
            };

            TestHelper.race(r1, r2);

            if (ts.values().size() > 0) {
                ts.assertValuesOnly(0);
            } else {
                ts.assertEmpty();
            }
        }",maybe_loop_control
i,"for (int i = 0; i < TestHelper.RACE_LONG_LOOPS; i++) {

            BehaviorProcessor<Integer> bp = BehaviorProcessor.create();
            bp.onNext(1);

            TestSubscriber<Integer> ts = new TestSubscriber<>();

            final BehaviorSubscription<Integer> bs = new BehaviorSubscription<>(ts, bp);
            ts.onSubscribe(bs);

            Runnable r1 = new Runnable() {
                @Override
                public void run() {
                    bs.emitFirst();
                }
            };
            Runnable r2 = new Runnable() {
                @Override
                public void run() {
                    bs.cancel();
                }
            };

            TestHelper.race(r1, r2);
        }",loop_control
i,"for (int i = 0; i < TestHelper.RACE_LONG_LOOPS; i++) {

            BehaviorProcessor<Integer> bp = BehaviorProcessor.create();
            bp.onNext(1);

            TestSubscriber<Integer> ts = new TestSubscriber<>();

            final BehaviorSubscription<Integer> bs = new BehaviorSubscription<>(ts, bp);
            ts.onSubscribe(bs);

            Runnable r1 = new Runnable() {
                @Override
                public void run() {
                    bs.emitNext(2, 0);
                }
            };
            Runnable r2 = new Runnable() {
                @Override
                public void run() {
                    bs.cancel();
                }
            };

            TestHelper.race(r1, r2);
        }",loop_control
i,"for (int i = 0; i < TestHelper.RACE_DEFAULT_LOOPS; i++) {
            final int[] calls = { 0 };
            final UnicastProcessor<Object> up = UnicastProcessor.create(100, new Runnable() {
                @Override
                public void run() {
                    calls[0]++;
                }
            });

            final TestSubscriber<Object> ts = up.test();

            Runnable r1 = new Runnable() {
                @Override
                public void run() {
                    ts.cancel();
                }
            };

            Runnable r2 = new Runnable() {
                @Override
                public void run() {
                    up.onComplete();
                }
            };

            TestHelper.race(r1, r2);

            assertEquals(1, calls[0]);
        }",loop_control
i,"for (int i = 0; i < TestHelper.RACE_DEFAULT_LOOPS; i++) {
            final UnicastProcessor<Object> p = UnicastProcessor.create();

            final TestSubscriberEx<Object> ts = new TestSubscriberEx<>().setInitialFusionMode(QueueFuseable.ANY);

            p.subscribe(ts);

            Runnable r1 = new Runnable() {
                @Override
                public void run() {
                    p.onNext(1);
                }
            };

            Runnable r2 = new Runnable() {
                @Override
                public void run() {
                    ts.cancel();
                }
            };

            TestHelper.race(r1, r2);
        }",loop_control
i,"for (int i = 0; i < TestHelper.RACE_DEFAULT_LOOPS; i++) {
            final UnicastProcessor<Integer> up = UnicastProcessor.create();

            final TestSubscriberEx<Integer> ts1 = new TestSubscriberEx<>();
            final TestSubscriberEx<Integer> ts2 = new TestSubscriberEx<>();

            Runnable r1 = new Runnable() {
                @Override
                public void run() {
                    up.subscribe(ts1);
                }
            };

            Runnable r2 = new Runnable() {
                @Override
                public void run() {
                    up.subscribe(ts2);
                }
            };

            TestHelper.race(r1, r2);

            if (ts1.errors().size() == 0) {
                ts2.assertFailure(IllegalStateException.class);
            } else
            if (ts2.errors().size() == 0) {
                ts1.assertFailure(IllegalStateException.class);
            } else {
                fail(""Neither TestObserver failed"");
            }
        }",loop_control
j,"for (int j = 0; j < TestHelper.RACE_LONG_LOOPS; j++) {
            List<Throwable> errors = TestHelper.trackPluginErrors();
            try {
                final UnicastProcessor<Integer> up = UnicastProcessor.create();

                TestObserver<Integer> to = up
                .observeOn(Schedulers.io())
                .map(Functions.<Integer>identity())
                .observeOn(Schedulers.single())
                .firstOrError()
                .test();

                for (int i = 0; up.hasSubscribers(); i++) {
                    up.onNext(i);
                }

                to
                .awaitDone(5, TimeUnit.SECONDS)
                ;

                if (!errors.isEmpty()) {
                    throw new CompositeException(errors);
                }

                to.assertResult(0);
            } finally {
                RxJavaPlugins.reset();
            }
        }",loop_control
up,"{
                final UnicastProcessor<Integer> up = UnicastProcessor.create();

                TestObserver<Integer> to = up
                .observeOn(Schedulers.io())
                .map(Functions.<Integer>identity())
                .observeOn(Schedulers.single())
                .firstOrError()
                .test();

                for (int i = 0; up.hasSubscribers(); i++) {
                    up.onNext(i);
                }

                to
                .awaitDone(5, TimeUnit.SECONDS)
                ;

                if (!errors.isEmpty()) {
                    throw new CompositeException(errors);
                }

                to.assertResult(0);
            }",maybe_loop_control
i,"for (int i = 1; i < 3; i++) {
                Observable.just(i)
                .test()
                .withTag(""testing with item="" + i)
                .assertResult(1)
                ;
            }",loop_control
i,"for (int i = 0; i < n; i++) {
            TestMultiThreadedObservable onSubscribe = new TestMultiThreadedObservable(""one"", ""two"", ""three"", null,
                    ""four"", ""five"", ""six"", ""seven"", ""eight"", ""nine"");
            Observable<String> w = Observable.unsafeCreate(onSubscribe);

            BusyObserver busySubscriber = new BusyObserver();
            Observer<String> aw = serializedObserver(busySubscriber);

            w.subscribe(aw);
            onSubscribe.waitToFinish();

            System.out.println(""OnSubscribe maxConcurrentThreads: "" + onSubscribe.maxConcurrentThreads.get() + ""  Observer maxConcurrentThreads: "" + busySubscriber.maxConcurrentThreads.get());

            // we can have concurrency ...
            assertTrue(onSubscribe.maxConcurrentThreads.get() > 1);
            // ... but the onNext execution should be single threaded
            assertEquals(1, busySubscriber.maxConcurrentThreads.get());

            // this should not be the full number of items since the error should stop it before it completes all 9
            System.out.println(""onNext count: "" + busySubscriber.onNextCount.get());
            assertFalse(busySubscriber.onComplete);
            assertTrue(busySubscriber.onError);
            assertTrue(busySubscriber.onNextCount.get() < 9);
            // no onComplete because onError was invoked
            // non-deterministic because unsubscribe happens after 'waitToFinish' releases
            // so commenting out for now as this is not a critical thing to test here
            // verify(s, times(1)).unsubscribe();
        }",loop_control
i,"for (int i = 0; i < errors.size(); i++) {
                TestHelper.assertUndeliverable(errors, i, RuntimeException.class);
            }",loop_control
i,"for (int i = 0; i < n; i++) {
                final CountDownLatch firstOnNext = new CountDownLatch(1);
                final CountDownLatch onNextCount = new CountDownLatch(2);
                final CountDownLatch latch = new CountDownLatch(1);
                final CountDownLatch running = new CountDownLatch(2);

                TestObserverEx<String> to = new TestObserverEx<>(new DefaultObserver<String>() {

                    @Override
                    public void onComplete() {

                    }

                    @Override
                    public void onError(Throwable e) {

                    }

                    @Override
                    public void onNext(String t) {
                        firstOnNext.countDown();
                        // force it to take time when delivering so the second one is enqueued
                        try {
                            latch.await();
                        } catch (InterruptedException e) {
                        }
                    }

                });
                Observer<String> o = serializedObserver(to);

                Future<?> f1 = tp1.submit(new OnNextThread(o, 1, onNextCount, running));
                Future<?> f2 = tp2.submit(new OnNextThread(o, 1, onNextCount, running));

                running.await(); // let one of the OnNextThread actually run before proceeding

                firstOnNext.await();

                Thread t1 = to.lastThread();
                System.out.println(""first onNext on thread: "" + t1);

                latch.countDown();

                waitOnThreads(f1, f2);
                // not completed yet

                assertEquals(2, to.values().size());

                Thread t2 = to.lastThread();
                System.out.println(""second onNext on thread: "" + t2);

                assertSame(t1, t2);

                System.out.println(to.values());
                o.onComplete();
                System.out.println(to.values());
            }",loop_control
f,"for (Future<?> f : futures) {
            try {
                f.get(20, TimeUnit.SECONDS);
            } catch (Throwable e) {
                System.err.println(""Failed while waiting on future."");
                e.printStackTrace();
            }
        }",iterator
bs,"{
                Disposable bs = Disposable.empty();
                observer.onSubscribe(bs);
                while (!bs.isDisposed()) {
                    observer.onNext(""onNext"");
                    produced.incrementAndGet();
                }
            }",maybe_loop_control
i,"for (int i = 0; i < numStringsToSend; i++) {
                observer.onNext(Thread.currentThread().getId() + ""-"" + i);
                if (latch != null) {
                    latch.countDown();
                }
                produced.incrementAndGet();
            }",loop_control
f,"for (Future<?> f : waitOnThese) {
                    try {
                        f.get();
                    } catch (Throwable e) {
                        System.err.println(""Error while waiting on future in CompletionThread"");
                    }
                }",iterator
i,"for (int i = 0; i < 20; i++) {
                s += s * i;
            }",loop_control
e,"{

        /**
         * used to store the order and number of events received.
         */
        private final LinkedBlockingQueue<TestConcurrencySubscriberEvent> events = new LinkedBlockingQueue<>();
        private final int waitTime;

        @SuppressWarnings(""unused"")
        TestConcurrencySubscriber(int waitTimeInNext) {
            this.waitTime = waitTimeInNext;
        }

        TestConcurrencySubscriber() {
            this.waitTime = 0;
        }

        @Override
        public void onComplete() {
            events.add(TestConcurrencySubscriberEvent.onComplete);
        }

        @Override
        public void onError(Throwable e) {
            events.add(TestConcurrencySubscriberEvent.onError);
        }

        @Override
        public void onNext(String args) {
            events.add(TestConcurrencySubscriberEvent.onNext);
            // do some artificial work to make the thread scheduling/timing vary
            int s = 0;
            for (int i = 0; i < 20; i++) {
                s += s * i;
            }

            if (waitTime > 0) {
                try {
                    Thread.sleep(waitTime);
                } catch (InterruptedException e) {
                    // ignore
                }
            }
        }

        /**
         * Assert the order of events is correct and return the number of onNext executions.
         *
         * @param expectedEndingEvent the expected last event
         * @return int count of onNext calls
         * @throws IllegalStateException
         *             If order of events was invalid.
         */
        public int assertEvents(TestConcurrencySubscriberEvent expectedEndingEvent) throws IllegalStateException {
            int nextCount = 0;
            boolean finished = false;
            for (TestConcurrencySubscriberEvent e : events) {
                if (e == TestConcurrencySubscriberEvent.onNext) {
                    if (finished) {
                        // already finished, we shouldn't get this again
                        throw new IllegalStateException(""Received onNext but we're already finished."");
                    }
                    nextCount++;
                } else if (e == TestConcurrencySubscriberEvent.onError) {
                    if (finished) {
                        // already finished, we shouldn't get this again
                        throw new IllegalStateException(""Received onError but we're already finished."");
                    }
                    if (expectedEndingEvent != null && TestConcurrencySubscriberEvent.onError != expectedEndingEvent) {
                        throw new IllegalStateException(""Received onError ending event but expected "" + expectedEndingEvent);
                    }
                    finished = true;
                } else if (e == TestConcurrencySubscriberEvent.onComplete) {
                    if (finished) {
                        // already finished, we shouldn't get this again
                        throw new IllegalStateException(""Received onComplete but we're already finished."");
                    }
                    if (expectedEndingEvent != null && TestConcurrencySubscriberEvent.onComplete != expectedEndingEvent) {
                        throw new IllegalStateException(""Received onComplete ending event but expected "" + expectedEndingEvent);
                    }
                    finished = true;
                }
            }

            return nextCount;
        }

    }",iterator
s,"for (String s : values) {
                            System.out.println(""TestSingleThreadedObservable onNext: "" + s);
                            observer.onNext(s);
                        }",iterator
s,"for (final String s : values) {
                            final int fj = ++j;
                            threadPool.execute(new Runnable() {

                                @Override
                                public void run() {
                                    threadsRunning.incrementAndGet();
                                    try {
                                        // perform onNext call
                                        System.out.println(""TestMultiThreadedObservable onNext: "" + s + "" on thread "" + Thread.currentThread().getName());
                                        if (s == null) {
                                            // force an error
                                            throw npe;
                                        } else {
                                             // allow the exception to queue up
                                            int sleep = (fj % 3) * 10;
                                            if (sleep != 0) {
                                                Thread.sleep(sleep);
                                            }
                                        }
                                        observer.onNext(s);
                                        // capture 'maxThreads'
                                        int concurrentThreads = threadsRunning.get();
                                        int maxThreads = maxConcurrentThreads.get();
                                        if (concurrentThreads > maxThreads) {
                                            maxConcurrentThreads.compareAndSet(maxThreads, concurrentThreads);
                                        }
                                    } catch (Throwable e) {
                                        observer.onError(e);
                                    } finally {
                                        threadsRunning.decrementAndGet();
                                    }
                                }
                            });
                        }",iterator
i,"for (int i = 0; i < TestHelper.RACE_DEFAULT_LOOPS; i++) {
            TestObserver<Integer> to = new TestObserver<>();

            final SerializedObserver<Integer> so = new SerializedObserver<>(to);

            Disposable d = Disposable.empty();

            so.onSubscribe(d);

            Runnable r = new Runnable() {
                @Override
                public void run() {
                    so.onComplete();
                }
            };

            TestHelper.race(r, r);

            to.awaitDone(5, TimeUnit.SECONDS)
            .assertResult();
        }",loop_control
i,"for (int i = 0; i < TestHelper.RACE_DEFAULT_LOOPS; i++) {
            TestObserver<Integer> to = new TestObserver<>();

            final SerializedObserver<Integer> so = new SerializedObserver<>(to);

            Disposable d = Disposable.empty();

            so.onSubscribe(d);

            Runnable r1 = new Runnable() {
                @Override
                public void run() {
                    so.onComplete();
                }
            };

            Runnable r2 = new Runnable() {
                @Override
                public void run() {
                    so.onNext(1);
                }
            };

            TestHelper.race(r1, r2);

            to.awaitDone(5, TimeUnit.SECONDS)
            .assertNoErrors()
            .assertComplete();

            assertTrue(to.values().size() <= 1);
        }",loop_control
i,"for (int i = 0; i < TestHelper.RACE_DEFAULT_LOOPS; i++) {
            TestObserver<Integer> to = new TestObserver<>();

            final SerializedObserver<Integer> so = new SerializedObserver<>(to);

            Disposable d = Disposable.empty();

            so.onSubscribe(d);

            final Throwable ex = new TestException();

            Runnable r1 = new Runnable() {
                @Override
                public void run() {
                    so.onError(ex);
                }
            };

            Runnable r2 = new Runnable() {
                @Override
                public void run() {
                    so.onNext(1);
                }
            };

            TestHelper.race(r1, r2);

            to.awaitDone(5, TimeUnit.SECONDS)
            .assertError(ex)
            .assertNotComplete();

            assertTrue(to.values().size() <= 1);
        }",loop_control
i,"for (int i = 0; i < TestHelper.RACE_DEFAULT_LOOPS; i++) {
            TestObserver<Integer> to = new TestObserver<>();

            final SerializedObserver<Integer> so = new SerializedObserver<>(to, true);

            Disposable d = Disposable.empty();

            so.onSubscribe(d);

            final Throwable ex = new TestException();

            Runnable r1 = new Runnable() {
                @Override
                public void run() {
                    so.onError(ex);
                }
            };

            Runnable r2 = new Runnable() {
                @Override
                public void run() {
                    so.onNext(1);
                }
            };

            TestHelper.race(r1, r2);

            to.awaitDone(5, TimeUnit.SECONDS)
            .assertError(ex)
            .assertNotComplete();

            assertTrue(to.values().size() <= 1);
        }",loop_control
i,"for (int i = 0; i < TestHelper.RACE_DEFAULT_LOOPS; i++) {

            List<Throwable> errors = TestHelper.trackPluginErrors();
            try {
                TestObserverEx<Integer> to = new TestObserverEx<>();

                final SerializedObserver<Integer> so = new SerializedObserver<>(to);

                Disposable d = Disposable.empty();

                so.onSubscribe(d);

                final Throwable ex = new TestException();

                Runnable r1 = new Runnable() {
                    @Override
                    public void run() {
                        so.onError(ex);
                    }
                };

                Runnable r2 = new Runnable() {
                    @Override
                    public void run() {
                        so.onComplete();
                    }
                };

                TestHelper.race(r1, r2);

                to.awaitDone(5, TimeUnit.SECONDS);

                if (to.completions() != 0) {
                    to.assertResult();
                } else {
                    to.assertFailure(TestException.class).assertError(ex);
                }

                for (Throwable e : errors) {
                    assertTrue(e.toString(), e.getCause() instanceof TestException);
                }
            } finally {
                RxJavaPlugins.reset();
            }
        }",loop_control
e,"for (Throwable e : errors) {
                    assertTrue(e.toString(), e.getCause() instanceof TestException);
                }",iterator
i,"for (int i = 0; i < retryCount; i++) {
                try {
                    base.evaluate();
                    return;
                } catch (Throwable t) {
                    caughtThrowable = t;
                    System.err.println(description.getDisplayName() + "": run "" + (i + 1) + "" failed"");
                    int n = sleep;
                    if (backoff && i != 0) {
                        n = n * (2 << i);
                    }
                    Thread.sleep(n);
                }
            }",loop_control
i,"for (int i = 1; i < subs.length; i++) {
                subs[i] = NoOpConsumer.INSTANCE;
            }",loop_control
count,"{
        final AtomicInteger count = new AtomicInteger(2);
        final CountDownLatch cdl = new CountDownLatch(2);

        final Throwable[] errors = { null, null };

        s.scheduleDirect(new Runnable() {
            @Override
            public void run() {
                if (count.decrementAndGet() != 0) {
                    while (count.get() != 0) { }
                }

                try {
                    try {
                        r1.run();
                    } catch (Throwable ex) {
                        errors[0] = ex;
                    }
                } finally {
                    cdl.countDown();
                }
            }
        });

        if (count.decrementAndGet() != 0) {
            while (count.get() != 0) { }
        }

        try {
            try {
                r2.run();
            } catch (Throwable ex) {
                errors[1] = ex;
            }
        } finally {
            cdl.countDown();
        }

        try {
            if (!cdl.await(5, TimeUnit.SECONDS)) {
                throw new AssertionError(""The wait timed out!"");
            }
        } catch (InterruptedException ex) {
            throw new RuntimeException(ex);
        }
        if (errors[0] != null && errors[1] == null) {
            throw ExceptionHelper.wrapOrThrow(errors[0]);
        }

        if (errors[0] == null && errors[1] != null) {
            throw ExceptionHelper.wrapOrThrow(errors[1]);
        }

        if (errors[0] != null && errors[1] != null) {
            throw new CompositeException(errors);
        }
    }",maybe_loop_control
o,"for (Enum<E> o : (Enum<E>[])m.invoke(null)) {
                assertSame(o, e.invoke(null, o.name()));
            }",iterator
i,"for (int i = 0; i < subscribers.length; i++) {
                        try {
                            BooleanSubscription bs1 = new BooleanSubscription();

                            subscribers[i].onSubscribe(bs1);

                            BooleanSubscription bs2 = new BooleanSubscription();

                            subscribers[i].onSubscribe(bs2);

                            b[i * 2 + 0] = bs1.isCancelled();
                            b[i * 2 + 1] = bs2.isCancelled();
                        } finally {
                            cdl.countDown();
                        }
                    }",loop_control
i,"for (int i = 0; i < subscribers.length; i++) {
                        try {
                            BooleanSubscription bs1 = new BooleanSubscription();

                            subscribers[i].onSubscribe(bs1);

                            BooleanSubscription bs2 = new BooleanSubscription();

                            subscribers[i].onSubscribe(bs2);

                            b[i * 2 + 0] = bs1.isCancelled();
                            b[i * 2 + 1] = bs2.isCancelled();
                        } finally {
                            cdl.countDown();
                        }
                    }",loop_control
i,"for (int i = 0; i < classes.length; i++) {
            assertError(list, i, classes[i]);
        }",loop_control
i,"for (int i = 0; i < classes.length; i += 2) {
            assertError(list, i, (Class<Throwable>)classes[i], (String)classes[i + 1]);
        }",loop_control
i,"for (int i = 0; i < classes.length; i++) {
            assertError(list, i, classes[i]);
        }",loop_control
i,"for (int i = 0; i < classes.length; i += 2) {
            assertError(list, i, (Class<Throwable>)classes[i], (String)classes[i + 1]);
        }",loop_control
v,"for (T v : values) {
            p.onNext(v);
        }",iterator
v,"for (T v : values) {
            p.onNext(v);
        }",iterator
i,"for (int i = 0; i <= n; i++) {
            tss[i] = new TestSubscriber<>().withTag("""" + i);
        }",loop_control
i,"for (int i = 0; i <= n; i++) {
            tss[i].assertFailure(IllegalArgumentException.class);
        }",loop_control
t,"for (T t : ts.values()) {
            if (!expectedSet.contains(t)) {
                throw ts.failWith(""Item not in the set: "" + BaseTestConsumer.valueAndClass(t));
            }
        }",iterator
t,"for (T t : to.values()) {
            if (!expectedSet.contains(t)) {
                throw to.failWith(""Item not in the set: "" + BaseTestConsumer.valueAndClass(t));
            }
        }",iterator
idx,"{
            int idx = path.lastIndexOf(""/"");
            if (idx < 0) {
                break;
            }
            path = path.substring(0, idx);
            String check = path + ""/src/main/java"";

            if (new File(check).exists()) {
                p = check + ""/"" + parentPackage + ""/"" + baseClassName + "".java"";
                break;
            }
        }",break_loop_control
i,"{
        MemoryMXBean bean = ManagementFactory.getMemoryMXBean();

        System.gc();

        int i = maxLoop;
        while (i-- != 0) {
            long usage = bean.getHeapMemoryUsage().getUsed();
            if (usage <= expectedMemoryUsage) {
                return usage;
            }
            System.gc();
            Thread.sleep(oneSleep);
        }
        return bean.getHeapMemoryUsage().getUsed();
    }",loop_control
sync,"{
        AtomicInteger sync = new AtomicInteger(2);

        Schedulers.single().scheduleDirect(() -> {
            if (sync.decrementAndGet() != 0) {
                while (sync.get() != 0) { }
            }

            run.run();

            resume.countDown();
        });

        if (sync.decrementAndGet() != 0) {
            while (sync.get() != 0) { }
        }
    }",maybe_loop_control
i,"for (int i = 0; i < s; i++) {
            T v = this.values.get(i);
            if (Objects.equals(v, value)) {
                throw fail(""Value at position "" + i + "" is equal to "" + valueAndClass(value) + ""; Expected them to be different"");
            }
        }",loop_control
i,"for (int i = 0; i < s; i++) {
            T v = this.values.get(i);
            try {
                if (valuePredicate.test(v)) {
                    throw fail(""Value at position "" + i + "" matches predicate "" + valuePredicate.toString() + "", which was not expected."");
                }
            } catch (Throwable ex) {
                throw ExceptionHelper.wrapOrThrow(ex);
            }
        }",loop_control
t,"{
                        T t;
                        while ((t = qd.poll()) != null) {
                            values.add(t);
                        }
                        completions++;

                        upstream.lazySet(DisposableHelper.DISPOSED);
                    }",maybe_loop_control
t,"{
                while ((t = qd.poll()) != null) {
                    values.add(t);
                }
            }",maybe_loop_control
t,"{
        if (!checkSubscriptionOnce) {
            checkSubscriptionOnce = true;
            if (upstream.get() == null) {
                errors.add(new IllegalStateException(""onSubscribe not called in proper order""));
            }
        }

        lastThread = Thread.currentThread();

        if (establishedFusionMode == QueueFuseable.ASYNC) {
            try {
                while ((t = qd.poll()) != null) {
                    values.add(t);
                }
            } catch (Throwable ex) {
                errors.add(ex);
                qd.dispose();
            }
            return;
        }

        values.add(t);

        if (t == null) {
            errors.add(new NullPointerException(""onNext received a null value""));
        }

        downstream.onNext(t);
    }",maybe_loop_control
i,"for (int i = 1; i < 3; i++) {
                Observable.just(i)
                .test()
                .withTag(""testing with item="" + i)
                .assertResult(1)
                ;
            }",loop_control
i,"for (int i = 1; i < 3; i++) {
                Flowable.just(i)
                .test()
                .withTag(""testing with item="" + i)
                .assertResult(1)
                ;
            }",loop_control
t,"{
                        T t;
                        while ((t = qs.poll()) != null) {
                            values.add(t);
                        }
                        completions++;
                    }",maybe_loop_control
t,"{
                while ((t = qs.poll()) != null) {
                    values.add(t);
                }
            }",maybe_loop_control
t,"{
        if (!checkSubscriptionOnce) {
            checkSubscriptionOnce = true;
            if (upstream.get() == null) {
                errors.add(new IllegalStateException(""onSubscribe not called in proper order""));
            }
        }
        lastThread = Thread.currentThread();

        if (establishedFusionMode == QueueFuseable.ASYNC) {
            try {
                while ((t = qs.poll()) != null) {
                    values.add(t);
                }
            } catch (Throwable ex) {
                // Exceptions.throwIfFatal(e); TODO add fatal exceptions?
                errors.add(ex);
                qs.cancel();
            }
            return;
        }

        values.add(t);

        if (t == null) {
            errors.add(new NullPointerException(""onNext received a null value""));
        }

        downstream.onNext(t);
    }",maybe_loop_control
dirs,"{
        File f = TestHelper.findSource(""Flowable"");
        if (f == null) {
            System.out.println(""Unable to find sources of RxJava"");
            return;
        }

        Queue<File> dirs = new ArrayDeque<>();

        StringBuilder fail = new StringBuilder();
        fail.append(""The following code pattern was found: "").append(pattern).append(""\n"");
        fail.append(""Refresh and re-run tests!\n\n"");

        File parent = f.getParentFile().getParentFile();

        dirs.offer(new File(parent.getAbsolutePath().replace('\\', '/')));
        dirs.offer(new File(parent.getAbsolutePath().replace('\\', '/').replace(""src/main/java"", ""src/test/java"")));

        Pattern p = Pattern.compile(pattern);

        int total = 0;

        while (!dirs.isEmpty()) {
            f = dirs.poll();

            File[] list = f.listFiles();
            if (list != null && list.length != 0) {

                for (File u : list) {
                    if (u.isDirectory()) {
                        dirs.offer(u);
                    } else {
                        String fname = u.getName();
                        if (fname.endsWith("".java"")) {

                            int lineNum = 0;
                            List<String> lines = new ArrayList<>();
                            BufferedReader in = new BufferedReader(new FileReader(u));
                            //boolean found = false;
                            try {
                                for (; ; ) {
                                    String line = in.readLine();
                                    if (line == null) {
                                        break;
                                    }
                                    lineNum++;

                                    Matcher matcher = p.matcher(line);
                                    if (!line.startsWith(""//"") && !line.startsWith(""*"") && matcher.find()) {
                                        // found = true;
                                        fail
                                                .append(fname)
                                                .append(""#L"").append(lineNum)
                                                .append(""    "").append(line)
                                                .append(""\n"");
                                        total++;

                                        int methodNameStartIndex = matcher.end() - 1;
                                        char firstChar = Character.toLowerCase(line.charAt(methodNameStartIndex));

                                        String newLine = matcher.replaceAll(replacement + firstChar);

                                        lines.add(newLine);
                                    } else {
                                        lines.add(line);
                                    }

                                }
                            } finally {
                                in.close();
                            }

                            /*if (found && System.getenv(""CI"") == null) {
                                PrintWriter w = new PrintWriter(new FileWriter(u));

                                try {
                                    for (String s : lines) {
                                        w.println(s);
                                    }
                                } finally {
                                    w.close();
                                }
                            }*/
                        }
                    }
                }
            }
        }
        if (total != 0) {
            fail.append(""Found "")
                    .append(total)
                    .append("" instances"");
            System.out.println(fail);
            throw new AssertionError(fail.toString());
        }
    }",maybe_loop_control
u,"for (File u : list) {
                    if (u.isDirectory()) {
                        dirs.offer(u);
                    } else {
                        String fname = u.getName();
                        if (fname.endsWith("".java"")) {

                            int lineNum = 0;
                            List<String> lines = new ArrayList<>();
                            BufferedReader in = new BufferedReader(new FileReader(u));
                            //boolean found = false;
                            try {
                                for (; ; ) {
                                    String line = in.readLine();
                                    if (line == null) {
                                        break;
                                    }
                                    lineNum++;

                                    Matcher matcher = p.matcher(line);
                                    if (!line.startsWith(""//"") && !line.startsWith(""*"") && matcher.find()) {
                                        // found = true;
                                        fail
                                                .append(fname)
                                                .append(""#L"").append(lineNum)
                                                .append(""    "").append(line)
                                                .append(""\n"");
                                        total++;

                                        int methodNameStartIndex = matcher.end() - 1;
                                        char firstChar = Character.toLowerCase(line.charAt(methodNameStartIndex));

                                        String newLine = matcher.replaceAll(replacement + firstChar);

                                        lines.add(newLine);
                                    } else {
                                        lines.add(line);
                                    }

                                }
                            } finally {
                                in.close();
                            }

                            /*if (found && System.getenv(""CI"") == null) {
                                PrintWriter w = new PrintWriter(new FileWriter(u));

                                try {
                                    for (String s : lines) {
                                        w.println(s);
                                    }
                                } finally {
                                    w.close();
                                }
                            }*/
                        }
                    }
                }",iterator
linek,"for (; midx >= 0; midx--) {
                        String linek = lines.get(midx).trim();
                        if (linek.startsWith(""public"") || linek.startsWith(""private"")
                                || linek.startsWith(""protected"")
                                || linek.startsWith(""static"")
                                || linek.startsWith(baseClassName)) {
                            break;
                        }
                    }",break_loop_control
linek,"for (; midx >= 0; midx--) {
                        String linek = lines.get(midx).trim();
                        if (linek.startsWith(""public"") || linek.startsWith(""private"")
                                || linek.startsWith(""protected"")
                                || linek.startsWith(""static"")
                                || linek.startsWith(baseClassName)) {
                            break;
                        }
                    }",break_loop_control
linek,"for (int k = midx - 1; k >= 0; k--) {
                        String linek = lines.get(k).trim();
                        if (linek.startsWith(""/**"")) {
                            break;
                        }
                        if (linek.startsWith(""}"")) {
                            found = true; // no JavaDoc
                            break;
                        }
                        if (linek.startsWith(validatorStr.javadoc)) {
                            found = true;
                        }
                    }",break_loop_control
k,"for (int k = midx - 1; k >= 0; k--) {
                        String linek = lines.get(k).trim();
                        if (linek.startsWith(""/**"")) {
                            break;
                        }
                        if (linek.startsWith(""}"")) {
                            found = true; // no JavaDoc
                            break;
                        }
                        if (linek.startsWith(validatorStr.javadoc)) {
                            found = true;
                        }
                    }",loop_control
validatorStr,"for (ValidatorStrings validatorStr : TYPICAL_ARGUMENT_STRINGS) {
                    // find the method declaration ending {
                    for (int i = j; i < lines.size(); i++) {
                        String linei = lines.get(i).trim();

                        // space + code for capturing type declarations
                        String varPattern = "" "" + validatorStr.code;
                        if (linei.contains(varPattern + "")"")
                                || linei.contains(varPattern + "","")
                                || linei.endsWith(varPattern)) {
                            // ignore nullable-annotated arguments
                            if (!linei.matches("".*\\@Nullable\\s.*"" + validatorStr.code + "".*"")) {
                                boolean found = false;
                                for (int k = i - 1; k >= 0; k--) {
                                    String linek = lines.get(k).trim();
                                    if (linek.startsWith(""/**"")) {
                                        break;
                                    }
                                    if (linek.startsWith(""}"")) {
                                        found = true; // no method JavaDoc present
                                        break;
                                    }
                                    if (linek.startsWith(validatorStr.javadoc)) {
                                        // see if a @code paramName is present
                                        String paramStr = ""{@code "" + validatorStr.code + ""}"";
                                        for (int m = k; m < lines.size(); m++) {
                                            String linem = lines.get(m).trim();
                                            if (linem.startsWith(""* @see"")
                                                    || linem.startsWith(""* @since"")
                                                    || linem.startsWith(""*/"")) {
                                                break;
                                            }
                                            if (linem.contains(paramStr)) {
                                                found = true;
                                                break;
                                            }
                                        }
                                        break;
                                    }
                                }

                                if (!found) {
                                    errorCount++;
                                    errors.append(""L"")
                                    .append(j)
                                    .append("" : missing '"")
                                    .append(validatorStr.javadoc)
                                    .append(""' for typical argument: "")
                                    .append(validatorStr.code)
                                    .append(""\r\n    "")
                                    .append(line)
                                    .append(""\r\n at "")
                                    .append(fullClassName)
                                    .append("".method("")
                                    .append(f.getName())
                                    .append("":"")
                                    .append(j + 1)
                                    .append("")\r\n"")
                                    ;
                                }
                            }
                        }

                        if (linei.endsWith(""{"") || linei.endsWith("";"")) {
                            break;
                        }
                    }
                }",iterator
i,"for (int i = j; i < lines.size(); i++) {
                        String linei = lines.get(i).trim();

                        // space + code for capturing type declarations
                        String varPattern = "" "" + validatorStr.code;
                        if (linei.contains(varPattern + "")"")
                                || linei.contains(varPattern + "","")
                                || linei.endsWith(varPattern)) {
                            // ignore nullable-annotated arguments
                            if (!linei.matches("".*\\@Nullable\\s.*"" + validatorStr.code + "".*"")) {
                                boolean found = false;
                                for (int k = i - 1; k >= 0; k--) {
                                    String linek = lines.get(k).trim();
                                    if (linek.startsWith(""/**"")) {
                                        break;
                                    }
                                    if (linek.startsWith(""}"")) {
                                        found = true; // no method JavaDoc present
                                        break;
                                    }
                                    if (linek.startsWith(validatorStr.javadoc)) {
                                        // see if a @code paramName is present
                                        String paramStr = ""{@code "" + validatorStr.code + ""}"";
                                        for (int m = k; m < lines.size(); m++) {
                                            String linem = lines.get(m).trim();
                                            if (linem.startsWith(""* @see"")
                                                    || linem.startsWith(""* @since"")
                                                    || linem.startsWith(""*/"")) {
                                                break;
                                            }
                                            if (linem.contains(paramStr)) {
                                                found = true;
                                                break;
                                            }
                                        }
                                        break;
                                    }
                                }

                                if (!found) {
                                    errorCount++;
                                    errors.append(""L"")
                                    .append(j)
                                    .append("" : missing '"")
                                    .append(validatorStr.javadoc)
                                    .append(""' for typical argument: "")
                                    .append(validatorStr.code)
                                    .append(""\r\n    "")
                                    .append(line)
                                    .append(""\r\n at "")
                                    .append(fullClassName)
                                    .append("".method("")
                                    .append(f.getName())
                                    .append("":"")
                                    .append(j + 1)
                                    .append("")\r\n"")
                                    ;
                                }
                            }
                        }

                        if (linei.endsWith(""{"") || linei.endsWith("";"")) {
                            break;
                        }
                    }",loop_control
k,"for (int k = i - 1; k >= 0; k--) {
                                    String linek = lines.get(k).trim();
                                    if (linek.startsWith(""/**"")) {
                                        break;
                                    }
                                    if (linek.startsWith(""}"")) {
                                        found = true; // no method JavaDoc present
                                        break;
                                    }
                                    if (linek.startsWith(validatorStr.javadoc)) {
                                        // see if a @code paramName is present
                                        String paramStr = ""{@code "" + validatorStr.code + ""}"";
                                        for (int m = k; m < lines.size(); m++) {
                                            String linem = lines.get(m).trim();
                                            if (linem.startsWith(""* @see"")
                                                    || linem.startsWith(""* @since"")
                                                    || linem.startsWith(""*/"")) {
                                                break;
                                            }
                                            if (linem.contains(paramStr)) {
                                                found = true;
                                                break;
                                            }
                                        }
                                        break;
                                    }
                                }",loop_control
m,"for (int m = k; m < lines.size(); m++) {
                                            String linem = lines.get(m).trim();
                                            if (linem.startsWith(""* @see"")
                                                    || linem.startsWith(""* @since"")
                                                    || linem.startsWith(""*/"")) {
                                                break;
                                            }
                                            if (linem.contains(paramStr)) {
                                                found = true;
                                                break;
                                            }
                                        }",loop_control
linek,"for (int k = i - 1; k >= 0; k--) {
                                    String linek = lines.get(k).trim();
                                    if (linek.startsWith(""/**"")) {
                                        break;
                                    }
                                    if (linek.startsWith(""}"")) {
                                        found = true; // no method JavaDoc present
                                        break;
                                    }
                                    if (linek.startsWith(validatorStr.javadoc)) {
                                        // see if a @code paramName is present
                                        String paramStr = ""{@code "" + validatorStr.code + ""}"";
                                        for (int m = k; m < lines.size(); m++) {
                                            String linem = lines.get(m).trim();
                                            if (linem.startsWith(""* @see"")
                                                    || linem.startsWith(""* @since"")
                                                    || linem.startsWith(""*/"")) {
                                                break;
                                            }
                                            if (linem.contains(paramStr)) {
                                                found = true;
                                                break;
                                            }
                                        }
                                        break;
                                    }
                                }",break_loop_control
linei,"for (int i = j; i < lines.size(); i++) {
                        String linei = lines.get(i).trim();

                        // space + code for capturing type declarations
                        String varPattern = "" "" + validatorStr.code;
                        if (linei.contains(varPattern + "")"")
                                || linei.contains(varPattern + "","")
                                || linei.endsWith(varPattern)) {
                            // ignore nullable-annotated arguments
                            if (!linei.matches("".*\\@Nullable\\s.*"" + validatorStr.code + "".*"")) {
                                boolean found = false;
                                for (int k = i - 1; k >= 0; k--) {
                                    String linek = lines.get(k).trim();
                                    if (linek.startsWith(""/**"")) {
                                        break;
                                    }
                                    if (linek.startsWith(""}"")) {
                                        found = true; // no method JavaDoc present
                                        break;
                                    }
                                    if (linek.startsWith(validatorStr.javadoc)) {
                                        // see if a @code paramName is present
                                        String paramStr = ""{@code "" + validatorStr.code + ""}"";
                                        for (int m = k; m < lines.size(); m++) {
                                            String linem = lines.get(m).trim();
                                            if (linem.startsWith(""* @see"")
                                                    || linem.startsWith(""* @since"")
                                                    || linem.startsWith(""*/"")) {
                                                break;
                                            }
                                            if (linem.contains(paramStr)) {
                                                found = true;
                                                break;
                                            }
                                        }
                                        break;
                                    }
                                }

                                if (!found) {
                                    errorCount++;
                                    errors.append(""L"")
                                    .append(j)
                                    .append("" : missing '"")
                                    .append(validatorStr.javadoc)
                                    .append(""' for typical argument: "")
                                    .append(validatorStr.code)
                                    .append(""\r\n    "")
                                    .append(line)
                                    .append(""\r\n at "")
                                    .append(fullClassName)
                                    .append("".method("")
                                    .append(f.getName())
                                    .append("":"")
                                    .append(j + 1)
                                    .append("")\r\n"")
                                    ;
                                }
                            }
                        }

                        if (linei.endsWith(""{"") || linei.endsWith("";"")) {
                            break;
                        }
                    }",break_loop_control
line,"{
                int lineCount = 1;
                String line = null;

                while ((line = in.readLine()) != null) {
                    line = line.trim();

                    if (!line.contains("" to("")) {
                        if (line.startsWith(""public static <"") || line.startsWith(""public final <"")) {

                            for (String ta : parseTypeArguments(line)) {
                                if (!ta.startsWith(""@NonNull"") && !ta.startsWith(""@Nullable"")) {
                                    if (!(""Maybe"".equals(clazz.getSimpleName()) && (line.contains(""fromCallable("") || line.contains(""fromSupplier("")))) {
                                        result.append(""Missing annotation on argument "").append(ta).append(""\r\nat "")
                                        .append(parentPackage).append(""."").append(className).append("".method("")
                                        .append(className).append("".java:"").append(lineCount).append("")\r\n"");
                                        count++;
                                    }
                                }
                            }
                        }
                    }
                    lineCount++;
                }
            }",maybe_loop_control
line,"{

    static void process(Class<?> clazz) {

        String className = clazz.getSimpleName();
        String parentPackage = clazz.getPackage().getName();

        StringBuilder result = new StringBuilder();
        int count = 0;

        try {
            File f = TestHelper.findSource(className, parentPackage);

            try (BufferedReader in = Files.newBufferedReader(f.toPath())) {
                int lineCount = 1;
                String line = null;

                while ((line = in.readLine()) != null) {
                    line = line.trim();

                    if (!line.contains("" to("")) {
                        if (line.startsWith(""public static <"") || line.startsWith(""public final <"")) {

                            for (String ta : parseTypeArguments(line)) {
                                if (!ta.startsWith(""@NonNull"") && !ta.startsWith(""@Nullable"")) {
                                    if (!(""Maybe"".equals(clazz.getSimpleName()) && (line.contains(""fromCallable("") || line.contains(""fromSupplier("")))) {
                                        result.append(""Missing annotation on argument "").append(ta).append(""\r\nat "")
                                        .append(parentPackage).append(""."").append(className).append("".method("")
                                        .append(className).append("".java:"").append(lineCount).append("")\r\n"");
                                        count++;
                                    }
                                }
                            }
                        }
                    }
                    lineCount++;
                }
            }
        } catch (Exception ex) {
            throw new RuntimeException(ex);
        }

        if (count != 0) {
            throw new IllegalArgumentException(""Found "" + count + "" cases\r\n"" + result.toString());
        }
    }

    static List<String> parseTypeArguments(String line) {
        List<String> result = new ArrayList<>();
        int offset = line.indexOf(""<"");
        int c = 1;
        int i = offset + 1;
        int j = i;
        for (; i < line.length(); i++) {
            if (line.charAt(i) == '<') {
                c++;
            } else
            if (line.charAt(i) == '>') {
                c--;
                if (c == 0) {
                    break;
                }
            } else
            if (line.charAt(i) == ',' && c == 1) {
                result.add(line.substring(j, i).trim());
                j = i + 1;
            }
        }
        result.add(line.substring(j, i).trim());
        return result;
    }

    @Test
    public void parseTypeArguments() {
        assertEquals(new ArrayList<>(Arrays.asList(""T"")), parseTypeArguments(""<T>""));
        assertEquals(new ArrayList<>(Arrays.asList(""T"", ""U"")), parseTypeArguments(""<T, U>""));
        assertEquals(new ArrayList<>(Arrays.asList(""T"", ""Flowable<U>"")), parseTypeArguments(""<T, Flowable<U>>""));
        assertEquals(new ArrayList<>(Arrays.asList(""T"", ""Flowable<U, V>"")), parseTypeArguments(""<T, Flowable<U, V>>""));
    }

    @Test
    public void flowable() {
        process(Flowable.class);
    }

    @Test
    public void observable() {
        process(Observable.class);
    }

    @Test
    public void maybe() {
        process(Maybe.class);
    }

    @Test
    public void single() {
        process(Single.class);
    }

    @Test
    public void completable() {
        process(Completable.class);
    }

    @Test
    public void parallel() {
        process(ParallelFlowable.class);
    }

    @Test
    public void plugins() {
        process(RxJavaPlugins.class);
    }
}",maybe_loop_control
ta,"for (String ta : parseTypeArguments(line)) {
                                if (!ta.startsWith(""@NonNull"") && !ta.startsWith(""@Nullable"")) {
                                    if (!(""Maybe"".equals(clazz.getSimpleName()) && (line.contains(""fromCallable("") || line.contains(""fromSupplier("")))) {
                                        result.append(""Missing annotation on argument "").append(ta).append(""\r\nat "")
                                        .append(parentPackage).append(""."").append(className).append("".method("")
                                        .append(className).append("".java:"").append(lineCount).append("")\r\n"");
                                        count++;
                                    }
                                }
                            }",iterator
i,"{
        List<String> result = new ArrayList<>();
        int offset = line.indexOf(""<"");
        int c = 1;
        int i = offset + 1;
        int j = i;
        for (; i < line.length(); i++) {
            if (line.charAt(i) == '<') {
                c++;
            } else
            if (line.charAt(i) == '>') {
                c--;
                if (c == 0) {
                    break;
                }
            } else
            if (line.charAt(i) == ',' && c == 1) {
                result.add(line.substring(j, i).trim());
                j = i + 1;
            }
        }
        result.add(line.substring(j, i).trim());
        return result;
    }",loop_control
c,"{
        List<String> result = new ArrayList<>();
        int offset = line.indexOf(""<"");
        int c = 1;
        int i = offset + 1;
        int j = i;
        for (; i < line.length(); i++) {
            if (line.charAt(i) == '<') {
                c++;
            } else
            if (line.charAt(i) == '>') {
                c--;
                if (c == 0) {
                    break;
                }
            } else
            if (line.charAt(i) == ',' && c == 1) {
                result.add(line.substring(j, i).trim());
                j = i + 1;
            }
        }
        result.add(line.substring(j, i).trim());
        return result;
    }",break_loop_control
i,"for (int i = 0; i < index; i++) {
            if (s.charAt(i) == '\n') {
                cnt++;
            }
        }",loop_control
i,"for (int i = 0; i < index; i++) {
            if (s.charAt(i) == '\n') {
                cnt++;
            }
        }",loop_control
m,"for (RxMethod m : list) {
            int jdx;
            if (m.javadoc != null) {
                jdx = 0;
                for (;;) {
                    int idx = m.javadoc.indexOf(""onNext"", jdx);
                    if (idx >= 0) {
                        if (!m.signature.contains(""Publisher"")
                                && !m.signature.contains(""Flowable"")
                                && !m.signature.contains(""Observable"")
                                && !m.signature.contains(""ObservableSource"")) {
                            e.append(""java.lang.RuntimeException: Maybe doc mentions onNext but no Flowable/Observable in signature\r\n at io.reactivex.rxjava3.core."")
                            .append(""Maybe.method(Maybe.java:"").append(m.javadocLine + lineNumber(m.javadoc, idx) - 1).append("")\r\n\r\n"");
                        }

                        jdx = idx + 6;
                    } else {
                        break;
                    }
                }
                jdx = 0;
                for (;;) {
                    int idx = m.javadoc.indexOf(""Subscriber"", jdx);
                    if (idx >= 0) {
                        if (!m.signature.contains(""Publisher"")
                                && !m.signature.contains(""Flowable"")
                                && !m.signature.contains(""TestSubscriber"")
                        ) {
                            e.append(""java.lang.RuntimeException: Maybe doc mentions Subscriber but not using Flowable\r\n at io.reactivex.rxjava3.core."")
                            .append(""Maybe.method(Maybe.java:"").append(m.javadocLine + lineNumber(m.javadoc, idx) - 1).append("")\r\n\r\n"");
                        }

                        jdx = idx + 6;
                    } else {
                        break;
                    }
                }
                jdx = 0;
                for (;;) {
                    int idx = m.javadoc.indexOf("" Subscription"", jdx);
                    if (idx >= 0) {
                        if (!m.signature.contains(""Publisher"")
                                && !m.signature.contains(""Flowable"")
                        ) {
                            e.append(""java.lang.RuntimeException: Maybe doc mentions Subscription but not using Flowable\r\n at io.reactivex.rxjava3.core."")
                            .append(""Maybe.method(Maybe.java:"").append(m.javadocLine + lineNumber(m.javadoc, idx) - 1).append("")\r\n\r\n"");
                        }

                        jdx = idx + 6;
                    } else {
                        break;
                    }
                }
                jdx = 0;
                for (;;) {
                    int idx = m.javadoc.indexOf(""Observer"", jdx);
                    if (idx >= 0) {
                        if (!m.signature.contains(""ObservableSource"")
                                && !m.signature.contains(""Observable"")
                                && !m.signature.contains(""TestObserver"")) {

                            if (idx < 5 || !m.javadoc.substring(idx - 5, idx + 8).equals(""MaybeObserver"")) {
                                e.append(""java.lang.RuntimeException: Maybe doc mentions Observer but not using Observable\r\n at io.reactivex.rxjava3.core."")
                                .append(""Maybe.method(Maybe.java:"").append(m.javadocLine + lineNumber(m.javadoc, idx) - 1).append("")\r\n\r\n"");
                            }
                        }

                        jdx = idx + 6;
                    } else {
                        break;
                    }
                }
                jdx = 0;
                for (;;) {
                    int idx = m.javadoc.indexOf(""Publisher"", jdx);
                    if (idx >= 0) {
                        if (!m.signature.contains(""Publisher"")) {
                            if (idx == 0 || !m.javadoc.substring(idx - 1, idx + 9).equals(""(Publisher"")) {
                                e.append(""java.lang.RuntimeException: Maybe doc mentions Publisher but not in the signature\r\n at io.reactivex.rxjava3.core."")
                                .append(""Maybe.method(Maybe.java:"").append(m.javadocLine + lineNumber(m.javadoc, idx) - 1).append("")\r\n\r\n"");
                            }
                        }

                        jdx = idx + 6;
                    } else {
                        break;
                    }
                }
                jdx = 0;
                for (;;) {
                    int idx = m.javadoc.indexOf(""Flowable"", jdx);
                    if (idx >= 0) {
                        if (!m.signature.contains(""Flowable"")) {
                            Pattern p = Pattern.compile(""@see\\s+#[A-Za-z0-9 _.,()]*Flowable"");
                            if (!p.matcher(m.javadoc).find()) {
                                e.append(""java.lang.RuntimeException: Maybe doc mentions Flowable but not in the signature\r\n at io.reactivex.rxjava3.core."")
                                .append(""Maybe.method(Maybe.java:"").append(m.javadocLine + lineNumber(m.javadoc, idx) - 1).append("")\r\n\r\n"");
                            }
                        }
                        jdx = idx + 6;
                    } else {
                        break;
                    }
                }
                jdx = 0;
                for (;;) {
                    int idx = m.javadoc.indexOf(""Single"", jdx);
                    if (idx >= 0 && m.javadoc.indexOf(""Single#"", jdx) != idx) {
                        int j = m.javadoc.indexOf(""#toSingle"", jdx);
                        int k = m.javadoc.indexOf(""{@code Single"", jdx);
                        if (!m.signature.contains(""Single"") && (j + 3 != idx && k + 7 != idx)) {
                            e.append(""java.lang.RuntimeException: Maybe doc mentions Single but not in the signature\r\n at io.reactivex.rxjava3.core."")
                            .append(""Maybe.method(Maybe.java:"").append(m.javadocLine + lineNumber(m.javadoc, idx) - 1).append("")\r\n\r\n"");
                        }
                        jdx = idx + 6;
                    } else {
                        break;
                    }
                }
                jdx = 0;
                for (;;) {
                    int idx = m.javadoc.indexOf(""SingleSource"", jdx);
                    if (idx >= 0) {
                        if (!m.signature.contains(""SingleSource"")) {
                            e.append(""java.lang.RuntimeException: Maybe doc mentions SingleSource but not in the signature\r\n at io.reactivex.rxjava3.core."")
                            .append(""Maybe.method(Maybe.java:"").append(m.javadocLine + lineNumber(m.javadoc, idx) - 1).append("")\r\n\r\n"");
                        }
                        jdx = idx + 6;
                    } else {
                        break;
                    }
                }
                jdx = 0;
                for (;;) {
                    int idx = m.javadoc.indexOf(""Observable"", jdx);
                    if (idx >= 0) {
                        if (!m.signature.contains(""Observable"")) {
                            Pattern p = Pattern.compile(""@see\\s+#[A-Za-z0-9 _.,()]*Observable"");
                            if (!p.matcher(m.javadoc).find()) {
                                e.append(""java.lang.RuntimeException: Maybe doc mentions Observable but not in the signature\r\n at io.reactivex.rxjava3.core."")
                                .append(""Maybe.method(Maybe.java:"").append(m.javadocLine + lineNumber(m.javadoc, idx) - 1).append("")\r\n\r\n"");
                            }
                        }
                        jdx = idx + 6;
                    } else {
                        break;
                    }
                }
                jdx = 0;
                for (;;) {
                    int idx = m.javadoc.indexOf(""ObservableSource"", jdx);
                    if (idx >= 0) {
                        if (!m.signature.contains(""ObservableSource"")) {
                            e.append(""java.lang.RuntimeException: Maybe doc mentions ObservableSource but not in the signature\r\n at io.reactivex.rxjava3.core."")
                            .append(""Maybe.method(Maybe.java:"").append(m.javadocLine + lineNumber(m.javadoc, idx) - 1).append("")\r\n\r\n"");
                        }
                        jdx = idx + 6;
                    } else {
                        break;
                    }
                }

                checkAtReturnAndSignatureMatch(""Maybe"", m, e, ""Flowable"", ""Observable"", ""Maybe"", ""Single"", ""Completable"", ""Disposable"", ""Iterable"", ""Stream"", ""Future"", ""CompletionStage"");

                aOrAn(e, m, ""Maybe"");
                missingClosingDD(e, m, ""Maybe"", ""io.reactivex.rxjava3.core"");
                backpressureMentionedWithoutAnnotation(e, m, ""Maybe"");
            }
        }",iterator
idx,"for (;;) {
                    int idx = m.javadoc.indexOf(""onNext"", jdx);
                    if (idx >= 0) {
                        if (!m.signature.contains(""Publisher"")
                                && !m.signature.contains(""Flowable"")
                                && !m.signature.contains(""Observable"")
                                && !m.signature.contains(""ObservableSource"")) {
                            e.append(""java.lang.RuntimeException: Maybe doc mentions onNext but no Flowable/Observable in signature\r\n at io.reactivex.rxjava3.core."")
                            .append(""Maybe.method(Maybe.java:"").append(m.javadocLine + lineNumber(m.javadoc, idx) - 1).append("")\r\n\r\n"");
                        }

                        jdx = idx + 6;
                    } else {
                        break;
                    }
                }",break_loop_control
idx,"for (;;) {
                    int idx = m.javadoc.indexOf(""Subscriber"", jdx);
                    if (idx >= 0) {
                        if (!m.signature.contains(""Publisher"")
                                && !m.signature.contains(""Flowable"")
                                && !m.signature.contains(""TestSubscriber"")
                        ) {
                            e.append(""java.lang.RuntimeException: Maybe doc mentions Subscriber but not using Flowable\r\n at io.reactivex.rxjava3.core."")
                            .append(""Maybe.method(Maybe.java:"").append(m.javadocLine + lineNumber(m.javadoc, idx) - 1).append("")\r\n\r\n"");
                        }

                        jdx = idx + 6;
                    } else {
                        break;
                    }
                }",break_loop_control
idx,"for (;;) {
                    int idx = m.javadoc.indexOf("" Subscription"", jdx);
                    if (idx >= 0) {
                        if (!m.signature.contains(""Publisher"")
                                && !m.signature.contains(""Flowable"")
                        ) {
                            e.append(""java.lang.RuntimeException: Maybe doc mentions Subscription but not using Flowable\r\n at io.reactivex.rxjava3.core."")
                            .append(""Maybe.method(Maybe.java:"").append(m.javadocLine + lineNumber(m.javadoc, idx) - 1).append("")\r\n\r\n"");
                        }

                        jdx = idx + 6;
                    } else {
                        break;
                    }
                }",break_loop_control
idx,"for (;;) {
                    int idx = m.javadoc.indexOf(""Observer"", jdx);
                    if (idx >= 0) {
                        if (!m.signature.contains(""ObservableSource"")
                                && !m.signature.contains(""Observable"")
                                && !m.signature.contains(""TestObserver"")) {

                            if (idx < 5 || !m.javadoc.substring(idx - 5, idx + 8).equals(""MaybeObserver"")) {
                                e.append(""java.lang.RuntimeException: Maybe doc mentions Observer but not using Observable\r\n at io.reactivex.rxjava3.core."")
                                .append(""Maybe.method(Maybe.java:"").append(m.javadocLine + lineNumber(m.javadoc, idx) - 1).append("")\r\n\r\n"");
                            }
                        }

                        jdx = idx + 6;
                    } else {
                        break;
                    }
                }",break_loop_control
idx,"for (;;) {
                    int idx = m.javadoc.indexOf(""Publisher"", jdx);
                    if (idx >= 0) {
                        if (!m.signature.contains(""Publisher"")) {
                            if (idx == 0 || !m.javadoc.substring(idx - 1, idx + 9).equals(""(Publisher"")) {
                                e.append(""java.lang.RuntimeException: Maybe doc mentions Publisher but not in the signature\r\n at io.reactivex.rxjava3.core."")
                                .append(""Maybe.method(Maybe.java:"").append(m.javadocLine + lineNumber(m.javadoc, idx) - 1).append("")\r\n\r\n"");
                            }
                        }

                        jdx = idx + 6;
                    } else {
                        break;
                    }
                }",break_loop_control
idx,"for (;;) {
                    int idx = m.javadoc.indexOf(""Flowable"", jdx);
                    if (idx >= 0) {
                        if (!m.signature.contains(""Flowable"")) {
                            Pattern p = Pattern.compile(""@see\\s+#[A-Za-z0-9 _.,()]*Flowable"");
                            if (!p.matcher(m.javadoc).find()) {
                                e.append(""java.lang.RuntimeException: Maybe doc mentions Flowable but not in the signature\r\n at io.reactivex.rxjava3.core."")
                                .append(""Maybe.method(Maybe.java:"").append(m.javadocLine + lineNumber(m.javadoc, idx) - 1).append("")\r\n\r\n"");
                            }
                        }
                        jdx = idx + 6;
                    } else {
                        break;
                    }
                }",break_loop_control
idx,"for (;;) {
                    int idx = m.javadoc.indexOf(""Single"", jdx);
                    if (idx >= 0 && m.javadoc.indexOf(""Single#"", jdx) != idx) {
                        int j = m.javadoc.indexOf(""#toSingle"", jdx);
                        int k = m.javadoc.indexOf(""{@code Single"", jdx);
                        if (!m.signature.contains(""Single"") && (j + 3 != idx && k + 7 != idx)) {
                            e.append(""java.lang.RuntimeException: Maybe doc mentions Single but not in the signature\r\n at io.reactivex.rxjava3.core."")
                            .append(""Maybe.method(Maybe.java:"").append(m.javadocLine + lineNumber(m.javadoc, idx) - 1).append("")\r\n\r\n"");
                        }
                        jdx = idx + 6;
                    } else {
                        break;
                    }
                }",break_loop_control
idx,"for (;;) {
                    int idx = m.javadoc.indexOf(""SingleSource"", jdx);
                    if (idx >= 0) {
                        if (!m.signature.contains(""SingleSource"")) {
                            e.append(""java.lang.RuntimeException: Maybe doc mentions SingleSource but not in the signature\r\n at io.reactivex.rxjava3.core."")
                            .append(""Maybe.method(Maybe.java:"").append(m.javadocLine + lineNumber(m.javadoc, idx) - 1).append("")\r\n\r\n"");
                        }
                        jdx = idx + 6;
                    } else {
                        break;
                    }
                }",break_loop_control
idx,"for (;;) {
                    int idx = m.javadoc.indexOf(""Observable"", jdx);
                    if (idx >= 0) {
                        if (!m.signature.contains(""Observable"")) {
                            Pattern p = Pattern.compile(""@see\\s+#[A-Za-z0-9 _.,()]*Observable"");
                            if (!p.matcher(m.javadoc).find()) {
                                e.append(""java.lang.RuntimeException: Maybe doc mentions Observable but not in the signature\r\n at io.reactivex.rxjava3.core."")
                                .append(""Maybe.method(Maybe.java:"").append(m.javadocLine + lineNumber(m.javadoc, idx) - 1).append("")\r\n\r\n"");
                            }
                        }
                        jdx = idx + 6;
                    } else {
                        break;
                    }
                }",break_loop_control
idx,"for (;;) {
                    int idx = m.javadoc.indexOf(""ObservableSource"", jdx);
                    if (idx >= 0) {
                        if (!m.signature.contains(""ObservableSource"")) {
                            e.append(""java.lang.RuntimeException: Maybe doc mentions ObservableSource but not in the signature\r\n at io.reactivex.rxjava3.core."")
                            .append(""Maybe.method(Maybe.java:"").append(m.javadocLine + lineNumber(m.javadoc, idx) - 1).append("")\r\n\r\n"");
                        }
                        jdx = idx + 6;
                    } else {
                        break;
                    }
                }",break_loop_control
m,"for (RxMethod m : list) {
            int jdx;
            if (m.javadoc != null) {
                jdx = 0;
                for (;;) {
                    int idx = m.javadoc.indexOf(""onSuccess"", jdx);
                    if (idx >= 0) {
                        if (!m.signature.contains(""Maybe"")
                                && !m.signature.contains(""MaybeSource"")
                                && !m.signature.contains(""Single"")
                                && !m.signature.contains(""SingleSource"")) {
                            e.append(""java.lang.RuntimeException: Flowable doc mentions onSuccess\r\n at io.reactivex.rxjava3.core."")
                            .append(""Flowable.method(Flowable.java:"").append(m.javadocLine + lineNumber(m.javadoc, idx) - 1).append("")\r\n\r\n"");
                        }

                        jdx = idx + 6;
                    } else {
                        break;
                    }
                }
                jdx = 0;
                for (;;) {
                    int idx = m.javadoc.indexOf("" Observer"", jdx);
                    if (idx >= 0) {
                        if (!m.signature.contains(""ObservableSource"")
                                && !m.signature.contains(""Observable"")) {
                            e.append(""java.lang.RuntimeException: Flowable doc mentions Observer but not using Observable\r\n at io.reactivex.rxjava3.core."")
                            .append(""Flowable.method(Flowable.java:"").append(m.javadocLine + lineNumber(m.javadoc, idx) - 1).append("")\r\n\r\n"");
                        }

                        jdx = idx + 6;
                    } else {
                        break;
                    }
                }
                jdx = 0;
                for (;;) {
                    int idx = m.javadoc.indexOf("" SingleObserver"", jdx);
                    if (idx >= 0) {
                        if (!m.signature.contains(""SingleSource"")
                                && !m.signature.contains(""Single"")) {
                            e.append(""java.lang.RuntimeException: Flowable doc mentions SingleObserver but not using Single\r\n at io.reactivex.rxjava3.core."")
                            .append(""Flowable.method(Flowable.java:"").append(m.javadocLine + lineNumber(m.javadoc, idx) - 1).append("")\r\n\r\n"");
                        }

                        jdx = idx + 6;
                    } else {
                        break;
                    }
                }
                jdx = 0;
                for (;;) {
                    int idx = m.javadoc.indexOf("" MaybeObserver"", jdx);
                    if (idx >= 0) {
                        if (!m.signature.contains(""MaybeSource"")
                                && !m.signature.contains(""Maybe"")) {
                            e.append(""java.lang.RuntimeException: Flowable doc mentions MaybeObserver but not using Maybe\r\n at io.reactivex.rxjava3.core."")
                            .append(""Flowable.method(Flowable.java:"").append(m.javadocLine + lineNumber(m.javadoc, idx) - 1).append("")\r\n\r\n"");
                        }

                        jdx = idx + 6;
                    } else {
                        break;
                    }
                }
                jdx = 0;
                for (;;) {
                    int idx = m.javadoc.indexOf("" Disposable"", jdx);
                    if (idx >= 0) {
                        if (!m.signature.contains(""Observable"")
                                && !m.signature.contains(""ObservableSource"")
                                && !m.signature.contains(""Single"")
                                && !m.signature.contains(""SingleSource"")
                                && !m.signature.contains(""Completable"")
                                && !m.signature.contains(""CompletableSource"")
                                && !m.signature.contains(""Maybe"")
                                && !m.signature.contains(""MaybeSource"")
                                && !m.signature.contains(""Disposable"")
                                && !m.signature.contains(""void subscribe"")
                        ) {
                            CharSequence subSequence = m.javadoc.subSequence(idx - 6, idx + 11);
                            if (idx < 6 || !subSequence.equals(""{@link Disposable"")) {
                                e.append(""java.lang.RuntimeException: Flowable doc mentions Disposable but not using Flowable\r\n at io.reactivex.rxjava3.core."")
                                .append(""Flowable.method(Flowable.java:"").append(m.javadocLine + lineNumber(m.javadoc, idx) - 1).append("")\r\n\r\n"");
                            }
                        }

                        jdx = idx + 6;
                    } else {
                        break;
                    }
                }
                jdx = 0;
                for (;;) {
                    int idx = m.javadoc.indexOf(""Observable"", jdx);
                    if (idx >= 0) {
                        if (!m.signature.contains(""Observable"")) {
                            e.append(""java.lang.RuntimeException: Flowable doc mentions Observable but not in the signature\r\n at io.reactivex.rxjava3.core."")
                            .append(""Flowable.method(Flowable.java:"").append(m.javadocLine + lineNumber(m.javadoc, idx) - 1).append("")\r\n\r\n"");
                        }

                        jdx = idx + 6;
                    } else {
                        break;
                    }
                }
                jdx = 0;
                for (;;) {
                    int idx = m.javadoc.indexOf(""ObservableSource"", jdx);
                    if (idx >= 0) {
                        if (!m.signature.contains(""ObservableSource"")) {
                            e.append(""java.lang.RuntimeException: Flowable doc mentions ObservableSource but not in the signature\r\n at io.reactivex.rxjava3.core."")
                            .append(""Flowable.method(Flowable.java:"").append(m.javadocLine + lineNumber(m.javadoc, idx) - 1).append("")\r\n\r\n"");
                        }
                        jdx = idx + 6;
                    } else {
                        break;
                    }
                }

                checkAtReturnAndSignatureMatch(""Flowable"", m, e, ""Flowable"", ""Observable"", ""Maybe"", ""Single"", ""Completable"", ""ConnectableFlowable"", ""ParallelFlowable"", ""Disposable"", ""Iterable"", ""Stream"", ""Future"", ""CompletionStage"");

                aOrAn(e, m, ""Flowable"");
                missingClosingDD(e, m, ""Flowable"", ""io.reactivex.rxjava3.core"");
                backpressureMentionedWithoutAnnotation(e, m, ""Flowable"");
            }
        }",iterator
idx,"for (;;) {
                    int idx = m.javadoc.indexOf(""onSuccess"", jdx);
                    if (idx >= 0) {
                        if (!m.signature.contains(""Maybe"")
                                && !m.signature.contains(""MaybeSource"")
                                && !m.signature.contains(""Single"")
                                && !m.signature.contains(""SingleSource"")) {
                            e.append(""java.lang.RuntimeException: Flowable doc mentions onSuccess\r\n at io.reactivex.rxjava3.core."")
                            .append(""Flowable.method(Flowable.java:"").append(m.javadocLine + lineNumber(m.javadoc, idx) - 1).append("")\r\n\r\n"");
                        }

                        jdx = idx + 6;
                    } else {
                        break;
                    }
                }",break_loop_control
idx,"for (;;) {
                    int idx = m.javadoc.indexOf("" Observer"", jdx);
                    if (idx >= 0) {
                        if (!m.signature.contains(""ObservableSource"")
                                && !m.signature.contains(""Observable"")) {
                            e.append(""java.lang.RuntimeException: Flowable doc mentions Observer but not using Observable\r\n at io.reactivex.rxjava3.core."")
                            .append(""Flowable.method(Flowable.java:"").append(m.javadocLine + lineNumber(m.javadoc, idx) - 1).append("")\r\n\r\n"");
                        }

                        jdx = idx + 6;
                    } else {
                        break;
                    }
                }",break_loop_control
idx,"for (;;) {
                    int idx = m.javadoc.indexOf("" SingleObserver"", jdx);
                    if (idx >= 0) {
                        if (!m.signature.contains(""SingleSource"")
                                && !m.signature.contains(""Single"")) {
                            e.append(""java.lang.RuntimeException: Flowable doc mentions SingleObserver but not using Single\r\n at io.reactivex.rxjava3.core."")
                            .append(""Flowable.method(Flowable.java:"").append(m.javadocLine + lineNumber(m.javadoc, idx) - 1).append("")\r\n\r\n"");
                        }

                        jdx = idx + 6;
                    } else {
                        break;
                    }
                }",break_loop_control
idx,"for (;;) {
                    int idx = m.javadoc.indexOf("" MaybeObserver"", jdx);
                    if (idx >= 0) {
                        if (!m.signature.contains(""MaybeSource"")
                                && !m.signature.contains(""Maybe"")) {
                            e.append(""java.lang.RuntimeException: Flowable doc mentions MaybeObserver but not using Maybe\r\n at io.reactivex.rxjava3.core."")
                            .append(""Flowable.method(Flowable.java:"").append(m.javadocLine + lineNumber(m.javadoc, idx) - 1).append("")\r\n\r\n"");
                        }

                        jdx = idx + 6;
                    } else {
                        break;
                    }
                }",break_loop_control
idx,"for (;;) {
                    int idx = m.javadoc.indexOf("" Disposable"", jdx);
                    if (idx >= 0) {
                        if (!m.signature.contains(""Observable"")
                                && !m.signature.contains(""ObservableSource"")
                                && !m.signature.contains(""Single"")
                                && !m.signature.contains(""SingleSource"")
                                && !m.signature.contains(""Completable"")
                                && !m.signature.contains(""CompletableSource"")
                                && !m.signature.contains(""Maybe"")
                                && !m.signature.contains(""MaybeSource"")
                                && !m.signature.contains(""Disposable"")
                                && !m.signature.contains(""void subscribe"")
                        ) {
                            CharSequence subSequence = m.javadoc.subSequence(idx - 6, idx + 11);
                            if (idx < 6 || !subSequence.equals(""{@link Disposable"")) {
                                e.append(""java.lang.RuntimeException: Flowable doc mentions Disposable but not using Flowable\r\n at io.reactivex.rxjava3.core."")
                                .append(""Flowable.method(Flowable.java:"").append(m.javadocLine + lineNumber(m.javadoc, idx) - 1).append("")\r\n\r\n"");
                            }
                        }

                        jdx = idx + 6;
                    } else {
                        break;
                    }
                }",break_loop_control
idx,"for (;;) {
                    int idx = m.javadoc.indexOf(""Observable"", jdx);
                    if (idx >= 0) {
                        if (!m.signature.contains(""Observable"")) {
                            e.append(""java.lang.RuntimeException: Flowable doc mentions Observable but not in the signature\r\n at io.reactivex.rxjava3.core."")
                            .append(""Flowable.method(Flowable.java:"").append(m.javadocLine + lineNumber(m.javadoc, idx) - 1).append("")\r\n\r\n"");
                        }

                        jdx = idx + 6;
                    } else {
                        break;
                    }
                }",break_loop_control
idx,"for (;;) {
                    int idx = m.javadoc.indexOf(""ObservableSource"", jdx);
                    if (idx >= 0) {
                        if (!m.signature.contains(""ObservableSource"")) {
                            e.append(""java.lang.RuntimeException: Flowable doc mentions ObservableSource but not in the signature\r\n at io.reactivex.rxjava3.core."")
                            .append(""Flowable.method(Flowable.java:"").append(m.javadocLine + lineNumber(m.javadoc, idx) - 1).append("")\r\n\r\n"");
                        }
                        jdx = idx + 6;
                    } else {
                        break;
                    }
                }",break_loop_control
m,"for (RxMethod m : list) {
            int jdx;
            if (m.javadoc != null) {
                jdx = 0;
                for (;;) {
                    int idx = m.javadoc.indexOf(""onSuccess"", jdx);
                    if (idx >= 0) {
                        if (!m.signature.contains(""Maybe"")
                                && !m.signature.contains(""MaybeSource"")
                                && !m.signature.contains(""Single"")
                                && !m.signature.contains(""SingleSource"")) {
                            e.append(""java.lang.RuntimeException: Flowable doc mentions onSuccess\r\n at io.reactivex.rxjava3.core."")
                            .append(""Flowable.method(Flowable.java:"").append(m.javadocLine + lineNumber(m.javadoc, idx) - 1).append("")\r\n\r\n"");
                        }

                        jdx = idx + 6;
                    } else {
                        break;
                    }
                }
                jdx = 0;
                for (;;) {
                    int idx = m.javadoc.indexOf("" Observer"", jdx);
                    if (idx >= 0) {
                        if (!m.signature.contains(""ObservableSource"")
                                && !m.signature.contains(""Observable"")) {
                            e.append(""java.lang.RuntimeException: Flowable doc mentions Observer but not using Observable\r\n at io.reactivex.rxjava3.core."")
                            .append(""Flowable.method(Flowable.java:"").append(m.javadocLine + lineNumber(m.javadoc, idx) - 1).append("")\r\n\r\n"");
                        }

                        jdx = idx + 6;
                    } else {
                        break;
                    }
                }
                jdx = 0;
                for (;;) {
                    int idx = m.javadoc.indexOf("" SingleObserver"", jdx);
                    if (idx >= 0) {
                        if (!m.signature.contains(""SingleSource"")
                                && !m.signature.contains(""Single"")) {
                            e.append(""java.lang.RuntimeException: Flowable doc mentions SingleObserver but not using Single\r\n at io.reactivex.rxjava3.core."")
                            .append(""Flowable.method(Flowable.java:"").append(m.javadocLine + lineNumber(m.javadoc, idx) - 1).append("")\r\n\r\n"");
                        }

                        jdx = idx + 6;
                    } else {
                        break;
                    }
                }
                jdx = 0;
                for (;;) {
                    int idx = m.javadoc.indexOf("" MaybeObserver"", jdx);
                    if (idx >= 0) {
                        if (!m.signature.contains(""MaybeSource"")
                                && !m.signature.contains(""Maybe"")) {
                            e.append(""java.lang.RuntimeException: Flowable doc mentions MaybeObserver but not using Maybe\r\n at io.reactivex.rxjava3.core."")
                            .append(""Flowable.method(Flowable.java:"").append(m.javadocLine + lineNumber(m.javadoc, idx) - 1).append("")\r\n\r\n"");
                        }

                        jdx = idx + 6;
                    } else {
                        break;
                    }
                }
                jdx = 0;
                for (;;) {
                    int idx = m.javadoc.indexOf("" Disposable"", jdx);
                    if (idx >= 0) {
                        if (!m.signature.contains(""Observable"")
                                && !m.signature.contains(""ObservableSource"")
                                && !m.signature.contains(""Single"")
                                && !m.signature.contains(""SingleSource"")
                                && !m.signature.contains(""Completable"")
                                && !m.signature.contains(""CompletableSource"")
                                && !m.signature.contains(""Maybe"")
                                && !m.signature.contains(""MaybeSource"")
                                && !m.signature.contains(""Disposable"")
                        ) {
                            CharSequence subSequence = m.javadoc.subSequence(idx - 6, idx + 11);
                            if (idx < 6 || !subSequence.equals(""{@link Disposable"")) {
                                e.append(""java.lang.RuntimeException: Flowable doc mentions Disposable but not using Flowable\r\n at io.reactivex.rxjava3.core."")
                                .append(""Flowable.method(Flowable.java:"").append(m.javadocLine + lineNumber(m.javadoc, idx) - 1).append("")\r\n\r\n"");
                            }
                        }

                        jdx = idx + 6;
                    } else {
                        break;
                    }
                }
                jdx = 0;
                for (;;) {
                    int idx = m.javadoc.indexOf(""Observable"", jdx);
                    if (idx >= 0) {
                        if (!m.signature.contains(""Observable"")) {
                            e.append(""java.lang.RuntimeException: Flowable doc mentions Observable but not in the signature\r\n at io.reactivex.rxjava3.core."")
                            .append(""Flowable.method(Flowable.java:"").append(m.javadocLine + lineNumber(m.javadoc, idx) - 1).append("")\r\n\r\n"");
                        }

                        jdx = idx + 6;
                    } else {
                        break;
                    }
                }
                jdx = 0;
                for (;;) {
                    int idx = m.javadoc.indexOf(""ObservableSource"", jdx);
                    if (idx >= 0) {
                        if (!m.signature.contains(""ObservableSource"")) {
                            e.append(""java.lang.RuntimeException: Flowable doc mentions ObservableSource but not in the signature\r\n at io.reactivex.rxjava3.core."")
                            .append(""Flowable.method(Flowable.java:"").append(m.javadocLine + lineNumber(m.javadoc, idx) - 1).append("")\r\n\r\n"");
                        }
                        jdx = idx + 6;
                    } else {
                        break;
                    }
                }

                checkAtReturnAndSignatureMatch(""ParallelFlowable"", m, e, ""Flowable"", ""Observable"", ""Maybe"", ""Single"", ""Completable"", ""ConnectableFlowable"", ""ParallelFlowable"", ""Disposable"", ""Iterable"", ""Stream"", ""Future"", ""CompletionStage"");

                aOrAn(e, m, ""ParallelFlowable"");
                missingClosingDD(e, m, ""ParallelFlowable"", ""io.reactivex.rxjava3.parallel"");
                backpressureMentionedWithoutAnnotation(e, m, ""ParallelFlowable"");
            }
        }",iterator
idx,"for (;;) {
                    int idx = m.javadoc.indexOf(""onSuccess"", jdx);
                    if (idx >= 0) {
                        if (!m.signature.contains(""Maybe"")
                                && !m.signature.contains(""MaybeSource"")
                                && !m.signature.contains(""Single"")
                                && !m.signature.contains(""SingleSource"")) {
                            e.append(""java.lang.RuntimeException: Flowable doc mentions onSuccess\r\n at io.reactivex.rxjava3.core."")
                            .append(""Flowable.method(Flowable.java:"").append(m.javadocLine + lineNumber(m.javadoc, idx) - 1).append("")\r\n\r\n"");
                        }

                        jdx = idx + 6;
                    } else {
                        break;
                    }
                }",break_loop_control
idx,"for (;;) {
                    int idx = m.javadoc.indexOf("" Observer"", jdx);
                    if (idx >= 0) {
                        if (!m.signature.contains(""ObservableSource"")
                                && !m.signature.contains(""Observable"")) {
                            e.append(""java.lang.RuntimeException: Flowable doc mentions Observer but not using Observable\r\n at io.reactivex.rxjava3.core."")
                            .append(""Flowable.method(Flowable.java:"").append(m.javadocLine + lineNumber(m.javadoc, idx) - 1).append("")\r\n\r\n"");
                        }

                        jdx = idx + 6;
                    } else {
                        break;
                    }
                }",break_loop_control
idx,"for (;;) {
                    int idx = m.javadoc.indexOf("" SingleObserver"", jdx);
                    if (idx >= 0) {
                        if (!m.signature.contains(""SingleSource"")
                                && !m.signature.contains(""Single"")) {
                            e.append(""java.lang.RuntimeException: Flowable doc mentions SingleObserver but not using Single\r\n at io.reactivex.rxjava3.core."")
                            .append(""Flowable.method(Flowable.java:"").append(m.javadocLine + lineNumber(m.javadoc, idx) - 1).append("")\r\n\r\n"");
                        }

                        jdx = idx + 6;
                    } else {
                        break;
                    }
                }",break_loop_control
idx,"for (;;) {
                    int idx = m.javadoc.indexOf("" MaybeObserver"", jdx);
                    if (idx >= 0) {
                        if (!m.signature.contains(""MaybeSource"")
                                && !m.signature.contains(""Maybe"")) {
                            e.append(""java.lang.RuntimeException: Flowable doc mentions MaybeObserver but not using Maybe\r\n at io.reactivex.rxjava3.core."")
                            .append(""Flowable.method(Flowable.java:"").append(m.javadocLine + lineNumber(m.javadoc, idx) - 1).append("")\r\n\r\n"");
                        }

                        jdx = idx + 6;
                    } else {
                        break;
                    }
                }",break_loop_control
idx,"for (;;) {
                    int idx = m.javadoc.indexOf("" Disposable"", jdx);
                    if (idx >= 0) {
                        if (!m.signature.contains(""Observable"")
                                && !m.signature.contains(""ObservableSource"")
                                && !m.signature.contains(""Single"")
                                && !m.signature.contains(""SingleSource"")
                                && !m.signature.contains(""Completable"")
                                && !m.signature.contains(""CompletableSource"")
                                && !m.signature.contains(""Maybe"")
                                && !m.signature.contains(""MaybeSource"")
                                && !m.signature.contains(""Disposable"")
                        ) {
                            CharSequence subSequence = m.javadoc.subSequence(idx - 6, idx + 11);
                            if (idx < 6 || !subSequence.equals(""{@link Disposable"")) {
                                e.append(""java.lang.RuntimeException: Flowable doc mentions Disposable but not using Flowable\r\n at io.reactivex.rxjava3.core."")
                                .append(""Flowable.method(Flowable.java:"").append(m.javadocLine + lineNumber(m.javadoc, idx) - 1).append("")\r\n\r\n"");
                            }
                        }

                        jdx = idx + 6;
                    } else {
                        break;
                    }
                }",break_loop_control
idx,"for (;;) {
                    int idx = m.javadoc.indexOf(""Observable"", jdx);
                    if (idx >= 0) {
                        if (!m.signature.contains(""Observable"")) {
                            e.append(""java.lang.RuntimeException: Flowable doc mentions Observable but not in the signature\r\n at io.reactivex.rxjava3.core."")
                            .append(""Flowable.method(Flowable.java:"").append(m.javadocLine + lineNumber(m.javadoc, idx) - 1).append("")\r\n\r\n"");
                        }

                        jdx = idx + 6;
                    } else {
                        break;
                    }
                }",break_loop_control
idx,"for (;;) {
                    int idx = m.javadoc.indexOf(""ObservableSource"", jdx);
                    if (idx >= 0) {
                        if (!m.signature.contains(""ObservableSource"")) {
                            e.append(""java.lang.RuntimeException: Flowable doc mentions ObservableSource but not in the signature\r\n at io.reactivex.rxjava3.core."")
                            .append(""Flowable.method(Flowable.java:"").append(m.javadocLine + lineNumber(m.javadoc, idx) - 1).append("")\r\n\r\n"");
                        }
                        jdx = idx + 6;
                    } else {
                        break;
                    }
                }",break_loop_control
m,"for (RxMethod m : list) {
            int jdx;
            if (m.javadoc != null) {
                jdx = 0;
                for (;;) {
                    int idx = m.javadoc.indexOf(""onSuccess"", jdx);
                    if (idx >= 0) {
                        if (!m.signature.contains(""Maybe"")
                                && !m.signature.contains(""MaybeSource"")
                                && !m.signature.contains(""Single"")
                                && !m.signature.contains(""SingleSource"")) {
                            e.append(""java.lang.RuntimeException: Observable doc mentions onSuccess\r\n at io.reactivex.rxjava3.core."")
                            .append(""Observable.method(Observable.java:"").append(m.javadocLine + lineNumber(m.javadoc, idx) - 1).append("")\r\n\r\n"");
                        }

                        jdx = idx + 6;
                    } else {
                        break;
                    }
                }
                jdx = 0;
                for (;;) {
                    int idx = m.javadoc.indexOf("" Subscription"", jdx);
                    if (idx >= 0) {
                        if (!m.signature.contains(""Flowable"")
                                && !m.signature.contains(""Publisher"")
                        ) {
                            e.append(""java.lang.RuntimeException: Observable doc mentions Subscription but not using Flowable\r\n at io.reactivex.rxjava3.core."")
                            .append(""Observable.method(Observable.java:"").append(m.javadocLine + lineNumber(m.javadoc, idx) - 1).append("")\r\n\r\n"");
                        }

                        jdx = idx + 6;
                    } else {
                        break;
                    }
                }
                jdx = 0;
                for (;;) {
                    int idx = m.javadoc.indexOf(""Flowable"", jdx);
                    if (idx >= 0) {
                        if (!m.signature.contains(""Flowable"")) {
                            if (idx < 6 || !m.javadoc.substring(idx - 6, idx + 8).equals(""@link Flowable"")) {
                                e.append(""java.lang.RuntimeException: Observable doc mentions Flowable but not in the signature\r\n at io.reactivex.rxjava3.core."")
                                .append(""Observable.method(Observable.java:"").append(m.javadocLine + lineNumber(m.javadoc, idx) - 1).append("")\r\n\r\n"");
                            }
                        }

                        jdx = idx + 6;
                    } else {
                        break;
                    }
                }
                jdx = 0;
                for (;;) {
                    int idx = m.javadoc.indexOf(""Publisher"", jdx);
                    if (idx >= 0) {
                        if (!m.signature.contains(""Publisher"")) {
                            e.append(""java.lang.RuntimeException: Observable doc mentions Publisher but not in the signature\r\n at io.reactivex.rxjava3.core."")
                            .append(""Observable.method(Observable.java:"").append(m.javadocLine + lineNumber(m.javadoc, idx) - 1).append("")\r\n\r\n"");
                        }
                        jdx = idx + 6;
                    } else {
                        break;
                    }
                }
                jdx = 0;
                for (;;) {
                    int idx = m.javadoc.indexOf(""Subscriber"", jdx);
                    if (idx >= 0) {
                        if (!m.signature.contains(""Publisher"")
                                && !m.signature.contains(""Flowable"")) {
                            e.append(""java.lang.RuntimeException: Observable doc mentions Subscriber but not using Flowable\r\n at io.reactivex.rxjava3.core."")
                            .append(""Observable.method(Observable.java:"").append(m.javadocLine + lineNumber(m.javadoc, idx) - 1).append("")\r\n\r\n"");
                        }

                        jdx = idx + 6;
                    } else {
                        break;
                    }
                }
                checkAtReturnAndSignatureMatch(""Observable"", m, e, ""Flowable"", ""Observable"", ""Maybe"", ""Single"", ""Completable"", ""ConnectableObservable"", ""Disposable"", ""Iterable"", ""Stream"", ""Future"", ""CompletionStage"");

                aOrAn(e, m, ""Observable"");
                missingClosingDD(e, m, ""Observable"", ""io.reactivex.rxjava3.core"");
                backpressureMentionedWithoutAnnotation(e, m, ""Observable"");
            }
        }",iterator
idx,"for (;;) {
                    int idx = m.javadoc.indexOf(""onSuccess"", jdx);
                    if (idx >= 0) {
                        if (!m.signature.contains(""Maybe"")
                                && !m.signature.contains(""MaybeSource"")
                                && !m.signature.contains(""Single"")
                                && !m.signature.contains(""SingleSource"")) {
                            e.append(""java.lang.RuntimeException: Observable doc mentions onSuccess\r\n at io.reactivex.rxjava3.core."")
                            .append(""Observable.method(Observable.java:"").append(m.javadocLine + lineNumber(m.javadoc, idx) - 1).append("")\r\n\r\n"");
                        }

                        jdx = idx + 6;
                    } else {
                        break;
                    }
                }",maybe_loop_control
idx,"for (;;) {
                    int idx = m.javadoc.indexOf("" Subscription"", jdx);
                    if (idx >= 0) {
                        if (!m.signature.contains(""Flowable"")
                                && !m.signature.contains(""Publisher"")
                        ) {
                            e.append(""java.lang.RuntimeException: Observable doc mentions Subscription but not using Flowable\r\n at io.reactivex.rxjava3.core."")
                            .append(""Observable.method(Observable.java:"").append(m.javadocLine + lineNumber(m.javadoc, idx) - 1).append("")\r\n\r\n"");
                        }

                        jdx = idx + 6;
                    } else {
                        break;
                    }
                }",maybe_loop_control
idx,"for (;;) {
                    int idx = m.javadoc.indexOf(""Flowable"", jdx);
                    if (idx >= 0) {
                        if (!m.signature.contains(""Flowable"")) {
                            if (idx < 6 || !m.javadoc.substring(idx - 6, idx + 8).equals(""@link Flowable"")) {
                                e.append(""java.lang.RuntimeException: Observable doc mentions Flowable but not in the signature\r\n at io.reactivex.rxjava3.core."")
                                .append(""Observable.method(Observable.java:"").append(m.javadocLine + lineNumber(m.javadoc, idx) - 1).append("")\r\n\r\n"");
                            }
                        }

                        jdx = idx + 6;
                    } else {
                        break;
                    }
                }",maybe_loop_control
idx,"for (;;) {
                    int idx = m.javadoc.indexOf(""Publisher"", jdx);
                    if (idx >= 0) {
                        if (!m.signature.contains(""Publisher"")) {
                            e.append(""java.lang.RuntimeException: Observable doc mentions Publisher but not in the signature\r\n at io.reactivex.rxjava3.core."")
                            .append(""Observable.method(Observable.java:"").append(m.javadocLine + lineNumber(m.javadoc, idx) - 1).append("")\r\n\r\n"");
                        }
                        jdx = idx + 6;
                    } else {
                        break;
                    }
                }",maybe_loop_control
idx,"for (;;) {
                    int idx = m.javadoc.indexOf(""Subscriber"", jdx);
                    if (idx >= 0) {
                        if (!m.signature.contains(""Publisher"")
                                && !m.signature.contains(""Flowable"")) {
                            e.append(""java.lang.RuntimeException: Observable doc mentions Subscriber but not using Flowable\r\n at io.reactivex.rxjava3.core."")
                            .append(""Observable.method(Observable.java:"").append(m.javadocLine + lineNumber(m.javadoc, idx) - 1).append("")\r\n\r\n"");
                        }

                        jdx = idx + 6;
                    } else {
                        break;
                    }
                }",maybe_loop_control
idx,"for (;;) {
                    int idx = m.javadoc.indexOf(""onNext"", jdx);
                    if (idx >= 0) {
                        if (!m.signature.contains(""Publisher"")
                                && !m.signature.contains(""Flowable"")
                                && !m.signature.contains(""Observable"")
                                && !m.signature.contains(""ObservableSource"")) {
                            e.append(""java.lang.RuntimeException: Single doc mentions onNext but no Flowable/Observable in signature\r\n at io.reactivex.rxjava3.core."")
                            .append(""Single.method(Single.java:"").append(m.javadocLine + lineNumber(m.javadoc, idx) - 1).append("")\r\n\r\n"");
                        }

                        jdx = idx + 6;
                    } else {
                        break;
                    }
                }",break_loop_control
idx,"for (;;) {
                    int idx = m.javadoc.indexOf(""Subscriber"", jdx);
                    if (idx >= 0) {
                        if (!m.signature.contains(""Publisher"")
                                && !m.signature.contains(""Flowable"")
                                && !m.signature.contains(""TestSubscriber"")) {
                            e.append(""java.lang.RuntimeException: Single doc mentions Subscriber but not using Flowable\r\n at io.reactivex.rxjava3.core."")
                            .append(""Single.method(Single.java:"").append(m.javadocLine + lineNumber(m.javadoc, idx) - 1).append("")\r\n\r\n"");
                        }

                        jdx = idx + 6;
                    } else {
                        break;
                    }
                }",break_loop_control
idx,"for (;;) {
                    int idx = m.javadoc.indexOf("" Subscription"", jdx);
                    if (idx >= 0) {
                        if (!m.signature.contains(""Flowable"")
                                && !m.signature.contains(""Publisher"")
                        ) {
                            e.append(""java.lang.RuntimeException: Single doc mentions Subscription but not using Flowable\r\n at io.reactivex.rxjava3.core."")
                            .append(""Single.method(Single.java:"").append(m.javadocLine + lineNumber(m.javadoc, idx) - 1).append("")\r\n\r\n"");
                        }

                        jdx = idx + 6;
                    } else {
                        break;
                    }
                }",break_loop_control
idx,"for (;;) {
                    int idx = m.javadoc.indexOf(""Observer"", jdx);
                    if (idx >= 0) {
                        if (!m.signature.contains(""ObservableSource"")
                                && !m.signature.contains(""Observable"")
                                && !m.signature.contains(""TestObserver"")) {

                            if (idx < 6 || !m.javadoc.substring(idx - 6, idx + 8).equals(""SingleObserver"")) {
                                e.append(""java.lang.RuntimeException: Single doc mentions Observer but not using Observable\r\n at io.reactivex.rxjava3.core."")
                                .append(""Single.method(Single.java:"").append(m.javadocLine + lineNumber(m.javadoc, idx) - 1).append("")\r\n\r\n"");
                            }
                        }

                        jdx = idx + 6;
                    } else {
                        break;
                    }
                }",break_loop_control
idx,"for (;;) {
                    int idx = m.javadoc.indexOf(""Publisher"", jdx);
                    if (idx >= 0) {
                        if (!m.signature.contains(""Publisher"")) {
                            if (idx == 0 || !m.javadoc.substring(idx - 1, idx + 9).equals(""(Publisher"")) {
                                e.append(""java.lang.RuntimeException: Single doc mentions Publisher but not in the signature\r\n at io.reactivex.rxjava3.core."")
                                .append(""Single.method(Single.java:"").append(m.javadocLine + lineNumber(m.javadoc, idx) - 1).append("")\r\n\r\n"");
                            }
                        }

                        jdx = idx + 6;
                    } else {
                        break;
                    }
                }",break_loop_control
idx,"for (;;) {
                    int idx = m.javadoc.indexOf("" Flowable"", jdx);
                    if (idx >= 0) {
                        if (!m.signature.contains(""Flowable"")) {
                            e.append(""java.lang.RuntimeException: Single doc mentions Flowable but not in the signature\r\n at io.reactivex.rxjava3.core."")
                            .append(""Single.method(Single.java:"").append(m.javadocLine + lineNumber(m.javadoc, idx) - 1).append("")\r\n\r\n"");
                        }
                        jdx = idx + 6;
                    } else {
                        break;
                    }
                }",break_loop_control
idx,"for (;;) {
                    int idx = m.javadoc.indexOf("" Maybe"", jdx);
                    if (idx >= 0) {
                        if (!m.signature.contains(""Maybe"")) {
                            e.append(""java.lang.RuntimeException: Single doc mentions Maybe but not in the signature\r\n at io.reactivex.rxjava3.core."")
                            .append(""Single.method(Single.java:"").append(m.javadocLine + lineNumber(m.javadoc, idx) - 1).append("")\r\n\r\n"");
                        }
                        jdx = idx + 6;
                    } else {
                        break;
                    }
                }",break_loop_control
idx,"for (;;) {
                    int idx = m.javadoc.indexOf("" MaybeSource"", jdx);
                    if (idx >= 0) {
                        if (!m.signature.contains(""MaybeSource"")) {
                            e.append(""java.lang.RuntimeException: Single doc mentions SingleSource but not in the signature\r\n at io.reactivex.rxjava3.core."")
                            .append(""Maybe.method(Maybe.java:"").append(m.javadocLine + lineNumber(m.javadoc, idx) - 1).append("")\r\n\r\n"");
                        }
                        jdx = idx + 6;
                    } else {
                        break;
                    }
                }",break_loop_control
idx,"for (;;) {
                    int idx = m.javadoc.indexOf("" Observable"", jdx);
                    if (idx >= 0) {
                        if (!m.signature.contains(""Observable"")) {
                            e.append(""java.lang.RuntimeException: Single doc mentions Observable but not in the signature\r\n at io.reactivex.rxjava3.core."")
                            .append(""Single.method(Single.java:"").append(m.javadocLine + lineNumber(m.javadoc, idx) - 1).append("")\r\n\r\n"");
                        }
                        jdx = idx + 6;
                    } else {
                        break;
                    }
                }",break_loop_control
idx,"for (;;) {
                    int idx = m.javadoc.indexOf("" ObservableSource"", jdx);
                    if (idx >= 0) {
                        if (!m.signature.contains(""ObservableSource"")) {
                            e.append(""java.lang.RuntimeException: Single doc mentions ObservableSource but not in the signature\r\n at io.reactivex.rxjava3.core."")
                            .append(""Single.method(Single.java:"").append(m.javadocLine + lineNumber(m.javadoc, idx) - 1).append("")\r\n\r\n"");
                        }
                        jdx = idx + 6;
                    } else {
                        break;
                    }
                }",break_loop_control
m,"for (RxMethod m : list) {
            int jdx;
            if (m.javadoc != null) {
                jdx = 0;
                for (;;) {
                    int idx = m.javadoc.indexOf(""onNext"", jdx);
                    if (idx >= 0) {
                        if (!m.signature.contains(""Publisher"")
                                && !m.signature.contains(""Flowable"")
                                && !m.signature.contains(""Observable"")
                                && !m.signature.contains(""ObservableSource"")) {
                            e.append(""java.lang.RuntimeException: Single doc mentions onNext but no Flowable/Observable in signature\r\n at io.reactivex.rxjava3.core."")
                            .append(""Single.method(Single.java:"").append(m.javadocLine + lineNumber(m.javadoc, idx) - 1).append("")\r\n\r\n"");
                        }

                        jdx = idx + 6;
                    } else {
                        break;
                    }
                }
                jdx = 0;
                for (;;) {
                    int idx = m.javadoc.indexOf(""Subscriber"", jdx);
                    if (idx >= 0) {
                        if (!m.signature.contains(""Publisher"")
                                && !m.signature.contains(""Flowable"")
                                && !m.signature.contains(""TestSubscriber"")) {
                            e.append(""java.lang.RuntimeException: Single doc mentions Subscriber but not using Flowable\r\n at io.reactivex.rxjava3.core."")
                            .append(""Single.method(Single.java:"").append(m.javadocLine + lineNumber(m.javadoc, idx) - 1).append("")\r\n\r\n"");
                        }

                        jdx = idx + 6;
                    } else {
                        break;
                    }
                }
                jdx = 0;
                for (;;) {
                    int idx = m.javadoc.indexOf("" Subscription"", jdx);
                    if (idx >= 0) {
                        if (!m.signature.contains(""Flowable"")
                                && !m.signature.contains(""Publisher"")
                        ) {
                            e.append(""java.lang.RuntimeException: Single doc mentions Subscription but not using Flowable\r\n at io.reactivex.rxjava3.core."")
                            .append(""Single.method(Single.java:"").append(m.javadocLine + lineNumber(m.javadoc, idx) - 1).append("")\r\n\r\n"");
                        }

                        jdx = idx + 6;
                    } else {
                        break;
                    }
                }
                jdx = 0;
                for (;;) {
                    int idx = m.javadoc.indexOf(""Observer"", jdx);
                    if (idx >= 0) {
                        if (!m.signature.contains(""ObservableSource"")
                                && !m.signature.contains(""Observable"")
                                && !m.signature.contains(""TestObserver"")) {

                            if (idx < 6 || !m.javadoc.substring(idx - 6, idx + 8).equals(""SingleObserver"")) {
                                e.append(""java.lang.RuntimeException: Single doc mentions Observer but not using Observable\r\n at io.reactivex.rxjava3.core."")
                                .append(""Single.method(Single.java:"").append(m.javadocLine + lineNumber(m.javadoc, idx) - 1).append("")\r\n\r\n"");
                            }
                        }

                        jdx = idx + 6;
                    } else {
                        break;
                    }
                }
                jdx = 0;
                for (;;) {
                    int idx = m.javadoc.indexOf(""Publisher"", jdx);
                    if (idx >= 0) {
                        if (!m.signature.contains(""Publisher"")) {
                            if (idx == 0 || !m.javadoc.substring(idx - 1, idx + 9).equals(""(Publisher"")) {
                                e.append(""java.lang.RuntimeException: Single doc mentions Publisher but not in the signature\r\n at io.reactivex.rxjava3.core."")
                                .append(""Single.method(Single.java:"").append(m.javadocLine + lineNumber(m.javadoc, idx) - 1).append("")\r\n\r\n"");
                            }
                        }

                        jdx = idx + 6;
                    } else {
                        break;
                    }
                }
                jdx = 0;
                for (;;) {
                    int idx = m.javadoc.indexOf("" Flowable"", jdx);
                    if (idx >= 0) {
                        if (!m.signature.contains(""Flowable"")) {
                            e.append(""java.lang.RuntimeException: Single doc mentions Flowable but not in the signature\r\n at io.reactivex.rxjava3.core."")
                            .append(""Single.method(Single.java:"").append(m.javadocLine + lineNumber(m.javadoc, idx) - 1).append("")\r\n\r\n"");
                        }
                        jdx = idx + 6;
                    } else {
                        break;
                    }
                }
                jdx = 0;
                for (;;) {
                    int idx = m.javadoc.indexOf("" Maybe"", jdx);
                    if (idx >= 0) {
                        if (!m.signature.contains(""Maybe"")) {
                            e.append(""java.lang.RuntimeException: Single doc mentions Maybe but not in the signature\r\n at io.reactivex.rxjava3.core."")
                            .append(""Single.method(Single.java:"").append(m.javadocLine + lineNumber(m.javadoc, idx) - 1).append("")\r\n\r\n"");
                        }
                        jdx = idx + 6;
                    } else {
                        break;
                    }
                }
                jdx = 0;
                for (;;) {
                    int idx = m.javadoc.indexOf("" MaybeSource"", jdx);
                    if (idx >= 0) {
                        if (!m.signature.contains(""MaybeSource"")) {
                            e.append(""java.lang.RuntimeException: Single doc mentions SingleSource but not in the signature\r\n at io.reactivex.rxjava3.core."")
                            .append(""Maybe.method(Maybe.java:"").append(m.javadocLine + lineNumber(m.javadoc, idx) - 1).append("")\r\n\r\n"");
                        }
                        jdx = idx + 6;
                    } else {
                        break;
                    }
                }
                jdx = 0;
                for (;;) {
                    int idx = m.javadoc.indexOf("" Observable"", jdx);
                    if (idx >= 0) {
                        if (!m.signature.contains(""Observable"")) {
                            e.append(""java.lang.RuntimeException: Single doc mentions Observable but not in the signature\r\n at io.reactivex.rxjava3.core."")
                            .append(""Single.method(Single.java:"").append(m.javadocLine + lineNumber(m.javadoc, idx) - 1).append("")\r\n\r\n"");
                        }
                        jdx = idx + 6;
                    } else {
                        break;
                    }
                }
                jdx = 0;
                for (;;) {
                    int idx = m.javadoc.indexOf("" ObservableSource"", jdx);
                    if (idx >= 0) {
                        if (!m.signature.contains(""ObservableSource"")) {
                            e.append(""java.lang.RuntimeException: Single doc mentions ObservableSource but not in the signature\r\n at io.reactivex.rxjava3.core."")
                            .append(""Single.method(Single.java:"").append(m.javadocLine + lineNumber(m.javadoc, idx) - 1).append("")\r\n\r\n"");
                        }
                        jdx = idx + 6;
                    } else {
                        break;
                    }
                }

                checkAtReturnAndSignatureMatch(""Single"", m, e, ""Flowable"", ""Observable"", ""Maybe"", ""Single"", ""Completable"", ""Disposable"", ""Iterable"", ""Stream"", ""Future"", ""CompletionStage"");

                aOrAn(e, m, ""Single"");
                missingClosingDD(e, m, ""Single"", ""io.reactivex.rxjava3.core"");
                backpressureMentionedWithoutAnnotation(e, m, ""Single"");
            }
        }",iterator
m,"for (RxMethod m : list) {
            int jdx;
            if (m.javadoc != null) {
                jdx = 0;
                for (;;) {
                    int idx = m.javadoc.indexOf(""onNext"", jdx);
                    if (idx >= 0) {
                        if (!m.signature.contains(""Publisher"")
                                && !m.signature.contains(""Flowable"")
                                && !m.signature.contains(""Observable"")
                                && !m.signature.contains(""ObservableSource"")) {
                            e.append(""java.lang.RuntimeException: Completable doc mentions onNext but no Flowable/Observable in signature\r\n at io.reactivex.rxjava3.core."")
                            .append(""Completable.method(Completable.java:"").append(m.javadocLine + lineNumber(m.javadoc, idx) - 1).append("")\r\n\r\n"");
                        }

                        jdx = idx + 6;
                    } else {
                        break;
                    }
                }
                jdx = 0;
                for (;;) {
                    int idx = m.javadoc.indexOf(""Subscriber"", jdx);
                    if (idx >= 0) {
                        if (!m.signature.contains(""Publisher"")
                                && !m.signature.contains(""Flowable"")
                                && !m.signature.contains(""TestSubscriber"")) {
                            e.append(""java.lang.RuntimeException: Completable doc mentions Subscriber but not using Flowable\r\n at io.reactivex.rxjava3.core."")
                            .append(""Completable.method(Completable.java:"").append(m.javadocLine + lineNumber(m.javadoc, idx) - 1).append("")\r\n\r\n"");
                        }

                        jdx = idx + 6;
                    } else {
                        break;
                    }
                }
                jdx = 0;
                for (;;) {
                    int idx = m.javadoc.indexOf("" Subscription"", jdx);
                    if (idx >= 0) {
                        if (!m.signature.contains(""Flowable"")
                                && !m.signature.contains(""Publisher"")
                        ) {
                            e.append(""java.lang.RuntimeException: Completable doc mentions Subscription but not using Flowable\r\n at io.reactivex.rxjava3.core."")
                            .append(""Completable.method(Completable.java:"").append(m.javadocLine + lineNumber(m.javadoc, idx) - 1).append("")\r\n\r\n"");
                        }

                        jdx = idx + 6;
                    } else {
                        break;
                    }
                }
                jdx = 0;
                for (;;) {
                    int idx = m.javadoc.indexOf(""Observer"", jdx);
                    if (idx >= 0) {
                        if (!m.signature.contains(""ObservableSource"")
                                && !m.signature.contains(""Observable"")
                                && !m.signature.contains(""TestObserver"")) {

                            if (idx < 11 || !m.javadoc.substring(idx - 11, idx + 8).equals(""CompletableObserver"")) {
                                e.append(""java.lang.RuntimeException: Completable doc mentions Observer but not using Observable\r\n at io.reactivex.rxjava3.core."")
                                .append(""Completable.method(Completable.java:"").append(m.javadocLine + lineNumber(m.javadoc, idx) - 1).append("")\r\n\r\n"");
                            }
                        }

                        jdx = idx + 6;
                    } else {
                        break;
                    }
                }
                jdx = 0;
                for (;;) {
                    int idx = m.javadoc.indexOf(""Publisher"", jdx);
                    if (idx >= 0) {
                        if (!m.signature.contains(""Publisher"")) {
                            if (idx == 0 || !m.javadoc.substring(idx - 1, idx + 9).equals(""(Publisher"")) {
                                e.append(""java.lang.RuntimeException: Completable doc mentions Publisher but not in the signature\r\n at io.reactivex.rxjava3.core."")
                                .append(""Completable.method(Completable.java:"").append(m.javadocLine + lineNumber(m.javadoc, idx) - 1).append("")\r\n\r\n"");
                            }
                        }

                        jdx = idx + 6;
                    } else {
                        break;
                    }
                }
                jdx = 0;
                for (;;) {
                    int idx = m.javadoc.indexOf(""Flowable"", jdx);
                    if (idx >= 0) {
                        if (!m.signature.contains(""Flowable"")) {
                            Pattern p = Pattern.compile(""@see\\s+#[A-Za-z0-9 _.,()]*Flowable"");
                            if (!p.matcher(m.javadoc).find()) {
                                e.append(""java.lang.RuntimeException: Completable doc mentions Flowable but not in the signature\r\n at io.reactivex.rxjava3.core."")
                                .append(""Completable.method(Completable.java:"").append(m.javadocLine + lineNumber(m.javadoc, idx) - 1).append("")\r\n\r\n"");
                            }
                        }
                        jdx = idx + 6;
                    } else {
                        break;
                    }
                }
                jdx = 0;
                for (;;) {
                    int idx = m.javadoc.indexOf(""Single"", jdx);
                    if (idx >= 0) {
                        if (!m.signature.contains(""Single"")) {
                            Pattern p = Pattern.compile(""@see\\s+#[A-Za-z0-9 _.,()]*Single"");
                            if (!p.matcher(m.javadoc).find()) {
                                e.append(""java.lang.RuntimeException: Completable doc mentions Single but not in the signature\r\n at io.reactivex.rxjava3.core."")
                                .append(""Completable.method(Completable.java:"").append(m.javadocLine + lineNumber(m.javadoc, idx) - 1).append("")\r\n\r\n"");
                            }
                        }
                        jdx = idx + 6;
                    } else {
                        break;
                    }
                }
                jdx = 0;
                for (;;) {
                    int idx = m.javadoc.indexOf(""SingleSource"", jdx);
                    if (idx >= 0) {
                        if (!m.signature.contains(""SingleSource"")) {
                            Pattern p = Pattern.compile(""@see\\s+#[A-Za-z0-9 _.,()]*SingleSource"");
                            if (!p.matcher(m.javadoc).find()) {
                                e.append(""java.lang.RuntimeException: Completable doc mentions SingleSource but not in the signature\r\n at io.reactivex.rxjava3.core."")
                                .append(""Completable.method(Completable.java:"").append(m.javadocLine + lineNumber(m.javadoc, idx) - 1).append("")\r\n\r\n"");
                            }
                        }
                        jdx = idx + 6;
                    } else {
                        break;
                    }
                }
                jdx = 0;
                for (;;) {
                    int idx = m.javadoc.indexOf("" Observable"", jdx);
                    if (idx >= 0) {
                        if (!m.signature.contains(""Observable"")) {
                            Pattern p = Pattern.compile(""@see\\s+#[A-Za-z0-9 _.,()]*Observable"");
                            if (!p.matcher(m.javadoc).find()) {
                                e.append(""java.lang.RuntimeException: Completable doc mentions Observable but not in the signature\r\n at io.reactivex.rxjava3.core."")
                                .append(""Completable.method(Completable.java:"").append(m.javadocLine + lineNumber(m.javadoc, idx) - 1).append("")\r\n\r\n"");
                            }
                        }
                        jdx = idx + 6;
                    } else {
                        break;
                    }
                }
                jdx = 0;
                for (;;) {
                    int idx = m.javadoc.indexOf(""ObservableSource"", jdx);
                    if (idx >= 0) {
                        if (!m.signature.contains(""ObservableSource"")) {
                            Pattern p = Pattern.compile(""@see\\s+#[A-Za-z0-9 _.,()]*ObservableSource"");
                            if (!p.matcher(m.javadoc).find()) {
                                e.append(""java.lang.RuntimeException: Completable doc mentions ObservableSource but not in the signature\r\n at io.reactivex.rxjava3.core."")
                                .append(""Completable.method(Completable.java:"").append(m.javadocLine + lineNumber(m.javadoc, idx) - 1).append("")\r\n\r\n"");
                            }
                        }
                        jdx = idx + 6;
                    } else {
                        break;
                    }
                }

                checkAtReturnAndSignatureMatch(""Completable"", m, e, ""Flowable"", ""Observable"", ""Maybe"", ""Single"", ""Completable"", ""Disposable"", ""Iterable"", ""Stream"", ""Future"", ""CompletionStage"");

                aOrAn(e, m, ""Completable"");
                missingClosingDD(e, m, ""Completable"", ""io.reactivex.rxjava3.core"");
                backpressureMentionedWithoutAnnotation(e, m, ""Completable"");
            }
        }",iterator
idx,"for (;;) {
                    int idx = m.javadoc.indexOf(""onNext"", jdx);
                    if (idx >= 0) {
                        if (!m.signature.contains(""Publisher"")
                                && !m.signature.contains(""Flowable"")
                                && !m.signature.contains(""Observable"")
                                && !m.signature.contains(""ObservableSource"")) {
                            e.append(""java.lang.RuntimeException: Completable doc mentions onNext but no Flowable/Observable in signature\r\n at io.reactivex.rxjava3.core."")
                            .append(""Completable.method(Completable.java:"").append(m.javadocLine + lineNumber(m.javadoc, idx) - 1).append("")\r\n\r\n"");
                        }

                        jdx = idx + 6;
                    } else {
                        break;
                    }
                }",break_loop_control
idx,"for (;;) {
                    int idx = m.javadoc.indexOf(""Subscriber"", jdx);
                    if (idx >= 0) {
                        if (!m.signature.contains(""Publisher"")
                                && !m.signature.contains(""Flowable"")
                                && !m.signature.contains(""TestSubscriber"")) {
                            e.append(""java.lang.RuntimeException: Completable doc mentions Subscriber but not using Flowable\r\n at io.reactivex.rxjava3.core."")
                            .append(""Completable.method(Completable.java:"").append(m.javadocLine + lineNumber(m.javadoc, idx) - 1).append("")\r\n\r\n"");
                        }

                        jdx = idx + 6;
                    } else {
                        break;
                    }
                }",break_loop_control
idx,"for (;;) {
                    int idx = m.javadoc.indexOf("" Subscription"", jdx);
                    if (idx >= 0) {
                        if (!m.signature.contains(""Flowable"")
                                && !m.signature.contains(""Publisher"")
                        ) {
                            e.append(""java.lang.RuntimeException: Completable doc mentions Subscription but not using Flowable\r\n at io.reactivex.rxjava3.core."")
                            .append(""Completable.method(Completable.java:"").append(m.javadocLine + lineNumber(m.javadoc, idx) - 1).append("")\r\n\r\n"");
                        }

                        jdx = idx + 6;
                    } else {
                        break;
                    }
                }",break_loop_control
idx,"for (;;) {
                    int idx = m.javadoc.indexOf(""Observer"", jdx);
                    if (idx >= 0) {
                        if (!m.signature.contains(""ObservableSource"")
                                && !m.signature.contains(""Observable"")
                                && !m.signature.contains(""TestObserver"")) {

                            if (idx < 11 || !m.javadoc.substring(idx - 11, idx + 8).equals(""CompletableObserver"")) {
                                e.append(""java.lang.RuntimeException: Completable doc mentions Observer but not using Observable\r\n at io.reactivex.rxjava3.core."")
                                .append(""Completable.method(Completable.java:"").append(m.javadocLine + lineNumber(m.javadoc, idx) - 1).append("")\r\n\r\n"");
                            }
                        }

                        jdx = idx + 6;
                    } else {
                        break;
                    }
                }",break_loop_control
idx,"for (;;) {
                    int idx = m.javadoc.indexOf(""Publisher"", jdx);
                    if (idx >= 0) {
                        if (!m.signature.contains(""Publisher"")) {
                            if (idx == 0 || !m.javadoc.substring(idx - 1, idx + 9).equals(""(Publisher"")) {
                                e.append(""java.lang.RuntimeException: Completable doc mentions Publisher but not in the signature\r\n at io.reactivex.rxjava3.core."")
                                .append(""Completable.method(Completable.java:"").append(m.javadocLine + lineNumber(m.javadoc, idx) - 1).append("")\r\n\r\n"");
                            }
                        }

                        jdx = idx + 6;
                    } else {
                        break;
                    }
                }",break_loop_control
idx,"for (;;) {
                    int idx = m.javadoc.indexOf(""Flowable"", jdx);
                    if (idx >= 0) {
                        if (!m.signature.contains(""Flowable"")) {
                            Pattern p = Pattern.compile(""@see\\s+#[A-Za-z0-9 _.,()]*Flowable"");
                            if (!p.matcher(m.javadoc).find()) {
                                e.append(""java.lang.RuntimeException: Completable doc mentions Flowable but not in the signature\r\n at io.reactivex.rxjava3.core."")
                                .append(""Completable.method(Completable.java:"").append(m.javadocLine + lineNumber(m.javadoc, idx) - 1).append("")\r\n\r\n"");
                            }
                        }
                        jdx = idx + 6;
                    } else {
                        break;
                    }
                }",break_loop_control
idx,"for (;;) {
                    int idx = m.javadoc.indexOf(""Single"", jdx);
                    if (idx >= 0) {
                        if (!m.signature.contains(""Single"")) {
                            Pattern p = Pattern.compile(""@see\\s+#[A-Za-z0-9 _.,()]*Single"");
                            if (!p.matcher(m.javadoc).find()) {
                                e.append(""java.lang.RuntimeException: Completable doc mentions Single but not in the signature\r\n at io.reactivex.rxjava3.core."")
                                .append(""Completable.method(Completable.java:"").append(m.javadocLine + lineNumber(m.javadoc, idx) - 1).append("")\r\n\r\n"");
                            }
                        }
                        jdx = idx + 6;
                    } else {
                        break;
                    }
                }",break_loop_control
idx,"for (;;) {
                    int idx = m.javadoc.indexOf(""SingleSource"", jdx);
                    if (idx >= 0) {
                        if (!m.signature.contains(""SingleSource"")) {
                            Pattern p = Pattern.compile(""@see\\s+#[A-Za-z0-9 _.,()]*SingleSource"");
                            if (!p.matcher(m.javadoc).find()) {
                                e.append(""java.lang.RuntimeException: Completable doc mentions SingleSource but not in the signature\r\n at io.reactivex.rxjava3.core."")
                                .append(""Completable.method(Completable.java:"").append(m.javadocLine + lineNumber(m.javadoc, idx) - 1).append("")\r\n\r\n"");
                            }
                        }
                        jdx = idx + 6;
                    } else {
                        break;
                    }
                }",break_loop_control
idx,"for (;;) {
                    int idx = m.javadoc.indexOf("" Observable"", jdx);
                    if (idx >= 0) {
                        if (!m.signature.contains(""Observable"")) {
                            Pattern p = Pattern.compile(""@see\\s+#[A-Za-z0-9 _.,()]*Observable"");
                            if (!p.matcher(m.javadoc).find()) {
                                e.append(""java.lang.RuntimeException: Completable doc mentions Observable but not in the signature\r\n at io.reactivex.rxjava3.core."")
                                .append(""Completable.method(Completable.java:"").append(m.javadocLine + lineNumber(m.javadoc, idx) - 1).append("")\r\n\r\n"");
                            }
                        }
                        jdx = idx + 6;
                    } else {
                        break;
                    }
                }",break_loop_control
idx,"for (;;) {
                    int idx = m.javadoc.indexOf(""ObservableSource"", jdx);
                    if (idx >= 0) {
                        if (!m.signature.contains(""ObservableSource"")) {
                            Pattern p = Pattern.compile(""@see\\s+#[A-Za-z0-9 _.,()]*ObservableSource"");
                            if (!p.matcher(m.javadoc).find()) {
                                e.append(""java.lang.RuntimeException: Completable doc mentions ObservableSource but not in the signature\r\n at io.reactivex.rxjava3.core."")
                                .append(""Completable.method(Completable.java:"").append(m.javadocLine + lineNumber(m.javadoc, idx) - 1).append("")\r\n\r\n"");
                            }
                        }
                        jdx = idx + 6;
                    } else {
                        break;
                    }
                }",break_loop_control
t,"for (String t : types) {
            String regex;
            if (t.contains(""Completable"")) {
                regex = ""(?s).*?\\s"" + t + ""\\s+\\w+\\(.*"";
            } else {
                regex = ""(?s).*?\\s"" + t + ""\\<.*?\\>\\s+\\w+\\(.*"";
            }
            if (m.signature.matches(regex)) {
                for (String at : AT_RETURN_WORDS) {
                    for (String u : types) {
                        if (!t.equals(u)) {
                            int idx = m.javadoc.indexOf(at + ""{@code "" + u);
                            if (idx >= 0) {
                                e.append(""Returns "").append(t)
                                .append("" but docs return "")
                                .append(u)
                                .append(""\r\n at io.reactivex.rxjava3.core."")
                                .append(className)
                                .append("".method("")
                                .append(className)
                                .append("".java:"")
                                .append(m.javadocLine + lineNumber(m.javadoc, idx) - 1)
                                .append("")\r\n\r\n"");
                            }
                        }
                    }
                }
            }
        }",iterator
at,"for (String at : AT_RETURN_WORDS) {
                    for (String u : types) {
                        if (!t.equals(u)) {
                            int idx = m.javadoc.indexOf(at + ""{@code "" + u);
                            if (idx >= 0) {
                                e.append(""Returns "").append(t)
                                .append("" but docs return "")
                                .append(u)
                                .append(""\r\n at io.reactivex.rxjava3.core."")
                                .append(className)
                                .append("".method("")
                                .append(className)
                                .append("".java:"")
                                .append(m.javadocLine + lineNumber(m.javadoc, idx) - 1)
                                .append("")\r\n\r\n"");
                            }
                        }
                    }
                }",iterator
u,"for (String u : types) {
                        if (!t.equals(u)) {
                            int idx = m.javadoc.indexOf(at + ""{@code "" + u);
                            if (idx >= 0) {
                                e.append(""Returns "").append(t)
                                .append("" but docs return "")
                                .append(u)
                                .append(""\r\n at io.reactivex.rxjava3.core."")
                                .append(className)
                                .append("".method("")
                                .append(className)
                                .append("".java:"")
                                .append(m.javadocLine + lineNumber(m.javadoc, idx) - 1)
                                .append("")\r\n\r\n"");
                            }
                        }
                    }",iterator
idx,"{
        int jdx = 0;
        int idx;
        for (;;) {
            idx = m.javadoc.indexOf(wrongPre + "" "" + word, jdx);
            if (idx >= 0) {
                e.append(""java.lang.RuntimeException: a/an typo "")
                .append(word)
                .append(""\r\n at io.reactivex.rxjava3.core."")
                .append(baseTypeName)
                .append("".method("")
                .append(baseTypeName)
                .append("".java:"").append(m.javadocLine + lineNumber(m.javadoc, idx) - 1).append("")\r\n\r\n"");
                jdx = idx + 6;
            } else {
                break;
            }
        }

        jdx = 0;
        for (;;) {
            idx = m.javadoc.indexOf(wrongPre + "" {@link "" + word, jdx);
            if (idx >= 0) {
                e.append(""java.lang.RuntimeException: a/an typo "")
                .append(word)
                .append(""\r\n at io.reactivex.rxjava3.core."")
                .append(baseTypeName)
                .append("".method("")
                .append(baseTypeName)
                .append("".java:"").append(m.javadocLine + lineNumber(m.javadoc, idx) - 1).append("")\r\n\r\n"");
                jdx = idx + 6;
            } else {
                break;
            }
        }

        jdx = 0;
        for (;;) {
            idx = m.javadoc.indexOf(wrongPre + "" {@linkplain "" + word, jdx);
            if (idx >= 0) {
                e.append(""java.lang.RuntimeException: a/an typo "")
                .append(word)
                .append(""\r\n at io.reactivex.rxjava3.core."")
                .append(baseTypeName)
                .append("".method("")
                .append(baseTypeName)
                .append("".java:"").append(m.javadocLine + lineNumber(m.javadoc, idx) - 1).append("")\r\n\r\n"");
                jdx = idx + 6;
            } else {
                break;
            }
        }

        jdx = 0;
        for (;;) {
            idx = m.javadoc.indexOf(wrongPre + "" {@code "" + word, jdx);
            if (idx >= 0) {
                e.append(""java.lang.RuntimeException: a/an typo "")
                .append(word)
                .append(""\r\n at io.reactivex.rxjava3.core."")
                .append(baseTypeName)
                .append("".method("")
                .append(baseTypeName)
                .append("".java:"").append(m.javadocLine + lineNumber(m.javadoc, idx) - 1).append("")\r\n\r\n"");
                jdx = idx + 6;
            } else {
                break;
            }
        }

        // remove linebreaks and multi-spaces
        String javadoc2 = m.javadoc.replace(""\n"", "" "").replace(""\r"", "" "")
                .replace("" * "", "" "")
                .replaceAll(""\\s+"", "" "");

        // strip {@xxx } tags
        int kk = 0;
        for (;;) {
            int jj = javadoc2.indexOf(""{@"", kk);
            if (jj < 0) {
                break;
            }
            int nn = javadoc2.indexOf("" "", jj + 2);
            int mm = javadoc2.indexOf(""}"", jj + 2);

            javadoc2 = javadoc2.substring(0, jj) + javadoc2.substring(nn + 1, mm) + javadoc2.substring(mm + 1);

            kk = mm + 1;
        }

        jdx = 0;
        for (;;) {
            idx = javadoc2.indexOf(wrongPre + "" "" + word, jdx);
            if (idx >= 0) {
                e.append(""java.lang.RuntimeException: a/an typo "")
                .append(word)
                .append(""\r\n at io.reactivex.rxjava3.core."")
                .append(baseTypeName)
                .append("".method("")
                .append(baseTypeName)
                .append("".java:"").append(m.javadocLine).append("")\r\n\r\n"");
                jdx = idx + wrongPre.length() + 1 + word.length();
            } else {
                break;
            }
        }
    }",break_loop_control
jj,"for (;;) {
            int jj = javadoc2.indexOf(""{@"", kk);
            if (jj < 0) {
                break;
            }
            int nn = javadoc2.indexOf("" "", jj + 2);
            int mm = javadoc2.indexOf(""}"", jj + 2);

            javadoc2 = javadoc2.substring(0, jj) + javadoc2.substring(nn + 1, mm) + javadoc2.substring(mm + 1);

            kk = mm + 1;
        }",break_loop_control
idx1,"for (;;) {
            int idx1 = m.javadoc.indexOf(""<dd>"", jdx);
            int idx2 = m.javadoc.indexOf(""</dd>"", jdx);

            if (idx1 < 0 && idx2 < 0) {
                break;
            }

            int idx3 = m.javadoc.indexOf(""<dd>"", idx1 + 4);

            if (idx1 > 0 && idx2 > 0 && (idx3 < 0 || (idx2 < idx3 && idx3 > 0))) {
                jdx = idx2 + 5;
            } else {
                e.append(""java.lang.RuntimeException: unbalanced <dd></dd> "")
                .append(""\r\n at "")
                .append(packageName)
                .append(""."")
                .append(baseTypeName)
                .append("".method("")
                .append(baseTypeName)
                .append("".java:"").append(m.javadocLine + lineNumber(m.javadoc, idx1) - 1).append("")\r\n\r\n"");
                break;
            }
        }",break_loop_control
idx2,"for (;;) {
            int idx1 = m.javadoc.indexOf(""<dd>"", jdx);
            int idx2 = m.javadoc.indexOf(""</dd>"", jdx);

            if (idx1 < 0 && idx2 < 0) {
                break;
            }

            int idx3 = m.javadoc.indexOf(""<dd>"", idx1 + 4);

            if (idx1 > 0 && idx2 > 0 && (idx3 < 0 || (idx2 < idx3 && idx3 > 0))) {
                jdx = idx2 + 5;
            } else {
                e.append(""java.lang.RuntimeException: unbalanced <dd></dd> "")
                .append(""\r\n at "")
                .append(packageName)
                .append(""."")
                .append(baseTypeName)
                .append("".method("")
                .append(baseTypeName)
                .append("".java:"").append(m.javadocLine + lineNumber(m.javadoc, idx1) - 1).append("")\r\n\r\n"");
                break;
            }
        }",break_loop_control
eventPool,"{
    // nextInt is normally exclusive of the top value,
    // so add 1 to make it inclusive
    var randomNum = rand.nextInt((MAX_ID - MIN_ID) + 1) + MIN_ID;
    while (eventPool.containsKey(randomNum)) {
      randomNum = rand.nextInt((MAX_ID - MIN_ID) + 1) + MIN_ID;
    }

    return randomNum;
  }",maybe_loop_control
option,"{
    var eventManager = new EventManager();

    var s = new Scanner(System.in);
    var option = -1;
    while (option != 4) {
      LOGGER.info(""Hello. Would you like to boil some eggs?"");
      LOGGER.info(""(1) BOIL AN EGG \n(2) STOP BOILING THIS EGG \n(3) HOW ARE MY EGGS? \n(4) EXIT"");
      LOGGER.info(""Choose [1,2,3,4]: "");
      option = s.nextInt();

      if (option == 1) {
        processOption1(eventManager, s);
      } else if (option == 2) {
        processOption2(eventManager, s);
      } else if (option == 3) {
        processOption3(eventManager, s);
      } else if (option == 4) {
        eventManager.shutdown();
      }
    }

    s.close();
  }",loop_control
i,"{
    var json = new StringBuilder().append(""{"");

    var i = 0;
    var fieldsLength = fields.length;
    while (i < fieldsLength) {
      json.append(getString(video, Video.class.getDeclaredField(fields[i])));
      if (i != fieldsLength - 1) {
        json.append("","");
      }
      i++;
    }
    json.append(""}"");
    return json.toString();
  }",loop_control
i,"for (int i = 0; i < RETRIES; i++) {
      if (retries >= RETRIES) {
        return FAILURE.getRemoteServiceStatusValue();
      }

      if ((result = checkLatency(value)) == FAILURE.getRemoteServiceStatusValue()) {
        LOGGER.info(""Failed to reach remote: ({})"", i + 1);
        retries++;
        try {
          sleep(DELAY_MS);
        } catch (InterruptedException e) {
          LOGGER.error(""Thread sleep state interrupted"", e);
          Thread.currentThread().interrupt();
        }
      } else {
        break;
      }
    }",loop_control
health,"for (final var health : Health.values()) {
      controller.setHealth(health);
      verify(model).setHealth(health);
      verifyZeroInteractions(view);
    }",iterator
fatigue,"for (final var fatigue : Fatigue.values()) {
      controller.setFatigue(fatigue);
      verify(model).setFatigue(fatigue);
      verifyZeroInteractions(view);
    }",iterator
nourishment,"for (final var nourishment : Nourishment.values()) {
      controller.setNourishment(nourishment);
      verify(model).setNourishment(nourishment);
      verifyZeroInteractions(view);
    }",iterator
health,"for (final var health : Health.values()) {
      model.setHealth(health);
      assertEquals(health, model.getHealth());
      assertEquals(String.format(messageFormat, health), model.toString());
    }",iterator
fatigue,"for (final var fatigue : Fatigue.values()) {
      model.setFatigue(fatigue);
      assertEquals(fatigue, model.getFatigue());
      assertEquals(String.format(messageFormat, fatigue), model.toString());
    }",iterator
nourishment,"for (final var nourishment : Nourishment.values()) {
      model.setNourishment(nourishment);
      assertEquals(nourishment, model.getNourishment());
      assertEquals(String.format(messageFormat, nourishment), model.toString());
    }",iterator
i,"for (var i = 0; i < Instruction.values().length; i++) {
      if (Instruction.values()[i].getIntValue() == value) {
        return Instruction.values()[i];
      }
    }",loop_control
i,"for (var i = 0; i < bytecode.length; i++) {
      Instruction instruction = Instruction.getInstruction(bytecode[i]);
      switch (instruction) {
        case LITERAL:
          // Read the next byte from the bytecode.
          int value = bytecode[++i];
          // Push the next value to stack
          stack.push(value);
          break;
        case SET_AGILITY:
          var amount = stack.pop();
          var wizard = stack.pop();
          setAgility(wizard, amount);
          break;
        case SET_WISDOM:
          amount = stack.pop();
          wizard = stack.pop();
          setWisdom(wizard, amount);
          break;
        case SET_HEALTH:
          amount = stack.pop();
          wizard = stack.pop();
          setHealth(wizard, amount);
          break;
        case GET_HEALTH:
          wizard = stack.pop();
          stack.push(getHealth(wizard));
          break;
        case GET_AGILITY:
          wizard = stack.pop();
          stack.push(getAgility(wizard));
          break;
        case GET_WISDOM:
          wizard = stack.pop();
          stack.push(getWisdom(wizard));
          break;
        case ADD:
          var a = stack.pop();
          var b = stack.pop();
          stack.push(a + b);
          break;
        case DIVIDE:
          a = stack.pop();
          b = stack.pop();
          stack.push(b / a);
          break;
        case PLAY_SOUND:
          wizard = stack.pop();
          getWizards()[wizard].playSound();
          break;
        case SPAWN_PARTICLES:
          wizard = stack.pop();
          getWizards()[wizard].spawnParticles();
          break;
        default:
          throw new IllegalArgumentException(""Invalid instruction value"");
      }
      LOGGER.info(""Executed "" + instruction.name() + "", Stack contains "" + getStack());
    }",loop_control
i,"for (var i = 0; i < splitedInstructions.length; i++) {
      if (isValidInstruction(splitedInstructions[i])) {
        bytecode[i] = Instruction.valueOf(splitedInstructions[i]).getIntValue();
      } else if (isValidInt(splitedInstructions[i])) {
        bytecode[i] = Integer.parseInt(splitedInstructions[i]);
      } else {
        var errorMessage = ""Invalid instruction or number: "" + splitedInstructions[i];
        throw new IllegalArgumentException(errorMessage);
      }
    }",loop_control
count,"{
    var count = this.msgCount;

    try {
      while (count > 0) {
        var statusMsg = ""Message-"" + count + "" submitted by "" + Thread.currentThread().getName();
        this.submit(new Message(statusMsg));

        LOGGER.info(statusMsg);

        // reduce the message count.
        count--;

        // Make the current thread to sleep after every Message submission.
        Thread.sleep(1000);
      }
    } catch (Exception e) {
      LOGGER.error(e.getMessage());
    }
  }",loop_control
isCompleted,"{
        while (!isCompleted()) {
          lock.wait();
        }
      }",maybe_loop_control
i,"for (var i = headIndex; i != tailIndex; i = (i + 1) % MAX_PENDING) {
      var playMessage = getPendingAudio()[i];
      if (playMessage.getStream() == stream) {
        // Use the larger of the two volumes.
        playMessage.setVolume(Math.max(volume, playMessage.getVolume()));

        // Don't need to enqueue.
        return;
      }
    }",loop_control
saga,"{
      var next = state.current();
      var ch = saga.get(next);
      var srvOpt = sd.find(ch.name);

      if (srvOpt.isEmpty()) {
        state.directionToBack();
        state.back();
        continue;
      }

      var srv = srvOpt.get();

      if (state.isForward()) {
        var processRes = srv.process(tempVal);
        if (processRes.isSuccess()) {
          next = state.forward();
          tempVal = (K) processRes.getValue();
        } else {
          state.directionToBack();
        }
      } else {
        var rlRes = srv.rollback(tempVal);
        if (rlRes.isSuccess()) {
          next = state.back();
          tempVal = (K) rlRes.getValue();
        } else {
          result = CRASHED;
          next = state.back();
        }
      }


      if (!saga.isPresent(next)) {
        return state.isForward() ? FINISHED : result == CRASHED ? CRASHED : ROLLBACK;
      }
    }",break_loop_control
fromIterator,"{
            while (fromIterator.hasNext()) {
              var candidate = fromIterator.next();
              if (predicate.test(candidate)) {
                return candidate;
              }
            }

            return null;
          }",maybe_loop_control
resultIterator,"{
    var resultIterator = last(1).iterator();
    return resultIterator.hasNext() ? Optional.of(resultIterator.next()) : Optional.empty();
  }",iterator
currentIndex,"{
          private int stopIndex;
          private int totalElementsCount;
          private List<E> list;
          private int currentIndex;

          @Override
          public E computeNext() {
            initialize();

            while (currentIndex < stopIndex && fromIterator.hasNext()) {
              currentIndex++;
              fromIterator.next();
            }
            if (currentIndex >= stopIndex && fromIterator.hasNext()) {
              return fromIterator.next();
            }
            return null;
          }

          private void initialize() {
            if (list == null) {
              list = new ArrayList<>();
              iterable.forEach(list::add);
              totalElementsCount = list.size();
              stopIndex = totalElementsCount - count;
            }
          }
        }",loop_control
oldTypeIterator,"{
          final Iterator<E> oldTypeIterator = iterable.iterator();

          @Override
          public T computeNext() {
            if (oldTypeIterator.hasNext()) {
              E candidate = oldTypeIterator.next();
              return function.apply(candidate);
            } else {
              return null;
            }
          }
        }",iterator
iterator,"{
    var iterator = iterator();
    while (iterator.hasNext()) {
      var nextElement = iterator.next();
      if (!predicate.test(nextElement)) {
        iterator.remove();
      }
    }
    return this;
  }",iterator
resultIterator,"{
    var resultIterator = first(1).iterator();
    return resultIterator.hasNext() ? Optional.of(resultIterator.next()) : Optional.empty();
  }",iterator
iterator,"{
    var iterator = iterator();
    var currentCount = 0;
    while (iterator.hasNext()) {
      iterator.next();
      if (currentCount >= count) {
        iterator.remove();
      }
      currentCount++;
    }
    return this;
  }",iterator
iterator,"{
    var remainingElementsCount = getRemainingElementsCount();
    var iterator = iterator();
    var currentIndex = 0;
    while (iterator.hasNext()) {
      iterator.next();
      if (currentIndex < remainingElementsCount - count) {
        iterator.remove();
      }
      currentIndex++;
    }

    return this;
  }",iterator
ignored,"for (var ignored : this) {
      counter++;
    }",iterator
i,"for (var i = 1; i <= titleList.length; i++) {
      result.addAlbums(titleList[i - 1], artistList[i - 1],
              isClassicalList[i - 1], composerList[i - 1]);
    }",loop_control
i,"for (var i = 0; i < result.length; i++) {
      result[i] = data.getAlbums().get(i).getTitle();
    }",loop_control
id,"for (var id = 0; id < ITEM_COUNT; id++) {
      queue.put(new Item(""producer"", id));
    }",loop_control
id,"for (var id = 0; id < ITEM_COUNT; id++) {
      consumer.consume();
    }",loop_control
i,"for (var i = 0; i < 2; i++) {

      final var producer = new Producer(""Producer_"" + i, queue);
      executorService.submit(() -> {
        while (true) {
          producer.produce();
        }
      });
    }",loop_control
i,"for (var i = 0; i < 3; i++) {
      final var consumer = new Consumer(""Consumer_"" + i, queue);
      executorService.submit(() -> {
        while (true) {
          consumer.consume();
        }
      });
    }",loop_control
res,"for (var res : results) {
        final var instance = res.get();
        assertNotNull(instance);
        assertSame(expectedInstance, instance);
      }",iterator
isRunning,"{
    while (isRunning) {
      processInput();
      update();
      render();
    }
  }",maybe_loop_control
entity,"for (var entity : entities) {
      entity.update();
    }",iterator
i,"for (var i = 0; i < 3; i++) {
      jtFields[i] = new JTextField();
    }",loop_control
i,"for (var i = 0; i < 2; i++) {
      jtAreas[i] = new JTextArea();
    }",loop_control
last,"{
    Filter last = this;
    while (last.getNext() != null) {
      last = last.getNext();
    }
    return last;
  }",maybe_loop_control
infinite,"{
      boolean infinite = true;
      while (infinite) {
        try {
          requests.take().run();
        } catch (InterruptedException e) {
          if (this.status != 0) {
            logger.error(""Thread was interrupted. --> {}"", e.getMessage()); 
          }
          infinite = false;
          Thread.currentThread().interrupt();
        }
      }
    }",maybe_loop_control
i,"for (int i = 0;i < NUM_CREATURES;i++) {
        creatures.add(new Orc(Orc.class.getSimpleName() + i));
        creatures.get(i).eat();
        creatures.get(i).roam();
      }",loop_control
i,"for (int i = 0;i < NUM_CREATURES;i++) {
        creatures.get(i).kill(0);
      }",loop_control
q,"for (String q : excludeQueries) {
      finder = finder.not(Finder.contains(q));
    }",iterator
query,"for (String query : queries) {
      finder = finder.and(Finder.contains(query));
    }",iterator
query,"for (String query : queries) {
      finder = finder.or(Finder.contains(query));
    }",iterator
isLockFree,"{

        // Wait until the lock is free.
        while (!isLockFree()) {
          try {
            globalMutex.wait();
          } catch (InterruptedException e) {
            LOGGER.info(""InterruptedException while waiting for globalMutex to begin writing"", e);
            Thread.currentThread().interrupt();
          }
        }
        // When the lock is free, acquire it by placing an entry in globalMutex
        globalMutex.add(this);
      }",maybe_loop_control
i,"for (var i = 0; i < 5; i++) {
      var writingTime = ThreadLocalRandom.current().nextLong(5000);
      executeService.submit(new Writer(""Writer "" + i, lock.writeLock(), writingTime));
    }",loop_control
i,"for (var i = 0; i < 5; i++) {
      var readingTime = ThreadLocalRandom.current().nextLong(10);
      executeService.submit(new Reader(""Reader "" + i, lock.readLock(), readingTime));
    }",loop_control
i,"for (var i = 6; i < 10; i++) {
      var readingTime = ThreadLocalRandom.current().nextLong(10);
      executeService.submit(new Reader(""Reader "" + i, lock.readLock(), readingTime));
    }",loop_control
pendingWrite,"{
    var pendingWrites = channelToPendingWrites.get(key.channel());
    Object pendingWrite;
    while ((pendingWrite = pendingWrites.poll()) != null) {
      // ask the concrete channel to make sense of data and write it to java channel
      doWrite(pendingWrite, key);
    }
    // We don't have anything more to write so channel is interested in reading more data
    reactor.changeOps(key, SelectionKey.OP_READ);
  }",maybe_loop_control
iterator,"{
      // honor any pending commands first
      processPendingCommands();

      /*
       * Synchronous event de-multiplexing happens here, this is blocking call which returns when it
       * is possible to initiate non-blocking operation on any of the registered channels.
       */
      selector.select();

      /*
       * Represents the events that have occurred on registered handles.
       */
      var keys = selector.selectedKeys();
      var iterator = keys.iterator();

      while (iterator.hasNext()) {
        var key = iterator.next();
        if (!key.isValid()) {
          iterator.remove();
          continue;
        }
        processKey(key);
      }
      keys.clear();
    }",iterator
iterator,"{
    var iterator = pendingCommands.iterator();
    while (iterator.hasNext()) {
      var command = iterator.next();
      command.run();
      iterator.remove();
    }
  }",iterator
i,"for (var i = 0; i < 4; i++) {
        writer.println(clientName + "" - Log request: "" + i);
        writer.flush();

        var data = new byte[1024];
        var read = inputStream.read(data, 0, data.length);
        if (read == 0) {
          LOGGER.info(""Read zero bytes"");
        } else {
          LOGGER.info(new String(data, 0, read));
        }

        artificialDelayOf(100);
      }",loop_control
i,"for (var i = 0; i < 4; i++) {

          var message = clientName + "" - Log request: "" + i;
          var bytes = message.getBytes();
          var request = new DatagramPacket(bytes, bytes.length, remoteAddress);

          socket.send(request);

          var data = new byte[1024];
          var reply = new DatagramPacket(data, data.length);
          socket.receive(reply);
          if (reply.getLength() == 0) {
            LOGGER.info(""Read zero bytes"");
          } else {
            LOGGER.info(new String(reply.getData(), 0, reply.getLength()));
          }

          artificialDelayOf(100);
        }",loop_control
channel,"for (var channel : channels) {
      channel.getJavaChannel().close();
    }",iterator
i,"for (var i = 0; i < 10; i++) {
      queueManager.publishMessage(new Message(""Low Message Priority"", 0));
    }",loop_control
i,"for (var i = 0; i < 10; i++) {
      queueManager.publishMessage(new Message(""High Message Priority"", 1));
    }",loop_control
index,"{
    var index = 0;
    while (hasLeftChild(index)) {

      var smallerIndex = leftChildIndex(index);

      if (hasRightChild(index) && right(index).compareTo(left(index)) > 0) {
        smallerIndex = rightChildIndex(index);
      }

      if (queue[index].compareTo(queue[smallerIndex]) > 0) {
        break;
      } else {
        swap(index, smallerIndex);
      }

      index = smallerIndex;


    }

  }",break_loop_control
index,"{
    var index = 0;
    while (hasLeftChild(index)) {

      var smallerIndex = leftChildIndex(index);

      if (hasRightChild(index) && right(index).compareTo(left(index)) > 0) {
        smallerIndex = rightChildIndex(index);
      }

      if (queue[index].compareTo(queue[smallerIndex]) > 0) {
        break;
      } else {
        swap(index, smallerIndex);
      }

      index = smallerIndex;


    }

  }",loop_control
index,"{
    var index = size - 1;
    while (hasParent(index) && parent(index).compareTo(queue[index]) < 0) {
      swap(parentIndex(index), index);
      index = parentIndex(index);
    }
  }",loop_control
i,"for (var i = 0; i <= size / 2; i++) {
      LOGGER.info("" PARENT : "" + queue[i] + "" LEFT CHILD : ""
          + left(i) + "" RIGHT CHILD :"" + right(i));
    }",loop_control
iterator,"{
    final var chest = new TreasureChest();
    final var iterator = chest.iterator(expectedItem.getType());
    assertNotNull(iterator);

    while (iterator.hasNext()) {
      final var item = iterator.next();
      assertNotNull(item);
      assertEquals(expectedItem.getType(), item.getType());

      final var name = item.toString();
      assertNotNull(name);
      if (expectedItem.toString().equals(name)) {
        return;
      }
    }

    fail(""Expected to find item ["" + expectedItem + ""] using iterator, but we didn't."");

  }",iterator
expectedItem,"{
    final var chest = new TreasureChest();
    final var iterator = chest.iterator(expectedItem.getType());
    assertNotNull(iterator);

    while (iterator.hasNext()) {
      final var item = iterator.next();
      assertNotNull(item);
      assertEquals(expectedItem.getType(), item.getType());

      final var name = item.toString();
      assertNotNull(name);
      if (expectedItem.toString().equals(name)) {
        return;
      }
    }

    fail(""Expected to find item ["" + expectedItem + ""] using iterator, but we didn't."");

  }",break_loop_control
item,"for (final var item : items) {
      assertNotNull(item);
      assertNotNull(item.getType());
      assertNotNull(item.toString());

      final var sameType = expectedItem.getType() == item.getType();
      final var sameName = expectedItem.toString().equals(item.toString());
      if (sameType && sameName) {
        return;
      }
    }",iterator
sameType,"for (final var item : items) {
      assertNotNull(item);
      assertNotNull(item.getType());
      assertNotNull(item.toString());

      final var sameType = expectedItem.getType() == item.getType();
      final var sameName = expectedItem.toString().equals(item.toString());
      if (sameType && sameName) {
        return;
      }
    }",break_loop_control
sameName,"for (final var item : items) {
      assertNotNull(item);
      assertNotNull(item.getType());
      assertNotNull(item.toString());

      final var sameType = expectedItem.getType() == item.getType();
      final var sameName = expectedItem.toString().equals(item.toString());
      if (sameType && sameName) {
        return;
      }
    }",break_loop_control
iter,"{
    var iter = new BstIterator<>(emptyRoot);
    assertThrows(NoSuchElementException.class, iter::next,
        ""next() should throw an IllegalStateException if hasNext() is false."");
  }",iterator
iter,"{
    var iter = new BstIterator<>(nonEmptyRoot);
    assertEquals(Integer.valueOf(1), iter.next().getVal(), ""First Node is 1."");
    assertEquals(Integer.valueOf(3), iter.next().getVal(), ""Second Node is 3."");
    assertEquals(Integer.valueOf(4), iter.next().getVal(), ""Third Node is 4."");
    assertEquals(Integer.valueOf(5), iter.next().getVal(), ""Fourth Node is 5."");
    assertEquals(Integer.valueOf(6), iter.next().getVal(), ""Fifth Node is 6."");
    assertEquals(Integer.valueOf(7), iter.next().getVal(), ""Sixth Node is 7."");
  }",iterator
iter,"{
    var iter = new BstIterator<>(emptyRoot);
    assertFalse(iter.hasNext(), ""hasNext() should return false for empty tree."");
  }",iterator
iter,"{
    var iter = new BstIterator<>(nonEmptyRoot);
    assertTrue(iter.hasNext(), ""hasNext() should return true for populated tree."");
  }",iterator
iter,"{
    var iter = new BstIterator<>(nonEmptyRoot);
    assertTrue(iter.hasNext(), ""Iterator hasNext() should be true."");
    assertEquals(Integer.valueOf(1), iter.next().getVal(), ""First Node is 1."");
    assertTrue(iter.hasNext(), ""Iterator hasNext() should be true."");
    assertEquals(Integer.valueOf(3), iter.next().getVal(), ""Second Node is 3."");
    assertTrue(iter.hasNext(), ""Iterator hasNext() should be true."");
    assertEquals(Integer.valueOf(4), iter.next().getVal(), ""Third Node is 4."");
    assertTrue(iter.hasNext(), ""Iterator hasNext() should be true."");
    assertEquals(Integer.valueOf(5), iter.next().getVal(), ""Fourth Node is 5."");
    assertTrue(iter.hasNext(), ""Iterator hasNext() should be true."");
    assertEquals(Integer.valueOf(6), iter.next().getVal(), ""Fifth Node is 6."");
    assertTrue(iter.hasNext(), ""Iterator hasNext() should be true."");
    assertEquals(Integer.valueOf(7), iter.next().getVal(), ""Sixth Node is 7."");
    assertFalse(iter.hasNext(), ""Iterator hasNext() should be false, end of tree."");
  }",iterator
itemIterator,"{
    LOGGER.info(""------------------------"");
    LOGGER.info(""Item Iterator for ItemType "" + itemType + "": "");
    var itemIterator = TREASURE_CHEST.iterator(itemType);
    while (itemIterator.hasNext()) {
      LOGGER.info(itemIterator.next().toString());
    }
  }",iterator
bstIterator,"{
    LOGGER.info(""------------------------"");
    LOGGER.info(""BST Iterator: "");
    var root = buildIntegerBst();
    var bstIterator = new BstIterator<>(root);
    while (bstIterator.hasNext()) {
      LOGGER.info(""Next node: "" + bstIterator.next().getVal());
    }
  }",iterator
tempIdx,"{
    var items = chest.getItems();
    var tempIdx = idx;
    while (true) {
      tempIdx++;
      if (tempIdx >= items.size()) {
        tempIdx = -1;
        break;
      }
      if (type.equals(ItemType.ANY) || items.get(tempIdx).getType().equals(type)) {
        break;
      }
    }
    return tempIdx;
  }",break_loop_control
items,"{
    var items = chest.getItems();
    var tempIdx = idx;
    while (true) {
      tempIdx++;
      if (tempIdx >= items.size()) {
        tempIdx = -1;
        break;
      }
      if (type.equals(ItemType.ANY) || items.get(tempIdx).getType().equals(type)) {
        break;
      }
    }
    return tempIdx;
  }",break_loop_control
node,"{
    while (node != null) {
      pathStack.push(node);
      node = node.getLeft();
    }
  }",maybe_loop_control
curr,"{
    TreeNode<T> parent = null;
    var curr = this;

    while (curr != null) {
      parent = curr;
      curr = curr.traverseOneLevelDown(valToInsert);
    }

    return parent;
  }",maybe_loop_control
i,"for (int i = 0; i < 1000000; i++)
                    bank.transfer(random.nextInt(4), random.nextInt(4), (int) (Math.random() * 1000));",loop_control
i,"for (int i = 0; i < 5; i++) {
            executorService.execute(runnable);
        }",loop_control
account,"for (int account : accounts) {
            balance += account;
        }",iterator
stat,"for (final var stat : Stats.values()) {
      assertFalse(prototype.has(stat));
      assertNull(prototype.get(stat));

      final var expectedValue = stat.ordinal();
      prototype.set(stat, expectedValue);
      assertTrue(prototype.has(stat));
      assertEquals(expectedValue, prototype.get(stat));

      prototype.remove(stat);
      assertFalse(prototype.has(stat));
      assertNull(prototype.get(stat));
    }",iterator
stat,"{
    final var prototype = new Character();
    Arrays.stream(Stats.values()).forEach(stat -> prototype.set(stat, stat.ordinal()));

    final var mage = new Character(Type.MAGE, prototype);
    for (final var stat : Stats.values()) {
      final var expectedValue = stat.ordinal();
      assertTrue(mage.has(stat));
      assertEquals(expectedValue, mage.get(stat));
    }
  }",iterator
stat,"for (var stat : Stats.values()) {
      var value = this.get(stat);
      if (value == null) {
        continue;
      }
      builder.append("" - "").append(stat.name()).append(':').append(value).append('\n');
    }",iterator
i,"for (var i = 0; i < loadBalancer.getNoOfServers() * 2; i++) {
      loadBalancer.serverRequest(request);
    }",loop_control
port,"for (var port : new int[]{8080, 8081, 8082, 8083, 8084}) {
      SERVERS.add(new Server(""localhost"", port, ++id));
    }",iterator
serviceName,"for (final var serviceName : serviceNames) {
      final var service = ServiceLocator.getService(serviceName);
      assertNotNull(service);
      assertEquals(serviceName, service.getName());
      assertTrue(service.getId() > 0); // The id is generated randomly, but the minimum value is '1'
      assertSame(service, ServiceLocator.getService(serviceName));
    }",iterator
action,"for (final var action : Action.values()) {
      member.partyAction(action);
      assertEquals(member.toString() + "" "" + action.getDescription(), appender.getLastMessage());
    }",iterator
action,"for (final var action : Action.values()) {
      member.act(action);
      assertEquals(member.toString() + "" "" + action.toString(), appender.getLastMessage());
      verify(party).act(member, action);
    }",iterator
member,"for (var member : members) {
      if (!member.equals(actor)) {
        member.partyAction(action);
      }
    }",iterator
i,"for (var i = 0; i < pixels.length; ++i) {
      if (pixels[i] == Pixel.BLACK) {
        var y = i / FrameBuffer.WIDTH;
        var x = i % FrameBuffer.WIDTH;
        log.append("" ("").append(x).append("", "").append(y).append("")"");
      }
    }",loop_control
id,"for (var id = 1; id <= numberOfWorkers; id++) {
      var worker = new Worker(id, this, taskSet, taskHandler);
      workers.add(worker);
    }",loop_control
i,"for (var i = 0; i < 5; i++) {
      var time = Math.abs(rand.nextInt(1000));
      taskSet.addTask(new Task(time));
    }",loop_control
i,"for (int i = 0; i < 20; i++) {
      var p = new Bubble(rand.nextInt(300), rand.nextInt(300), i, rand.nextInt(2) + 1);
      points.add(p);
    }",loop_control
point,"for (var point : toCheck) {
      var otherId = point.id;
      if (allBubbles.get(otherId) != null && //the bubble hasn't been popped yet
          this.id != otherId && //the two bubbles are not the same
          this.touches(allBubbles.get(otherId))) { //the bubbles touch
        allBubbles.get(otherId).pop(allBubbles);
        toBePopped = true;
      }
    }",iterator
i,"for (int i = 0; i < 10000; i++) {
      var b = new Bubble(rand.nextInt(300), rand.nextInt(300), i, rand.nextInt(2) + 1);
      bubbles1.put(i, b);
      bubbles2.put(i, b);
      LOGGER.info(BUBBLE, i, "" with radius "", b.radius,
          "" added at ("", b.coordinateX, "","", b.coordinateY + "")"");
    }",loop_control
d,"for (double d = 0.1; d < 2; d = d + 0.1) {
            paymentTime *= d;
            queueTaskTime *= d;
            Commander c = buildCommanderObjectVanilla();
            var order = new Order(new User(""K"", ""J""), ""pen"", 1f);
            for (Order.MessageSent ms : Order.MessageSent.values()) {
                c.placeOrder(order);
                assertFalse(StringUtils.isBlank(order.id));
            }
        }",loop_control
ms,"for (Order.MessageSent ms : Order.MessageSent.values()) {
                c.placeOrder(order);
                assertFalse(StringUtils.isBlank(order.id));
            }",iterator
d,"for (double d = 0.1; d < 2; d = d + 0.1) {
            paymentTime *= d;
            queueTaskTime *= d;
            Commander c = buildCommanderObject(true);
            var order = new Order(new User(""K"", ""J""), ""pen"", 1f);
            for (Order.MessageSent ms : Order.MessageSent.values()) {
                c.placeOrder(order);
                assertFalse(StringUtils.isBlank(order.id));
            }
        }",loop_control
ms,"for (Order.MessageSent ms : Order.MessageSent.values()) {
                c.placeOrder(order);
                assertFalse(StringUtils.isBlank(order.id));
            }",iterator
d,"for (double d = 0.1; d < 2; d = d + 0.1) {
            paymentTime *= d;
            queueTaskTime *= d;
            Commander c = buildCommanderObject(false);
            var order = new Order(new User(""K"", ""J""), ""pen"", 1f);
            for (Order.MessageSent ms : Order.MessageSent.values()) {
                c.placeOrder(order);
                assertFalse(StringUtils.isBlank(order.id));
            }
        }",loop_control
ms,"for (Order.MessageSent ms : Order.MessageSent.values()) {
                c.placeOrder(order);
                assertFalse(StringUtils.isBlank(order.id));
            }",iterator
d,"for (double d = 0.1; d < 2; d = d + 0.1) {
            paymentTime *= d;
            queueTaskTime *= d;
            Commander c = buildCommanderObjectNoPaymentException1();
            var order = new Order(new User(""K"", ""J""), ""pen"", 1f);
            for (Order.MessageSent ms : Order.MessageSent.values()) {
                c.placeOrder(order);
                assertFalse(StringUtils.isBlank(order.id));
            }
        }",loop_control
ms,"for (Order.MessageSent ms : Order.MessageSent.values()) {
                c.placeOrder(order);
                assertFalse(StringUtils.isBlank(order.id));
            }",iterator
d,"for (double d = 0.1; d < 2; d = d + 0.1) {
            paymentTime *= d;
            queueTaskTime *= d;
            Commander c = buildCommanderObjectNoPaymentException2();
            var order = new Order(new User(""K"", ""J""), ""pen"", 1f);
            for (Order.MessageSent ms : Order.MessageSent.values()) {
                c.placeOrder(order);
                assertFalse(StringUtils.isBlank(order.id));
            }
        }",loop_control
ms,"for (Order.MessageSent ms : Order.MessageSent.values()) {
                c.placeOrder(order);
                assertFalse(StringUtils.isBlank(order.id));
            }",iterator
d,"for (double d = 0.1; d < 2; d = d + 0.1) {
            paymentTime *= d;
            queueTaskTime *= d;
            Commander c = buildCommanderObjectNoPaymentException3();
            var order = new Order(new User(""K"", ""J""), ""pen"", 1f);
            for (Order.MessageSent ms : Order.MessageSent.values()) {
                c.placeOrder(order);
                assertFalse(StringUtils.isBlank(order.id));
            }
        }",loop_control
ms,"for (Order.MessageSent ms : Order.MessageSent.values()) {
                c.placeOrder(order);
                assertFalse(StringUtils.isBlank(order.id));
            }",iterator
d,"for (double d = 0.1; d < 2; d = d + 0.1) {
            paymentTime *= d;
            queueTaskTime *= d;
            Commander c = buildCommanderObjectNoPaymentException3();
            var order = new Order(new User(""K"", ""J""), ""pen"", 1f);
            for (Order.MessageSent ms : Order.MessageSent.values()) {
                c.placeOrder(order);
                c.placeOrder(order);
                c.placeOrder(order);
                assertFalse(StringUtils.isBlank(order.id));
            }
        }",loop_control
ms,"for (Order.MessageSent ms : Order.MessageSent.values()) {
                c.placeOrder(order);
                c.placeOrder(order);
                c.placeOrder(order);
                assertFalse(StringUtils.isBlank(order.id));
            }",iterator
d,"for (double d = 0.1; d < 2; d = d + 0.1) {
            paymentTime *= d;
            queueTaskTime *= d;
            messageTime *= d;
            employeeTime *= d;
            queueTime *= d;
            Commander c = buildCommanderObjectUnknownException();
            var order = new Order(new User(""K"", ""J""), ""pen"", 1f);
            for (Order.MessageSent ms : Order.MessageSent.values()) {
                c.placeOrder(order);
                assertFalse(StringUtils.isBlank(order.id));
            }
        }",loop_control
ms,"for (Order.MessageSent ms : Order.MessageSent.values()) {
                c.placeOrder(order);
                assertFalse(StringUtils.isBlank(order.id));
            }",iterator
d,"for (double d = 0.1; d < 2; d = d + 0.1) {
            paymentTime *= d;
            queueTaskTime *= d;
            messageTime *= d;
            employeeTime *= d;
            queueTime *= d;
            Commander c = buildCommanderObject(true);
            var order = new Order(new User(""K"", ""J""), ""pen"", 1f);
            for (Order.MessageSent ms : Order.MessageSent.values()) {
                c.placeOrder(order);
                assertFalse(StringUtils.isBlank(order.id));
            }
        }",loop_control
ms,"for (Order.MessageSent ms : Order.MessageSent.values()) {
                c.placeOrder(order);
                assertFalse(StringUtils.isBlank(order.id));
            }",iterator
d,"for (double d = 0.1; d < 2; d = d + 0.1) {
            paymentTime *= d;
            queueTaskTime *= d;
            messageTime *= d;
            employeeTime *= d;
            queueTime *= d;
            Commander c = buildCommanderObject(false);
            var order = new Order(new User(""K"", ""J""), ""pen"", 1f);
            for (Order.MessageSent ms : Order.MessageSent.values()) {
                c.placeOrder(order);
                assertFalse(StringUtils.isBlank(order.id));
            }
        }",loop_control
ms,"for (Order.MessageSent ms : Order.MessageSent.values()) {
                c.placeOrder(order);
                assertFalse(StringUtils.isBlank(order.id));
            }",iterator
d,"for (double d = 0.1; d < 2; d = d + 0.1) {
            paymentTime *= d;
            queueTaskTime *= d;
            messageTime *= d;
            employeeTime *= d;
            queueTime *= d;
            Commander c = buildCommanderObjectNoPaymentException1();
            var order = new Order(new User(""K"", ""J""), ""pen"", 1f);
            for (Order.MessageSent ms : Order.MessageSent.values()) {
                c.placeOrder(order);
                assertFalse(StringUtils.isBlank(order.id));
            }
        }",loop_control
ms,"for (Order.MessageSent ms : Order.MessageSent.values()) {
                c.placeOrder(order);
                assertFalse(StringUtils.isBlank(order.id));
            }",iterator
d,"for (double d = 0.1; d < 2; d = d + 0.1) {
            paymentTime *= d;
            queueTaskTime *= d;
            messageTime *= d;
            employeeTime *= d;
            queueTime *= d;
            Commander c = buildCommanderObjectUnknownException();
            var order = new Order(new User(""K"", ""J""), ""pen"", 1f);
            for (Order.MessageSent ms : Order.MessageSent.values()) {
                c.placeOrder(order);
                assertFalse(StringUtils.isBlank(order.id));
            }
        }",loop_control
ms,"for (Order.MessageSent ms : Order.MessageSent.values()) {
                c.placeOrder(order);
                assertFalse(StringUtils.isBlank(order.id));
            }",iterator
d,"for (double d = 0.1; d < 2; d = d + 0.1) {
            paymentTime *= d;
            queueTaskTime *= d;
            messageTime *= d;
            employeeTime *= d;
            queueTime *= d;
            Commander c = buildCommanderObjectWithDB();
            var order = new Order(new User(""K"", null), ""pen"", 1f);
            for (Order.MessageSent ms : Order.MessageSent.values()) {
                c.placeOrder(order);
                assertFalse(StringUtils.isBlank(order.id));
            }
        }",loop_control
ms,"for (Order.MessageSent ms : Order.MessageSent.values()) {
                c.placeOrder(order);
                assertFalse(StringUtils.isBlank(order.id));
            }",iterator
d,"for (double d = 0.1; d < 2; d = d + 0.1) {
            paymentTime *= d;
            queueTaskTime *= d;
            messageTime *= d;
            employeeTime *= d;
            queueTime *= d;

            for (Exception e : exceptionList) {

                Commander c = buildCommanderObjectWithDB(true, true, e);
                var order = new Order(new User(""K"", null), ""pen"", 1f);
                for (Order.MessageSent ms : Order.MessageSent.values()) {
                    c.placeOrder(order);
                    assertFalse(StringUtils.isBlank(order.id));
                }

                c = buildCommanderObjectWithDB(true, false, e);
                order = new Order(new User(""K"", null), ""pen"", 1f);
                for (Order.MessageSent ms : Order.MessageSent.values()) {
                    c.placeOrder(order);
                    assertFalse(StringUtils.isBlank(order.id));
                }

                c = buildCommanderObjectWithDB(false, false, e);
                order = new Order(new User(""K"", null), ""pen"", 1f);
                for (Order.MessageSent ms : Order.MessageSent.values()) {
                    c.placeOrder(order);
                    assertFalse(StringUtils.isBlank(order.id));
                }

                c = buildCommanderObjectWithDB(false, true, e);
                order = new Order(new User(""K"", null), ""pen"", 1f);
                for (Order.MessageSent ms : Order.MessageSent.values()) {
                    c.placeOrder(order);
                    assertFalse(StringUtils.isBlank(order.id));
                }
            }
        }",loop_control
e,"for (Exception e : exceptionList) {

                Commander c = buildCommanderObjectWithDB(true, true, e);
                var order = new Order(new User(""K"", null), ""pen"", 1f);
                for (Order.MessageSent ms : Order.MessageSent.values()) {
                    c.placeOrder(order);
                    assertFalse(StringUtils.isBlank(order.id));
                }

                c = buildCommanderObjectWithDB(true, false, e);
                order = new Order(new User(""K"", null), ""pen"", 1f);
                for (Order.MessageSent ms : Order.MessageSent.values()) {
                    c.placeOrder(order);
                    assertFalse(StringUtils.isBlank(order.id));
                }

                c = buildCommanderObjectWithDB(false, false, e);
                order = new Order(new User(""K"", null), ""pen"", 1f);
                for (Order.MessageSent ms : Order.MessageSent.values()) {
                    c.placeOrder(order);
                    assertFalse(StringUtils.isBlank(order.id));
                }

                c = buildCommanderObjectWithDB(false, true, e);
                order = new Order(new User(""K"", null), ""pen"", 1f);
                for (Order.MessageSent ms : Order.MessageSent.values()) {
                    c.placeOrder(order);
                    assertFalse(StringUtils.isBlank(order.id));
                }
            }",loop_control
ms,"for (Order.MessageSent ms : Order.MessageSent.values()) {
                    c.placeOrder(order);
                    assertFalse(StringUtils.isBlank(order.id));
                }",iterator
ms,"for (Order.MessageSent ms : Order.MessageSent.values()) {
                    c.placeOrder(order);
                    assertFalse(StringUtils.isBlank(order.id));
                }",iterator
ms,"for (Order.MessageSent ms : Order.MessageSent.values()) {
                    c.placeOrder(order);
                    assertFalse(StringUtils.isBlank(order.id));
                }",iterator
ms,"for (Order.MessageSent ms : Order.MessageSent.values()) {
                    c.placeOrder(order);
                    assertFalse(StringUtils.isBlank(order.id));
                }",iterator
d,"for (double d = 0.1; d < 2; d = d + 0.1) {
            paymentTime *= d;
            queueTaskTime *= d;
            messageTime *= d;
            employeeTime *= d;
            queueTime *= d;
            Commander c = buildCommanderObjectWithoutDB();
            var order = new Order(new User(""K"", null), ""pen"", 1f);
            for (Order.MessageSent ms : Order.MessageSent.values()) {
                c.placeOrder(order);
                assertFalse(StringUtils.isBlank(order.id));
            }
        }",loop_control
ms,"for (Order.MessageSent ms : Order.MessageSent.values()) {
                c.placeOrder(order);
                assertFalse(StringUtils.isBlank(order.id));
            }",iterator
d,"for (double d = 0.1; d < 2; d = d + 0.1) {
            paymentTime *= d;
            queueTaskTime *= d;
            messageTime *= d;
            employeeTime *= d;
            queueTime *= d;

            for (Exception e : exceptionList) {

                Commander c = buildCommanderObjectWithoutDB(true, true, e);
                var order = new Order(new User(""K"", null), ""pen"", 1f);
                for (Order.MessageSent ms : Order.MessageSent.values()) {
                    c.placeOrder(order);
                    assertFalse(StringUtils.isBlank(order.id));
                }

                c = buildCommanderObjectWithoutDB(true, false, e);
                order = new Order(new User(""K"", null), ""pen"", 1f);
                for (Order.MessageSent ms : Order.MessageSent.values()) {
                    c.placeOrder(order);
                    assertFalse(StringUtils.isBlank(order.id));
                }

                c = buildCommanderObjectWithoutDB(false, false, e);
                order = new Order(new User(""K"", null), ""pen"", 1f);
                for (Order.MessageSent ms : Order.MessageSent.values()) {
                    c.placeOrder(order);
                    assertFalse(StringUtils.isBlank(order.id));
                }

                c = buildCommanderObjectWithoutDB(false, true, e);
                order = new Order(new User(""K"", null), ""pen"", 1f);
                for (Order.MessageSent ms : Order.MessageSent.values()) {
                    c.placeOrder(order);
                    assertFalse(StringUtils.isBlank(order.id));
                }
            }
        }",loop_control
ms,"for (Order.MessageSent ms : Order.MessageSent.values()) {
                    c.placeOrder(order);
                    assertFalse(StringUtils.isBlank(order.id));
                }",iterator
ms,"for (Order.MessageSent ms : Order.MessageSent.values()) {
                    c.placeOrder(order);
                    assertFalse(StringUtils.isBlank(order.id));
                }",iterator
ms,"for (Order.MessageSent ms : Order.MessageSent.values()) {
                    c.placeOrder(order);
                    assertFalse(StringUtils.isBlank(order.id));
                }",iterator
ms,"for (Order.MessageSent ms : Order.MessageSent.values()) {
                    c.placeOrder(order);
                    assertFalse(StringUtils.isBlank(order.id));
                }",iterator
e,"for (Exception e : exceptionList) {

                Commander c = buildCommanderObjectWithoutDB(true, true, e);
                var order = new Order(new User(""K"", null), ""pen"", 1f);
                for (Order.MessageSent ms : Order.MessageSent.values()) {
                    c.placeOrder(order);
                    assertFalse(StringUtils.isBlank(order.id));
                }

                c = buildCommanderObjectWithoutDB(true, false, e);
                order = new Order(new User(""K"", null), ""pen"", 1f);
                for (Order.MessageSent ms : Order.MessageSent.values()) {
                    c.placeOrder(order);
                    assertFalse(StringUtils.isBlank(order.id));
                }

                c = buildCommanderObjectWithoutDB(false, false, e);
                order = new Order(new User(""K"", null), ""pen"", 1f);
                for (Order.MessageSent ms : Order.MessageSent.values()) {
                    c.placeOrder(order);
                    assertFalse(StringUtils.isBlank(order.id));
                }

                c = buildCommanderObjectWithoutDB(false, true, e);
                order = new Order(new User(""K"", null), ""pen"", 1f);
                for (Order.MessageSent ms : Order.MessageSent.values()) {
                    c.placeOrder(order);
                    assertFalse(StringUtils.isBlank(order.id));
                }
            }",iterator
i,"for (var i = -10; i < 10; i++) {
      for (var j = -10; j < 10; j++) {
        testData.add(Arguments.of(
            new NumberExpression(i),
            new NumberExpression(j),
            resultCalc.applyAsInt(i, j)
        ));
      }
    }",loop_control
j,"for (var j = -10; j < 10; j++) {
        testData.add(Arguments.of(
            new NumberExpression(i),
            new NumberExpression(j),
            resultCalc.applyAsInt(i, j)
        ));
      }",loop_control
s,"for (var s : tokenList) {
      if (isOperator(s)) {
        // when an operator is encountered we expect that the numbers can be popped from the top of
        // the stack
        var rightExpression = stack.pop();
        var leftExpression = stack.pop();
        LOGGER.info(""popped from stack left: {} right: {}"",
            leftExpression.interpret(), rightExpression.interpret());
        var operator = getOperatorInstance(s, leftExpression, rightExpression);
        LOGGER.info(""operator: {}"", operator);
        var result = operator.interpret();
        // the operation result is pushed on top of the stack
        var resultExpression = new NumberExpression(result);
        stack.push(resultExpression);
        LOGGER.info(""push result to stack: {}"", resultExpression.interpret());
      } else {
        // numbers are pushed on top of the stack
        var i = new NumberExpression(s);
        stack.push(i);
        LOGGER.info(""push to stack: {}"", i.interpret());
      }
    }",iterator
weekday,"for (final var weekday : Weekday.values()) {
      // Pass each week of the day, day by day to the event emitter
      emitter.timePasses(weekday);

      if (weekday == specialDay) {
        // On a special day, every observer should have received the event
        for (final var observer : observers) {
          verify(observer, times(1)).onEvent(eq(event));
        }
      } else {
        // On any other normal day, the observers should have received nothing at all
        verifyZeroInteractions(observers);
      }
    }",iterator
observer,"for (final var observer : observers) {
          verify(observer, times(1)).onEvent(eq(event));
        }",iterator
num,"for (final var num : nums) {
      sum += num;
    }",iterator
num,"for (final var num : nums) {
      sum *= num;
    }",iterator
i,"for (int i = 0; i < 51; i++) {
            var usageDetail = new UsageDetail();
            usageDetail.setUserId(""userId"" + i);
            usageDetail.setData(random.nextInt(500));
            usageDetail.setDuration(random.nextInt(500));

            usageDetailsList.add(usageDetail);
        }",loop_control
i,"for (int i = 0; i < 2; i++) {
            var usageDetail = new UsageDetail();
            usageDetail.setUserId(""userId"" + i);
            usageDetail.setData(i + 1);
            usageDetail.setDuration(i + 1);
            usageDetailsList.add(usageDetail);

            var usageCostDetail = new UsageCostDetail();
            usageCostDetail.setUserId(usageDetail.getUserId());
            usageCostDetail.setDataCost(usageDetail.getData() * 0.20);
            usageCostDetail.setCallCost(usageDetail.getDuration() * 0.30);
            usageCostDetailsList.add(usageCostDetail);
        }",loop_control
eventGridEvent,"for (var eventGridEvent : eventGridEvents) {
        // Handle system events
        if (eventGridEvent.getEventType()
            .equals(""Microsoft.EventGrid.SubscriptionValidationEvent"")) {
          SubscriptionValidationEventData subscriptionValidationEventData = eventGridEvent.getData()
              .toObject(SubscriptionValidationEventData.class);
          // Handle the subscription validation event
          var responseData = new SubscriptionValidationResponse();
          responseData.setValidationResponse(subscriptionValidationEventData.getValidationCode());
          return request.createResponseBuilder(HttpStatus.OK).body(responseData).build();

        } else if (eventGridEvent.getEventType().equals(""UsageDetail"")) {
          // Get message header and reference
          var messageReference = eventGridEvent.getData()
              .toObject(MessageReference.class);

          // Read message from persistent storage
          var message = this.messageHandlerUtilityForUsageDetail
              .readFromPersistantStorage(messageReference, context.getLogger());

          // Get Data and generate cost details
          List<UsageDetail> usageDetailsList = BinaryData.fromObject(
              message.getMessageBody().getData())
              .toObject(new TypeReference<>() {
              });
          var usageCostDetailsList = calculateUsageCostDetails(usageDetailsList);

          // Create message body
          var newMessageBody = new MessageBody<UsageCostDetail>();
          newMessageBody.setData(usageCostDetailsList);

          // Create message header
          var newMessageReference = new MessageReference(""callusageapp"",
              eventGridEvent.getId() + ""/output.json"");
          var newMessageHeader = new MessageHeader();
          newMessageHeader.setId(eventGridEvent.getId());
          newMessageHeader.setSubject(""UsageCostProcessor"");
          newMessageHeader.setTopic("""");
          newMessageHeader.setEventType(""UsageCostDetail"");
          newMessageHeader.setEventTime(OffsetDateTime.now().toString());
          newMessageHeader.setData(newMessageReference);
          newMessageHeader.setDataVersion(""v1.0"");

          // Create entire message
          var newMessage = new Message<UsageCostDetail>();
          newMessage.setMessageHeader(newMessageHeader);
          newMessage.setMessageBody(newMessageBody);

          // Drop data to persistent storage
          this.messageHandlerUtilityForUsageCostDetail.dropToPersistantStorage(newMessage,
              context.getLogger());

          context.getLogger().info(""Message is dropped successfully"");
          return request.createResponseBuilder(HttpStatus.OK)
              .body(""Message is dropped successfully"").build();
        }
      }",iterator
eventGridEvent,"for (EventGridEvent eventGridEvent : eventGridEvents) {
        // Handle system events
        if (eventGridEvent.getEventType()
            .equals(""Microsoft.EventGrid.SubscriptionValidationEvent"")) {
          SubscriptionValidationEventData subscriptionValidationEventData = eventGridEvent.getData()
              .toObject(SubscriptionValidationEventData.class);
          // Handle the subscription validation event
          var responseData = new SubscriptionValidationResponse();
          responseData.setValidationResponse(subscriptionValidationEventData.getValidationCode());
          return request.createResponseBuilder(HttpStatus.OK).body(responseData).build();

        } else if (eventGridEvent.getEventType().equals(""UsageDetail"")) {
          // Create message body
          var messageBody = new MessageBody<UsageDetail>();
          var usageDetailsList = new ArrayList<UsageDetail>();
          var random = new Random();
          for (int i = 0; i < 51; i++) {
            var usageDetail = new UsageDetail();
            usageDetail.setUserId(""userId"" + i);
            usageDetail.setData(random.nextInt(500));
            usageDetail.setDuration(random.nextInt(500));

            usageDetailsList.add(usageDetail);
          }
          messageBody.setData(usageDetailsList);

          // Create message header
          var messageHeader = new MessageHeader();
          messageHeader.setId(UUID.randomUUID().toString());
          messageHeader.setSubject(""UsageDetailPublisher"");
          messageHeader.setTopic(""usagecostprocessorfunction-topic"");
          messageHeader.setEventType(""UsageDetail"");
          messageHeader.setEventTime(OffsetDateTime.now().toString());
          var messageReference = new MessageReference(""callusageapp"",
              messageHeader.getId() + ""/input.json"");
          messageHeader.setData(messageReference);
          messageHeader.setDataVersion(""v1.0"");

          // Create entire message
          var message = new Message<UsageDetail>();
          message.setMessageHeader(messageHeader);
          message.setMessageBody(messageBody);

          // Drop data to persistent storage
          this.messageHandlerUtility.dropToPersistantStorage(message, context.getLogger());

          // Publish event to event grid topic
          eventHandlerUtility.publishEvent(messageHeader, context.getLogger());

          context.getLogger().info(""Message is dropped and event is published successfully"");
          return request.createResponseBuilder(HttpStatus.OK).body(message).build();
        }
      }",iterator
i,"for (int i = 0; i < 51; i++) {
            var usageDetail = new UsageDetail();
            usageDetail.setUserId(""userId"" + i);
            usageDetail.setData(random.nextInt(500));
            usageDetail.setDuration(random.nextInt(500));

            usageDetailsList.add(usageDetail);
          }",loop_control
layer,"for (final var layer : availableLayers) {
      assertNotNull(layer.id);
      assertNotNull(layer.name);
      assertNotNull(layer.toString());
      assertTrue(layer.calories > 0);
    }",iterator
topping,"for (final var topping : availableToppings) {
      assertNotNull(topping.id);
      assertNotNull(topping.name);
      assertNotNull(topping.toString());
      assertTrue(topping.calories > 0);
    }",iterator
cakeInfo,"for (final var cakeInfo : allCakes) {
      assertNotNull(cakeInfo.id);
      assertNotNull(cakeInfo.cakeToppingInfo);
      assertNotNull(cakeInfo.cakeLayerInfos);
      assertNotNull(cakeInfo.toString());
      assertFalse(cakeInfo.cakeLayerInfos.isEmpty());
      assertTrue(cakeInfo.calculateTotalCalories() > 0);
    }",iterator
info,"for (var info : cakeInfo.cakeLayerInfos) {
      var found = allLayers.stream().filter(layer -> layer.getName().equals(info.name)).findFirst();
      if (found.isEmpty()) {
        throw new CakeBakingException(String.format(""Layer %s is not available"", info.name));
      } else {
        foundLayers.add(found.get());
      }
    }",iterator
layer,"for (var info : cakeInfo.cakeLayerInfos) {
      var found = allLayers.stream().filter(layer -> layer.getName().equals(info.name)).findFirst();
      if (found.isEmpty()) {
        throw new CakeBakingException(String.format(""Layer %s is not available"", info.name));
      } else {
        foundLayers.add(found.get());
      }
    }",iterator
layer,"for (var layer : foundLayers) {
        layer.setCake(cake);
        layerBean.save(layer);
      }",iterator
topping,"for (CakeTopping topping : bean.findAll()) {
      if (topping.getCake() == null) {
        result.add(topping);
      }
    }",iterator
next,"for (CakeTopping next : bean.findAll()) {
      if (next.getCake() == null) {
        result.add(new CakeToppingInfo(next.getId(), next.getName(), next.getCalories()));
      }
    }",iterator
next,"for (CakeLayer next : bean.findAll()) {
      if (next.getCake() == null) {
        result.add(next);
      }
    }",iterator
next,"for (CakeLayer next : bean.findAll()) {
      if (next.getCake() == null) {
        result.add(new CakeLayerInfo(next.getId(), next.getName(), next.getCalories()));
      }
    }",iterator
cake,"for (Cake cake : cakeBean.findAll()) {
      var cakeToppingInfo =
          new CakeToppingInfo(cake.getTopping().getId(), cake.getTopping().getName(), cake
              .getTopping().getCalories());
      List<CakeLayerInfo> cakeLayerInfos = new ArrayList<>();
      for (var layer : cake.getLayers()) {
        cakeLayerInfos.add(new CakeLayerInfo(layer.getId(), layer.getName(), layer.getCalories()));
      }
      var cakeInfo = new CakeInfo(cake.getId(), cakeToppingInfo, cakeLayerInfos);
      result.add(cakeInfo);
    }",iterator
layer,"for (var layer : cake.getLayers()) {
        cakeLayerInfos.add(new CakeLayerInfo(layer.getId(), layer.getName(), layer.getCalories()));
      }",iterator
i,"for (var i = 1; i < 20; i++) {
      weather.timePasses();
      inOrder.verify(observer).update(weatherTypes[i % weatherTypes.length]);
    }",loop_control
i,"for (var i = 1; i < 20; i++) {
      weather.timePasses();
      inOrder.verify(observer).update(weather, weatherTypes[i % weatherTypes.length]);
    }",loop_control
obs,"for (var obs : observers) {
      obs.update(currentWeather);
    }",iterator
observer,"for (var observer : observers) {
      observer.update((S) this, argument);
    }",iterator
i,"for (int i = 0; i < 3; i++) {
      executorService.execute(washingMachine::wash);
    }",loop_control
book,"for (final var book : allBooks) {
      final var spellByName = dao.findByName(book.getName());
      assertNotNull(spellByName);
      assertEquals(book.getId(), spellByName.getId());
      assertEquals(book.getName(), spellByName.getName());
    }",iterator
i,"for (int i = 0; i < INITIAL_COUNT; i++) {
      final var className = dao.persistentClass.getSimpleName();
      final var entityName = String.format(""%s%d"", className, ID_GENERATOR.incrementAndGet());
      this.dao.persist(this.factory.apply(entityName));
    }",loop_control
entity,"for (final var entity : all) {
      final var byId = this.dao.find(entity.getId());
      assertNotNull(byId);
      assertEquals(byId.getId(), byId.getId());
    }",iterator
spell,"for (final var spell : allWizards) {
      final var byName = dao.findByName(spell.getName());
      assertNotNull(byName);
      assertEquals(spell.getId(), byName.getId());
      assertEquals(spell.getName(), byName.getName());
    }",iterator
spell,"for (final var spell : allSpells) {
      final var spellByName = dao.findByName(spell.getName());
      assertNotNull(spellByName);
      assertEquals(spell.getId(), spellByName.getId());
      assertEquals(spell.getName(), spellByName.getName());
    }",iterator
car,"for (Car car : cars) {
      if (car.getYear() > 2000) {
        carsSortedByYear.add(car);
      }
    }",iterator
car,"for (Car car : carsSortedByYear) {
      models.add(car.getModel());
    }",iterator
car,"for (Car car : cars) {
      if (groupingByCategory.containsKey(car.getCategory())) {
        groupingByCategory.get(car.getCategory()).add(car);
      } else {
        List<Car> categoryCars = new ArrayList<>();
        categoryCars.add(car);
        groupingByCategory.put(car.getCategory(), categoryCars);
      }
    }",iterator
person,"for (Person person : persons) {
      cars.addAll(person.getCars());
    }",iterator
car,"for (Car car : cars) {
      if (Category.SEDAN.equals(car.getCategory())) {
        sedanCars.add(car);
      }
    }",iterator
content,"for (final var content : Content.values()) {
      final var toString = content.toString();
      assertNotNull(toString);
      assertFalse(toString.trim().isEmpty());
    }",iterator
menuItem,"for (final var menuItem : MenuItem.values()) {
      final var toString = menuItem.toString();
      assertNotNull(toString);
      assertFalse(toString.trim().isEmpty());
    }",iterator
item,"for (var item : MenuItem.values()) {
      if (selected.equals(item)) {
        LOGGER.info(""* {}"", item);
      } else {
        LOGGER.info(item.toString());
      }
    }",iterator
customer,"for (var customer : generateSampleCustomers()) {
      customerDao.add(customer);
    }",iterator
room,"for (var room : generateSampleRooms()) {
      hotelDao.add(room);
    }",iterator
room,"for (var room : generateSampleRooms()) {
      hotelDao.add(room);
    }",iterator
i,"for (var i = 0; i < rows; i++) {
      for (var j = 0; j < columns; j++) {
        inputMatrix[i][j] = rand.nextInt(10);
      }
    }",loop_control
i,"{
    var rows = 10;
    var columns = 10;
    var inputMatrix = new int[rows][columns];
    var rand = new Random();
    for (var i = 0; i < rows; i++) {
      for (var j = 0; j < columns; j++) {
        inputMatrix[i][j] = rand.nextInt(10);
      }
    }
    var i = new ArrayInput(inputMatrix);
    var table = i.divideData(4);
    var division1 = new int[][]{inputMatrix[0], inputMatrix[1], inputMatrix[2]};
    var division2 = new int[][]{inputMatrix[3], inputMatrix[4], inputMatrix[5]};
    var division3 = new int[][]{inputMatrix[6], inputMatrix[7]};
    var division4 = new int[][]{inputMatrix[8], inputMatrix[9]};
    assertTrue(matricesSame(table.get(0).data, division1)
        && matricesSame(table.get(1).data, division2)
        && matricesSame(table.get(2).data, division3)
        && matricesSame(table.get(3).data, division4));
  }",loop_control
j,"for (var j = 0; j < columns; j++) {
        inputMatrix[i][j] = rand.nextInt(10);
      }",loop_control
i,"for (var i = 0; i < a1.length; i++) {
        if (a1[i] == a2[i]) {
          answer = true;
        } else {
          answer = false;
          break;
        }
      }",loop_control
i,"for (var i = 0; i < a1.length; i++) {
        if (a1[i] == a2[i]) {
          answer = true;
        } else {
          answer = false;
          break;
        }
      }",break_loop_control
i,"for (var i = 0; i < m1.length; i++) {
        if (arraysSame(m1[i], m2[i])) {
          answer = true;
        } else {
          answer = false;
          break;
        }
      }",loop_control
i,"for (var i = 0; i < m1.length; i++) {
        if (arraysSame(m1[i], m2[i])) {
          answer = true;
        } else {
          answer = false;
          break;
        }
      }",break_loop_control
i,"for (var i = 0; i < rows; i++) {
      for (var j = 0; j < columns; j++) {
        //filling cells in matrix
        matrix[i][j] = RANDOM.nextInt(10);
      }
    }",loop_control
j,"for (var j = 0; j < columns; j++) {
        //filling cells in matrix
        matrix[i][j] = RANDOM.nextInt(10);
      }",loop_control
ints,"for (var ints : matrix) {
      for (var j = 0; j < matrix[0].length; j++) {
        LOGGER.info(ints[j] + "" "");
      }
      LOGGER.info("""");
    }",iterator
j,"for (var j = 0; j < matrix[0].length; j++) {
        LOGGER.info(ints[j] + "" "");
      }",loop_control
i,"for (var i = 0; i < num; i++) {
        var rows = divisions[i];
        if (rows != 0) {
          var divided = new int[rows][this.data[0].length];
          System.arraycopy(this.data, rowsDone, divided, 0, rows);
          rowsDone += rows;
          var dividedInput = new ArrayInput(divided);
          result.add(dividedInput);
        } else {
          break; //rest of divisions will also be 0
        }
      }",loop_control
rows,"for (var i = 0; i < num; i++) {
        var rows = divisions[i];
        if (rows != 0) {
          var divided = new int[rows][this.data[0].length];
          System.arraycopy(this.data, rowsDone, divided, 0, rows);
          rowsDone += rows;
          var dividedInput = new ArrayInput(divided);
          result.add(dividedInput);
        } else {
          break; //rest of divisions will also be 0
        }
      }",break_loop_control
i,"for (var i = 0; i < cols; i++) {
      for (var j = 0; j < rows; j++) {
        //flipping element positions along diagonal
        resultData[j][i] = arrayInput.data[i][j];
      }
    }",loop_control
j,"for (var j = 0; j < rows; j++) {
        //flipping element positions along diagonal
        resultData[j][i] = arrayInput.data[i][j];
      }",loop_control
i,"for (var i = 0; i < this.expectedNumResults; i++) {
        //ith division given to ith worker in this.workers
        this.workers.get(i).setReceivedData(this, dividedInput.get(i));
        this.workers.get(i).start();
      }",loop_control
i,"for (var i = 0; i < this.expectedNumResults; i++) {
        try {
          this.workers.get(i).join();
        } catch (InterruptedException e) {
          System.err.println(""Error while executing thread"");
        }
      }",loop_control
elements,"{
    // number of rows in final result is number of rows in any of obtained results from workers
    var allResultData = this.getAllResultData();
    var rows = ((ArrayResult) allResultData.elements().nextElement()).data.length;
    var elements = allResultData.elements();
    var columns = 0; // columns = sum of number of columns in all results obtained from workers
    while (elements.hasMoreElements()) {
      columns += ((ArrayResult) elements.nextElement()).data[0].length;
    }
    var resultData = new int[rows][columns];
    var columnsDone = 0; //columns aggregated so far
    var workers = this.getWorkers();
    for (var i = 0; i < this.getExpectedNumResults(); i++) {
      //result obtained from ith worker
      var worker = workers.get(i);
      var workerId = worker.getWorkerId();
      var work = ((ArrayResult) allResultData.get(workerId)).data;
      for (var m = 0; m < work.length; m++) {
        //m = row number, n = columns number
        System.arraycopy(work[m], 0, resultData[m], columnsDone, work[0].length);
      }
      columnsDone += work[0].length;
    }
    return new ArrayResult(resultData);
  }",maybe_loop_control
i,"for (var i = 0; i < this.getExpectedNumResults(); i++) {
      //result obtained from ith worker
      var worker = workers.get(i);
      var workerId = worker.getWorkerId();
      var work = ((ArrayResult) allResultData.get(workerId)).data;
      for (var m = 0; m < work.length; m++) {
        //m = row number, n = columns number
        System.arraycopy(work[m], 0, resultData[m], columnsDone, work[0].length);
      }
      columnsDone += work[0].length;
    }",loop_control
m,"for (var m = 0; m < work.length; m++) {
        //m = row number, n = columns number
        System.arraycopy(work[m], 0, resultData[m], columnsDone, work[0].length);
      }",loop_control
i,"for (var i = 0; i < cp.randomCode.length; i++) {
      ht.putIfAbsent(cp.randomCode[i].name, true);
      if (cp.randomCode[i].name.equals(""fruit"") || cp.randomCode[i].name.equals(""candy"")) {
        parentTypes++;
      }
    }",loop_control
o,"for (var o : a) {
      var candy = (JSONObject) o;
      var name = (String) candy.get(""name"");
      var parentName = (String) candy.get(""parent"");
      var t = (String) candy.get(""type"");
      var type = Type.CRUSHABLE_CANDY;
      if (t.equals(""rewardFruit"")) {
        type = Type.REWARD_FRUIT;
      }
      var points = Integer.parseInt((String) candy.get(""points""));
      var c = new Candy(name, parentName, type, points);
      this.candies.put(name, c);
    }",iterator
e,"for (var e = this.candies.keys(); e.hasMoreElements(); ) {
      var c = this.candies.get(e.nextElement());
      if (c.parentName == null) {
        c.parent = null;
      } else {
        c.parent = this.candies.get(c.parentName);
      }
      if (c.getPoints() == 0 && c.parent != null) {
        c.setPoints(c.parent.getPoints());
      }
    }",maybe_loop_control
y,"for (var y = this.positionY; y > 0; y--) {
      cellMatrix[y][this.positionX] = cellMatrix[y - 1][this.positionX];
      cellMatrix[y][this.positionX].positionY = y;
    }",loop_control
i,"for (var i = 0; i < num; i++) {
      for (var j = 0; j < num; j++) {
        this.cells[i][j] = this.pool.getNewCell();
        this.cells[i][j].positionX = j;
        this.cells[i][j].positionY = i;
      }
    }",loop_control
j,"for (var j = 0; j < num; j++) {
        this.cells[i][j] = this.pool.getNewCell();
        this.cells[i][j].positionX = j;
        this.cells[i][j].positionY = i;
      }",loop_control
j,"for (var j = 0; j < cells.length; j++) {
        var candyName = cell[j].candy.name;
        if (candyName.length() < 20) {
          var totalSpaces = 20 - candyName.length();
          LOGGER.info(numOfSpaces(totalSpaces / 2) + cell[j].candy.name
              + numOfSpaces(totalSpaces - totalSpaces / 2) + ""|"");
        } else {
          LOGGER.info(candyName + ""|"");
        }
      }",loop_control
cell,"for (Cell[] cell : cells) {
      for (var j = 0; j < cells.length; j++) {
        var candyName = cell[j].candy.name;
        if (candyName.length() < 20) {
          var totalSpaces = 20 - candyName.length();
          LOGGER.info(numOfSpaces(totalSpaces / 2) + cell[j].candy.name
              + numOfSpaces(totalSpaces - totalSpaces / 2) + ""|"");
        } else {
          LOGGER.info(candyName + ""|"");
        }
      }
      LOGGER.info("""");
    }",iterator
i,"for (var i = 0; i < this.cells.length; i++) {
      if (this.cells[cells.length - 1][i].candy.getType().equals(Type.REWARD_FRUIT)) {
        return true;
      }
    }",loop_control
i,"for (var i = 0; i < this.cells.length; i++) {
      for (var j = 0; j < this.cells.length; j++) {
        if (!this.cells[i][j].candy.getType().equals(Type.REWARD_FRUIT)) {
          var adj = adjacentCells(i, j);
          for (Cell cell : adj) {
            if (this.cells[i][j].candy.name.equals(cell.candy.name)) {
              return true;
            }
          }
        }
      }
    }",loop_control
j,"for (var j = 0; j < this.cells.length; j++) {
        if (!this.cells[i][j].candy.getType().equals(Type.REWARD_FRUIT)) {
          var adj = adjacentCells(i, j);
          for (Cell cell : adj) {
            if (this.cells[i][j].candy.name.equals(cell.candy.name)) {
              return true;
            }
          }
        }
      }",loop_control
cell,"for (Cell cell : adj) {
            if (this.cells[i][j].candy.name.equals(cell.candy.name)) {
              return true;
            }
          }",iterator
end,"{
    var start = System.currentTimeMillis();
    var end = System.currentTimeMillis();
    while (end - start + timeSoFar < totalTime && continueRound()) {
      for (var i = 0; i < this.cells.length; i++) {
        var points = 0;
        var j = this.cells.length - 1;
        while (this.cells[j][i].candy.getType().equals(Type.REWARD_FRUIT)) {
          points = this.cells[j][i].candy.getPoints();
          this.cells[j][i].crush(pool, this.cells);
          handleChange(points);
        }
      }
      for (var i = 0; i < this.cells.length; i++) {
        var j = cells.length - 1;
        var points = 0;
        while (j > 0) {
          points = this.cells[j][i].interact(this.cells[j - 1][i], this.pool, this.cells);
          if (points != 0) {
            handleChange(points);
          } else {
            j = j - 1;
          }
        }
      }
      for (Cell[] cell : this.cells) {
        var j = 0;
        var points = 0;
        while (j < cells.length - 1) {
          points = cell[j].interact(cell[j + 1], this.pool, this.cells);
          if (points != 0) {
            handleChange(points);
          } else {
            j = j + 1;
          }
        }
      }
      end = System.currentTimeMillis();
    }
  }",loop_control
start,"{
    var start = System.currentTimeMillis();
    var end = System.currentTimeMillis();
    while (end - start + timeSoFar < totalTime && continueRound()) {
      for (var i = 0; i < this.cells.length; i++) {
        var points = 0;
        var j = this.cells.length - 1;
        while (this.cells[j][i].candy.getType().equals(Type.REWARD_FRUIT)) {
          points = this.cells[j][i].candy.getPoints();
          this.cells[j][i].crush(pool, this.cells);
          handleChange(points);
        }
      }
      for (var i = 0; i < this.cells.length; i++) {
        var j = cells.length - 1;
        var points = 0;
        while (j > 0) {
          points = this.cells[j][i].interact(this.cells[j - 1][i], this.pool, this.cells);
          if (points != 0) {
            handleChange(points);
          } else {
            j = j - 1;
          }
        }
      }
      for (Cell[] cell : this.cells) {
        var j = 0;
        var points = 0;
        while (j < cells.length - 1) {
          points = cell[j].interact(cell[j + 1], this.pool, this.cells);
          if (points != 0) {
            handleChange(points);
          } else {
            j = j + 1;
          }
        }
      }
      end = System.currentTimeMillis();
    }
  }",loop_control
i,"for (var i = 0; i < this.cells.length; i++) {
        var points = 0;
        var j = this.cells.length - 1;
        while (this.cells[j][i].candy.getType().equals(Type.REWARD_FRUIT)) {
          points = this.cells[j][i].candy.getPoints();
          this.cells[j][i].crush(pool, this.cells);
          handleChange(points);
        }
      }",loop_control
i,"for (var i = 0; i < this.cells.length; i++) {
        var j = cells.length - 1;
        var points = 0;
        while (j > 0) {
          points = this.cells[j][i].interact(this.cells[j - 1][i], this.pool, this.cells);
          if (points != 0) {
            handleChange(points);
          } else {
            j = j - 1;
          }
        }
      }",loop_control
j,"for (var i = 0; i < this.cells.length; i++) {
        var points = 0;
        var j = this.cells.length - 1;
        while (this.cells[j][i].candy.getType().equals(Type.REWARD_FRUIT)) {
          points = this.cells[j][i].candy.getPoints();
          this.cells[j][i].crush(pool, this.cells);
          handleChange(points);
        }
      }",loop_control
j,"for (var i = 0; i < this.cells.length; i++) {
        var j = cells.length - 1;
        var points = 0;
        while (j > 0) {
          points = this.cells[j][i].interact(this.cells[j - 1][i], this.pool, this.cells);
          if (points != 0) {
            handleChange(points);
          } else {
            j = j - 1;
          }
        }
      }",loop_control
j,"for (Cell[] cell : this.cells) {
        var j = 0;
        var points = 0;
        while (j < cells.length - 1) {
          points = cell[j].interact(cell[j + 1], this.pool, this.cells);
          if (points != 0) {
            handleChange(points);
          } else {
            j = j + 1;
          }
        }
      }",loop_control
cell,"for (Cell[] cell : this.cells) {
        var j = 0;
        var points = 0;
        while (j < cells.length - 1) {
          points = cell[j].interact(cell[j + 1], this.pool, this.cells);
          if (points != 0) {
            handleChange(points);
          } else {
            j = j + 1;
          }
        }
      }",iterator
i,"for (int i = 0; i < num; i++) {
      var c = new Cell();
      c.candy = randomCode[RANDOM.nextInt(randomCode.length)];
      this.pool.add(c);
    }",loop_control
e,"for (var e = jp.candies.keys(); e.hasMoreElements(); ) {
      var s = e.nextElement();
      if (!s.equals(FRUIT) && !s.equals(CANDY)) {
        //not generic
        randomCode[i] = jp.candies.get(s);
        i++;
      }
    }",maybe_loop_control
arg,"for (String arg : args) {
      if (arg.equals(USE_MONGO_DB)) {
        return true;
      }
    }",iterator
i,"for (var i = 0; i < paramNumber; i++) {
      final var fs = new SimpleObjectCreate().setName(names.get(i));
      ec.executeChild(this, fs.getName(), fs);
      simpleObjects.add(fs.getSimpleObject());
    }",loop_control
letter,"for (char letter : letters) {
      this.add(new Letter(letter));
    }",iterator
name,"for (final var name : NazgulName.values()) {
      final var nazgul = Nazgul.getInstance(name);
      assertNotNull(nazgul);
      assertSame(nazgul, Nazgul.getInstance(name));
      assertEquals(name, nazgul.getName());
    }",iterator
weapon,"for (var weapon : weaponsToBeInserted) {
      LOGGER.info(""Inserting a new weapon {} to sales rack."", weapon.getName());
      weaponDatabase.insert(weapon);
    }",iterator
weapon,"for (var weapon : modifiedWeapons) {
      LOGGER.info(""Scheduling {} for modification work."", weapon.getName());
      weaponDatabase.modify(weapon);
    }",iterator
weapon,"for (var weapon : deletedWeapons) {
      LOGGER.info(""Scrapping {}."", weapon.getName());
      weaponDatabase.delete(weapon);
    }",iterator
i,"for (var i = 0; i < 20; i++) {
      stew.mix();
      assertEquals(expectedMessage, appender.getLastMessage());
    }",loop_control
i,"for (var i = 0; i < 20; i++) {
      stew.mix();
      assertEquals(expectedMessage, appender.getLastMessage());
    }",loop_control
dt,"for (var dt : res.getDateList()) {
      var cal = Calendar.getInstance();
      cal.setTime(dt);
      returnList.add(cal.get(Calendar.DAY_OF_MONTH) + "".""
          + cal.get(Calendar.MONTH) + "".""
          + cal.get(Calendar.YEAR)
      );
    }",iterator
i,"for (var i = 0; i < result.length; i++) {
        createdDateValues[i] = convertDatesToString(result[i]);
      }",loop_control
dt,"for (var dt : res.getDateList()) {
      var cal = Calendar.getInstance();
      cal.setTime(dt);
      returnList.add(cal.get(Calendar.DAY_OF_MONTH) + "".""
          + cal.get(Calendar.MONTH) + "".""
          + cal.get(Calendar.YEAR)
      );
    }",iterator
createdDateValue,"for (var createdDateValue : createdDateValues) {
      assertEquals(expectedDateValues, createdDateValue);
    }",iterator
value,"for (var value : result) {
      assertEquals(expectedCounterDateValues, value.getDateList().size());
    }",iterator
value,"for (var value : result) {
      assertEquals(expectedCounterExceptions, value.getExceptionList().size());
    }",iterator
value,"for (var value : result) {
        counterDateValues = counterDateValues + printAndCountDates(value);
        counterExceptions = counterExceptions + printAndCountExceptions(value);
      }",iterator
dt,"for (var dt : res.getDateList()) {
      counter++;
      var cal = Calendar.getInstance();
      cal.setTime(dt);
      // Formatted output of the date value: DD.MM.YYYY
      LOGGER.info(cal.get(Calendar.DAY_OF_MONTH) + "".""
          + cal.get(Calendar.MONTH) + "".""
          + cal.get(Calendar.YEAR)
      );
    }",iterator
ex,"for (var ex : res.getExceptionList()) {
      counter++;
      LOGGER.info(ex);
    }",iterator
message,"for (final var message : messages) {
      queue.put(message);
    }",iterator
i,"for (var i = 0; i < 10; i++) {
      assertEquals(this.expectedExecutionTime * i, this.factory.apply(i).getTimeMs());
    }",loop_control
user,"for (var user: generateSampleUsers()) {
      var id = userService.createUser(user);
      LOGGER.info(""Add user"" + user + ""at"" + id + ""."");
    }",iterator
user,"{
    // get service
    var userService = new UserService();
    // use create service to add users
    for (var user: generateSampleUsers()) {
      var id = userService.createUser(user);
      LOGGER.info(""Add user"" + user + ""at"" + id + ""."");
    }
    // use list service to get users
    var users = userService.listUser();
    LOGGER.info(String.valueOf(users));
    // use get service to get a user
    var user = userService.getUser(1);
    LOGGER.info(String.valueOf(user));
    // change password of user 1
    user.setPassword(""new123"");
    // use update service to update user 1
    userService.updateUser(1, user);
    // use delete service to delete user 2
    userService.deleteUser(2);
    // close service
    userService.close();
  }",iterator
iterator,"for (var iterator = userIter.iterator(); iterator.hasNext();) {
        users.add(iterator.next());
      }",iterator
anchor,"for (var anchor : albumLinks) {
      if (anchor.getTextContent().equals(albumTitle)) {
        try {
          anchor.click();
          return new AlbumPage(webClient);
        } catch (IOException e) {
          e.printStackTrace();
        }
      }
    }",iterator
anchor,"for (var anchor : albumLinks) {
      if (anchor.getTextContent().equals(albumTitle)) {
        try {
          anchor.click();
          return new AlbumPage(webClient);
        } catch (IOException e) {
          LOGGER.error(""An error occured on selectAlbum"", e);
        }
      }
    }",iterator
i,"for (int i = 0; i < 100; i++) {
        final var oliphaunt = pool.checkOut();
        assertEquals(""Pool available=0 inUse=1"", pool.toString());
        assertSame(expectedOliphaunt, oliphaunt);
        assertEquals(expectedOliphaunt.getId(), oliphaunt.getId());
        assertEquals(expectedOliphaunt.toString(), oliphaunt.toString());

        pool.checkIn(oliphaunt);
        assertEquals(""Pool available=1 inUse=0"", pool.toString());
      }",loop_control
i,"for (var i = 0; i < WORKERS; i++) {
      creatures.add(new Elf(String.format(""Elf %s"", i)));
      creatures.add(new Orc(String.format(""Orc %s"", i)));
      creatures.add(new Human(String.format(""Human %s"", i)));
    }",loop_control
i,"for (var i = 0; i < totalFiends; i = i + MULTIPLICATION_FACTOR) {
      service.submit(new Feind(creatures.get(i), sword));
      service.submit(new Feind(creatures.get(i + 1), sword));
      service.submit(new Feind(creatures.get(i + 2), sword));
    }",loop_control
lockable,"for (Lockable lockable : instruments) {
      lockable.unlock(this);
    }",iterator
id,"for (var id : tickets.keySet()) {
      var checkResult = service.checkTicketForPrize(id, winningNumbers);
      assertNotEquals(CheckResult.TICKET_NOT_SUBMITTED, checkResult.getResult());
      if (checkResult.getResult().equals(CheckResult.WIN_PRIZE)) {
        assertTrue(checkResult.getPrizeAmount() > 0);
      } else {
        assertEquals(0, checkResult.getPrizeAmount());
      }
    }",iterator
i,"for (var i = 0; i < numTickets; i++) {
      var randomPlayerDetails = getRandomPlayerDetails();
      var lotteryNumbers = LotteryNumbers.createRandom();
      var lotteryTicketId = new LotteryTicketId();
      var ticket = new LotteryTicket(lotteryTicketId, randomPlayerDetails, lotteryNumbers);
      lotteryService.submitTicket(ticket);
    }",loop_control
id,"for (var id : tickets.keySet()) {
      var lotteryTicket = tickets.get(id);
      var playerDetails = lotteryTicket.getPlayerDetails();
      var playerAccount = playerDetails.getBankAccount();
      var result = LotteryUtils.checkTicketForPrize(repository, id, numbers).getResult();
      if (result == LotteryTicketCheckResult.CheckResult.WIN_PRIZE) {
        if (wireTransfers.transferFunds(PRIZE_AMOUNT, SERVICE_BANK_ACCOUNT, playerAccount)) {
          notifications.ticketWon(playerDetails, PRIZE_AMOUNT);
        } else {
          notifications.prizeError(playerDetails, PRIZE_AMOUNT);
        }
      } else if (result == LotteryTicketCheckResult.CheckResult.NO_PRIZE) {
        notifications.ticketDidNotWin(playerDetails);
      }
    }",iterator
i,"for (int i = 0; i < stuff.length / 10; i++) {
        int a = (int) (Math.random() * stuff.length);
        int b = (int) (Math.random() * stuff.length);
        if (stuff[a] == '\n' || stuff[b] == '\n') {
          continue;  // skip newline characters
        }
        stuff[a] = selection.charAt(b);
        stuff[b] = selection.charAt(a);
      }",loop_control
warning,"for (String warning : warningsAccumulator) {
        System.out.print(tr(""Warning""));
        System.out.print("": "");
        System.out.println(warning);
      }",iterator
progressListener,"for (CompilerProgressListener progressListener : progressListeners){
        progressListener.progress(Double.valueOf(args[0].toString()).intValue());
      }",iterator
entry,"for (Map.Entry<String, String> entry : BaseNoGui.getBoardPreferences().entrySet()) {
        if (entry.getKey().startsWith(""runtime.tools"")) {
          cmd.add(""-prefs="" + entry.getKey() + ""="" + entry.getValue());
        }
    }",iterator
i,"for (int i = 0; i < compiledSketches.size(); i++) {
        saveHex(compiledSketches.get(i), copyOfCompiledSketches.get(i), dict);
        saveHex(compiledSketches.get(i), copyOfCompiledSketches.get(i), withBootloaderDict);
      }",loop_control
recipe,"for (String recipe : patterns) {
      runRecipe(recipe, prefs);
    }",iterator
string,"for (String string : command) {
      string = string.trim();
      if (string.length() != 0)
        stringList.add(string);
    }",iterator
c,"for (String c : command)
        System.out.print(c + "" "");",iterator
i,"for (int i = 1; i < command.length; i++) {
      commandLine.addArgument(command[i], false);
    }",loop_control
file,"for (SketchFile file : sketch.getFiles()) {
      if (new File(fileName).getName().equals(file.getFileName())) {
        return new RunnerException(message, file, line, col);
      }
    }",iterator
file,"for (File file : copyOfFiles) {
      if (file.exists() && file.canWrite()) {
        FileUtils.recursiveDelete(file);
      }
    }",iterator
c,"for (String c : command)
          System.out.print(c + "" "");",iterator
targetPackage,"for (TargetPackage targetPackage : BaseNoGui.packages.values()) {
      for (TargetPlatform targetPlatform : targetPackage.getPlatforms().values()) {
        for (TargetBoard board : targetPlatform.getBoards().values()) {
          if (matchesBoard(board)) {
            setBoardName(board.getName());
            return board;
          }
        }
      }
    }",iterator
targetPlatform,"for (TargetPlatform targetPlatform : targetPackage.getPlatforms().values()) {
        for (TargetBoard board : targetPlatform.getBoards().values()) {
          if (matchesBoard(board)) {
            setBoardName(board.getName());
            return board;
          }
        }
      }",iterator
board,"for (TargetBoard board : targetPlatform.getBoards().values()) {
          if (matchesBoard(board)) {
            setBoardName(board.getName());
            return board;
          }
        }",iterator
board,"for (TargetBoard board : targetPlatform.getBoards().values()) {
          if (matchesBoard(board)) {
            setBoardName(board.getName());
            return board;
          }
        }",break_loop_control
prop,"for (String prop : identificationProps.keySet()) {
        String value = identificationProps.get(prop);
        prop += ""."" + suffix;
        if (!boardProps.containsKey(prop)) {
          return false;
        }
        if (!value.equalsIgnoreCase(boardProps.get(prop))) {
          found = false;
          break;
        }
      }",iterator
value,"for (String prop : identificationProps.keySet()) {
        String value = identificationProps.get(prop);
        prop += ""."" + suffix;
        if (!boardProps.containsKey(prop)) {
          return false;
        }
        if (!value.equalsIgnoreCase(boardProps.get(prop))) {
          found = false;
          break;
        }
      }",break_loop_control
found,"for (int suffix = 0;; suffix++) {
      boolean found = true;
      for (String prop : identificationProps.keySet()) {
        String value = identificationProps.get(prop);
        prop += ""."" + suffix;
        if (!boardProps.containsKey(prop)) {
          return false;
        }
        if (!value.equalsIgnoreCase(boardProps.get(prop))) {
          found = false;
          break;
        }
      }
      if (found) {
        return true;
      }
    }",break_loop_control
boardProps,"{
    PreferencesMap identificationProps = getIdentificationPrefs();
    PreferencesMap boardProps = board.getPreferences();

    String wildMatcher = identificationProps.get(""."");
    if (wildMatcher != null) {
      if (wildMatcher.equals(board.getId())) {
        return true;
      }
      if (wildMatcher.equals(board.getFQBN())) {
        return true;
      }
    }

    // Identification properties are defined in boards.txt with a "".N"" suffix
    // for example:
    //
    // uno.name=Arduino/Genuino Uno
    // uno.vid.0=0x2341
    // uno.pid.0=0x0043
    // uno.vid.1=0x2341
    // uno.pid.1=0x0001
    // uno.vid.2=0x2A03
    // uno.pid.2=0x0043
    // uno.vid.3=0x2341
    // uno.pid.3=0x0243
    //
    // so we must search starting from suffix "".0"" and increasing until we
    // found a match or the board has no more identification properties defined

    for (int suffix = 0;; suffix++) {
      boolean found = true;
      for (String prop : identificationProps.keySet()) {
        String value = identificationProps.get(prop);
        prop += ""."" + suffix;
        if (!boardProps.containsKey(prop)) {
          return false;
        }
        if (!value.equalsIgnoreCase(boardProps.get(prop))) {
          found = false;
          break;
        }
      }
      if (found) {
        return true;
      }
    }
  }",break_loop_control
targetPackage,"for (TargetPackage targetPackage : packages.values()) {
      for (TargetPlatform platform: targetPackage.getPlatforms().values()) {
        //System.out.println(""installed: ""+platform);
        PreferencesMap prefs = platform.getPreferences().subTree(""discovery"");
        PreferencesMap pathPrefs = new PreferencesMap();
        File platformFolder = platform.getFolder();
        pathPrefs.put(""runtime.platform.path"", platformFolder.getAbsolutePath());
        pathPrefs.put(""runtime.hardware.path"", platformFolder.getParentFile().getAbsolutePath());
        for (String discoveryName : prefs.firstLevelMap().keySet()) {
          PreferencesMap discoveryPrefs = prefs.subTree(discoveryName);

          String pattern = discoveryPrefs.get(""pattern"");
          if (pattern == null) {
            System.out.println(format(tr(""No recipes defined for discovery '{0}'""),discoveryName));
            continue;
          }
          try {
            if (PreferencesData.getBoolean(""discovery.debug"")) {
              System.out.println(""found discovery: "" + discoveryName + "" -> "" + pattern);
              System.out.println(""with pathnames -> "" + pathPrefs);
              System.out.println(""with preferencess -> "" + discoveryPrefs);
            }
            pattern = StringReplacer.replaceFromMapping(pattern, PreferencesData.getMap());
            pattern = StringReplacer.replaceFromMapping(pattern, pathPrefs);
            String[] cmd = StringReplacer.formatAndSplit(pattern, discoveryPrefs);
            discoverers.add(new PluggableDiscovery(discoveryName, cmd));
          } catch (Exception e) {
            if (PreferencesData.getBoolean(""discovery.debug"")) {
              System.out.println(format(tr(""Could not start discovery '{0}': {1}""), discoveryName, e.getMessage()));
            }
          }
        }
      }
    }",iterator
platform,"for (TargetPlatform platform: targetPackage.getPlatforms().values()) {
        //System.out.println(""installed: ""+platform);
        PreferencesMap prefs = platform.getPreferences().subTree(""discovery"");
        PreferencesMap pathPrefs = new PreferencesMap();
        File platformFolder = platform.getFolder();
        pathPrefs.put(""runtime.platform.path"", platformFolder.getAbsolutePath());
        pathPrefs.put(""runtime.hardware.path"", platformFolder.getParentFile().getAbsolutePath());
        for (String discoveryName : prefs.firstLevelMap().keySet()) {
          PreferencesMap discoveryPrefs = prefs.subTree(discoveryName);

          String pattern = discoveryPrefs.get(""pattern"");
          if (pattern == null) {
            System.out.println(format(tr(""No recipes defined for discovery '{0}'""),discoveryName));
            continue;
          }
          try {
            if (PreferencesData.getBoolean(""discovery.debug"")) {
              System.out.println(""found discovery: "" + discoveryName + "" -> "" + pattern);
              System.out.println(""with pathnames -> "" + pathPrefs);
              System.out.println(""with preferencess -> "" + discoveryPrefs);
            }
            pattern = StringReplacer.replaceFromMapping(pattern, PreferencesData.getMap());
            pattern = StringReplacer.replaceFromMapping(pattern, pathPrefs);
            String[] cmd = StringReplacer.formatAndSplit(pattern, discoveryPrefs);
            discoverers.add(new PluggableDiscovery(discoveryName, cmd));
          } catch (Exception e) {
            if (PreferencesData.getBoolean(""discovery.debug"")) {
              System.out.println(format(tr(""Could not start discovery '{0}': {1}""), discoveryName, e.getMessage()));
            }
          }
        }
      }",iterator
discoveryName,"for (String discoveryName : prefs.firstLevelMap().keySet()) {
          PreferencesMap discoveryPrefs = prefs.subTree(discoveryName);

          String pattern = discoveryPrefs.get(""pattern"");
          if (pattern == null) {
            System.out.println(format(tr(""No recipes defined for discovery '{0}'""),discoveryName));
            continue;
          }
          try {
            if (PreferencesData.getBoolean(""discovery.debug"")) {
              System.out.println(""found discovery: "" + discoveryName + "" -> "" + pattern);
              System.out.println(""with pathnames -> "" + pathPrefs);
              System.out.println(""with preferencess -> "" + discoveryPrefs);
            }
            pattern = StringReplacer.replaceFromMapping(pattern, PreferencesData.getMap());
            pattern = StringReplacer.replaceFromMapping(pattern, pathPrefs);
            String[] cmd = StringReplacer.formatAndSplit(pattern, discoveryPrefs);
            discoverers.add(new PluggableDiscovery(discoveryName, cmd));
          } catch (Exception e) {
            if (PreferencesData.getBoolean(""discovery.debug"")) {
              System.out.println(format(tr(""Could not start discovery '{0}': {1}""), discoveryName, e.getMessage()));
            }
          }
        }",iterator
d,"for (Discovery d : discoverers) {
      try {
        new Thread(d).start();
      } catch (Exception e) {
        System.err.println(tr(""Error starting discovery method: "") + d.toString());
        e.printStackTrace();
      }
    }",iterator
d,"for (Discovery d : discoverers) {
        try {
          d.stop();
        } catch (Exception e) {
          e.printStackTrace(); //just printing as the JVM is terminating
        }
      }",iterator
d,"for (Discovery d : discoverers) {
      res.addAll(d.listDiscoveredBoards());
    }",iterator
d,"for (Discovery d : discoverers) {
      res.addAll(d.listDiscoveredBoards(complete));
    }",iterator
boardPort,"for (BoardPort boardPort : discovery()) {
      if (boardPort.getAddress().equals(address)) {
        return boardPort;
      }
    }",iterator
boardPort,"for (BoardPort boardPort : discovery(complete)) {
      if (boardPort.getAddress().equals(address)) {
        return boardPort;
      }
    }",iterator
boardPort,"for (BoardPort boardPort : discovery(complete)) {
      if (boardPort.getAddress().equals(address)) {
        return boardPort;
      }
    }",break_loop_control
boardPort,"for (BoardPort boardPort : discovery()) {
      if (boardPort.getAddress().equals(address)) {
        return boardPort;
      }
    }",break_loop_control
inetAddress,"for (InetAddress inetAddress : info.getInet4Addresses()) {
      String address = inetAddress.getHostAddress();
      String name = serviceEvent.getName();

      BoardPort port = new BoardPort();

      String board = null;
      String description = null;
      if (info.hasData()) {
        board = info.getPropertyString(""board"");
        description = info.getPropertyString(""description"");
        port.getPrefs().put(""board"", board);
        port.getPrefs().put(""distro_version"", info.getPropertyString(""distro_version""));
        port.getPrefs().put(""port"", """" + info.getPort());

        //Add additional fields to permit generic ota updates
        //and make sure we do not intefere with Arduino boards
        // define ""ssh_upload=no"" TXT property to use generic uploader
        // define ""tcp_check=no"" TXT property if you are not using TCP
        // define ""auth_upload=yes"" TXT property if you want to use authenticated generic upload
        String useSSH = info.getPropertyString(""ssh_upload"");
        String checkTCP = info.getPropertyString(""tcp_check"");
        String useAuth = info.getPropertyString(""auth_upload"");
        if(useSSH == null || !useSSH.contentEquals(""no"")) useSSH = ""yes"";
        if(checkTCP == null || !checkTCP.contentEquals(""no"")) checkTCP = ""yes"";
        if(useAuth == null || !useAuth.contentEquals(""yes"")) useAuth = ""no"";
        port.getPrefs().put(""ssh_upload"", useSSH);
        port.getPrefs().put(""tcp_check"", checkTCP);
        port.getPrefs().put(""auth_upload"", useAuth);
      }

      String label = name + "" at "" + address;
      if (board != null && BaseNoGui.packages != null) {
        String boardName = BaseNoGui.getPlatform().resolveDeviceByBoardID(BaseNoGui.packages, board);
        port.setBoardName(boardName);
      } else if (description != null) {
        label += "" ("" + description + "")"";
      }

      port.setAddress(address);
      port.setProtocol(""network"");
      port.setLabel(label);

      synchronized (boardPortsDiscoveredWithJmDNS) {
        removeDuplicateBoards(port);
        boardPortsDiscoveredWithJmDNS.add(port);
      }
    }",iterator
port,"for (BoardPort port : serialBoardPorts) {
        if (port.isOnline() == true) {
          onlineBoardPorts.add(port);
        }
      }",iterator
board,"for (BoardPort board : boardPorts) {
      if (!ports.contains(board.toCompleteString())) {
        board.setOnlineStatus(false);
      }
    }",iterator
board,"{
        boardPort.getPrefs().put(""vid"", boardData.get(""vid"").toString());
        boardPort.getPrefs().put(""pid"", boardData.get(""pid"").toString());

        String iserial = boardData.get(""iserial"").toString();
        boardPort.getPrefs().put(""iserial"", iserial);

        TargetBoard board = (TargetBoard) boardData.get(""board"");
        if (board != null) {
          String boardName = board.getName();
          boardPort.setBoardName(boardName);
        }
      }",iterator
newPort,"for (String newPort : ports) {

      // if port has been already discovered bring it back online
      BoardPort oldBoardPort = boardPorts.stream() //
          .filter(bp -> bp.toCompleteString().equalsIgnoreCase(newPort)) //
          .findAny().orElse(null);
      if (oldBoardPort != null) {
        oldBoardPort.setOnlineStatus(true);
        continue;
      }

      // Otherwise build a BoardPort object out of it and add it to
      // to the known boardPorts

      String[] parts = newPort.split(""_"");
      if (parts.length < 3) {
        // something went horribly wrong
        continue;
      }
      if (parts.length > 3) {
        // port name with _ in it (like CP2102 on OSX)
        for (int i = 1; i < (parts.length-2); i++) {
          parts[0] += ""_"" + parts[i];
        }
        parts[1] = parts[parts.length-2];
        parts[2] = parts[parts.length-1];
      }

      String port = parts[0];

      BoardPort boardPort = new BoardPort();
      boardPorts.add(boardPort);
      boardPort.setAddress(port);
      boardPort.setProtocol(""serial"");
      boardPort.setOnlineStatus(true);
      boardPort.setLabel(port);

      Map<String, Object> boardData = platform.resolveDeviceByVendorIdProductId(port, BaseNoGui.packages);
      if (boardData != null) {
        boardPort.getPrefs().put(""vid"", boardData.get(""vid"").toString());
        boardPort.getPrefs().put(""pid"", boardData.get(""pid"").toString());

        String iserial = boardData.get(""iserial"").toString();
        boardPort.getPrefs().put(""iserial"", iserial);

        TargetBoard board = (TargetBoard) boardData.get(""board"");
        if (board != null) {
          String boardName = board.getName();
          boardPort.setBoardName(boardName);
        }
      } else if (!parts[1].equals(""0000"")) {
        boardPort.getPrefs().put(""vid"", parts[1]);
        boardPort.getPrefs().put(""pid"", parts[2]);
        // ask Cloud API to match the board with known VID/PID pair
        boardCloudResolver.getBoardBy(parts[1], parts[2]);
      } else {
        boardPort.getPrefs().put(""vid"", ""0000"");
        boardPort.getPrefs().put(""pid"", ""0000"");
        boardPort.getPrefs().put(""iserial"", """");
      }
    }",iterator
i,"for (int i = 1; i < (parts.length-2); i++) {
          parts[0] += ""_"" + parts[i];
        }",loop_control
file,"for (File file : files) {
      if (!FILES_NOT_TO_COPY.contains(file.getName())) {
        if (file.isDirectory() && file.canExecute()) {
          scp.startFolder(file.getName());
          recursiveSCP(file, scp);
          scp.endFolder();
        } else if (file.isFile() && file.canRead()) {
          scp.sendFile(file);
        }
      }
    }",iterator
line,"for (String line : mergedSketch) {
        writer.write(line);
        writer.write(""\n"");
      }",iterator
elapsed,"{
    // Wait for a port to appear on the list
    int elapsed = 0;
    while (elapsed < timeout) {
      List<String> now = Serial.list();
      List<String> diff = new ArrayList<>(now);
      diff.removeAll(before);
      if (verbose) {
        System.out.print(""PORTS {"");
        for (String p : before)
          System.out.print(p + "", "");
        System.out.print(""} / {"");
        for (String p : now)
          System.out.print(p + "", "");
        System.out.print(""} => {"");
        for (String p : diff)
          System.out.print(p + "", "");
        System.out.println(""}"");
      }
      if (diff.size() > 0) {
        String newPort = diff.get(0);
        if (verbose)
          System.out.println(""Found upload port: "" + newPort);
        return newPort;
      }

      // Keep track of port that disappears
      before = now;
      Thread.sleep(250);
      elapsed += 250;

      // On Windows and OS X, it can take a few seconds for the port to disappear and
      // come back, so use a time out before assuming that the selected port is the
      // bootloader (not the sketch).
      if (elapsed >= 5000 && now.contains(uploadPort)) {
        if (verbose)
          System.out.println(""Uploading using selected port: "" + uploadPort);
        return uploadPort;
      }
    }

    // Something happened while detecting port
    throw new RunnerException(tr(""Couldn't find a Board on the selected port. Check that you have the correct port selected.  If it is correct, try pressing the board's reset button after initiating the upload.""), false);
  }",loop_control
p,"for (String p : before)
          System.out.print(p + "", "");",iterator
p,"for (String p : now)
          System.out.print(p + "", "");",iterator
p,"for (String p : diff)
          System.out.print(p + "", "");",iterator
entry,"{
        ArchiveEntry entry = in.getNextEntry();
        if (entry == null) {
          break;
        }

        // Extract entry info
        long size = entry.getSize();
        String name = entry.getName();
        boolean isDirectory = entry.isDirectory();
        boolean isLink = false;
        boolean isSymLink = false;
        String linkName = null;
        Integer mode = null;
        long modifiedTime = entry.getLastModifiedDate().getTime();

        {
          // Skip MacOSX metadata
          // http://superuser.com/questions/61185/why-do-i-get-files-like-foo-in-my-tarball-on-os-x
          int slash = name.lastIndexOf('/');
          if (slash == -1) {
            if (name.startsWith(""._"")) {
              continue;
            }
          } else {
            if (name.substring(slash + 1).startsWith(""._"")) {
              continue;
            }
          }
        }

        // Skip git metadata
        // http://www.unix.com/unix-for-dummies-questions-and-answers/124958-file-pax_global_header-means-what.html
        if (name.contains(""pax_global_header"")) {
          continue;
        }

        if (entry instanceof TarArchiveEntry) {
          TarArchiveEntry tarEntry = (TarArchiveEntry) entry;
          mode = tarEntry.getMode();
          isLink = tarEntry.isLink();
          isSymLink = tarEntry.isSymbolicLink();
          linkName = tarEntry.getLinkName();
        }

        // On the first archive entry, if requested, detect the common path
        // prefix to be stripped from filenames
        if (stripPath > 0 && pathPrefix.isEmpty()) {
          int slash = 0;
          while (stripPath > 0) {
            slash = name.indexOf(""/"", slash);
            if (slash == -1) {
              throw new IOException(""Invalid archive: it must contain a single root folder"");
            }
            slash++;
            stripPath--;
          }
          pathPrefix = name.substring(0, slash);
        }

        // Strip the common path prefix when requested
        if (!name.startsWith(pathPrefix)) {
          throw new IOException(""Invalid archive: it must contain a single root folder while file "" + name + "" is outside "" + pathPrefix);
        }
        name = name.substring(pathPrefix.length());
        if (name.isEmpty()) {
          continue;
        }
        File outputFile = new File(destFolder, name);

        File outputLinkedFile = null;
        if (isLink) {
          if (!linkName.startsWith(pathPrefix)) {
            throw new IOException(""Invalid archive: it must contain a single root folder while file "" + linkName + "" is outside "" + pathPrefix);
          }
          linkName = linkName.substring(pathPrefix.length());
          outputLinkedFile = new File(destFolder, linkName);
        }
        if (isSymLink) {
          // Symbolic links are referenced with relative paths
          outputLinkedFile = new File(linkName);
          if (outputLinkedFile.isAbsolute()) {
            System.err.println(I18n.format(tr(""Warning: file {0} links to an absolute path {1}""), outputFile, outputLinkedFile));
            System.err.println();
          }
        }

        // Safety check
        if (isDirectory) {
          if (outputFile.isFile() && !overwrite) {
            throw new IOException(""Can't create folder "" + outputFile + "", a file with the same name exists!"");
          }
        } else {
          // - isLink
          // - isSymLink
          // - anything else
          if (outputFile.exists() && !overwrite) {
            throw new IOException(""Can't extract file "" + outputFile + "", file already exists!"");
          }
        }

        // Extract the entry
        if (isDirectory) {
          if (!outputFile.exists() && !outputFile.mkdirs()) {
            throw new IOException(""Could not create folder: "" + outputFile);
          }
          foldersTimestamps.put(outputFile, modifiedTime);
        } else if (isLink) {
          hardLinks.put(outputFile, outputLinkedFile);
          hardLinksMode.put(outputFile, mode);
        } else if (isSymLink) {
          symLinks.put(outputFile, linkName);
          symLinksModifiedTimes.put(outputFile, modifiedTime);
        } else {
          // Create the containing folder if not exists
          if (!outputFile.getParentFile().isDirectory()) {
            outputFile.getParentFile().mkdirs();
          }
          copyStreamToFile(in, size, outputFile);
          outputFile.setLastModified(modifiedTime);
        }

        // Set file/folder permission
        if (mode != null && !isSymLink && outputFile.exists()) {
          platform.chmod(outputFile, mode);
        }
      }",break_loop_control
entry,"for (Map.Entry<File, File> entry : hardLinks.entrySet()) {
        if (entry.getKey().exists() && overwrite) {
          entry.getKey().delete();
        }
        platform.link(entry.getValue(), entry.getKey());
        Integer mode = hardLinksMode.get(entry.getKey());
        if (mode != null) {
          platform.chmod(entry.getKey(), mode);
        }
      }",break_loop_control
entry,"for (Map.Entry<File, String> entry : symLinks.entrySet()) {
        if (entry.getKey().exists() && overwrite) {
          entry.getKey().delete();
        }
        platform.symlink(entry.getValue(), entry.getKey());
        entry.getKey().setLastModified(symLinksModifiedTimes.get(entry.getKey()));
      }",break_loop_control
stripPath,"{
        ArchiveEntry entry = in.getNextEntry();
        if (entry == null) {
          break;
        }

        // Extract entry info
        long size = entry.getSize();
        String name = entry.getName();
        boolean isDirectory = entry.isDirectory();
        boolean isLink = false;
        boolean isSymLink = false;
        String linkName = null;
        Integer mode = null;
        long modifiedTime = entry.getLastModifiedDate().getTime();

        {
          // Skip MacOSX metadata
          // http://superuser.com/questions/61185/why-do-i-get-files-like-foo-in-my-tarball-on-os-x
          int slash = name.lastIndexOf('/');
          if (slash == -1) {
            if (name.startsWith(""._"")) {
              continue;
            }
          } else {
            if (name.substring(slash + 1).startsWith(""._"")) {
              continue;
            }
          }
        }

        // Skip git metadata
        // http://www.unix.com/unix-for-dummies-questions-and-answers/124958-file-pax_global_header-means-what.html
        if (name.contains(""pax_global_header"")) {
          continue;
        }

        if (entry instanceof TarArchiveEntry) {
          TarArchiveEntry tarEntry = (TarArchiveEntry) entry;
          mode = tarEntry.getMode();
          isLink = tarEntry.isLink();
          isSymLink = tarEntry.isSymbolicLink();
          linkName = tarEntry.getLinkName();
        }

        // On the first archive entry, if requested, detect the common path
        // prefix to be stripped from filenames
        if (stripPath > 0 && pathPrefix.isEmpty()) {
          int slash = 0;
          while (stripPath > 0) {
            slash = name.indexOf(""/"", slash);
            if (slash == -1) {
              throw new IOException(""Invalid archive: it must contain a single root folder"");
            }
            slash++;
            stripPath--;
          }
          pathPrefix = name.substring(0, slash);
        }

        // Strip the common path prefix when requested
        if (!name.startsWith(pathPrefix)) {
          throw new IOException(""Invalid archive: it must contain a single root folder while file "" + name + "" is outside "" + pathPrefix);
        }
        name = name.substring(pathPrefix.length());
        if (name.isEmpty()) {
          continue;
        }
        File outputFile = new File(destFolder, name);

        File outputLinkedFile = null;
        if (isLink) {
          if (!linkName.startsWith(pathPrefix)) {
            throw new IOException(""Invalid archive: it must contain a single root folder while file "" + linkName + "" is outside "" + pathPrefix);
          }
          linkName = linkName.substring(pathPrefix.length());
          outputLinkedFile = new File(destFolder, linkName);
        }
        if (isSymLink) {
          // Symbolic links are referenced with relative paths
          outputLinkedFile = new File(linkName);
          if (outputLinkedFile.isAbsolute()) {
            System.err.println(I18n.format(tr(""Warning: file {0} links to an absolute path {1}""), outputFile, outputLinkedFile));
            System.err.println();
          }
        }

        // Safety check
        if (isDirectory) {
          if (outputFile.isFile() && !overwrite) {
            throw new IOException(""Can't create folder "" + outputFile + "", a file with the same name exists!"");
          }
        } else {
          // - isLink
          // - isSymLink
          // - anything else
          if (outputFile.exists() && !overwrite) {
            throw new IOException(""Can't extract file "" + outputFile + "", file already exists!"");
          }
        }

        // Extract the entry
        if (isDirectory) {
          if (!outputFile.exists() && !outputFile.mkdirs()) {
            throw new IOException(""Could not create folder: "" + outputFile);
          }
          foldersTimestamps.put(outputFile, modifiedTime);
        } else if (isLink) {
          hardLinks.put(outputFile, outputLinkedFile);
          hardLinksMode.put(outputFile, mode);
        } else if (isSymLink) {
          symLinks.put(outputFile, linkName);
          symLinksModifiedTimes.put(outputFile, modifiedTime);
        } else {
          // Create the containing folder if not exists
          if (!outputFile.getParentFile().isDirectory()) {
            outputFile.getParentFile().mkdirs();
          }
          copyStreamToFile(in, size, outputFile);
          outputFile.setLastModified(modifiedTime);
        }

        // Set file/folder permission
        if (mode != null && !isSymLink && outputFile.exists()) {
          platform.chmod(outputFile, mode);
        }
      }",loop_control
entry,"{
        ArchiveEntry entry = in.getNextEntry();
        if (entry == null) {
          break;
        }

        // Extract entry info
        long size = entry.getSize();
        String name = entry.getName();
        boolean isDirectory = entry.isDirectory();
        boolean isLink = false;
        boolean isSymLink = false;
        String linkName = null;
        Integer mode = null;
        long modifiedTime = entry.getLastModifiedDate().getTime();

        {
          // Skip MacOSX metadata
          // http://superuser.com/questions/61185/why-do-i-get-files-like-foo-in-my-tarball-on-os-x
          int slash = name.lastIndexOf('/');
          if (slash == -1) {
            if (name.startsWith(""._"")) {
              continue;
            }
          } else {
            if (name.substring(slash + 1).startsWith(""._"")) {
              continue;
            }
          }
        }

        // Skip git metadata
        // http://www.unix.com/unix-for-dummies-questions-and-answers/124958-file-pax_global_header-means-what.html
        if (name.contains(""pax_global_header"")) {
          continue;
        }

        if (entry instanceof TarArchiveEntry) {
          TarArchiveEntry tarEntry = (TarArchiveEntry) entry;
          mode = tarEntry.getMode();
          isLink = tarEntry.isLink();
          isSymLink = tarEntry.isSymbolicLink();
          linkName = tarEntry.getLinkName();
        }

        // On the first archive entry, if requested, detect the common path
        // prefix to be stripped from filenames
        if (stripPath > 0 && pathPrefix.isEmpty()) {
          int slash = 0;
          while (stripPath > 0) {
            slash = name.indexOf(""/"", slash);
            if (slash == -1) {
              throw new IOException(""Invalid archive: it must contain a single root folder"");
            }
            slash++;
            stripPath--;
          }
          pathPrefix = name.substring(0, slash);
        }

        // Strip the common path prefix when requested
        if (!name.startsWith(pathPrefix)) {
          throw new IOException(""Invalid archive: it must contain a single root folder while file "" + name + "" is outside "" + pathPrefix);
        }
        name = name.substring(pathPrefix.length());
        if (name.isEmpty()) {
          continue;
        }
        File outputFile = new File(destFolder, name);

        File outputLinkedFile = null;
        if (isLink) {
          if (!linkName.startsWith(pathPrefix)) {
            throw new IOException(""Invalid archive: it must contain a single root folder while file "" + linkName + "" is outside "" + pathPrefix);
          }
          linkName = linkName.substring(pathPrefix.length());
          outputLinkedFile = new File(destFolder, linkName);
        }
        if (isSymLink) {
          // Symbolic links are referenced with relative paths
          outputLinkedFile = new File(linkName);
          if (outputLinkedFile.isAbsolute()) {
            System.err.println(I18n.format(tr(""Warning: file {0} links to an absolute path {1}""), outputFile, outputLinkedFile));
            System.err.println();
          }
        }

        // Safety check
        if (isDirectory) {
          if (outputFile.isFile() && !overwrite) {
            throw new IOException(""Can't create folder "" + outputFile + "", a file with the same name exists!"");
          }
        } else {
          // - isLink
          // - isSymLink
          // - anything else
          if (outputFile.exists() && !overwrite) {
            throw new IOException(""Can't extract file "" + outputFile + "", file already exists!"");
          }
        }

        // Extract the entry
        if (isDirectory) {
          if (!outputFile.exists() && !outputFile.mkdirs()) {
            throw new IOException(""Could not create folder: "" + outputFile);
          }
          foldersTimestamps.put(outputFile, modifiedTime);
        } else if (isLink) {
          hardLinks.put(outputFile, outputLinkedFile);
          hardLinksMode.put(outputFile, mode);
        } else if (isSymLink) {
          symLinks.put(outputFile, linkName);
          symLinksModifiedTimes.put(outputFile, modifiedTime);
        } else {
          // Create the containing folder if not exists
          if (!outputFile.getParentFile().isDirectory()) {
            outputFile.getParentFile().mkdirs();
          }
          copyStreamToFile(in, size, outputFile);
          outputFile.setLastModified(modifiedTime);
        }

        // Set file/folder permission
        if (mode != null && !isSymLink && outputFile.exists()) {
          platform.chmod(outputFile, mode);
        }
      }",iterator
entry,"for (Map.Entry<File, File> entry : hardLinks.entrySet()) {
        if (entry.getKey().exists() && overwrite) {
          entry.getKey().delete();
        }
        platform.link(entry.getValue(), entry.getKey());
        Integer mode = hardLinksMode.get(entry.getKey());
        if (mode != null) {
          platform.chmod(entry.getKey(), mode);
        }
      }",iterator
entry,"for (Map.Entry<File, String> entry : symLinks.entrySet()) {
        if (entry.getKey().exists() && overwrite) {
          entry.getKey().delete();
        }
        platform.symlink(entry.getValue(), entry.getKey());
        entry.getKey().setLastModified(symLinksModifiedTimes.get(entry.getKey()));
      }",iterator
folder,"for (File folder : foldersTimestamps.keySet()) {
      folder.setLastModified(foldersTimestamps.get(folder));
    }",iterator
b,"for (byte b : hash) {
        int c = b & 0xFF;
        if (c < 0x10)
          res += ""0"";
        res += Integer.toHexString(c);
      }",iterator
in,"{
    FileInputStream in = null;
    try {
      in = new FileInputStream(file);
      byte buff[] = new byte[10240];
      MessageDigest digest = MessageDigest.getInstance(algorithm);
      while (in.available() > 0) {
        int read = in.read(buff);
        digest.update(buff, 0, read);
      }
      byte[] hash = digest.digest();
      String res = """";
      for (byte b : hash) {
        int c = b & 0xFF;
        if (c < 0x10)
          res += ""0"";
        res += Integer.toHexString(c);
      }
      return algorithm + "":"" + res;
    } finally {
      IOUtils.closeQuietly(in);
    }
  }",maybe_loop_control
language,"for (Language language : languages) {
      if (language.getIsoCode().equals(isoCode)) {
        return true;
      }
    }",iterator
language,"for (Language language : languages) {
      if (language.getIsoCode().equals(isoCode)) {
        return true;
      }
    }",break_loop_control
i,"for (int i = 0; i < args.size(); i++) {
      try {
        args.set(i, URLDecoder.decode(args.get(i), ""UTF-8""));
      } catch (UnsupportedEncodingException e) {
        throw new RuntimeException(e);
      }
    }",loop_control
i,"for (int i = 0; i < endingSpacesOnly.length(); i++) {
        additionalArgs.add("""");
      }",loop_control
c,"for (HostDependentDownloadableContribution c : getSystems()) {
      if (c.isCompatible(platform))
        return c;
    }",iterator
c,"for (HostDependentDownloadableContribution c : getSystems()) {
      if (c.isCompatible(platform))
        return c;
    }",break_loop_control
sys,"for (HostDependentDownloadableContribution sys : getSystems()) {
      res += ""     sys"";
      if (platform != null) {
        res += sys.isCompatible(platform) ? ""*"" : "" "";
      }
      res += "" : "" + sys + ""\n"";
    }",iterator
pack,"for (ContributedPackage pack : getPackages()) {
      if (pack.getName().equals(packageName))
        return pack;
    }",iterator
pack,"for (ContributedPackage pack : getPackages()) {
      if (pack.getName().equals(packageName))
        return pack;
    }",break_loop_control
pack,"for (ContributedPackage pack : getPackages()) {
      pack.getPlatforms().stream()
        .filter(platform -> !categories.contains(platform.getCategory()))
        .forEach(platform -> categories.add(platform.getCategory()));
    }",iterator
pack,"for (ContributedPackage pack : getPackages()) {
      if (pack.getName().equals(packageName)) {
        return pack;
      }
    }",iterator
pack,"for (ContributedPackage pack : getPackages()) {
      if (pack.getName().equals(packageName)) {
        return pack;
      }
    }",break_loop_control
c,"for (String c : getCategories())
      res += ""'"" + c + ""' "";",iterator
pack,"for (ContributedPackage pack : getPackages())
      res += pack + ""\n"";",iterator
platform,"for (ContributedPlatform platform : getPlatforms()) {
      if (platform.getArchitecture().equals(architecture) && version.equals(platform.getParsedVersion()))
        return platform;
    }",iterator
platform,"for (ContributedPlatform platform : getPlatforms()) {
      if (platform.getArchitecture().equals(architecture) && version.equals(platform.getParsedVersion()))
        return platform;
    }",break_loop_control
tool,"for (ContributedTool tool : getTools()) {
      if (tool.getName().equals(name) && tool.getVersion().equals(version))
        return tool;
    }",iterator
tool,"for (ContributedTool tool : getTools()) {
      if (tool.getName().equals(name) && tool.getVersion().equals(version))
        return tool;
    }",break_loop_control
platform,"for (ContributedPlatform platform : getPlatforms()) {
      for (ContributedTool tool : platform.getResolvedTools()) {
        if (toolName.equals(tool.getName()) && version.equals(tool.getVersion())) {
          return tool;
        }
      }
    }",iterator
tool,"for (ContributedTool tool : platform.getResolvedTools()) {
        if (toolName.equals(tool.getName()) && version.equals(tool.getVersion())) {
          return tool;
        }
      }",iterator
tool,"for (ContributedTool tool : platform.getResolvedTools()) {
        if (toolName.equals(tool.getName()) && version.equals(tool.getVersion())) {
          return tool;
        }
      }",break_loop_control
plat,"for (ContributedPlatform plat : getPlatforms()) {
        res += ""\n        Plaform   : name         : "" + plat.getName();
        if (plat.isInstalled()) {
          res += ""\n                    "" + plat;
        }
        res += ""\n                    category     : "" + plat.getCategory();
        res += ""\n                    architecture : "" +
          plat.getArchitecture() + "" "" + plat.getParsedVersion() + ""\n"";
        if (plat.getToolsDependencies() != null)
          for (ContributedToolReference t : plat.getToolsDependencies()) {
            res += ""                    tool dep     : "" + t.getName() + "" "" +
              t.getVersion() + ""\n"";
          }
        if (plat.getBoards() != null)
          for (ContributedBoard board : plat.getBoards())
            res += ""                    board        : "" + board.getName() +
              ""\n"";
      }",iterator
t,"for (ContributedToolReference t : plat.getToolsDependencies()) {
            res += ""                    tool dep     : "" + t.getName() + "" "" +
              t.getVersion() + ""\n"";
          }",iterator
board,"for (ContributedBoard board : plat.getBoards())
            res += ""                    board        : "" + board.getName() +
              ""\n"";",iterator
tool,"for (ContributedTool tool : getTools())
        res += tool + ""\n"";",iterator
dep,"for (ContributedToolReference dep : getToolsDependencies()) {
      // Search the referenced tool
      ContributedTool tool = dep.resolve(packages);
      if (tool == null) {
        System.err.println(""Index error: could not find referenced tool "" + dep);
      } else {
        resolvedToolReferences.put(dep, tool);
      }
    }",iterator
tool,"for (ContributedTool tool : contributedPlatform.getResolvedTools()) {
      DownloadableContribution downloadable = tool.getDownloadableContribution(platform);
      if (downloadable == null) {
        throw new Exception(format(tr(""Tool {0} is not available for your operating system.""), tool.getName()));
      }
      // Download the tool if it's not installed or it's a built-in tool
      if (!tool.isInstalled() || tool.isBuiltIn()) {
        tools.add(tool);
      }
    }",iterator
tool,"for (ContributedTool tool : tools) {
        String msg = format(tr(""Downloading tools ({0}/{1}).""), i, tools.size());
        i++;
        downloader.download(tool.getDownloadableContribution(platform), progress, msg, progressListener, false);
        progress.stepDone();
      }",iterator
tool,"for (Map.Entry<ContributedToolReference, ContributedTool> entry : resolvedToolReferences) {
      progress.setStatus(format(tr(""Installing tools ({0}/{1})...""), i, resolvedToolReferences.size()));
      progressListener.onProgress(progress);
      i++;
      ContributedTool tool = entry.getValue();
      Path destFolder = Paths.get(BaseNoGui.indexer.getPackagesFolder().getAbsolutePath(), entry.getKey().getPackager(), ""tools"", tool.getName(), tool.getVersion());

      Files.createDirectories(destFolder);

      DownloadableContribution toolContrib = tool.getDownloadableContribution(platform);
      assert toolContrib.getDownloadedFile() != null;
      new ArchiveExtractor(platform).extract(toolContrib.getDownloadedFile(), destFolder.toFile(), 1);
      try {
        findAndExecutePostInstallScriptIfAny(destFolder.toFile(), contributedPlatform.getParentPackage().isTrusted(), PreferencesData.areInsecurePackagesAllowed());
      } catch (IOException e) {
        errors.add(tr(""Error running post install script""));
      }
      tool.setInstalled(true);
      tool.setInstalledFolder(destFolder.toFile());
      progress.stepDone();
    }",iterator
entry,"{
    List<String> errors = new LinkedList<>();
    if (contributedPlatform.isInstalled()) {
      throw new Exception(""Platform is already installed!"");
    }

    // Do not download already installed tools
    List<ContributedTool> tools = new ArrayList<>();
    for (ContributedTool tool : contributedPlatform.getResolvedTools()) {
      DownloadableContribution downloadable = tool.getDownloadableContribution(platform);
      if (downloadable == null) {
        throw new Exception(format(tr(""Tool {0} is not available for your operating system.""), tool.getName()));
      }
      // Download the tool if it's not installed or it's a built-in tool
      if (!tool.isInstalled() || tool.isBuiltIn()) {
        tools.add(tool);
      }
    }

    DownloadableContributionsDownloader downloader = new DownloadableContributionsDownloader(BaseNoGui.indexer.getStagingFolder());

    // Calculate progress increases
    MultiStepProgress progress = new MultiStepProgress((tools.size() + 1) * 2);

    // Download all
    try {
      // Download platform
      downloader.download(contributedPlatform, progress, tr(""Downloading boards definitions.""), progressListener, false);
      progress.stepDone();

      // Download tools
      int i = 1;
      for (ContributedTool tool : tools) {
        String msg = format(tr(""Downloading tools ({0}/{1}).""), i, tools.size());
        i++;
        downloader.download(tool.getDownloadableContribution(platform), progress, msg, progressListener, false);
        progress.stepDone();
      }
    } catch (InterruptedException e) {
      // Download interrupted... just exit
      return errors;
    }

    ContributedPackage pack = contributedPlatform.getParentPackage();
    File packageFolder = new File(BaseNoGui.indexer.getPackagesFolder(), pack.getName());

    // TODO: Extract to temporary folders and move to the final destination only
    // once everything is successfully unpacked. If the operation fails remove
    // all the temporary folders and abort installation.

    List<Map.Entry<ContributedToolReference, ContributedTool>> resolvedToolReferences = contributedPlatform
      .getResolvedToolReferences().entrySet().stream()
      .filter((entry) -> !entry.getValue().isInstalled()
        || entry.getValue().isBuiltIn())
      .collect(Collectors.toList());

    int i = 1;
    for (Map.Entry<ContributedToolReference, ContributedTool> entry : resolvedToolReferences) {
      progress.setStatus(format(tr(""Installing tools ({0}/{1})...""), i, resolvedToolReferences.size()));
      progressListener.onProgress(progress);
      i++;
      ContributedTool tool = entry.getValue();
      Path destFolder = Paths.get(BaseNoGui.indexer.getPackagesFolder().getAbsolutePath(), entry.getKey().getPackager(), ""tools"", tool.getName(), tool.getVersion());

      Files.createDirectories(destFolder);

      DownloadableContribution toolContrib = tool.getDownloadableContribution(platform);
      assert toolContrib.getDownloadedFile() != null;
      new ArchiveExtractor(platform).extract(toolContrib.getDownloadedFile(), destFolder.toFile(), 1);
      try {
        findAndExecutePostInstallScriptIfAny(destFolder.toFile(), contributedPlatform.getParentPackage().isTrusted(), PreferencesData.areInsecurePackagesAllowed());
      } catch (IOException e) {
        errors.add(tr(""Error running post install script""));
      }
      tool.setInstalled(true);
      tool.setInstalledFolder(destFolder.toFile());
      progress.stepDone();
    }

    // Unpack platform on the correct location
    progress.setStatus(tr(""Installing boards...""));
    progressListener.onProgress(progress);
    File platformFolder = new File(packageFolder, ""hardware"" + File.separator + contributedPlatform.getArchitecture());
    File destFolder = new File(platformFolder, contributedPlatform.getParsedVersion());
    Files.createDirectories(destFolder.toPath());
    new ArchiveExtractor(platform).extract(contributedPlatform.getDownloadedFile(), destFolder, 1);
    contributedPlatform.setInstalled(true);
    contributedPlatform.setInstalledFolder(destFolder);
    try {
      findAndExecutePostInstallScriptIfAny(destFolder, contributedPlatform.getParentPackage().isTrusted(), PreferencesData.areInsecurePackagesAllowed());
    } catch (IOException e) {
      e.printStackTrace();
      errors.add(tr(""Error running post install script""));
    }
    progress.stepDone();

    progress.setStatus(tr(""Installation completed!""));
    progressListener.onProgress(progress);

    return errors;
  }",iterator
tool,"for (ContributedTool tool : contributedPlatform.getResolvedTools()) {
      // Do not remove used tools
      if (BaseNoGui.indexer.isContributedToolUsed(contributedPlatform, tool))
        continue;

      // Do not remove built-in tools
      if (tool.isBuiltIn())
        continue;

      // Ok, delete the tool
      File destFolder = tool.getInstalledFolder();
      FileUtils.recursiveDelete(destFolder);
      tool.setInstalled(false);
      tool.setInstalledFolder(null);

      // We removed the version folder (.../tools/TOOL_NAME/VERSION)
      // now try to remove the containing TOOL_NAME folder
      // (and silently fail if another version of the tool is installed)
      try {
        Files.delete(destFolder.getParentFile().toPath());
      } catch (Exception e) {
        // ignore
      }
    }",iterator
packageIndexURLString,"for (String packageIndexURLString : packageIndexURLs) {
      try {
        // Extract the file name from the URL
        final URL packageIndexURL = new URL(packageIndexURLString);

        downloader.downloadIndexAndSignature(progress, packageIndexURL, progressListener, signatureVerifier);
      } catch (Exception e) {
        System.err.println(e.getMessage());
      }
    }",iterator
indexFile,"for (File indexFile : indexFiles) {
      try {
        mergeContributions(indexFile);
      } catch (JsonProcessingException e) {
        System.err.println(format(tr(""Skipping contributed index file {0}, parsing error occured:""), indexFile));
        System.err.println(e);
      }
    }",iterator
tool,"for (ContributedTool tool : pack.getTools()) {
        tool.setPackage(pack);
      }",iterator
pack,"{
    // Read bundled index...
    File bundledIndexFile = new File(builtInHardwareFolder, Constants.BUNDLED_INDEX_FILE_NAME);
    mergeContributions(bundledIndexFile);

    // ...and overlay the default index if present
    File defaultIndexFile = getIndexFile(Constants.DEFAULT_INDEX_FILE_NAME);
    if (defaultIndexFile.exists()) {
      // Check main index signature
      if (signatureVerifier.isSigned(defaultIndexFile)) {
        mergeContributions(defaultIndexFile);
      } else if (PreferencesData.areInsecurePackagesAllowed()) {
        System.err.println(format(tr(""Warning: forced trusting untrusted contributions"")));
        mergeContributions(defaultIndexFile);
      } else {
        BaseNoGui
            .showWarning(Constants.DEFAULT_INDEX_FILE_NAME,
                              tr(""A package index has an invalid signature and needs to be updated.\n""
                                 + ""Please open the Board Manager from the menu\n""
                                 + ""\n"" //
                                 + ""      Tools -> Board -> Board Manager\n""
                                 + ""\nto update it""),
                              null);
      }
    }

    // Set main and bundled indexes as trusted
    index.getPackages().forEach(pack -> pack.setTrusted(true));

    // Overlay 3rd party indexes
    List<File> indexFiles = get3rdPartyIndexFiles();
    for (File indexFile : indexFiles) {
      try {
        mergeContributions(indexFile);
      } catch (JsonProcessingException e) {
        System.err.println(format(tr(""Skipping contributed index file {0}, parsing error occured:""), indexFile));
        System.err.println(e);
      }
    }

    // Fill tools and toolsDependency cross references
    List<ContributedPackage> packages = index.getPackages();
    Collection<ContributedPackage> packagesWithTools = packages.stream()
      .filter(input -> input.getTools() != null && !input.getTools().isEmpty())
      .collect(Collectors.toList());

    for (ContributedPackage pack : packages) {
      // Fill references to package in tools
      for (ContributedTool tool : pack.getTools()) {
        tool.setPackage(pack);
      }

      for (ContributedPlatform plat : pack.getPlatforms()) {
        // Set a reference to parent packages
        plat.setParentPackage(pack);

        // Resolve tools dependencies (works also as a check for file integrity)
        plat.resolveToolsDependencies(packagesWithTools);
      }
    }

    index.fillCategories();
  }",iterator
plat,"for (ContributedPlatform plat : pack.getPlatforms()) {
        // Set a reference to parent packages
        plat.setParentPackage(pack);

        // Resolve tools dependencies (works also as a check for file integrity)
        plat.resolveToolsDependencies(packagesWithTools);
      }",iterator
urlString,"for (String urlString : PreferencesData.getCollection(Constants.PREF_BOARDS_MANAGER_ADDITIONAL_URLS)) {
      URL url;
      try {
        url = new URL(urlString);
        String filename = FilenameUtils.getName(url.getPath());
        indexFiles.add(getIndexFile(filename));
      } catch (MalformedURLException e) {
        System.err.println(format(tr(""Malformed Additional Board Manager URL '{0}': {1}""), urlString, e.getMessage()));
      }
    }",iterator
contributedPackage,"for (ContributedPackage contributedPackage : contributionsIndex.getPackages()) {
      contributedPackage.setTrusted(signed || trustall);
      if (!contributedPackage.isTrusted()) {
        for (ContributedPlatform contributedPlatform : contributedPackage.getPlatforms()) {
          contributedPlatform.setCategory(""Contributed"");
        }
      }

      ContributedPackage targetPackage = index.getPackage(contributedPackage.getName());

      if (targetPackage == null) {
        index.getPackages().add(contributedPackage);
      } else {
        if (contributedPackage.isTrusted() || !isPackageNameProtected(contributedPackage)) {
          if (isPackageNameProtected(contributedPackage) && trustall) {
            System.err.println(format(tr(""Warning: forced trusting untrusted contributions"")));
          }
          List<ContributedPlatform> platforms = contributedPackage.getPlatforms();
          if (platforms == null) {
            platforms = new LinkedList<>();
          }
          for (ContributedPlatform contributedPlatform : platforms) {
            ContributedPlatform plat = targetPackage.findPlatform(contributedPlatform.getArchitecture(), contributedPlatform.getVersion());
            if (plat != null) {
              targetPackage.getPlatforms().remove(plat);
            }
            targetPackage.getPlatforms().add(contributedPlatform);
          }
          List<ContributedTool> tools = contributedPackage.getTools();
          if (tools == null) {
            tools = new LinkedList<>();
          }
          for (ContributedTool contributedTool : tools) {
            ContributedTool tool = targetPackage.findTool(contributedTool.getName(), contributedTool.getVersion());
            if (tool != null) {
              targetPackage.getTools().remove(tool);
            }
            targetPackage.getTools().add(contributedTool);
          }
        }
      }
    }",iterator
contributedPlatform,"for (ContributedPlatform contributedPlatform : contributedPackage.getPlatforms()) {
          contributedPlatform.setCategory(""Contributed"");
        }",iterator
contributedPlatform,"for (ContributedPlatform contributedPlatform : platforms) {
            ContributedPlatform plat = targetPackage.findPlatform(contributedPlatform.getArchitecture(), contributedPlatform.getVersion());
            if (plat != null) {
              targetPackage.getPlatforms().remove(plat);
            }
            targetPackage.getPlatforms().add(contributedPlatform);
          }",iterator
contributedTool,"for (ContributedTool contributedTool : tools) {
            ContributedTool tool = targetPackage.findTool(contributedTool.getName(), contributedTool.getVersion());
            if (tool != null) {
              targetPackage.getTools().remove(tool);
            }
            targetPackage.getTools().add(contributedTool);
          }",iterator
folder,"for (File folder : builtInHardwareFolder.listFiles(ONLY_DIRS)) {
      ContributedPackage pack = index.findPackage(folder.getName());
      if (pack == null)
        continue;
      syncBuiltInPackageWithFilesystem(pack, folder);

      File toolsFolder = new File(builtInHardwareFolder, ""tools"");
      if (!toolsFolder.isDirectory())
        continue;

      for (File toolFolder : toolsFolder.listFiles(ONLY_DIRS)) {

        // builtin_tools_versions.txt contains tools versions in the format:
        // ""PACKAGER.TOOL_NAME=TOOL_VERSION""
        // for example:
        // ""arduino.avrdude=6.0.1-arduino5""

        File versionsFile = new File(toolFolder, ""builtin_tools_versions.txt"");
        if (!versionsFile.isFile())
          continue;
        PreferencesMap toolsVersion = new PreferencesMap(versionsFile).subTree(pack.getName());
        for (String name : toolsVersion.keySet()) {
          String version = toolsVersion.get(name);
          ContributedTool tool = syncToolWithFilesystem(pack, toolFolder, name, version);
          if (tool != null)
            tool.setBuiltIn(true);
        }
      }
    }",iterator
toolFolder,"for (File toolFolder : toolsFolder.listFiles(ONLY_DIRS)) {

        // builtin_tools_versions.txt contains tools versions in the format:
        // ""PACKAGER.TOOL_NAME=TOOL_VERSION""
        // for example:
        // ""arduino.avrdude=6.0.1-arduino5""

        File versionsFile = new File(toolFolder, ""builtin_tools_versions.txt"");
        if (!versionsFile.isFile())
          continue;
        PreferencesMap toolsVersion = new PreferencesMap(versionsFile).subTree(pack.getName());
        for (String name : toolsVersion.keySet()) {
          String version = toolsVersion.get(name);
          ContributedTool tool = syncToolWithFilesystem(pack, toolFolder, name, version);
          if (tool != null)
            tool.setBuiltIn(true);
        }
      }",iterator
name,"for (String name : toolsVersion.keySet()) {
          String version = toolsVersion.get(name);
          ContributedTool tool = syncToolWithFilesystem(pack, toolFolder, name, version);
          if (tool != null)
            tool.setBuiltIn(true);
        }",iterator
platformFolder,"for (File platformFolder : hardwareFolder.listFiles(ONLY_DIRS)) {
      File platformTxt = new File(platformFolder, ""platform.txt"");
      String version = new PreferencesMap(platformTxt).get(""version"");
      ContributedPlatform p = syncHardwareWithFilesystem(pack, platformFolder, platformFolder.getName(), version);
      if (p != null) {
        p.setBuiltIn(true);
      }
    }",iterator
folder,"for (File folder : packagesFolder.listFiles(ONLY_DIRS)) {
      ContributedPackage pack = index.findPackage(folder.getName());
      if (pack != null) {
        syncPackageWithFilesystem(pack, folder);
      }
    }",iterator
platformFolder,"for (File platformFolder : hardwareFolder.listFiles(ONLY_DIRS)) {
        for (File versionFolder : platformFolder.listFiles(ONLY_DIRS)) {
          syncHardwareWithFilesystem(pack, versionFolder, platformFolder.getName(), versionFolder.getName());
        }
      }",iterator
versionFolder,"for (File versionFolder : platformFolder.listFiles(ONLY_DIRS)) {
          syncHardwareWithFilesystem(pack, versionFolder, platformFolder.getName(), versionFolder.getName());
        }",iterator
versionFolder,"for (File versionFolder : toolFolder.listFiles(ONLY_DIRS)) {
          syncToolWithFilesystem(pack, versionFolder, toolFolder.getName(), versionFolder.getName());
        }",iterator
toolFolder,"for (File toolFolder : toolsFolder.listFiles(ONLY_DIRS)) {
        for (File versionFolder : toolFolder.listFiles(ONLY_DIRS)) {
          syncToolWithFilesystem(pack, versionFolder, toolFolder.getName(), versionFolder.getName());
        }
      }",iterator
aPackage,"for (ContributedPackage aPackage : index.getPackages()) {
      ContributedTargetPackage targetPackage = new ContributedTargetPackage(aPackage.getName());

      List<ContributedPlatform> platforms = aPackage.getPlatforms().stream() //
          .filter(p -> p.isInstalled()) //
          .collect(Collectors.toList());
      Collections.sort(platforms, ContributedPlatform.BUILTIN_AS_LAST);

      for (ContributedPlatform p : platforms) {
        String arch = p.getArchitecture();
        File folder = p.getInstalledFolder();

        try {
          TargetPlatform targetPlatform = new ContributedTargetPlatform(arch, folder, targetPackage);
          if (!targetPackage.hasPlatform(targetPlatform)) {
            targetPackage.addPlatform(targetPlatform);
          }
        } catch (TargetPlatformException e) {
          System.err.println(e.getMessage());
        }
      }

      if (targetPackage.hasPlatforms()) {
        packages.add(targetPackage);
      }
    }",iterator
p,"for (ContributedPackage aPackage : index.getPackages()) {
      ContributedTargetPackage targetPackage = new ContributedTargetPackage(aPackage.getName());

      List<ContributedPlatform> platforms = aPackage.getPlatforms().stream() //
          .filter(p -> p.isInstalled()) //
          .collect(Collectors.toList());
      Collections.sort(platforms, ContributedPlatform.BUILTIN_AS_LAST);

      for (ContributedPlatform p : platforms) {
        String arch = p.getArchitecture();
        File folder = p.getInstalledFolder();

        try {
          TargetPlatform targetPlatform = new ContributedTargetPlatform(arch, folder, targetPackage);
          if (!targetPackage.hasPlatform(targetPlatform)) {
            targetPackage.addPlatform(targetPlatform);
          }
        } catch (TargetPlatformException e) {
          System.err.println(e.getMessage());
        }
      }

      if (targetPackage.hasPlatforms()) {
        packages.add(targetPackage);
      }
    }",iterator
pack,"for (ContributedPackage pack : index.getPackages()) {
      for (ContributedPlatform p : pack.getPlatforms()) {
        if (platformToIgnore.equals(p)) {
          continue;
        }
        if (!p.isInstalled() || p.isBuiltIn()) {
          continue;
        }
        for (ContributedTool requiredTool : p.getResolvedTools()) {
          if (requiredTool.equals(tool))
            return true;
        }
      }
    }",iterator
p,"for (ContributedPlatform p : pack.getPlatforms()) {
        if (platformToIgnore.equals(p)) {
          continue;
        }
        if (!p.isInstalled() || p.isBuiltIn()) {
          continue;
        }
        for (ContributedTool requiredTool : p.getResolvedTools()) {
          if (requiredTool.equals(tool))
            return true;
        }
      }",iterator
requiredTool,"for (ContributedTool requiredTool : p.getResolvedTools()) {
          if (requiredTool.equals(tool))
            return true;
        }",iterator
requiredTool,"for (ContributedTool requiredTool : p.getResolvedTools()) {
          if (requiredTool.equals(tool))
            return true;
        }",break_loop_control
pack,"for (ContributedPackage pack : index.getPackages()) {
      Collection<ContributedPlatform> platforms = pack.getPlatforms().stream() //
          .filter(p -> p.isInstalled()) //
          .collect(Collectors.toList());
      Map<String, List<ContributedPlatform>> platformsByName = platforms.stream().collect(Collectors.groupingBy(ContributedPlatform::getName));

      platformsByName.forEach((platformName, platformsWithName) -> {
        if (platformsWithName.size() > 1) {
          platformsWithName = platformsWithName.stream() //
              .filter(p -> !p.isBuiltIn()) //
              .collect(Collectors.toList());
        }
        for (ContributedPlatform p : platformsWithName) {
          tools.addAll(p.getResolvedTools());
        }
      });
    }",iterator
p,"for (ContributedPackage pack : index.getPackages()) {
      Collection<ContributedPlatform> platforms = pack.getPlatforms().stream() //
          .filter(p -> p.isInstalled()) //
          .collect(Collectors.toList());
      Map<String, List<ContributedPlatform>> platformsByName = platforms.stream().collect(Collectors.groupingBy(ContributedPlatform::getName));

      platformsByName.forEach((platformName, platformsWithName) -> {
        if (platformsWithName.size() > 1) {
          platformsWithName = platformsWithName.stream() //
              .filter(p -> !p.isBuiltIn()) //
              .collect(Collectors.toList());
        }
        for (ContributedPlatform p : platformsWithName) {
          tools.addAll(p.getResolvedTools());
        }
      });
    }",iterator
plat,"for (ContributedPlatform plat : getInstalledPlatforms()) {
      if (plat.getInstalledFolder().equals(targetPlatform.getFolder()))
        return plat;
    }",iterator
plat,"for (ContributedPlatform plat : getInstalledPlatforms()) {
      if (plat.getInstalledFolder().equals(targetPlatform.getFolder()))
        return plat;
    }",break_loop_control
pack,"for (ContributedPackage pack : packages) {
      assert pack.getTools() != null;
      for (ContributedTool tool : pack.getTools())
        if (tool.getName().equals(getName()) &&
            tool.getVersion().equals(getVersion()) &&
            pack.getName().equals(getPackager()))
          return tool;
    }",iterator
tool,"for (ContributedTool tool : pack.getTools())
        if (tool.getName().equals(getName()) &&
            tool.getVersion().equals(getVersion()) &&
            pack.getName().equals(getPackager()))
          return tool;",iterator
tool,"for (ContributedTool tool : pack.getTools())
        if (tool.getName().equals(getName()) &&
            tool.getVersion().equals(getVersion()) &&
            pack.getName().equals(getPackager()))
          return tool;",break_loop_control
r,"for (ContributedLibrary r : releases) {
      if (r == lib) {
        selected = r;
        return;
      }
    }",iterator
r,"for (ContributedLibrary r : releases) {
      if (r == lib) {
        selected = r;
        return;
      }
    }",break_loop_control
lib,"for (ContributedLibrary lib : index.getLibraries()) {
      lib.unsetInstalledUserLibrary();
    }",iterator
folderDesc,"for (UserLibraryFolder folderDesc : librariesFolders) {
      scanInstalledLibraries(folderDesc);
    }",iterator
list,"{
    File list[] = folderDesc.folder.listFiles(OnlyDirs.ONLY_DIRS);
    // if a bad folder or something like that, this might come back null
    if (list == null)
      return;

    for (File subfolder : list) {
      String subfolderName = subfolder.getName();
      if (!BaseNoGui.isSanitaryName(subfolderName)) {

        // Detect whether the current folder name has already had a notification.
        if (!badLibNotified.contains(subfolderName)) {

          badLibNotified.add(subfolderName);

          String mess = I18n.format(tr(""The library \""{0}\"" cannot be used.\n""
              + ""Library folder names must start with a letter or number, followed by letters,\n""
              + ""numbers, dashes, dots and underscores. Maximum length is 63 characters.""),
              subfolderName);
          BaseNoGui.showMessage(tr(""Ignoring library with bad name""), mess);
        }
        continue;
      }

      try {
        scanLibrary(new UserLibraryFolder(subfolder, folderDesc.location));
      } catch (IOException e) {
        System.out.println(I18n.format(tr(""Invalid library found in {0}: {1}""), subfolder, e.getMessage()));
      }
    }
  }",iterator
lib,"for (ContributedLibrary lib : find(name)) {
      if (version.equals(lib.getParsedVersion())) {
        return lib;
      }
    }",iterator
library,"for (ContributedLibrary library : getLibraries()) {
      sb.append(library.toString());
    }",iterator
lib,"for (ContributedLibrary lib : getLibraries()) {
      if (lib.getCategory() != null && !categories.contains(lib.getCategory())) {
        categories.add(lib.getCategory());
      }
    }",iterator
lib,"for (ContributedLibrary lib : getLibraries()) {
      if (lib.getTypes() != null) {
        typesAccumulator.addAll(lib.getTypes());
      }
    }",iterator
dep,"for (ContributedLibraryDependency dep : requirements) {

      // If the current solution already contains this dependency, skip over
      boolean alreadyInSolution = solution.stream()
          .anyMatch(l -> l.getName().equals(dep.getName()));
      if (alreadyInSolution)
        continue;

      // Generate possible matching dependencies
      List<ContributedLibrary> possibleDeps = findMatchingDependencies(dep);

      // If there are no dependencies available add as ""missing"" lib
      if (possibleDeps.isEmpty()) {
        solution.add(new UnavailableContributedLibrary(dep));
        continue;
      }

      // Pick the installed version if available
      ContributedLibrary selected;
      Optional<ContributedLibrary> installed = possibleDeps.stream()
          .filter(l -> l.getInstalledLibrary().isPresent()).findAny();
      if (installed.isPresent()) {
        selected = installed.get();
      } else {
        // otherwise pick the latest version
        selected = possibleDeps.stream().reduce(VersionComparator::max).get();
      }

      // Add dependency to the solution and process recursively
      solution.add(selected);
      if (!resolveDependeciesOf(solution, selected)) {
        return false;
      }
    }",iterator
selected,"for (ContributedLibraryDependency dep : requirements) {

      // If the current solution already contains this dependency, skip over
      boolean alreadyInSolution = solution.stream()
          .anyMatch(l -> l.getName().equals(dep.getName()));
      if (alreadyInSolution)
        continue;

      // Generate possible matching dependencies
      List<ContributedLibrary> possibleDeps = findMatchingDependencies(dep);

      // If there are no dependencies available add as ""missing"" lib
      if (possibleDeps.isEmpty()) {
        solution.add(new UnavailableContributedLibrary(dep));
        continue;
      }

      // Pick the installed version if available
      ContributedLibrary selected;
      Optional<ContributedLibrary> installed = possibleDeps.stream()
          .filter(l -> l.getInstalledLibrary().isPresent()).findAny();
      if (installed.isPresent()) {
        selected = installed.get();
      } else {
        // otherwise pick the latest version
        selected = possibleDeps.stream().reduce(VersionComparator::max).get();
      }

      // Add dependency to the solution and process recursively
      solution.add(selected);
      if (!resolveDependeciesOf(solution, selected)) {
        return false;
      }
    }",break_loop_control
lib,"for (ContributedLibrary lib : libs) {
      // Do install library (3 steps)
      performInstall(lib, progressListener, progress);
    }",iterator
reqArch,"for (String reqArch : reqArchs)
      if (supportsArchitecture(reqArch))
        return true;",iterator
reqArch,"for (String reqArch : reqArchs)
      if (supportsArchitecture(reqArch))
        return true;",break_loop_control
a,"for (String a : getArchitectures()) {
        res += a + "","";
      }",iterator
r,"for (ContributedLibraryDependency r : getDependencies()) {
        res += ""                       "" + r;
      }",iterator
counter,"{
        int counter = 0;
        List<Byte> newArr = new ArrayList<>();
        while (counter < targetSize && (array.length - 1 - counter >= 0)) {
            newArr.add(0, array[array.length - 1 - counter]);
            counter++;
        }

        int size = newArr.size();
        for (int i = 0; i < (targetSize - size); i++) {

            newArr.add(0, (byte) 0);
        }

        byte[] ret = new byte[newArr.size()];
        for (int i = 0; i < newArr.size(); i++) {
            ret[i] = newArr.get(i);
        }
        return ret;
    }",loop_control
i,"for (int i = 0; i < (targetSize - size); i++) {

            newArr.add(0, (byte) 0);
        }",loop_control
i,"for (int i = 0; i < newArr.size(); i++) {
            ret[i] = newArr.get(i);
        }",loop_control
file,"for (File file : FileUtils.listFiles(folder, false, EXTENSIONS)) {
      if (BaseNoGui.isSanitaryName(FileUtils.splitFilename(file).basename)) {
        result.add(new SketchFile(this, file));
      } else if (showWarnings) {
        System.err.println(I18n.format(tr(""File name {0} is invalid: ignored""), file.getName()));
      }
    }",iterator
file,"for (SketchFile file : getFiles()) {
      if (file.isModified())
        file.save();
    }",iterator
file,"for (SketchFile file : files) {
      if (file.isModified())
        return true;
    }",iterator
file,"for (SketchFile file : files) {
      if (file.getFile().equals(filename))
        return i;
      i++;
    }",iterator
file,"for (SketchFile file : files) {
      if (file.getFile().equals(filename))
        return i;
      i++;
    }",break_loop_control
file,"for (SketchFile file : files)
      file.renamedTo(new File(newFolder, file.getFileName()));",iterator
file,"for (SketchFile file : files) {
      if (file.isPrimary())
        file.saveAs(newPrimary);
      else
        file.saveAs(new File(newFolder, file.getFileName()));
    }",iterator
c,"for (char c : what.toCharArray()) {
      if (c == '\n') count++;
    }",iterator
menuId,"for (String menuId : board.getMenuIds()) {
      if (!board.hasMenu(menuId))
        continue;

      // Get ""custom_[MENU_ID]"" preference (for example ""custom_cpu"")
      String entry = PreferencesData.get(""custom_"" + menuId);
      if (entry != null && entry.startsWith(boardId)) {

        String selectionId = entry.substring(boardId.length() + 1);
        prefs.putAll(board.getMenuPreferences(menuId, selectionId));

        // Update the name with the extended configuration
        extendedName += "", "" + board.getMenuLabel(menuId, selectionId);
      }
    }",iterator
tool,"for (ContributedTool tool : requiredTools) {
      File folder = tool.getInstalledFolder();
      if (folder == null) {
        continue;
      }
      String toolPath = folder.getAbsolutePath();
      prefs.put(prefix + tool.getName() + "".path"", toolPath);
      prefs.put(prefix + tool.getName() + ""-"" + tool.getVersion() + "".path"", toolPath);
      PreferencesData.set(prefix + tool.getName() + "".path"", toolPath);
      PreferencesData.set(prefix + tool.getName() + ""-"" + tool.getVersion() + "".path"", toolPath);
    }",iterator
entry,"for (Map.Entry<String, String> entry : prefs.entrySet()) {
        System.out.println(entry.getKey() + ""="" + entry.getValue());
      }",iterator
target,"for (String target : list) {
      // Skip reserved 'tools' folder.
      if (target.equals(""tools"")) {
        continue;
      }
      File subfolder = new File(folder, target);

      TargetPackage targetPackage;
      if (packages.containsKey(target)) {
        targetPackage = packages.get(target);
      } else {
        targetPackage = new LegacyTargetPackage(target);
        packages.put(target, targetPackage);
      }
      try {
        loadTargetPackage(targetPackage, subfolder);
      } catch (TargetPlatformException e) {
        System.out.println(""WARNING: Error loading hardware folder "" + new File(folder, target));
        System.out.println(""  "" + e.getMessage());
      }
    }",iterator
subFolder,"for (File subFolder : folders) {
      if (!subFolder.exists() || !subFolder.canRead()) {
        continue;
      }
      String arch = subFolder.getName();
      try {
        TargetPlatform p = new LegacyTargetPlatform(arch, subFolder, targetPackage);
        targetPackage.getPlatforms().put(arch, p);
      } catch (TargetPlatformException e) {
        System.err.println(e.getMessage());
      }
    }",iterator
pack,"for (TargetPackage pack : idx.createTargetPackages()) {
      packages.put(pack.getId(), pack);
    }",iterator
tool,"for (ContributedTool tool : installedTools) {
      File installedFolder = tool.getInstalledFolder();
      String toolPath;
      if (installedFolder != null) {
        toolPath = installedFolder.getAbsolutePath();
      } else {
        toolPath = Constants.PREF_REMOVE_PLACEHOLDER;
      }
      String toolName = tool.getName();
      String toolVersion = tool.getVersion();
      PreferencesData.set(prefix + toolName + ""-"" + toolVersion + "".path"", toolPath);
      PreferencesData.set(prefix + tool.getPackager() + ""-"" + toolName + ""-"" + toolVersion + "".path"", toolPath);
      // In the generic tool property put the path of the latest version if more are available
      try {
        if (!latestVersions.containsKey(toolName) || VersionComparator.greaterThan(toolVersion, latestVersions.get(toolName))) {
          latestVersions.put(toolName, toolVersion);
          PreferencesData.set(prefix + toolName + "".path"", toolPath);
        }
      } catch (Exception e) {
        // Ignore invalid versions
      }
    }",iterator
lib,"for (UserLibrary lib : librariesIndexer.getInstalledLibraries()) {
      try {
        String headers[] = headerListFromIncludePath(lib.getSrcFolder());
        for (String header : headers) {
          LibraryList list = importToLibraryTable.get(header);
          if (list == null) {
            // This is the first library found with this header
            list = new LibraryList();
            list.addFirst(lib);
            importToLibraryTable.put(header, list);
          } else {
            UserLibrary old = list.peekFirst();
            boolean useThisLib = true;
            // This is the case where 2 libraries have a .h header
            // with the same name.  We must decide which library to
            // use when a sketch has #include ""name.h""
            //
            // When all other factors are equal, ""libName"" is
            // used in preference to ""oldName"", because getLibraries()
            // gives the library list in order from less specific to
            // more specific locations.
            //
            // But often one library is more clearly the user's
            // intention to use.  Many cases are tested, always first
            // for ""libName"", then for ""oldName"".
            //
            String name = header.substring(0, header.length() - 2); // name without "".h""
            String oldName = old.getInstalledFolder().getName();  // just the library folder name
            String libName = lib.getInstalledFolder().getName();  // just the library folder name
            //System.out.println(""name conflict: "" + name);
            //System.out.println("" old = "" + oldName + "" -> "" + old.getInstalledFolder().getPath());
            //System.out.println("" new = "" + libName + "" -> "" + lib.getInstalledFolder().getPath());
            String name_lc = name.toLowerCase();
            String oldName_lc = oldName.toLowerCase();
            String libName_lc = libName.toLowerCase();
            // always favor a perfect name match
            if (libName.equals(name)) {
            } else if (oldName.equals(name)) {
                useThisLib = false;
            // check for ""-master"" appended (zip file from github)
            } else if (libName.equals(name+""-master"")) {
            } else if (oldName.equals(name+""-master"")) {
                useThisLib = false;
            // next, favor a match with other stuff appended
            } else if (libName.startsWith(name)) {
            } else if (oldName.startsWith(name)) {
                useThisLib = false;
            // otherwise, favor a match with stuff prepended
            } else if (libName.endsWith(name)) {
            } else if (oldName.endsWith(name)) {
                useThisLib = false;
            // as a last resort, match if stuff prepended and appended
            } else if (libName.contains(name)) {
            } else if (oldName.contains(name)) {
                useThisLib = false;
            // repeat all the above tests, with case insensitive matching
            } else if (libName_lc.equals(name_lc)) {
            } else if (oldName_lc.equals(name_lc)) {
                useThisLib = false;
            } else if (libName_lc.equals(name_lc+""-master"")) {
            } else if (oldName_lc.equals(name_lc+""-master"")) {
                useThisLib = false;
            } else if (libName_lc.startsWith(name_lc)) {
            } else if (oldName_lc.startsWith(name_lc)) {
                useThisLib = false;
            } else if (libName_lc.endsWith(name_lc)) {
            } else if (oldName_lc.endsWith(name_lc)) {
                useThisLib = false;
            } else if (libName_lc.contains(name_lc)) {
            } else if (oldName_lc.contains(name_lc)) {
                useThisLib = false;
            } else {
              // none of these tests matched, so just default to ""libName"".
            }
            if (useThisLib) {
              list.addFirst(lib);
            } else {
              list.addLast(lib);
            }
          }
        }
      } catch (IOException e) {
        showWarning(tr(""Error""), I18n
            .format(""Unable to list header files in {0}"", lib.getSrcFolder()), e);
      }
    }",iterator
header,"for (String header : headers) {
          LibraryList list = importToLibraryTable.get(header);
          if (list == null) {
            // This is the first library found with this header
            list = new LibraryList();
            list.addFirst(lib);
            importToLibraryTable.put(header, list);
          } else {
            UserLibrary old = list.peekFirst();
            boolean useThisLib = true;
            // This is the case where 2 libraries have a .h header
            // with the same name.  We must decide which library to
            // use when a sketch has #include ""name.h""
            //
            // When all other factors are equal, ""libName"" is
            // used in preference to ""oldName"", because getLibraries()
            // gives the library list in order from less specific to
            // more specific locations.
            //
            // But often one library is more clearly the user's
            // intention to use.  Many cases are tested, always first
            // for ""libName"", then for ""oldName"".
            //
            String name = header.substring(0, header.length() - 2); // name without "".h""
            String oldName = old.getInstalledFolder().getName();  // just the library folder name
            String libName = lib.getInstalledFolder().getName();  // just the library folder name
            //System.out.println(""name conflict: "" + name);
            //System.out.println("" old = "" + oldName + "" -> "" + old.getInstalledFolder().getPath());
            //System.out.println("" new = "" + libName + "" -> "" + lib.getInstalledFolder().getPath());
            String name_lc = name.toLowerCase();
            String oldName_lc = oldName.toLowerCase();
            String libName_lc = libName.toLowerCase();
            // always favor a perfect name match
            if (libName.equals(name)) {
            } else if (oldName.equals(name)) {
                useThisLib = false;
            // check for ""-master"" appended (zip file from github)
            } else if (libName.equals(name+""-master"")) {
            } else if (oldName.equals(name+""-master"")) {
                useThisLib = false;
            // next, favor a match with other stuff appended
            } else if (libName.startsWith(name)) {
            } else if (oldName.startsWith(name)) {
                useThisLib = false;
            // otherwise, favor a match with stuff prepended
            } else if (libName.endsWith(name)) {
            } else if (oldName.endsWith(name)) {
                useThisLib = false;
            // as a last resort, match if stuff prepended and appended
            } else if (libName.contains(name)) {
            } else if (oldName.contains(name)) {
                useThisLib = false;
            // repeat all the above tests, with case insensitive matching
            } else if (libName_lc.equals(name_lc)) {
            } else if (oldName_lc.equals(name_lc)) {
                useThisLib = false;
            } else if (libName_lc.equals(name_lc+""-master"")) {
            } else if (oldName_lc.equals(name_lc+""-master"")) {
                useThisLib = false;
            } else if (libName_lc.startsWith(name_lc)) {
            } else if (oldName_lc.startsWith(name_lc)) {
                useThisLib = false;
            } else if (libName_lc.endsWith(name_lc)) {
            } else if (oldName_lc.endsWith(name_lc)) {
                useThisLib = false;
            } else if (libName_lc.contains(name_lc)) {
            } else if (oldName_lc.contains(name_lc)) {
                useThisLib = false;
            } else {
              // none of these tests matched, so just default to ""libName"".
            }
            if (useThisLib) {
              list.addFirst(lib);
            } else {
              list.addLast(lib);
            }
          }
        }",iterator
i,"for (int i = 0; i < args.length - 1; i++) {
      if (args[i].equals(""--preferences-file"")) {
        ++i;
        preferencesFile = args[i];
        continue;
      }
    }",loop_control
i,"for (int i = 0; i < c.length; i++) {
      if (((c[i] >= '0') && (c[i] <= '9')) ||
          ((c[i] >= 'a') && (c[i] <= 'z')) ||
          ((c[i] >= 'A') && (c[i] <= 'Z')) ||
          ((i > 0) && (c[i] == '-')) ||
          ((i > 0) && (c[i] == '.'))) {
        buffer.append(c[i]);
      } else {
        buffer.append('_');
      }
    }",loop_control
item,"for (String item : strArray) {
      item.trim();
    }",iterator
port,"for (String port : listSerialsNative()) {
      list.add(port.split(""_"")[0]);
    }",iterator
targetPackage,"for (TargetPackage targetPackage : packages.values()) {
      for (TargetPlatform targetPlatform : targetPackage.getPlatforms().values()) {
        for (TargetBoard board : targetPlatform.getBoards().values()) {
          List<String> vids = new LinkedList<>(board.getPreferences().subTree(""vid"", 1).values());
          if (!vids.isEmpty()) {
            List<String> pids = new LinkedList<>(board.getPreferences().subTree(""pid"", 1).values());
            List<String> descriptors = new LinkedList<>(board.getPreferences().subTree(""descriptor"", 1).values());
            for (int i = 0; i < vids.size(); i++) {
              String vidPid = vids.get(i) + ""_"" + pids.get(i);
              if (vid_pid_iSerial.toUpperCase().contains(vidPid.toUpperCase())) {
                if (!descriptors.isEmpty()) {
                  boolean matched = false;
                  for (int j = 0; j < descriptors.size(); j++) {
                    if (vid_pid_iSerial.toUpperCase().contains(descriptors.get(j).toUpperCase())) {
                      matched = true;
                      break;
                    }
                  }
                  if (matched == false) {
                    continue;
                  }
                }
                Map<String, Object> boardData = new HashMap<>();
                boardData.put(""board"", board);
                // remove 0x from VID / PID to keep them as reported by liblistserial
                boardData.put(""vid"", vids.get(i).replaceAll(""0x"", """"));
                boardData.put(""pid"", pids.get(i).replaceAll(""0x"", """"));
                String extrafields = vid_pid_iSerial.substring(vidPid.length() + 1);
                String[] parts = extrafields.split(""_"");
                boardData.put(""iserial"", parts[0]);
                return boardData;
              }
            }
          }
        }
      }
    }",iterator
targetPlatform,"for (TargetPlatform targetPlatform : targetPackage.getPlatforms().values()) {
        for (TargetBoard board : targetPlatform.getBoards().values()) {
          List<String> vids = new LinkedList<>(board.getPreferences().subTree(""vid"", 1).values());
          if (!vids.isEmpty()) {
            List<String> pids = new LinkedList<>(board.getPreferences().subTree(""pid"", 1).values());
            List<String> descriptors = new LinkedList<>(board.getPreferences().subTree(""descriptor"", 1).values());
            for (int i = 0; i < vids.size(); i++) {
              String vidPid = vids.get(i) + ""_"" + pids.get(i);
              if (vid_pid_iSerial.toUpperCase().contains(vidPid.toUpperCase())) {
                if (!descriptors.isEmpty()) {
                  boolean matched = false;
                  for (int j = 0; j < descriptors.size(); j++) {
                    if (vid_pid_iSerial.toUpperCase().contains(descriptors.get(j).toUpperCase())) {
                      matched = true;
                      break;
                    }
                  }
                  if (matched == false) {
                    continue;
                  }
                }
                Map<String, Object> boardData = new HashMap<>();
                boardData.put(""board"", board);
                // remove 0x from VID / PID to keep them as reported by liblistserial
                boardData.put(""vid"", vids.get(i).replaceAll(""0x"", """"));
                boardData.put(""pid"", pids.get(i).replaceAll(""0x"", """"));
                String extrafields = vid_pid_iSerial.substring(vidPid.length() + 1);
                String[] parts = extrafields.split(""_"");
                boardData.put(""iserial"", parts[0]);
                return boardData;
              }
            }
          }
        }
      }",iterator
board,"for (TargetBoard board : targetPlatform.getBoards().values()) {
          List<String> vids = new LinkedList<>(board.getPreferences().subTree(""vid"", 1).values());
          if (!vids.isEmpty()) {
            List<String> pids = new LinkedList<>(board.getPreferences().subTree(""pid"", 1).values());
            List<String> descriptors = new LinkedList<>(board.getPreferences().subTree(""descriptor"", 1).values());
            for (int i = 0; i < vids.size(); i++) {
              String vidPid = vids.get(i) + ""_"" + pids.get(i);
              if (vid_pid_iSerial.toUpperCase().contains(vidPid.toUpperCase())) {
                if (!descriptors.isEmpty()) {
                  boolean matched = false;
                  for (int j = 0; j < descriptors.size(); j++) {
                    if (vid_pid_iSerial.toUpperCase().contains(descriptors.get(j).toUpperCase())) {
                      matched = true;
                      break;
                    }
                  }
                  if (matched == false) {
                    continue;
                  }
                }
                Map<String, Object> boardData = new HashMap<>();
                boardData.put(""board"", board);
                // remove 0x from VID / PID to keep them as reported by liblistserial
                boardData.put(""vid"", vids.get(i).replaceAll(""0x"", """"));
                boardData.put(""pid"", pids.get(i).replaceAll(""0x"", """"));
                String extrafields = vid_pid_iSerial.substring(vidPid.length() + 1);
                String[] parts = extrafields.split(""_"");
                boardData.put(""iserial"", parts[0]);
                return boardData;
              }
            }
          }
        }",iterator
i,"for (int i = 0; i < vids.size(); i++) {
              String vidPid = vids.get(i) + ""_"" + pids.get(i);
              if (vid_pid_iSerial.toUpperCase().contains(vidPid.toUpperCase())) {
                if (!descriptors.isEmpty()) {
                  boolean matched = false;
                  for (int j = 0; j < descriptors.size(); j++) {
                    if (vid_pid_iSerial.toUpperCase().contains(descriptors.get(j).toUpperCase())) {
                      matched = true;
                      break;
                    }
                  }
                  if (matched == false) {
                    continue;
                  }
                }
                Map<String, Object> boardData = new HashMap<>();
                boardData.put(""board"", board);
                // remove 0x from VID / PID to keep them as reported by liblistserial
                boardData.put(""vid"", vids.get(i).replaceAll(""0x"", """"));
                boardData.put(""pid"", pids.get(i).replaceAll(""0x"", """"));
                String extrafields = vid_pid_iSerial.substring(vidPid.length() + 1);
                String[] parts = extrafields.split(""_"");
                boardData.put(""iserial"", parts[0]);
                return boardData;
              }
            }",loop_control
j,"for (int j = 0; j < descriptors.size(); j++) {
                    if (vid_pid_iSerial.toUpperCase().contains(descriptors.get(j).toUpperCase())) {
                      matched = true;
                      break;
                    }
                  }",loop_control
targetPackage,"for (TargetPackage targetPackage : packages.values()) {
      for (TargetPlatform targetPlatform : targetPackage.getPlatforms().values()) {
        for (TargetBoard board : targetPlatform.getBoards().values()) {
          if (boardId.equals(board.getId())) {
            return board.getName();
          }
        }
      }
    }",iterator
targetPlatform,"for (TargetPlatform targetPlatform : targetPackage.getPlatforms().values()) {
        for (TargetBoard board : targetPlatform.getBoards().values()) {
          if (boardId.equals(board.getId())) {
            return board.getName();
          }
        }
      }",iterator
board,"for (TargetBoard board : targetPlatform.getBoards().values()) {
          if (boardId.equals(board.getId())) {
            return board.getName();
          }
        }",iterator
boardId,"{
    assert packages != null;
    assert boardId != null;
    for (TargetPackage targetPackage : packages.values()) {
      for (TargetPlatform targetPlatform : targetPackage.getPlatforms().values()) {
        for (TargetBoard board : targetPlatform.getBoards().values()) {
          if (boardId.equals(board.getId())) {
            return board.getName();
          }
        }
      }
    }
    return null;
  }",break_loop_control
key,"for (String key : keys) {
        if (key.startsWith(""runtime.""))
          continue;
        writer.println(key + ""="" + prefs.get(key));
      }",iterator
i,"for(int i = 0; i < minLength; i++){
                char charA = valueA.charAt(i - shiftA);
                char charB = valueB.charAt(i - shiftB);
                if(charA != charB){
                    if(Character.isDigit(charA) && Character.isDigit(charB)){
                        int[] resultsA = getNumberAndLastIndex(valueA, i - shiftA);
                        int[] resultsB = getNumberAndLastIndex(valueB, i - shiftB);

                        if(resultsA[0] != resultsB[0]){
                            return resultsA[0] - resultsB[0];
                        }

                        if(valueA.length() < valueB.length()){
                            i = resultsA[1];
                            shiftB = resultsA[1] - resultsB[1];
                        }
                        else {
                            i = resultsB[1];
                            shiftA = resultsB[1] - resultsA[1];
                        }
                    }
                    else {
                        if(Character.toLowerCase(charA) - Character.toLowerCase(charB) != 0){
                            return Character.toLowerCase(charA) - Character.toLowerCase(charB);
                        }
                    }
                }
            }",loop_control
i,"for(int i = startIndex; i < str.length(); i++){
                returnValues[1] = i;
                char c = str.charAt(i);
                if(Character.isDigit(c)){
                    numberValue += c;
                }
                else {
                    break;
                }
            }",loop_control
resultsA,"{
                        int[] resultsA = getNumberAndLastIndex(valueA, i - shiftA);
                        int[] resultsB = getNumberAndLastIndex(valueB, i - shiftB);

                        if(resultsA[0] != resultsB[0]){
                            return resultsA[0] - resultsB[0];
                        }

                        if(valueA.length() < valueB.length()){
                            i = resultsA[1];
                            shiftB = resultsA[1] - resultsB[1];
                        }
                        else {
                            i = resultsB[1];
                            shiftA = resultsB[1] - resultsA[1];
                        }
                    }",break_loop_control
resultsB,"{
                        int[] resultsA = getNumberAndLastIndex(valueA, i - shiftA);
                        int[] resultsB = getNumberAndLastIndex(valueB, i - shiftB);

                        if(resultsA[0] != resultsB[0]){
                            return resultsA[0] - resultsB[0];
                        }

                        if(valueA.length() < valueB.length()){
                            i = resultsA[1];
                            shiftB = resultsA[1] - resultsB[1];
                        }
                        else {
                            i = resultsB[1];
                            shiftA = resultsB[1] - resultsA[1];
                        }
                    }",break_loop_control
c,"{
            String numberValue = """";
            int[] returnValues = {-1, startIndex};
            for(int i = startIndex; i < str.length(); i++){
                returnValues[1] = i;
                char c = str.charAt(i);
                if(Character.isDigit(c)){
                    numberValue += c;
                }
                else {
                    break;
                }
            }",break_loop_control
portName,"for(String portName : portNames){
            if(pattern.matcher(portName).find()){
                ports.add(portName);
            }
        }",iterator
file,"for(File file : files){
                    String fileName = file.getName();
                    if(!file.isDirectory() && !file.isFile() && pattern.matcher(fileName).find()){
                        String portName = searchPath + fileName;
                        // For linux ttyS0..31 serial ports check existence by opening each of them
                        if (fileName.startsWith(""ttyS"")) {
	                        long portHandle = serialInterface.openPort(portName, false);//Open port without TIOCEXCL
	                        if(portHandle < 0 && portHandle != SerialNativeInterface.ERR_PORT_BUSY){
	                            continue;
	                        }
	                        else if(portHandle != SerialNativeInterface.ERR_PORT_BUSY) {
	                            serialInterface.closePort(portHandle);
	                        }
                        }
                        portsTree.add(portName);
                    }
                }",iterator
folder,"for (Path folder : tempBuildFolders) {
      if (!deleteCompiledFilesFrom(folder)) {
        return false;
      }
    }",iterator
folder,"for (Path folder : tempBuildFolders) {
      if (!deleteCompiledFilesFrom(folder)) {
        return false;
      }
    }",break_loop_control
compiledFile,"for (Path compiledFile : compiledFiles) {
      try {
        Files.delete(compiledFile);
      } catch (IOException e) {
        return false;
      }
    }",iterator
l,"for (UserLibrary l : this)
      if (l.getName().equals(name))
        return l;",iterator
l,"for (UserLibrary l : this)
      if (l.getName().equals(name))
        return l;",break_loop_control
lib,"for (UserLibrary lib : this) {
      if (FileUtils.isSubDirectory(subFolder, lib.getInstalledFolder())) {
        res.add(lib);
      }
    }",iterator
l,"for (UserLibrary l : this)
      if (l == lib) return true;",iterator
l,"for (UserLibrary l : this)
      if (l == lib) return true;",break_loop_control
p,"for (String p : Constants.LIBRARY_MANDATORY_PROPERTIES)
      if (!properties.containsKey(p))
        throw new IOException(""Missing '"" + p + ""' from library"");",iterator
arch,"for (String arch : architectures.split("",""))
      archs.add(arch.trim());",iterator
type,"for (String type : types.split("","")) {
      typesList.add(type.trim());
    }",iterator
i,"for (String i : properties.get(""includes"").split("",""))
        includes.add(i.trim());",iterator
port,"for (BoardPort port : ports) {
      if (!port.getAddress().startsWith(""/dev/tty."")) {
        filteredPorts.add(port);
      }
    }",iterator
i,"for (int i = 0; i < command.length; i++)
      cmdLine[i] = command[i].replace(""\"""", ""\\\"""");",loop_control
i,"for (int i = 0; i < 10; i++) {
      // Do a replace with dictionary
      res = StringReplacer.replaceFromMapping(src, dict);
      if (res.equals(src))
        break;
      src = res;
    }",loop_control
res,"{
    // If the key is not missing -> everything is OK
    String checkedValue = inDict.get(key);
    if (checkedValue != null && !checkedValue.isEmpty())
      return;

    PreferencesMap dict = new PreferencesMap(inDict);

    // Find a random tag that is not contained in the dictionary and the src pattern
    String tag;
    while (true) {
      tag = UUID.randomUUID().toString();
      if (src.contains(tag))
        continue;
      if (dict.values().contains(tag))
        continue;
      if (dict.keySet().contains(tag))
        continue;
      break;
    }

    // Inject tag inside the dictionary
    dict.put(key, tag);

    // Recursive replace with a max depth of 10 levels.
    String res;
    for (int i = 0; i < 10; i++) {
      // Do a replace with dictionary
      res = StringReplacer.replaceFromMapping(src, dict);
      if (res.equals(src))
        break;
      src = res;
    }

    // If the resulting string contains the tag, then the key is required
    if (src.contains(tag)) {
      throw new PreferencesMapException(key);
    }
  }",break_loop_control
i,"for (int i = 0; i < 10; i++) {
      // Do a replace with dictionary
      res = StringReplacer.replaceFromMapping(src, dict);
      if (res.equals(src))
        break;
      src = res;
    }",loop_control
i,"for (String i : src.split("" "")) {
      if (escapingChar == null) {
        // If the first char is not an escape char..
        String first = null;
        if (i.length() > 0)
          first = i.substring(0, 1);
        if (first == null || !quoteChars.contains(first)) {
          if (i.trim().length() != 0 || acceptEmptyArguments)
            res.add(i);
          continue;
        }

        escapingChar = first;
        i = i.substring(1);
        escapedArg = """";
      }

      if (!i.endsWith(escapingChar)) {
        escapedArg += i + "" "";
        continue;
      }

      escapedArg += i.substring(0, i.length() - 1);
      if (escapedArg.trim().length() != 0 || acceptEmptyArguments)
        res.add(escapedArg);
      escapingChar = null;
    }",iterator
entry,"for (Map.Entry<String, String> entry : map.entrySet()) {
      String keyword = leftDelimiter + entry.getKey() + rightDelimiter;
      if (entry.getValue() != null && keyword != null) {
          src = src.replace(keyword, entry.getValue());
      }
    }",iterator
port,"for (Integer port : ports) {
      reachable = reachable || isPortOpen(address, port);
    }",iterator
targetPackage,"for (TargetPackage targetPackage : packages.values()) {
      for (TargetPlatform targetPlatform : targetPackage.getPlatforms().values()) {
        for (TargetBoard board : targetPlatform.getBoards().values()) {
          if (boardId.equals(board.getId())) {
            return board.getName();
          }
        }
      }
    }",iterator
targetPlatform,"for (TargetPlatform targetPlatform : targetPackage.getPlatforms().values()) {
        for (TargetBoard board : targetPlatform.getBoards().values()) {
          if (boardId.equals(board.getId())) {
            return board.getName();
          }
        }
      }",iterator
board,"for (TargetBoard board : targetPlatform.getBoards().values()) {
          if (boardId.equals(board.getId())) {
            return board.getName();
          }
        }",iterator
line,"for (String line : lines) {
      if (line.length() == 0 || line.charAt(0) == '#')
        continue;

      int equals = line.indexOf('=');
      if (equals != -1) {
        String key = line.substring(0, equals).trim();
        String value = line.substring(equals + 1).trim();

        key = processPlatformSuffix(key, "".linux"", OSUtils.isLinux());
        key = processPlatformSuffix(key, "".windows"", OSUtils.isWindows());
        key = processPlatformSuffix(key, "".macosx"", OSUtils.isMacOS());

        if (key != null)
          put(key, value);
      }
    }",iterator
key,"for (String key : keySet()) {
      if (key.contains("".""))
        continue;
      res.put(key, get(key));
    }",iterator
key,"for (String key : keySet()) {
      int dot = key.indexOf('.');
      if (dot == -1)
        continue;

      String parent = key.substring(0, dot);
      String child = key.substring(dot + 1);

      if (!res.containsKey(parent))
        res.put(parent, new PreferencesMap());
      res.get(parent).put(child, get(key));
    }",iterator
key,"for (String key : keySet()) {
      if (key.startsWith(parent)) {
        String newKey = key.substring(parentLen);
        int keySubLevels = newKey.split(""\\."").length;
        if (sublevels == -1 || keySubLevels == sublevels) {
          res.put(newKey, get(key));
        }
      }
    }",iterator
k,"for (String k : treeSet)
      res += indent + ""  "" + k + "" = "" + get(k) + ""\n"";",iterator
parentFile,"{
    try {
      base = base.getCanonicalFile();
      child = child.getCanonicalFile();
    } catch (IOException e) {
      return false;
    }

    File parentFile = child;
    while (parentFile != null) {
      if (base.equals(parentFile)) {
        return true;
      }
      parentFile = parentFile.getParentFile();
    }
    return false;
  }",maybe_loop_control
readBytes,"{
      fis = new FileInputStream(source);
      fos = new FileOutputStream(dest);
      byte[] buf = new byte[4096];
      int readBytes = -1;
      while ((readBytes = fis.read(buf, 0, buf.length)) != -1) {
        fos.write(buf, 0, readBytes);
      }
    }",maybe_loop_control
file,"for (File file : sourceFolder.listFiles()) {
      File destFile = new File(destFolder, file.getName());
      if (file.isDirectory() && !SOURCE_CONTROL_FOLDERS.contains(file.getName())) {
        if (!destFile.exists() && !destFile.mkdir()) {
          throw new IOException(""Unable to create folder: "" + destFile);
        }
        copy(file, destFile);
      } else if (!file.isDirectory()) {
        copyFile(file, destFile);
      }
    }",iterator
current,"for (File current : files) {
        recursiveDelete(current);
      }",iterator
line,"{
      reader = new BufferedReader(new InputStreamReader(new FileInputStream(file), encoding));
      StringBuilder sb = new StringBuilder();
      String line;
      while ((line = reader.readLine()) != null) {
        sb.append(line).append(""\n"");
      }
      return sb.toString();
    }",maybe_loop_control
file,"for (File file : folder.listFiles()) {
      if (isSCCSOrHiddenFile(file))
        continue;

      if (file.isDirectory()) {
        if (recursive)
          result.addAll(listFiles(file, true, extensions));
        continue;
      }

      if (extensions.isEmpty() || hasExtension(file, extensions))
        result.add(file);
    }",iterator
i,"for (int i = 0; i < args.length; i++) {
      ACTION a = actions.get(args[i]);
      if (a != null) {
        if (action != ACTION.GUI && action != ACTION.NOOP) {
          Set<String> strings = actions.keySet();
          String[] valid = strings.toArray(new String[strings.size()]);
          String mess = I18n.format(tr(""Can only pass one of: {0}""), PApplet.join(valid, "", ""));
          BaseNoGui.showError(null, mess, 3);
        }
        if (a == ACTION.GET_PREF) {
          i++;
          if (i < args.length) {
            getPref = args[i];
          }
        }
        if (a == ACTION.INSTALL_BOARD) {
          i++;
          if (i >= args.length) {
            BaseNoGui.showError(null, I18n.format(tr(""Argument required for {0}""), a.value), 3);
          }
          boardToInstall = args[i];
        }
        if (a == ACTION.INSTALL_LIBRARY) {
          i++;
          if (i >= args.length) {
            BaseNoGui.showError(null, I18n.format(tr(""Argument required for {0}""), a.value), 3);
          }
          libraryToInstall = args[i];
        }
        action = a;
        continue;
      }
      if (args[i].startsWith(""-psn"")) {
        //discard
        continue;
      }
      if (args[i].equals(""--verbose"") || args[i].equals(""-v"")) {
        doVerboseBuild = true;
        doVerboseUpload = true;
        if (action == ACTION.GUI)
          action = ACTION.NOOP;
        continue;
      }
      if (args[i].equals(""--preserve-temp-files"")) {
        preserveTempFiles = true;
        if (action == ACTION.GUI)
          action = ACTION.NOOP;
        continue;
      }
      if (args[i].equals(""--verbose-build"")) {
        doVerboseBuild = true;
        if (action == ACTION.GUI)
          action = ACTION.NOOP;
        continue;
      }
      if (args[i].equals(""--verbose-upload"")) {
        doVerboseUpload = true;
        if (action == ACTION.GUI)
          action = ACTION.NOOP;
        continue;
      }
      if (args[i].equals(""--useprogrammer"")) {
        doUseProgrammer = true;
        if (action == ACTION.GUI)
          action = ACTION.NOOP;
        continue;
      }
      if (args[i].equals(""--nouploadport"")) {
        noUploadPort = true;
        if (action == ACTION.GUI)
          action = ACTION.NOOP;
        continue;
      }
      if (args[i].equals(""--board"")) {
        i++;
        if (i >= args.length)
          BaseNoGui.showError(null, tr(""Argument required for --board""), 3);
        if (action == ACTION.GUI)
          action = ACTION.NOOP;
        continue;
      }
      if (args[i].equals(""--port"")) {
        i++;
        if (i >= args.length)
          BaseNoGui.showError(null, tr(""Argument required for --port""), 3);
        uploadPort = Optional.of(args[i]);
        if (action == ACTION.GUI)
          action = ACTION.NOOP;
        continue;
      }
      if (args[i].equals(""--curdir"")) {
        BaseNoGui.showError(null, tr(""--curdir no longer supported""), 3);
        return;
      }
      if (args[i].equals(""--buildpath"")) {
        i++;
        if (i >= args.length) {
          BaseNoGui.showError(null, ""Argument required for --buildpath"", 3);
        }
        File buildFolder = new File(args[i]);
        if (!buildFolder.exists()) {
          BaseNoGui.showError(null, ""The build path doesn't exist"", 3);
        }
        if (!buildFolder.isDirectory()) {
          BaseNoGui.showError(null, ""The build path is not a folder"", 3);
        }
        PreferencesData.set(""build.path"", buildFolder.getAbsolutePath());
        continue;
      }
      if (args[i].equals(""--pref"")) {
        i++;
        if (i >= args.length)
          BaseNoGui.showError(null, tr(""Argument required for --pref""), 3);
        processPrefArgument(args[i]);
        if (action == ACTION.GUI)
          action = ACTION.NOOP;
        continue;
      }
      if (args[i].equals(""--save-prefs"")) {
        forceSavePrefs = true;
        continue;
      }
      if (args[i].equals(""--preferences-file"")) {
        i++;
        if (i >= args.length)
          BaseNoGui.showError(null, tr(""Argument required for --preferences-file""), 3);
        // Argument should be already processed by Base.main(...)
        continue;
      }
      if (args[i].startsWith(""--""))
        BaseNoGui.showError(null, I18n.format(tr(""unknown option: {0}""), args[i]), 3);

      filenames.add(args[i]);
    }",loop_control
i,"for (int i = 0; i < args.length; i++) {
      if (args[i].equals(""--board"")) {
        i++;
        if (i >= args.length) {
          BaseNoGui.showError(null, tr(""Argument required for --board""), 3);
        }
        processBoardArgument(args[i]);
        if (action == ACTION.GUI) {
          action = ACTION.NOOP;
        }
      }
    }",loop_control
option,"for (String option : options) {
        String[] keyValue = option.split(""="", 2);

        if (keyValue.length != 2)
          BaseNoGui.showError(null, I18n.format(tr(""{0}: Invalid option, should be of the form \""name=value\""""), option, targetBoard.getId()), 3);
        String key = keyValue[0].trim();
        String value = keyValue[1].trim();

        if (!targetBoard.hasMenu(key))
          BaseNoGui.showError(null, I18n.format(tr(""{0}: Invalid option for board \""{1}\""""), key, targetBoard.getId()), 3);
        if (targetBoard.getMenuLabel(key, value) == null)
          BaseNoGui.showError(null, I18n.format(tr(""{0}: Invalid value for option \""{1}\"" for board \""{2}\""""), value, key, targetBoard.getId()), 3);

        PreferencesData.set(""custom_"" + key, targetBoard.getId() + ""_"" + value);
      }",iterator
ext,"for (String ext : extensions) {
      if (name.endsWith(ext)) {
        return true;
      }
    }",iterator
name,"for (String ext : extensions) {
      if (name.endsWith(ext)) {
        return true;
      }
    }",break_loop_control
line,"{
    BufferedReader reader = new BufferedReader(new StringReader(output));
    String line;
    while ((line = reader.readLine()) != null) {
      String[] lineParts = line.split("" "");
      if (lineParts.length > 0 && lineParts[0].toUpperCase().equals(serial.toUpperCase())) {
        String vidPidPart = lineParts[lineParts.length - 1];
        Matcher vidMatcher = vidRegExp.matcher(vidPidPart);
        Matcher pidMatcher = pidRegExp.matcher(vidPidPart);
        if (vidMatcher.find() && pidMatcher.find()) {
          return (""0x"" + vidMatcher.group(1) + ""_0x"" + pidMatcher.group(1)).toUpperCase();
        }
      }
    }

    return null;
  }",iterator
vidMatcher,"{
        String vidPidPart = lineParts[lineParts.length - 1];
        Matcher vidMatcher = vidRegExp.matcher(vidPidPart);
        Matcher pidMatcher = pidRegExp.matcher(vidPidPart);
        if (vidMatcher.find() && pidMatcher.find()) {
          return (""0x"" + vidMatcher.group(1) + ""_0x"" + pidMatcher.group(1)).toUpperCase();
        }
      }",break_loop_control
pidMatcher,"{
        String vidPidPart = lineParts[lineParts.length - 1];
        Matcher vidMatcher = vidRegExp.matcher(vidPidPart);
        Matcher pidMatcher = pidRegExp.matcher(vidPidPart);
        if (vidMatcher.find() && pidMatcher.find()) {
          return (""0x"" + vidMatcher.group(1) + ""_0x"" + pidMatcher.group(1)).toUpperCase();
        }
      }",break_loop_control
lineParts,"{
      String[] lineParts = line.split("" "");
      if (lineParts.length > 0 && lineParts[0].toUpperCase().equals(serial.toUpperCase())) {
        String vidPidPart = lineParts[lineParts.length - 1];
        Matcher vidMatcher = vidRegExp.matcher(vidPidPart);
        Matcher pidMatcher = pidRegExp.matcher(vidPidPart);
        if (vidMatcher.find() && pidMatcher.find()) {
          return (""0x"" + vidMatcher.group(1) + ""_0x"" + pidMatcher.group(1)).toUpperCase();
        }
      }
    }",break_loop_control
item,"for (String item : pieces) {
      if (item.startsWith(""\"""")) {
        item = item.substring(1);
      }
      if (item.endsWith(""\"""")) {
        item = item.substring(0, item.length() - 1);
      }
      if (item.endsWith(File.separator)) {
        item = item.substring(0, item.length() - File.separator.length());
      }
      File directory = new File(item);
      if (!directory.exists()) {
        continue;
      }
      if (item.trim().length() == 0) {
        continue;
      }
      legit[legitCount++] = item;
    }",iterator
toker,"{
    StringTokenizer toker = new StringTokenizer(what, delim);
    String pieces[] = new String[toker.countTokens()];

    int index = 0;
    while (toker.hasMoreTokens()) {
      pieces[index++] = toker.nextToken();
    }
    return pieces;
  }",maybe_loop_control
i,"for (int i = 0; i < chars.length; i++) {
      if (chars[i] == delim)
        splitCount++;
    }",loop_control
i,"for (int i = 0; i < chars.length; i++) {
      if (chars[i] == delim) {
        splits[splitIndex++] = new String(chars, startIndex, i - startIndex);
        startIndex = i + 1;
      }
    }",loop_control
i,"for (int i = 0; i < str.length; i++) {
      if (i != 0) buffer.append(separator);
      buffer.append(str[i]);
    }",loop_control
i,"for (int i = 0; i < what.length; i++) {
      try {
        output[i] = Integer.parseInt(what[i]);
      } catch (NumberFormatException e) {
        output[i] = missing;
      }
    }",loop_control
line,"{
      reader = new BufferedReader(new InputStreamReader(input, ""UTF-8""));

      String lines[] = new String[100];
      int lineCount = 0;
      String line = null;
      while ((line = reader.readLine()) != null) {
        if (lineCount == lines.length) {
          String temp[] = new String[lineCount << 1];
          System.arraycopy(lines, 0, temp, 0, lineCount);
          lines = temp;
        }
        lines[lineCount++] = line;
      }

      if (lineCount == lines.length) {
        return lines;
      }

      // resize array to appropriate amount for these lines
      String output[] = new String[lineCount];
      System.arraycopy(lines, 0, output, 0, lineCount);
      return output;

    }",maybe_loop_control
string,"for (String string : strings) {
        writer.println(string);
      }",iterator
m,"{
    Pattern p = Pattern.compile(regexp, Pattern.MULTILINE | Pattern.DOTALL);
    Matcher m = p.matcher(what);
    ArrayList<String[]> results = new ArrayList<>();
    int count = m.groupCount() + 1;
    while (m.find()) {
      String[] groups = new String[count];
      for (int i = 0; i < count; i++) {
        groups[i] = m.group(i);
      }
      results.add(groups);
    }
    if (results.isEmpty()) {
      return null;
    }
    String[][] matches = new String[results.size()][count];
    for (int i = 0; i < matches.length; i++) {
      matches[i] = results.get(i);
    }
    return matches;
  }",maybe_loop_control
i,"for (int i = 0; i < count; i++) {
        groups[i] = m.group(i);
      }",loop_control
i,"for (int i = 0; i < matches.length; i++) {
      matches[i] = results.get(i);
    }",loop_control
i,"for (int i = 0; i < count; i++) {
        groups[i] = m.group(i);
      }",loop_control
i,"for (int i = 0; i < formatted.length; i++) {
      formatted[i] = nf(num[i], digits);
    }",loop_control
i,for (int i = 0; i < x.length; i++) s[i] = String.valueOf(x[i]);,loop_control
boardId,"for (String boardId : boardIds) {
        PreferencesMap prefs = boardsPreferences.get(boardId);
        TargetBoard board = new LegacyTargetBoard(boardId, prefs, this);
        boards.put(boardId, board);

        // Pick the first board as default
        if (defaultBoard == null)
          defaultBoard = board;
      }",iterator
entry,"for (Map.Entry<String, String> entry : oldProps.entrySet()) {
      String preferencesKey = entry.getKey().substring(entry.getKey().indexOf(""."") + 1);
      if (preferences.containsKey(preferencesKey) && entry.getValue().equals(preferences.get(preferencesKey))) {
        preferences.put(preferencesKey, newProps.get(entry.getKey()));
      }
    }",iterator
entry,"for (Map.Entry<String, String> entry : addedProps.entrySet()) {
      String keyToAdd = entry.getKey();
      String[] keyToAddParts = keyToAdd.split(""\\."");
      String keyToAddFirstLevel = keyToAddParts[0];
      String keyToAddSecondLevel = keyToAddParts[0] + ""."" + keyToAddParts[1];
      if (!preferences.subTree(keyToAddFirstLevel).isEmpty() && !preferences.subTree(keyToAddSecondLevel).isEmpty() && !preferences.containsKey(keyToAdd)) {
        preferences.put(keyToAdd, entry.getValue());
      }
    }",iterator
boardId,"for (String boardId : boards.keySet())
      res += ""  "" + boardId + "" = "" + boards.get(boardId) + ""\n"";",iterator
running,"{
      String pattern = prefs.get(""recipe.size.pattern"");
      String cmd[] = StringReplacer.formatAndSplit(pattern, prefs);

      exception = null;
      textSize = -1;
      dataSize = -1;
      eepromSize = -1;
      Process process = ProcessUtils.exec(cmd);
      MessageSiphon in = new MessageSiphon(process.getInputStream(), this);
      MessageSiphon err = new MessageSiphon(process.getErrorStream(), this);

      boolean running = true;
      while(running) {
        try {
          in.join();
          err.join();
          r = process.waitFor();
          running = false;
        } catch (InterruptedException intExc) { }
      }
    }",maybe_loop_control
canRun,"{
      // process data until we hit EOF; this will happily block
      // (effectively sleeping the thread) until new data comes in.
      // when the program is finally done, null will come through.
      //
      StringBuilder currentLine = new StringBuilder();
      long lineStartTime = 0;
      while (canRun) {
        // First, try to read as many characters as possible. Take care
        // not to block when:
        //  1. lineTimeout is nonzero, and
        //  2. we have some characters buffered already
        while (lineTimeout == 0 || currentLine.length() == 0 || streamReader.ready()) {
          int c = streamReader.read();
          if (c == -1)
            return; // EOF
          if (!canRun)
            return;

          // Keep track of the line start time
          if (currentLine.length() == 0)
            lineStartTime = System.nanoTime();

          // Store the character line
          currentLine.append((char)c);

          if (c == '\n') {
            // We read a full line, pass it on
            consumer.message(currentLine.toString());
            currentLine.setLength(0);
          }
        }

        // No more characters available. Wait until lineTimeout
        // milliseconds have passed since the start of the line and then
        // try reading again. If the time has already passed, then just
        // pass on the characters read so far.
        long passed = (System.nanoTime() - lineStartTime) / 1000;
        if (passed < this.lineTimeout) {
          Thread.sleep(this.lineTimeout - passed);
          continue;
        }

        consumer.message(currentLine.toString());
        currentLine.setLength(0);
      }
      //EditorConsole.systemOut.println(""messaging thread done"");
    }",maybe_loop_control
lineTimeout,"{
        // First, try to read as many characters as possible. Take care
        // not to block when:
        //  1. lineTimeout is nonzero, and
        //  2. we have some characters buffered already
        while (lineTimeout == 0 || currentLine.length() == 0 || streamReader.ready()) {
          int c = streamReader.read();
          if (c == -1)
            return; // EOF
          if (!canRun)
            return;

          // Keep track of the line start time
          if (currentLine.length() == 0)
            lineStartTime = System.nanoTime();

          // Store the character line
          currentLine.append((char)c);

          if (c == '\n') {
            // We read a full line, pass it on
            consumer.message(currentLine.toString());
            currentLine.setLength(0);
          }
        }

        // No more characters available. Wait until lineTimeout
        // milliseconds have passed since the start of the line and then
        // try reading again. If the time has already passed, then just
        // pass on the characters read so far.
        long passed = (System.nanoTime() - lineStartTime) / 1000;
        if (passed < this.lineTimeout) {
          Thread.sleep(this.lineTimeout - passed);
          continue;
        }

        consumer.message(currentLine.toString());
        currentLine.setLength(0);
      }",loop_control
currentLine,"{
      // process data until we hit EOF; this will happily block
      // (effectively sleeping the thread) until new data comes in.
      // when the program is finally done, null will come through.
      //
      StringBuilder currentLine = new StringBuilder();
      long lineStartTime = 0;
      while (canRun) {
        // First, try to read as many characters as possible. Take care
        // not to block when:
        //  1. lineTimeout is nonzero, and
        //  2. we have some characters buffered already
        while (lineTimeout == 0 || currentLine.length() == 0 || streamReader.ready()) {
          int c = streamReader.read();
          if (c == -1)
            return; // EOF
          if (!canRun)
            return;

          // Keep track of the line start time
          if (currentLine.length() == 0)
            lineStartTime = System.nanoTime();

          // Store the character line
          currentLine.append((char)c);

          if (c == '\n') {
            // We read a full line, pass it on
            consumer.message(currentLine.toString());
            currentLine.setLength(0);
          }
        }

        // No more characters available. Wait until lineTimeout
        // milliseconds have passed since the start of the line and then
        // try reading again. If the time has already passed, then just
        // pass on the characters read so far.
        long passed = (System.nanoTime() - lineStartTime) / 1000;
        if (passed < this.lineTimeout) {
          Thread.sleep(this.lineTimeout - passed);
          continue;
        }

        consumer.message(currentLine.toString());
        currentLine.setLength(0);
      }
      //EditorConsole.systemOut.println(""messaging thread done"");
    }",maybe_loop_control
streamReader,"{
        // First, try to read as many characters as possible. Take care
        // not to block when:
        //  1. lineTimeout is nonzero, and
        //  2. we have some characters buffered already
        while (lineTimeout == 0 || currentLine.length() == 0 || streamReader.ready()) {
          int c = streamReader.read();
          if (c == -1)
            return; // EOF
          if (!canRun)
            return;

          // Keep track of the line start time
          if (currentLine.length() == 0)
            lineStartTime = System.nanoTime();

          // Store the character line
          currentLine.append((char)c);

          if (c == '\n') {
            // We read a full line, pass it on
            consumer.message(currentLine.toString());
            currentLine.setLength(0);
          }
        }

        // No more characters available. Wait until lineTimeout
        // milliseconds have passed since the start of the line and then
        // try reading again. If the time has already passed, then just
        // pass on the characters read so far.
        long passed = (System.nanoTime() - lineStartTime) / 1000;
        if (passed < this.lineTimeout) {
          Thread.sleep(this.lineTimeout - passed);
          continue;
        }

        consumer.message(currentLine.toString());
        currentLine.setLength(0);
      }",maybe_loop_control
c,"{
          int c = streamReader.read();
          if (c == -1)
            return; // EOF
          if (!canRun)
            return;

          // Keep track of the line start time
          if (currentLine.length() == 0)
            lineStartTime = System.nanoTime();

          // Store the character line
          currentLine.append((char)c);

          if (c == '\n') {
            // We read a full line, pass it on
            consumer.message(currentLine.toString());
            currentLine.setLength(0);
          }
        }",break_loop_control
canRun,"{
      // process data until we hit EOF; this will happily block
      // (effectively sleeping the thread) until new data comes in.
      // when the program is finally done, null will come through.
      //
      StringBuilder currentLine = new StringBuilder();
      long lineStartTime = 0;
      while (canRun) {
        // First, try to read as many characters as possible. Take care
        // not to block when:
        //  1. lineTimeout is nonzero, and
        //  2. we have some characters buffered already
        while (lineTimeout == 0 || currentLine.length() == 0 || streamReader.ready()) {
          int c = streamReader.read();
          if (c == -1)
            return; // EOF
          if (!canRun)
            return;

          // Keep track of the line start time
          if (currentLine.length() == 0)
            lineStartTime = System.nanoTime();

          // Store the character line
          currentLine.append((char)c);

          if (c == '\n') {
            // We read a full line, pass it on
            consumer.message(currentLine.toString());
            currentLine.setLength(0);
          }
        }

        // No more characters available. Wait until lineTimeout
        // milliseconds have passed since the start of the line and then
        // try reading again. If the time has already passed, then just
        // pass on the characters read so far.
        long passed = (System.nanoTime() - lineStartTime) / 1000;
        if (passed < this.lineTimeout) {
          Thread.sleep(this.lineTimeout - passed);
          continue;
        }

        consumer.message(currentLine.toString());
        currentLine.setLength(0);
      }
      //EditorConsole.systemOut.println(""messaging thread done"");
    }",break_loop_control
line,"for(String line : lines) {
      contentBuilder.append(line).append('\n');
    }",iterator
language,"for (Language language : Languages.languages) {
      if (!language.getIsoCode().equals("""")) {
        Locale locale = toLocale(language);
        ResourceBundle bundle = ResourceBundle.getBundle(""processing.app.i18n.Resources"", locale);
        if (locale.equals(bundle.getLocale())) {
          Collections.list(bundle.getKeys()).stream().map(bundle::getString).filter(key -> !key.contains(""<html"")).forEach(key -> {
            try {
              I18n.format(key);
            } catch (IllegalArgumentException e) {
              System.out.println(language);
              System.out.println(key);
              throw e;
            }
          });
        } else {
          System.out.println(""Missing locale: "" + locale);
        }
      }
    }",iterator
line,"{
    StringWriter sw = new StringWriter();

    BufferedReader reader = new BufferedReader(new InputStreamReader(is));
    String line;
    try {
      while ((line = reader.readLine()) != null) {
        sw.append(line).append('\n');
      }
      return sw.toString();
    } finally {
      is.close();
    }
  }",maybe_loop_control
f,"for (File f : deleteAfter)
      FileUtils.recursiveDelete(f);",iterator
submenu,"for (Component submenu : menu.getMenuComponents()) {
      if (submenu instanceof JMenu && text.equals(((JMenu) submenu).getText())) {
        return (JMenu) submenu;
      }
    }",iterator
submenu,"for (Component submenu : menu.getMenuComponents()) {
      if (submenu instanceof JMenu && text.equals(((JMenu) submenu).getText())) {
        return (JMenu) submenu;
      }
    }",break_loop_control
e,"for (Editor e : base.getEditors()) {
          if (e.getSketch().isModified()) {
            String msg = tr(""You have unsaved changes!\nYou must save all your sketches to enable this option."");
            JOptionPane.showMessageDialog(null, msg,
                                          tr(""Can't enable external editor""),
                                          JOptionPane.INFORMATION_MESSAGE);
            externalEditorBox.setSelected(false);
            return;
          }
        }",iterator
e,"for (Editor e : base.getEditors()) {
          if (e.getSketch().isModified()) {
            String msg = tr(""You have unsaved changes!\nYou must save all your sketches to enable this option."");
            JOptionPane.showMessageDialog(null, msg,
                                          tr(""Can't enable external editor""),
                                          JOptionPane.INFORMATION_MESSAGE);
            externalEditorBox.setSelected(false);
            return;
          }
        }",break_loop_control
language,"for (Language language : Languages.languages) {
      if (language.getIsoCode().equals(currentLanguageISOCode)) {
        comboLanguage.setSelectedItem(language);
      }
    }",iterator
theme,"for (ZippedTheme theme : availablethemes) {
      comboTheme.addItem(theme);
      if (theme.getKey().equals(selectedTheme)) {
        comboTheme.setSelectedItem(theme);
      }
    }",iterator
item,"for (WarningItem item : warningItems) {
      if (currentWarningLevel.equals(item.getValue())) {
        comboWarnings.setSelectedItem(item);
      }
    }",iterator
base,"{
    if (PreferencesData.getInteger(""builtin_platform_is_newer"", -1) >= BaseNoGui.REVISION) {
      return;
    }

    List<ContributedPlatform> contributedPlatforms = BaseNoGui.indexer
        .getPackages().stream() //
        .map(pack -> pack.getPlatforms()) //
        .flatMap(platfs -> platfs.stream()) //
        .collect(Collectors.toList());

    Optional<ContributedPlatform> mayInstalledBuiltIn = contributedPlatforms
        .stream() //
        .filter(p -> p.isInstalled()) //
        .filter(p -> p.isBuiltIn()) //
        .findFirst();
    if (!mayInstalledBuiltIn.isPresent()) {
      return;
    }
    final ContributedPlatform installedBuiltIn = mayInstalledBuiltIn.get();

    ContributedPlatform installedNotBuiltIn = BaseNoGui.indexer.getInstalled(installedBuiltIn.getParentPackage().getName(), installedBuiltIn.getArchitecture());
    if (installedNotBuiltIn == null) {
      return;
    }

    while (!base.hasActiveEditor()) {
      Thread.sleep(100);
    }

    if (VersionComparator.greaterThan(installedBuiltIn.getParsedVersion(), installedNotBuiltIn.getParsedVersion())) {
      SwingUtilities.invokeLater(() -> {
        PreferencesData.setInteger(""builtin_platform_is_newer"", BaseNoGui.REVISION);
        assert base.hasActiveEditor();
        int chosenOption = JOptionPane.showConfirmDialog(base.getActiveEditor(), I18n.format(tr(""The IDE includes an updated {0} package, but you're using an older one.\nDo you want to upgrade {0}?""), installedBuiltIn.getName()), I18n.format(tr(""A newer {0} package is available""), installedBuiltIn.getName()), JOptionPane.YES_NO_OPTION, JOptionPane.QUESTION_MESSAGE);
        if (chosenOption == JOptionPane.YES_OPTION) {
          try {
            base.openBoardsManager(installedBuiltIn.getName(), """");
          } catch (Exception e) {
            e.printStackTrace();
          }
        }
      });
    }
  }",maybe_loop_control
e,"for (Editor e : base.getEditors())
            e.removeWindowFocusListener(this);",iterator
e,"for (Editor e : base.getEditors())
        e.addWindowFocusListener(wfl);",iterator
s,"for (String s : categories) {
      categoryChooser.addItem(new DropdownCoreOfCategoryItem(s));
    }",iterator
board,"for (ContributedBoard board : selected.getBoards()) {
      desc += board.getName() + "", "";
    }",iterator
plat,"for (ContributedPlatform plat : releases) {
      if (plat == value) {
        selected = plat;
        return;
      }
    }",iterator
pack,"for (ContributedPackage pack : BaseNoGui.indexer.getPackages()) {
      for (ContributedPlatform platform : pack.getPlatforms()) {
        addContribution(platform);
      }
    }",iterator
platform,"for (ContributedPlatform platform : pack.getPlatforms()) {
        addContribution(platform);
      }",iterator
platform,"for (ContributedPlatform platform : releases.releases) {
        String compoundTargetSearchText = platform.getName() + ""\n""
                                          + platform.getBoards().stream()
                                              .map(ContributedBoard::getName)
                                              .collect(Collectors.joining("" ""));
        if (!filter.test(platform)) {
          continue;
        }
        if (!stringContainsAll(compoundTargetSearchText, filters))
          continue;
        return false;
      }",iterator
s,"for (String s : set) {
      if (!string.toLowerCase().contains(s.toLowerCase()))
        return false;
    }",iterator
contribution,"for (ContributedPlatformReleases contribution : contributions) {
      if (!contribution.shouldContain(platform)) {
        continue;
      }
      contribution.add(platform);
      return;
    }",iterator
filter,"for (String filter : filters) {
      if (!string.toLowerCase().contains(filter.toLowerCase())) {
        return false;
      }
    }",iterator
releases,"for (ContributedLibraryReleases releases : contributions) {
      if (releases.shouldContain(lib))
        row = contributions.indexOf(releases);
    }",iterator
releases,"for (ContributedLibraryReleases releases : contributions) {
      if (releases.shouldContain(lib)) {
        if (row == -1) {
          row = contributions.indexOf(releases);
          fireTableRowsInserted(row, row);
        } else {
          fireTableRowsUpdated(row, row);
        }
        return;
      }
    }",iterator
releases,"for (ContributedLibraryReleases releases : contributions) {
      if (releases.shouldContain(lib))
        row = contributions.indexOf(releases);
    }",break_loop_control
releases,"for (ContributedLibraryReleases releases : contributions) {
      if (releases.shouldContain(lib)) {
        if (row == -1) {
          row = contributions.indexOf(releases);
          fireTableRowsInserted(row, row);
        } else {
          fireTableRowsUpdated(row, row);
        }
        return;
      }
    }",break_loop_control
contribution,"for (ContributedLibraryReleases contribution : res) {
            if (!contribution.shouldContain(lib))
              continue;
            contribution.add(lib);
            return;
          }",iterator
l,"for (ContributedLibrary l : dependencies) {
        if (l.getName().equals(lib.getName()))
          continue;
        if (l.getInstalledLibrary().isPresent())
          continue;
        if (l instanceof UnavailableContributedLibrary)
          continue;
        desc += format(""- <b>{0}</b><br/>"", l.getName());
      }",iterator
type,"for (String type : types) {
      typeChooser.addItem(new DropdownLibraryOfTypeItem(type));
    }",iterator
listener,"for (FocusListener listener : filterField.getFocusListeners()) {
      listener.focusGained(new FocusEvent(filterField, FocusEvent.FOCUS_GAINED));
    }",iterator
i,"for (int i = 0; i < combo.getItemCount(); i++) {
      if (dropdownItem.equals(combo.getItemAt(i).getClass().getSimpleName())) {
        combo.setSelectedIndex(i);
        return;
      }
    }",loop_control
dropdownItem,"for (int i = 0; i < combo.getItemCount(); i++) {
      if (dropdownItem.equals(combo.getItemAt(i).getClass().getSimpleName())) {
        combo.setSelectedIndex(i);
        return;
      }
    }",break_loop_control
listener,"for (KeyListener listener : delegate.getKeyListeners()) {
      listener.keyTyped(keyEvent);
    }",iterator
listener,"for (KeyListener listener : delegate.getKeyListeners()) {
      listener.keyPressed(keyEvent);
    }",iterator
listener,"for (KeyListener listener : delegate.getKeyListeners()) {
      listener.keyReleased(keyEvent);
    }",iterator
i,"for (int i = 0; i < devices.length; i++) {
      String name = String.valueOf(i + 1);
      if (devices[i] == defaultDevice) {
        defaultIndex = i;
        name += "" (default)"";
      }
      names.add(name);
    }",loop_control
i,"for (int i = 0; i < buffer.size() - 1; ++i) {
        g.drawLine(
          (int) (i * xstep), (int) transformY(buffer.get(i), minY, rangeY, height),
          (int) ((i + 1) * xstep), (int) transformY(buffer.get(i + 1), minY, rangeY, height)
        );
      }",loop_control
g,"for(Graph g : graphs) {
        if (!g.buffer.isEmpty()) {
          minY = Math.min(g.buffer.min(), minY);
          maxY = Math.max(g.buffer.max(), maxY);
        }
      }",iterator
i,"for (int i = 0; i < ticks.getTickCount(); ++i) {
        double tick = ticks.getTick(i);
        Rectangle2D fRect = fm.getStringBounds(String.valueOf(tick), g);
        xOffset = Math.max(xOffset, (int) fRect.getWidth() + 15);

        g.setColor(boundsColor);
        // draw tick
        g.drawLine(xOffset - 5, (int) transformY(tick), xOffset + 2, (int) transformY(tick));
        // draw tick label
        g.drawString(String.valueOf(tick), xOffset - (int) fRect.getWidth() - 10, transformY(tick) - (float) fRect.getHeight() * 0.5f + fm.getAscent());
        // draw horizontal grid lines
        g.setColor(gridColor);
        g.drawLine(xOffset + 3, (int) transformY(tick), bounds.width - xPadding, (int) transformY(tick));
      }",loop_control
i,"for (int i = 0; i < ticks.getTickCount() + 1; i++) {
          String s;
          int xValue;
          int sWidth;
          Rectangle2D fBounds;
          if  (i == 0) {
              s = String.valueOf(cnt);
              fBounds = fm.getStringBounds(s, g);
              sWidth = (int)fBounds.getWidth()/2;
              xValue = xOffset;
          } else {
              s = String.valueOf((int)(xTickRange * i)+cnt);
              fBounds = fm.getStringBounds(s, g);
              sWidth = (int)fBounds.getWidth()/2;
              xValue = (int)((bounds.width - xOffset - xPadding) * ((xTickRange * i) / BUFFER_CAPACITY) + xOffset);
          }
          // draw graph x axis, ticks and labels
          g.setColor(boundsColor);
          g.drawString(s, xValue - sWidth, (int) bounds.y + (int) transformY(zeroTick) + 15);
          g.drawLine(xValue, (int)transformY(zeroTick) - 2, xValue, bounds.y + (int)transformY(zeroTick) + 5);
          // draw vertical grid lines
          g.setColor(gridColor);
          g.drawLine(xValue, (int)transformY(zeroTick) - 3, xValue, bounds.y + (int)transformY(lastTick));
      }",loop_control
i,"for(int i = 0; i < graphs.size(); ++i) {
        graphs.get(i).paint(g, xstep, minY, maxY, rangeY, bounds.height);
        if(graphs.size() > 1) {
          //draw legend rectangle
          g.fillRect(10 + legendXOffset, 10, 10, 10);
          legendXOffset += 13;
          //draw label
          g.setColor(boundsColor);
          String s = graphs.get(i).label;
          if(s != null && s.length() > 0) {
            Rectangle2D fBounds = fm.getStringBounds(s, g);
            int sWidth = (int)fBounds.getWidth();
            g.drawString(s, 10 + legendXOffset, 10 + (int)fBounds.getHeight() /2);
            legendXOffset += sWidth + 3;
          }
        }
      }",loop_control
serialRateString,"for (String serialRateString : serialRateStrings) serialRates.addItem(serialRateString + "" "" + tr(""baud""));",iterator
linebreak,"{
      int linebreak = messageBuffer.indexOf(""\n"");
      if (linebreak == -1) {
        break;
      }
      xCount++;
      String line = messageBuffer.substring(0, linebreak);
      messageBuffer.delete(0, linebreak + 1);

      line = line.trim();
      if (line.length() == 0) {
        // the line only contained trimmable characters
        continue;
      }
      String[] parts = line.split(""[, \t]+"");
      if(parts.length == 0) {
        continue;
      }

      int validParts = 0;
      int validLabels = 0;
      for(int i = 0; i < parts.length; ++i) {
        Double value = null;
        String label = null;
        
        // column formated name value pair
        if(parts[i].contains("":"")) {
          // get label
          String[] subString = parts[i].split(""[:]+"");
            
          if(subString.length > 0) {
            int labelLength = subString[0].length();
              
            if(labelLength > 32) {
                labelLength = 32;
            }
            label = subString[0].substring(0, labelLength);
          } else {
            label = """";
          }
            
          if(subString.length > 1) {
            parts[i] = subString[1];
          } else {
            parts[i] = """";
          }
        }

        try {
          value = Double.valueOf(parts[i]);
        } catch (NumberFormatException e) {
          // ignored
        }
        //CSV header
        if(label == null && value == null) {
          label = parts[i];
        }
        
        if(value != null) {
          if(validParts >= graphs.size()) {
            graphs.add(new Graph(validParts));
          }
          graphs.get(validParts).buffer.add(value);
          validParts++;
        }
        if(label != null) {
          if(validLabels >= graphs.size()) {
            graphs.add(new Graph(validLabels));
          }
          graphs.get(validLabels).label = label;
          validLabels++;
        }
        if(validParts > validLabels) validLabels = validParts;
        else if(validLabels > validParts) validParts = validLabels;
      }
    }",break_loop_control
i,"for(int i = 0; i < parts.length; ++i) {
        Double value = null;
        String label = null;
        
        // column formated name value pair
        if(parts[i].contains("":"")) {
          // get label
          String[] subString = parts[i].split(""[:]+"");
            
          if(subString.length > 0) {
            int labelLength = subString[0].length();
              
            if(labelLength > 32) {
                labelLength = 32;
            }
            label = subString[0].substring(0, labelLength);
          } else {
            label = """";
          }
            
          if(subString.length > 1) {
            parts[i] = subString[1];
          } else {
            parts[i] = """";
          }
        }

        try {
          value = Double.valueOf(parts[i]);
        } catch (NumberFormatException e) {
          // ignored
        }
        //CSV header
        if(label == null && value == null) {
          label = parts[i];
        }
        
        if(value != null) {
          if(validParts >= graphs.size()) {
            graphs.add(new Graph(validParts));
          }
          graphs.get(validParts).buffer.add(value);
          validParts++;
        }
        if(label != null) {
          if(validLabels >= graphs.size()) {
            graphs.add(new Graph(validLabels));
          }
          graphs.get(validLabels).label = label;
          validLabels++;
        }
        if(validParts > validLabels) validLabels = validParts;
        else if(validLabels > validParts) validParts = validLabels;
      }",loop_control
zipFile,"for (File zipFile : folder.listFiles((dir, name) -> name.endsWith("".zip""))) {
      ZippedTheme theme = ZippedTheme.load(namespace, zipFile);
      if (theme != null) {
        discoveredThemes.put(theme.getKey(), theme);
      }
    }",iterator
channel,"{
      while (!channel.isClosed()) {
        try {
          Thread.sleep(100);
        } catch (InterruptedException e) {
          // ignore
        }
      }
      if (connectionAttempts < MAX_CONNECTION_ATTEMPTS) {
        s = ""\n"" + tr(""Unable to connect: retrying"") + "" ("" + connectionAttempts + "")... "";

        SwingUtilities.invokeLater(new Runnable() {
          @Override
          public void run() {
            try {
              NetworkMonitor.this.tryConnect();
            } catch (JSchException e) {
              e.printStackTrace();
            } catch (IOException e) {
              e.printStackTrace();
            }
          }
        });
      } else {
        s = ""\n"" + tr(""Unable to connect: is the sketch using the bridge?"");
      }
    }",maybe_loop_control
end,"for (int end = document.getLength() - 1; end >= 0; end = start - 1) {
        Element elem = document.getParagraphElement(end);
        start = elem.getStartOffset();
        AttributeSet attrs = elem.getElement(0).getAttributes();
        AttributeSet newAttrs;
        if (attrs.isEqual(stdErrStyleOld)) {
          newAttrs = stdErrStyle;
        } else if (attrs.isEqual(stdOutStyleOld)) {
          newAttrs = stdOutStyle;
        } else {
          continue;
        }
        try {
          String text = document.getText(start, end - start);
          document.remove(start, end - start);
          document.insertString(start, text, newAttrs);
        } catch (BadLocationException e) {
          // Should only happen when text is async removed (through clear()).
          // Accept this case, but throw an error when text could mess up.
          if (document.getLength() != 0) {
            throw new Error(e);
          }
        }
      }",loop_control
m,"{
    // Separate the string into content, newlines and lone carriage
    // returns.
    //
    // Doing so allows lone CRs to move the insertPosition back to the
    // start of the line to allow overwriting the most recent line (e.g.
    // for a progress bar). Any CR or NL that are immediately followed
    // by another NL are bunched together for efficiency, since these
    // can just be inserted into the document directly and still be
    // correct.
    //
    // The regex is written so it will necessarily match any string
    // completely if applied repeatedly. This is important because any
    // part not matched would be silently dropped.
    Matcher m = newLinePattern.matcher(str);

    while (m.find()) {
      String content = m.group(1);
      String newlines = m.group(2);
      String crs = m.group(3);

      // Replace (or append if at end of the document) the content first
      int replaceLength = Math.min(content.length(), document.getLength() - insertPosition);
      document.replace(insertPosition, replaceLength, content, attributes);
      insertPosition += content.length();

      // Then insert any newlines, but always at the end of the document
      // e.g. if insertPosition is halfway a line, do not delete
      // anything, just add the newline(s) at the end).
      if (newlines != null) {
        document.insertString(document.getLength(), newlines, attributes);
        insertPosition = document.getLength();
        startOfLine = insertPosition;
      }

      // Then, for any CRs not followed by newlines, move insertPosition
      // to the start of the line. Note that if a newline follows before
      // any content in the next call to insertString, it will be added
      // at the end of the document anyway, as expected.
      if (crs != null) {
        insertPosition = startOfLine;
      }
    }
  }",maybe_loop_control
menuItem,"for (Component menuItem : toolsMenu.getMenuComponents()) {
            if (menuItem instanceof JComponent) {
              Object removeOnWindowDeactivation = ((JComponent) menuItem).getClientProperty(""removeOnWindowDeactivation"");
              if (removeOnWindowDeactivation != null && Boolean.valueOf(removeOnWindowDeactivation.toString())) {
                toolsMenuItemsToRemove.add(menuItem);
              }
            }
          }",iterator
menuItem,"for (Component menuItem : toolsMenuItemsToRemove) {
            toolsMenu.remove(menuItem);
          }",iterator
file,"for (File file : list) {
            if (sketchController.addFile(file)) {
              successful++;
            }
          }",iterator
piece,"for (String piece : pieces) {
            if (piece.startsWith(""#"")) continue;

            String path = null;
            if (piece.startsWith(""file:///"")) {
              path = piece.substring(7);
            } else if (piece.startsWith(""file:/"")) {
              path = piece.substring(5);
            }
            if (sketchController.addFile(new File(path))) {
              successful++;
            }
          }",iterator
tab,"for (EditorTab tab: tabs) {
      tab.applyPreferences();
    }",iterator
menu,"for (JMenu menu : base.getBoardsCustomMenus()) {
          if (!components.contains(menu)) {
            toolsMenu.insert(menu, numTools + offset);
            offset++;
          }
        }",iterator
recentSketchMenuItem,"for (JMenuItem recentSketchMenuItem  : base.getRecentSketchesMenuItems()) {
      recentSketchesMenu.add(recentSketchMenuItem);
    }",iterator
i,"for (int i=0; i < count; i++) {
          JMenuItem item = menu.getItem(i);

          if ((item instanceof JMenu))
            item = getSelectedItemRecursive((JMenu)item);

          if (item != null && item.isSelected())
            return item;
        }",loop_control
item,"{
    toolsMenu = new JMenu(tr(""Tools""));
    toolsMenu.setMnemonic(KeyEvent.VK_T);

    addInternalTools(toolsMenu);

    JMenuItem item = newJMenuItemShift(tr(""Manage Libraries...""), 'I');
    item.addActionListener(e -> base.openLibraryManager("""", """"));
    toolsMenu.add(item);

    item = newJMenuItemShift(tr(""Serial Monitor""), 'M');
    item.addActionListener(e -> handleSerial());
    toolsMenu.add(item);

    item = newJMenuItemShift(tr(""Serial Plotter""), 'L');
    item.addActionListener(e -> handlePlotter());
    toolsMenu.add(item);

    addTools(toolsMenu, BaseNoGui.getToolsFolder());
    File sketchbookTools = new File(BaseNoGui.getSketchbookFolder(), ""tools"");
    addTools(toolsMenu, sketchbookTools);

    toolsMenu.addSeparator();

    numTools = toolsMenu.getItemCount();

    // XXX: DAM: these should probably be implemented using the Tools plugin
    // API, if possible (i.e. if it supports custom actions, etc.)

    base.getBoardsCustomMenus().stream().forEach(toolsMenu::add);

    if (portMenu == null)
      portMenu = new JMenu(tr(""Port""));
    populatePortMenu();
    toolsMenu.add(portMenu);
    MenuScroller.setScrollerFor(portMenu);
    item = new JMenuItem(tr(""Get Board Info""));
    item.addActionListener(e -> handleBoardInfo());
    toolsMenu.add(item);
    toolsMenu.addSeparator();

    base.rebuildProgrammerMenu();
    programmersMenu = new JMenu(tr(""Programmer""));
    MenuScroller.setScrollerFor(programmersMenu);
    base.getProgrammerMenus().stream().forEach(programmersMenu::add);
    toolsMenu.add(programmersMenu);

    item = new JMenuItem(tr(""Burn Bootloader""));
    item.addActionListener(e -> handleBurnBootloader());
    toolsMenu.add(item);

    toolsMenu.addMenuListener(new StubMenuListener() {
      public JMenuItem getSelectedItemRecursive(JMenu menu) {
        int count = menu.getItemCount();
        for (int i=0; i < count; i++) {
          JMenuItem item = menu.getItem(i);

          if ((item instanceof JMenu))
            item = getSelectedItemRecursive((JMenu)item);

          if (item != null && item.isSelected())
            return item;
        }
        return null;
      }

      public void menuSelected(MenuEvent e) {
        //System.out.println(""Tools menu selected."");
        populatePortMenu();
        for (Component c : toolsMenu.getMenuComponents()) {
          if ((c instanceof JMenu) && c.isVisible()) {
            JMenu menu = (JMenu)c;
            String name = menu.getText();
            if (name == null) continue;
            String basename = name;
            int index = name.indexOf(':');
            if (index > 0) basename = name.substring(0, index);

            JMenuItem item = getSelectedItemRecursive(menu);
            String sel = item != null ? item.getText() : null;
            if (sel == null) {
              if (!name.equals(basename)) menu.setText(basename);
            } else {
              if (sel.length() > 50) sel = sel.substring(0, 50) + ""..."";
              String newname = basename + "": \"""" + sel + ""\"""";
              if (!name.equals(newname)) menu.setText(newname);
            }
          }
        }
      }
    });

    return toolsMenu;
  }",break_loop_control
c,"for (Component c : toolsMenu.getMenuComponents()) {
          if ((c instanceof JMenu) && c.isVisible()) {
            JMenu menu = (JMenu)c;
            String name = menu.getText();
            if (name == null) continue;
            String basename = name;
            int index = name.indexOf(':');
            if (index > 0) basename = name.substring(0, index);

            JMenuItem item = getSelectedItemRecursive(menu);
            String sel = item != null ? item.getText() : null;
            if (sel == null) {
              if (!name.equals(basename)) menu.setText(basename);
            } else {
              if (sel.length() > 50) sel = sel.substring(0, 50) + ""..."";
              String newname = basename + "": \"""" + sel + ""\"""";
              if (!name.equals(newname)) menu.setText(newname);
            }
          }
        }",iterator
folder,"{
      public boolean accept(File folder) {
        if (folder.isDirectory()) {
          //System.out.println(""checking "" + folder);
          File subfolder = new File(folder, ""tool"");
          return subfolder.exists();
        }
        return false;
      }
    }",iterator
folder,"for (File folder : folders) {
      File toolDirectory = new File(folder, ""tool"");

      try {
        // add dir to classpath for .classes
        //urlList.add(toolDirectory.toURL());

        // add .jar files to classpath
        File[] archives = toolDirectory.listFiles(new FilenameFilter() {
          public boolean accept(File dir, String name) {
            return (name.toLowerCase().endsWith("".jar"") ||
              name.toLowerCase().endsWith("".zip""));
          }
        });

        URL[] urlList = new URL[archives.length];
        for (int j = 0; j < urlList.length; j++) {
          urlList[j] = archives[j].toURI().toURL();
        }
        URLClassLoader loader = new URLClassLoader(urlList);

        String className = null;
        for (File archive : archives) {
          className = findClassInZipFile(folder.getName(), archive);
          if (className != null) break;
        }

        /*
        // Alternatively, could use manifest files with special attributes:
        // http://java.sun.com/j2se/1.3/docs/guide/jar/jar.html
        // Example code for loading from a manifest file:
        // http://forums.sun.com/thread.jspa?messageID=3791501
        File infoFile = new File(toolDirectory, ""tool.txt"");
        if (!infoFile.exists()) continue;

        String[] info = PApplet.loadStrings(infoFile);
        //Main-Class: org.poo.shoe.AwesomerTool
        //String className = folders[i].getName();
        String className = null;
        for (int k = 0; k < info.length; k++) {
          if (info[k].startsWith("";"")) continue;

          String[] pieces = PApplet.splitTokens(info[k], "": "");
          if (pieces.length == 2) {
            if (pieces[0].equals(""Main-Class"")) {
              className = pieces[1];
            }
          }
        }
        */
        // If no class name found, just move on.
        if (className == null) continue;

        Class<?> toolClass = Class.forName(className, true, loader);
        final Tool tool = (Tool) toolClass.newInstance();

        tool.init(Editor.this);

        String title = tool.getMenuTitle();
        JMenuItem item = new JMenuItem(title);
        item.addActionListener(event -> {
          SwingUtilities.invokeLater(tool);
          //new Thread(tool).start();
        });
        //menu.add(item);
        toolItems.put(title, item);

      } catch (Exception e) {
        e.printStackTrace();
      }
    }",iterator
j,"for (int j = 0; j < urlList.length; j++) {
          urlList[j] = archives[j].toURI().toURL();
        }",loop_control
archive,"for (File archive : archives) {
          className = findClassInZipFile(folder.getName(), archive);
          if (className != null) break;
        }",iterator
className,"{
        // add dir to classpath for .classes
        //urlList.add(toolDirectory.toURL());

        // add .jar files to classpath
        File[] archives = toolDirectory.listFiles(new FilenameFilter() {
          public boolean accept(File dir, String name) {
            return (name.toLowerCase().endsWith("".jar"") ||
              name.toLowerCase().endsWith("".zip""));
          }
        });

        URL[] urlList = new URL[archives.length];
        for (int j = 0; j < urlList.length; j++) {
          urlList[j] = archives[j].toURI().toURL();
        }
        URLClassLoader loader = new URLClassLoader(urlList);

        String className = null;
        for (File archive : archives) {
          className = findClassInZipFile(folder.getName(), archive);
          if (className != null) break;
        }

        /*
        // Alternatively, could use manifest files with special attributes:
        // http://java.sun.com/j2se/1.3/docs/guide/jar/jar.html
        // Example code for loading from a manifest file:
        // http://forums.sun.com/thread.jspa?messageID=3791501
        File infoFile = new File(toolDirectory, ""tool.txt"");
        if (!infoFile.exists()) continue;

        String[] info = PApplet.loadStrings(infoFile);
        //Main-Class: org.poo.shoe.AwesomerTool
        //String className = folders[i].getName();
        String className = null;
        for (int k = 0; k < info.length; k++) {
          if (info[k].startsWith("";"")) continue;

          String[] pieces = PApplet.splitTokens(info[k], "": "");
          if (pieces.length == 2) {
            if (pieces[0].equals(""Main-Class"")) {
              className = pieces[1];
            }
          }
        }
        */
        // If no class name found, just move on.
        if (className == null) continue;

        Class<?> toolClass = Class.forName(className, true, loader);
        final Tool tool = (Tool) toolClass.newInstance();

        tool.init(Editor.this);

        String title = tool.getMenuTitle();
        JMenuItem item = new JMenuItem(title);
        item.addActionListener(event -> {
          SwingUtilities.invokeLater(tool);
          //new Thread(tool).start();
        });
        //menu.add(item);
        toolItems.put(title, item);

      }",break_loop_control
title,"{
        // add dir to classpath for .classes
        //urlList.add(toolDirectory.toURL());

        // add .jar files to classpath
        File[] archives = toolDirectory.listFiles(new FilenameFilter() {
          public boolean accept(File dir, String name) {
            return (name.toLowerCase().endsWith("".jar"") ||
              name.toLowerCase().endsWith("".zip""));
          }
        });

        URL[] urlList = new URL[archives.length];
        for (int j = 0; j < urlList.length; j++) {
          urlList[j] = archives[j].toURI().toURL();
        }
        URLClassLoader loader = new URLClassLoader(urlList);

        String className = null;
        for (File archive : archives) {
          className = findClassInZipFile(folder.getName(), archive);
          if (className != null) break;
        }

        /*
        // Alternatively, could use manifest files with special attributes:
        // http://java.sun.com/j2se/1.3/docs/guide/jar/jar.html
        // Example code for loading from a manifest file:
        // http://forums.sun.com/thread.jspa?messageID=3791501
        File infoFile = new File(toolDirectory, ""tool.txt"");
        if (!infoFile.exists()) continue;

        String[] info = PApplet.loadStrings(infoFile);
        //Main-Class: org.poo.shoe.AwesomerTool
        //String className = folders[i].getName();
        String className = null;
        for (int k = 0; k < info.length; k++) {
          if (info[k].startsWith("";"")) continue;

          String[] pieces = PApplet.splitTokens(info[k], "": "");
          if (pieces.length == 2) {
            if (pieces[0].equals(""Main-Class"")) {
              className = pieces[1];
            }
          }
        }
        */
        // If no class name found, just move on.
        if (className == null) continue;

        Class<?> toolClass = Class.forName(className, true, loader);
        final Tool tool = (Tool) toolClass.newInstance();

        tool.init(Editor.this);

        String title = tool.getMenuTitle();
        JMenuItem item = new JMenuItem(title);
        item.addActionListener(event -> {
          SwingUtilities.invokeLater(tool);
          //new Thread(tool).start();
        });
        //menu.add(item);
        toolItems.put(title, item);

      }",iterator
title,"for (String title : toolList) {
      menu.add(toolItems.get(title));
    }",iterator
entries,"{
      zipFile = new ZipFile(file);
      Enumeration<?> entries = zipFile.entries();
      while (entries.hasMoreElements()) {
        ZipEntry entry = (ZipEntry) entries.nextElement();

        if (!entry.isDirectory()) {
          String name = entry.getName();
          //System.out.println(""entry: "" + name);

          if (name.endsWith(classFileName)) {
            //int slash = name.lastIndexOf('/');
            //String packageName = (slash == -1) ? """" : name.substring(0, slash);
            // Remove .class and convert slashes to periods.
            return name.substring(0, name.length() - 6).replace('/', '.');
          }
        }
      }
    }",maybe_loop_control
entry,"{
        ZipEntry entry = (ZipEntry) entries.nextElement();

        if (!entry.isDirectory()) {
          String name = entry.getName();
          //System.out.println(""entry: "" + name);

          if (name.endsWith(classFileName)) {
            //int slash = name.lastIndexOf('/');
            //String packageName = (slash == -1) ? """" : name.substring(0, slash);
            // Remove .class and convert slashes to periods.
            return name.substring(0, name.length() - 6).replace('/', '.');
          }
        }
      }",break_loop_control
name,"{
          String name = entry.getName();
          //System.out.println(""entry: "" + name);

          if (name.endsWith(classFileName)) {
            //int slash = name.lastIndexOf('/');
            //String packageName = (slash == -1) ? """" : name.substring(0, slash);
            // Remove .class and convert slashes to periods.
            return name.substring(0, name.length() - 6).replace('/', '.');
          }
        }",break_loop_control
tab,"for (EditorTab tab : tabs)
      tab.updateKeywords(keywords);",iterator
i,"for (int i = 0; i < portMenu.getItemCount(); i++) {
      JMenuItem menuItem = portMenu.getItem(i);
      if (!(menuItem instanceof JCheckBoxMenuItem)) {
        continue;
      }
      JCheckBoxMenuItem checkBoxMenuItem = ((JCheckBoxMenuItem) menuItem);
      checkBoxMenuItem.setState(false);
      if (name.equals(checkBoxMenuItem.getText())) selection = checkBoxMenuItem;
    }",loop_control
port,"{
    final List<String> PROTOCOLS_ORDER = Arrays.asList(""serial"", ""network"");
    final List<String> PROTOCOLS_LABELS = Arrays.asList(tr(""Serial ports""), tr(""Network ports""));

    portMenu.removeAll();

    String selectedPort = PreferencesData.get(""serial.port"");

    List<BoardPort> ports = Base.getDiscoveryManager().discovery();

    ports = platform.filterPorts(ports, PreferencesData.getBoolean(""serial.ports.showall""));

    ports.stream() //
        .filter(port -> port.getProtocolLabel() == null || port.getProtocolLabel().isEmpty())
        .forEach(port -> {
          int labelIdx = PROTOCOLS_ORDER.indexOf(port.getProtocol());
          if (labelIdx != -1) {
            port.setProtocolLabel(PROTOCOLS_LABELS.get(labelIdx));
          } else {
            port.setProtocolLabel(port.getProtocol());
          }
        });

    Collections.sort(ports, (port1, port2) -> {
      String pr1 = port1.getProtocol();
      String pr2 = port2.getProtocol();
      int prIdx1 = PROTOCOLS_ORDER.contains(pr1) ? PROTOCOLS_ORDER.indexOf(pr1) : 999;
      int prIdx2 = PROTOCOLS_ORDER.contains(pr2) ? PROTOCOLS_ORDER.indexOf(pr2) : 999;
      int r = prIdx1 - prIdx2;
      if (r != 0)
        return r;
      r = port1.getProtocolLabel().compareTo(port2.getProtocolLabel());
      if (r != 0)
        return r;
      return port1.getAddress().compareTo(port2.getAddress());
    });

    String lastProtocol = """";
    String lastProtocolLabel = """";
    for (BoardPort port : ports) {
      if (!port.getProtocol().equals(lastProtocol) || !port.getProtocolLabel().equals(lastProtocolLabel)) {
        if (!lastProtocol.isEmpty()) {
          portMenu.addSeparator();
        }
        lastProtocol = port.getProtocol();
        lastProtocolLabel = port.getProtocolLabel();
        JMenuItem item = new JMenuItem(tr(lastProtocolLabel));
        item.setEnabled(false);
        portMenu.add(item);
      }
      String address = port.getAddress();

      BoardPortJCheckBoxMenuItem item = new BoardPortJCheckBoxMenuItem(port);
      item.setSelected(address.equals(selectedPort));
      portMenu.add(item);
    }

    portMenu.setEnabled(portMenu.getMenuComponentCount() > 0);
  }",iterator
i,"for (int i = 0; i < tabs.size(); ++i) {
      if (tabs.get(i).getSketchFile() == file)
        return i;
    }",loop_control
i,"for (int i = 0; i < tabs.size(); ++i) {
      if (tabs.get(i).getSketchFile().getFile().equals(file))
        return i;
    }",loop_control
file,"for (SketchFile file : sketch.getFiles()) {
      try {
        addTab(file, null);
      } catch(IOException e) {
        // TODO: Improve / move error handling
        System.err.println(e);
      }
    }",iterator
i,for (int i = 0; i < 10; i++) System.out.println();,loop_control
tab,"for (EditorTab tab : tabs)
      tab.getTextArea().removeAllLineHighlights();",iterator
i,"for (int i = 0; i < foldManager.getFoldCount(); i++) {
        if (foldManager.getFold(i).containsLine(line)) {
          foldManager.getFold(i).setCollapsed(false);
        }
      }",loop_control
i,"for (int i = 0; i < portMenu.getItemCount(); i++) {
      if (portMenu.getItem(i) instanceof BoardPortJCheckBoxMenuItem)
        items.add((BoardPortJCheckBoxMenuItem) portMenu.getItem(i));
    }",loop_control
boardPort,"{
      try {
        Thread.sleep(200);
      } catch (InterruptedException e) {
          // noop
      }
      BoardPort boardPort = BaseNoGui.getDiscoveryManager().find(PreferencesData.get(""serial.port""));
      long sleptFor = 0;
      while (boardPort == null && sleptFor < MAX_TIME_AWAITING_FOR_RESUMING_SERIAL_MONITOR) {
        try {
          Thread.sleep(100);
          sleptFor += 100;
          boardPort = BaseNoGui.getDiscoveryManager().find(PreferencesData.get(""serial.port""));
        } catch (InterruptedException e) {
          // noop
        }
      }
      try {
        if (serialMonitor != null) {
          serialMonitor.resume(boardPort);
          if (boardPort == null) {
            serialMonitor.close();
            handleSerial();
          } else {
            serialMonitor.resume(boardPort);
          }
        }
      } catch (Exception e) {
        statusError(e);
      }
   }",maybe_loop_control
sleptFor,"{
      try {
        Thread.sleep(200);
      } catch (InterruptedException e) {
          // noop
      }
      BoardPort boardPort = BaseNoGui.getDiscoveryManager().find(PreferencesData.get(""serial.port""));
      long sleptFor = 0;
      while (boardPort == null && sleptFor < MAX_TIME_AWAITING_FOR_RESUMING_SERIAL_MONITOR) {
        try {
          Thread.sleep(100);
          sleptFor += 100;
          boardPort = BaseNoGui.getDiscoveryManager().find(PreferencesData.get(""serial.port""));
        } catch (InterruptedException e) {
          // noop
        }
      }
      try {
        if (serialMonitor != null) {
          serialMonitor.resume(boardPort);
          if (boardPort == null) {
            serialMonitor.close();
            handleSerial();
          } else {
            serialMonitor.resume(boardPort);
          }
        }
      } catch (Exception e) {
        statusError(e);
      }
   }",maybe_loop_control
serialMonitor,"{
    if(serialPlotter != null) {
      if(serialPlotter.isClosed()) {
        serialPlotter = null;
      } else {
        statusError(tr(""Serial monitor not available while plotter is open""));
        return;
      }
    }

    if (serialMonitor != null) {
      // The serial monitor already exists

      if (serialMonitor.isClosed()) {
        serialMonitor.dispose();
        // If it's closed, clear the refrence to the existing
        // monitor and create a new one
        serialMonitor = null;
      }
      else {
        // If it's not closed, give it the focus
        try {
          serialMonitor.toFront();
          serialMonitor.requestFocus();
          return;
        } catch (Exception e) {
          // noop
        }
      }
    }

    BoardPort port = Base.getDiscoveryManager().find(PreferencesData.get(""serial.port""));

    if (port == null) {
      statusError(I18n.format(tr(""Board at {0} is not available""), PreferencesData.get(""serial.port"")));
      return;
    }

    serialMonitor = new MonitorFactory().newMonitor(port);

    if (serialMonitor == null) {
      String board = port.getPrefs().get(""board"");
      String boardName = BaseNoGui.getPlatform().resolveDeviceByBoardID(BaseNoGui.packages, board);
      statusError(I18n.format(tr(""Serial monitor is not supported on network ports such as {0} for the {1} in this release""), PreferencesData.get(""serial.port""), boardName));
      return;
    }

    base.addEditorFontResizeListeners(serialMonitor);
    Base.setIcon(serialMonitor);

    // If currently uploading, disable the monitor (it will be later
    // enabled when done uploading)
    if (uploading || avoidMultipleOperations) {
      try {
        serialMonitor.suspend();
      } catch (Exception e) {
        statusError(e);
      }
    }

    boolean success = false;
    do {
      if (serialMonitor.requiresAuthorization() && !PreferencesData.has(serialMonitor.getAuthorizationKey())) {
        PasswordAuthorizationDialog dialog = new PasswordAuthorizationDialog(this, tr(""Type board password to access its console""));
        dialog.setLocationRelativeTo(this);
        dialog.setVisible(true);

        if (dialog.isCancelled()) {
          statusNotice(tr(""Unable to open serial monitor""));
          return;
        }

        PreferencesData.set(serialMonitor.getAuthorizationKey(), dialog.getPassword());
      }

      try {
        if (!avoidMultipleOperations) {
          serialMonitor.open();
        }
        serialMonitor.setVisible(true);
        success = true;
        statusEmpty();
      } catch (ConnectException e) {
        statusError(tr(""Unable to connect: is the sketch using the bridge?""));
      } catch (JSchException e) {
        statusError(tr(""Unable to connect: wrong password?""));
      } catch (SerialException e) {
        String errorMessage = e.getMessage();
        if (e.getCause() != null && e.getCause() instanceof SerialPortException) {
          errorMessage += "" ("" + ((SerialPortException) e.getCause()).getExceptionType() + "")"";
        }
        serialMonitor = null;
        statusError(errorMessage);
        try {
          serialMonitor.close();
        } catch (Exception e1) {
          // noop
        }
      } catch (Exception e) {
        statusError(e);
      } finally {
        if (serialMonitor != null && serialMonitor.requiresAuthorization() && !success) {
          PreferencesData.remove(serialMonitor.getAuthorizationKey());
        }
      }

    } while (serialMonitor != null && serialMonitor.requiresAuthorization() && !success);

  }",maybe_loop_control
success,"{
    if(serialPlotter != null) {
      if(serialPlotter.isClosed()) {
        serialPlotter = null;
      } else {
        statusError(tr(""Serial monitor not available while plotter is open""));
        return;
      }
    }

    if (serialMonitor != null) {
      // The serial monitor already exists

      if (serialMonitor.isClosed()) {
        serialMonitor.dispose();
        // If it's closed, clear the refrence to the existing
        // monitor and create a new one
        serialMonitor = null;
      }
      else {
        // If it's not closed, give it the focus
        try {
          serialMonitor.toFront();
          serialMonitor.requestFocus();
          return;
        } catch (Exception e) {
          // noop
        }
      }
    }

    BoardPort port = Base.getDiscoveryManager().find(PreferencesData.get(""serial.port""));

    if (port == null) {
      statusError(I18n.format(tr(""Board at {0} is not available""), PreferencesData.get(""serial.port"")));
      return;
    }

    serialMonitor = new MonitorFactory().newMonitor(port);

    if (serialMonitor == null) {
      String board = port.getPrefs().get(""board"");
      String boardName = BaseNoGui.getPlatform().resolveDeviceByBoardID(BaseNoGui.packages, board);
      statusError(I18n.format(tr(""Serial monitor is not supported on network ports such as {0} for the {1} in this release""), PreferencesData.get(""serial.port""), boardName));
      return;
    }

    base.addEditorFontResizeListeners(serialMonitor);
    Base.setIcon(serialMonitor);

    // If currently uploading, disable the monitor (it will be later
    // enabled when done uploading)
    if (uploading || avoidMultipleOperations) {
      try {
        serialMonitor.suspend();
      } catch (Exception e) {
        statusError(e);
      }
    }

    boolean success = false;
    do {
      if (serialMonitor.requiresAuthorization() && !PreferencesData.has(serialMonitor.getAuthorizationKey())) {
        PasswordAuthorizationDialog dialog = new PasswordAuthorizationDialog(this, tr(""Type board password to access its console""));
        dialog.setLocationRelativeTo(this);
        dialog.setVisible(true);

        if (dialog.isCancelled()) {
          statusNotice(tr(""Unable to open serial monitor""));
          return;
        }

        PreferencesData.set(serialMonitor.getAuthorizationKey(), dialog.getPassword());
      }

      try {
        if (!avoidMultipleOperations) {
          serialMonitor.open();
        }
        serialMonitor.setVisible(true);
        success = true;
        statusEmpty();
      } catch (ConnectException e) {
        statusError(tr(""Unable to connect: is the sketch using the bridge?""));
      } catch (JSchException e) {
        statusError(tr(""Unable to connect: wrong password?""));
      } catch (SerialException e) {
        String errorMessage = e.getMessage();
        if (e.getCause() != null && e.getCause() instanceof SerialPortException) {
          errorMessage += "" ("" + ((SerialPortException) e.getCause()).getExceptionType() + "")"";
        }
        serialMonitor = null;
        statusError(errorMessage);
        try {
          serialMonitor.close();
        } catch (Exception e1) {
          // noop
        }
      } catch (Exception e) {
        statusError(e);
      } finally {
        if (serialMonitor != null && serialMonitor.requiresAuthorization() && !success) {
          PreferencesData.remove(serialMonitor.getAuthorizationKey());
        }
      }

    } while (serialMonitor != null && serialMonitor.requiresAuthorization() && !success);

  }",maybe_loop_control
serialPlotter,"{
    if(serialMonitor != null) {
      if(serialMonitor.isClosed()) {
        serialMonitor = null;
      } else {
        statusError(tr(""Plotter not available while serial monitor is open""));
        return;
      }
    }

    if (serialPlotter != null) {
      // The serial plotter already exists

      if (serialPlotter.isClosed()) {
        // If it's closed, clear the refrence to the existing
        // plotter and create a new one
        serialPlotter.dispose();
        serialPlotter = null;
      }
      else {
        // If it's not closed, give it the focus
        try {
          serialPlotter.toFront();
          serialPlotter.requestFocus();
          return;
        } catch (Exception e) {
          // noop
        }
      }
    }

    BoardPort port = Base.getDiscoveryManager().find(PreferencesData.get(""serial.port""));

    if (port == null) {
      statusError(I18n.format(tr(""Board at {0} is not available""), PreferencesData.get(""serial.port"")));
      return;
    }

    serialPlotter = new SerialPlotter(port);
    Base.setIcon(serialPlotter);

    // If currently uploading, disable the plotter (it will be later
    // enabled when done uploading)
    if (uploading) {
      try {
        serialPlotter.suspend();
      } catch (Exception e) {
        statusError(e);
      }
    }

    boolean success = false;
    do {
      if (serialPlotter.requiresAuthorization() && !PreferencesData.has(serialPlotter.getAuthorizationKey())) {
        PasswordAuthorizationDialog dialog = new PasswordAuthorizationDialog(this, tr(""Type board password to access its console""));
        dialog.setLocationRelativeTo(this);
        dialog.setVisible(true);

        if (dialog.isCancelled()) {
          statusNotice(tr(""Unable to open serial plotter""));
          return;
        }

        PreferencesData.set(serialPlotter.getAuthorizationKey(), dialog.getPassword());
      }

      try {
        serialPlotter.open();
        serialPlotter.setVisible(true);
        success = true;
        statusEmpty();
      } catch (ConnectException e) {
        statusError(tr(""Unable to connect: is the sketch using the bridge?""));
      } catch (JSchException e) {
        statusError(tr(""Unable to connect: wrong password?""));
      } catch (SerialException e) {
        String errorMessage = e.getMessage();
        if (e.getCause() != null && e.getCause() instanceof SerialPortException) {
          errorMessage += "" ("" + ((SerialPortException) e.getCause()).getExceptionType() + "")"";
        }
        statusError(errorMessage);
        serialPlotter = null;
      } catch (Exception e) {
        statusError(e);
      } finally {
        if (serialPlotter != null && serialPlotter.requiresAuthorization() && !success) {
          PreferencesData.remove(serialPlotter.getAuthorizationKey());
        }
      }

    } while (serialPlotter != null && serialPlotter.requiresAuthorization() && !success);

  }",maybe_loop_control
success,"{
    if(serialMonitor != null) {
      if(serialMonitor.isClosed()) {
        serialMonitor = null;
      } else {
        statusError(tr(""Plotter not available while serial monitor is open""));
        return;
      }
    }

    if (serialPlotter != null) {
      // The serial plotter already exists

      if (serialPlotter.isClosed()) {
        // If it's closed, clear the refrence to the existing
        // plotter and create a new one
        serialPlotter.dispose();
        serialPlotter = null;
      }
      else {
        // If it's not closed, give it the focus
        try {
          serialPlotter.toFront();
          serialPlotter.requestFocus();
          return;
        } catch (Exception e) {
          // noop
        }
      }
    }

    BoardPort port = Base.getDiscoveryManager().find(PreferencesData.get(""serial.port""));

    if (port == null) {
      statusError(I18n.format(tr(""Board at {0} is not available""), PreferencesData.get(""serial.port"")));
      return;
    }

    serialPlotter = new SerialPlotter(port);
    Base.setIcon(serialPlotter);

    // If currently uploading, disable the plotter (it will be later
    // enabled when done uploading)
    if (uploading) {
      try {
        serialPlotter.suspend();
      } catch (Exception e) {
        statusError(e);
      }
    }

    boolean success = false;
    do {
      if (serialPlotter.requiresAuthorization() && !PreferencesData.has(serialPlotter.getAuthorizationKey())) {
        PasswordAuthorizationDialog dialog = new PasswordAuthorizationDialog(this, tr(""Type board password to access its console""));
        dialog.setLocationRelativeTo(this);
        dialog.setVisible(true);

        if (dialog.isCancelled()) {
          statusNotice(tr(""Unable to open serial plotter""));
          return;
        }

        PreferencesData.set(serialPlotter.getAuthorizationKey(), dialog.getPassword());
      }

      try {
        serialPlotter.open();
        serialPlotter.setVisible(true);
        success = true;
        statusEmpty();
      } catch (ConnectException e) {
        statusError(tr(""Unable to connect: is the sketch using the bridge?""));
      } catch (JSchException e) {
        statusError(tr(""Unable to connect: wrong password?""));
      } catch (SerialException e) {
        String errorMessage = e.getMessage();
        if (e.getCause() != null && e.getCause() instanceof SerialPortException) {
          errorMessage += "" ("" + ((SerialPortException) e.getCause()).getExceptionType() + "")"";
        }
        statusError(errorMessage);
        serialPlotter = null;
      } catch (Exception e) {
        statusError(e);
      } finally {
        if (serialPlotter != null && serialPlotter.requiresAuthorization() && !success) {
          PreferencesData.remove(serialPlotter.getAuthorizationKey());
        }
      }

    } while (serialPlotter != null && serialPlotter.requiresAuthorization() && !success);

  }",maybe_loop_control
port,"for (BoardPort port : ports) {
      if (port.getAddress().equals(selectedPort)) {
        label = port.getBoardName();
        vid = port.getPrefs().get(""vid"");
        pid = port.getPrefs().get(""pid"");
        iserial = port.getPrefs().get(""iserial"");
        protocol = port.getProtocol();
        found = true;
        break;
      }
    }",iterator
port,"for (BoardPort port : ports) {
      if (port.getAddress().equals(selectedPort)) {
        label = port.getBoardName();
        vid = port.getPrefs().get(""vid"");
        pid = port.getPrefs().get(""pid"");
        iserial = port.getPrefs().get(""iserial"");
        protocol = port.getProtocol();
        found = true;
        break;
      }
    }",break_loop_control
i,"for (int i = 0; i < BUTTON_COUNT; i++) {
      final int selection = i;
      
      // add spacers before NEW and SERIAL buttons
      if (i == NEW) {
        touchBar.addItem(new TouchBarItem(TouchBarItem.NSTouchBarItemIdentifierFixedSpaceSmall));
      } else if (i == SERIAL) {
        touchBar.addItem(new TouchBarItem(TouchBarItem.NSTouchBarItemIdentifierFlexibleSpace));
      }
      
      touchBarButtons[i] = new TouchBarButton();
      touchBarButtons[i].setImage(touchBarImages[i][ROLLOVER]);
      touchBarButtons[i].setAction(event -> {
        // Run event handler later to prevent hanging if a dialog needs to be open
        EventQueue.invokeLater(new Runnable() {
          @Override
          public void run() {
            handleSelectionPressed(selection);
          }
        });
      });
      
      TouchBarItem touchBarItem = new TouchBarItem(title[i], touchBarButtons[i], true);
      touchBarItem.setCustomizationLabel(title[i]);
      
      touchBar.addItem(touchBarItem);
    }",loop_control
i,"for (int i = 0; i < BUTTON_COUNT; i++) {
      for (int state = 0; state < 3; state++) {
        Image image = createImage(BUTTON_WIDTH, BUTTON_HEIGHT);
        Graphics g = image.getGraphics();
        g.setColor(bgcolor);
        g.fillRect(0, 0, BUTTON_WIDTH, BUTTON_HEIGHT);
        int offset = (BUTTON_IMAGE_SIZE - BUTTON_WIDTH) / 2;
        g.drawImage(allButtons, -(i * BUTTON_IMAGE_SIZE) - offset,
                    (-2 + state) * BUTTON_IMAGE_SIZE, null);
        buttonImages[i][state] = image;
      }
    }",loop_control
state,"for (int state = 0; state < 3; state++) {
        Image image = createImage(BUTTON_WIDTH, BUTTON_HEIGHT);
        Graphics g = image.getGraphics();
        g.setColor(bgcolor);
        g.fillRect(0, 0, BUTTON_WIDTH, BUTTON_HEIGHT);
        int offset = (BUTTON_IMAGE_SIZE - BUTTON_WIDTH) / 2;
        g.drawImage(allButtons, -(i * BUTTON_IMAGE_SIZE) - offset,
                    (-2 + state) * BUTTON_IMAGE_SIZE, null);
        buttonImages[i][state] = image;
      }",loop_control
i,"for (int i = 0; i < BUTTON_COUNT; i++) {
      for (int state = 0; state < 3; state++) {
        BufferedImage image = new BufferedImage(BUTTON_WIDTH * 2, BUTTON_HEIGHT * 2, 
                                                BufferedImage.TYPE_INT_ARGB);
        Graphics g = image.getGraphics();

        int offset = (BUTTON_IMAGE_SIZE * 2 - BUTTON_WIDTH * 2) / 2;
        g.drawImage(allButtonsRetina, -(i * BUTTON_IMAGE_SIZE * 2) - offset,
                    (-2 + state) * BUTTON_IMAGE_SIZE * 2, null);        
        
        // convert the image to a PNG to display on the touch bar
        ByteArrayOutputStream pngStream = new ByteArrayOutputStream();
        
        try {
          ImageIO.write(image, ""PNG"", pngStream);

          touchBarImages[i][state] = new com.thizzer.jtouchbar.common.Image(pngStream.toByteArray());
        } catch (IOException e) {
          // ignore errors
        }
      }
    }",loop_control
state,"for (int state = 0; state < 3; state++) {
        BufferedImage image = new BufferedImage(BUTTON_WIDTH * 2, BUTTON_HEIGHT * 2, 
                                                BufferedImage.TYPE_INT_ARGB);
        Graphics g = image.getGraphics();

        int offset = (BUTTON_IMAGE_SIZE * 2 - BUTTON_WIDTH * 2) / 2;
        g.drawImage(allButtonsRetina, -(i * BUTTON_IMAGE_SIZE * 2) - offset,
                    (-2 + state) * BUTTON_IMAGE_SIZE * 2, null);        
        
        // convert the image to a PNG to display on the touch bar
        ByteArrayOutputStream pngStream = new ByteArrayOutputStream();
        
        try {
          ImageIO.write(image, ""PNG"", pngStream);

          touchBarImages[i][state] = new com.thizzer.jtouchbar.common.Image(pngStream.toByteArray());
        } catch (IOException e) {
          // ignore errors
        }
      }",loop_control
i,"for (int i = 0; i < buttonCount; i++) {
        setState(i, INACTIVE, false);
      }",loop_control
i,"for (int i = 0; i < buttonCount; i++) {
        x1[i] = offsetX;
        if (i == 2 || i == 6) x1[i] += BUTTON_GAP;
        x2[i] = x1[i] + BUTTON_WIDTH;
        offsetX = x2[i];
      }",loop_control
i,"for (int i = 0; i < buttonCount; i++) {
      g.drawImage(stateImage[i], x1[i], y1, null);
    }",loop_control
i,"for (int i = 0; i < buttonCount; i++) {
      if ((y > y1) && (x > x1[i]) &&
        (y < y2) && (x < x2[i])) {
        //System.out.println(""sel is "" + i);
        return i;
      }
    }",loop_control
y,"for (int i = 0; i < buttonCount; i++) {
      if ((y > y1) && (x > x1[i]) &&
        (y < y2) && (x < x2[i])) {
        //System.out.println(""sel is "" + i);
        return i;
      }
    }",break_loop_control
x,"for (int i = 0; i < buttonCount; i++) {
      if ((y > y1) && (x > x1[i]) &&
        (y < y2) && (x < x2[i])) {
        //System.out.println(""sel is "" + i);
        return i;
      }
    }",break_loop_control
tmp,"{
      int current = textarea.getCaretPosition();
      int startOffset = 0;
      int endIndex = current;
      String tmp = textarea.getDocument().getText(current, 1);
      // TODO probably a regexp that matches Arduino lang special chars
      // already exists.
      String regexp = ""[\\s\\n();\\\\.!='\\[\\]{}]"";

      while (!tmp.matches(regexp)) {
        endIndex++;
        tmp = textarea.getDocument().getText(endIndex, 1);
      }
      // For some reason document index start at 2.
      // if( current - start < 2 ) return;

      tmp = """";
      while (!tmp.matches(regexp)) {
        startOffset++;
        if (current - startOffset < 0) {
          tmp = textarea.getDocument().getText(0, 1);
          break;
        } else
          tmp = textarea.getDocument().getText(current - startOffset, 1);
      }
      startOffset--;

      int length = endIndex - current + startOffset;
      text = textarea.getDocument().getText(current - startOffset, length);

    }",maybe_loop_control
current,"{
      int current = textarea.getCaretPosition();
      int startOffset = 0;
      int endIndex = current;
      String tmp = textarea.getDocument().getText(current, 1);
      // TODO probably a regexp that matches Arduino lang special chars
      // already exists.
      String regexp = ""[\\s\\n();\\\\.!='\\[\\]{}]"";

      while (!tmp.matches(regexp)) {
        endIndex++;
        tmp = textarea.getDocument().getText(endIndex, 1);
      }
      // For some reason document index start at 2.
      // if( current - start < 2 ) return;

      tmp = """";
      while (!tmp.matches(regexp)) {
        startOffset++;
        if (current - startOffset < 0) {
          tmp = textarea.getDocument().getText(0, 1);
          break;
        } else
          tmp = textarea.getDocument().getText(current - startOffset, 1);
      }
      startOffset--;

      int length = endIndex - current + startOffset;
      text = textarea.getDocument().getText(current - startOffset, length);

    }",break_loop_control
rate,"for (String rate : serialRateStrings) {
      serialRates.addItem(rate + "" "" + tr(""baud""));
    }",iterator
tokenizer,"{
    String now = new SimpleDateFormat(""HH:mm:ss.SSS -> "").format(new Date());
    final StringBuilder sb = new StringBuilder(text.length() + now.length());
    StringTokenizer tokenizer = new StringTokenizer(text, LINE_SEPARATOR, true);
    while (tokenizer.hasMoreTokens()) {
      if (isStartingLine) {
        sb.append(now);
      }
      String token = tokenizer.nextToken();
      sb.append(token);
      // tokenizer returns ""\n"" as a single token
      isStartingLine = token.equals(LINE_SEPARATOR);
    }
    return sb.toString();
  }",maybe_loop_control
file,"for (SketchFile file : sketch.getFiles()) {
      if (file.isExtension(Sketch.OLD_SKETCH_EXTENSIONS))
        oldFiles.add(file);
    }",iterator
file,"for (SketchFile file : oldFiles) {
          File newName = FileUtils.replaceExtension(file.getFile(), Sketch.DEFAULT_SKETCH_EXTENSION);
          file.renameTo(newName.getName());
        }",iterator
aList,"for (String aList : list) {
      buffer.append(""#include <"");
      buffer.append(aList);
      buffer.append("">\n"");
    }",iterator
progressListener,"for (CompilerProgressListener progressListener : editor.status.getCompilerProgressListeners()){
      progressListener.progress(20);
    }",iterator
file,"for (SketchFile file : Stream.of(sketch.getFiles()).filter(SketchFile::isModified).collect(Collectors.toList())) {
      Files.write(Paths.get(tempFolder.getAbsolutePath(), file.getFileName()), file.getProgram().getBytes(""UTF-8""));
    }",iterator
warning,"for (String warning : warningsAccumulator) {
        System.out.print(tr(""Warning""));
        System.out.print("": "");
        System.out.println(warning);
      }",iterator
file,"for (SketchFile file : sketch.getFiles()) {
        file.save();  // this will force a save
      }",iterator
file,"for (SketchFile file : sketch.getFiles()) {
      if (file.isModified() && file.fileReadOnly() && file.fileExists()) {
        return true;
      }
    }",iterator
i,"for (int i = 0; i < STATUS.length; i++) {
        for (int j = 0; j < WHERE.length; j++) {
          String path = ""tab-"" + STATUS[i] + ""-"" + WHERE[j];
          pieces[i][j] = Theme.getThemeImage(path, this, PIECE_WIDTH,
                                             PIECE_HEIGHT);
        }
        String path = ""tab-"" + STATUS[i] + ""-menu"";
        menuButtons[i] = Theme.getThemeImage(path, this, PIECE_HEIGHT,
                                             PIECE_HEIGHT);
      }",loop_control
i,"for (int i = 0; i < numTabs; i++) {
              if ((x > tabLeft[i]) && (x < tabRight[i])) {
                editor.selectTab(i);
                repaint();
              }
            }",loop_control
j,"for (int j = 0; j < WHERE.length; j++) {
          String path = ""tab-"" + STATUS[i] + ""-"" + WHERE[j];
          pieces[i][j] = Theme.getThemeImage(path, this, PIECE_WIDTH,
                                             PIECE_HEIGHT);
        }",loop_control
tab,"for (EditorTab tab : tabs) {
      SketchFile file = tab.getSketchFile();
      String filename = file.getPrettyName();

      // if modified, add the li'l glyph next to the name
      String text = ""  "" + filename + (file.isModified() ? "" \u00A7"" : ""  "");

      int textWidth = (int)
        font.getStringBounds(text, g.getFontRenderContext()).getWidth();

      int pieceCount = 2 + (textWidth / PIECE_WIDTH);
      int pieceWidth = pieceCount * PIECE_WIDTH;

      int state = (i == editor.getCurrentTabIndex()) ? SELECTED : UNSELECTED;
      g.drawImage(pieces[state][LEFT], x, 0, null);
      x += PIECE_WIDTH;

      int contentLeft = x;
      tabLeft[i] = x;
      for (int j = 0; j < pieceCount; j++) {
        g.drawImage(pieces[state][MIDDLE], x, 0, null);
        x += PIECE_WIDTH;
      }
      tabRight[i] = x;
      int textLeft = contentLeft + (pieceWidth - textWidth) / 2;

      g.setColor(textColor[state]);
      int tabMarginTop = sizeH - TAB_HEIGHT;
      int baseline = tabMarginTop + ((TAB_HEIGHT + fontAscent) / 2) ; 
      g.drawString(text, textLeft, baseline);

      g.drawImage(pieces[state][RIGHT], x, 0, null);
      x += PIECE_WIDTH - 1;  // overlap by 1 pixel
      i++;
    }",iterator
tab,"for (EditorTab tab : editor.getTabs()) {
        SketchFile file = tab.getSketchFile();
        final int index = i++;
        item = new JMenuItem(file.getPrettyName());
        item.addActionListener((ActionEvent e) -> {
          editor.selectTab(index);
        });
        menu.add(item);
      }",iterator
handler,"for(Handler handler : handlers) {
        globalLogger.removeHandler(handler);
    }",iterator
handler,"for(Handler handler : handlers) {
      root.removeHandler(handler);
    }",iterator
library,"for (String library : parser.getLibraryToInstall().split("","")) {
        String[] libraryToInstallParts = library.split("":"");

        ContributedLibrary selected = null;
        if (libraryToInstallParts.length == 2) {
          Optional<Version> version = VersionHelper.valueOf(libraryToInstallParts[1]);
          if (!version.isPresent()) {
            System.out.println(format(tr(""Invalid version {0}""), libraryToInstallParts[1]));
            System.exit(1);
          }
          selected = indexer.getIndex().find(libraryToInstallParts[0], version.get().toString());
        } else if (libraryToInstallParts.length == 1) {
          List<ContributedLibrary> librariesByName = indexer.getIndex().find(libraryToInstallParts[0]);
          Collections.sort(librariesByName, new DownloadableContributionVersionComparator());
          if (!librariesByName.isEmpty()) {
            selected = librariesByName.get(librariesByName.size() - 1);
          }
        }
        if (selected == null) {
          System.out.println(tr(""Selected library is not available""));
          System.exit(1);
        }

        Optional<ContributedLibrary> mayInstalled = indexer.getIndex().getInstalled(libraryToInstallParts[0]);
        if (mayInstalled.isPresent() && selected.isIDEBuiltIn()) {
          System.out.println(tr(I18n
              .format(""Library {0} is available as built-in in the IDE.\nRemoving the other version {1} installed in the sketchbook..."",
                      library, mayInstalled.get().getParsedVersion())));
          libraryInstaller.remove(mayInstalled.get(), progressListener);
        } else {
          libraryInstaller.install(selected, progressListener);
        }
      }",iterator
path,"for (String path : parser.getFilenames()) {
        // Correctly resolve relative paths
        File file = absoluteFile(path);

        // Fix a problem with systems that use a non-ASCII languages. Paths are
        // being passed in with 8.3 syntax, which makes the sketch loader code
        // unhappy, since the sketch folder naming doesn't match up correctly.
        // http://dev.processing.org/bugs/show_bug.cgi?id=1089
        if (OSUtils.isWindows()) {
          try {
            file = file.getCanonicalFile();
          } catch (IOException e) {
            e.printStackTrace();
          }
        }

        if (!parser.isForceSavePrefs())
          PreferencesData.setDoSave(true);
        if (handleOpen(file, retrieveSketchLocation("".default""), false) == null) {
          String mess = format(tr(""Failed to open sketch: \""{0}\""""), path);
          // Open failure is fatal in upload/verify mode
          if (parser.isVerifyOrUploadMode())
            showError(null, mess, 2);
          else
            showWarning(null, mess, null);
        }
      }",iterator
warning,"for (String warning : warnings) {
            System.out.println(tr(""Warning"") + "": "" + warning);
          }",iterator
i,"for (int i = count - 1; i >= 0; i--) {
      String path = PreferencesData.get(""last.sketch"" + i + "".path"");
      if (path == null) {
        continue;
      }
      if (BaseNoGui.getPortableFolder() != null && !new File(path).isAbsolute()) {
        File absolute = new File(BaseNoGui.getPortableFolder(), path);
        try {
          path = absolute.getCanonicalPath();
        } catch (IOException e) {
          // path unchanged.
        }
      }
      int[] location = retrieveSketchLocation("""" + i);
      // If file did not exist, null will be returned for the Editor
      if (handleOpen(new File(path), location, nextEditorLocation(), false, false) != null) {
        opened++;
      }
    }",loop_control
editor,"for (Editor editor : reversedEditors) {
      Sketch sketch = editor.getSketch();
      String path = sketch.getMainFilePath();
      // Skip untitled sketches if they do not contains changes.
      if (path.startsWith(untitledPath) && !sketch.isModified()) {
        continue;
      }
      storeSketchLocation(editor, """" + index);
      index++;
    }",iterator
handler,"for(Handler handler : handlers) {
        globalLogger.removeHandler(handler);
    }",iterator
handler,"for(Handler handler : handlers) {
      root.removeHandler(handler);
    }",iterator
library,"for (String library : parser.getLibraryToInstall().split("","")) {
        String[] libraryToInstallParts = library.split("":"");

        ContributedLibrary selected = null;
        if (libraryToInstallParts.length == 2) {
          Optional<Version> version = VersionHelper.valueOf(libraryToInstallParts[1]);
          if (!version.isPresent()) {
            System.out.println(format(tr(""Invalid version {0}""), libraryToInstallParts[1]));
            System.exit(1);
          }
          selected = indexer.getIndex().find(libraryToInstallParts[0], version.get().toString());
        } else if (libraryToInstallParts.length == 1) {
          List<ContributedLibrary> librariesByName = indexer.getIndex().find(libraryToInstallParts[0]);
          Collections.sort(librariesByName, new DownloadableContributionVersionComparator());
          if (!librariesByName.isEmpty()) {
            selected = librariesByName.get(librariesByName.size() - 1);
          }
        }
        if (selected == null) {
          System.out.println(tr(""Selected library is not available""));
          System.exit(1);
        }

        Optional<ContributedLibrary> mayInstalled = indexer.getIndex().getInstalled(libraryToInstallParts[0]);
        if (mayInstalled.isPresent() && selected.isIDEBuiltIn()) {
          System.out.println(tr(I18n
              .format(""Library {0} is available as built-in in the IDE.\nRemoving the other version {1} installed in the sketchbook..."",
                      library, mayInstalled.get().getParsedVersion())));
          libraryInstaller.remove(mayInstalled.get(), progressListener);
        } else {
          libraryInstaller.install(selected, progressListener);
        }
      }",iterator
warning,"for (String warning : warnings) {
            System.out.println(tr(""Warning"") + "": "" + warning);
          }",iterator
path,"for (String path : parser.getFilenames()) {
        // Correctly resolve relative paths
        File file = absoluteFile(path);

        // Fix a problem with systems that use a non-ASCII languages. Paths are
        // being passed in with 8.3 syntax, which makes the sketch loader code
        // unhappy, since the sketch folder naming doesn't match up correctly.
        // http://dev.processing.org/bugs/show_bug.cgi?id=1089
        if (OSUtils.isWindows()) {
          try {
            file = file.getCanonicalFile();
          } catch (IOException e) {
            e.printStackTrace();
          }
        }

        if (!parser.isForceSavePrefs())
          PreferencesData.setDoSave(true);
        if (handleOpen(file, retrieveSketchLocation("".default""), false) == null) {
          String mess = format(tr(""Failed to open sketch: \""{0}\""""), path);
          // Open failure is fatal in upload/verify mode
          if (parser.isVerifyOrUploadMode())
            showError(null, mess, 2);
          else
            showWarning(null, mess, null);
        }
      }",iterator
i,"for (int i = count - 1; i >= 0; i--) {
      String path = PreferencesData.get(""last.sketch"" + i + "".path"");
      if (path == null) {
        continue;
      }
      if (BaseNoGui.getPortableFolder() != null && !new File(path).isAbsolute()) {
        File absolute = new File(BaseNoGui.getPortableFolder(), path);
        try {
          path = absolute.getCanonicalPath();
        } catch (IOException e) {
          // path unchanged.
        }
      }
      int[] location = retrieveSketchLocation("""" + i);
      // If file did not exist, null will be returned for the Editor
      if (handleOpen(new File(path), location, nextEditorLocation(), false, false) != null) {
        opened++;
      }
    }",loop_control
editor,"for (Editor editor : reversedEditors) {
      Sketch sketch = editor.getSketch();
      String path = sketch.getMainFilePath();
      // Skip untitled sketches if they do not contains changes.
      if (path.startsWith(untitledPath) && !sketch.isModified()) {
        continue;
      }
      storeSketchLocation(editor, """" + index);
      index++;
    }",iterator
index,"{
    File newbieDir = null;
    String newbieName = null;

    // In 0126, untitled sketches will begin in the temp folder,
    // and then moved to a new location because Save will default to Save As.
    File sketchbookDir = BaseNoGui.getSketchbookFolder();
    File newbieParentDir = untitledFolder;

    // Use a generic name like sketch_031008a, the date plus a char
    int index = 0;
    //SimpleDateFormat formatter = new SimpleDateFormat(""yyMMdd"");
    //SimpleDateFormat formatter = new SimpleDateFormat(""MMMdd"");
    //String purty = formatter.format(new Date()).toLowerCase();
    Calendar cal = Calendar.getInstance();
    int day = cal.get(Calendar.DAY_OF_MONTH);  // 1..31
    int month = cal.get(Calendar.MONTH);  // 0..11
    String purty = months[month] + PApplet.nf(day, 2);

    do {
      if (index == 26*26) {
        // In 0166, avoid running past zz by sending people outdoors.
        if (!breakTime) {
          showWarning(tr(""Time for a Break""),
                  tr(""You've reached the limit for auto naming of new sketches\n"" +
                          ""for the day. How about going for a walk instead?""), null);
          breakTime = true;
        } else {
          showWarning(tr(""Sunshine""),
                  tr(""No really, time for some fresh air for you.""), null);
        }
        return null;
      }

      int multiples = index / 26;

      if(multiples > 0){
        newbieName = ((char) ('a' + (multiples-1))) + """" + ((char) ('a' + (index % 26))) + """";
      }else{
        newbieName = ((char) ('a' + index)) + """";
      }
      newbieName = ""sketch_"" + purty + newbieName;
      newbieDir = new File(newbieParentDir, newbieName);
      index++;
      // Make sure it's not in the temp folder *and* it's not in the sketchbook
    } while (newbieDir.exists() || new File(sketchbookDir, newbieName).exists());

    // Make the directory for the new sketch
    newbieDir.mkdirs();

    // Make an empty pde file
    File newbieFile = new File(newbieDir, newbieName + "".ino"");
    if (!newbieFile.createNewFile()) {
      throw new IOException();
    }

    // Initialize the pde file with the BareMinimum sketch.
    // Apply user-defined tab settings.
    String sketch = FileUtils.readFileToString(
        new File(getContentFile(""examples""), ""01.Basics"" + File.separator
            + ""BareMinimum"" + File.separator + ""BareMinimum.ino""));
    String currentTab = ""  "";
    String newTab = (PreferencesData.getBoolean(""editor.tabs.expand"")
        ? StringUtils.repeat("" "",
            PreferencesData.getInteger(""editor.tabs.size""))
        : ""\t"");
    sketch = sketch.replaceAll(
        ""(?<=(^|\n)("" + currentTab + ""){0,50})"" + currentTab, newTab);
    FileUtils.writeStringToFile(newbieFile, sketch);
    return newbieFile;
  }",break_loop_control
newbieDir,"{
    File newbieDir = null;
    String newbieName = null;

    // In 0126, untitled sketches will begin in the temp folder,
    // and then moved to a new location because Save will default to Save As.
    File sketchbookDir = BaseNoGui.getSketchbookFolder();
    File newbieParentDir = untitledFolder;

    // Use a generic name like sketch_031008a, the date plus a char
    int index = 0;
    //SimpleDateFormat formatter = new SimpleDateFormat(""yyMMdd"");
    //SimpleDateFormat formatter = new SimpleDateFormat(""MMMdd"");
    //String purty = formatter.format(new Date()).toLowerCase();
    Calendar cal = Calendar.getInstance();
    int day = cal.get(Calendar.DAY_OF_MONTH);  // 1..31
    int month = cal.get(Calendar.MONTH);  // 0..11
    String purty = months[month] + PApplet.nf(day, 2);

    do {
      if (index == 26*26) {
        // In 0166, avoid running past zz by sending people outdoors.
        if (!breakTime) {
          showWarning(tr(""Time for a Break""),
                  tr(""You've reached the limit for auto naming of new sketches\n"" +
                          ""for the day. How about going for a walk instead?""), null);
          breakTime = true;
        } else {
          showWarning(tr(""Sunshine""),
                  tr(""No really, time for some fresh air for you.""), null);
        }
        return null;
      }

      int multiples = index / 26;

      if(multiples > 0){
        newbieName = ((char) ('a' + (multiples-1))) + """" + ((char) ('a' + (index % 26))) + """";
      }else{
        newbieName = ((char) ('a' + index)) + """";
      }
      newbieName = ""sketch_"" + purty + newbieName;
      newbieDir = new File(newbieParentDir, newbieName);
      index++;
      // Make sure it's not in the temp folder *and* it's not in the sketchbook
    } while (newbieDir.exists() || new File(sketchbookDir, newbieName).exists());

    // Make the directory for the new sketch
    newbieDir.mkdirs();

    // Make an empty pde file
    File newbieFile = new File(newbieDir, newbieName + "".ino"");
    if (!newbieFile.createNewFile()) {
      throw new IOException();
    }

    // Initialize the pde file with the BareMinimum sketch.
    // Apply user-defined tab settings.
    String sketch = FileUtils.readFileToString(
        new File(getContentFile(""examples""), ""01.Basics"" + File.separator
            + ""BareMinimum"" + File.separator + ""BareMinimum.ino""));
    String currentTab = ""  "";
    String newTab = (PreferencesData.getBoolean(""editor.tabs.expand"")
        ? StringUtils.repeat("" "",
            PreferencesData.getInteger(""editor.tabs.size""))
        : ""\t"");
    sketch = sketch.replaceAll(
        ""(?<=(^|\n)("" + currentTab + ""){0,50})"" + currentTab, newTab);
    FileUtils.writeStringToFile(newbieFile, sketch);
    return newbieFile;
  }",maybe_loop_control
editor,"for (Editor editor : editors) {
      if (editor.getSketch().getPrimaryFile().getFile().equals(file)) {
        editor.toFront();
        return editor;
      }
    }",iterator
editor,"{
    if (!file.exists()) return null;

    // Cycle through open windows to make sure that it's not already open.
    for (Editor editor : editors) {
      if (editor.getSketch().getPrimaryFile().getFile().equals(file)) {
        editor.toFront();
        return editor;
      }
    }

    Editor editor = new Editor(this, file, storedLocation, defaultLocation, BaseNoGui.getPlatform());

    // Make sure that the sketch actually loaded
    if (editor.getSketchController() == null) {
      return null;  // Just walk away quietly
    }

    editor.untitled = untitled;

    editors.add(editor);

    if (storeOpenedSketches) {
      // Store information on who's open and running
      // (in case there's a crash or something that can't be recovered)
      storeSketches();
      storeRecentSketches(editor.getSketchController());
      rebuildRecentSketchesMenuItems();
      PreferencesData.save();
    }

    // now that we're ready, show the window
    // (don't do earlier, cuz we might move it based on a window being closed)
    SwingUtilities.invokeLater(() -> editor.setVisible(true));

    return editor;
  }",iterator
editor,"for (Editor editor : editors) {
      if (editor.getSketch().getPrimaryFile().getFile().equals(file)) {
        editor.toFront();
        return editor;
      }
    }",break_loop_control
editor,"{
    if (!file.exists()) return null;

    // Cycle through open windows to make sure that it's not already open.
    for (Editor editor : editors) {
      if (editor.getSketch().getPrimaryFile().getFile().equals(file)) {
        editor.toFront();
        return editor;
      }
    }

    Editor editor = new Editor(this, file, storedLocation, defaultLocation, BaseNoGui.getPlatform());

    // Make sure that the sketch actually loaded
    if (editor.getSketchController() == null) {
      return null;  // Just walk away quietly
    }

    editor.untitled = untitled;

    editors.add(editor);

    if (storeOpenedSketches) {
      // Store information on who's open and running
      // (in case there's a crash or something that can't be recovered)
      storeSketches();
      storeRecentSketches(editor.getSketchController());
      rebuildRecentSketchesMenuItems();
      PreferencesData.save();
    }

    // now that we're ready, show the window
    // (don't do earlier, cuz we might move it based on a window being closed)
    SwingUtilities.invokeLater(() -> editor.setVisible(true));

    return editor;
  }",break_loop_control
path,"for (String path : PreferencesData.getCollection(""recent.sketches"")) {
      File file = new File(path);
      if (file.exists()) {
        recentSketches.add(file);
      }
    }",iterator
recentSketch,"for (final File recentSketch : recentSketches) {
      JMenuItem recentSketchMenuItem = new JMenuItem(recentSketch.getParentFile().getName());
      recentSketchMenuItem.addActionListener(new ActionListener() {
        @Override
        public void actionPerformed(ActionEvent actionEvent) {
          try {
            handleOpen(recentSketch);
          } catch (Exception e) {
            e.printStackTrace();
          }
        }
      });
      recentSketchesMenuItems.add(recentSketchMenuItem);
    }",iterator
editor,"for (Editor editor : editors) {
      if (!editor.checkModified()) {
        return false;
      }
    }",iterator
editor,"for (Editor editor : editors) {
      if (!editor.checkModified()) {
        return false;
      }
    }",break_loop_control
lib,"for (UserLibrary lib : libs) {
        String libType = lib.getTypes().get(0);
        if (!libType.equals(lastLibType)) {
          if (lastLibType != null) {
            importMenu.addSeparator();
          }
          lastLibType = libType;
          JMenuItem platformItem = new JMenuItem(format(tr(""{0} libraries""), tr(lastLibType)));
          platformItem.setEnabled(false);
          importMenu.add(platformItem);
        }

        AbstractAction action = new AbstractAction(lib.getName()) {
          public void actionPerformed(ActionEvent event) {
            UserLibrary l = (UserLibrary) getValue(""library"");
            try {
              activeEditor.getSketchController().importLibrary(l);
            } catch (IOException e) {
              showWarning(tr(""Error""), format(""Unable to list header files in {0}"", l.getSrcFolder()), e);
            }
          }
        };
        action.putValue(""library"", lib);

        // Add new element at the bottom
        JMenuItem item = new JMenuItem(action);
        item.putClientProperty(""library"", lib);
        importMenu.add(item);
      }",iterator
lib,"for (UserLibrary lib : allLibraries) {
      // Get the library's location - used for sorting into categories
      Location location = lib.getLocation();
      // Is this library compatible?
      List<String> arch = lib.getArchitectures();
      boolean compatible;
      if (myArch == null || arch == null || arch.contains(""*"")) {
        compatible = true;
      } else {
        compatible = arch.contains(myArch);
      }
      // IDE Libaries (including retired)
      if (location == Location.IDE_BUILTIN) {
        if (compatible) {
          // only compatible IDE libs are shown
          if (lib.getTypes().contains(""Retired"")) {
            retiredIdeLibs.add(lib);
          } else {
            ideLibs.add(lib);
          }
        }
      // Platform Libraries
      } else if (location == Location.CORE) {
        // all platform libs are assumed to be compatible
        platformLibs.add(lib);
      // Referenced Platform Libraries
      } else if (location == Location.REFERENCED_CORE) {
        // all referenced platform libs are assumed to be compatible
        referencedPlatformLibs.add(lib);
      // Sketchbook Libraries (including incompatible)
      } else if (location == Location.SKETCHBOOK) {
        if (compatible) {
          // libraries promoted from sketchbook (behave as builtin)
          if (!lib.getTypes().isEmpty() && lib.getTypes().contains(""Arduino"")
              && lib.getArchitectures().contains(""*"")) {
            ideLibs.add(lib);
          } else {
            sketchbookLibs.add(lib);
          }
        } else {
          sketchbookIncompatibleLibs.add(lib);
        }
      // Other libraries of unknown type (should never occur)
      } else {
        otherLibs.add(lib);
      }
    }",iterator
lib,"for (UserLibrary lib : ideLibs) {
      addSketchesSubmenu(menu, lib);
    }",iterator
lib,"for (UserLibrary lib : retiredIdeLibs) {
        addSketchesSubmenu(retired, lib);
      }",iterator
lib,"for (UserLibrary lib : platformLibs) {
        addSketchesSubmenu(menu, lib);
      }",iterator
lib,"for (UserLibrary lib : referencedPlatformLibs) {
        addSketchesSubmenu(menu, lib);
      }",iterator
lib,"for (UserLibrary lib : sketchbookLibs) {
        addSketchesSubmenu(menu, lib);
      }",iterator
lib,"for (UserLibrary lib : sketchbookIncompatibleLibs) {
        addSketchesSubmenu(incompatible, lib);
      }",iterator
lib,"for (UserLibrary lib : otherLibs) {
        addSketchesSubmenu(menu, lib);
      }",iterator
editor,"for (Editor editor : editors) {
          editor.updateKeywords(pdeKeywords);
        }",iterator
editor,"for (Editor editor : editors) {
      editor.onBoardOrPortChange();
    }",iterator
handler,"for(Handler handler : handlers) {
        globalLogger.removeHandler(handler);
    }",iterator
handler,"for(Handler handler : handlers) {
      root.removeHandler(handler);
    }",iterator
library,"for (String library : parser.getLibraryToInstall().split("","")) {
        String[] libraryToInstallParts = library.split("":"");

        ContributedLibrary selected = null;
        if (libraryToInstallParts.length == 2) {
          Optional<Version> version = VersionHelper.valueOf(libraryToInstallParts[1]);
          if (!version.isPresent()) {
            System.out.println(format(tr(""Invalid version {0}""), libraryToInstallParts[1]));
            System.exit(1);
          }
          selected = indexer.getIndex().find(libraryToInstallParts[0], version.get().toString());
        } else if (libraryToInstallParts.length == 1) {
          List<ContributedLibrary> librariesByName = indexer.getIndex().find(libraryToInstallParts[0]);
          Collections.sort(librariesByName, new DownloadableContributionVersionComparator());
          if (!librariesByName.isEmpty()) {
            selected = librariesByName.get(librariesByName.size() - 1);
          }
        }
        if (selected == null) {
          System.out.println(tr(""Selected library is not available""));
          System.exit(1);
        }

        Optional<ContributedLibrary> mayInstalled = indexer.getIndex().getInstalled(libraryToInstallParts[0]);
        if (mayInstalled.isPresent() && selected.isIDEBuiltIn()) {
          System.out.println(tr(I18n
              .format(""Library {0} is available as built-in in the IDE.\nRemoving the other version {1} installed in the sketchbook..."",
                      library, mayInstalled.get().getParsedVersion())));
          libraryInstaller.remove(mayInstalled.get(), progressListener);
        } else {
          libraryInstaller.install(selected, progressListener);
        }
      }",iterator
path,"for (String path : parser.getFilenames()) {
        // Correctly resolve relative paths
        File file = absoluteFile(path);

        // Fix a problem with systems that use a non-ASCII languages. Paths are
        // being passed in with 8.3 syntax, which makes the sketch loader code
        // unhappy, since the sketch folder naming doesn't match up correctly.
        // http://dev.processing.org/bugs/show_bug.cgi?id=1089
        if (OSUtils.isWindows()) {
          try {
            file = file.getCanonicalFile();
          } catch (IOException e) {
            e.printStackTrace();
          }
        }

        if (!parser.isForceSavePrefs())
          PreferencesData.setDoSave(true);
        if (handleOpen(file, retrieveSketchLocation("".default""), false) == null) {
          String mess = format(tr(""Failed to open sketch: \""{0}\""""), path);
          // Open failure is fatal in upload/verify mode
          if (parser.isVerifyOrUploadMode())
            showError(null, mess, 2);
          else
            showWarning(null, mess, null);
        }
      }",iterator
i,"for (int i = count - 1; i >= 0; i--) {
      String path = PreferencesData.get(""last.sketch"" + i + "".path"");
      if (path == null) {
        continue;
      }
      if (BaseNoGui.getPortableFolder() != null && !new File(path).isAbsolute()) {
        File absolute = new File(BaseNoGui.getPortableFolder(), path);
        try {
          path = absolute.getCanonicalPath();
        } catch (IOException e) {
          // path unchanged.
        }
      }
      int[] location = retrieveSketchLocation("""" + i);
      // If file did not exist, null will be returned for the Editor
      if (handleOpen(new File(path), location, nextEditorLocation(), false, false) != null) {
        opened++;
      }
    }",loop_control
editor,"for (Editor editor : reversedEditors) {
      Sketch sketch = editor.getSketch();
      String path = sketch.getMainFilePath();
      // Skip untitled sketches if they do not contains changes.
      if (path.startsWith(untitledPath) && !sketch.isModified()) {
        continue;
      }
      storeSketchLocation(editor, """" + index);
      index++;
    }",iterator
index,"{
    File newbieDir = null;
    String newbieName = null;

    // In 0126, untitled sketches will begin in the temp folder,
    // and then moved to a new location because Save will default to Save As.
    File sketchbookDir = BaseNoGui.getSketchbookFolder();
    File newbieParentDir = untitledFolder;

    // Use a generic name like sketch_031008a, the date plus a char
    int index = 0;
    //SimpleDateFormat formatter = new SimpleDateFormat(""yyMMdd"");
    //SimpleDateFormat formatter = new SimpleDateFormat(""MMMdd"");
    //String purty = formatter.format(new Date()).toLowerCase();
    Calendar cal = Calendar.getInstance();
    int day = cal.get(Calendar.DAY_OF_MONTH);  // 1..31
    int month = cal.get(Calendar.MONTH);  // 0..11
    String purty = months[month] + PApplet.nf(day, 2);

    do {
      if (index == 26*26) {
        // In 0166, avoid running past zz by sending people outdoors.
        if (!breakTime) {
          showWarning(tr(""Time for a Break""),
                  tr(""You've reached the limit for auto naming of new sketches\n"" +
                          ""for the day. How about going for a walk instead?""), null);
          breakTime = true;
        } else {
          showWarning(tr(""Sunshine""),
                  tr(""No really, time for some fresh air for you.""), null);
        }
        return null;
      }

      int multiples = index / 26;

      if(multiples > 0){
        newbieName = ((char) ('a' + (multiples-1))) + """" + ((char) ('a' + (index % 26))) + """";
      }else{
        newbieName = ((char) ('a' + index)) + """";
      }
      newbieName = ""sketch_"" + purty + newbieName;
      newbieDir = new File(newbieParentDir, newbieName);
      index++;
      // Make sure it's not in the temp folder *and* it's not in the sketchbook
    } while (newbieDir.exists() || new File(sketchbookDir, newbieName).exists());

    // Make the directory for the new sketch
    newbieDir.mkdirs();

    // Make an empty pde file
    File newbieFile = new File(newbieDir, newbieName + "".ino"");
    if (!newbieFile.createNewFile()) {
      throw new IOException();
    }

    // Initialize the pde file with the BareMinimum sketch.
    // Apply user-defined tab settings.
    String sketch = FileUtils.readFileToString(
        new File(getContentFile(""examples""), ""01.Basics"" + File.separator
            + ""BareMinimum"" + File.separator + ""BareMinimum.ino""));
    String currentTab = ""  "";
    String newTab = (PreferencesData.getBoolean(""editor.tabs.expand"")
        ? StringUtils.repeat("" "",
            PreferencesData.getInteger(""editor.tabs.size""))
        : ""\t"");
    sketch = sketch.replaceAll(
        ""(?<=(^|\n)("" + currentTab + ""){0,50})"" + currentTab, newTab);
    FileUtils.writeStringToFile(newbieFile, sketch);
    return newbieFile;
  }",break_loop_control
newbieDir,"{
    File newbieDir = null;
    String newbieName = null;

    // In 0126, untitled sketches will begin in the temp folder,
    // and then moved to a new location because Save will default to Save As.
    File sketchbookDir = BaseNoGui.getSketchbookFolder();
    File newbieParentDir = untitledFolder;

    // Use a generic name like sketch_031008a, the date plus a char
    int index = 0;
    //SimpleDateFormat formatter = new SimpleDateFormat(""yyMMdd"");
    //SimpleDateFormat formatter = new SimpleDateFormat(""MMMdd"");
    //String purty = formatter.format(new Date()).toLowerCase();
    Calendar cal = Calendar.getInstance();
    int day = cal.get(Calendar.DAY_OF_MONTH);  // 1..31
    int month = cal.get(Calendar.MONTH);  // 0..11
    String purty = months[month] + PApplet.nf(day, 2);

    do {
      if (index == 26*26) {
        // In 0166, avoid running past zz by sending people outdoors.
        if (!breakTime) {
          showWarning(tr(""Time for a Break""),
                  tr(""You've reached the limit for auto naming of new sketches\n"" +
                          ""for the day. How about going for a walk instead?""), null);
          breakTime = true;
        } else {
          showWarning(tr(""Sunshine""),
                  tr(""No really, time for some fresh air for you.""), null);
        }
        return null;
      }

      int multiples = index / 26;

      if(multiples > 0){
        newbieName = ((char) ('a' + (multiples-1))) + """" + ((char) ('a' + (index % 26))) + """";
      }else{
        newbieName = ((char) ('a' + index)) + """";
      }
      newbieName = ""sketch_"" + purty + newbieName;
      newbieDir = new File(newbieParentDir, newbieName);
      index++;
      // Make sure it's not in the temp folder *and* it's not in the sketchbook
    } while (newbieDir.exists() || new File(sketchbookDir, newbieName).exists());

    // Make the directory for the new sketch
    newbieDir.mkdirs();

    // Make an empty pde file
    File newbieFile = new File(newbieDir, newbieName + "".ino"");
    if (!newbieFile.createNewFile()) {
      throw new IOException();
    }

    // Initialize the pde file with the BareMinimum sketch.
    // Apply user-defined tab settings.
    String sketch = FileUtils.readFileToString(
        new File(getContentFile(""examples""), ""01.Basics"" + File.separator
            + ""BareMinimum"" + File.separator + ""BareMinimum.ino""));
    String currentTab = ""  "";
    String newTab = (PreferencesData.getBoolean(""editor.tabs.expand"")
        ? StringUtils.repeat("" "",
            PreferencesData.getInteger(""editor.tabs.size""))
        : ""\t"");
    sketch = sketch.replaceAll(
        ""(?<=(^|\n)("" + currentTab + ""){0,50})"" + currentTab, newTab);
    FileUtils.writeStringToFile(newbieFile, sketch);
    return newbieFile;
  }",maybe_loop_control
editor,"for (Editor editor : editors) {
      if (editor.getSketch().getPrimaryFile().getFile().equals(file)) {
        editor.toFront();
        return editor;
      }
    }",iterator
editor,"{
    if (!file.exists()) return null;

    // Cycle through open windows to make sure that it's not already open.
    for (Editor editor : editors) {
      if (editor.getSketch().getPrimaryFile().getFile().equals(file)) {
        editor.toFront();
        return editor;
      }
    }

    Editor editor = new Editor(this, file, storedLocation, defaultLocation, BaseNoGui.getPlatform());

    // Make sure that the sketch actually loaded
    if (editor.getSketchController() == null) {
      return null;  // Just walk away quietly
    }

    editor.untitled = untitled;

    editors.add(editor);

    if (storeOpenedSketches) {
      // Store information on who's open and running
      // (in case there's a crash or something that can't be recovered)
      storeSketches();
      storeRecentSketches(editor.getSketchController());
      rebuildRecentSketchesMenuItems();
      PreferencesData.save();
    }

    // now that we're ready, show the window
    // (don't do earlier, cuz we might move it based on a window being closed)
    SwingUtilities.invokeLater(() -> editor.setVisible(true));

    return editor;
  }",iterator
editor,"for (Editor editor : editors) {
      if (editor.getSketch().getPrimaryFile().getFile().equals(file)) {
        editor.toFront();
        return editor;
      }
    }",break_loop_control
editor,"{
    if (!file.exists()) return null;

    // Cycle through open windows to make sure that it's not already open.
    for (Editor editor : editors) {
      if (editor.getSketch().getPrimaryFile().getFile().equals(file)) {
        editor.toFront();
        return editor;
      }
    }

    Editor editor = new Editor(this, file, storedLocation, defaultLocation, BaseNoGui.getPlatform());

    // Make sure that the sketch actually loaded
    if (editor.getSketchController() == null) {
      return null;  // Just walk away quietly
    }

    editor.untitled = untitled;

    editors.add(editor);

    if (storeOpenedSketches) {
      // Store information on who's open and running
      // (in case there's a crash or something that can't be recovered)
      storeSketches();
      storeRecentSketches(editor.getSketchController());
      rebuildRecentSketchesMenuItems();
      PreferencesData.save();
    }

    // now that we're ready, show the window
    // (don't do earlier, cuz we might move it based on a window being closed)
    SwingUtilities.invokeLater(() -> editor.setVisible(true));

    return editor;
  }",break_loop_control
path,"for (String path : PreferencesData.getCollection(""recent.sketches"")) {
      File file = new File(path);
      if (file.exists()) {
        recentSketches.add(file);
      }
    }",iterator
recentSketch,"for (final File recentSketch : recentSketches) {
      JMenuItem recentSketchMenuItem = new JMenuItem(recentSketch.getParentFile().getName());
      recentSketchMenuItem.addActionListener(new ActionListener() {
        @Override
        public void actionPerformed(ActionEvent actionEvent) {
          try {
            handleOpen(recentSketch);
          } catch (Exception e) {
            e.printStackTrace();
          }
        }
      });
      recentSketchesMenuItems.add(recentSketchMenuItem);
    }",iterator
editor,"for (Editor editor : editors) {
      if (!editor.checkModified()) {
        return false;
      }
    }",iterator
editor,"for (Editor editor : editors) {
      if (!editor.checkModified()) {
        return false;
      }
    }",break_loop_control
lib,"for (UserLibrary lib : libs) {
        String libType = lib.getTypes().get(0);
        if (!libType.equals(lastLibType)) {
          if (lastLibType != null) {
            importMenu.addSeparator();
          }
          lastLibType = libType;
          JMenuItem platformItem = new JMenuItem(format(tr(""{0} libraries""), tr(lastLibType)));
          platformItem.setEnabled(false);
          importMenu.add(platformItem);
        }

        AbstractAction action = new AbstractAction(lib.getName()) {
          public void actionPerformed(ActionEvent event) {
            UserLibrary l = (UserLibrary) getValue(""library"");
            try {
              activeEditor.getSketchController().importLibrary(l);
            } catch (IOException e) {
              showWarning(tr(""Error""), format(""Unable to list header files in {0}"", l.getSrcFolder()), e);
            }
          }
        };
        action.putValue(""library"", lib);

        // Add new element at the bottom
        JMenuItem item = new JMenuItem(action);
        item.putClientProperty(""library"", lib);
        importMenu.add(item);
      }",iterator
lib,"for (UserLibrary lib : allLibraries) {
      // Get the library's location - used for sorting into categories
      Location location = lib.getLocation();
      // Is this library compatible?
      List<String> arch = lib.getArchitectures();
      boolean compatible;
      if (myArch == null || arch == null || arch.contains(""*"")) {
        compatible = true;
      } else {
        compatible = arch.contains(myArch);
      }
      // IDE Libaries (including retired)
      if (location == Location.IDE_BUILTIN) {
        if (compatible) {
          // only compatible IDE libs are shown
          if (lib.getTypes().contains(""Retired"")) {
            retiredIdeLibs.add(lib);
          } else {
            ideLibs.add(lib);
          }
        }
      // Platform Libraries
      } else if (location == Location.CORE) {
        // all platform libs are assumed to be compatible
        platformLibs.add(lib);
      // Referenced Platform Libraries
      } else if (location == Location.REFERENCED_CORE) {
        // all referenced platform libs are assumed to be compatible
        referencedPlatformLibs.add(lib);
      // Sketchbook Libraries (including incompatible)
      } else if (location == Location.SKETCHBOOK) {
        if (compatible) {
          // libraries promoted from sketchbook (behave as builtin)
          if (!lib.getTypes().isEmpty() && lib.getTypes().contains(""Arduino"")
              && lib.getArchitectures().contains(""*"")) {
            ideLibs.add(lib);
          } else {
            sketchbookLibs.add(lib);
          }
        } else {
          sketchbookIncompatibleLibs.add(lib);
        }
      // Other libraries of unknown type (should never occur)
      } else {
        otherLibs.add(lib);
      }
    }",iterator
lib,"for (UserLibrary lib : ideLibs) {
      addSketchesSubmenu(menu, lib);
    }",iterator
lib,"for (UserLibrary lib : retiredIdeLibs) {
        addSketchesSubmenu(retired, lib);
      }",iterator
lib,"for (UserLibrary lib : platformLibs) {
        addSketchesSubmenu(menu, lib);
      }",iterator
lib,"for (UserLibrary lib : referencedPlatformLibs) {
        addSketchesSubmenu(menu, lib);
      }",iterator
lib,"for (UserLibrary lib : sketchbookLibs) {
        addSketchesSubmenu(menu, lib);
      }",iterator
lib,"for (UserLibrary lib : sketchbookIncompatibleLibs) {
        addSketchesSubmenu(incompatible, lib);
      }",iterator
lib,"for (UserLibrary lib : otherLibs) {
        addSketchesSubmenu(menu, lib);
      }",iterator
editor,"for (Editor editor : editors) {
          editor.updateKeywords(pdeKeywords);
        }",iterator
editor,"for (Editor editor : editors) {
      editor.onBoardOrPortChange();
    }",iterator
targetPlatform,"for (TargetPlatform targetPlatform : targetPackage.platforms()) {
        for (String customMenuTitle : targetPlatform.getCustomMenus().values()) {
          JMenu customMenu = new JMenu(tr(customMenuTitle));
          customMenu.putClientProperty(""platform"", getPlatformUniqueId(targetPlatform));
          customMenu.putClientProperty(""removeOnWindowDeactivation"", true);
          boardsCustomMenus.add(customMenu);
          MenuScroller.setScrollerFor(customMenu);
        }
      }",iterator
targetPlatform,"for (TargetPlatform targetPlatform : targetPackage.platforms()) {

        // Add a title for each platform
        String platformLabel = targetPlatform.getPreferences().get(""name"");
        if (platformLabel == null)
          platformLabel = targetPackage.getId() + ""-"" + targetPlatform.getId();

        // add an hint that this core lives in sketchbook
        if (targetPlatform.isInSketchbook())
          platformLabel += "" (in sketchbook)"";

        JMenu platformBoardsMenu = new JMenu(platformLabel);
        MenuScroller.setScrollerFor(platformBoardsMenu);
        platformMenus.add(platformBoardsMenu);

        // Cycle through all boards of this platform
        for (TargetBoard board : targetPlatform.getBoards().values()) {
          if (board.getPreferences().get(""hide"") != null)
            continue;
          JMenuItem item = createBoardMenusAndCustomMenus(boardsCustomMenus, menuItemsToClickAfterStartup,
                  buttonGroupsMap,
                  board, targetPlatform, targetPackage);
          platformBoardsMenu.add(item);
          boardsButtonGroup.add(item);
        }
      }",iterator
targetPackage,"for (TargetPackage targetPackage : BaseNoGui.packages.values()) {
      for (TargetPlatform targetPlatform : targetPackage.platforms()) {
        for (String customMenuTitle : targetPlatform.getCustomMenus().values()) {
          JMenu customMenu = new JMenu(tr(customMenuTitle));
          customMenu.putClientProperty(""platform"", getPlatformUniqueId(targetPlatform));
          customMenu.putClientProperty(""removeOnWindowDeactivation"", true);
          boardsCustomMenus.add(customMenu);
          MenuScroller.setScrollerFor(customMenu);
        }
      }
    }",iterator
targetPackage,"for (TargetPackage targetPackage : BaseNoGui.packages.values()) {
      // For every package cycle through all platform
      for (TargetPlatform targetPlatform : targetPackage.platforms()) {

        // Add a title for each platform
        String platformLabel = targetPlatform.getPreferences().get(""name"");
        if (platformLabel == null)
          platformLabel = targetPackage.getId() + ""-"" + targetPlatform.getId();

        // add an hint that this core lives in sketchbook
        if (targetPlatform.isInSketchbook())
          platformLabel += "" (in sketchbook)"";

        JMenu platformBoardsMenu = new JMenu(platformLabel);
        MenuScroller.setScrollerFor(platformBoardsMenu);
        platformMenus.add(platformBoardsMenu);

        // Cycle through all boards of this platform
        for (TargetBoard board : targetPlatform.getBoards().values()) {
          if (board.getPreferences().get(""hide"") != null)
            continue;
          JMenuItem item = createBoardMenusAndCustomMenus(boardsCustomMenus, menuItemsToClickAfterStartup,
                  buttonGroupsMap,
                  board, targetPlatform, targetPackage);
          platformBoardsMenu.add(item);
          boardsButtonGroup.add(item);
        }
      }
    }",iterator
platformMenu,"for (JMenu platformMenu : platformMenus) {
        if (firstBoardItem == null && platformMenu.getItemCount() > 0)
          firstBoardItem = platformMenu.getItem(0);
        boardMenu.add(platformMenu);
      }",iterator
menuItemToClick,"for (JMenuItem menuItemToClick : menuItemsToClickAfterStartup) {
      menuItemToClick.setSelected(true);
      menuItemToClick.getAction().actionPerformed(new ActionEvent(this, -1, """"));
    }",iterator
customMenuTitle,"for (String customMenuTitle : targetPlatform.getCustomMenus().values()) {
          JMenu customMenu = new JMenu(tr(customMenuTitle));
          customMenu.putClientProperty(""platform"", getPlatformUniqueId(targetPlatform));
          customMenu.putClientProperty(""removeOnWindowDeactivation"", true);
          boardsCustomMenus.add(customMenu);
          MenuScroller.setScrollerFor(customMenu);
        }",iterator
board,"for (TargetBoard board : targetPlatform.getBoards().values()) {
          if (board.getPreferences().get(""hide"") != null)
            continue;
          JMenuItem item = createBoardMenusAndCustomMenus(boardsCustomMenus, menuItemsToClickAfterStartup,
                  buttonGroupsMap,
                  board, targetPlatform, targetPackage);
          platformBoardsMenu.add(item);
          boardsButtonGroup.add(item);
        }",iterator
menuId,"for (final String menuId : customMenus.keySet()) {
      String title = customMenus.get(menuId);
      JMenu menu = getBoardCustomMenu(tr(title), getPlatformUniqueId(targetPlatform));

      if (board.hasMenu(menuId)) {
        PreferencesMap boardCustomMenu = board.getMenuLabels(menuId);
        for (String customMenuOption : boardCustomMenu.keySet()) {
          @SuppressWarnings(""serial"")
          Action subAction = new AbstractAction(tr(boardCustomMenu.get(customMenuOption))) {
            public void actionPerformed(ActionEvent e) {
              PreferencesData.set(""custom_"" + menuId, ((List<TargetBoard>) getValue(""board"")).get(0).getId() + ""_"" + getValue(""custom_menu_option""));
              onBoardOrPortChange();
            }
          };
          List<TargetBoard> boards = (List<TargetBoard>) subAction.getValue(""board"");
          if (boards == null) {
            boards = new ArrayList<>();
          }
          boards.add(board);
          subAction.putValue(""board"", boards);
          subAction.putValue(""custom_menu_option"", customMenuOption);

          if (!buttonGroupsMap.containsKey(menuId)) {
            buttonGroupsMap.put(menuId, new ButtonGroup());
          }

          JRadioButtonMenuItem subItem = new JRadioButtonMenuItem(subAction);
          menu.add(subItem);
          buttonGroupsMap.get(menuId).add(subItem);

          String selectedCustomMenuEntry = PreferencesData.get(""custom_"" + menuId);
          if (selBoard.equals(boardId) && (boardId + ""_"" + customMenuOption).equals(selectedCustomMenuEntry)) {
            menuItemsToClickAfterStartup.add(subItem);
          }
        }
      }
    }",iterator
customMenuOption,"for (String customMenuOption : boardCustomMenu.keySet()) {
          @SuppressWarnings(""serial"")
          Action subAction = new AbstractAction(tr(boardCustomMenu.get(customMenuOption))) {
            public void actionPerformed(ActionEvent e) {
              PreferencesData.set(""custom_"" + menuId, ((List<TargetBoard>) getValue(""board"")).get(0).getId() + ""_"" + getValue(""custom_menu_option""));
              onBoardOrPortChange();
            }
          };
          List<TargetBoard> boards = (List<TargetBoard>) subAction.getValue(""board"");
          if (boards == null) {
            boards = new ArrayList<>();
          }
          boards.add(board);
          subAction.putValue(""board"", boards);
          subAction.putValue(""custom_menu_option"", customMenuOption);

          if (!buttonGroupsMap.containsKey(menuId)) {
            buttonGroupsMap.put(menuId, new ButtonGroup());
          }

          JRadioButtonMenuItem subItem = new JRadioButtonMenuItem(subAction);
          menu.add(subItem);
          buttonGroupsMap.get(menuId).add(subItem);

          String selectedCustomMenuEntry = PreferencesData.get(""custom_"" + menuId);
          if (selBoard.equals(boardId) && (boardId + ""_"" + customMenuOption).equals(selectedCustomMenuEntry)) {
            menuItemsToClickAfterStartup.add(subItem);
          }
        }",iterator
i,"for (int i = fromIndex; i < boardsCustomMenus.size(); i++) {
      JMenu menu = boardsCustomMenus.get(i);
      for (int m = 0; m < menu.getItemCount(); m++) {
        JMenuItem menuItem = menu.getItem(m);
        for (TargetBoard t_board : (List<TargetBoard>)menuItem.getAction().getValue(""board"")) {
          menuItem.setVisible(t_board.equals(board));
        }
      }
      menu.setVisible(ifThereAreVisibleItemsOn(menu));

      if (menu.isVisible()) {
        JMenuItem visibleSelectedOrFirstMenuItem = selectVisibleSelectedOrFirstMenuItem(menu);
        if (!visibleSelectedOrFirstMenuItem.isSelected()) {
          visibleSelectedOrFirstMenuItem.setSelected(true);
          visibleSelectedOrFirstMenuItem.getAction().actionPerformed(null);
        }
      }
    }",loop_control
m,"for (int m = 0; m < menu.getItemCount(); m++) {
        JMenuItem menuItem = menu.getItem(m);
        for (TargetBoard t_board : (List<TargetBoard>)menuItem.getAction().getValue(""board"")) {
          menuItem.setVisible(t_board.equals(board));
        }
      }",loop_control
t_board,"for (TargetBoard t_board : (List<TargetBoard>)menuItem.getAction().getValue(""board"")) {
          menuItem.setVisible(t_board.equals(board));
        }",iterator
i,"for (int i = 0; i < menu.getItemCount(); i++) {
      if (menu.getItem(i).isVisible()) {
        return true;
      }
    }",loop_control
menu,"for (int i = 0; i < menu.getItemCount(); i++) {
      if (menu.getItem(i).isVisible()) {
        return true;
      }
    }",break_loop_control
menu,"for (JMenu menu : boardsCustomMenus) {
      if (label.equals(menu.getText()) && menu.getClientProperty(""platform"").equals(platformUniqueId)) {
        return menu;
      }
    }",iterator
label,"for (JMenu menu : boardsCustomMenus) {
      if (label.equals(menu.getText()) && menu.getClientProperty(""platform"").equals(platformUniqueId)) {
        return menu;
      }
    }",break_loop_control
menu,"for (JMenu menu : boardsCustomMenus) {
      if (label.equals(menu.getText()) && menu.getClientProperty(""platform"").equals(platformUniqueId)) {
        return menu;
      }
    }",break_loop_control
i,"for (int i = 0; i < menu.getItemCount(); i++) {
      JMenuItem item = menu.getItem(i);
      if (item != null && item.isVisible()) {
        if (item.isSelected()) {
          return item;
        }
        if (firstVisible == null) {
          firstVisible = item;
        }
      }
    }",loop_control
item,"for (int i = 0; i < menu.getItemCount(); i++) {
      JMenuItem item = menu.getItem(i);
      if (item != null && item.isVisible()) {
        if (item.isSelected()) {
          return item;
        }
        if (firstVisible == null) {
          firstVisible = item;
        }
      }
    }",break_loop_control
programmer,"for (String programmer : platform.getProgrammers().keySet()) {
      String id = platform.getContainerPackage().getId() + "":"" + programmer;

      @SuppressWarnings(""serial"")
      AbstractAction action = new AbstractAction(platform.getProgrammer(programmer).get(""name"")) {
        public void actionPerformed(ActionEvent actionevent) {
          PreferencesData.set(""programmer"", """" + getValue(""id""));
        }
      };
      action.putValue(""id"", id);
      JMenuItem item = new JRadioButtonMenuItem(action);
      if (PreferencesData.get(""programmer"").equals(id)) {
        item.setSelected(true);
      }
      group.add(item);
      menus.add(item);
    }",iterator
subfolder,"for (File subfolder : files) {
      if (!FileUtils.isSCCSOrHiddenFile(subfolder) && subfolder.isDirectory()
          && addSketchesSubmenu(menu, subfolder.getName(), subfolder)) {
        ifound = true;
      }
    }",iterator
lib,"for (UserLibrary lib : list) {
      @SuppressWarnings(""serial"")
      AbstractAction action = new AbstractAction(lib.getName()) {
        public void actionPerformed(ActionEvent event) {
          UserLibrary l = (UserLibrary) getValue(""library"");
          try {
            activeEditor.getSketchController().importLibrary(l);
          } catch (IOException e) {
            showWarning(tr(""Error""), format(""Unable to list header files in {0}"", l.getSrcFolder()), e);
          }
        }
      };
      action.putValue(""library"", lib);

      // Add new element at the bottom
      JMenuItem item = new JMenuItem(action);
      item.putClientProperty(""library"", lib);
      menu.add(item);

      // XXX: DAM: should recurse here so that library folders can be nested
    }",iterator
bytesRead,"{
      input = new FileInputStream(file);
      byte buffer[] = new byte[size];
      int offset = 0;
      int bytesRead;
      while ((bytesRead = input.read(buffer, offset, size - offset)) != -1) {
        offset += bytesRead;
        if (bytesRead == 0) break;
      }
      return buffer;
    }",maybe_loop_control
bytesRead,"{
      input = new FileInputStream(file);
      byte buffer[] = new byte[size];
      int offset = 0;
      int bytesRead;
      while ((bytesRead = input.read(buffer, offset, size - offset)) != -1) {
        offset += bytesRead;
        if (bytesRead == 0) break;
      }
      return buffer;
    }",break_loop_control
i,"for (int i = 0; i < lines.length; i++) {
      int hash = lines[i].indexOf('#');
      String line = (hash == -1) ?
              lines[i].trim() : lines[i].substring(0, hash).trim();
      if (line.length() == 0) continue;

      int equals = line.indexOf('=');
      if (equals == -1) {
        System.err.println(""ignoring illegal line in "" + inputFile);
        System.err.println(""  "" + line);
        continue;
      }
      String attr = line.substring(0, equals).trim();
      String valu = line.substring(equals + 1).trim();
      outgoing.put(attr, valu);
    }",loop_control
bytesRead,"{
      from = new BufferedInputStream(new FileInputStream(sourceFile));
      to = new BufferedOutputStream(new FileOutputStream(targetFile));
      byte[] buffer = new byte[16 * 1024];
      int bytesRead;
      while ((bytesRead = from.read(buffer)) != -1) {
        to.write(buffer, 0, bytesRead);
      }
      to.flush();
    }",maybe_loop_control
i,"for (int i = 0; i < files.length; i++) {
      if (files[i].equals(""."") || (files[i].equals("".."")) ||
              files[i].equals("".DS_Store"")) continue;
      File fella = new File(folder, files[i]);
      if (fella.isDirectory()) {
        size += calcFolderSize(fella);
      } else {
        size += (int) fella.length();
      }
    }",loop_control
base,"{
    while (base.getActiveEditor() == null) {
      try {
        Thread.sleep(1000);
      } catch (InterruptedException e) {
        e.printStackTrace();
      }
    }
    BaseNoGui.addPropertyChangeListener(this);
    checkForNewBoardAttached();
  }",maybe_loop_control
e,"for (Editor e : base.getEditors())
            e.removeWindowFocusListener(this);",iterator
e,"for (Editor e : base.getEditors())
        e.addWindowFocusListener(wfl);",iterator
i,"for (int i = 0; i < exts.length; i++) {
      this.extensions[i] = exts[i].toLowerCase(Locale.ENGLISH);
    }",loop_control
extension,"for (String extension : extensions) {
        if (extension.equals(fileExtension)) {
          return true;
        }
      }",iterator
extension,"for (String extension : extensions) {
        if (extension.equals(fileExtension)) {
          return true;
        }
      }",break_loop_control
file,"for (File file : openFilesEvent.getFiles()) {
              System.out.println(file);
              try {
                Base.INSTANCE.handleOpen(file);
                List<Editor> editors = Base.INSTANCE.getEditors();
                if (editors.size() == 2 && editors.get(0).getSketchController().isUntitled()) {
                  Base.INSTANCE.handleClose(editors.get(0));
                }
              } catch (Exception e) {
                throw new RuntimeException(e);
              }
            }",iterator
slept,"{
    int slept = 0;
    while (Base.INSTANCE == null) {
      if (slept >= MAX_WAIT_FOR_BASE) {
        return false;
      }
      sleep(100);
      slept += 100;
    }
    return true;
  }",break_loop_control
set,"for (int set : sets) {
      Set<AWTKeyStroke> keys = component.getFocusTraversalKeys(set);
      // keys is immutable, so create a new set to allow changes
      keys = new HashSet<>(keys);
      if (set == 0)
        keys.add(ctrlAlt('Z'));

      // If the given keystroke was present in the set, replace it with the
      // updated set with the keystroke removed.
      if (keys.remove(keystroke))
        component.setFocusTraversalKeys(set, keys);
    }",iterator
potentialStep,"for (double potentialStep : new double[]{1.0, 1.5, 2.0, 2.5, 3.0, 4.0, 5.0, 6.0, 8.0, 10.0}) {
      if (potentialStep < rawTickStep) {
        continue;
      }

      tickStep = potentialStep * scale;
      tickMin = tickStep * Math.floor(min / tickStep);
      tickMax = tickMin + tickStep * (tickCount - 1);
      if (tickMax >= max) {
        break;
      }
    }",iterator
tickMax,"for (double potentialStep : new double[]{1.0, 1.5, 2.0, 2.5, 3.0, 4.0, 5.0, 6.0, 8.0, 10.0}) {
      if (potentialStep < rawTickStep) {
        continue;
      }

      tickStep = potentialStep * scale;
      tickMin = tickStep * Math.floor(min / tickStep);
      tickMax = tickMin + tickStep * (tickCount - 1);
      if (tickMax >= max) {
        break;
      }
    }",break_loop_control
tickMax,"{
    double range = max - min;
    double exp;
    if (range == 0.0) {
      exp = 0;
    } else {
      exp = Math.floor(Math.log10(range / (tickCount - 1)));
    }
    double scale = Math.pow(10, exp);

    double rawTickStep = (range / (tickCount - 1)) / scale;
    for (double potentialStep : new double[]{1.0, 1.5, 2.0, 2.5, 3.0, 4.0, 5.0, 6.0, 8.0, 10.0}) {
      if (potentialStep < rawTickStep) {
        continue;
      }

      tickStep = potentialStep * scale;
      tickMin = tickStep * Math.floor(min / tickStep);
      tickMax = tickMin + tickStep * (tickCount - 1);
      if (tickMax >= max) {
        break;
      }
    }

    tickCount -= (int) Math.floor((tickMax - max) / tickStep);
    this.tickCount = tickCount;

    ticks = new double[tickCount];
    for (int i = 0; i < tickCount; ++i) {
      ticks[i] = tickMin + i * tickStep;
    }
  }",break_loop_control
i,"for (int i = 0; i < tickCount; ++i) {
      ticks[i] = tickMin + i * tickStep;
    }",loop_control
i,"for (int i = 1; i < size(); ++i) {
      out = Math.min(out, get(i));
    }",loop_control
i,"for (int i = 1; i < size(); ++i) {
      out = Math.max(out, get(i));
    }",loop_control
newbie,"{
    SketchController sketch = editor.getSketchController();
    
    // first save the sketch so that things don't archive strangely
    boolean success = false;
    try {
      success = sketch.save();
    } catch (Exception e) {
      e.printStackTrace();
    }
    if (!success) {
      Base.showWarning(tr(""Couldn't archive sketch""),
                       tr(""Archiving the sketch has been canceled because\nthe sketch couldn't save properly.""), null);
      return;
    }

    File location = sketch.getSketch().getFolder();
    String name = location.getName();
    File parent = new File(location.getParent());

    //System.out.println(""loc "" + location);
    //System.out.println(""par "" + parent);

    File newbie = null;
    String namely = null;
    int index = 0;
    do {
      // only use the date if the sketch name isn't the default name
      useDate = !name.startsWith(""sketch_"");

      if (useDate) {
        String purty = dateFormat.format(new Date());
        String stamp = purty + ((char) ('a' + index));
        namely = name + ""-"" + stamp;
        newbie = new File(parent, namely + "".zip"");

      } else {
        String diggie = numberFormat.format(index + 1);
        namely = name + ""-"" + diggie;
        newbie = new File(parent, namely + "".zip"");
      }
      index++;
    } while (newbie.exists());

    // open up a prompt for where to save this fella
    FileDialog fd = new FileDialog(editor, tr(""Archive sketch as:""), FileDialog.SAVE);
    fd.setDirectory(parent.getAbsolutePath());
    fd.setFile(newbie.getName());
    fd.setVisible(true);

    String directory = fd.getDirectory();
    String filename = fd.getFile();

    // only write the file if not canceled
    if (filename != null) {
      newbie = new File(directory, filename);

      ZipOutputStream zos = null;
      try {
        //System.out.println(newbie);
        zos = new ZipOutputStream(new FileOutputStream(newbie));

        // recursively fill the zip file
        buildZip(location, name, zos);

        // close up the jar file
        zos.flush();
        editor.statusNotice(""Created archive "" + newbie.getName() + ""."");
      } catch (IOException e) {
        e.printStackTrace();
      } finally {
        IOUtils.closeQuietly(zos);
      }
    } else {
      editor.statusNotice(tr(""Archive sketch canceled.""));
    }
  }",maybe_loop_control
i,"for (int i = 0; i < files.length; i++) {
      if (files[i].equals(""."") ||
          files[i].equals("".."")) continue;

      File sub = new File(dir, files[i]);
      String nowfar = (sofar == null) ?
        files[i] : (sofar + ""/"" + files[i]);

      if (sub.isDirectory()) {
        // directories are empty entries and have / at the end
        ZipEntry entry = new ZipEntry(nowfar + ""/"");
        //System.out.println(entry);
        zos.putNextEntry(entry);
        zos.closeEntry();
        buildZip(sub, nowfar, zos);

      } else {
        ZipEntry entry = new ZipEntry(nowfar);
        entry.setTime(sub.lastModified());
        zos.putNextEntry(entry);
        zos.write(Base.loadBytesRaw(sub));
        zos.closeEntry();
      }
    }",loop_control
i,"for (int i = startLine; i <= stopLine; i++) {
      appendFormattedLine(cf, i);
    }",loop_control
j,"for (int j = 0; j < segmentCount; j++) {
        char c = segmentArray[j + segmentOffset];
        appendToHTML(c, buffer);
      }",loop_control
i,"for (int i = 0; i < sketch.getCodeCount(); i++) {
        SketchFile file = sketch.getFile(i);
        editor.findTab(file).setText(loadWithLocalEncoding(file.getFile()));
      }",loop_control
line,"{
      reader = new BufferedReader(new FileReader(file));

      StringBuffer buffer = new StringBuffer();
      String line;
      while ((line = reader.readLine()) != null) {
        buffer.append(line);
        buffer.append('\n');
      }
      return buffer.toString();
    }",maybe_loop_control
i,"for (int i = 0; i < topFixedCount; i++) {
        menu.add(menuItems[i]);
      }",loop_control
i,"for (int i = firstIndex; i < scrollCount + firstIndex; i++) {
        menu.add(menuItems[i]);
      }",loop_control
i,"for (int i = menuItems.length - bottomFixedCount; i < menuItems.length; i++) {
        menu.add(menuItems[i]);
      }",loop_control
component,"for (Component component : allMenuItems) {
        menu.add(component);
      }",iterator
entries,"{
    String tmpFolderName = folderNameFromZip() + random.nextInt(1000000);

    File tmpFolder = new File(destFolder, tmpFolderName);

    if (!tmpFolder.mkdir()) {
      throw new IOException(""Unable to create folder "" + tmpFolderName);
    }

    Enumeration<? extends ZipEntry> entries = zipFile.entries();
    while (entries.hasMoreElements()) {
      ZipEntry entry = entries.nextElement();
      ensureFoldersOfEntryExist(tmpFolder, entry);
      File entryFile = new File(tmpFolder, entry.getName());
      if (entry.isDirectory()) {
        entryFile.mkdir();
      } else {
        FileOutputStream fos = null;
        InputStream zipInputStream = null;
        try {
          fos = new FileOutputStream(entryFile);
          zipInputStream = zipFile.getInputStream(entry);
          byte[] buffer = new byte[1024 * 4];
          int len = -1;
          while ((len = zipInputStream.read(buffer)) != -1) {
            fos.write(buffer, 0, len);
          }
        } finally {
          IOUtils.closeQuietly(fos);
          IOUtils.closeQuietly(zipInputStream);
        }
      }
    }

    deleteUndesiredFoldersAndFiles(tmpFolder);

    // Test.zip may or may not contain Test folder. If it does, we keep it. If not, we use zip name.
    ensureOneLevelFolder(tmpFolder);
  }",maybe_loop_control
len,"{
          fos = new FileOutputStream(entryFile);
          zipInputStream = zipFile.getInputStream(entry);
          byte[] buffer = new byte[1024 * 4];
          int len = -1;
          while ((len = zipInputStream.read(buffer)) != -1) {
            fos.write(buffer, 0, len);
          }
        }",maybe_loop_control
file,"for (File file : folder.listFiles()) {
      if (file.isDirectory() && ""__MACOSX"".equals(file.getName())) {
        FileUtils.recursiveDelete(file);
      } else if (file.getName().startsWith(""."")) {
        FileUtils.recursiveDelete(file);
      }
    }",iterator
i,"for (int i = 0; i < parts.length - 1; i++) {
      current = new File(current, parts[i]);
      current.mkdir();
    }",loop_control
i,"for (int i = listeners.length - 2; i >= 0; i -= 2) {
        if (listeners[i] == HyperlinkListener.class) {
          ((HyperlinkListener) listeners[i + 1]).hyperlinkUpdate(e);
        }
      }",loop_control
lib,"for (UserLibrary lib : BaseNoGui.librariesIndexer.getInstalledLibraries()) {
        File keywords = new File(lib.getInstalledFolder(), ""keywords.txt"");
        if (keywords.exists()) {
          parseKeywordsTxt(keywords);
        }
      }",iterator
line,"{
      reader = new BufferedReader(new InputStreamReader(new FileInputStream(input)));

      String line;
      while ((line = reader.readLine()) != null) {
        //System.out.println(""line is "" + line);
        // in case there's any garbage on the line
        line = line.trim();
        if (line.length() == 0 || line.startsWith(""#"")) {
          continue;
        }

        String pieces[] = line.split(""\t"");

        String keyword = pieces[0].trim();
        if (keyword.startsWith(""\\#"")) {
          keyword = keyword.replace(""\\#"", ""#"");
        }

        if (pieces.length >= 2) {
          keywordOldToken.put(keyword, pieces[1]);
        }

        if (pieces.length >= 3) {
          parseHTMLReferenceFileName(pieces[2], keyword);
        }
        if (pieces.length >= 4) {
          parseRSyntaxTextAreaTokenType(pieces[3], keyword);
        }
      }

      fillMissingTokenType();
    }",maybe_loop_control
oldTokenEntry,"for (Map.Entry<String, String> oldTokenEntry : keywordOldToken.entrySet()) {
      String keyword = oldTokenEntry.getKey();
      if (!keywordTokenTypeAsString.containsKey(keyword)) {
        if (""KEYWORD1"".equals(oldTokenEntry.getValue())) {
          parseRSyntaxTextAreaTokenType(""DATA_TYPE"", keyword);
        }
        else if (""LITERAL1"".equals(oldTokenEntry.getValue())) {      
          parseRSyntaxTextAreaTokenType(""RESERVED_WORD_2"", keyword);
        }
        else {
          parseRSyntaxTextAreaTokenType(""FUNCTION"", keyword);
        }
      }
    }",iterator
line1,"{

      if (!textArea.isEditable() || !textArea.isEnabled()) {
        UIManager.getLookAndFeel().provideErrorFeedback(textArea);
        return;
      }

      RSyntaxDocument doc = (RSyntaxDocument) textArea.getDocument();
      Element map = doc.getDefaultRootElement();
      Caret c = textArea.getCaret();
      int dot = c.getDot();
      int mark = c.getMark();
      int line1 = map.getElementIndex(dot);
      int line2 = map.getElementIndex(mark);
      int start = Math.min(line1, line2);
      int end = Math.max(line1, line2);

      org.fife.ui.rsyntaxtextarea.Token t = doc.getTokenListForLine(start);
      int languageIndex = t != null ? t.getLanguageIndex() : 0;
      String[] startEnd = doc.getLineCommentStartAndEnd(languageIndex);

      if (startEnd == null) {
        UIManager.getLookAndFeel().provideErrorFeedback(textArea);
        return;
      }

      // Don't toggle comment on last line if there is no
      // text selected on it.
      if (start != end) {
        Element elem = map.getElement(end);
        if (Math.max(dot, mark) == elem.getStartOffset()) {
          end--;
        }
      }

      textArea.beginAtomicEdit();
      try {
        boolean add = getDoAdd(doc, map, start, end, startEnd);
        for (line1 = start; line1 <= end; line1++) {
          Element elem = map.getElement(line1);
          handleToggleComment(elem, doc, startEnd, add);
        }
      } catch (BadLocationException ble) {
        ble.printStackTrace();
        UIManager.getLookAndFeel().provideErrorFeedback(textArea);
      } finally {
        textArea.endAtomicEdit();
      }

    }",loop_control
i,"for (int i = startLine; i <= endLine; i++) {
        Element elem = map.getElement(i);
        int start = elem.getStartOffset();
        String t = doc.getText(start, elem.getEndOffset() - start - 1).trim();
        if (!t.startsWith(startEnd[0]) ||
          (startEnd[1] != null && !t.endsWith(startEnd[1]))) {
          doAdd = true;
          break;
        }
      }",loop_control
t,"for (int i = startLine; i <= endLine; i++) {
        Element elem = map.getElement(i);
        int start = elem.getStartOffset();
        String t = doc.getText(start, elem.getEndOffset() - start - 1).trim();
        if (!t.startsWith(startEnd[0]) ||
          (startEnd[1] != null && !t.endsWith(startEnd[1]))) {
          doAdd = true;
          break;
        }
      }",break_loop_control
t,"for (int i = startLine; i <= endLine; i++) {
        Element elem = map.getElement(i);
        int start = elem.getStartOffset();
        String t = doc.getText(start, elem.getEndOffset() - start - 1).trim();
        if (!t.startsWith(startEnd[0]) ||
          (startEnd[1] != null && !t.endsWith(startEnd[1]))) {
          doAdd = true;
          break;
        }
      }",break_loop_control
e,"for (Enumeration<? extends ZipEntry> e = zipFile.entries(); e.hasMoreElements();) {
            ZipEntry entry = e.nextElement();
            if (entry.getName().endsWith("".class"")) {
                StringWriter sw = new StringWriter();
                // PrintWriter pw = new PrintWriter(sw);

                try (InputStream is = zipFile.getInputStream(entry)) {
                    verify(new ClassReader(ZipUtil.toByteArray(is)));
                }
                Assert.assertTrue(sw.toString(), sw.toString().length() == 0);
            }
        }",maybe_loop_control
f,"for (Path f : files) {
            args.add(f.toAbsolutePath().toString());
        }",iterator
f,"for (File f : files) {
            args.add(f.getCanonicalPath());
        }",iterator
ext,"for (String ext : exts) {
                        if (name.endsWith(ext)) {
                            add = true;
                            break;
                        }
                    }",iterator
name,"{
                    String name = file.getFileName().toString();
                    boolean add = false;
                    for (String ext : exts) {
                        if (name.endsWith(ext)) {
                            add = true;
                            break;
                        }
                    }
                    if (add) {
                        list.add(file);
                    }
                    return super.visitFile(file, attrs);
                }",break_loop_control
j,"for (int j = 0; j < method.instructions.size(); ++j) {
            method.instructions.get(j).accept(mv);

            StringBuffer s = new StringBuffer();
            Frame f = frames[j];
            if (f == null) {
                s.append('?');
            } else {
                for (int k = 0; k < f.getLocals(); ++k) {
                    s.append(getShortName(f.getLocal(k).toString()));
                }
                s.append("" : "");
                for (int k = 0; k < f.getStackSize(); ++k) {
                    s.append(getShortName(f.getStack(k).toString()));
                }
            }
            pw.printf(format, j, s, buf.get(t)); // mv.text.get(j));
        }",loop_control
j,"for (int j = 0; j < method.tryCatchBlocks.size(); ++j) {
            ((TryCatchBlockNode) method.tryCatchBlocks.get(j)).accept(mv);
            pw.print("" "" + buf.get(t));
        }",loop_control
k,"for (int k = 0; k < f.getLocals(); ++k) {
                    s.append(getShortName(f.getLocal(k).toString()));
                }",loop_control
k,"for (int k = 0; k < f.getStackSize(); ++k) {
                    s.append(getShortName(f.getStack(k).toString()));
                }",loop_control
i,"for (int i = 0; i < methods.size(); ++i) {
            MethodNode method = (MethodNode) methods.get(i);

            List tryCatchBlocks = method.tryCatchBlocks;
            for (int j = 0; j < tryCatchBlocks.size(); j++) {
                TryCatchBlockNode tcn = (TryCatchBlockNode) tryCatchBlocks.get(j);
                if (tcn.start.equals(tcn.end)) {
                    throw new DexException(""try/catch block %d in %s has same start(%s) and end(%s)"", j, method.name,
                            tcn.start.getLabel(), tcn.end.getLabel());
                }
            }

            BasicVerifier verifier = new BasicVerifier();
            Analyzer a = new Analyzer(verifier);
            try {
                a.analyze(cn.name, method);
            } catch (Exception e) {
                out.println(cr.getClassName() + ""."" + method.name + method.desc);
                printAnalyzerResult(method, a, out);
                e.printStackTrace(out);
                out.flush();
                throw new DexException(""method "" + method.name + "" "" + method.desc, e);
            }
        }",loop_control
j,"for (int j = 0; j < tryCatchBlocks.size(); j++) {
                TryCatchBlockNode tcn = (TryCatchBlockNode) tryCatchBlocks.get(j);
                if (tcn.start.equals(tcn.end)) {
                    throw new DexException(""try/catch block %d in %s has same start(%s) and end(%s)"", j, method.name,
                            tcn.start.getLabel(), tcn.end.getLabel());
                }
            }",loop_control
f,"for (Path f : TestUtils.listTestDexFiles()) {
                System.out.println(""asmifier file "" + f);
                File distDir = new File(""target"", getBaseName(f.getFileName().toString()) + ""_asmifier.zip"");
                try (FileSystem fs = BaseCmd.createZip(distDir.toPath())) {
                    ASMifierFileV.doFile(f, fs.getPath(""/""));
                }
            }",iterator
f,"for (final Path f : files) {
                final DexFileNode fileNode = readDex(f);
                runners.add(new ParentRunner<DexClassNode>(testClass) {
                    @Override
                    protected List<DexClassNode> getChildren() {
                        return fileNode.clzs;
                    }

                    @Override
                    protected String getName() {
                        return ""d2j ["" + f.toString() + ""]"";
                    }

                    @Override
                    protected Description describeChild(DexClassNode child) {
                        return Description.createTestDescription(testClass, ""c ["" + child.className + ""]"");
                    }

                    @Override
                    protected void runChild(final DexClassNode child, RunNotifier notifier) {
                        runLeaf(new Statement() {
                            @Override
                            public void evaluate() throws Throwable {
                                TestUtils.translateAndCheck(fileNode, child);
                            }
                        }, describeChild(child), notifier);
                    }
                });
            }",iterator
i,"for (int i = 0; i < 2000; i++) {// 2000 insns
            code.visitConstStmt(Op.CONST, i, i);
        }",loop_control
i,"for (int i = 0; i < 18000; i++) {// 18000 insns
            code.visitConstStmt(Op.CONST, 25, i);
        }",loop_control
p,"for (final Path p : files) {

                Smali smali = new Smali();
                final DexFileNode fileNode = new DexFileNode();
                try {
                    smali.smaliFile(p, fileNode);
                } catch (IOException e) {
                    throw new RuntimeException(e);
                }
                runners.add(new ParentRunner<DexClassNode>(testClass) {
                    @Override
                    protected List<DexClassNode> getChildren() {
                        return fileNode.clzs;
                    }

                    @Override
                    protected String getName() {
                        return ""s2j ["" + basePath.relativize(p) + ""]"";
                    }

                    @Override
                    protected Description describeChild(DexClassNode child) {
                        return Description.createTestDescription(testClass, ""["" + child.className + ""]"");
                    }

                    @Override
                    protected void runChild(final DexClassNode child, RunNotifier notifier) {
                        runLeaf(new Statement() {
                            @Override
                            public void evaluate() throws Throwable {
                                if(p.getFileName().toString().contains(""mayfail"")) {
                                    try {
                                        TestUtils.translateAndCheck(fileNode, child);
                                    } catch (Exception ex) {
                                        ex.printStackTrace();
                                    }
                                } else {
                                    TestUtils.translateAndCheck(fileNode, child);
                                }
                            }
                        }, describeChild(child), notifier);
                    }
                });
            }",iterator
ln,"for (String ln : lines) {
            if (!inMethodContent) {
                if (ln.startsWith("".method"")) {
                    // append here to keep the line number
                    sb.append("".class LTT;.super Ljava/lang/Object;"");
                    sb.append(ln);
                    inMethodContent = true;
                    hasMethod = true;
                }
            } else {
                sb.append(ln);
                if (ln.startsWith("".end method"")) {
                    inMethodContent = false;
                }
            }
            sb.append(""\n"");
        }",iterator
ln,"for (String ln : lines) {
            if (!found) {
                if (ln.startsWith("".method"")) {
                    // append here to keep the line number
                    sb.append("".class LTT;.super Ljava/lang/Object;"");
                    sb.append(ln).append(""\n"");
                    found = true;
                } else {
                    sb.append(""\n"");
                }
            } else {
                sb.append(ln).append(""\n"");
            }
        }",iterator
provider,"for (FileSystemProvider provider : FileSystemProvider.installedProviders()) {
                String scheme = provider.getScheme();
                if (scheme.equals(""zip"") || scheme.equals(""jar"")) {
                    zipFSP = provider;
                    break;
                }
            }",iterator
scheme,"for (FileSystemProvider provider : FileSystemProvider.installedProviders()) {
                String scheme = provider.getScheme();
                if (scheme.equals(""zip"") || scheme.equals(""jar"")) {
                    zipFSP = provider;
                    break;
                }
            }",break_loop_control
p,"for (final Path p : files) {
                Map<String, ?> env = new HashMap<>();
                try (FileSystem fs = zipFSP.newFileSystem(p, env)) {
                    List<Path> methods = Files.walk(fs.getPath(""/""))
                            .filter(Files::isReadable)
                            .filter(Files::isRegularFile)
                            .filter(px -> {
                                String fn = px.getFileName().toString();
                                return fn.startsWith(""m-"") && fn.endsWith("".txt"") || fn.equals(""summary.txt"");
                            })
                            .collect(Collectors.toList());

                    for (Path m : methods) {
                        processEachEntry(testClass, runners, p.getFileName().toString(), m);
                    }
                } catch (Exception e) {
                    throw new RuntimeException(e);
                }
            }",iterator
m,"for (Path m : methods) {
                        processEachEntry(testClass, runners, p.getFileName().toString(), m);
                    }",iterator
m,"for (DexMethodNode m : classNode.methods) {
                                    DexClassNode sub = new DexClassNode(0, ""Lx;"", ""Ly;"", new String[0]);
                                    sub.methods.add(m);
                                    TestUtils.translateAndCheck(null, sub);
                                }",iterator
f,"for (Path f : TestUtils.listPath(dir, "".class"")) {
                String name = getBaseName(f.getFileName().toString());

                int i = name.indexOf('$');
                String z = i > 0 ? name.substring(0, i) : name;
                FileSet fs = m.get(z);
                if (fs == null) {
                    fs = new FileSet();
                    fs.name = z;
                    m.put(z, fs);
                }
                fs.files.add(f);
            }",iterator
classNode,"for (DexClassNode classNode : fileNode.clzs) {
                        TestUtils.translateAndCheck(fileNode, classNode);
                    }",iterator
i,"for (int i = 0; i < 5; i++) {
            ++count;
        }",loop_control
i,"for (int i = 0; i < ret.length; i++) {
            char h = d[2 * i];
            char l = d[2 * i + 1];
            int hh = 0;
            if (h >= '0' && h <= '9') {
                hh = h - '0';
            } else if (h >= 'a' && h <= 'f') {
                hh = h - 'a' + 10;
            } else if (h >= 'A' && h <= 'F') {
                hh = h - 'A' + 10;
            } else {
                throw new RuntimeException();
            }
            int ll = 0;
            if (l >= '0' && l <= '9') {
                ll = h - '0';
            } else if (l >= 'a' && l <= 'f') {
                ll = h - 'a' + 10;
            } else if (l >= 'A' && l <= 'F') {
                ll = h - 'A' + 10;
            } else {
                throw new RuntimeException();
            }
            d[i] = (char) ((hh << 4) | ll);
        }",loop_control
ann,"for (DexAnnotationNode ann : anns) {
                if (ann.visibility != Visibility.SYSTEM) {
                    accept(ann, cv);
                }
            }",iterator
ann,"for (DexAnnotationNode ann : anns) {
                if (ann.visibility != Visibility.SYSTEM) {
                    accept(ann, fv);
                }
            }",iterator
ann,"for (DexAnnotationNode ann : anns) {
                if (ann.visibility != Visibility.SYSTEM) {
                    accept(ann, mv);
                }
            }",iterator
item,"for (DexAnnotationNode.Item item : items) {
            accept(av, item.name, item.value);
        }",iterator
e,"for (Object e : array) {
                    accept(arrayVisitor, null, e);
                }",iterator
item,"for (DexAnnotationNode.Item item : ann.items) {
                    accept(av, item.name, item.value);
                }",iterator
ann,"for (DexAnnotationNode ann : methodNode.anns) {
                if (ann.visibility == Visibility.SYSTEM) {
                    switch (ann.type) {
                    case DexConstants.ANNOTATION_THROWS_TYPE: {
                        Object[] strs = (Object[]) findAnnotationAttribute(ann, ""value"");
                        if (strs != null) {
                            xthrows = new String[strs.length];
                            for (int i = 0; i < strs.length; i++) {
                                DexType type = (DexType) strs[i];
                                xthrows[i] = toInternalName(type);
                            }
                        }
                    }
                        break;
                    case DexConstants.ANNOTATION_SIGNATURE_TYPE: {
                        Object[] strs = (Object[]) findAnnotationAttribute(ann, ""value"");
                        if (strs != null) {
                            StringBuilder sb = new StringBuilder();
                            for (Object str : strs) {
                                sb.append(str);
                            }
                            signature = sb.toString();
                        }
                    }
                        break;
                    }
                }
            }",iterator
i,"for (int i = 0; i < strs.length; i++) {
                                DexType type = (DexType) strs[i];
                                xthrows[i] = toInternalName(type);
                            }",loop_control
str,"for (Object str : strs) {
                                sb.append(str);
                            }",iterator
classNode,"for (DexClassNode classNode : fileNode.clzs) {
            Clz clz = get(classes, classNode.className);
            clz.access = (clz.access & ~ACC_INTERFACE_ABSTRACT) | classNode.access;
            if (classNode.anns != null) {
                for (DexAnnotationNode ann : classNode.anns) {
                    if (ann.visibility == Visibility.SYSTEM) {
                        switch (ann.type) {
                        case DexConstants.ANNOTATION_ENCLOSING_CLASS_TYPE: {
                            DexType type = (DexType) findAnnotationAttribute(ann, ""value"");
                            Clz enclosingClass = get(classes, type.desc);
                            clz.enclosingClass = enclosingClass;

                            // apply patch from ChaeHoon Lim,
                            // obfuscated code may declare itself as enclosing class
                            // which cause dex2jar to endless loop
                            //if(!clz.name.equals(clz.enclosingClass.name)) {
                            //    enclosingClass.addInner(clz);
                            //}
                            enclosingClass.addInner(clz);

                        }
                            break;
                        case DexConstants.ANNOTATION_ENCLOSING_METHOD_TYPE: {
                            Method m = (Method) findAnnotationAttribute(ann, ""value"");
                            Clz enclosingClass = get(classes, m.getOwner());
                            clz.enclosingClass = enclosingClass;
                            clz.enclosingMethod = m;
                            enclosingClass.addInner(clz);
                        }
                            break;
                        case DexConstants.ANNOTATION_INNER_CLASS_TYPE: {
                            for (DexAnnotationNode.Item it : ann.items) {
                                if (""accessFlags"".equals(it.name)) {
                                    clz.access |= (Integer) it.value & ~ACC_INTERFACE_ABSTRACT;
                                } else if (""name"".equals(it.name)) {
                                    clz.innerName = (String) it.value;
                                }
                            }
                        }
                            break;
                        case DexConstants.ANNOTATION_MEMBER_CLASSES_TYPE: {
                            Object ts[] = (Object[]) findAnnotationAttribute(ann, ""value"");
                            for (Object v : ts) {
                                DexType type = (DexType) v;
                                Clz inner = get(classes, type.desc);
                                clz.addInner(inner);
                                inner.enclosingClass = clz;
                            }
                        }
                            break;
                        }
                    }
                }
            }
        }",iterator
it,"for (DexAnnotationNode.Item it : ann.items) {
                                if (""accessFlags"".equals(it.name)) {
                                    clz.access |= (Integer) it.value & ~ACC_INTERFACE_ABSTRACT;
                                } else if (""name"".equals(it.name)) {
                                    clz.innerName = (String) it.value;
                                }
                            }",iterator
ann,"for (DexAnnotationNode ann : classNode.anns) {
                    if (ann.visibility == Visibility.SYSTEM) {
                        switch (ann.type) {
                        case DexConstants.ANNOTATION_ENCLOSING_CLASS_TYPE: {
                            DexType type = (DexType) findAnnotationAttribute(ann, ""value"");
                            Clz enclosingClass = get(classes, type.desc);
                            clz.enclosingClass = enclosingClass;

                            // apply patch from ChaeHoon Lim,
                            // obfuscated code may declare itself as enclosing class
                            // which cause dex2jar to endless loop
                            //if(!clz.name.equals(clz.enclosingClass.name)) {
                            //    enclosingClass.addInner(clz);
                            //}
                            enclosingClass.addInner(clz);

                        }
                            break;
                        case DexConstants.ANNOTATION_ENCLOSING_METHOD_TYPE: {
                            Method m = (Method) findAnnotationAttribute(ann, ""value"");
                            Clz enclosingClass = get(classes, m.getOwner());
                            clz.enclosingClass = enclosingClass;
                            clz.enclosingMethod = m;
                            enclosingClass.addInner(clz);
                        }
                            break;
                        case DexConstants.ANNOTATION_INNER_CLASS_TYPE: {
                            for (DexAnnotationNode.Item it : ann.items) {
                                if (""accessFlags"".equals(it.name)) {
                                    clz.access |= (Integer) it.value & ~ACC_INTERFACE_ABSTRACT;
                                } else if (""name"".equals(it.name)) {
                                    clz.innerName = (String) it.value;
                                }
                            }
                        }
                            break;
                        case DexConstants.ANNOTATION_MEMBER_CLASSES_TYPE: {
                            Object ts[] = (Object[]) findAnnotationAttribute(ann, ""value"");
                            for (Object v : ts) {
                                DexType type = (DexType) v;
                                Clz inner = get(classes, type.desc);
                                clz.addInner(inner);
                                inner.enclosingClass = clz;
                            }
                        }
                            break;
                        }
                    }
                }",iterator
v,"for (Object v : ts) {
                                DexType type = (DexType) v;
                                Clz inner = get(classes, type.desc);
                                clz.addInner(inner);
                                inner.enclosingClass = clz;
                            }",iterator
i,"for (int i = 1; i < str.length(); i++) {
            if (!Character.isJavaIdentifierPart(str.charAt(i))) {
                return false;
            }
        }",loop_control
ann,"for (DexAnnotationNode ann : classNode.anns) {
                if (ann.visibility == Visibility.SYSTEM) {
                    switch (ann.type) {
                    case DexConstants.ANNOTATION_SIGNATURE_TYPE: {
                        Object[] strs = (Object[]) findAnnotationAttribute(ann, ""value"");
                        if (strs != null) {
                            StringBuilder sb = new StringBuilder();
                            for (Object str : strs) {
                                sb.append(str);
                            }
                            signature = sb.toString();
                        }
                    }
                        break;
                    }
                }
            }",iterator
str,"for (Object str : strs) {
                                sb.append(str);
                            }",iterator
i,"for (int i = 0; i < classNode.interfaceNames.length; i++) {
                interfaceInterNames[i] = toInternalName(classNode.interfaceNames[i]);
            }",loop_control
icn,"for (InnerClassNode icn : innerClassNodes) {
            if (icn.innerName != null && !isJavaIdentifier(icn.innerName)) {
                System.err.println(""WARN: ignored invalid inner class name "" + "", treat as anonymous inner class."");
                icn.innerName = null;
                icn.outerName = null;
            }
            icn.accept(cv);
        }",iterator
fieldNode,"for (DexFieldNode fieldNode : classNode.fields) {
                convertField(classNode, fieldNode, cv);
            }",iterator
methodNode,"for (DexMethodNode methodNode : classNode.methods) {
                convertMethod(classNode, methodNode, cv, clzCtx);
            }",iterator
classNode,"for (DexClassNode classNode : fileNode.clzs) {
                convertClass(fileNode, classNode, cvf, classes);
            }",iterator
ann,"for (DexAnnotationNode ann : fieldNode.anns) {
                if (ann.visibility == Visibility.SYSTEM) {
                    switch (ann.type) {
                    case DexConstants.ANNOTATION_SIGNATURE_TYPE: {
                        Object[] strs = (Object[]) findAnnotationAttribute(ann, ""value"");
                        if (strs != null) {
                            StringBuilder sb = new StringBuilder();
                            for (Object str : strs) {
                                sb.append(str);
                            }
                            signature = sb.toString();
                        }
                    }
                        break;
                    }
                }
            }",iterator
str,"for (Object str : strs) {
                                sb.append(str);
                            }",iterator
i,"for (int i = 0; i < copy.length; i++) {
            Object ele = copy[i];
            ele = convertConstantValue(ele);
            copy[i] = ele;
        }",loop_control
ann,"for (DexAnnotationNode ann : classNode.anns) {
                    if (ann.visibility == Visibility.SYSTEM && ann.type.equals(DexConstants.ANNOTATION_DEFAULT_TYPE)) {
                        DexAnnotationNode node = (DexAnnotationNode) findAnnotationAttribute(ann, ""value"");
                        if (node != null) {
                            defaultValue = findAnnotationAttribute(node, methodNode.method.getName());
                        }
                        break;
                    }
                }",iterator
ann,"for (DexAnnotationNode ann : anns) {
                        if (ann.visibility != Visibility.SYSTEM) {
                            acceptParameter(ann, i, mv);
                        }
                    }",iterator
i,"for (int i = 0; i < methodNode.parameterAnns.length; i++) {
                List<DexAnnotationNode> anns = methodNode.parameterAnns[i];
                if (anns != null) {
                    for (DexAnnotationNode ann : anns) {
                        if (ann.visibility != Visibility.SYSTEM) {
                            acceptParameter(ann, i, mv);
                        }
                    }
                }
            }",loop_control
ann,"for (DexAnnotationNode ann : classNode.anns) {
                    if (ann.visibility == Visibility.SYSTEM && ann.type.equals(DexConstants.ANNOTATION_DEFAULT_TYPE)) {
                        DexAnnotationNode node = (DexAnnotationNode) findAnnotationAttribute(ann, ""value"");
                        if (node != null) {
                            defaultValue = findAnnotationAttribute(node, methodNode.method.getName());
                        }
                        break;
                    }
                }",iterator
ann,"for (DexAnnotationNode ann : anns) {
                        if (ann.visibility != Visibility.SYSTEM) {
                            acceptParameter(ann, i, mv);
                        }
                    }",iterator
item,"for (DexAnnotationNode.Item item : ann.items) {
            if (item.name.equals(name)) {
                return item.value;
            }
        }",iterator
p,"for (Clz p = clz; p != null; p = p.enclosingClass) {
            if (!visitedClz.add(p)) { // prevent endless loop
                break;
            }
            Clz enclosingClass = p.enclosingClass;
            if (enclosingClass == null) {
                break;
            }
            if (enclosingClass == clz) {
                // enclosing itself, that is impossible
                break;
            }
            int accessInInner = clearInnerAccess(p.access);
            if (p.innerName != null) {// non-anonymous Innerclass
                innerClassNodes.add(new InnerClassNode(toInternalName(p.name),
                        toInternalName(enclosingClass.name), p.innerName, accessInInner));
            } else {// anonymous Innerclass
                innerClassNodes.add(new InnerClassNode(toInternalName(p.name), null, null, accessInInner));
            }
        }",maybe_loop_control
visitedClz,"{
        Set<Clz> visitedClz = new HashSet<>();
        for (Clz p = clz; p != null; p = p.enclosingClass) {
            if (!visitedClz.add(p)) { // prevent endless loop
                break;
            }
            Clz enclosingClass = p.enclosingClass;
            if (enclosingClass == null) {
                break;
            }
            if (enclosingClass == clz) {
                // enclosing itself, that is impossible
                break;
            }
            int accessInInner = clearInnerAccess(p.access);
            if (p.innerName != null) {// non-anonymous Innerclass
                innerClassNodes.add(new InnerClassNode(toInternalName(p.name),
                        toInternalName(enclosingClass.name), p.innerName, accessInInner));
            } else {// anonymous Innerclass
                innerClassNodes.add(new InnerClassNode(toInternalName(p.name), null, null, accessInInner));
            }
        }
    }",break_loop_control
enclosingClass,"for (Clz p = clz; p != null; p = p.enclosingClass) {
            if (!visitedClz.add(p)) { // prevent endless loop
                break;
            }
            Clz enclosingClass = p.enclosingClass;
            if (enclosingClass == null) {
                break;
            }
            if (enclosingClass == clz) {
                // enclosing itself, that is impossible
                break;
            }
            int accessInInner = clearInnerAccess(p.access);
            if (p.innerName != null) {// non-anonymous Innerclass
                innerClassNodes.add(new InnerClassNode(toInternalName(p.name),
                        toInternalName(enclosingClass.name), p.innerName, accessInInner));
            } else {// anonymous Innerclass
                innerClassNodes.add(new InnerClassNode(toInternalName(p.name), null, null, accessInInner));
            }
        }",break_loop_control
stack,"{
        Set<Clz> visited = new HashSet<>();
        Stack<Clz> stack = new Stack<>();
        stack.push(clz);
        while (!stack.empty()) {
            clz = stack.pop();
            if (visited.contains(clz)) {
                continue;
            } else {
                visited.add(clz);
            }
            if (clz.inners != null) {
                for (Clz inner : clz.inners) {
                    if (inner.innerName == null) {// anonymous Innerclass
                        innerClassNodes.add(new InnerClassNode(toInternalName(inner.name), null, null,
                                clearInnerAccess(inner.access)));
                    } else {// non-anonymous Innerclass
                        innerClassNodes.add(new InnerClassNode(toInternalName(inner.name), toInternalName(className),
                                inner.innerName, clearInnerAccess(inner.access)));
                    }
                    stack.push(inner);
                }
            }
        }
    }",maybe_loop_control
inner,"for (Clz inner : clz.inners) {
                    if (inner.innerName == null) {// anonymous Innerclass
                        innerClassNodes.add(new InnerClassNode(toInternalName(inner.name), null, null,
                                clearInnerAccess(inner.access)));
                    } else {// non-anonymous Innerclass
                        innerClassNodes.add(new InnerClassNode(toInternalName(inner.name), toInternalName(className),
                                inner.innerName, clearInnerAccess(inner.access)));
                    }
                    stack.push(inner);
                }",iterator
classNode,"for (DexClassNode classNode : dex.clzs) {
                fixStaticFinalFieldValue(classNode);
            }",iterator
fn,"for (DexFieldNode fn : classNode.fields) {
            if ((fn.access & ACC_STATIC_FINAL) == ACC_STATIC_FINAL) {
                if (fn.cst == null) {
                    char t = fn.field.getType().charAt(0);
                    if (t == 'L' || t == '[') {
                        // ignore Object
                        continue;
                    }
                    fs.put(fn.field.getName() + "":"" + fn.field.getType(), fn);
                } else if (isPrimitiveZero(fn.field.getType(), fn.cst)) {
                    shouldNotBeAssigned.put(fn.field.getName() + "":"" + fn.field.getType(), fn);
                }
            }
        }",iterator
fn,"for (DexFieldNode fn : fs.values()) {
            fn.cst = getDefaultValueOfType(fn.field.getType().charAt(0));
        }",iterator
mn,"for (DexMethodNode mn : classNode.methods) {
                if (mn.method.getName().equals(""<clinit>"")) {
                    node = mn;
                    break;
                }
            }",iterator
mn,"for (DexMethodNode mn : classNode.methods) {
                if (mn.method.getName().equals(""<clinit>"")) {
                    node = mn;
                    break;
                }
            }",break_loop_control
fn,"for (DexFieldNode fn : classNode.fields) {
            if ((fn.access & ACC_STATIC_FINAL) == ACC_STATIC_FINAL) {
                if (fn.cst == null) {
                    char t = fn.field.getType().charAt(0);
                    if (t == 'L' || t == '[') {
                        // ignore Object
                        continue;
                    }
                    fs.put(fn.field.getName() + "":"" + fn.field.getType(), fn);
                } else if (isPrimitiveZero(fn.field.getType(), fn.cst)) {
                    shouldNotBeAssigned.put(fn.field.getName() + "":"" + fn.field.getType(), fn);
                }
            }
        }",iterator
fn,"for (DexFieldNode fn : fs.values()) {
            fn.cst = getDefaultValueOfType(fn.field.getType().charAt(0));
        }",iterator
p,"for (Stmt p : irMethod.stmts) {
                        if (p.st == Stmt.ST.LABEL) {
                            LabelStmt labelStmt = (LabelStmt) p;
                            labelStmt.displayName = ""L"" + i++;
                        }
                    }",iterator
p,"for (FileSystemProvider p : FileSystemProvider.installedProviders()) {
            String s = p.getScheme();
            if (""jar"".equals(s) || ""zip"".equalsIgnoreCase(s)) {
                return p.newFileSystem(output, env);
            }
        }",iterator
s,"for (FileSystemProvider p : FileSystemProvider.installedProviders()) {
            String s = p.getScheme();
            if (""jar"".equals(s) || ""zip"".equalsIgnoreCase(s)) {
                return p.newFileSystem(output, env);
            }
        }",break_loop_control
t,"for (String t : m.getParameterTypes()) {
            switch (t.charAt(0)) {
            case 'J':
            case 'D':
                a += 2;
                break;
            default:
                a += 1;
                break;
            }
        }",iterator
t,"for (String t : m.getParameterTypes()) {
            switch (t.charAt(0)) {
            case 'J':
            case 'D':
                a += 2;
                break;
            default:
                a += 1;
                break;
            }
        }",break_loop_control
i,"for (int i = 0; i < locals.length; i++) {
            locals[i] = new Local(i);
        }",loop_control
i,"for (int i = 0; i < args.length; i++) {
            String t = args[i];
            x(Stmts.nIdentity(locals[nextReg], Exprs.nParameterRef(t, i)));
            nextReg++;
            if (t.equals(""J"") || t.equals(""D"")) {
                nextReg++;
            }
        }",loop_control
i,"for (int i = 0; i < nextReg0; i++) {
            x(Stmts.nAssign(locals[i], nInt(0)));
        }",loop_control
i,"for (int i = 0; i < args.length; i++) {
            list.add(nAssign(nArray(array, nInt(i), elem), locals[args[i]]));
        }",loop_control
i,"for (int i = 0; i < cases.length; i++) {
            lss[i] = toLabelStmt(labels[i]);
        }",loop_control
t,"for (String t : method.getParameterTypes()) {
                ps.add(locals[args[i]]);
                if (t.equals(""J"") || t.equals(""D"")) {
                    i += 2;
                } else {
                    i++;
                }
            }",iterator
i,"for (int i = 0; i < labels.length; i++) {
            lss[i] = toLabelStmt(labels[i]);
        }",loop_control
i,"for (int i = 0; i < types.length; i++) {
            xlabelStmts[i] = toLabelStmt(handlers[i]);
        }",loop_control
n,"for (TryCatchNode n : codeNode.tryStmts) {
                n.accept(this);
            }",iterator
n,"for (DexStmtNode n : codeNode.stmts) {
            n.accept(this);
            if (n instanceof FilledNewArrayStmtNode) {
                lastIsInvokeOrFilledNewArray = true;
            } else if (n instanceof MethodStmtNode) {
                lastIsInvokeOrFilledNewArray = !((MethodStmtNode) n).method.getReturnType().equals(""V"");
            } else if (!(n instanceof DexLabelStmtNode)) {
                lastIsInvokeOrFilledNewArray = false;
            }
        }",iterator
p,"for (Stmt p : ir.stmts) {
            if (p.st == ST.LABEL) {
                LabelStmt labelStmt = (LabelStmt) p;
                labelStmt.tag = new Label();
            }
        }",iterator
trap,"for (Trap trap : ir.traps) {
            boolean needAdd = false;
            for (Stmt p = trap.start.getNext(); p != null && p != trap.end; p = p.getNext()) {
                if (p.st != ST.LABEL) {
                    needAdd = true;
                    break;
                }
            }
            if (needAdd) {
                for (int i = 0; i < trap.handlers.length; i++) {
                    String type = trap.types[i];
                    asm.visitTryCatchBlock((Label) trap.start.tag, (Label) trap.end.tag, (Label) trap.handlers[i].tag,
                            type == null ? null : toInternal(type));
                }
            }
        }",iterator
p,"for (Stmt p = trap.start.getNext(); p != null && p != trap.end; p = p.getNext()) {
                if (p.st != ST.LABEL) {
                    needAdd = true;
                    break;
                }
            }",maybe_loop_control
p,"for (Stmt p = trap.start.getNext(); p != null && p != trap.end; p = p.getNext()) {
                if (p.st != ST.LABEL) {
                    needAdd = true;
                    break;
                }
            }",break_loop_control
i,"for (int i = 0; i < trap.handlers.length; i++) {
                    String type = trap.types[i];
                    asm.visitTryCatchBlock((Label) trap.start.tag, (Label) trap.end.tag, (Label) trap.handlers[i].tag,
                            type == null ? null : toInternal(type));
                }",loop_control
local,"for (Local local : ir.locals) {
            maxLocalIndex = Math.max(maxLocalIndex, local._ls_index);
        }",iterator
local,"{
                case LOCAL:

                    Local local = ((Local) v1);
                    int i = local._ls_index;

                    boolean skipOrg = false;
                    if (v2.vt == VT.LOCAL && (i == ((Local) v2)._ls_index)) {// check for a=a
                        skipOrg = true;
                    } else if (v1.valueType.charAt(0) == 'I') {// check for IINC
                        if (v2.vt == VT.ADD) {
                            if (isLocalWithIndex(v2.getOp1(), i) && v2.getOp2().vt == VT.CONSTANT) { // a=a+1;
                                int increment = (Integer) ((Constant) v2.getOp2()).value;
                                if (increment >= Short.MIN_VALUE && increment <= Short.MAX_VALUE) {
                                    asm.visitIincInsn(i, increment);
                                    skipOrg = true;
                                }
                            } else if (isLocalWithIndex(v2.getOp2(), i) && v2.getOp1().vt == VT.CONSTANT) { // a=1+a;
                                int increment = (Integer) ((Constant) v2.getOp1()).value;
                                if (increment >= Short.MIN_VALUE && increment <= Short.MAX_VALUE) {
                                    asm.visitIincInsn(i, increment);
                                    skipOrg = true;
                                }
                            }
                        } else if (v2.vt == VT.SUB) {
                            if (isLocalWithIndex(v2.getOp1(), i) && v2.getOp2().vt == VT.CONSTANT) { // a=a-1;
                                int increment = -(Integer) ((Constant) v2.getOp2()).value;
                                if (increment >= Short.MIN_VALUE && increment <= Short.MAX_VALUE) {
                                    asm.visitIincInsn(i, increment);
                                    skipOrg = true;
                                }
                            }
                        }
                    }
                    if (!skipOrg) {
                        accept(v2, asm);
                        if (i >= 0) {
                            asm.visitVarInsn(getOpcode(v1, ISTORE), i);
                        } else if (!v1.valueType.equals(""V"")) { // skip void type locals
                            switch (v1.valueType.charAt(0)) {
                            case 'J':
                            case 'D':
                                asm.visitInsn(POP2);
                                break;
                            default:
                                asm.visitInsn(POP);
                                break;
                            }
                        }
                    }
                    break;
                case STATIC_FIELD: {
                    StaticFieldExpr fe = (StaticFieldExpr) v1;
                    accept(v2, asm);
                    insertI2x(v2.valueType, fe.type, asm);
                    asm.visitFieldInsn(PUTSTATIC, toInternal(fe.owner), fe.name, fe.type);
                    break;
                }
                case FIELD: {
                    FieldExpr fe = (FieldExpr) v1;
                    accept(fe.op, asm);
                    accept(v2, asm);
                    insertI2x(v2.valueType, fe.type, asm);
                    asm.visitFieldInsn(PUTFIELD, toInternal(fe.owner), fe.name, fe.type);
                    break;
                }
                case ARRAY:
                    ArrayExpr ae = (ArrayExpr) v1;
                    accept(ae.op1, asm);
                    accept(ae.op2, asm);
                    accept(v2, asm);
                    String tp1 = ae.op1.valueType;
                    String tp2 = ae.valueType;
                    if (tp1.charAt(0) == '[') {
                        String arrayElementType = tp1.substring(1);
                        insertI2x(v2.valueType, arrayElementType, asm);
                        asm.visitInsn(getOpcode(arrayElementType, IASTORE));
                    } else {
                        asm.visitInsn(getOpcode(tp2, IASTORE));
                    }
                    break;
                }",iterator
i,"{
                case LOCAL:

                    Local local = ((Local) v1);
                    int i = local._ls_index;

                    boolean skipOrg = false;
                    if (v2.vt == VT.LOCAL && (i == ((Local) v2)._ls_index)) {// check for a=a
                        skipOrg = true;
                    } else if (v1.valueType.charAt(0) == 'I') {// check for IINC
                        if (v2.vt == VT.ADD) {
                            if (isLocalWithIndex(v2.getOp1(), i) && v2.getOp2().vt == VT.CONSTANT) { // a=a+1;
                                int increment = (Integer) ((Constant) v2.getOp2()).value;
                                if (increment >= Short.MIN_VALUE && increment <= Short.MAX_VALUE) {
                                    asm.visitIincInsn(i, increment);
                                    skipOrg = true;
                                }
                            } else if (isLocalWithIndex(v2.getOp2(), i) && v2.getOp1().vt == VT.CONSTANT) { // a=1+a;
                                int increment = (Integer) ((Constant) v2.getOp1()).value;
                                if (increment >= Short.MIN_VALUE && increment <= Short.MAX_VALUE) {
                                    asm.visitIincInsn(i, increment);
                                    skipOrg = true;
                                }
                            }
                        } else if (v2.vt == VT.SUB) {
                            if (isLocalWithIndex(v2.getOp1(), i) && v2.getOp2().vt == VT.CONSTANT) { // a=a-1;
                                int increment = -(Integer) ((Constant) v2.getOp2()).value;
                                if (increment >= Short.MIN_VALUE && increment <= Short.MAX_VALUE) {
                                    asm.visitIincInsn(i, increment);
                                    skipOrg = true;
                                }
                            }
                        }
                    }
                    if (!skipOrg) {
                        accept(v2, asm);
                        if (i >= 0) {
                            asm.visitVarInsn(getOpcode(v1, ISTORE), i);
                        } else if (!v1.valueType.equals(""V"")) { // skip void type locals
                            switch (v1.valueType.charAt(0)) {
                            case 'J':
                            case 'D':
                                asm.visitInsn(POP2);
                                break;
                            default:
                                asm.visitInsn(POP);
                                break;
                            }
                        }
                    }
                    break;
                case STATIC_FIELD: {
                    StaticFieldExpr fe = (StaticFieldExpr) v1;
                    accept(v2, asm);
                    insertI2x(v2.valueType, fe.type, asm);
                    asm.visitFieldInsn(PUTSTATIC, toInternal(fe.owner), fe.name, fe.type);
                    break;
                }
                case FIELD: {
                    FieldExpr fe = (FieldExpr) v1;
                    accept(fe.op, asm);
                    accept(v2, asm);
                    insertI2x(v2.valueType, fe.type, asm);
                    asm.visitFieldInsn(PUTFIELD, toInternal(fe.owner), fe.name, fe.type);
                    break;
                }
                case ARRAY:
                    ArrayExpr ae = (ArrayExpr) v1;
                    accept(ae.op1, asm);
                    accept(ae.op2, asm);
                    accept(v2, asm);
                    String tp1 = ae.op1.valueType;
                    String tp2 = ae.valueType;
                    if (tp1.charAt(0) == '[') {
                        String arrayElementType = tp1.substring(1);
                        insertI2x(v2.valueType, arrayElementType, asm);
                        asm.visitInsn(getOpcode(arrayElementType, IASTORE));
                    } else {
                        asm.visitInsn(getOpcode(tp2, IASTORE));
                    }
                    break;
                }",loop_control
i,"for (int i = 0; i < arraySize; i++) {
                            asm.visitInsn(DUP);
                            asm.visitLdcInsn(i);
                            asm.visitLdcInsn(Array.get(arrayData, i));
                            asm.visitInsn(iastoreOP);
                        }",loop_control
i,"for (int i = 0; i < arraySize; i++) {
                            asm.visitInsn(DUP);
                            asm.visitLdcInsn(i);
                            accept(filledArrayExpr.ops[i], asm);
                            asm.visitInsn(iastoreOP);
                        }",loop_control
i,"for (int i = 0; i < targets.length; i++) {
                    targets[i] = (Label) lss.targets[i].tag;
                }",loop_control
i,"for (int i = 0; i < targets.length; i++) {
                    targets[i] = (Label) tss.targets[i].tag;
                }",loop_control
i,"for (int i = 0; i < cst.length(); i += 65500) {
                int a = Math.min(65500, cst.length() - i);
                asm.visitLdcInsn(cst.substring(i, i + a));
                asm.visitMethodInsn(Opcodes.INVOKEVIRTUAL, ""java/lang/StringBuilder"",
                        ""append"",
                        ""(Ljava/lang/String;)Ljava/lang/StringBuilder;"",
                        false
                );
            }",loop_control
b,"for (byte b : data) {
            sb.append(String.format(""%02x"", b & 0xFF));
        }",iterator
i,"for (int i = 0; i < fae.ops.length; i++) {
                if (fae.ops[i] == null)
                    continue;
                asm.visitInsn(DUP);
                asm.visitLdcInsn(i);
                accept(fae.ops[i], asm);
                String tp2 = fae.ops[i].valueType;
                if (elementType != null) {
                    insertI2x(tp2, elementType, asm);
                }
                asm.visitInsn(xastore);
            }",loop_control
i,"for (int i = 0; i < nmae.dimension; i++) {
                sb.append('[');
            }",loop_control
i,"{
            InvokeExpr ie = (InvokeExpr) value;
            int i = 0;
            if (value.vt != VT.INVOKE_STATIC && value.vt != VT.INVOKE_NEW) {
                i = 1;
                accept(value.ops[0], asm);
            }
            for (int j = 0; i < value.ops.length; i++, j++) {
                Value vb = value.ops[i];
                accept(vb, asm);
                insertI2x(vb.valueType, ie.getArgs()[j], asm);
            }

            int opcode;
            switch (value.vt) {
            case INVOKE_VIRTUAL:
                opcode = INVOKEVIRTUAL;
                break;
            case INVOKE_INTERFACE:
                opcode = INVOKEINTERFACE;
                break;
            case INVOKE_NEW:
            case INVOKE_SPECIAL:
                opcode = INVOKESPECIAL;
                break;
            case INVOKE_STATIC:
                opcode = INVOKESTATIC;
                break;
            default:
                opcode = -1;
            }

            Proto p = ie.getProto();
            if (ie.vt == VT.INVOKE_NEW) {
                p = new Proto(p.getParameterTypes(), ""V"");
            }
            asm.visitMethodInsn(opcode, toInternal(ie.getOwner()), ie.getName(), p.getDesc());
        }",loop_control
i,"for (int i = 0; i < vbs.length; i++) {
                    Value vb = vbs[i];
                    accept(vb, asm);
                    insertI2x(vb.valueType, argTypes[i], asm);
                }",loop_control
i,"for (int i = 1; i < vbs.length; i++) {
                    Value vb = vbs[i];
                    accept(vb, asm);
                    insertI2x(vb.valueType, argTypes[i - 1], asm);
                }",loop_control
i,"for (int i = 1; i < vbs.length; i++) {
                Value vb = vbs[i];
                accept(vb, asm);
                insertI2x(vb.valueType, argTypes[i - 1], asm);
            }",loop_control
vb,"for (Value vb : value.ops) {
                accept(vb, asm);
            }",iterator
vb,"for (int j = 0; i < value.ops.length; i++, j++) {
                Value vb = value.ops[i];
                accept(vb, asm);
                insertI2x(vb.valueType, ie.getArgs()[j], asm);
            }",iterator
vb,"for (int i = 0; i < vbs.length; i++) {
                    Value vb = vbs[i];
                    accept(vb, asm);
                    insertI2x(vb.valueType, argTypes[i], asm);
                }",iterator
vb,"for (int i = 1; i < vbs.length; i++) {
                    Value vb = vbs[i];
                    accept(vb, asm);
                    insertI2x(vb.valueType, argTypes[i - 1], asm);
                }",iterator
vb,"for (int i = 1; i < vbs.length; i++) {
                Value vb = vbs[i];
                accept(vb, asm);
                insertI2x(vb.valueType, argTypes[i - 1], asm);
            }",iterator
j,"for (int j = 0; i < value.ops.length; i++, j++) {
                Value vb = value.ops[i];
                accept(vb, asm);
                insertI2x(vb.valueType, ie.getArgs()[j], asm);
            }",loop_control
i,"for (int i = 0, opsLength = ops.length; i < opsLength; i++) {
                    Value op = ops[i];
                    Constant cst = (Constant) op;
                    d[i] = ((Number) cst.value).byteValue();
                }",loop_control
i,"for (int i = 0, opsLength = ops.length; i < opsLength; i++) {
                    Value op = ops[i];
                    Constant cst = (Constant) op;
                    d[i] = ((Number) cst.value).shortValue();
                }",loop_control
i,"for (int i = 0, opsLength = ops.length; i < opsLength; i++) {
                    Value op = ops[i];
                    Constant cst = (Constant) op;
                    d[i] = ((Number) cst.value).intValue();
                }",loop_control
i,"for (int i = 0, opsLength = ops.length; i < opsLength; i++) {
                    Value op = ops[i];
                    Constant cst = (Constant) op;
                    d[i] = ((Number) cst.value).longValue();
                }",loop_control
op,"for (Value op : ops) {
            if (op.vt != VT.CONSTANT) {
                return false;
            }
        }",iterator
s,"for (String s : args) {
            i += sizeofType(s);
        }",iterator
i,"for (int i = 0; i < insnList.size(); i++) {
            DexStmtNode stmtNode = insnList.get(i);
            stmtNode.__index = i;
            if (stmtNode instanceof DexLabelStmtNode) {
                DexLabelStmtNode dexLabelStmtNode = (DexLabelStmtNode) stmtNode;
                labelMap.put(dexLabelStmtNode.label, dexLabelStmtNode);
            }
        }",loop_control
i,"for (int i = 0; i < insnList.size(); i++) {
            DexStmtNode p = insnList.get(i);
            if (access.get(i)) {
                List<Stmt> es = emitStmts[i];
                if (es != null) {
                    stmts.addAll(es);
                }
            } else {
                if (p instanceof DexLabelStmtNode) {
                    stmts.add(getLabel(((DexLabelStmtNode) p).label));
                }
            }
        }",loop_control
i,"for (int i = 0; i < frames.length; i++) {
            Dex2IrFrame frame = frames[i];
            if (parentCount[i] > 1 && frame != null && access.get(i)) {
                DexStmtNode p = insnList.get(i);
                LabelStmt labelStmt = getLabel(((DexLabelStmtNode) p).label);
                List<AssignStmt> phis = new ArrayList<>();
                for (int j = 0; j < frame.getTotalRegisters(); j++) {
                    DvmValue v = frame.getReg(j);
                    addPhi(v, phiValues, phis);
                }

                labelStmt.phis = phis;
                phiLabels.add(labelStmt);
            }
        }",loop_control
i1,"for (int i1 = 0; i1 < frames.length; i1++) {
            Dex2IrFrame frame = frames[i1];
            if (parentCount[i1] > 1 && frame != null && access.get(i1)) {
                for (int j = 0; j < frame.getTotalRegisters(); j++) {
                    DvmValue v = frame.getReg(j);
                    addToQueue(queue, v);
                }
            }

        }",loop_control
j,"for (int j = 0; j < frame.getTotalRegisters(); j++) {
                    DvmValue v = frame.getReg(j);
                    addToQueue(queue, v);
                }",loop_control
j,"for (int j = 0; j < frame.getTotalRegisters(); j++) {
                    DvmValue v = frame.getReg(j);
                    addPhi(v, phiValues, phis);
                }",loop_control
tcb,"for (TryCatchNode tcb : dexCodeNode.tryStmts) {
            for (DexLabel h : tcb.handler) {
                int index = indexOf(h);
                q.add(index + 1); // add the next insn after label
                handlers.add(index);
            }
        }",iterator
tcb,"for (TryCatchNode tcb : dexCodeNode.tryStmts) {
                DexLabel[] handler = tcb.handler;
                for (int i = 0; i < handler.length; i++) {
                    DexLabel h = handler[i];
                    int index = indexOf(h);
                    if (needChange.containsKey(index)) {
                        DexLabel n = needChange.get(index);
                        if (n == null) {
                            n = new DexLabel();
                            needChange.put(index, n);
                            DexLabelStmtNode dexStmtNode = new DexLabelStmtNode(n);
                            dexStmtNode.__index = insnList.size();
                            insnList.add(dexStmtNode);
                            labelMap.put(n, dexStmtNode);
                            JumpStmtNode jumpStmtNode = new JumpStmtNode(Op.GOTO, 0, 0, h);
                            jumpStmtNode.__index = insnList.size();
                            insnList.add(jumpStmtNode);
                        }
                        handler[i] = n;
                    }
                }
            }",iterator
h,"for (DexLabel h : tcb.handler) {
                int index = indexOf(h);
                q.add(index + 1); // add the next insn after label
                handlers.add(index);
            }",iterator
h,"for (int i = 0; i < handler.length; i++) {
                    DexLabel h = handler[i];
                    int index = indexOf(h);
                    if (needChange.containsKey(index)) {
                        DexLabel n = needChange.get(index);
                        if (n == null) {
                            n = new DexLabel();
                            needChange.put(index, n);
                            DexLabelStmtNode dexStmtNode = new DexLabelStmtNode(n);
                            dexStmtNode.__index = insnList.size();
                            insnList.add(dexStmtNode);
                            labelMap.put(n, dexStmtNode);
                            JumpStmtNode jumpStmtNode = new JumpStmtNode(Op.GOTO, 0, 0, h);
                            jumpStmtNode.__index = insnList.size();
                            insnList.add(jumpStmtNode);
                        }
                        handler[i] = n;
                    }
                }",iterator
i,"for (int i = 0; i < handler.length; i++) {
                    DexLabel h = handler[i];
                    int index = indexOf(h);
                    if (needChange.containsKey(index)) {
                        DexLabel n = needChange.get(index);
                        if (n == null) {
                            n = new DexLabel();
                            needChange.put(index, n);
                            DexLabelStmtNode dexStmtNode = new DexLabelStmtNode(n);
                            dexStmtNode.__index = insnList.size();
                            insnList.add(dexStmtNode);
                            labelMap.put(n, dexStmtNode);
                            JumpStmtNode jumpStmtNode = new JumpStmtNode(Op.GOTO, 0, 0, h);
                            jumpStmtNode.__index = insnList.size();
                            insnList.add(jumpStmtNode);
                        }
                        handler[i] = n;
                    }
                }",loop_control
q,"{
        if (dexCodeNode.tryStmts == null) {
            return;
        }
        Queue<Integer> q = new LinkedList<>();
        Set<Integer> handlers = new TreeSet<>();
        for (TryCatchNode tcb : dexCodeNode.tryStmts) {
            for (DexLabel h : tcb.handler) {
                int index = indexOf(h);
                q.add(index + 1); // add the next insn after label
                handlers.add(index);
            }
        }

        q.add(0);

        Map<Integer, DexLabel> needChange = new HashMap<>();

        BitSet access = new BitSet(insnList.size());
        while (!q.isEmpty()) {
            Integer key = q.poll();
            int index = key;
            if (access.get(index)) {
                continue;
            } else {
                access.set(index);
            }
            if (handlers.contains(key)) { // the cfg goes to a exception handler
                needChange.put(key, null);
            }
            DexStmtNode node = insnList.get(key);
            if (node.op == null) {
                q.add(index + 1);
            } else {
                Op op = node.op;
                if (op.canContinue()) {
                    q.add(index + 1);
                }
                if (op.canBranch()) {
                    JumpStmtNode jump = (JumpStmtNode) node;
                    q.add(indexOf(jump.label));
                }
                if (op.canSwitch()) {
                    for (DexLabel dexLabel : ((BaseSwitchStmtNode) node).labels) {
                        q.add(indexOf(dexLabel));
                    }
                }
            }
        }

        if (needChange.size() > 0) {
            for (TryCatchNode tcb : dexCodeNode.tryStmts) {
                DexLabel[] handler = tcb.handler;
                for (int i = 0; i < handler.length; i++) {
                    DexLabel h = handler[i];
                    int index = indexOf(h);
                    if (needChange.containsKey(index)) {
                        DexLabel n = needChange.get(index);
                        if (n == null) {
                            n = new DexLabel();
                            needChange.put(index, n);
                            DexLabelStmtNode dexStmtNode = new DexLabelStmtNode(n);
                            dexStmtNode.__index = insnList.size();
                            insnList.add(dexStmtNode);
                            labelMap.put(n, dexStmtNode);
                            JumpStmtNode jumpStmtNode = new JumpStmtNode(Op.GOTO, 0, 0, h);
                            jumpStmtNode.__index = insnList.size();
                            insnList.add(jumpStmtNode);
                        }
                        handler[i] = n;
                    }
                }
            }
        }
    }",maybe_loop_control
h,"for (DexLabel h : tcb.handler) {
                    handlers.set(indexOf(h));
                }",iterator
h,"for (DexLabel h : tcb.handler) {
                            int hIndex = indexOf(h);
                            x.set(hIndex);
                            parentCount[hIndex]++;
                        }",iterator
tcb,"for (TryCatchNode tcb : dexCodeNode.tryStmts) {
                for (DexLabel h : tcb.handler) {
                    handlers.set(indexOf(h));
                }
                boolean hasEx = false;
                int endIndex = indexOf(tcb.end);
                for (int p = indexOf(tcb.start) + 1; p < endIndex; p++) {
                    DexStmtNode stmt = insnList.get(p);
                    if (stmt.op != null && stmt.op.canThrow()) {
                        hasEx = true;
                        BitSet x = exBranch[p];
                        if (x == null) {
                            x = exBranch[p] = new BitSet(insnList.size());
                        }
                        for (DexLabel h : tcb.handler) {
                            int hIndex = indexOf(h);
                            x.set(hIndex);
                            parentCount[hIndex]++;
                        }
                    }
                }
                if (hasEx) {
                    target.traps.add(new Trap(getLabel(tcb.start), getLabel(tcb.end), getLabels(tcb.handler),
                            tcb.type));
                }
            }",iterator
p,"for (int p = indexOf(tcb.start) + 1; p < endIndex; p++) {
                    DexStmtNode stmt = insnList.get(p);
                    if (stmt.op != null && stmt.op.canThrow()) {
                        hasEx = true;
                        BitSet x = exBranch[p];
                        if (x == null) {
                            x = exBranch[p] = new BitSet(insnList.size());
                        }
                        for (DexLabel h : tcb.handler) {
                            int hIndex = indexOf(h);
                            x.set(hIndex);
                            parentCount[hIndex]++;
                        }
                    }
                }",loop_control
v2,"for (DvmValue v2 : v.otherParent) {
                        phiValues.add(getLocal(v2));
                    }",iterator
v,"{
        if (v != null) {
            if (v.local != null) {
                if (v.parent != null) {
                    if (v.parent.local == null) {
                        queue.add(v.parent);
                    }
                }
                if (v.otherParent != null) {
                    for (DvmValue v2 : v.otherParent) {
                        if (v2.local == null) {
                            queue.add(v2);
                        }
                    }
                }
            }
        }
    }",iterator
stack,"{
        currentEmit = preEmit;

        Dex2IrFrame first = initFirstFrame(dexCodeNode, target);
        if (parentCount[0] > 1) {
            merge(first, 0);
        } else {
            frames[0] = first;
        }
        Stack<DexStmtNode> stack = new Stack<>();
        stack.push(insnList.get(0));
        Dex2IrFrame tmp = new Dex2IrFrame(dexCodeNode.totalRegister);


        while (!stack.isEmpty()) {
            DexStmtNode p = stack.pop();
            int index = p.__index;
            if (!access.get(index)) {
                access.set(index);
            } else {
                continue;
            }
            Dex2IrFrame frame = frames[index];
            setCurrentEmit(index);

            if (p instanceof DexLabelStmtNode) {
                emit(getLabel(((DexLabelStmtNode) p).label));
                if (handlers.get(index)) {
                    Local ex = newLocal();
                    emit(Stmts.nIdentity(ex, Exprs.nExceptionRef(""Ljava/lang/Throwable;"")));
                    frame.setTmp(new DvmValue(ex));
                }
            }
            BitSet ex = exBranch[index];
            if (ex != null) {
                for (int i = ex.nextSetBit(0); i >= 0; i = ex.nextSetBit(i + 1)) {
                    merge(frame, i);
                    stack.push(insnList.get(i));
                }
            }

            tmp.init(frame);
            try {
                if (p.op != null) {
                    switch (p.op) {
                        case RETURN_VOID:
                            emit(nReturnVoid());
                            break;
                        case GOTO:
                        case GOTO_16:
                        case GOTO_32:
                            emit(nGoto(getLabel(((JumpStmtNode) p).label)));
                            break;
                        case NOP:
                            emit(nNop());
                            break;
                        case BAD_OP:
                            emit(nThrow(nInvokeNew(new Value[]{nString(""bad dex opcode"")}, new String[]{
                                            ""Ljava/lang/String;""},
                                    ""Ljava/lang/VerifyError;"")));
                            break;
                        default:
                            tmp.execute(p, interpreter);
                            break;
                    }
                }
            } catch (Exception exception) {
                throw new RuntimeException(""Fail on Op "" + p.op + "" index "" + index, exception);
            }


            if (p.op != null) {
                Op op = p.op;
                if (op.canBranch()) {
                    JumpStmtNode jump = (JumpStmtNode) p;
                    int targetIndex = indexOf(jump.label);
                    stack.push(insnList.get(targetIndex));
                    merge(tmp, targetIndex);
                }
                if (op.canSwitch()) {
                    BaseSwitchStmtNode switchStmtNode = (BaseSwitchStmtNode) p;
                    for (DexLabel label : switchStmtNode.labels) {
                        int targetIndex = indexOf(label);
                        stack.push(insnList.get(targetIndex));
                        merge(tmp, targetIndex);
                    }
                }
                if (op.canContinue()) {
                    stack.push(insnList.get(index + 1));
                    merge(tmp, index + 1);
                }
            } else {

                stack.push(insnList.get(index + 1));
                merge(tmp, index + 1);

            }
            // cleanup frame it is useless
            if (parentCount[index] <= 1) {
                frames[index] = null;
            }

        }

    }",maybe_loop_control
i,"for (int i = ex.nextSetBit(0); i >= 0; i = ex.nextSetBit(i + 1)) {
                    merge(frame, i);
                    stack.push(insnList.get(i));
                }",loop_control
label,"{
                emit(getLabel(((DexLabelStmtNode) p).label));
                if (handlers.get(index)) {
                    Local ex = newLocal();
                    emit(Stmts.nIdentity(ex, Exprs.nExceptionRef(""Ljava/lang/Throwable;"")));
                    frame.setTmp(new DvmValue(ex));
                }
            }",iterator
label,"{
                        case RETURN_VOID:
                            emit(nReturnVoid());
                            break;
                        case GOTO:
                        case GOTO_16:
                        case GOTO_32:
                            emit(nGoto(getLabel(((JumpStmtNode) p).label)));
                            break;
                        case NOP:
                            emit(nNop());
                            break;
                        case BAD_OP:
                            emit(nThrow(nInvokeNew(new Value[]{nString(""bad dex opcode"")}, new String[]{
                                            ""Ljava/lang/String;""},
                                    ""Ljava/lang/VerifyError;"")));
                            break;
                        default:
                            tmp.execute(p, interpreter);
                            break;
                    }",iterator
label,"{
                    JumpStmtNode jump = (JumpStmtNode) p;
                    int targetIndex = indexOf(jump.label);
                    stack.push(insnList.get(targetIndex));
                    merge(tmp, targetIndex);
                }",iterator
label,"for (DexLabel label : switchStmtNode.labels) {
                        int targetIndex = indexOf(label);
                        stack.push(insnList.get(targetIndex));
                        merge(tmp, targetIndex);
                    }",iterator
i,"for (int i = 0; i < src.getTotalRegisters(); i++) {
                DvmValue p = src.getReg(i);
                DvmValue q = distFrame.getReg(i);
                if (p != null) {
                    if (q == null) {
                        q = new DvmValue();
                        distFrame.setReg(i, q);
                    }
                    relate(p, q);
                }
            }",loop_control
i,"for (int i = 0; i < target.args.length; i++) {
            Local p = newLocal();
            emit(Stmts.nIdentity(p, Exprs.nParameterRef(target.args[i], i)));
            first.setReg(x, new DvmValue(p));
            x += sizeofType(target.args[i]);
        }",loop_control
i,"for (int i = 0; i < first.getTotalRegisters(); i++) {
                if (first.getReg(i) == null) {
                    Local p = newLocal();
                    emit(nAssign(p, nInt(0)));
                    first.setReg(i, new DvmValue(p));
                }
            }",loop_control
i,"for (int i = 0; i < labels.length; i++) {
                            lss[i] = getLabel(labels[i]);
                        }",loop_control
i,"for (int i = 0; i < values.size(); i++) {
                            emit(nAssign(nArray(getLocal(value), nInt(i), elem), getLocal(values.get(i))));
                        }",loop_control
i,"for (int i = 0; i < vs.length; i++) {
                            vs[i] = getLocal(values.get(i));
                        }",loop_control
i,"for (int i = 0; i < vs.length; i++) {
                            vs[i] = getLocal(values.get(i));
                        }",loop_control
i,"for (int i = 0; i < vs.length; i++) {
                            vs[i] = getLocal(values.get(i));
                        }",loop_control
i,"for (int i = 0; i < handler.length; i++) {
            ts[i] = getLabel(handler[i]);
        }",loop_control
p,"for (DexStmtNode p : insnList) {
            Op op = p.op;
            if (op == null) {
                if (p.__index < parentCount.length - 1) { // not the last label
                    parentCount[p.__index + 1]++;
                }
            } else {
                if (op.canBranch()) {
                    parentCount[indexOf(((JumpStmtNode) p).label)]++;
                }
                if (op.canSwitch()) {
                    BaseSwitchStmtNode switchStmtNode = (BaseSwitchStmtNode) p;
                    for (DexLabel label : switchStmtNode.labels) {
                        parentCount[indexOf(label)]++;
                    }
                }
                if (op.canContinue()) {
                    parentCount[p.__index + 1]++;
                }
            }
        }",iterator
label,"{
                    parentCount[indexOf(((JumpStmtNode) p).label)]++;
                }",iterator
label,"for (DexLabel label : switchStmtNode.labels) {
                        parentCount[indexOf(label)]++;
                    }",iterator
i,"for (int i = 0; i < args.length; i++) {
            sArgs[i] = args[i].getDescriptor();
        }",loop_control
tcb,"for (TryCatchBlockNode tcb : methodNode.tryCatchBlocks) {
                target.traps.add(new Trap(getLabel(tcb.start), getLabel(tcb.end), new LabelStmt[]{getLabel(tcb.handler)},
                        new String[]{tcb.type == null ? null : Type.getObjectType(tcb.type).getDescriptor()}));
                int handlerIdx = insnList.indexOf(tcb.handler);
                handlers.set(handlerIdx);

                for (AbstractInsnNode p = tcb.start.getNext(); p != tcb.end; p = p.getNext()) {

                    BitSet x = exBranch[insnList.indexOf(p)];
                    if (x == null) {
                        x = exBranch[insnList.indexOf(p)] = new BitSet(insnList.size());
                    }
                    x.set(handlerIdx);
                    parentCount[handlerIdx]++;
                }
            }",iterator
p,"for (AbstractInsnNode p = tcb.start.getNext(); p != tcb.end; p = p.getNext()) {

                    BitSet x = exBranch[insnList.indexOf(p)];
                    if (x == null) {
                        x = exBranch[insnList.indexOf(p)] = new BitSet(insnList.size());
                    }
                    x.set(handlerIdx);
                    parentCount[handlerIdx]++;
                }",maybe_loop_control
p,"for (int i = 0; i < insnList.size(); i++) {
            AbstractInsnNode p = insnList.get(i);
            if (access.get(i)) {
                List<Stmt> es = emitStmts[i];
                if (es != null) {
                    stmts.addAll(es);
                }
            } else {
                if (p.getType() == AbstractInsnNode.LABEL) {
                    stmts.add(getLabel((LabelNode) p));
                }
            }
        }",maybe_loop_control
p,"{
                AbstractInsnNode p = insnList.get(i);
                LabelStmt labelStmt = getLabel((LabelNode) p);
                List<AssignStmt> phis = new ArrayList<>();
                for (int j = 0; j < frame.getLocals(); j++) {
                    JvmValue v = frame.getLocal(j);
                    addPhi(v, phiValues, phis);
                }
                for (int j = 0; j < frame.getStackSize(); j++) {
                    addPhi(frame.getStack(j), phiValues, phis);
                }
                labelStmt.phis = phis;
                phiLabels.add(labelStmt);
            }",maybe_loop_control
i,"for (int i = 0; i < insnList.size(); i++) {
            AbstractInsnNode p = insnList.get(i);
            if (access.get(i)) {
                List<Stmt> es = emitStmts[i];
                if (es != null) {
                    stmts.addAll(es);
                }
            } else {
                if (p.getType() == AbstractInsnNode.LABEL) {
                    stmts.add(getLabel((LabelNode) p));
                }
            }
        }",loop_control
i,"for (int i = 0; i < frames.length; i++) {
            JvmFrame frame = frames[i];
            if (parentCount[i] > 1 && frame != null && access.get(i)) {
                AbstractInsnNode p = insnList.get(i);
                LabelStmt labelStmt = getLabel((LabelNode) p);
                List<AssignStmt> phis = new ArrayList<>();
                for (int j = 0; j < frame.getLocals(); j++) {
                    JvmValue v = frame.getLocal(j);
                    addPhi(v, phiValues, phis);
                }
                for (int j = 0; j < frame.getStackSize(); j++) {
                    addPhi(frame.getStack(j), phiValues, phis);
                }
                labelStmt.phis = phis;
                phiLabels.add(labelStmt);
            }
        }",loop_control
j,"for (int j = 0; j < frame.getLocals(); j++) {
                    JvmValue v = frame.getLocal(j);
                    addToQueue(queue, v);
                }",loop_control
j,"for (int j = 0; j < frame.getStackSize(); j++) {
                    addToQueue(queue, frame.getStack(j));
                }",loop_control
j,"for (int j = 0; j < frame.getLocals(); j++) {
                    JvmValue v = frame.getLocal(j);
                    addPhi(v, phiValues, phis);
                }",loop_control
j,"for (int j = 0; j < frame.getStackSize(); j++) {
                    addPhi(frame.getStack(j), phiValues, phis);
                }",loop_control
v2,"for (JvmValue v2 : v.otherParent) {
                        phiValues.add(getLocal(v2));
                    }",iterator
v2,"for (JvmValue v2 : v.otherParent) {
                        if (v2.local == null) {
                            queue.add(v2);
                        }
                    }",iterator
stack,"{
        currentEmit = preEmit;
        JvmFrame first = initFirstFrame(methodNode, target);
        if (parentCount[0] > 1) {
            merge(first, 0);
        } else {
            frames[0] = first;
        }
        Stack<AbstractInsnNode> stack = new Stack<>();
        stack.push(insnList.getFirst());

        JvmFrame tmp = new JvmFrame(methodNode.maxLocals, methodNode.maxStack);

        while (!stack.isEmpty()) {
            AbstractInsnNode p = stack.pop();
            int index = insnList.indexOf(p);
            if (!access.get(index)) {
                access.set(index);
            } else {
                continue;
            }
            JvmFrame frame = frames[index];
            setCurrentEmit(index);

            if (p.getType() == AbstractInsnNode.LABEL) {
                emit(getLabel((LabelNode) p));
                if (handlers.get(index)) {
                    Local ex = newLocal();
                    emit(Stmts.nIdentity(ex, Exprs.nExceptionRef(""Ljava/lang/Throwable;"")));
                    frame.clearStack();
                    frame.push(new JvmValue(1, ex));
                }
            }
            BitSet ex = exBranch[index];
            if (ex != null) {
                for (int i = ex.nextSetBit(0); i >= 0; i = ex.nextSetBit(i + 1)) {
                    mergeEx(frame, i);
                    stack.push(insnList.get(i));
                }
            }

            tmp.init(frame);
            tmp.execute(p, interpreter);

            int op = p.getOpcode();
            if (p.getType() == AbstractInsnNode.JUMP_INSN) {
                JumpInsnNode jump = (JumpInsnNode) p;
                stack.push(jump.label);
                merge(tmp, insnList.indexOf(jump.label));
            }

            if (op == Opcodes.TABLESWITCH || op == Opcodes.LOOKUPSWITCH) {
                if (op == Opcodes.TABLESWITCH) {
                    TableSwitchInsnNode tsin = (TableSwitchInsnNode) p;
                    for (LabelNode label : tsin.labels) {
                        stack.push(label);
                        merge(tmp, insnList.indexOf(label));
                    }
                    stack.push(tsin.dflt);
                    merge(tmp, insnList.indexOf(tsin.dflt));

                } else {
                    LookupSwitchInsnNode lsin = (LookupSwitchInsnNode) p;
                    for (LabelNode label : lsin.labels) {
                        stack.push(label);
                        merge(tmp, insnList.indexOf(label));
                    }
                    stack.push(lsin.dflt);
                    merge(tmp, insnList.indexOf(lsin.dflt));
                }
            }
            if ((op >= Opcodes.GOTO && op <= Opcodes.RETURN) || op == Opcodes.ATHROW) {
                // can't continue
            } else {
                stack.push(p.getNext());
                merge(tmp, index + 1);
            }

            // cleanup frame it is useless
            if (parentCount[index] <= 1) {
                frames[index] = null;
            }

        }
    }",maybe_loop_control
label,"{
                JumpInsnNode jump = (JumpInsnNode) p;
                stack.push(jump.label);
                merge(tmp, insnList.indexOf(jump.label));
            }",iterator
label,"for (LabelNode label : tsin.labels) {
                        stack.push(label);
                        merge(tmp, insnList.indexOf(label));
                    }",iterator
label,"for (LabelNode label : lsin.labels) {
                        stack.push(label);
                        merge(tmp, insnList.indexOf(label));
                    }",iterator
p,"for (AbstractInsnNode p = insnList.getFirst(); p != null; p = p.getNext()) {
            if (p.getType() == AbstractInsnNode.JUMP_INSN) {
                JumpInsnNode jump = (JumpInsnNode) p;
                parentCount[insnList.indexOf(jump.label)]++;
            }
            int op = p.getOpcode();
            if (op == Opcodes.TABLESWITCH || op == Opcodes.LOOKUPSWITCH) {
                if (op == Opcodes.TABLESWITCH) {
                    TableSwitchInsnNode tsin = (TableSwitchInsnNode) p;
                    for (LabelNode label : tsin.labels) {
                        parentCount[insnList.indexOf(label)]++;
                    }
                    parentCount[insnList.indexOf(tsin.dflt)]++;
                } else {
                    LookupSwitchInsnNode lsin = (LookupSwitchInsnNode) p;
                    for (LabelNode label : lsin.labels) {
                        parentCount[insnList.indexOf(label)]++;
                    }
                    parentCount[insnList.indexOf(lsin.dflt)]++;
                }
            }
            if ((op >= Opcodes.GOTO && op <= Opcodes.RETURN) || op == Opcodes.ATHROW) {
                // can't continue
            } else {
                AbstractInsnNode next = p.getNext();
                if(next!=null) {
                    parentCount[insnList.indexOf(p.getNext())]++;
                }
            }
        }",maybe_loop_control
label,"{
                JumpInsnNode jump = (JumpInsnNode) p;
                parentCount[insnList.indexOf(jump.label)]++;
            }",iterator
label,"for (LabelNode label : tsin.labels) {
                        parentCount[insnList.indexOf(label)]++;
                    }",iterator
label,"for (LabelNode label : lsin.labels) {
                        parentCount[insnList.indexOf(label)]++;
                    }",iterator
i,"for (int i = 0; i < src.getLocals(); i++) {
            JvmValue p = src.getLocal(i);
            JvmValue q = distFrame.getLocal(i);
            if (p != null) {
                if (q == null) {
                    q = new JvmValue(p.getSize());
                    distFrame.setLocal(i, q);
                }
                relate(p, q);
            }
        }",loop_control
i,"for (int i = 0; i < src.getLocals(); i++) {
                JvmValue p = src.getLocal(i);
                JvmValue q = distFrame.getLocal(i);
                if (p != null) {
                    if (q == null) {
                        q = new JvmValue(p.getSize());
                        distFrame.setLocal(i, q);
                    }
                    relate(p, q);
                }
            }",loop_control
i,"for (int i = 0; i < src.getStackSize(); i++) {
                        distFrame.push(new JvmValue(src.getStack(i).getSize()));
                    }",loop_control
i,"for (int i = 0; i < src.getStackSize(); i++) {
                    JvmValue p = src.getStack(i);
                    JvmValue q = distFrame.getStack(i);
                    relate(p, q);
                }",loop_control
i,"for (int i = 0; i < target.args.length; i++) {
            Local p = newLocal();
            emit(Stmts.nIdentity(p, Exprs.nParameterRef(target.args[i], i)));
            int sizeOfType = sizeOfType(target.args[i]);
            first.setLocal(x, new JvmValue(sizeOfType, p));
            x += sizeOfType;
        }",loop_control
i,"{
        List<String> list = new ArrayList<>(5);
        if (desc == null) {
            return list;
        }
        char[] chars = desc.toCharArray();
        int i = 0;
        while (i < chars.length) {
            switch (chars[i]) {
            case 'V':
            case 'Z':
            case 'C':
            case 'B':
            case 'S':
            case 'I':
            case 'F':
            case 'J':
            case 'D':
                list.add(Character.toString(chars[i]));
                i++;
                break;
            case '[': {
                int count = 1;
                while (chars[i + count] == '[') {
                    count++;
                }
                if (chars[i + count] == 'L') {
                    count++;
                    while (chars[i + count] != ';') {
                        count++;
                    }
                }
                count++;
                list.add(new String(chars, i, count));
                i += count;
                break;
            }
            case 'L': {
                int count = 1;
                while (chars[i + count] != ';') {
                    ++count;
                }
                count++;
                list.add(new String(chars, i, count));
                i += count;
                break;
            }
            default:
                throw new RuntimeException(""can't parse type list: "" + desc);
            }
        }
        return list;
    }",loop_control
at,"for (int at = 0; at < rawLength; /* at */) {
            char c = signature.charAt(at);
            int endAt = at + 1;
            if (c == 'L') {
                // Scan to ';' or '<'. Consume ';' but not '<'.
                while (endAt < rawLength) {
                    c = signature.charAt(endAt);
                    if (c == ';') {
                        endAt++;
                        break;
                    } else if (c == '<') {
                        break;
                    }
                    endAt++;
                }
            } else {
                // Scan to 'L' without consuming it.
                while (endAt < rawLength) {
                    c = signature.charAt(endAt);
                    if (c == 'L') {
                        break;
                    }
                    endAt++;
                }
            }

            pieces.add(signature.substring(at, endAt));
            at = endAt;
        }",loop_control
endAt,"for (int at = 0; at < rawLength; /* at */) {
            char c = signature.charAt(at);
            int endAt = at + 1;
            if (c == 'L') {
                // Scan to ';' or '<'. Consume ';' but not '<'.
                while (endAt < rawLength) {
                    c = signature.charAt(endAt);
                    if (c == ';') {
                        endAt++;
                        break;
                    } else if (c == '<') {
                        break;
                    }
                    endAt++;
                }
            } else {
                // Scan to 'L' without consuming it.
                while (endAt < rawLength) {
                    c = signature.charAt(endAt);
                    if (c == 'L') {
                        break;
                    }
                    endAt++;
                }
            }

            pieces.add(signature.substring(at, endAt));
            at = endAt;
        }",loop_control
c,"for (int at = 0; at < rawLength; /* at */) {
            char c = signature.charAt(at);
            int endAt = at + 1;
            if (c == 'L') {
                // Scan to ';' or '<'. Consume ';' but not '<'.
                while (endAt < rawLength) {
                    c = signature.charAt(endAt);
                    if (c == ';') {
                        endAt++;
                        break;
                    } else if (c == '<') {
                        break;
                    }
                    endAt++;
                }
            } else {
                // Scan to 'L' without consuming it.
                while (endAt < rawLength) {
                    c = signature.charAt(endAt);
                    if (c == 'L') {
                        break;
                    }
                    endAt++;
                }
            }

            pieces.add(signature.substring(at, endAt));
            at = endAt;
        }",break_loop_control
mv,"{
        while (mv != null && !(mv instanceof MethodWriter)) {
            mv = mv.mv;
        }
        return mv;
    }",maybe_loop_control
p,"{
        // mv must be the last element
        ClassWriter cw = mw.cw;
        MethodWriter p = cw.firstMethod;
        if (p == mw) {
            cw.firstMethod = null;
            if (cw.lastMethod == mw) {
                cw.lastMethod = null;
            }
        } else {
            while (p != null) {
                if (p.mv == mw) {
                    p.mv = mw.mv;
                    if (cw.lastMethod == mw) {
                        cw.lastMethod = p;
                    }
                    break;
                } else {
                    p = (MethodWriter) p.mv;
                }
            }
        }
    }",maybe_loop_control
p,"{
        // mv must be the last element
        ClassWriter cw = mw.cw;
        MethodWriter p = cw.firstMethod;
        if (p == mw) {
            cw.firstMethod = null;
            if (cw.lastMethod == mw) {
                cw.lastMethod = null;
            }
        } else {
            while (p != null) {
                if (p.mv == mw) {
                    p.mv = mw.mv;
                    if (cw.lastMethod == mw) {
                        cw.lastMethod = p;
                    }
                    break;
                } else {
                    p = (MethodWriter) p.mv;
                }
            }
        }
    }",break_loop_control
itf,"for (String itf : cn.interfaces) {
            pw.print("".implements "");
            printIdAfterAccess(pw, itf);
            pw.println();
        }",iterator
an,"for (AnnotationNode an : cn.visibleAnnotations) {
                printAnnotation(an, 1, -1);
            }",iterator
an,"for (AnnotationNode an : cn.invisibleAnnotations) {
                printAnnotation(an, 2, -1);
            }",iterator
an,"for (AnnotationNode an : fn.visibleAnnotations) {
                    printAnnotation(an, 1, -1);
                }",iterator
an,"for (AnnotationNode an : fn.invisibleAnnotations) {
                    printAnnotation(an, 2, -1);
                }",iterator
an,"for (AnnotationNode an : mn.visibleAnnotations) {
                    printAnnotation(an, 1, -1);
                }",iterator
an,"for (AnnotationNode an : mn.invisibleAnnotations) {
                    printAnnotation(an, 2, -1);
                }",iterator
an,"for (AnnotationNode an : pas) {
                            printAnnotation(an, 1, j + 1);
                        }",iterator
an,"for (AnnotationNode an : pas) {
                            printAnnotation(an, 2, j + 1);
                        }",iterator
in,"for (InnerClassNode in : cn.innerClasses) {
            pw.print("".inner class"");
            pw.print(access_clz(in.access & (~Opcodes.ACC_SUPER)));
            if (in.innerName != null) {
                pw.print(' ');
                printIdAfterAccess(pw, in.innerName);
            }
            if (in.name != null) {
                pw.print("" inner "");
                pw.print(in.name);
            }
            if (in.outerName != null) {
                pw.print("" outer "");
                pw.print(in.outerName);
            }
            pw.println();
        }",iterator
in,"for (int j = 0; j < mn.instructions.size(); ++j) {
                    AbstractInsnNode in = mn.instructions.get(j);
                    if (in.getType() != AbstractInsnNode.LINE && in.getType() != AbstractInsnNode.FRAME) {
                       if(in.getType()==AbstractInsnNode.LABEL){
                           pw.print(""  "");
                       }else {
                           pw.print(""    "");
                       }
                    }
                    in.accept(new MethodVisitor(ASM4) {

                        @Override
                        public void visitInsn(int opcode) {
                            print(opcode);
                            pw.println();
                        }

                        @Override
                        public void visitIntInsn(int opcode, int operand) {
                            print(opcode);
                            if (opcode == Opcodes.NEWARRAY) {
                                switch (operand) {
                                case Opcodes.T_BOOLEAN:
                                    pw.println("" boolean"");
                                    break;
                                case Opcodes.T_CHAR:
                                    pw.println("" char"");
                                    break;
                                case Opcodes.T_FLOAT:
                                    pw.println("" float"");
                                    break;
                                case Opcodes.T_DOUBLE:
                                    pw.println("" double"");
                                    break;
                                case Opcodes.T_BYTE:
                                    pw.println("" byte"");
                                    break;
                                case Opcodes.T_SHORT:
                                    pw.println("" short"");
                                    break;
                                case Opcodes.T_INT:
                                    pw.println("" int"");
                                    break;
                                case Opcodes.T_LONG:
                                default:
                                    pw.println("" long"");
                                    break;
                                }
                            } else {
                                pw.print(' ');
                                pw.println(operand);
                            }
                        }

                        @Override
                        public void visitVarInsn(int opcode, int var) {
                            print(opcode);
                            pw.print(' ');
                            pw.println(var);
                        }

                        @Override
                        public void visitTypeInsn(int opcode, String type) {
                            print(opcode);
                            pw.print(' ');
                            pw.println(type);
                        }

                        @Override
                        public void visitFieldInsn(int opcode, String owner, String name, String desc) {
                            print(opcode);
                            pw.print(' ');
                            pw.print(owner);
                            pw.print('/');
                            pw.print(name);
                            pw.print(' ');
                            pw.println(desc);
                        }

                        @Override
                        public void visitMethodInsn(int opcode, String owner, String name, String desc) {
                            print(opcode);
                            pw.print(' ');
                            pw.print(owner);
                            pw.print('/');
                            pw.print(name);
                            pw.print(desc);
                            if (opcode == Opcodes.INVOKEINTERFACE) {
                                pw.print(' ');
                                pw.print((Type.getArgumentsAndReturnSizes(desc) >> 2) - 1);
                            }
                            pw.println();
                        }

                        @Override
                        public void visitJumpInsn(int opcode, Label label) {
                            print(opcode);
                            pw.print(' ');
                            print(label);
                            pw.println();
                        }

                        @Override
                        public void visitLabel(Label label) {
                            print(label);
                            pw.println(':');
                        }

                        @Override
                        public void visitLdcInsn(Object cst) {

                            if (cst instanceof Integer || cst instanceof Float) {
                                pw.print(""ldc_w "");
                                print(cst);
                            } else if (cst instanceof Long || cst instanceof Double) {
                                pw.print(""ldc2_w "");
                                print(cst);
                            } else {
                                pw.print(""ldc "");
                                if (cst instanceof Type) {
                                    pw.print(((Type) cst).getInternalName());
                                } else {
                                    print(cst);
                                }
                            }
                            pw.println();

                        }

                        @Override
                        public void visitIincInsn(int var, int increment) {
                            pw.print(""iinc "");
                            pw.print(var);
                            pw.print(' ');
                            pw.println(increment);
                        }

                        @Override
                        public void visitTableSwitchInsn(int min, int max, Label dflt, Label... labels) {
                            pw.print(""tableswitch "");
                            pw.println(min);
                            for (Label label : labels) {
                                pw.print(""      "");
                                print(label);
                                pw.println();
                            }
                            pw.print(""      default : "");
                            print(dflt);
                            pw.println();
                        }

                        @Override
                        public void visitLookupSwitchInsn(Label dflt, int[] keys, Label[] labels) {
                            pw.println(""lookupswitch"");
                            for (int i = 0; i < keys.length; ++i) {
                                pw.print(""      "");
                                pw.print(keys[i]);
                                pw.print("" : "");
                                print(labels[i]);
                                pw.println();
                            }
                            pw.print(""      default : "");
                            print(dflt);
                            pw.println();
                        }

                        @Override
                        public void visitMultiANewArrayInsn(String desc, int dims) {
                            pw.print(""multianewarray "");
                            pw.print(desc);
                            pw.print(' ');
                            pw.println(dims);
                        }

                        @Override
                        public void visitLineNumber(int line, Label start) {
                            pw.print("".line "");
                            pw.println(line);
                        }
                    });
                }",iterator
fn,"for (FieldNode fn : cn.fields) {
            boolean annotations = false;
            if (fn.visibleAnnotations != null && fn.visibleAnnotations.size() > 0) {
                annotations = true;
            }
            if (fn.invisibleAnnotations != null && fn.invisibleAnnotations.size() > 0) {
                annotations = true;
            }
            boolean deprecated = (fn.access & Opcodes.ACC_DEPRECATED) != 0;
            pw.print(""\n.field"");
            pw.print(access_fld(fn.access));
            pw.print(' ');
            printIdAfterAccess(pw,fn.name);
            pw.print(' ');
            pw.print(fn.desc);
            if (fn.value instanceof String) {
                StringBuffer buf = new StringBuffer();
                Printer.appendString(buf, (String) fn.value);
                pw.print("" = "");
                pw.print(buf.toString());
            } else if (fn.value != null) {
                pw.print("" = "");
                print(fn.value);
            }
            pw.println();
            if (fn.signature != null) {
                pw.print("".signature \"""");
                pw.print(fn.signature);
                pw.println(""\"""");
            }
            if (deprecated) {
                pw.println("".deprecated"");
            }
            if (fn.visibleAnnotations != null) {
                for (AnnotationNode an : fn.visibleAnnotations) {
                    printAnnotation(an, 1, -1);
                }
            }
            if (fn.invisibleAnnotations != null) {
                for (AnnotationNode an : fn.invisibleAnnotations) {
                    printAnnotation(an, 2, -1);
                }
            }
            if (fn.signature != null || deprecated || annotations) {
                pw.println("".end field"");
            }
        }",iterator
mn,"for (MethodNode mn : cn.methods) {
            pw.print(""\n.method"");
            pw.print(access_mtd(mn.access));
            pw.print(' ');
            printIdAfterAccess(pw, mn.name);
            pw.println(mn.desc);
            if (mn.signature != null) {
                pw.print("".signature \"""");
                pw.print(mn.signature);
                pw.println(""\"""");
            }
            if (mn.annotationDefault != null) {
                pw.println("".annotation default"");
                printAnnotationValue(mn.annotationDefault);
                pw.println("".end annotation"");
            }
            if (mn.visibleAnnotations != null) {
                for (AnnotationNode an : mn.visibleAnnotations) {
                    printAnnotation(an, 1, -1);
                }
            }
            if (mn.invisibleAnnotations != null) {
                for (AnnotationNode an : mn.invisibleAnnotations) {
                    printAnnotation(an, 2, -1);
                }
            }
            if (mn.visibleParameterAnnotations != null) {
                for (int j = 0; j < mn.visibleParameterAnnotations.length; ++j) {
                    List<AnnotationNode> pas = mn.visibleParameterAnnotations[j];
                    if (pas != null) {
                        for (AnnotationNode an : pas) {
                            printAnnotation(an, 1, j + 1);
                        }
                    }
                }
            }
            if (mn.invisibleParameterAnnotations != null) {
                for (int j = 0; j < mn.invisibleParameterAnnotations.length; ++j) {
                    List<AnnotationNode> pas = mn.invisibleParameterAnnotations[j];
                    if (pas != null) {
                        for (AnnotationNode an : pas) {
                            printAnnotation(an, 2, j + 1);
                        }
                    }
                }
            }
            for (String ex : mn.exceptions) {
                println("".throws "", ex);
            }
            if ((mn.access & Opcodes.ACC_DEPRECATED) != 0) {
                pw.println("".deprecated"");
            }
            if (mn.instructions != null && mn.instructions.size() > 0) {
                labelNames.clear();
                if (mn.tryCatchBlocks != null) {
                    for (TryCatchBlockNode tcb : mn.tryCatchBlocks) {
                        pw.print("".catch "");
                        pw.print(tcb.type == null ? ""all"" : ""all"".equals(tcb.type) ? ""\\u0097ll"" : tcb.type);
                        pw.print("" from "");
                        print(tcb.start);
                        pw.print("" to "");
                        print(tcb.end);
                        pw.print("" using "");
                        print(tcb.handler);
                        pw.println();
                    }
                }
                for (int j = 0; j < mn.instructions.size(); ++j) {
                    AbstractInsnNode in = mn.instructions.get(j);
                    if (in.getType() != AbstractInsnNode.LINE && in.getType() != AbstractInsnNode.FRAME) {
                       if(in.getType()==AbstractInsnNode.LABEL){
                           pw.print(""  "");
                       }else {
                           pw.print(""    "");
                       }
                    }
                    in.accept(new MethodVisitor(ASM4) {

                        @Override
                        public void visitInsn(int opcode) {
                            print(opcode);
                            pw.println();
                        }

                        @Override
                        public void visitIntInsn(int opcode, int operand) {
                            print(opcode);
                            if (opcode == Opcodes.NEWARRAY) {
                                switch (operand) {
                                case Opcodes.T_BOOLEAN:
                                    pw.println("" boolean"");
                                    break;
                                case Opcodes.T_CHAR:
                                    pw.println("" char"");
                                    break;
                                case Opcodes.T_FLOAT:
                                    pw.println("" float"");
                                    break;
                                case Opcodes.T_DOUBLE:
                                    pw.println("" double"");
                                    break;
                                case Opcodes.T_BYTE:
                                    pw.println("" byte"");
                                    break;
                                case Opcodes.T_SHORT:
                                    pw.println("" short"");
                                    break;
                                case Opcodes.T_INT:
                                    pw.println("" int"");
                                    break;
                                case Opcodes.T_LONG:
                                default:
                                    pw.println("" long"");
                                    break;
                                }
                            } else {
                                pw.print(' ');
                                pw.println(operand);
                            }
                        }

                        @Override
                        public void visitVarInsn(int opcode, int var) {
                            print(opcode);
                            pw.print(' ');
                            pw.println(var);
                        }

                        @Override
                        public void visitTypeInsn(int opcode, String type) {
                            print(opcode);
                            pw.print(' ');
                            pw.println(type);
                        }

                        @Override
                        public void visitFieldInsn(int opcode, String owner, String name, String desc) {
                            print(opcode);
                            pw.print(' ');
                            pw.print(owner);
                            pw.print('/');
                            pw.print(name);
                            pw.print(' ');
                            pw.println(desc);
                        }

                        @Override
                        public void visitMethodInsn(int opcode, String owner, String name, String desc) {
                            print(opcode);
                            pw.print(' ');
                            pw.print(owner);
                            pw.print('/');
                            pw.print(name);
                            pw.print(desc);
                            if (opcode == Opcodes.INVOKEINTERFACE) {
                                pw.print(' ');
                                pw.print((Type.getArgumentsAndReturnSizes(desc) >> 2) - 1);
                            }
                            pw.println();
                        }

                        @Override
                        public void visitJumpInsn(int opcode, Label label) {
                            print(opcode);
                            pw.print(' ');
                            print(label);
                            pw.println();
                        }

                        @Override
                        public void visitLabel(Label label) {
                            print(label);
                            pw.println(':');
                        }

                        @Override
                        public void visitLdcInsn(Object cst) {

                            if (cst instanceof Integer || cst instanceof Float) {
                                pw.print(""ldc_w "");
                                print(cst);
                            } else if (cst instanceof Long || cst instanceof Double) {
                                pw.print(""ldc2_w "");
                                print(cst);
                            } else {
                                pw.print(""ldc "");
                                if (cst instanceof Type) {
                                    pw.print(((Type) cst).getInternalName());
                                } else {
                                    print(cst);
                                }
                            }
                            pw.println();

                        }

                        @Override
                        public void visitIincInsn(int var, int increment) {
                            pw.print(""iinc "");
                            pw.print(var);
                            pw.print(' ');
                            pw.println(increment);
                        }

                        @Override
                        public void visitTableSwitchInsn(int min, int max, Label dflt, Label... labels) {
                            pw.print(""tableswitch "");
                            pw.println(min);
                            for (Label label : labels) {
                                pw.print(""      "");
                                print(label);
                                pw.println();
                            }
                            pw.print(""      default : "");
                            print(dflt);
                            pw.println();
                        }

                        @Override
                        public void visitLookupSwitchInsn(Label dflt, int[] keys, Label[] labels) {
                            pw.println(""lookupswitch"");
                            for (int i = 0; i < keys.length; ++i) {
                                pw.print(""      "");
                                pw.print(keys[i]);
                                pw.print("" : "");
                                print(labels[i]);
                                pw.println();
                            }
                            pw.print(""      default : "");
                            print(dflt);
                            pw.println();
                        }

                        @Override
                        public void visitMultiANewArrayInsn(String desc, int dims) {
                            pw.print(""multianewarray "");
                            pw.print(desc);
                            pw.print(' ');
                            pw.println(dims);
                        }

                        @Override
                        public void visitLineNumber(int line, Label start) {
                            pw.print("".line "");
                            pw.println(line);
                        }
                    });
                }
                if (mn.localVariables != null) {
                    for (LocalVariableNode lv : mn.localVariables) {
                        pw.print(""  .var "");
                        pw.print(lv.index);
                        pw.print("" is '"");
                        pw.print(lv.name);
                        pw.print(""' "");
                        pw.print(lv.desc);
                        if (lv.signature != null) {
                            pw.print("" signature \"""");
                            pw.print(lv.signature);
                            pw.print(""\"""");
                        }
                        pw.print("" from "");
                        print(lv.start);
                        pw.print("" to "");
                        print(lv.end);
                        pw.println();
                    }
                }
                println(""  .limit locals "", Integer.toString(mn.maxLocals));
                println(""  .limit stack "", Integer.toString(mn.maxStack));
            }
            pw.println("".end method"");
        }",iterator
j,"for (int j = 0; j < mn.visibleParameterAnnotations.length; ++j) {
                    List<AnnotationNode> pas = mn.visibleParameterAnnotations[j];
                    if (pas != null) {
                        for (AnnotationNode an : pas) {
                            printAnnotation(an, 1, j + 1);
                        }
                    }
                }",loop_control
j,"for (int j = 0; j < mn.invisibleParameterAnnotations.length; ++j) {
                    List<AnnotationNode> pas = mn.invisibleParameterAnnotations[j];
                    if (pas != null) {
                        for (AnnotationNode an : pas) {
                            printAnnotation(an, 2, j + 1);
                        }
                    }
                }",loop_control
j,"for (int j = 0; j < mn.instructions.size(); ++j) {
                    AbstractInsnNode in = mn.instructions.get(j);
                    if (in.getType() != AbstractInsnNode.LINE && in.getType() != AbstractInsnNode.FRAME) {
                       if(in.getType()==AbstractInsnNode.LABEL){
                           pw.print(""  "");
                       }else {
                           pw.print(""    "");
                       }
                    }
                    in.accept(new MethodVisitor(ASM4) {

                        @Override
                        public void visitInsn(int opcode) {
                            print(opcode);
                            pw.println();
                        }

                        @Override
                        public void visitIntInsn(int opcode, int operand) {
                            print(opcode);
                            if (opcode == Opcodes.NEWARRAY) {
                                switch (operand) {
                                case Opcodes.T_BOOLEAN:
                                    pw.println("" boolean"");
                                    break;
                                case Opcodes.T_CHAR:
                                    pw.println("" char"");
                                    break;
                                case Opcodes.T_FLOAT:
                                    pw.println("" float"");
                                    break;
                                case Opcodes.T_DOUBLE:
                                    pw.println("" double"");
                                    break;
                                case Opcodes.T_BYTE:
                                    pw.println("" byte"");
                                    break;
                                case Opcodes.T_SHORT:
                                    pw.println("" short"");
                                    break;
                                case Opcodes.T_INT:
                                    pw.println("" int"");
                                    break;
                                case Opcodes.T_LONG:
                                default:
                                    pw.println("" long"");
                                    break;
                                }
                            } else {
                                pw.print(' ');
                                pw.println(operand);
                            }
                        }

                        @Override
                        public void visitVarInsn(int opcode, int var) {
                            print(opcode);
                            pw.print(' ');
                            pw.println(var);
                        }

                        @Override
                        public void visitTypeInsn(int opcode, String type) {
                            print(opcode);
                            pw.print(' ');
                            pw.println(type);
                        }

                        @Override
                        public void visitFieldInsn(int opcode, String owner, String name, String desc) {
                            print(opcode);
                            pw.print(' ');
                            pw.print(owner);
                            pw.print('/');
                            pw.print(name);
                            pw.print(' ');
                            pw.println(desc);
                        }

                        @Override
                        public void visitMethodInsn(int opcode, String owner, String name, String desc) {
                            print(opcode);
                            pw.print(' ');
                            pw.print(owner);
                            pw.print('/');
                            pw.print(name);
                            pw.print(desc);
                            if (opcode == Opcodes.INVOKEINTERFACE) {
                                pw.print(' ');
                                pw.print((Type.getArgumentsAndReturnSizes(desc) >> 2) - 1);
                            }
                            pw.println();
                        }

                        @Override
                        public void visitJumpInsn(int opcode, Label label) {
                            print(opcode);
                            pw.print(' ');
                            print(label);
                            pw.println();
                        }

                        @Override
                        public void visitLabel(Label label) {
                            print(label);
                            pw.println(':');
                        }

                        @Override
                        public void visitLdcInsn(Object cst) {

                            if (cst instanceof Integer || cst instanceof Float) {
                                pw.print(""ldc_w "");
                                print(cst);
                            } else if (cst instanceof Long || cst instanceof Double) {
                                pw.print(""ldc2_w "");
                                print(cst);
                            } else {
                                pw.print(""ldc "");
                                if (cst instanceof Type) {
                                    pw.print(((Type) cst).getInternalName());
                                } else {
                                    print(cst);
                                }
                            }
                            pw.println();

                        }

                        @Override
                        public void visitIincInsn(int var, int increment) {
                            pw.print(""iinc "");
                            pw.print(var);
                            pw.print(' ');
                            pw.println(increment);
                        }

                        @Override
                        public void visitTableSwitchInsn(int min, int max, Label dflt, Label... labels) {
                            pw.print(""tableswitch "");
                            pw.println(min);
                            for (Label label : labels) {
                                pw.print(""      "");
                                print(label);
                                pw.println();
                            }
                            pw.print(""      default : "");
                            print(dflt);
                            pw.println();
                        }

                        @Override
                        public void visitLookupSwitchInsn(Label dflt, int[] keys, Label[] labels) {
                            pw.println(""lookupswitch"");
                            for (int i = 0; i < keys.length; ++i) {
                                pw.print(""      "");
                                pw.print(keys[i]);
                                pw.print("" : "");
                                print(labels[i]);
                                pw.println();
                            }
                            pw.print(""      default : "");
                            print(dflt);
                            pw.println();
                        }

                        @Override
                        public void visitMultiANewArrayInsn(String desc, int dims) {
                            pw.print(""multianewarray "");
                            pw.print(desc);
                            pw.print(' ');
                            pw.println(dims);
                        }

                        @Override
                        public void visitLineNumber(int line, Label start) {
                            pw.print("".line "");
                            pw.println(line);
                        }
                    });
                }",loop_control
lv,"for (LocalVariableNode lv : mn.localVariables) {
                        pw.print(""  .var "");
                        pw.print(lv.index);
                        pw.print("" is '"");
                        pw.print(lv.name);
                        pw.print(""' "");
                        pw.print(lv.desc);
                        if (lv.signature != null) {
                            pw.print("" signature \"""");
                            pw.print(lv.signature);
                            pw.print(""\"""");
                        }
                        pw.print("" from "");
                        print(lv.start);
                        pw.print("" to "");
                        print(lv.end);
                        pw.println();
                    }",iterator
tcb,"for (TryCatchBlockNode tcb : mn.tryCatchBlocks) {
                        pw.print("".catch "");
                        pw.print(tcb.type == null ? ""all"" : ""all"".equals(tcb.type) ? ""\\u0097ll"" : tcb.type);
                        pw.print("" from "");
                        print(tcb.start);
                        pw.print("" to "");
                        print(tcb.end);
                        pw.print("" using "");
                        print(tcb.handler);
                        pw.println();
                    }",iterator
ex,"for (String ex : mn.exceptions) {
                println("".throws "", ex);
            }",iterator
i,"for (int i = 0; i < n.values.size(); i += 2) {
                pw.print(n.values.get(i));
                pw.print(' ');
                printAnnotationValue(n.values.get(i + 1));
            }",loop_control
element,"for (byte element : v) {
                pw.print(element);
                pw.print(' ');
            }",iterator
element,"for (boolean element : v) {
                pw.print(element ? '1' : '0');
                pw.print(' ');
            }",iterator
element,"for (short element : v) {
                pw.print(element);
                pw.print(' ');
            }",iterator
element,"for (char element : v) {
                pw.print(new Integer(element));
                pw.print(' ');
            }",iterator
element,"for (int element : v) {
                pw.print(element);
                pw.print(' ');
            }",iterator
element,"for (long element : v) {
                pw.print(element);
                pw.print(' ');
            }",iterator
element,"for (float element : v) {
                print(new Float(element));
                pw.print(' ');
            }",iterator
element,"for (double element : v) {
                print(new Double(element));
                pw.print(' ');
            }",iterator
p,"for (FileSystemProvider p : FileSystemProvider.installedProviders()) {
            String s = p.getScheme();
            if (""jar"".equals(s) || ""zip"".equalsIgnoreCase(s)) {
                return p.newFileSystem(output, env);
            }
        }",iterator
s,"for (FileSystemProvider p : FileSystemProvider.installedProviders()) {
            String s = p.getScheme();
            if (""jar"".equals(s) || ""zip"".equalsIgnoreCase(s)) {
                return p.newFileSystem(output, env);
            }
        }",break_loop_control
p,"for (FileSystemProvider p : FileSystemProvider.installedProviders()) {
            String s = p.getScheme();
            if (""jar"".equals(s) || ""zip"".equalsIgnoreCase(s)) {
                return p.newFileSystem(in, new HashMap<String, Object>());
            }
        }",iterator
s,"for (FileSystemProvider p : FileSystemProvider.installedProviders()) {
            String s = p.getScheme();
            if (""jar"".equals(s) || ""zip"".equalsIgnoreCase(s)) {
                return p.newFileSystem(in, new HashMap<String, Object>());
            }
        }",break_loop_control
e,"for (Map.Entry<String, Option> e : optMap.entrySet()) {
            Option option = e.getValue();
            if (option.required) {
                options.add(option);
            }
        }",iterator
f,"for (Field f : fs) {
            Opt opt = f.getAnnotation(Opt.class);
            if (opt != null) {
                f.setAccessible(true);
                Option option = new Option();
                option.field = f;
                option.description = opt.description();
                option.hasArg = opt.hasArg();
                option.required = opt.required();
                if ("""".equals(opt.longOpt()) && """".equals(opt.opt())) {   // into automode
                    option.longOpt = fromCamel(f.getName());
                    if (f.getType().equals(boolean.class)) {
                        option.hasArg=false;
                        try {
                            if (f.getBoolean(this)) {
                                throw new RuntimeException(""the value of "" + f + "" must be false, as it is declared as no args"");
                            }
                        } catch (IllegalAccessException e) {
                            throw new RuntimeException(e);
                        }
                    }
                    checkConflict(option, ""--"" + option.longOpt);
                    continue;
                }
                if (!opt.hasArg()) {
                    if (!f.getType().equals(boolean.class)) {
                        throw new RuntimeException(""the type of "" + f
                                + "" must be boolean, as it is declared as no args"");
                    }

                    try {
                        if (f.getBoolean(this)) {
                            throw new RuntimeException(""the value of "" + f + "" must be false, as it is declared as no args"");
                        }
                    } catch (IllegalAccessException e) {
                        throw new RuntimeException(e);
                    }
                }
                boolean haveLongOpt = false;
                if (!"""".equals(opt.longOpt())) {
                    option.longOpt = opt.longOpt();
                    checkConflict(option, ""--"" + option.longOpt);
                    haveLongOpt = true;
                }
                if (!"""".equals(opt.argName())) {
                    option.argName = opt.argName();
                }
                if (!"""".equals(opt.opt())) {
                    option.opt = opt.opt();
                    checkConflict(option, ""-"" + option.opt);
                } else {
                    if (!haveLongOpt) {
                        throw new RuntimeException(""opt or longOpt is not set in @Opt(...) "" + f);
                    }
                }
            }
        }",iterator
i,"for (int i = 1; i < charArray.length; i++) {
            char c = charArray[i];
            if (Character.isUpperCase(c)) {
                sb.append(""-"").append(Character.toLowerCase(c));
            } else {
                sb.append(c);
            }
        }",loop_control
s,"for (String s : args) {
            if (needArgOpt != null) {
                needArgOpt.field.set(this, convert(s, needArgOpt.field.getType()));
                needArgOpt = null;
            } else if (s.startsWith(""-"")) {// its a short or long option
                Option opt = optMap.get(s);
                requiredOpts.remove(opt);
                if (opt == null) {
                    System.err.println(""ERROR: Unrecognized option: "" + s);
                    throw new HelpException();
                } else {
                    if (opt.hasArg) {
                        needArgOpt = opt;
                    } else {
                        opt.field.set(this, true);
                    }
                }
            } else {
                remainsOptions.add(s);
            }
        }",iterator
option,"for (Option option : requiredOpts) {
                if (first) {
                    first = false;
                } else {
                    sb.append("" and "");
                }
                sb.append(option.getOptAndLongOpt());
            }",iterator
option,"for (Option option : options) {
            int pa = 4 + option.getOptAndLongOpt().length();
            if (option.hasArg) {
                pa += 3 + option.argName.length();
            }
            if (pa < maxPaLength) {
                if (pa > palength) {
                    palength = pa;
                }
            }
        }",iterator
option,"for (Option option : options) {
            sb.setLength(0);
            sb.append("" "").append(option.getOptAndLongOpt());
            if (option.hasArg) {
                sb.append("" <"").append(option.argName).append("">"");
            }
            String desc = option.description;
            if (desc == null || desc.length() == 0) {// no description
                out.println(sb);
            } else {
                for (int i = palength - sb.length(); i > 0; i--) {
                    sb.append(' ');
                }
                if (sb.length() > maxPaLength) {// to huge part A
                    out.println(sb);
                    sb.setLength(0);
                    for (int i = 0; i < palength; i++) {
                        sb.append(' ');
                    }
                }
                int nextStart = 0;
                while (nextStart < desc.length()) {
                    if (desc.length() - nextStart < pblength) {// can put in one line
                        sb.append(desc.substring(nextStart));
                        out.println(sb);
                        nextStart = desc.length();
                        sb.setLength(0);
                    } else {
                        sb.append(desc.substring(nextStart, nextStart + pblength));
                        out.println(sb);
                        nextStart += pblength;
                        sb.setLength(0);
                        if (nextStart < desc.length()) {
                            for (int i = 0; i < palength; i++) {
                                sb.append(' ');
                            }
                        }
                    }
                }
                if (sb.length() > 0) {
                    out.println(sb);
                    sb.setLength(0);
                }
            }
        }",iterator
i,"for (int i = palength - sb.length(); i > 0; i--) {
                    sb.append(' ');
                }",loop_control
i,"for (int i = 0; i < palength; i++) {
                        sb.append(' ');
                    }",loop_control
i,"for (int i = 0; i < palength; i++) {
                                sb.append(' ');
                            }",loop_control
nextStart,"{
                for (int i = palength - sb.length(); i > 0; i--) {
                    sb.append(' ');
                }
                if (sb.length() > maxPaLength) {// to huge part A
                    out.println(sb);
                    sb.setLength(0);
                    for (int i = 0; i < palength; i++) {
                        sb.append(' ');
                    }
                }
                int nextStart = 0;
                while (nextStart < desc.length()) {
                    if (desc.length() - nextStart < pblength) {// can put in one line
                        sb.append(desc.substring(nextStart));
                        out.println(sb);
                        nextStart = desc.length();
                        sb.setLength(0);
                    } else {
                        sb.append(desc.substring(nextStart, nextStart + pblength));
                        out.println(sb);
                        nextStart += pblength;
                        sb.setLength(0);
                        if (nextStart < desc.length()) {
                            for (int i = 0; i < palength; i++) {
                                sb.append(' ');
                            }
                        }
                    }
                }
                if (sb.length() > 0) {
                    out.println(sb);
                    sb.setLength(0);
                }
            }",loop_control
t,"for (String t : parameterTypes) {
                    ps.append(t);
                }",iterator
i,"for (int i = 0; i < parameterNames.size(); i++) {
                String name = parameterNames.get(i);
                if (name != null) {
                    v.visitParameterName(i, name);
                }
            }",loop_control
n,"for (DexDebugOpNode n : debugNodes) {
                n.accept(v);
            }",iterator
ann,"for (DexAnnotationNode ann : anns) {
                ann.accept(fv);
            }",iterator
cn,"for (DexClassNode cn : clzs) {
            cn.accept(dcv);
        }",iterator
cn,"for (DexClassNode cn : clzs) {
            cn.accept(dfv);
        }",iterator
ann,"for (DexAnnotationNode ann : anns) {
                ann.accept(dcv);
            }",iterator
m,"for (DexMethodNode m : methods) {
                m.accept(dcv);
            }",iterator
f,"for (DexFieldNode f : fields) {
                f.accept(dcv);
            }",iterator
i,"for (int i = 0; i < parameterAnns.length; i++) {
                List<DexAnnotationNode> ps = parameterAnns[i];
                if (ps != null) {
                    DexAnnotationAble av = mv.visitParameterAnnotation(i);
                    if (av != null) {
                        for (DexAnnotationNode p : ps) {
                            p.accept(av);
                        }
                    }
                }
            }",loop_control
ann,"for (DexAnnotationNode ann : anns) {
                ann.accept(mv);
            }",iterator
p,"for (DexAnnotationNode p : ps) {
                            p.accept(av);
                        }",iterator
n,"for (TryCatchNode n : tryStmts) {
                n.accept(v);
            }",iterator
n,"for (DexStmtNode n : stmts) {
            n.accept(v);
        }",iterator
e,"for (Object e : array) {
                    acceptAnnotationItem(arrayVisitor, null, e);
                }",iterator
item,"for (Item item : items) {
                acceptAnnotationItem(av1, item.name, item.value);
            }",iterator
i,"{
                int i = 0;
                AbstractMethodStmtNode methodStmtNode = (AbstractMethodStmtNode) insn;
                List<V> v;
                Proto proto = methodStmtNode.getProto();
                boolean isStatic = false;
                if (insn.op == Op.INVOKE_STATIC || insn.op == Op.INVOKE_STATIC_RANGE) {
                    isStatic = true;
                } else if (insn.op == Op.INVOKE_CUSTOM || insn.op == Op.INVOKE_CUSTOM_RANGE) {
                    isStatic = true;
                }
                if (isStatic) {
                    v = new ArrayList<>(proto.getParameterTypes().length);
                } else {
                    v = new ArrayList<>(proto.getParameterTypes().length + 1);
                    v.add(getReg(methodStmtNode.args[i++]));
                }

                for (String type : proto.getParameterTypes()) {
                    v.add(getReg(methodStmtNode.args[i]));
                    char t = type.charAt(0);
                    if (t == 'J' || t == 'D') {
                        i += 2;
                    } else {
                        i += 1;
                    }
                }
                setTmp(interpreter.naryOperation(insn, v));
            }",loop_control
i,"for (int i = 0; i < filledNewArrayStmtNode.args.length; i++) {
                    v.add(getReg(filledNewArrayStmtNode.args[i]));
                }",loop_control
type,"for (String type : proto.getParameterTypes()) {
                    v.add(getReg(methodStmtNode.args[i]));
                    char t = type.charAt(0);
                    if (t == 'J' || t == 'D') {
                        i += 2;
                    } else {
                        i += 1;
                    }
                }",iterator
op,"for (Op op : Op.values()) {
            if (op.opcode >= 0) {
                ops[op.opcode] = op;
            }
        }",iterator
i,"for (int i = 0; i < 2000; i++) {
            Local b = addLocal(""a"");
            addStmt(nAssign(b, nString(""123"")));
        }",loop_control
i,"for (int i = 0; i < 20000; i++) {
            addStmt(nAssign(b, nString(""123"")));
        }",loop_control
trap,"for (Trap trap : traps) {
            n.traps.add(trap.clone(mapper));
        }",iterator
var,"for (LocalVar var : vars) {
            n.vars.add(var.clone(mapper));
        }",iterator
labelStmt,"for (LabelStmt labelStmt : phiLabels) {
                nPhiLabels.add(labelStmt.clone(mapper));
            }",iterator
arg,"for (String arg : args) {
                if (first) {
                    first = false;
                } else {
                    sb.append(',');
                }
                sb.append(Util.toShortClassName(arg));
            }",iterator
trap,"for (Trap trap : traps) {
                sb.append(trap).append('\n');
            }",iterator
var,"for (LocalVar var : vars) {
                sb.append(var).append('\n');
            }",iterator
i,"for (int i = 0; i < size; i++) {
            cloneHandlers[i] = handlers[i].clone(mapper);
            cloneTypes[i] = types[i];
        }",loop_control
i,"for (int i = 0; i < handlers.length; i++) {
            sb.append(types[i] == null ? ""all"" : types[i]).append("" > "").append(handlers[i].getDisplayName())
                    .append("","");
        }",loop_control
i,"{
        List<String> list = new ArrayList<String>(5);
        char[] chars = desc.toCharArray();
        int i = 0;
        while (i < chars.length) {
            switch (chars[i]) {
            case 'V':
            case 'Z':
            case 'C':
            case 'B':
            case 'S':
            case 'I':
            case 'F':
            case 'J':
            case 'D':
                list.add(Character.toString(chars[i]));
                i++;
                break;
            case '[': {
                int count = 1;
                while (chars[i + count] == '[') {
                    count++;
                }
                if (chars[i + count] == 'L') {
                    count++;
                    while (chars[i + count] != ';') {
                        count++;
                    }
                }
                count++;
                list.add(new String(chars, i, count));
                i += count + 1;
                break;
            }
            case 'L': {
                int count = 1;
                while (chars[i + count] != ';') {
                    ++count;
                }
                count++;
                list.add(new String(chars, i, count));
                i += count + 1;
                break;
            }
            default:
            }
        }
        return list;
    }",loop_control
count,"{
                int count = 1;
                while (chars[i + count] == '[') {
                    count++;
                }
                if (chars[i + count] == 'L') {
                    count++;
                    while (chars[i + count] != ';') {
                        count++;
                    }
                }
                count++;
                list.add(new String(chars, i, count));
                i += count + 1;
                break;
            }",loop_control
count,"{
                int count = 1;
                while (chars[i + count] != ';') {
                    ++count;
                }
                count++;
                list.add(new String(chars, i, count));
                i += count + 1;
                break;
            }",loop_control
d,"{
        case 'Z':
            return ""boolean"";
        case 'B':
            return ""byte"";
        case 'C':
            return ""char"";
        case 'S':
            return ""short"";
        case 'I':
            return ""int"";
        case 'J':
            return ""long"";
        case 'F':
            return ""float"";
        case 'D':
            return ""double"";
        case 'V':
            return ""void"";
        case 'L': {
            int i = desc.lastIndexOf('/');
            return desc.substring(i < 0 ? 1 : i + 1, desc.length() - 1);
        }
        case '[':
            int d = 1;
            for (; d < desc.length(); d++) {
                if (desc.charAt(d) != '[') {
                    break;
                }
            }
            StringBuilder sb = new StringBuilder().append(toShortClassName(desc.substring(d)));
            for (int t = 0; t < d; t++) {
                sb.append(""[]"");
            }
            return sb.toString();
        }",loop_control
t,"for (int t = 0; t < d; t++) {
                sb.append(""[]"");
            }",loop_control
desc,"{
        switch (desc.charAt(0)) {
        case 'Z':
            return ""boolean"";
        case 'B':
            return ""byte"";
        case 'C':
            return ""char"";
        case 'S':
            return ""short"";
        case 'I':
            return ""int"";
        case 'J':
            return ""long"";
        case 'F':
            return ""float"";
        case 'D':
            return ""double"";
        case 'V':
            return ""void"";
        case 'L': {
            int i = desc.lastIndexOf('/');
            return desc.substring(i < 0 ? 1 : i + 1, desc.length() - 1);
        }
        case '[':
            int d = 1;
            for (; d < desc.length(); d++) {
                if (desc.charAt(d) != '[') {
                    break;
                }
            }
            StringBuilder sb = new StringBuilder().append(toShortClassName(desc.substring(d)));
            for (int t = 0; t < d; t++) {
                sb.append(""[]"");
            }
            return sb.toString();
        }
        throw new UnsupportedOperationException();
    }",break_loop_control
it,"for (Iterator<Stmt> it = stmts.iterator(); it.hasNext(); ) {
            Stmt stmt = it.next();
            Stmt n = travel(stmt);
            if (n != stmt) {
                stmts.insertBefore(stmt, n);
                it.remove();
            }
        }",iterator
i,"for (int i = 0; i < ops.length; i++) {
                    ops[i] = travel(ops[i]);
                }",loop_control
i,"for (int i = 0; i < ops.length; i++) {
                    ops[i] = travel(ops[i]);
                }",loop_control
stmt,"for (Stmt stmt : stmts) {
            travel(stmt);
        }",iterator
op,"for (Value op : ops) {
                    travel(op);
                }",iterator
op1,"for (Value op1 : ops) {
                    travel(op1);
                }",iterator
trap,"for (Trap trap : new ArrayList<Trap>(irMethod.traps)) {// copy the list and we can remove one from original list
            LabelStmt start = null;
            boolean removeTrap = true;
            for (Stmt p = trap.start.getNext(); p != null && p != trap.end;) {
                boolean notThrow = Cfg.notThrow(p);
                if (!notThrow) {
                    start = null;
                    p = p.getNext();
                    removeTrap = false;
                    continue;
                }
                switch (p.st) {
                case LABEL:
                    if (start != null) {
                        move4Label(irMethod.stmts, start, p.getPre(), (LabelStmt) p);
                    }
                    start = (LabelStmt) p;
                    p = p.getNext();

                    break;
                case GOTO:
                case RETURN:
                case RETURN_VOID:
                    if (start != null) {
                        Stmt tmp = p.getNext();
                        move4End(irMethod.stmts, start, p);
                        start = null;
                        p = tmp;
                    } else {
                        p = p.getNext();
                    }
                    break;
                default:
                    p = p.getNext();
                }
            }
            if (removeTrap) {
                irMethod.traps.remove(trap);
            }
        }",iterator
p,"for (Stmt p = trap.start.getNext(); p != null && p != trap.end;) {
                boolean notThrow = Cfg.notThrow(p);
                if (!notThrow) {
                    start = null;
                    p = p.getNext();
                    removeTrap = false;
                    continue;
                }
                switch (p.st) {
                case LABEL:
                    if (start != null) {
                        move4Label(irMethod.stmts, start, p.getPre(), (LabelStmt) p);
                    }
                    start = (LabelStmt) p;
                    p = p.getNext();

                    break;
                case GOTO:
                case RETURN:
                case RETURN_VOID:
                    if (start != null) {
                        Stmt tmp = p.getNext();
                        move4End(irMethod.stmts, start, p);
                        start = null;
                        p = tmp;
                    } else {
                        p = p.getNext();
                    }
                    break;
                default:
                    p = p.getNext();
                }
            }",maybe_loop_control
p,"for (Stmt p = stmts.getFirst(); p != null; p = p.getNext()) {
            if (p.st == ST.GOTO) {
                LabelStmt target = ((GotoStmt) p).target;
                Stmt next = target.getNext();
                if (next != null && (next.st == ST.RETURN || next.st == ST.RETURN_VOID)) {
                    Stmt nnext = next.clone(keepLocal);
                    stmts.insertAfter(p, nnext);
                    stmts.remove(p);
                    p = nnext;
                }
            }
        }",maybe_loop_control
p,"for (Stmt p = trap.start.getNext(); p != null && p != trap.end;) {
                boolean notThrow = Cfg.notThrow(p);
                if (!notThrow) {
                    start = null;
                    p = p.getNext();
                    removeTrap = false;
                    continue;
                }
                switch (p.st) {
                case LABEL:
                    if (start != null) {
                        move4Label(irMethod.stmts, start, p.getPre(), (LabelStmt) p);
                    }
                    start = (LabelStmt) p;
                    p = p.getNext();

                    break;
                case GOTO:
                case RETURN:
                case RETURN_VOID:
                    if (start != null) {
                        Stmt tmp = p.getNext();
                        move4End(irMethod.stmts, start, p);
                        start = null;
                        p = tmp;
                    } else {
                        p = p.getNext();
                    }
                    break;
                default:
                    p = p.getNext();
                }
            }",maybe_loop_control
p,"for (Stmt p = stmts.getFirst(); p != null; p = p.getNext()) {
            if (p.st == ST.GOTO) {
                LabelStmt target = ((GotoStmt) p).target;
                Stmt next = target.getNext();
                if (next != null && (next.st == ST.RETURN || next.st == ST.RETURN_VOID)) {
                    Stmt nnext = next.clone(keepLocal);
                    stmts.insertAfter(p, nnext);
                    stmts.remove(p);
                    p = nnext;
                }
            }
        }",maybe_loop_control
last,"{
        Stmt g1 = Stmts.nGoto(start);
        stmts.insertBefore(start, g1);
        Stmt last = stmts.getLast();
        while (last.st == ST.GOTO && ((GotoStmt) last).target == start) {
            stmts.remove(last);
            last = stmts.getLast();
        }
        stmts.move(start, end, last);

    }",maybe_loop_control
p,"for (Stmt p = method.stmts.getFirst(); p != null; p = p.getNext()) {
            if (p.st == Stmt.ST.ASSIGN) {
                AssignStmt as = (AssignStmt) p;
                if (as.getOp1().vt == Value.VT.LOCAL && as.getOp2().vt == Value.VT.CONSTANT) {
                    Constant cst = (Constant) as.getOp2();
                    Object value = cst.value;
                    if (value instanceof Number && !((value instanceof Long) || (value instanceof Double))) {
                        int v = ((Number) value).intValue();
                        if (v == 0 || v == 1) {
                            assignStmtList.add(as);
                        }
                    }
                }
            }
        }",maybe_loop_control
as,"{
                AssignStmt as = (AssignStmt) p;
                if (as.getOp1().vt == Value.VT.LOCAL && as.getOp2().vt == Value.VT.CONSTANT) {
                    Constant cst = (Constant) as.getOp2();
                    Object value = cst.value;
                    if (value instanceof Number && !((value instanceof Long) || (value instanceof Double))) {
                        int v = ((Number) value).intValue();
                        if (v == 0 || v == 1) {
                            assignStmtList.add(as);
                        }
                    }
                }
            }",iterator
as,"for (AssignStmt as : assignStmtList) {
                Local local = (Local) as.getOp1();
                boolean first = true;
                for (LabelStmt labelStmt : phiLabels) {
                    for (AssignStmt phi : labelStmt.phis) {
                        Value[] vs = phi.getOp2().getOps();
                        for (int i = 0; i < vs.length; i++) {
                            Value v = vs[i];
                            if (v == local) {
                                if (first) {
                                    first = false;
                                } else {
                                    Local nLocal = Exprs.nLocal(-1);
                                    method.locals.add(nLocal);
                                    changed = true;
                                    method.stmts.insertBefore(as, Stmts.nAssign(nLocal, as.getOp2().clone()));
                                    vs[i] = nLocal;
                                }
                            }
                        }
                    }
                }
            }",iterator
labelStmt,"for (LabelStmt labelStmt : phiLabels) {
                    for (AssignStmt phi : labelStmt.phis) {
                        Value[] vs = phi.getOp2().getOps();
                        for (int i = 0; i < vs.length; i++) {
                            Value v = vs[i];
                            if (v == local) {
                                if (first) {
                                    first = false;
                                } else {
                                    Local nLocal = Exprs.nLocal(-1);
                                    method.locals.add(nLocal);
                                    changed = true;
                                    method.stmts.insertBefore(as, Stmts.nAssign(nLocal, as.getOp2().clone()));
                                    vs[i] = nLocal;
                                }
                            }
                        }
                    }
                }",iterator
phi,"for (AssignStmt phi : labelStmt.phis) {
                        Value[] vs = phi.getOp2().getOps();
                        for (int i = 0; i < vs.length; i++) {
                            Value v = vs[i];
                            if (v == local) {
                                if (first) {
                                    first = false;
                                } else {
                                    Local nLocal = Exprs.nLocal(-1);
                                    method.locals.add(nLocal);
                                    changed = true;
                                    method.stmts.insertBefore(as, Stmts.nAssign(nLocal, as.getOp2().clone()));
                                    vs[i] = nLocal;
                                }
                            }
                        }
                    }",iterator
i,"for (int i = 0; i < vs.length; i++) {
                            Value v = vs[i];
                            if (v == local) {
                                if (first) {
                                    first = false;
                                } else {
                                    Local nLocal = Exprs.nLocal(-1);
                                    method.locals.add(nLocal);
                                    changed = true;
                                    method.stmts.insertBefore(as, Stmts.nAssign(nLocal, as.getOp2().clone()));
                                    vs[i] = nLocal;
                                }
                            }
                        }",loop_control
local,"for (Local local : method.locals) {
            local.tag = null;
            local._ls_index = i++;
        }",iterator
it,"for (Iterator<Stmt> it = method.stmts.iterator(); it.hasNext(); ) {
            Stmt stmt = it.next();
            if (!stmt.visited && stmt.st != ST.LABEL) {
                it.remove();
            }
        }",iterator
p,"for (Stmt p = stmts.getFirst(); p != null; p = p.getNext()) {
            if (p.st == ST.LABEL) {
                LabelStmt labelStmt = (LabelStmt) p;
                List<AssignStmt> phis = null;
                SSAValue[] frame = (SSAValue[]) p.frame;
                if (frame != null) {
                    for (SSAValue v : frame) {
                        if (v == null || !v.used) {
                            continue;
                        }
                        if (v.parent != null) {
                            froms.add(v.parent.local);
                        }
                        if (v.otherParents != null) {
                            for (SSAValue parent : v.otherParents) {
                                froms.add(parent.local);
                            }
                        }
                        froms.remove(v.local);
                        if (phis == null) {
                            phis = new ArrayList<>();
                        }
                        locals.add(v.local);
                        phis.add(Stmts.nAssign(v.local, Exprs.nPhi(froms.toArray(new Value[froms.size()]))));
                        froms.clear();
                    }
                }
                labelStmt.phis = phis;
                if (phis != null) {
                    phiLabels.add(labelStmt);
                }
            } else {
                Cfg.travelMod(p, tcb, true);
            }
            p.frame = null;
        }",maybe_loop_control
v,"for (SSAValue v : frame) {
                        if (v == null || !v.used) {
                            continue;
                        }
                        if (v.parent != null) {
                            froms.add(v.parent.local);
                        }
                        if (v.otherParents != null) {
                            for (SSAValue parent : v.otherParents) {
                                froms.add(parent.local);
                            }
                        }
                        froms.remove(v.local);
                        if (phis == null) {
                            phis = new ArrayList<>();
                        }
                        locals.add(v.local);
                        phis.add(Stmts.nAssign(v.local, Exprs.nPhi(froms.toArray(new Value[froms.size()]))));
                        froms.clear();
                    }",iterator
local,"for (Local local : locals) {
            int idx = local._ls_index;
            int read = readCounts[idx];
            int write = writeCounts[idx];
            if (read > 0 && write == 0) {
                // TODO if we need throw exception ?
                // or the code is dead?
            }

            if (read == 0 && write == 0) {
                // ignore the local
            } else {
                if (write <= 1) {
                    // no phi require
                    local._ls_index = -1;
                    oldLocals.add(local);
                } else if (read == 0) {
                    local._ls_index = -2;
                    needTravel = true;
                    // we are going to duplicate each usage of the local and add to method.locals,
                    // so not add the original local to method.locals
                } else {
                    needSSAAnalyze = true;
                    local._ls_index = index++;
                    oldLocals.add(local);
                }
            }
        }",iterator
v0,"for (SSAValue v0 : set) {
                SSAValue v = v0;
                if (v.used && v.local == null) {
                    v.local = new Local(nextIndex++);
                }
            }",iterator
p,"for (Stmt p = method.stmts.getFirst(); p != null; p = p.getNext()) {
                SSAValue[] frame = (SSAValue[]) p.frame;
                if (frame != null) {
                    for (int i = 0; i < frame.length; i++) {
                        SSAValue r = frame[i];
                        if (r != null && !r.used) {
                            frame[i] = null;
                        }
                    }
                }
            }",maybe_loop_control
q,"{
            Set<SSAValue> used = new HashSet<SSAValue>(aValues.size() / 2);
            Queue<SSAValue> q = new UniqueQueue<>();
            q.addAll(aValues);
            while (!q.isEmpty()) {
                SSAValue v = q.poll();
                if (v.used) {
                    used.add(v);
                    {
                        SSAValue p = v.parent;
                        if (p != null) {
                            if (!p.used) {
                                p.used = true;
                                q.add(p);
                            }
                        }
                    }
                    if (v.otherParents != null) {
                        for (SSAValue p : v.otherParents) {
                            if (!p.used) {
                                p.used = true;
                                q.add(p);
                            }
                        }
                    }

                }
            }
            return used;
        }",maybe_loop_control
p,"{
                        SSAValue p = v.parent;
                        if (p != null) {
                            if (!p.used) {
                                p.used = true;
                                q.add(p);
                            }
                        }
                    }",iterator
p,"for (SSAValue p : v.otherParents) {
                            if (!p.used) {
                                p.used = true;
                                q.add(p);
                            }
                        }",iterator
i,"for (int i = 0; i < localSize; i++) {
                SSAValue srcValue = (SSAValue) frame[i];
                if (srcValue != null) {
                    SSAValue distValue = (SSAValue) distFrame[i];
                    if (distValue == null) {
                        if (!dist.visited) {
                            distValue = newValue();
                            aValues.add(distValue);
                            distFrame[i] = distValue;
                            linkParentChildren(srcValue, distValue);
                        }
                    } else {
                        linkParentChildren(srcValue, distValue);
                    }
                }
            }",loop_control
labelStmt,"for (LabelStmt labelStmt : phiLabels) {
            List<AssignStmt> phis = (List<AssignStmt>) labelStmt.phis;

            for (AssignStmt phi : phis) {

                Local a = (Local) phi.getOp1();
                PhiExpr b = (PhiExpr) phi.getOp2();
                boolean introduceNewLocal = false;
                RegAssign aReg = (RegAssign) a.tag;
                for (Value op : b.getOps()) {
                    RegAssign bReg = (RegAssign) ((Local) op).tag;
                    if (aReg.excludes.contains(bReg)) {
                        introduceNewLocal = true;
                        break;
                    }
                }
                if (introduceNewLocal) {
                    Local newLocal = (Local) a.clone();
                    if (DEBUG) {
                        newLocal.debugName = ""x"" + method.locals.size();
                    }
                    phi.op1 = newLocal;
                    RegAssign newRegAssign = new RegAssign();
                    newLocal.tag = newRegAssign;

                    method.locals.add(newLocal);
                    Stmt newAssigStmt = Stmts.nAssign(a, newLocal);
                    Stmt next = labelStmt.getNext();
                    if (next != null && next.st == ST.IDENTITY && next.getOp2().vt == VT.EXCEPTION_REF) {
                        // it's a handler, insert after the exception ref
                        method.stmts.insertAfter(next, newAssigStmt);
                    } else {
                        method.stmts.insertAfter(labelStmt, newAssigStmt);
                    }
                    LiveV[] frame = (LiveV[]) labelStmt.frame;
                    if (DEBUG) {
                        LiveV[] copy = frame.clone();
                        LiveV n = new LiveV();
                        n.local = a;
                        n.used = true;
                        copy[a._ls_index] = new LiveV();
                        newAssigStmt.frame = copy;
                    }
                    LiveV thePhi = frame[a._ls_index];
                    thePhi.local = newLocal;
                    for (LiveV v : frame) {
                        if (v != null && v.used) {
                            RegAssign s = (RegAssign) v.local.tag;
                            s.excludes.add(newRegAssign);
                            newRegAssign.excludes.add(s);
                        }
                    }

                }
            }
        }",iterator
phi,"for (AssignStmt phi : phis) {

                Local a = (Local) phi.getOp1();
                PhiExpr b = (PhiExpr) phi.getOp2();
                boolean introduceNewLocal = false;
                RegAssign aReg = (RegAssign) a.tag;
                for (Value op : b.getOps()) {
                    RegAssign bReg = (RegAssign) ((Local) op).tag;
                    if (aReg.excludes.contains(bReg)) {
                        introduceNewLocal = true;
                        break;
                    }
                }
                if (introduceNewLocal) {
                    Local newLocal = (Local) a.clone();
                    if (DEBUG) {
                        newLocal.debugName = ""x"" + method.locals.size();
                    }
                    phi.op1 = newLocal;
                    RegAssign newRegAssign = new RegAssign();
                    newLocal.tag = newRegAssign;

                    method.locals.add(newLocal);
                    Stmt newAssigStmt = Stmts.nAssign(a, newLocal);
                    Stmt next = labelStmt.getNext();
                    if (next != null && next.st == ST.IDENTITY && next.getOp2().vt == VT.EXCEPTION_REF) {
                        // it's a handler, insert after the exception ref
                        method.stmts.insertAfter(next, newAssigStmt);
                    } else {
                        method.stmts.insertAfter(labelStmt, newAssigStmt);
                    }
                    LiveV[] frame = (LiveV[]) labelStmt.frame;
                    if (DEBUG) {
                        LiveV[] copy = frame.clone();
                        LiveV n = new LiveV();
                        n.local = a;
                        n.used = true;
                        copy[a._ls_index] = new LiveV();
                        newAssigStmt.frame = copy;
                    }
                    LiveV thePhi = frame[a._ls_index];
                    thePhi.local = newLocal;
                    for (LiveV v : frame) {
                        if (v != null && v.used) {
                            RegAssign s = (RegAssign) v.local.tag;
                            s.excludes.add(newRegAssign);
                            newRegAssign.excludes.add(s);
                        }
                    }

                }
            }",iterator
op,"for (Value op : b.getOps()) {
                    RegAssign bReg = (RegAssign) ((Local) op).tag;
                    if (aReg.excludes.contains(bReg)) {
                        introduceNewLocal = true;
                        break;
                    }
                }",iterator
aReg,"for (AssignStmt phi : phis) {

                Local a = (Local) phi.getOp1();
                PhiExpr b = (PhiExpr) phi.getOp2();
                boolean introduceNewLocal = false;
                RegAssign aReg = (RegAssign) a.tag;
                for (Value op : b.getOps()) {
                    RegAssign bReg = (RegAssign) ((Local) op).tag;
                    if (aReg.excludes.contains(bReg)) {
                        introduceNewLocal = true;
                        break;
                    }
                }
                if (introduceNewLocal) {
                    Local newLocal = (Local) a.clone();
                    if (DEBUG) {
                        newLocal.debugName = ""x"" + method.locals.size();
                    }
                    phi.op1 = newLocal;
                    RegAssign newRegAssign = new RegAssign();
                    newLocal.tag = newRegAssign;

                    method.locals.add(newLocal);
                    Stmt newAssigStmt = Stmts.nAssign(a, newLocal);
                    Stmt next = labelStmt.getNext();
                    if (next != null && next.st == ST.IDENTITY && next.getOp2().vt == VT.EXCEPTION_REF) {
                        // it's a handler, insert after the exception ref
                        method.stmts.insertAfter(next, newAssigStmt);
                    } else {
                        method.stmts.insertAfter(labelStmt, newAssigStmt);
                    }
                    LiveV[] frame = (LiveV[]) labelStmt.frame;
                    if (DEBUG) {
                        LiveV[] copy = frame.clone();
                        LiveV n = new LiveV();
                        n.local = a;
                        n.used = true;
                        copy[a._ls_index] = new LiveV();
                        newAssigStmt.frame = copy;
                    }
                    LiveV thePhi = frame[a._ls_index];
                    thePhi.local = newLocal;
                    for (LiveV v : frame) {
                        if (v != null && v.used) {
                            RegAssign s = (RegAssign) v.local.tag;
                            s.excludes.add(newRegAssign);
                            newRegAssign.excludes.add(s);
                        }
                    }

                }
            }",break_loop_control
v,"for (LiveV v : frame) {
                        if (v != null && v.used) {
                            RegAssign s = (RegAssign) v.local.tag;
                            s.excludes.add(newRegAssign);
                            newRegAssign.excludes.add(s);
                        }
                    }",loop_control
labelStmt,"for (LabelStmt labelStmt : phiLabels) {
            List<AssignStmt> phis = (List<AssignStmt>) labelStmt.phis;
            LiveV[] frame = (LiveV[]) labelStmt.frame;
            for (Stmt from : labelStmt._cfg_froms) {
                if (from.visited) { // at lease it is reached by cfg
                    for (AssignStmt phi : phis) {
                        Local a = (Local) phi.getOp1();
                        LiveV v = frame[a._ls_index];
                        Local local = v.stmt2regMap.get(from);
                        if (local != a) {
                            buff.add(Stmts.nAssign(a, local));
                        }
                    }
                    insertAssignPath(method.stmts, from, labelStmt, buff);
                    buff.clear();
                }
            }
        }",iterator
from,"for (Stmt from : labelStmt._cfg_froms) {
                if (from.visited) { // at lease it is reached by cfg
                    for (AssignStmt phi : phis) {
                        Local a = (Local) phi.getOp1();
                        LiveV v = frame[a._ls_index];
                        Local local = v.stmt2regMap.get(from);
                        if (local != a) {
                            buff.add(Stmts.nAssign(a, local));
                        }
                    }
                    insertAssignPath(method.stmts, from, labelStmt, buff);
                    buff.clear();
                }
            }",iterator
phi,"for (AssignStmt phi : phis) {
                        Local a = (Local) phi.getOp1();
                        LiveV v = frame[a._ls_index];
                        Local local = v.stmt2regMap.get(from);
                        if (local != a) {
                            buff.add(Stmts.nAssign(a, local));
                        }
                    }",iterator
as,"for (AssignStmt as : buff) {
                stmts.insertBefore(from, as);
            }",iterator
as,"for (AssignStmt as : buff) {
                stmts.insertAfter(from, as);
            }",iterator
as,"for (AssignStmt as : buff) {
            Local left = (Local) as.getOp1();
            {
                LiveV liveV = new LiveV();
                liveV.local = left;
                liveV.used = true;
                newLiveVs.add(liveV);
            }
            RegAssign leftRegAssign = (RegAssign) left.tag;
            Local right = (Local) as.getOp2();
            int toSkip = right._ls_index;
            for (int i = 0; i < frame.length; i++) {
                if (i == toSkip) {
                    continue;
                }
                LiveV v = frame[i];
                if (v != null && v.used) {
                    RegAssign assign = (RegAssign) v.local.tag;
                    assign.excludes.add(leftRegAssign);
                    leftRegAssign.excludes.add(assign);
                }
            }
            for (AssignStmt as2 : buff) {
                RegAssign assign = (RegAssign) ((Local) as2.getOp1()).tag;
                assign.excludes.add(leftRegAssign);
                leftRegAssign.excludes.add(assign);
            }
        }",iterator
i,"for (int i = 0; i < frame.length; i++) {
                if (i == toSkip) {
                    continue;
                }
                LiveV v = frame[i];
                if (v != null && v.used) {
                    RegAssign assign = (RegAssign) v.local.tag;
                    assign.excludes.add(leftRegAssign);
                    leftRegAssign.excludes.add(assign);
                }
            }",loop_control
i,"for (int i = 0; i < newLiveVs.size(); i++) {
            newFrame[i + frame.length] = newLiveVs.get(i);
        }",loop_control
as2,"for (AssignStmt as2 : buff) {
                RegAssign assign = (RegAssign) ((Local) as2.getOp1()).tag;
                assign.excludes.add(leftRegAssign);
                leftRegAssign.excludes.add(assign);
            }",iterator
phiLabel,"for (LabelStmt phiLabel : method.phiLabels) {
            Stmt stmt = phiLabel.getNext();
            if (stmt.st == ST.LABEL) {
                LabelStmt labelStmt2 = (LabelStmt) stmt;
                if (labelStmt2.phis != null && labelStmt2.phis.size() > 0) {
                    method.stmts.insertAfter(phiLabel, Stmts.nNop());
                }
            }
        }",iterator
local,"for (Local local : method.locals) {
            local.tag = null;
        }",iterator
stmt,"for (LabelStmt phiLabel : method.phiLabels) {
            Stmt stmt = phiLabel.getNext();
            if (stmt.st == ST.LABEL) {
                LabelStmt labelStmt2 = (LabelStmt) stmt;
                if (labelStmt2.phis != null && labelStmt2.phis.size() > 0) {
                    method.stmts.insertAfter(phiLabel, Stmts.nNop());
                }
            }
        }",iterator
stmt,"for (Stmt stmt : method.stmts) {
            stmt.frame = null;
        }",iterator
labelStmt,"for (LabelStmt labelStmt : method.phiLabels) {
            labelStmt.phis = null;
        }",iterator
local,"for (Local local : method.locals) {
            local.tag = new RegAssign();
        }",iterator
local,"{
                            RegAssign b = (RegAssign) v.local.tag;
                            regAssignTo.excludes.add(b);
                            b.excludes.add(regAssignTo);
                        }",iterator
local,"{
                                RegAssign b = (RegAssign) v.local.tag;
                                a.excludes.add(b);
                                b.excludes.add(a);
                            }",iterator
stmt,"for (Stmt stmt : method.stmts) {
            if ((stmt.st == ST.ASSIGN || stmt.st == ST.IDENTITY) && stmt.getOp1().vt == VT.LOCAL) {
                Local localAssignTo = (Local) stmt.getOp1();
                RegAssign regAssignTo = (RegAssign) localAssignTo.tag;
                Set<Integer> excludeIdx = new HashSet<>();
                Cfg.collectTos(stmt, tos);
                for (Stmt target : tos) {
                    LiveV frame[] = (LiveV[]) target.frame;
                    if (frame == null) {
                        continue;
                    }
                    // exclude thisReg and phiReg
                    excludeIdx.clear();
                    excludeIdx.add(localAssignTo._ls_index);
                    if (target.st == ST.LABEL) {
                        LabelStmt label = (LabelStmt) target;
                        if (label.phis != null) {
                            for (AssignStmt phiAssignStmt : (List<AssignStmt>) label.phis) {
                                Local phiLocal = (Local) phiAssignStmt.getOp1();
                                excludeIdx.add(phiLocal._ls_index);
                            }
                        }
                    }
                    for (int i = 0; i < frame.length; i++) {
                        if (excludeIdx.contains(i)) {
                            continue;
                        }
                        LiveV v = frame[i];
                        if (v != null && v.used) {
                            RegAssign b = (RegAssign) v.local.tag;
                            regAssignTo.excludes.add(b);
                            b.excludes.add(regAssignTo);
                        }
                    }
                }
                tos.clear();
            } else if (stmt.st == ST.LABEL) { //
                // https://github.com/pxb1988/dex2jar/issues/477
                // the exception handler is dead and stmt.frame is null
                LabelStmt label = (LabelStmt) stmt;
                if (label.phis != null && stmt.frame != null) {
                    for (AssignStmt phiAssignStmt : (List<AssignStmt>) label.phis) {
                        Local phiLocal = (Local) phiAssignStmt.getOp1();
                        RegAssign a = (RegAssign) phiLocal.tag;
                        LiveV frame[] = (LiveV[]) stmt.frame;
                        for (LiveV v : frame) {
                            if (v != null && v.used) {
                                RegAssign b = (RegAssign) v.local.tag;
                                a.excludes.add(b);
                                b.excludes.add(a);
                            }
                        }
                    }
                }
            }
        }",iterator
target,"for (Stmt target : tos) {
                    LiveV frame[] = (LiveV[]) target.frame;
                    if (frame == null) {
                        continue;
                    }
                    // exclude thisReg and phiReg
                    excludeIdx.clear();
                    excludeIdx.add(localAssignTo._ls_index);
                    if (target.st == ST.LABEL) {
                        LabelStmt label = (LabelStmt) target;
                        if (label.phis != null) {
                            for (AssignStmt phiAssignStmt : (List<AssignStmt>) label.phis) {
                                Local phiLocal = (Local) phiAssignStmt.getOp1();
                                excludeIdx.add(phiLocal._ls_index);
                            }
                        }
                    }
                    for (int i = 0; i < frame.length; i++) {
                        if (excludeIdx.contains(i)) {
                            continue;
                        }
                        LiveV v = frame[i];
                        if (v != null && v.used) {
                            RegAssign b = (RegAssign) v.local.tag;
                            regAssignTo.excludes.add(b);
                            b.excludes.add(regAssignTo);
                        }
                    }
                }",iterator
phiAssignStmt,"for (AssignStmt phiAssignStmt : (List<AssignStmt>) label.phis) {
                                Local phiLocal = (Local) phiAssignStmt.getOp1();
                                excludeIdx.add(phiLocal._ls_index);
                            }",iterator
phiAssignStmt,"for (AssignStmt phiAssignStmt : (List<AssignStmt>) label.phis) {
                        Local phiLocal = (Local) phiAssignStmt.getOp1();
                        RegAssign a = (RegAssign) phiLocal.tag;
                        LiveV frame[] = (LiveV[]) stmt.frame;
                        for (LiveV v : frame) {
                            if (v != null && v.used) {
                                RegAssign b = (RegAssign) v.local.tag;
                                a.excludes.add(b);
                                b.excludes.add(a);
                            }
                        }
                    }",iterator
p,"for (Stmt p = method.stmts.getFirst(); p != null; p = p.getNext()) {
                LiveV[] frame = (LiveV[]) p.frame;
                if (frame != null) {
                    for (int i = 0; i < frame.length; i++) {
                        LiveV r = frame[i];
                        if (r != null) {
                            if (!r.used) {
                                frame[i] = null;
                            }
                        }
                    }
                }
            }",maybe_loop_control
i,"for (int i = 0; i < frame.length; i++) {
                        LiveV r = frame[i];
                        if (r != null) {
                            if (!r.used) {
                                frame[i] = null;
                            }
                        }
                    }",loop_control
q,"{
            Set<LiveV> used = new HashSet<LiveV>(aValues.size() / 2);
            Queue<LiveV> q = new UniqueQueue<>();
            q.addAll(aValues);

            while (!q.isEmpty()) {
                LiveV v = q.poll();
                if (v.used) {
                    if (used.contains(v)) {
                        continue;
                    }
                    used.add(v);
                    {
                        LiveV parent = v.parent;
                        if (parent != null && !parent.used) {
                            parent.used = true;
                            q.add(parent);
                        }
                    }
                    {
                        List<LiveV> otherParent = v.otherParents;
                        if (otherParent != null && otherParent.size() > 0) {
                            for (LiveV parent : otherParent) {
                                if (parent != null && !parent.used) {
                                    parent.used = true;
                                    q.add(parent);
                                }
                            }
                            v.otherParents = null;
                        }
                    }
                }
            }
            for (LiveV v : aValues) {
                v.parent = null;
            }
            aValues = null;

            return used;
        }",maybe_loop_control
parent,"{
                        LiveV parent = v.parent;
                        if (parent != null && !parent.used) {
                            parent.used = true;
                            q.add(parent);
                        }
                    }",iterator
parent,"for (LiveV parent : otherParent) {
                                if (parent != null && !parent.used) {
                                    parent.used = true;
                                    q.add(parent);
                                }
                            }",iterator
parent,"for (LiveV v : aValues) {
                v.parent = null;
            }",iterator
v,"{
                LiveV v = q.poll();
                if (v.used) {
                    if (used.contains(v)) {
                        continue;
                    }
                    used.add(v);
                    {
                        LiveV parent = v.parent;
                        if (parent != null && !parent.used) {
                            parent.used = true;
                            q.add(parent);
                        }
                    }
                    {
                        List<LiveV> otherParent = v.otherParents;
                        if (otherParent != null && otherParent.size() > 0) {
                            for (LiveV parent : otherParent) {
                                if (parent != null && !parent.used) {
                                    parent.used = true;
                                    q.add(parent);
                                }
                            }
                            v.otherParents = null;
                        }
                    }
                }
            }",iterator
v,"for (LiveV v : aValues) {
                v.parent = null;
            }",iterator
phiAssignStmt,"for (AssignStmt phiAssignStmt : (List<AssignStmt>) label.phis) {
                        Local phiLocal = (Local) phiAssignStmt.getOp1();
                        phiLives.put(phiLocal._ls_index, phiAssignStmt);
                    }",iterator
phiAssignStmt,"for (AssignStmt phiAssignStmt : phiLives.values()) {
                Local phiLocal = (Local) phiAssignStmt.getOp1();

                LiveV distValue;
                if (firstMerge) {
                    distValue = new LiveV();
                    distValue.local = phiLocal;
                    distValue.stmt2regMap = new HashMap<>();
                    distFrame[phiLocal._ls_index] = distValue;
                } else {
                    distValue = distFrame[phiLocal._ls_index];
                }

                List<LiveV> liveVs = new ArrayList();

                LiveV possiblePhiLocal = srcFrame[phiLocal._ls_index];
                if (possiblePhiLocal != null) {
                    liveVs.add(possiblePhiLocal);
                }

                for (Value p0 : phiAssignStmt.getOp2().getOps()) {
                    Local srcLocal = (Local) p0;
                    LiveV s = srcFrame[srcLocal._ls_index];
                    if (s != null) {
                        liveVs.add(s);
                    }
                }
                Collections.sort(liveVs, sortByHopsASC);
                LiveV a = liveVs.get(0); // this value assign to
                                         // phiLocal in srcFrame
                a.used = true;
                distValue.stmt2regMap.put(src, a.local);
            }",iterator
p0,"for (Value p0 : phiAssignStmt.getOp2().getOps()) {
                    Local srcLocal = (Local) p0;
                    LiveV s = srcFrame[srcLocal._ls_index];
                    if (s != null) {
                        liveVs.add(s);
                    }
                }",iterator
i,"for (int i = 0; i < distFrame.length; i++) {
                    if (phiLives.containsKey(i)) { // skip phi
                        continue;
                    }
                    LiveV srcV = srcFrame[i];
                    if (srcV != null) {
                        LiveV distV = newValue();
                        aValues.add(distV);
                        distV.parent = srcV;
                        distV.hops = srcV.hops + 1;
                        distV.local = srcV.local;
                        distFrame[i] = distV;
                    }
                }",loop_control
i,"for (int i = 0; i < distFrame.length; i++) {
                    if (phiLives.containsKey(i)) {
                        continue;
                    }
                    LiveV srcV = srcFrame[i];
                    LiveV distV = distFrame[i];
                    if (srcV != null && distV != null) {
                        if (distV.otherParents == null) {
                            distV.otherParents = new ArrayList(5);
                        }
                        distV.otherParents.add(srcV);
                    }
                }",loop_control
local,"for (Local local : m.locals) {
            local.tag = null;
        }",iterator
local,"for (Local local : m.locals) {
            ConstAnalyzeValue cav = (ConstAnalyzeValue) local.tag;
            if (Boolean.TRUE.equals(cav.isConst)) {
                boolean allTosAreCst = true;
                for (ConstAnalyzeValue c : cav.assignTo) {
                    if (!Boolean.TRUE.equals(c.isConst)) {
                        allTosAreCst = false;
                        break;
                    }
                }
                if (allTosAreCst) {
                    cav.replacable = true;
                }
            }
        }",iterator
c,"for (ConstAnalyzeValue c : cav.assignTo) {
                    if (!Boolean.TRUE.equals(c.isConst)) {
                        allTosAreCst = false;
                        break;
                    }
                }",iterator
c,"for (ConstAnalyzeValue c : cav.assignTo) {
                    if (!Boolean.TRUE.equals(c.isConst)) {
                        allTosAreCst = false;
                        break;
                    }
                }",break_loop_control
queue,"{
        Queue<Local> queue = new UniqueQueue<>();
        queue.addAll(m.locals);
        while (!queue.isEmpty()) {
            ConstAnalyzeValue cav = (ConstAnalyzeValue) queue.poll().tag;

            Object cst = cav.cst;

            if (cav.isConst == null) {
                if (cst != null) {// we have a cst
                    boolean allCstEquals = true;
                    for (ConstAnalyzeValue p0 : cav.assignFrom) {
                        if (!cst.equals(p0.cst)) {
                            allCstEquals = false;
                            break;
                        }
                    }
                    if (allCstEquals) {
                        cav.isConst = true;

                    }
                }
            }

            if (cst != null || Boolean.TRUE.equals(cav.isConst)) {
                for (ConstAnalyzeValue p0 : cav.assignTo) {
                    if (p0.isConst == null) {
                        if (p0.cst == null) {
                            p0.cst = cst;
                        }
                        queue.add(p0.local);
                    }
                }
            }

            if (Boolean.FALSE.equals(cav.isConst)) {
                cav.cst = null;
                for (ConstAnalyzeValue c : cav.assignTo) {
                    if (!Boolean.FALSE.equals(c.isConst)) {
                        c.cst = null;
                        c.isConst = false;
                        queue.add(c.local);
                    }
                }
            }
        }
    }",maybe_loop_control
p0,"for (ConstAnalyzeValue p0 : cav.assignFrom) {
                        if (!cst.equals(p0.cst)) {
                            allCstEquals = false;
                            break;
                        }
                    }",iterator
p0,"for (ConstAnalyzeValue p0 : cav.assignTo) {
                    if (p0.isConst == null) {
                        if (p0.cst == null) {
                            p0.cst = cst;
                        }
                        queue.add(p0.local);
                    }
                }",iterator
c,"for (ConstAnalyzeValue c : cav.assignTo) {
                    if (!Boolean.FALSE.equals(c.isConst)) {
                        c.cst = null;
                        c.isConst = false;
                        queue.add(c.local);
                    }
                }",iterator
p0,"for (ConstAnalyzeValue p0 : cav.assignFrom) {
                        if (!cst.equals(p0.cst)) {
                            allCstEquals = false;
                            break;
                        }
                    }",break_loop_control
p0,"for (ConstAnalyzeValue p0 : cav.assignTo) {
                    if (p0.isConst == null) {
                        if (p0.cst == null) {
                            p0.cst = cst;
                        }
                        queue.add(p0.local);
                    }
                }",break_loop_control
cst,"{
            ConstAnalyzeValue cav = (ConstAnalyzeValue) queue.poll().tag;

            Object cst = cav.cst;

            if (cav.isConst == null) {
                if (cst != null) {// we have a cst
                    boolean allCstEquals = true;
                    for (ConstAnalyzeValue p0 : cav.assignFrom) {
                        if (!cst.equals(p0.cst)) {
                            allCstEquals = false;
                            break;
                        }
                    }
                    if (allCstEquals) {
                        cav.isConst = true;

                    }
                }
            }

            if (cst != null || Boolean.TRUE.equals(cav.isConst)) {
                for (ConstAnalyzeValue p0 : cav.assignTo) {
                    if (p0.isConst == null) {
                        if (p0.cst == null) {
                            p0.cst = cst;
                        }
                        queue.add(p0.local);
                    }
                }
            }

            if (Boolean.FALSE.equals(cav.isConst)) {
                cav.cst = null;
                for (ConstAnalyzeValue c : cav.assignTo) {
                    if (!Boolean.FALSE.equals(c.isConst)) {
                        c.cst = null;
                        c.isConst = false;
                        queue.add(c.local);
                    }
                }
            }
        }",break_loop_control
p,"for (Stmt p = m.stmts.getFirst(); p != null; p = p.getNext()) {
            if (p.st == ST.ASSIGN || p.st == ST.IDENTITY) {
                E2Stmt e2 = (E2Stmt) p;
                Value op1 = e2.op1.trim();
                Value op2 = e2.op2.trim();
                if (op1.vt == VT.LOCAL) {
                    ConstAnalyzeValue cav = (ConstAnalyzeValue) ((Local) op1).tag;
                    if (op2.vt == VT.CONSTANT) {
                        Constant c = (Constant) op2;
                        cav.isConst = true;
                        cav.cst = c.value;
                    } else if (op2.vt == VT.LOCAL) {
                        Local local2 = (Local) op2;
                        ConstAnalyzeValue zaf2 = (ConstAnalyzeValue) local2.tag;
                        cav.assignFrom.add(zaf2);
                        zaf2.assignTo.add(cav);
                    } else if (op2.vt == VT.PHI) {
                        PhiExpr pe = (PhiExpr) op2;
                        for (Value v : pe.ops) {
                            ConstAnalyzeValue zaf2 = (ConstAnalyzeValue) ((Local) v.trim()).tag;
                            cav.assignFrom.add(zaf2);
                            zaf2.assignTo.add(cav);
                        }
                    } else {
                        cav.isConst = Boolean.FALSE;
                    }
                }
            }
        }",maybe_loop_control
local,"for (Local local : m.locals) {
            local.tag = new ConstAnalyzeValue(local);
        }",iterator
var,"for (LocalVar var : irMethod.vars) {
            if (var.reg.trim().vt != VT.LOCAL) {
                if (var.reg.trim().vt == VT.CONSTANT) {
                    Local n = new Local(i++);
                    Value old = var.reg.trim();
                    irMethod.stmts.insertBefore(var.start, Stmts.nAssign(n, old));
                    var.reg = n;
                    irMethod.locals.add(n);
                } else {
                    // throw new DexExcpeption(""not support"");
                }
            }
        }",iterator
p,"for (Stmt p = method.stmts.getFirst(); p != null; p = p.getNext()) {
            if (p.st == Stmt.ST.ASSIGN) {
                AssignStmt as = (AssignStmt) p;
                if (as.getOp1().vt == Value.VT.LOCAL) {
                    if (as.getOp2().vt == Value.VT.CONSTANT) {
                        assignStmtList.add(as);
                        cstMap.put((Local) as.getOp1(), ((Constant) as.getOp2()).value);
                    } else if (as.getOp2().vt == Value.VT.LOCAL) {
                        cstMap.put((Local) as.getOp1(), as.getOp2());
                    }
                }
            }
        }",maybe_loop_control
p,"for (Value p : vs) {
                                Object cst = cstMap.get(p);
                                if (cst == null) {
                                    allEqual = false;
                                    break;
                                }
                                if (sameCst == null) {
                                    sameCst = cst;
                                } else if (!sameCst.equals(cst)) {
                                    allEqual = false;
                                    break;
                                }
                            }",maybe_loop_control
loopAgain,"{
            boolean loopAgain = true;
            while (loopAgain) {
                loopAgain = false;
                usedInPhi.clear();
                for (Iterator<LabelStmt> it = phiLabels.iterator(); it.hasNext();) {
                    LabelStmt labelStmt = it.next();
                    if (labelStmt.phis != null) {
                        for (Iterator<AssignStmt> it2 = labelStmt.phis.iterator(); it2.hasNext();) {
                            AssignStmt phi = it2.next();
                            Value[] vs = phi.getOp2().getOps();
                            Object sameCst = null;
                            boolean allEqual = true;
                            for (Value p : vs) {
                                Object cst = cstMap.get(p);
                                if (cst == null) {
                                    allEqual = false;
                                    break;
                                }
                                if (sameCst == null) {
                                    sameCst = cst;
                                } else if (!sameCst.equals(cst)) {
                                    allEqual = false;
                                    break;
                                }
                            }
                            if (allEqual) { // all are same constant
                                cstMap.put((Local) phi.getOp1(), sameCst);
                                if (sameCst instanceof Local) {
                                    phi.setOp2((Value) sameCst);
                                } else {
                                    phi.setOp2(Exprs.nConstant(sameCst));
                                    assignStmtList.add(phi);
                                }
                                it2.remove();
                                method.stmts.insertAfter(labelStmt, phi);
                                changed = true;
                                loopAgain = true; // loop again
                            } else {
                                usedInPhi.addAll(Arrays.asList(phi.getOp2().getOps()));
                            }
                        }
                        if (labelStmt.phis.size() == 0) {
                            it.remove();
                        }
                    }
                }
            }
        }",maybe_loop_control
it,"for (Iterator<LabelStmt> it = phiLabels.iterator(); it.hasNext();) {
                    LabelStmt labelStmt = it.next();
                    if (labelStmt.phis != null) {
                        for (Iterator<AssignStmt> it2 = labelStmt.phis.iterator(); it2.hasNext();) {
                            AssignStmt phi = it2.next();
                            Value[] vs = phi.getOp2().getOps();
                            Object sameCst = null;
                            boolean allEqual = true;
                            for (Value p : vs) {
                                Object cst = cstMap.get(p);
                                if (cst == null) {
                                    allEqual = false;
                                    break;
                                }
                                if (sameCst == null) {
                                    sameCst = cst;
                                } else if (!sameCst.equals(cst)) {
                                    allEqual = false;
                                    break;
                                }
                            }
                            if (allEqual) { // all are same constant
                                cstMap.put((Local) phi.getOp1(), sameCst);
                                if (sameCst instanceof Local) {
                                    phi.setOp2((Value) sameCst);
                                } else {
                                    phi.setOp2(Exprs.nConstant(sameCst));
                                    assignStmtList.add(phi);
                                }
                                it2.remove();
                                method.stmts.insertAfter(labelStmt, phi);
                                changed = true;
                                loopAgain = true; // loop again
                            } else {
                                usedInPhi.addAll(Arrays.asList(phi.getOp2().getOps()));
                            }
                        }
                        if (labelStmt.phis.size() == 0) {
                            it.remove();
                        }
                    }
                }",iterator
it,"for (Iterator<AssignStmt> it = assignStmtList.iterator(); it.hasNext();) {
            AssignStmt as = it.next();
            if (!usedInPhi.contains(as.getOp1())) {
                it.remove();
                method.stmts.remove(as);
                method.locals.remove(as.getOp1());
                changed = true;
            }
            toReplace.put((Local) as.getOp1(), as.getOp2());

        }",iterator
it2,"for (Iterator<AssignStmt> it2 = labelStmt.phis.iterator(); it2.hasNext();) {
                            AssignStmt phi = it2.next();
                            Value[] vs = phi.getOp2().getOps();
                            Object sameCst = null;
                            boolean allEqual = true;
                            for (Value p : vs) {
                                Object cst = cstMap.get(p);
                                if (cst == null) {
                                    allEqual = false;
                                    break;
                                }
                                if (sameCst == null) {
                                    sameCst = cst;
                                } else if (!sameCst.equals(cst)) {
                                    allEqual = false;
                                    break;
                                }
                            }
                            if (allEqual) { // all are same constant
                                cstMap.put((Local) phi.getOp1(), sameCst);
                                if (sameCst instanceof Local) {
                                    phi.setOp2((Value) sameCst);
                                } else {
                                    phi.setOp2(Exprs.nConstant(sameCst));
                                    assignStmtList.add(phi);
                                }
                                it2.remove();
                                method.stmts.insertAfter(labelStmt, phi);
                                changed = true;
                                loopAgain = true; // loop again
                            } else {
                                usedInPhi.addAll(Arrays.asList(phi.getOp2().getOps()));
                            }
                        }",iterator
p,"for (Stmt p = method.stmts.getFirst(); p != null; p = p.getNext()) {
            if (p.st == Stmt.ST.ASSIGN) {
                AssignStmt as = (AssignStmt) p;
                if (as.getOp1().vt == Value.VT.LOCAL) {
                    if (as.getOp2().vt == Value.VT.CONSTANT) {
                        assignStmtList.add(as);
                        cstMap.put((Local) as.getOp1(), ((Constant) as.getOp2()).value);
                    } else if (as.getOp2().vt == Value.VT.LOCAL) {
                        cstMap.put((Local) as.getOp1(), as.getOp2());
                    }
                }
            }
        }",iterator
p,"for (Value p : vs) {
                                Object cst = cstMap.get(p);
                                if (cst == null) {
                                    allEqual = false;
                                    break;
                                }
                                if (sameCst == null) {
                                    sameCst = cst;
                                } else if (!sameCst.equals(cst)) {
                                    allEqual = false;
                                    break;
                                }
                            }",iterator
sameCst,"for (Iterator<AssignStmt> it2 = labelStmt.phis.iterator(); it2.hasNext();) {
                            AssignStmt phi = it2.next();
                            Value[] vs = phi.getOp2().getOps();
                            Object sameCst = null;
                            boolean allEqual = true;
                            for (Value p : vs) {
                                Object cst = cstMap.get(p);
                                if (cst == null) {
                                    allEqual = false;
                                    break;
                                }
                                if (sameCst == null) {
                                    sameCst = cst;
                                } else if (!sameCst.equals(cst)) {
                                    allEqual = false;
                                    break;
                                }
                            }
                            if (allEqual) { // all are same constant
                                cstMap.put((Local) phi.getOp1(), sameCst);
                                if (sameCst instanceof Local) {
                                    phi.setOp2((Value) sameCst);
                                } else {
                                    phi.setOp2(Exprs.nConstant(sameCst));
                                    assignStmtList.add(phi);
                                }
                                it2.remove();
                                method.stmts.insertAfter(labelStmt, phi);
                                changed = true;
                                loopAgain = true; // loop again
                            } else {
                                usedInPhi.addAll(Arrays.asList(phi.getOp2().getOps()));
                            }
                        }",break_loop_control
as,"for (AssignStmt as : assignStmtList) {
            Value right = as.getOp2();
            T to = toReplace.get(right);
            if (to != null) {
                as.setOp2(to);
            }
        }",iterator
labelStmt,"for (LabelStmt labelStmt : phiLabels) {
                for (AssignStmt phi : labelStmt.phis) {
                    usedInPhi.addAll(Arrays.asList(phi.getOp2().getOps()));
                }
            }",iterator
it,"for (Iterator<AssignStmt> it = assignStmtList.iterator(); it.hasNext(); ) {
            AssignStmt as = it.next();
            if (!usedInPhi.contains(as.getOp1())) {
                it.remove();
                stmts.remove(as);
                toReplace.put((Local) as.getOp1(), (Local) as.getOp2());
                changed = true;
            }
        }",iterator
labelStmt,"for (LabelStmt labelStmt : phiLabels) {
                for (AssignStmt phi : labelStmt.phis) {
                    Value[] ops = phi.getOp2().getOps();
                    for (Value op : ops) {
                        Value n = toReplace.get(op);
                        if (n != null) {
                            set.add(n);
                        } else {
                            set.add(op);
                        }
                    }
                    set.remove(phi.getOp1());
                    phi.getOp2().setOps(set.toArray(new Value[set.size()]));
                    set.clear();
                }
            }",iterator
phi,"for (AssignStmt phi : labelStmt.phis) {
                    Value[] ops = phi.getOp2().getOps();
                    for (Value op : ops) {
                        Value n = toReplace.get(op);
                        if (n != null) {
                            set.add(n);
                        } else {
                            set.add(op);
                        }
                    }
                    set.remove(phi.getOp1());
                    phi.getOp2().setOps(set.toArray(new Value[set.size()]));
                    set.clear();
                }",iterator
op,"for (Value op : ops) {
                        Value n = toReplace.get(op);
                        if (n != null) {
                            set.add(n);
                        } else {
                            set.add(op);
                        }
                    }",iterator
itLabel,"for (Iterator<LabelStmt> itLabel = phiLabels.iterator(); itLabel.hasNext(); ) {
                LabelStmt labelStmt = itLabel.next();
                for (Iterator<AssignStmt> it = labelStmt.phis.iterator(); it.hasNext(); ) {
                    AssignStmt phi = it.next();
                    set.addAll(Arrays.asList(phi.getOp2().getOps()));
                    set.remove(phi.getOp1());
                    if (set.size() == 1) {
                        it.remove();
                        changed = true;
                        toReplace.put((Local) phi.getOp1(), (Local) set.iterator().next());
                    }
                    set.clear();
                }
                if (labelStmt.phis.size() == 0) {
                    labelStmt.phis = null;
                    itLabel.remove();
                }
            }",iterator
it,"for (Iterator<AssignStmt> it = labelStmt.phis.iterator(); it.hasNext(); ) {
                    AssignStmt phi = it.next();
                    set.addAll(Arrays.asList(phi.getOp2().getOps()));
                    set.remove(phi.getOp1());
                    if (set.size() == 1) {
                        it.remove();
                        changed = true;
                        toReplace.put((Local) phi.getOp1(), (Local) set.iterator().next());
                    }
                    set.clear();
                }",iterator
q,"{
            Set<Local> toDeletePhiAssign = new HashSet<>();
            Map<Local, PhiObject> phis;
            // detect loop init in phi
            phis = collectPhiObjects(phiLabels);
            Queue<PhiObject> q = new UniqueQueue<>();
            q.addAll(phis.values());
            while (!q.isEmpty()) {
                PhiObject po = q.poll();
                for (PhiObject child : po.children) {
                    if (child.isInitByPhi) {
                        if (child.parent.addAll(po.parent)) {
                            q.add(child);
                        }
                    }
                }
            }
            for (PhiObject po : phis.values()) {
                if (po.isInitByPhi) {
                    Local local = null;
                    for (PhiObject p : po.parent) {
                        if (!p.isInitByPhi) {
                            if (local == null) { // the first non-phi value
                                local = p.local;
                            } else {
                                local = null;
                                break;
                            }
                        }
                    }
                    if (local != null) {
                        toReplace.put(po.local, local);
                        toDeletePhiAssign.add(po.local);
                        changed = true;
                    }
                }
            }
            for (Iterator<LabelStmt> itLabel = phiLabels.iterator(); itLabel.hasNext(); ) {
                LabelStmt labelStmt = itLabel.next();
                for (Iterator<AssignStmt> it = labelStmt.phis.iterator(); it.hasNext(); ) {
                    AssignStmt phi = it.next();
                    if (toDeletePhiAssign.contains(phi.getOp1())) {
                        it.remove();
                    }
                }
                if (labelStmt.phis.size() == 0) {
                    labelStmt.phis = null;
                    itLabel.remove();
                }
            }
        }",maybe_loop_control
child,"for (PhiObject child : po.children) {
                    if (child.isInitByPhi) {
                        if (child.parent.addAll(po.parent)) {
                            q.add(child);
                        }
                    }
                }",iterator
po,"{
                PhiObject po = q.poll();
                for (PhiObject child : po.children) {
                    if (child.isInitByPhi) {
                        if (child.parent.addAll(po.parent)) {
                            q.add(child);
                        }
                    }
                }
            }",iterator
po,"for (PhiObject po : phis.values()) {
                if (po.isInitByPhi) {
                    Local local = null;
                    for (PhiObject p : po.parent) {
                        if (!p.isInitByPhi) {
                            if (local == null) { // the first non-phi value
                                local = p.local;
                            } else {
                                local = null;
                                break;
                            }
                        }
                    }
                    if (local != null) {
                        toReplace.put(po.local, local);
                        toDeletePhiAssign.add(po.local);
                        changed = true;
                    }
                }
            }",iterator
p,"for (PhiObject p : po.parent) {
                        if (!p.isInitByPhi) {
                            if (local == null) { // the first non-phi value
                                local = p.local;
                            } else {
                                local = null;
                                break;
                            }
                        }
                    }",iterator
itLabel,"for (Iterator<LabelStmt> itLabel = phiLabels.iterator(); itLabel.hasNext(); ) {
                LabelStmt labelStmt = itLabel.next();
                for (Iterator<AssignStmt> it = labelStmt.phis.iterator(); it.hasNext(); ) {
                    AssignStmt phi = it.next();
                    if (toDeletePhiAssign.contains(phi.getOp1())) {
                        it.remove();
                    }
                }
                if (labelStmt.phis.size() == 0) {
                    labelStmt.phis = null;
                    itLabel.remove();
                }
            }",iterator
it,"for (Iterator<AssignStmt> it = labelStmt.phis.iterator(); it.hasNext(); ) {
                    AssignStmt phi = it.next();
                    if (toDeletePhiAssign.contains(phi.getOp1())) {
                        it.remove();
                    }
                }",iterator
labelStmt,"for (LabelStmt labelStmt : phiLabels) {
            for (AssignStmt as : labelStmt.phis) {
                Local local = (Local) as.getOp1();
                PhiObject child = getOrCreate(phis, local);
                child.isInitByPhi = true;
                for (Value op : as.getOp2().getOps()) {
                    if (op == local) {
                        continue;
                    }
                    PhiObject parent = getOrCreate(phis, (Local) op);
                    linkPhiObject(parent, child);
                }
            }
        }",iterator
as,"for (AssignStmt as : labelStmt.phis) {
                Local local = (Local) as.getOp1();
                PhiObject child = getOrCreate(phis, local);
                child.isInitByPhi = true;
                for (Value op : as.getOp2().getOps()) {
                    if (op == local) {
                        continue;
                    }
                    PhiObject parent = getOrCreate(phis, (Local) op);
                    linkPhiObject(parent, child);
                }
            }",iterator
op,"for (Value op : as.getOp2().getOps()) {
                    if (op == local) {
                        continue;
                    }
                    PhiObject parent = getOrCreate(phis, (Local) op);
                    linkPhiObject(parent, child);
                }",iterator
e,"for (Map.Entry<Local, T> e : set) {
                T b = e.getValue();
                if(b instanceof  Local) {
                    T n = toReplace.get(b);
                    if (n != null && b != n) {
                        changed = true;
                        e.setValue(n);
                    }
                }
            }",iterator
changed,"{
        List<Map.Entry<Local, T>> set = new ArrayList<>(toReplace.entrySet());
        Collections.sort(set, new Comparator<Map.Entry<Local, T>>() {
            @Override
            public int compare(Map.Entry<Local, T> localTEntry, Map.Entry<Local, T> t1) {
                return Integer.compare(localTEntry.getKey()._ls_index, t1.getKey()._ls_index);
            }
        });

        boolean changed = true;
        while (changed) {
            changed = false;
            for (Map.Entry<Local, T> e : set) {
                T b = e.getValue();
                if(b instanceof  Local) {
                    T n = toReplace.get(b);
                    if (n != null && b != n) {
                        changed = true;
                        e.setValue(n);
                    }
                }
            }
        }
    }",maybe_loop_control
p,"for (Stmt p = method.stmts.getFirst(); p != null; p = p.getNext()) {
            if (p.st == Stmt.ST.ASSIGN) {
                AssignStmt as = (AssignStmt) p;
                if (as.getOp1().vt == Value.VT.LOCAL && as.getOp2().vt == Value.VT.LOCAL) {
                    assignStmtList.add(as);
                }
            }
        }",maybe_loop_control
changed,"{
        boolean irChanged = false;
        List<AssignStmt> assignStmtList = new ArrayList<>();
        List<LabelStmt> phiLabels = method.phiLabels;
        for (Stmt p = method.stmts.getFirst(); p != null; p = p.getNext()) {
            if (p.st == Stmt.ST.ASSIGN) {
                AssignStmt as = (AssignStmt) p;
                if (as.getOp1().vt == Value.VT.LOCAL && as.getOp2().vt == Value.VT.LOCAL) {
                    assignStmtList.add(as);
                }
            }
        }
        final Map<Local, Local> toReplace = new HashMap<>();
        Set<Value> set = new HashSet<>();
        boolean changed = true;
        while (changed) {
            changed = false;

            if (removeLoopFromPhi(phiLabels, toReplace)) {
                fixReplace(toReplace);
                replacePhi(phiLabels, toReplace, set);
            }

            while (simplePhi(phiLabels, toReplace, set)) {// remove a = phi(b)
                fixReplace(toReplace);
                replacePhi(phiLabels, toReplace, set);
            }
            while (simpleAssign(phiLabels, assignStmtList, toReplace, method.stmts)) {// remove a=b
                fixReplace(toReplace);
                replaceAssign(assignStmtList, toReplace);
                changed = true;
                irChanged = true;
            }
            replacePhi(phiLabels, toReplace, set);
        }

        for (Local local : toReplace.keySet()) {
            method.locals.remove(local);
            irChanged = true;
        }
        if (toReplace.size() > 0) {
            Cfg.travelMod(method.stmts, new Cfg.TravelCallBack() {
                @Override
                public Value onAssign(Local v, AssignStmt as) {
                    return v;
                }

                @Override
                public Value onUse(Local v) {
                    Local n = toReplace.get(v);
                    return n == null ? v : n;
                }
            }, true);
        }
        return irChanged;
    }",maybe_loop_control
local,"for (Local local : toReplace.keySet()) {
            method.locals.remove(local);
            irChanged = true;
        }",iterator
var,"for (LocalVar var : vars) {
                uselabels.add(var.start);
                uselabels.add(var.end);
            }",iterator
p,"for (Stmt p = stmts.getFirst(); p != null;) {
            if (p.st == ST.LABEL) {
                if (!uselabels.contains(p)) {
                    Stmt q = p.getNext();
                    stmts.remove(p);
                    p = q;
                    continue;
                }
            }
            p = p.getNext();
        }",maybe_loop_control
p,"for (Stmt p = stmts.getFirst(); p != null; p = p.getNext()) {
            if (p instanceof JumpStmt) {
                labels.add(((JumpStmt) p).getTarget());
            } else if (p instanceof BaseSwitchStmt) {
                BaseSwitchStmt stmt = (BaseSwitchStmt) p;
                labels.add(stmt.defaultTarget);
                for (LabelStmt t : stmt.targets) {
                    labels.add(t);
                }
            }
        }",maybe_loop_control
t,"for (LabelStmt t : stmt.targets) {
                    labels.add(t);
                }",iterator
trap,"for (Trap trap : traps) {
                labels.add(trap.start);
                labels.add(trap.end);
                for (LabelStmt h : trap.handlers) {
                    labels.add(h);
                }
            }",iterator
h,"for (LabelStmt h : trap.handlers) {
                    labels.add(h);
                }",iterator
d1,"{
                                                int d1 = 0;
                                                while (elementType.charAt(d1) == '[') {
                                                    d1++;
                                                }
                                                changed[0] = true;
                                                return Exprs.nNewMutiArray(elementType.substring(d1), d1 + d, filledArrayExpr.getOps());
                                            }",loop_control
elementType,"{
                                Value arg0 = invokeExpr.getOps()[0];
                                String elementType = null;
                                if (arg0.vt == Value.VT.CONSTANT) {
                                    elementType = ((DexType) ((Constant) invokeExpr.getOps()[0]).value).desc;
                                } else {
                                    if (arg0.vt == Value.VT.STATIC_FIELD) {
                                        StaticFieldExpr sfe = (StaticFieldExpr) arg0;
                                        if (sfe.owner.startsWith(""Ljava/lang/"") && sfe.name.equals(""TYPE"")) {
                                            switch (sfe.owner) {
                                                case ""Ljava/lang/Boolean;"":
                                                    elementType = ""Z"";
                                                    break;
                                                case ""Ljava/lang/Byte;"":
                                                    elementType = ""B"";
                                                    break;
                                                case ""Ljava/lang/Short;"":
                                                    elementType = ""S"";
                                                    break;
                                                case ""Ljava/lang/Character;"":
                                                    elementType = ""C"";
                                                    break;
                                                case ""Ljava/lang/Integer;"":
                                                    elementType = ""I"";
                                                    break;
                                                case ""Ljava/lang/Long;"":
                                                    elementType = ""J"";
                                                    break;
                                                case ""Ljava/lang/Float;"":
                                                    elementType = ""F"";
                                                    break;
                                                case ""Ljava/lang/Double;"":
                                                    elementType = ""D"";
                                                    break;
                                                case ""Ljava/lang/Void;"":
                                                    elementType = ""V"";
                                                    break;
                                                default:
                                            }
                                        }
                                    }
                                }
                                if (elementType != null) {
                                    Value dt = invokeExpr.getOps()[1];
                                    if (invokeExpr.getArgs()[1].equals(""I"")) {
                                        if (te.type.equals(""["" + elementType)) {
                                            int d = 0;
                                            while (elementType.charAt(d) == '[') {
                                                d++;
                                            }
                                            changed[0] = true;
                                            if (d > 0) {
                                                return Exprs.nNewMutiArray(elementType.substring(d), d + 1, new Value[]{dt});
                                            } else {
                                                return Exprs.nNewArray(elementType, dt);
                                            }
                                        }
                                    } else {// [I
                                        if (dt.vt == Value.VT.FILLED_ARRAY) {
                                            FilledArrayExpr filledArrayExpr = (FilledArrayExpr) dt;
                                            int d = filledArrayExpr.getOps().length;
                                            if (te.type.length() > d && te.type.substring(d).equals(elementType)) {
                                                int d1 = 0;
                                                while (elementType.charAt(d1) == '[') {
                                                    d1++;
                                                }
                                                changed[0] = true;
                                                return Exprs.nNewMutiArray(elementType.substring(d1), d1 + d, filledArrayExpr.getOps());
                                            }
                                        }
                                    }
                                }
                            }",maybe_loop_control
p,"for (Stmt p = method.stmts.getFirst(); p != null; p = p.getNext()) {
            tmp.clear();
            convertStmt(p, n);
            for (Stmt t : tmp) {
                method.stmts.insertBefore(p, t);
            }

        }",maybe_loop_control
t,"for (Stmt t : tmp) {
                method.stmts.insertBefore(p, t);
            }",iterator
i,"for (int i = 0; i < ops.length; i++) {
                ops[i] = convertExpr(ops[i], false, tmp);
            }",loop_control
i,"for (int i = 0; i < ops.length; i++) {
                ops[i] = convertExpr(ops[i], true, tmp);
            }",loop_control
t,"for (T t : c) {
            if (add(t)) {
                result = true;
            }
        }",loop_control
it,"for (Iterator<Trap> it = method.traps.iterator(); it.hasNext();) {
                Trap t = it.next();
                boolean allNotThrow = true;
                for (Stmt p = t.start; p != t.end; p = p.getNext()) {
                    if (p.visited && Cfg.isThrow(p)) {
                        allNotThrow = false;
                        break;
                    }
                }
                if (allNotThrow) {
                    it.remove();
                    continue;
                }

                boolean allNotVisited = true;
                boolean allVisited = true;
                for (LabelStmt labelStmt : t.handlers) {
                    if (labelStmt.visited) {
                        allNotVisited = false;
                    } else {
                        allVisited = false;
                    }
                }
                if (allNotVisited) {
                    it.remove();
                } else {
                    // keep start and end
                    t.start.visited = true;
                    t.end.visited = true;
                    if (!allVisited) { // part visited
                        List<String> types = new ArrayList<>(t.handlers.length);
                        List<LabelStmt> labelStmts = new ArrayList<>(t.handlers.length);
                        for (int i = 0; i < t.handlers.length; i++) {
                            labelStmts.add(t.handlers[i]);
                            types.add(t.types[i]);
                        }
                        t.handlers = labelStmts.toArray(new LabelStmt[labelStmts.size()]);
                        t.types = types.toArray(new String[types.size()]);
                    }
                }
            }",iterator
it,"for (Iterator<Stmt> it = method.stmts.iterator(); it.hasNext();) {
            Stmt p = it.next();
            if (!p.visited) {
                it.remove();
                continue;
            }
            if (p.st == Stmt.ST.ASSIGN || p.st == Stmt.ST.IDENTITY) {
                if (p.getOp1().vt == Value.VT.LOCAL) {
                    definedLocals.add((Local) p.getOp1());
                }
            }
        }",iterator
it,"for (Iterator<LabelStmt> it = method.phiLabels.iterator(); it.hasNext();) {
                LabelStmt labelStmt = it.next();
                if (!labelStmt.visited) {
                    it.remove();
                    continue;
                }
                if (labelStmt.phis != null) {
                    for (AssignStmt phi : labelStmt.phis) {
                        definedLocals.add((Local) phi.getOp1());
                    }
                }
            }",iterator
it,"for (Iterator<LabelStmt> it = method.phiLabels.iterator(); it.hasNext();) {
                LabelStmt labelStmt = it.next();
                if (labelStmt.phis != null) {
                    for (AssignStmt phi : labelStmt.phis) {
                        PhiExpr phiExpr = (PhiExpr) phi.getOp2();
                        boolean needRebuild = false;
                        for (Value v : phiExpr.getOps()) {
                            if (!definedLocals.contains(v)) {
                                needRebuild = true;
                                break;
                            }
                        }
                        if (needRebuild) {
                            for (Value v : phiExpr.getOps()) {
                                if (definedLocals.contains(v)) {
                                    tmp.add(v);
                                }
                            }
                            phiExpr.setOps(tmp.toArray(new Value[tmp.size()]));
                            tmp.clear();
                        }
                    }
                }
            }",iterator
p,"for (Stmt p = t.start; p != t.end; p = p.getNext()) {
                    if (p.visited && Cfg.isThrow(p)) {
                        allNotThrow = false;
                        break;
                    }
                }",maybe_loop_control
p,"for (Iterator<Stmt> it = method.stmts.iterator(); it.hasNext();) {
            Stmt p = it.next();
            if (!p.visited) {
                it.remove();
                continue;
            }
            if (p.st == Stmt.ST.ASSIGN || p.st == Stmt.ST.IDENTITY) {
                if (p.getOp1().vt == Value.VT.LOCAL) {
                    definedLocals.add((Local) p.getOp1());
                }
            }
        }",maybe_loop_control
p,"for (Stmt p = t.start; p != t.end; p = p.getNext()) {
                    if (p.visited && Cfg.isThrow(p)) {
                        allNotThrow = false;
                        break;
                    }
                }",break_loop_control
p,"for (Iterator<Stmt> it = method.stmts.iterator(); it.hasNext();) {
            Stmt p = it.next();
            if (!p.visited) {
                it.remove();
                continue;
            }
            if (p.st == Stmt.ST.ASSIGN || p.st == Stmt.ST.IDENTITY) {
                if (p.getOp1().vt == Value.VT.LOCAL) {
                    definedLocals.add((Local) p.getOp1());
                }
            }
        }",break_loop_control
labelStmt,"for (LabelStmt labelStmt : t.handlers) {
                    if (labelStmt.visited) {
                        allNotVisited = false;
                    } else {
                        allVisited = false;
                    }
                }",iterator
labelStmt,"for (Iterator<LabelStmt> it = method.phiLabels.iterator(); it.hasNext();) {
                LabelStmt labelStmt = it.next();
                if (!labelStmt.visited) {
                    it.remove();
                    continue;
                }
                if (labelStmt.phis != null) {
                    for (AssignStmt phi : labelStmt.phis) {
                        definedLocals.add((Local) phi.getOp1());
                    }
                }
            }",iterator
labelStmt,"for (Iterator<LabelStmt> it = method.phiLabels.iterator(); it.hasNext();) {
                LabelStmt labelStmt = it.next();
                if (labelStmt.phis != null) {
                    for (AssignStmt phi : labelStmt.phis) {
                        PhiExpr phiExpr = (PhiExpr) phi.getOp2();
                        boolean needRebuild = false;
                        for (Value v : phiExpr.getOps()) {
                            if (!definedLocals.contains(v)) {
                                needRebuild = true;
                                break;
                            }
                        }
                        if (needRebuild) {
                            for (Value v : phiExpr.getOps()) {
                                if (definedLocals.contains(v)) {
                                    tmp.add(v);
                                }
                            }
                            phiExpr.setOps(tmp.toArray(new Value[tmp.size()]));
                            tmp.clear();
                        }
                    }
                }
            }",iterator
i,"for (int i = 0; i < t.handlers.length; i++) {
                            labelStmts.add(t.handlers[i]);
                            types.add(t.types[i]);
                        }",loop_control
it,"for (Iterator<Trap> it = method.traps.iterator(); it.hasNext();) {
                Trap t = it.next();
                boolean allNotThrow = true;
                for (Stmt p = t.start; p != t.end; p = p.getNext()) {
                    if (p.visited && Cfg.isThrow(p)) {
                        allNotThrow = false;
                        break;
                    }
                }
                if (allNotThrow) {
                    it.remove();
                    continue;
                }

                boolean allNotVisited = true;
                boolean allVisited = true;
                for (LabelStmt labelStmt : t.handlers) {
                    if (labelStmt.visited) {
                        allNotVisited = false;
                    } else {
                        allVisited = false;
                    }
                }
                if (allNotVisited) {
                    it.remove();
                } else {
                    // keep start and end
                    t.start.visited = true;
                    t.end.visited = true;
                    if (!allVisited) { // part visited
                        List<String> types = new ArrayList<>(t.handlers.length);
                        List<LabelStmt> labelStmts = new ArrayList<>(t.handlers.length);
                        for (int i = 0; i < t.handlers.length; i++) {
                            labelStmts.add(t.handlers[i]);
                            types.add(t.types[i]);
                        }
                        t.handlers = labelStmts.toArray(new LabelStmt[labelStmts.size()]);
                        t.types = types.toArray(new String[types.size()]);
                    }
                }
            }",iterator
it,"for (Iterator<Stmt> it = method.stmts.iterator(); it.hasNext();) {
            Stmt p = it.next();
            if (!p.visited) {
                it.remove();
                continue;
            }
            if (p.st == Stmt.ST.ASSIGN || p.st == Stmt.ST.IDENTITY) {
                if (p.getOp1().vt == Value.VT.LOCAL) {
                    definedLocals.add((Local) p.getOp1());
                }
            }
        }",iterator
it,"for (Iterator<LabelStmt> it = method.phiLabels.iterator(); it.hasNext();) {
                LabelStmt labelStmt = it.next();
                if (!labelStmt.visited) {
                    it.remove();
                    continue;
                }
                if (labelStmt.phis != null) {
                    for (AssignStmt phi : labelStmt.phis) {
                        definedLocals.add((Local) phi.getOp1());
                    }
                }
            }",iterator
it,"for (Iterator<LabelStmt> it = method.phiLabels.iterator(); it.hasNext();) {
                LabelStmt labelStmt = it.next();
                if (labelStmt.phis != null) {
                    for (AssignStmt phi : labelStmt.phis) {
                        PhiExpr phiExpr = (PhiExpr) phi.getOp2();
                        boolean needRebuild = false;
                        for (Value v : phiExpr.getOps()) {
                            if (!definedLocals.contains(v)) {
                                needRebuild = true;
                                break;
                            }
                        }
                        if (needRebuild) {
                            for (Value v : phiExpr.getOps()) {
                                if (definedLocals.contains(v)) {
                                    tmp.add(v);
                                }
                            }
                            phiExpr.setOps(tmp.toArray(new Value[tmp.size()]));
                            tmp.clear();
                        }
                    }
                }
            }",iterator
p,"for (Stmt p = method.stmts.getFirst(); p != null; p = p.getNext()) {
            if (p.st == Stmt.ST.ASSIGN && p.getOp1().vt == Value.VT.LOCAL) {
                Local left = (Local) p.getOp1();
                if (reads[left._ls_index] == 0) {
                    Value op2 = p.getOp2();
                    if (op2 instanceof AbstractInvokeExpr) {
                        method.locals.remove(left);
                        Stmt nVoidInvoke = Stmts.nVoidInvoke(op2);
                        method.stmts.replace(p, nVoidInvoke);
                        p = nVoidInvoke;
                        changed = true;
                    }
                }
            }
        }",maybe_loop_control
ref,"for (TypeRef ref : refs) {
            String type = ref.getType();

            if (type == null) {
                System.err.println(ref);
                continue;
            }

            if (ref.value.vt == VT.CONSTANT) {
                Constant cst = (Constant) ref.value;
                switch (type.charAt(0)) {
                    case '[':
                    case 'L':
                        if (Integer.valueOf(0).equals(cst.value)) {
                            cst.value = Constant.Null;
                        }
                        if (type.equals(""[F"") && cst.value instanceof int[]) {
                            int x[] = (int[]) cst.value;
                            float f[] = new float[x.length];
                            for (int i = 0; i < x.length; i++) {
                                f[i] = Float.intBitsToFloat(x[i]);
                            }
                            cst.value = f;
                        }
                        if (type.equals(""[D"") && cst.value instanceof long[]) {
                            long x[] = (long[]) cst.value;
                            double f[] = new double[x.length];
                            for (int i = 0; i < x.length; i++) {
                                f[i] = Double.longBitsToDouble(x[i]);
                            }
                            cst.value = f;
                        }
                        break;
                    case 'F':
                        if (!(cst.value instanceof Float)) {
                            cst.value = Float.intBitsToFloat(((Number) cst.value).intValue());
                        }
                        break;
                    case 'D':
                        if (!(cst.value instanceof Double)) {
                            cst.value = Double.longBitsToDouble(((Number) cst.value).longValue());
                        }
                        break;
                    default:
                }
            }
            Value value = ref.value;
            value.valueType = type;
            value.tag = null;
            ref.clear();
        }",iterator
x,"{
            TypeRef x = this;
            while (x.next != null) {
                x = x.next;
            }
            if (x != this) {
                this.next = x;
            }
            return x;
        }",maybe_loop_control
t,"for (String t : possibleIntTypes) {
                    if (thiz.uses.contains(t)) {
                        return t;
                    }
                }",iterator
ref,"for (TypeRef ref : refs) {
                ref = ref.getReal();
                if (ref.gArrayValues != null || ref.sArrayValues != null) {
                    arrayRoots.add(ref);
                }
                mergeArrayRelation(ref, Relation.R_gArrayValues);
                mergeArrayRelation(ref, Relation.R_sArrayValues);
                mergeArrayRelation(ref, Relation.R_arrayRoots);
            }",iterator
ref,"{
                    TypeRef ref = q.poll();
                    copyTypes(q, ref);
                }",iterator
ref,"for (TypeRef ref : arrayRoots) {
                    ref = ref.getReal();
                    String provideDesc = ref.provideDesc;
                    if (provideDesc != null && provideDesc.charAt(0) == '[') {
                        String ele = provideDesc.substring(1);

                        TypeClass clz = TypeClass.clzOf(ele);
                        if (ref.gArrayValues != null) {
                            for (TypeRef p : ref.gArrayValues) {
                                p = p.getReal();
                                if (p.updateTypeClass(clz)) {
                                    q.add(p);
                                }
                                mergeTypeToArrayGetValue(ele, p, q);
                            }
                        }
                        if (ref.sArrayValues != null) {
                            for (TypeRef p : ref.sArrayValues) {
                                p = p.getReal();
                                if (p.updateTypeClass(clz)) {
                                    q.add(p);
                                }
                                if (p.addUses(ele)) {
                                    q.add(p);
                                }
                            }
                        }
                    }
                }",iterator
q,"{
            // 1. collect all Array Roots
            Set<TypeRef> arrayRoots = new HashSet<>();
            for (TypeRef ref : refs) {
                ref = ref.getReal();
                if (ref.gArrayValues != null || ref.sArrayValues != null) {
                    arrayRoots.add(ref);
                }
                mergeArrayRelation(ref, Relation.R_gArrayValues);
                mergeArrayRelation(ref, Relation.R_sArrayValues);
                mergeArrayRelation(ref, Relation.R_arrayRoots);
            }

            UniqueQueue<TypeRef> q = new UniqueQueue<>();
            q.addAll(refs);
            while (!q.isEmpty()) {
                // 2. merge provided type to children. merge uses to parent. merge TypeClass to sameValues
                while (!q.isEmpty()) {
                    TypeRef ref = q.poll();
                    copyTypes(q, ref);
                }
                // 3. merge type from Array Roots to Array Values
                for (TypeRef ref : arrayRoots) {
                    ref = ref.getReal();
                    String provideDesc = ref.provideDesc;
                    if (provideDesc != null && provideDesc.charAt(0) == '[') {
                        String ele = provideDesc.substring(1);

                        TypeClass clz = TypeClass.clzOf(ele);
                        if (ref.gArrayValues != null) {
                            for (TypeRef p : ref.gArrayValues) {
                                p = p.getReal();
                                if (p.updateTypeClass(clz)) {
                                    q.add(p);
                                }
                                mergeTypeToArrayGetValue(ele, p, q);
                            }
                        }
                        if (ref.sArrayValues != null) {
                            for (TypeRef p : ref.sArrayValues) {
                                p = p.getReal();
                                if (p.updateTypeClass(clz)) {
                                    q.add(p);
                                }
                                if (p.addUses(ele)) {
                                    q.add(p);
                                }
                            }
                        }
                    }
                }
            }
        }",maybe_loop_control
ref,"for (TypeRef ref : refs) {
                ref = ref.getReal();
                if (ref.gArrayValues != null || ref.sArrayValues != null) {
                    arrayRoots.add(ref);
                }
                mergeArrayRelation(ref, Relation.R_gArrayValues);
                mergeArrayRelation(ref, Relation.R_sArrayValues);
                mergeArrayRelation(ref, Relation.R_arrayRoots);
            }",iterator
ref,"{
                    TypeRef ref = q.poll();
                    copyTypes(q, ref);
                }",iterator
ref,"for (TypeRef ref : arrayRoots) {
                    ref = ref.getReal();
                    String provideDesc = ref.provideDesc;
                    if (provideDesc != null && provideDesc.charAt(0) == '[') {
                        String ele = provideDesc.substring(1);

                        TypeClass clz = TypeClass.clzOf(ele);
                        if (ref.gArrayValues != null) {
                            for (TypeRef p : ref.gArrayValues) {
                                p = p.getReal();
                                if (p.updateTypeClass(clz)) {
                                    q.add(p);
                                }
                                mergeTypeToArrayGetValue(ele, p, q);
                            }
                        }
                        if (ref.sArrayValues != null) {
                            for (TypeRef p : ref.sArrayValues) {
                                p = p.getReal();
                                if (p.updateTypeClass(clz)) {
                                    q.add(p);
                                }
                                if (p.addUses(ele)) {
                                    q.add(p);
                                }
                            }
                        }
                    }
                }",iterator
p,"for (TypeRef p : ref.gArrayValues) {
                                p = p.getReal();
                                if (p.updateTypeClass(clz)) {
                                    q.add(p);
                                }
                                mergeTypeToArrayGetValue(ele, p, q);
                            }",iterator
p,"for (TypeRef p : ref.sArrayValues) {
                                p = p.getReal();
                                if (p.updateTypeClass(clz)) {
                                    q.add(p);
                                }
                                if (p.addUses(ele)) {
                                    q.add(p);
                                }
                            }",iterator
i,"for (int i = 1; i < copy.size(); i++) {
                    mergeTo.merge(copy.get(i));
                }",loop_control
i,"for (int i = possibleIntTypes.length - 1; i >= 0; i--) {
                            String t = possibleIntTypes[i];
                            if (a.equals(t) || b.equals(t)) {
                                chooseType = t;
                                break;
                            }
                        }",loop_control
p,"for (TypeRef p : ref.parents) {
                    p = p.getReal();
                    if (p.updateTypeClass(clz)) {
                        q.add(p);
                    }
                    if (ref.uses != null) {
                        if (p.addAllUses(ref.uses)) {
                            q.add(p);
                        }
                    }
                }",iterator
p,"for (TypeRef p : ref.children) {
                    p = p.getReal();
                    if (p.updateTypeClass(clz)) {
                        q.add(p);
                    }

                    if (provideDesc != null) {
                        mergeTypeToSubRef(provideDesc, p, q);
                    }
                }",iterator
p,"for (TypeRef p : ref.sameValues) {
                    p = p.getReal();
                    if (p.updateTypeClass(clz)) {
                        q.add(p);
                    }
                }",iterator
p,"for (TypeRef p : ref.parents) {
                if (p.getProvideDesc() == null) {
                    allAreSet = false;
                    break;
                }
            }",iterator
i,"for (int i = possibleIntTypes.length - 1; i >= 0; i--) {
                        String t = possibleIntTypes[i];
                        if (a.equals(t) || b.equals(t)) {
                            return t;
                        }
                    }",loop_control
i,"for (int i = 0; i < dim; i++) {
                sb.append('[');
            }",loop_control
i,"{
            int i = 0;
            while (a.charAt(i) == '[') {
                i++;
            }
            return i;
        }",loop_control
it,"{
            Iterator<TypeRef> it = parents.iterator();
            String a = it.next().getProvideDesc();
            while (it.hasNext()) {
                a = mergeProviderType(a, it.next().getProvideDesc());
            }
            return a;
        }",iterator
i,"for (int i = 0; i < vbs.length; i++) {
                            useAs(vbs[i], argTypes[i]);
                        }",loop_control
i,"for (int i = 1; i < vbs.length; i++) {
                            useAs(vbs[i], argTypes[i - 1]);
                        }",loop_control
i,"for (int i = 0; i < nmae.dimension; i++) {
                        sb.append('[');
                    }",loop_control
vb,"for (Value vb : vbs) {
                        useAs(vb, fae.type);
                    }",iterator
vb,"for (Value vb : vbs) {
                        useAs(vb, ""I"");
                    }",iterator
vb,"for (Value vb : vbs) {
                        linkFromTo(vb, enExpr);
                    }",iterator
vb,"for (Value vb : enExpr.ops) {
                exExpr(vb);
            }",iterator
p,"for (Stmt p = method.stmts.getFirst(); p != null; p = p.getNext()) {
                switch (p.et) {
                    case E0:
                        // label, nop and return-void
                        if (p.st == ST.LABEL) {
                            LabelStmt labelStmt = (LabelStmt) p;
                            if (labelStmt.phis != null) {
                                for (AssignStmt phi : labelStmt.phis) {
                                    s2stmt(phi);
                                }
                            }
                        }
                        break;
                    case E1:
                        s1stmt((E1Stmt) p);
                        break;
                    case E2:
                        s2stmt((E2Stmt) p);
                        break;
                    case En:
                        // no stmt yet
                        // enstmt((EnStmt) p, refs, relationRefs);
                        break;
                }
            }",maybe_loop_control
ref,"for (TypeRef ref : refs) {
                sb.append(ref).append(""\n"");
            }",iterator
q,"{
        boolean changed = false;


        Set<Stmt> locationSensitiveStmts = new HashSet<>();
        // 1. merge location Insensitive stmts
        changed = simpleMergeLocals(method, changed, locationSensitiveStmts);

        if (locationSensitiveStmts.size() == 0) {
            return changed;
        }

        ReplaceX replaceX = new ReplaceX();
        Queue<Stmt> q = new UniqueQueue<>();
        q.addAll(locationSensitiveStmts);

        // 2. merge location sensitive stmts
        while (!q.isEmpty()) {
            Stmt stmt = q.poll();
            Local local = (Local) stmt.getOp1();
            Stmt next = stmt.getNext();

            switch (next.st) {
                case LABEL:
                case GOTO:
                case IDENTITY:
                case FILL_ARRAY_DATA:
                case NOP:
                case RETURN_VOID:
                    continue;
                default:
            }
            try {
                localCanExecFirst(local, next);
                throw new RuntimeException(); // impossible here
            } catch (MergeResult e) {
                if (e == SUCCESS) {
                    replaceX.local = local;
                    replaceX.replaceWith = stmt.getOp2();
                    method.locals.remove(local);
                    method.stmts.remove(stmt);

                    Cfg.travelMod(next, replaceX, false);

                    Stmt pre = next.getPre();
                    if (pre != null && locationSensitiveStmts.contains(pre)) {
                        q.add(pre);
                    }

                }
            }
        }


        return changed;
    }",maybe_loop_control
v,"for (Value v : op.getOps()) {
                    localCanExecFirst(local, v);
                }",iterator
it,"for (Iterator<Stmt> it = method.stmts.iterator(); it.hasNext(); ) {
            Stmt p = it.next();
            if (p.st == Stmt.ST.ASSIGN && p.getOp1().vt == Value.VT.LOCAL) {
                Local local = (Local) p.getOp1();
                if (useInPhi.contains(local)) {
                    continue;
                }
                if (readCounts[local._ls_index] < 2) {
                    Value op2 = p.getOp2();
                    if (isLocationInsensitive(op2)) {
                        method.locals.remove(local);
                        toReplace.put(local, op2);
                        it.remove();
                        changed = true;
                    } else {
                        locationSensitiveStmts.add(p);
                    }
                }
            }
        }",iterator
labelStmt,"for (LabelStmt labelStmt : method.phiLabels) {
                if (labelStmt.phis != null) {
                    for (AssignStmt phi : labelStmt.phis) {
                        useInPhi.add((Local) phi.getOp1());
                        for (Value op : phi.getOp2().getOps()) {
                            useInPhi.add((Local) op);
                        }
                    }
                }
            }",iterator
phi,"for (AssignStmt phi : labelStmt.phis) {
                        useInPhi.add((Local) phi.getOp1());
                        for (Value op : phi.getOp2().getOps()) {
                            useInPhi.add((Local) op);
                        }
                    }",iterator
op,"for (Value op : phi.getOp2().getOps()) {
                            useInPhi.add((Local) op);
                        }",iterator
e,"for (Map.Entry<Local, Value> e : toReplace.entrySet()) {
            Value v = e.getValue();
            if (v.vt == Value.VT.LOCAL) {
                while (true) {
                    Value v2 = toReplace.get(v);
                    if (v2 == null) {
                        break;
                    }
                    v = v2;
                    if (v.vt != Value.VT.LOCAL) {
                        break;
                    }
                }
                e.setValue(v);
            } else {
                Cfg.travelMod(v, tcb);
            }
        }",iterator
v2,"{
                    Value v2 = toReplace.get(v);
                    if (v2 == null) {
                        break;
                    }
                    v = v2;
                    if (v.vt != Value.VT.LOCAL) {
                        break;
                    }
                }",break_loop_control
v,"for (Map.Entry<Local, Value> e : toReplace.entrySet()) {
            Value v = e.getValue();
            if (v.vt == Value.VT.LOCAL) {
                while (true) {
                    Value v2 = toReplace.get(v);
                    if (v2 == null) {
                        break;
                    }
                    v = v2;
                    if (v.vt != Value.VT.LOCAL) {
                        break;
                    }
                }
                e.setValue(v);
            } else {
                Cfg.travelMod(v, tcb);
            }
        }",break_loop_control
v,"for (Value v : op.getOps()) {
                            if (!isLocationInsensitive(v)) {
                                return false;
                            }
                        }",iterator
v,"for (Value v : op.getOps()) {
                        if (!isLocationInsensitive(v)) {
                            return false;
                        }
                    }",iterator
stmt,"for (Stmt stmt : method.stmts) {
            if (stmt.st == ST.ASSIGN || stmt.st == ST.IDENTITY) {
                if (stmt.getOp1().vt == VT.LOCAL) {
                    Local left = (Local) stmt.getOp1();
                    Value op2 = stmt.getOp2();
                    int idx = left._ls_index;
                    Reg leftReg = regs[idx];

                    // a new local can't effect next value live in next frame
                    Cfg.collectTos(stmt, tos);
                    for (Stmt next : tos) {
                        SimpleLiveValue[] frame = (SimpleLiveValue[]) next.frame;
                        if (frame == null) {
                            continue;
                        }
                        for (int i = 0; i < frame.length; i++) {
                            if (i == idx) {
                                continue;
                            }
                            SimpleLiveValue v = frame[i];
                            if (v != null && v.used) {
                                Reg rightReg = regs[i];
                                leftReg.excludes.add(rightReg);
                                rightReg.excludes.add(leftReg);
                            }
                        }
                    }
                    tos.clear();

                    // Preferred same reg can save load-store
                    if (op2.vt == VT.LOCAL) {
                        Reg rightReg = regs[((Local) op2)._ls_index];
                        leftReg.prefers.add(rightReg);
                        rightReg.prefers.add(leftReg);
                    }

                    // record @this @parameter_x
                    if (op2.vt == VT.THIS_REF) {
                        args[0] = leftReg;
                    } else if (op2.vt == VT.PARAMETER_REF) {
                        RefExpr refExpr = (RefExpr) op2;
                        if (method.isStatic) {
                            args[refExpr.parameterIndex] = leftReg;
                        } else {
                            args[refExpr.parameterIndex + 1] = leftReg;
                        }
                    }
                }
            }
        }",iterator
next,"for (Stmt next : tos) {
                        SimpleLiveValue[] frame = (SimpleLiveValue[]) next.frame;
                        if (frame == null) {
                            continue;
                        }
                        for (int i = 0; i < frame.length; i++) {
                            if (i == idx) {
                                continue;
                            }
                            SimpleLiveValue v = frame[i];
                            if (v != null && v.used) {
                                Reg rightReg = regs[i];
                                leftReg.excludes.add(rightReg);
                                rightReg.excludes.add(leftReg);
                            }
                        }
                    }",iterator
i,"for (int i = 0; i < frame.length; i++) {
                            if (i == idx) {
                                continue;
                            }
                            SimpleLiveValue v = frame[i];
                            if (v != null && v.used) {
                                Reg rightReg = regs[i];
                                leftReg.excludes.add(rightReg);
                                rightReg.excludes.add(leftReg);
                            }
                        }",loop_control
reg,"for (Reg reg : regs) {
            reg.excludes.remove(reg);
            reg.prefers.remove(reg);
        }",iterator
reg,"for (Reg reg : regs) {
            char simpleType = reg.type;
            List<Reg> group = groups.get(simpleType);
            if (group == null) {
                group = new ArrayList<>();
                groups.put(simpleType, group);
            }
            group.add(reg);

            for (Iterator<Reg> it = reg.excludes.iterator(); it.hasNext(); ) {
                Reg ex = it.next();
                if (ex.type != reg.type) {
                    it.remove();
                }
            }
            for (Iterator<Reg> it = reg.prefers.iterator(); it.hasNext(); ) {
                Reg ex = it.next();
                if (ex.type != reg.type) {
                    it.remove();
                }
            }
        }",iterator
it,"for (Iterator<Reg> it = reg.excludes.iterator(); it.hasNext(); ) {
                Reg ex = it.next();
                if (ex.type != reg.type) {
                    it.remove();
                }
            }",iterator
it,"for (Iterator<Reg> it = reg.prefers.iterator(); it.hasNext(); ) {
                Reg ex = it.next();
                if (ex.type != reg.type) {
                    it.remove();
                }
            }",iterator
ex,"for (Reg ex : as.excludes) {
            if (ex.reg >= 0) {
                excludeColor.set(ex.reg);
                if (ex.type == 'J' || ex.type == 'D') {
                    excludeColor.set(ex.reg + 1);
                }
            }
        }",iterator
ex,"for (Reg ex : as.prefers) {
            if (ex.reg >= 0) {
                suggestColor.set(ex.reg);
            }
        }",iterator
local,"for (Local local : method.locals) {
            Reg reg = new Reg();
            char type = local.valueType.charAt(0);
            if (type == '[') {
                type = 'L';
            }
            reg.type = type;
            local.tag = reg;
            regs[local._ls_index] = reg;
        }",iterator
local,"for (Local local : method.locals) {
            Reg as = (Reg) local.tag;
            local._ls_index = as.reg;
            local.tag = null;
        }",iterator
reg,"for (Local local : method.locals) {
            Reg reg = new Reg();
            char type = local.valueType.charAt(0);
            if (type == '[') {
                type = 'L';
            }
            reg.type = type;
            local.tag = reg;
            regs[local._ls_index] = reg;
        }",iterator
reg,"for (Reg reg : regs) {
                if (reg == atThis) {
                    continue;
                }
                reg.excludes.add(atThis);
                atThis.excludes.add(reg);
            }",iterator
reg,"{
                args[i++].reg = index++;
            }",iterator
reg,"for (int j = 0; j < method.args.length; j++) {
                Reg reg = args[i++];
                String type = method.args[j];
                if (reg == null) {
                    index++;
                } else {
                    reg.reg = index++;
                }
                if (""J"".equals(type) || ""D"".equals(type)) {
                    index++;
                }
            }",iterator
reg,"for (Reg as : assigns) {
                if (as.reg < 0) {// need color

                    initExcludeColor(excludeColor, as);
                    excludeParameters(excludeColor, args, type);

                    excludeColor.or(globalExcludes); // exclude index used by other types

                    initSuggestColor(suggestColor, as);

                    // first find a preferred color
                    for (int i = suggestColor.nextSetBit(0); i >= 0; i = suggestColor.nextSetBit(i + 1)) {
                        if (doubleOrLong) { // need 2
                            if (!excludeColor.get(i) && !excludeColor.get(i + 1)) {
                                as.reg = i;
                                break;
                            }
                        } else {
                            if (!excludeColor.get(i)) {
                                as.reg = i;
                                break;
                            }
                        }
                    }
                    if (as.reg < 0) {
                        if (doubleOrLong) {
                            int reg = -1;
                            do {
                                reg++;
                                reg = excludeColor.nextClearBit(reg);
                            } while (excludeColor.get(reg + 1));
                            as.reg = reg;
                        } else {
                            int reg = excludeColor.nextClearBit(0);
                            as.reg = reg;
                        }
                    }
                }
                usedInOneType.set(as.reg);
                if (doubleOrLong) {
                    usedInOneType.set(as.reg + 1);
                }
            }",iterator
reg,"for (Local local : method.locals) {
            Reg as = (Reg) local.tag;
            local._ls_index = as.reg;
            local.tag = null;
        }",iterator
j,"for (int j = 0; j < method.args.length; j++) {
                Reg reg = args[i++];
                String type = method.args[j];
                if (reg == null) {
                    index++;
                } else {
                    reg.reg = index++;
                }
                if (""J"".equals(type) || ""D"".equals(type)) {
                    index++;
                }
            }",loop_control
e,"for (Map.Entry<Character, List<Reg>> e : groups.entrySet()) {
            List<Reg> assigns = e.getValue();
            Collections.sort(assigns, OrderRegAssignByPreferredSizeDesc);
            char type = e.getKey();
            boolean doubleOrLong = type == 'J' || type == 'D';
            for (Reg as : assigns) {
                if (as.reg < 0) {// need color

                    initExcludeColor(excludeColor, as);
                    excludeParameters(excludeColor, args, type);

                    excludeColor.or(globalExcludes); // exclude index used by other types

                    initSuggestColor(suggestColor, as);

                    // first find a preferred color
                    for (int i = suggestColor.nextSetBit(0); i >= 0; i = suggestColor.nextSetBit(i + 1)) {
                        if (doubleOrLong) { // need 2
                            if (!excludeColor.get(i) && !excludeColor.get(i + 1)) {
                                as.reg = i;
                                break;
                            }
                        } else {
                            if (!excludeColor.get(i)) {
                                as.reg = i;
                                break;
                            }
                        }
                    }
                    if (as.reg < 0) {
                        if (doubleOrLong) {
                            int reg = -1;
                            do {
                                reg++;
                                reg = excludeColor.nextClearBit(reg);
                            } while (excludeColor.get(reg + 1));
                            as.reg = reg;
                        } else {
                            int reg = excludeColor.nextClearBit(0);
                            as.reg = reg;
                        }
                    }
                }
                usedInOneType.set(as.reg);
                if (doubleOrLong) {
                    usedInOneType.set(as.reg + 1);
                }
            }
            globalExcludes.or(usedInOneType);
            usedInOneType.clear();
        }",iterator
as,"for (Reg as : assigns) {
                if (as.reg < 0) {// need color

                    initExcludeColor(excludeColor, as);
                    excludeParameters(excludeColor, args, type);

                    excludeColor.or(globalExcludes); // exclude index used by other types

                    initSuggestColor(suggestColor, as);

                    // first find a preferred color
                    for (int i = suggestColor.nextSetBit(0); i >= 0; i = suggestColor.nextSetBit(i + 1)) {
                        if (doubleOrLong) { // need 2
                            if (!excludeColor.get(i) && !excludeColor.get(i + 1)) {
                                as.reg = i;
                                break;
                            }
                        } else {
                            if (!excludeColor.get(i)) {
                                as.reg = i;
                                break;
                            }
                        }
                    }
                    if (as.reg < 0) {
                        if (doubleOrLong) {
                            int reg = -1;
                            do {
                                reg++;
                                reg = excludeColor.nextClearBit(reg);
                            } while (excludeColor.get(reg + 1));
                            as.reg = reg;
                        } else {
                            int reg = excludeColor.nextClearBit(0);
                            as.reg = reg;
                        }
                    }
                }
                usedInOneType.set(as.reg);
                if (doubleOrLong) {
                    usedInOneType.set(as.reg + 1);
                }
            }",iterator
as,"for (Local local : method.locals) {
            Reg as = (Reg) local.tag;
            local._ls_index = as.reg;
            local.tag = null;
        }",iterator
i,"{ // assgin @this, @parameter_x from index 0
            int i = 0;
            int index = 0;
            if (!method.isStatic) {
                args[i++].reg = index++;
            }
            for (int j = 0; j < method.args.length; j++) {
                Reg reg = args[i++];
                String type = method.args[j];
                if (reg == null) {
                    index++;
                } else {
                    reg.reg = index++;
                }
                if (""J"".equals(type) || ""D"".equals(type)) {
                    index++;
                }
            }
        }",loop_control
i,"for (int i = suggestColor.nextSetBit(0); i >= 0; i = suggestColor.nextSetBit(i + 1)) {
                        if (doubleOrLong) { // need 2
                            if (!excludeColor.get(i) && !excludeColor.get(i + 1)) {
                                as.reg = i;
                                break;
                            }
                        } else {
                            if (!excludeColor.get(i)) {
                                as.reg = i;
                                break;
                            }
                        }
                    }",loop_control
doubleOrLong,"for (Map.Entry<Character, List<Reg>> e : groups.entrySet()) {
            List<Reg> assigns = e.getValue();
            Collections.sort(assigns, OrderRegAssignByPreferredSizeDesc);
            char type = e.getKey();
            boolean doubleOrLong = type == 'J' || type == 'D';
            for (Reg as : assigns) {
                if (as.reg < 0) {// need color

                    initExcludeColor(excludeColor, as);
                    excludeParameters(excludeColor, args, type);

                    excludeColor.or(globalExcludes); // exclude index used by other types

                    initSuggestColor(suggestColor, as);

                    // first find a preferred color
                    for (int i = suggestColor.nextSetBit(0); i >= 0; i = suggestColor.nextSetBit(i + 1)) {
                        if (doubleOrLong) { // need 2
                            if (!excludeColor.get(i) && !excludeColor.get(i + 1)) {
                                as.reg = i;
                                break;
                            }
                        } else {
                            if (!excludeColor.get(i)) {
                                as.reg = i;
                                break;
                            }
                        }
                    }
                    if (as.reg < 0) {
                        if (doubleOrLong) {
                            int reg = -1;
                            do {
                                reg++;
                                reg = excludeColor.nextClearBit(reg);
                            } while (excludeColor.get(reg + 1));
                            as.reg = reg;
                        } else {
                            int reg = excludeColor.nextClearBit(0);
                            as.reg = reg;
                        }
                    }
                }
                usedInOneType.set(as.reg);
                if (doubleOrLong) {
                    usedInOneType.set(as.reg + 1);
                }
            }
            globalExcludes.or(usedInOneType);
            usedInOneType.clear();
        }",break_loop_control
excludeColor,"{
        if (method.locals.size() == 0) {
            return;
        }
        SimpleLiveAnalyze sa = new SimpleLiveAnalyze(method, true);
        sa.analyze();

        // init regs
        int maxLocalSize = sa.getLocalSize();
        final Reg regs[] = new Reg[maxLocalSize];
        for (Local local : method.locals) {
            Reg reg = new Reg();
            char type = local.valueType.charAt(0);
            if (type == '[') {
                type = 'L';
            }
            reg.type = type;
            local.tag = reg;
            regs[local._ls_index] = reg;
        }

        // gen graph
        Reg[] args = genGraph(method, regs);

        // fix up the graph, make sure @this is not share index with others
        if (!method.isStatic) {
            Reg atThis = args[0];
            for (Reg reg : regs) {
                if (reg == atThis) {
                    continue;
                }
                reg.excludes.add(atThis);
                atThis.excludes.add(reg);
            }
        }

        { // assgin @this, @parameter_x from index 0
            int i = 0;
            int index = 0;
            if (!method.isStatic) {
                args[i++].reg = index++;
            }
            for (int j = 0; j < method.args.length; j++) {
                Reg reg = args[i++];
                String type = method.args[j];
                if (reg == null) {
                    index++;
                } else {
                    reg.reg = index++;
                }
                if (""J"".equals(type) || ""D"".equals(type)) {
                    index++;
                }
            }
        }

        Map<Character, List<Reg>> groups = groupAndCleanUpByType(regs);
        // type each group
        BitSet excludeColor = new BitSet();
        BitSet suggestColor = new BitSet();
        BitSet globalExcludes = new BitSet();
        BitSet usedInOneType = new BitSet();
        for (Map.Entry<Character, List<Reg>> e : groups.entrySet()) {
            List<Reg> assigns = e.getValue();
            Collections.sort(assigns, OrderRegAssignByPreferredSizeDesc);
            char type = e.getKey();
            boolean doubleOrLong = type == 'J' || type == 'D';
            for (Reg as : assigns) {
                if (as.reg < 0) {// need color

                    initExcludeColor(excludeColor, as);
                    excludeParameters(excludeColor, args, type);

                    excludeColor.or(globalExcludes); // exclude index used by other types

                    initSuggestColor(suggestColor, as);

                    // first find a preferred color
                    for (int i = suggestColor.nextSetBit(0); i >= 0; i = suggestColor.nextSetBit(i + 1)) {
                        if (doubleOrLong) { // need 2
                            if (!excludeColor.get(i) && !excludeColor.get(i + 1)) {
                                as.reg = i;
                                break;
                            }
                        } else {
                            if (!excludeColor.get(i)) {
                                as.reg = i;
                                break;
                            }
                        }
                    }
                    if (as.reg < 0) {
                        if (doubleOrLong) {
                            int reg = -1;
                            do {
                                reg++;
                                reg = excludeColor.nextClearBit(reg);
                            } while (excludeColor.get(reg + 1));
                            as.reg = reg;
                        } else {
                            int reg = excludeColor.nextClearBit(0);
                            as.reg = reg;
                        }
                    }
                }
                usedInOneType.set(as.reg);
                if (doubleOrLong) {
                    usedInOneType.set(as.reg + 1);
                }
            }
            globalExcludes.or(usedInOneType);
            usedInOneType.clear();
        }

        for (Local local : method.locals) {
            Reg as = (Reg) local.tag;
            local._ls_index = as.reg;
            local.tag = null;
        }
        for (Stmt stmt : method.stmts) {
            stmt.frame = null;
        }
    }",maybe_loop_control
arg,"for (Reg arg : args) {
            if (arg.type != type) {
                excludeColor.set(arg.reg);
                if (arg.type == 'J' || arg.type == 'D') {
                    excludeColor.set(arg.reg + 1);
                }
            }
        }",iterator
stmt,"for (Stmt stmt : irMethod.stmts) {
            if (stmt.st == ST.LABEL) {
                ((LabelStmt) stmt).displayName = ""L"" + i++;
            }
        }",iterator
st,"for (Stmt st : jm.stmts) {
            st.frame = null;
            st.exceptionHandlers = null;
            if (st._cfg_froms == null) {
                st._cfg_froms = new TreeSet<>(jm.stmts);
            } else {
                st._cfg_froms.clear();
            }
        }",iterator
st,"for (Stmt st : jm.stmts) {
            if (st.st.canBranch()) {
                link(st, ((JumpStmt) st).getTarget());
            }
            if (st.st.canContinue()) {
                link(st, st.getNext());
            }
            if (st.st.canSwitch()) {
                BaseSwitchStmt bss = (BaseSwitchStmt) st;
                link(st, bss.defaultTarget);
                for (Stmt target : bss.targets) {
                    link(st, target);
                }
            }
        }",iterator
t,"for (Trap t : jm.traps) {
            for (Stmt s = t.start; s != t.end; s = s.getNext()) {
                if (isThrow(s)) {
                    Set<LabelStmt> hs = s.exceptionHandlers;
                    if (hs == null) {
                        hs = new TreeSet<>(jm.stmts);
                        s.exceptionHandlers = hs;
                    }
                    for (LabelStmt handler : t.handlers) {
                        link(s, handler);
                        hs.add(handler);
                    }
                }
            }
        }",iterator
s,"for (Stmt s = t.start; s != t.end; s = s.getNext()) {
                if (isThrow(s)) {
                    Set<LabelStmt> hs = s.exceptionHandlers;
                    if (hs == null) {
                        hs = new TreeSet<>(jm.stmts);
                        s.exceptionHandlers = hs;
                    }
                    for (LabelStmt handler : t.handlers) {
                        link(s, handler);
                        hs.add(handler);
                    }
                }
            }",maybe_loop_control
st,"for (Stmt st : method.stmts) {
            st.visited = false;
        }",iterator
st,"{
            Stmt currentStmt = stack.pop();
            if (currentStmt.visited) {
                continue;
            } else {
                currentStmt.visited = true;
            }
            if (currentStmt.exceptionHandlers != null) {
                for (LabelStmt labelStmt : currentStmt.exceptionHandlers) {
                    stack.push(labelStmt);
                }
            }
            if (visitor != null) {
                visitor.onVisit(currentStmt);
            }
            if (currentStmt.st.canSwitch()) {
                BaseSwitchStmt bs = (BaseSwitchStmt) currentStmt;
                Collections.addAll(stack, bs.targets);
                LabelStmt target = bs.defaultTarget;
                stack.add(target);
            }
            if (currentStmt.st.canBranch()) {
                Stmt target = ((JumpStmt) currentStmt).getTarget();
                stack.add(target);
            }
            if (currentStmt.st.canContinue()) {
                Stmt target = currentStmt.getNext();
                stack.add(target);
            }
        }",iterator
stack,"{
        for (Stmt st : method.stmts) {
            st.visited = false;
        }
        Stack<Stmt> stack = new Stack<>();
        stack.add(method.stmts.getFirst());
        while (!stack.isEmpty()) {
            Stmt currentStmt = stack.pop();
            if (currentStmt.visited) {
                continue;
            } else {
                currentStmt.visited = true;
            }
            if (currentStmt.exceptionHandlers != null) {
                for (LabelStmt labelStmt : currentStmt.exceptionHandlers) {
                    stack.push(labelStmt);
                }
            }
            if (visitor != null) {
                visitor.onVisit(currentStmt);
            }
            if (currentStmt.st.canSwitch()) {
                BaseSwitchStmt bs = (BaseSwitchStmt) currentStmt;
                Collections.addAll(stack, bs.targets);
                LabelStmt target = bs.defaultTarget;
                stack.add(target);
            }
            if (currentStmt.st.canBranch()) {
                Stmt target = ((JumpStmt) currentStmt).getTarget();
                stack.add(target);
            }
            if (currentStmt.st.canContinue()) {
                Stmt target = currentStmt.getNext();
                stack.add(target);
            }
        }
    }",maybe_loop_control
st,"for (Stmt st : stmts) {
            st.visited = false;
            st.frame = null;
        }",iterator
st,"{
        if (stmts.getSize() == 0) {
            return;
        }
        // clean
        for (Stmt st : stmts) {
            st.visited = false;
            st.frame = null;
        }

        Stack<Stmt> stack = new Stack<Stmt>();
        Stmt first = stmts.getFirst();
        Stmt nop = null;
        if (first.st == ST.LABEL && first._cfg_froms.size() > 0) {
            nop = Stmts.nNop();
            // for
            // L0:
            // ...
            // GOTO L0:
            // make sure the first Label has one more super
            first._cfg_froms.add(nop);
        }
        stack.add(first);
        first.frame = sv.initFirstFrame(first);

        while (!stack.isEmpty()) {
            Stmt currentStmt = stack.pop();
            if (currentStmt == null || currentStmt.visited) {
                continue;
            } else {
                currentStmt.visited = true;
            }

            T beforeExecFrame = (T) currentStmt.frame;
            
            if (currentStmt.exceptionHandlers != null) {
                for (LabelStmt labelStmt : currentStmt.exceptionHandlers) {
                    labelStmt.frame = sv.merge(beforeExecFrame, (T) labelStmt.frame, currentStmt, labelStmt);
                    stack.push(labelStmt);
                }
            }
            
            T afterExecFrame = sv.exec(beforeExecFrame, currentStmt);

            if (currentStmt.st.canSwitch()) {
                BaseSwitchStmt bs = (BaseSwitchStmt) currentStmt;
                for (LabelStmt target : bs.targets) {
                    target.frame = sv.merge(afterExecFrame, (T) target.frame, currentStmt, target);
                    stack.push(target);
                }
                LabelStmt target = bs.defaultTarget;
                target.frame = sv.merge(afterExecFrame, (T) target.frame, currentStmt, target);
                stack.push(target);
            }
            if (currentStmt.st.canBranch()) {
                Stmt target = ((JumpStmt) currentStmt).getTarget();
                target.frame = sv.merge(afterExecFrame, (T) target.frame, currentStmt, target);
                stack.push(target);
            }
            if (currentStmt.st.canContinue()) {
                Stmt target = currentStmt.getNext();
                target.frame = sv.merge(afterExecFrame, (T) target.frame, currentStmt, target);
                stack.push(target);
            }
        }

        if (nop != null) {
            first._cfg_froms.remove(nop);
        }      
    }",iterator
stack,"{
        if (stmts.getSize() == 0) {
            return;
        }
        // clean
        for (Stmt st : stmts) {
            st.visited = false;
            st.frame = null;
        }

        Stack<Stmt> stack = new Stack<Stmt>();
        Stmt first = stmts.getFirst();
        Stmt nop = null;
        if (first.st == ST.LABEL && first._cfg_froms.size() > 0) {
            nop = Stmts.nNop();
            // for
            // L0:
            // ...
            // GOTO L0:
            // make sure the first Label has one more super
            first._cfg_froms.add(nop);
        }
        stack.add(first);
        first.frame = sv.initFirstFrame(first);

        while (!stack.isEmpty()) {
            Stmt currentStmt = stack.pop();
            if (currentStmt == null || currentStmt.visited) {
                continue;
            } else {
                currentStmt.visited = true;
            }

            T beforeExecFrame = (T) currentStmt.frame;
            
            if (currentStmt.exceptionHandlers != null) {
                for (LabelStmt labelStmt : currentStmt.exceptionHandlers) {
                    labelStmt.frame = sv.merge(beforeExecFrame, (T) labelStmt.frame, currentStmt, labelStmt);
                    stack.push(labelStmt);
                }
            }
            
            T afterExecFrame = sv.exec(beforeExecFrame, currentStmt);

            if (currentStmt.st.canSwitch()) {
                BaseSwitchStmt bs = (BaseSwitchStmt) currentStmt;
                for (LabelStmt target : bs.targets) {
                    target.frame = sv.merge(afterExecFrame, (T) target.frame, currentStmt, target);
                    stack.push(target);
                }
                LabelStmt target = bs.defaultTarget;
                target.frame = sv.merge(afterExecFrame, (T) target.frame, currentStmt, target);
                stack.push(target);
            }
            if (currentStmt.st.canBranch()) {
                Stmt target = ((JumpStmt) currentStmt).getTarget();
                target.frame = sv.merge(afterExecFrame, (T) target.frame, currentStmt, target);
                stack.push(target);
            }
            if (currentStmt.st.canContinue()) {
                Stmt target = currentStmt.getNext();
                target.frame = sv.merge(afterExecFrame, (T) target.frame, currentStmt, target);
                stack.push(target);
            }
        }

        if (nop != null) {
            first._cfg_froms.remove(nop);
        }      
    }",maybe_loop_control
labelStmt,"for (LabelStmt labelStmt : currentStmt.exceptionHandlers) {
                    labelStmt.frame = sv.merge(beforeExecFrame, (T) labelStmt.frame, currentStmt, labelStmt);
                    stack.push(labelStmt);
                }",iterator
target,"for (LabelStmt target : bs.targets) {
                    target.frame = sv.merge(afterExecFrame, (T) target.frame, currentStmt, target);
                    stack.push(target);
                }",iterator
target,"{
                BaseSwitchStmt bs = (BaseSwitchStmt) currentStmt;
                for (LabelStmt target : bs.targets) {
                    target.frame = sv.merge(afterExecFrame, (T) target.frame, currentStmt, target);
                    stack.push(target);
                }
                LabelStmt target = bs.defaultTarget;
                target.frame = sv.merge(afterExecFrame, (T) target.frame, currentStmt, target);
                stack.push(target);
            }",iterator
target,"{
                Stmt target = ((JumpStmt) currentStmt).getTarget();
                target.frame = sv.merge(afterExecFrame, (T) target.frame, currentStmt, target);
                stack.push(target);
            }",iterator
target,"{
                Stmt target = currentStmt.getNext();
                target.frame = sv.merge(afterExecFrame, (T) target.frame, currentStmt, target);
                stack.push(target);
            }",iterator
i,"for (int i = 0; i < ops.length; i++) {
                ops[i] = travelMod(ops[i], callback);
            }",loop_control
i,"for (int i = 0; i < ops.length; i++) {
                travel(ops[i], callback);
            }",loop_control
phi,"for (AssignStmt phi : labelStmt.phis) {
                        travelMod(phi, callback, false);
                    }",iterator
phi,"for (AssignStmt phi : labelStmt.phis) {
                        travel(phi, callback, false);
                    }",iterator
p,"for (Stmt p = stmts.getFirst(); p != null; p = p.getNext()) {
            travel(p, callback, travelPhi);
        }",maybe_loop_control
p,"for (Stmt p = stmts.getFirst(); p != null; p = p.getNext()) {
            travelMod(p, callback, travelPhi);
        }",maybe_loop_control
local,"for (Local local : method.locals) {
            local._ls_index = i++;
        }",iterator
target,"for (Stmt target : bss.targets) {
                tos.add(target);
            }",iterator
trap,"for (Trap trap : trips) {
            Trap ntrap = trap.clone(map);
            int status = 0;
            for (Stmt p = trap.start.getNext(); p != trap.end; p = p.getNext()) {
                if (!Cfg.notThrow(p)) {
                    if (status == 0) {
                        Stmt pre = p.getPre();
                        if (pre == null || pre.st != ST.LABEL) {
                            pre = Stmts.nLabel();
                            irMethod.stmts.insertBefore(p, pre);
                        }
                        ntrap.start = (LabelStmt) pre;
                        status = 1;
                    } else if (status == 1) {
                        // continue;
                    }

                } else if (status == 1) {
                    Stmt pre = p.getPre();
                    if (pre == null || pre.st != ST.LABEL) {
                        pre = Stmts.nLabel();
                        irMethod.stmts.insertBefore(p, pre);
                    }

                    ntrap.end = (LabelStmt) pre;
                    irMethod.traps.add(ntrap);
                    status = 0;
                    ntrap = trap.clone(map);
                }
            }
            if (status == 1) {
                ntrap.end = trap.end;
                irMethod.traps.add(ntrap);
                status = 0;
            }
        }",iterator
p,"for (Stmt p = trap.start.getNext(); p != trap.end; p = p.getNext()) {
                if (!Cfg.notThrow(p)) {
                    if (status == 0) {
                        Stmt pre = p.getPre();
                        if (pre == null || pre.st != ST.LABEL) {
                            pre = Stmts.nLabel();
                            irMethod.stmts.insertBefore(p, pre);
                        }
                        ntrap.start = (LabelStmt) pre;
                        status = 1;
                    } else if (status == 1) {
                        // continue;
                    }

                } else if (status == 1) {
                    Stmt pre = p.getPre();
                    if (pre == null || pre.st != ST.LABEL) {
                        pre = Stmts.nLabel();
                        irMethod.stmts.insertBefore(p, pre);
                    }

                    ntrap.end = (LabelStmt) pre;
                    irMethod.traps.add(ntrap);
                    status = 0;
                    ntrap = trap.clone(map);
                }
            }",maybe_loop_control
p,"for (Stmt p : method.stmts) {
            if (p.st == ASSIGN && p.getOp1().vt == LOCAL && p.getOp2().vt == NEW) {
                // the stmt is a new assign stmt
                Local local = (Local) p.getOp1();
                init.put(local, new TObject(local, (AssignStmt) p));
            }
        }",iterator
stmt,"for (Stmt stmt : method.stmts) {
                stmt.frame = null;
            }",iterator
it,"for (Iterator<Stmt> it = method.stmts.iterator(); it.hasNext(); ) {
            Stmt p = it.next();

            InvokeExpr ie = findInvokeExpr(p);

            if (ie != null) {
                if (""<init>"".equals(ie.getName()) && ""V"".equals(ie.getRet())) {
                    Value[] orgOps = ie.getOps();
                    if (orgOps[0].vt == NEW) {
                        NewExpr newExpr = (NewExpr) ie.getOps()[0];
                        if (newExpr != null) {
                            Value[] nOps = Arrays.copyOfRange(orgOps, 1, orgOps.length);
                            InvokeExpr invokeNew = Exprs.nInvokeNew(nOps, ie.getArgs(), ie.getOwner());
                            method.stmts.insertBefore(p, Stmts.nVoidInvoke(invokeNew));
                            it.remove();
                        }
                    }
                }
            }
        }",iterator
local,"for (Local local : method.locals) {
            locals[local._ls_index] = local;
        }",iterator
local,"{
                    Local b = locals[i];
                    if (b != obj.local) {
                        method.stmts.insertAfter(obj.invokeStmt, Stmts.nAssign(b, obj.local));
                    }
                }",iterator
local,"for (TObject obj : init.values()) {
            Vx[] frame = (Vx[]) obj.invokeStmt.frame;
            for (int i = 0; i < frame.length; i++) {
                Vx s = frame[i];
                if (s != null && s.obj == obj) {
                    Local b = locals[i];
                    if (b != obj.local) {
                        method.stmts.insertAfter(obj.invokeStmt, Stmts.nAssign(b, obj.local));
                    }
                }
            }
            InvokeExpr ie = findInvokeExpr(obj.invokeStmt);
            Value[] orgOps = ie.getOps();
            Value[] nOps = Arrays.copyOfRange(orgOps, 1, orgOps.length);
            InvokeExpr invokeNew = Exprs.nInvokeNew(nOps, ie.getArgs(), ie.getOwner());
            method.stmts.replace(obj.invokeStmt, Stmts.nAssign(obj.local, invokeNew));
        }",iterator
obj,"for (TObject obj : init.values()) {
            Vx[] frame = (Vx[]) obj.invokeStmt.frame;
            for (int i = 0; i < frame.length; i++) {
                Vx s = frame[i];
                if (s != null && s.obj == obj) {
                    toDelete.add(locals[i]);
                }
            }
        }",iterator
obj,"for (TObject obj : init.values()) {
            Vx[] frame = (Vx[]) obj.invokeStmt.frame;
            for (int i = 0; i < frame.length; i++) {
                Vx s = frame[i];
                if (s != null && s.obj == obj) {
                    Local b = locals[i];
                    if (b != obj.local) {
                        method.stmts.insertAfter(obj.invokeStmt, Stmts.nAssign(b, obj.local));
                    }
                }
            }
            InvokeExpr ie = findInvokeExpr(obj.invokeStmt);
            Value[] orgOps = ie.getOps();
            Value[] nOps = Arrays.copyOfRange(orgOps, 1, orgOps.length);
            InvokeExpr invokeNew = Exprs.nInvokeNew(nOps, ie.getArgs(), ie.getOwner());
            method.stmts.replace(obj.invokeStmt, Stmts.nAssign(obj.local, invokeNew));
        }",iterator
i,"for (int i = 0; i < frame.length; i++) {
                Vx s = frame[i];
                if (s != null && s.obj == obj) {
                    toDelete.add(locals[i]);
                }
            }",loop_control
i,"for (int i = 0; i < frame.length; i++) {
                Vx s = frame[i];
                if (s != null && s.obj == obj) {
                    Local b = locals[i];
                    if (b != obj.local) {
                        method.stmts.insertAfter(obj.invokeStmt, Stmts.nAssign(b, obj.local));
                    }
                }
            }",loop_control
it,"for (Iterator<Stmt> it = method.stmts.iterator(); it.hasNext(); ) {
            Stmt p = it.next();
            if (p.st == ASSIGN && p.getOp1().vt == LOCAL) {
                if (toDelete.contains((Local) p.getOp1())) {
                    it.remove();
                }
            }
        }",iterator
phi,"for (AssignStmt phi : labelStmt.phis) {
                                Local local = (Local) phi.getOp1();
                                tmp[local._ls_index] = IGNORED;
                            }",iterator
phi,"for (AssignStmt phi : phis) {
                            for (Value value : phi.getOp2().getOps()) {
                                Local local = (Local) value;
                                int i = local._ls_index;
                                Vx s = srcFrame[i];
                                Vx d = distFrame[i];
                                if (d != null) {
                                    if (!d.init) {
                                        TObject obj = d.obj;
                                        if (obj != null) {
                                            obj.useBeforeInit = true;
                                        }
                                    }
                                } else if (s != null) {
                                    if (!s.init) {
                                        TObject obj = s.obj;
                                        if (obj != null) {
                                            obj.useBeforeInit = true;
                                        }
                                    }
                                }
                            }
                        }",iterator
i,"for (int i = 0; i < tmp.length; i++) {
                                                Vx s = tmp[i];
                                                if (s != null && s.obj == object) {
                                                    tmp[i] = IGNORED;
                                                }
                                            }",loop_control
i,"for (int i = 0; i < size; i++) {
                        Vx s = srcFrame[i];
                        Vx d = distFrame[i];
                        if (s != null) {
                            if (d == null) {
                                distFrame[i] = s;
                            } else {
                                if (s != d) {
                                    TObject obj = s.obj;
                                    if (obj != null) {
                                        obj.useBeforeInit = true;
                                    }
                                    obj = d.obj;
                                    if (obj != null) {
                                        obj.useBeforeInit = true;
                                    }
                                }
                            }
                        }
                    }",loop_control
i,"for (Value value : phi.getOp2().getOps()) {
                                Local local = (Local) value;
                                int i = local._ls_index;
                                Vx s = srcFrame[i];
                                Vx d = distFrame[i];
                                if (d != null) {
                                    if (!d.init) {
                                        TObject obj = d.obj;
                                        if (obj != null) {
                                            obj.useBeforeInit = true;
                                        }
                                    }
                                } else if (s != null) {
                                    if (!s.init) {
                                        TObject obj = s.obj;
                                        if (obj != null) {
                                            obj.useBeforeInit = true;
                                        }
                                    }
                                }
                            }",loop_control
iterator,"for (Iterator<Map.Entry<Local, TObject>> iterator = init.entrySet().iterator(); iterator.hasNext(); ) {
            Map.Entry<Local, TObject> e = iterator.next();
            boolean keep = true;
            TObject obj = e.getValue();
            if (obj.useBeforeInit) {
                keep = false;
            }
            if (obj.invokeStmt == null) {
                keep = false;
            }
            if (!keep) {
                iterator.remove();
            }
        }",iterator
size,"{
        boolean changed = false;
        if (method.locals.size() == 0) {
            return false;
        }
        StmtSearcher st = new StmtSearcher() {
            @Override
            public void travel(Stmt stmt) {
                if (stmt.st == Stmt.ST.FILL_ARRAY_DATA) {
                    if (isNull(stmt.getOp1())) {
                        throw NPE;
                    }
                }
                super.travel(stmt);
            }

            @Override
            public void travel(Value op) {
                switch (op.vt) {
                case INVOKE_VIRTUAL:
                case INVOKE_SPECIAL:
                case INVOKE_INTERFACE: {
                    if (isNull(op.getOps()[0])) {
                        throw NPE;
                    }
                }
                    break;
                case ARRAY: {
                    if (isNull(op.getOp1())) {
                        throw NPE;
                    }
                }
                    break;
                case FIELD: {
                    if (isNull(op.getOp())) {
                        throw NPE;
                    }
                }
                    break;
                    case IDIV:
                        if (op.getOp2().vt == Value.VT.CONSTANT) {
                            Constant constant = (Constant) op.getOp2();
                            if (((Number) constant.value).intValue() == 0) {
                                throw DIVE;
                            }
                        }
                        break;
                    case LDIV:
                        if (op.getOp2().vt == Value.VT.CONSTANT) {
                            Constant constant = (Constant) op.getOp2();
                            if (((Number) constant.value).longValue() == 0) {
                                throw DIVE;
                            }
                        }
                        break;
                    case NEW_ARRAY:
                        if (op.getOp().vt == Value.VT.CONSTANT) {
                            Constant constant = (Constant) op.getOp();
                            if (((Number) constant.value).intValue() < 0) {
                                throw NEGATIVE_ARRAY_SIZE;
                            }
                        }
                        break;
                    case NEW_MUTI_ARRAY:
                        for (Value size : op.getOps()) {
                            if (size.vt == Value.VT.CONSTANT) {
                                Constant constant = (Constant) size;
                                if (((Number) constant.value).intValue() < 0) {
                                    throw NEGATIVE_ARRAY_SIZE;
                                }
                            }
                        }
                        break;
                default:
                }
            }

        };
        for (Stmt p = method.stmts.getFirst(); p != null;) {
            try {
                st.travel(p);
                p = p.getNext();
            } catch (MustThrowException e) {
                replace(method, p);
                Stmt q = p.getNext();
                method.stmts.remove(p);
                changed = true;
                p = q;
            }
        }
        return changed;
    }",iterator
p,"for (Stmt p = method.stmts.getFirst(); p != null;) {
            try {
                st.travel(p);
                p = p.getNext();
            } catch (MustThrowException e) {
                replace(method, p);
                Stmt q = p.getNext();
                method.stmts.remove(p);
                changed = true;
                p = q;
            }
        }",maybe_loop_control
i,"for (int i = 1; i < ops.length; i++) {
                            travel(ops[i]);
                        }",loop_control
size,"for (Value size : op.getOps()) {
                            if (size.vt == Value.VT.CONSTANT) {
                                Constant constant = (Constant) size;
                                if (((Number) constant.value).intValue() < 0) {
                                    throw NEGATIVE_ARRAY_SIZE;
                                }else {
                                    travel(size);
                                }
                            }
                        }",iterator
e,"for (Map.Entry<Local, ArrayObject> e : arraySizes.entrySet()) {
            final Local local0 = e.getKey();
            final ArrayObject ao = e.getValue();
            final Value t[] = new Value[ao.size];
            for (Iterator<Stmt> it = ao.putItem.iterator(); it.hasNext();) {
                Stmt p = it.next();
                if (p.st == Stmt.ST.FILL_ARRAY_DATA) {
                    Local local = (Local) p.getOp1();
                    if (local == local0) {
                        Object vs = ((Constant) p.getOp2()).value;
                        int endPos = Array.getLength(vs);
                        for (int j = 0; j < endPos; j++) {
                            t[j] = Exprs.nConstant(Array.get(vs, j));
                        }
                    }
                } else { // ASSIGN
                    ArrayExpr ae = (ArrayExpr) p.getOp1();
                    Local local = (Local) ae.getOp1();
                    if (local == local0) {
                        int idx = ((Number) ((Constant) ae.getOp2()).value).intValue();
                        Value op2 = p.getOp2();
                        if (op2.vt != Value.VT.LOCAL && op2.vt != Value.VT.CONSTANT) {
                            Local n = new Local(-1);
                            method.locals.add(n);
                            method.stmts.insertBefore(p, Stmts.nAssign(n, op2));
                            op2 = n;
                        }
                        t[idx] = op2;
                    }
                }
            }

            // for code
            // b=new Object[1]
            // b[0]=null
            // a =new Object[1]
            // a =b;
            // use(a)
            // if a is replace before b, the code
            // b=new Object[1]
            // b[0]=null
            // use(new Object[]{b})
            // the used stmt of b is outdated, so we have to search pre replaced arrays

            method.locals.remove(local0);
            method.stmts.remove(ao.init);
            for (Stmt p : ao.putItem) {
                method.stmts.remove(p);
            }
            Cfg.TravelCallBack tcb = new Cfg.TravelCallBack() {
                @Override
                public Value onAssign(Local v, AssignStmt as) {
                    return v;
                }

                @Override
                public Value onUse(Local v) {
                    if (local0 == v) {
                        FilledArrayExpr fae = Exprs.nFilledArray(ao.type, t);
                        filledArrayExprs.add(fae);
                        return fae;
                    }
                    return v;
                }
            };

            if (ao.used.size() == 1) {
                Stmt stmt = ao.used.get(0);
                if (method.stmts.contains(stmt)) { // the stmt is not removed by pre array replacement
                    Cfg.travelMod(stmt, tcb, false);
                } else {
                    int size = filledArrayExprs.size();
                    for (int i = 0; i < size; i++) {
                        Cfg.travelMod(filledArrayExprs.get(i), tcb);
                    }
                }
            } else if (ao.used.size() == 0) {
                // the array is never used, ignore
            } else {
                throw new RuntimeException(""array is used multiple times"");
            }
        }",iterator
it,"for (Iterator<Stmt> it = ao.putItem.iterator(); it.hasNext();) {
                Stmt p = it.next();
                if (p.st == Stmt.ST.FILL_ARRAY_DATA) {
                    Local local = (Local) p.getOp1();
                    if (local == local0) {
                        Object vs = ((Constant) p.getOp2()).value;
                        int endPos = Array.getLength(vs);
                        for (int j = 0; j < endPos; j++) {
                            t[j] = Exprs.nConstant(Array.get(vs, j));
                        }
                    }
                } else { // ASSIGN
                    ArrayExpr ae = (ArrayExpr) p.getOp1();
                    Local local = (Local) ae.getOp1();
                    if (local == local0) {
                        int idx = ((Number) ((Constant) ae.getOp2()).value).intValue();
                        Value op2 = p.getOp2();
                        if (op2.vt != Value.VT.LOCAL && op2.vt != Value.VT.CONSTANT) {
                            Local n = new Local(-1);
                            method.locals.add(n);
                            method.stmts.insertBefore(p, Stmts.nAssign(n, op2));
                            op2 = n;
                        }
                        t[idx] = op2;
                    }
                }
            }",iterator
j,"for (int j = 0; j < endPos; j++) {
                            t[j] = Exprs.nConstant(Array.get(vs, j));
                        }",loop_control
p,"for (Iterator<Stmt> it = ao.putItem.iterator(); it.hasNext();) {
                Stmt p = it.next();
                if (p.st == Stmt.ST.FILL_ARRAY_DATA) {
                    Local local = (Local) p.getOp1();
                    if (local == local0) {
                        Object vs = ((Constant) p.getOp2()).value;
                        int endPos = Array.getLength(vs);
                        for (int j = 0; j < endPos; j++) {
                            t[j] = Exprs.nConstant(Array.get(vs, j));
                        }
                    }
                } else { // ASSIGN
                    ArrayExpr ae = (ArrayExpr) p.getOp1();
                    Local local = (Local) ae.getOp1();
                    if (local == local0) {
                        int idx = ((Number) ((Constant) ae.getOp2()).value).intValue();
                        Value op2 = p.getOp2();
                        if (op2.vt != Value.VT.LOCAL && op2.vt != Value.VT.CONSTANT) {
                            Local n = new Local(-1);
                            method.locals.add(n);
                            method.stmts.insertBefore(p, Stmts.nAssign(n, op2));
                            op2 = n;
                        }
                        t[idx] = op2;
                    }
                }
            }",iterator
p,"for (Stmt p : ao.putItem) {
                method.stmts.remove(p);
            }",iterator
local,"for (Local local : method.locals) {
            local._ls_index = -1;
        }",iterator
local,"for (Local local : arrays) {
                    local._ls_index = -1;
                }",iterator
i,"for (int i = 0; i < MAX && it.hasNext(); i++) {
                    Map.Entry<Local, ArrayObject> e = it.next();
                    keptInPart.put(e.getKey(), e.getValue());
                    it.remove();
                    arrays.add(e.getKey());
                }",loop_control
it,"{

            // this method consumes too many memory, case 'java.lang.OutOfMemoryError: Java heap space', we have to cut
            // it
            Map<Local, ArrayObject> keptInAll = new HashMap<>();
            Map<Local, ArrayObject> keptInPart = new HashMap<>();
            List<Local> arrays = new ArrayList<>(MAX);

            Iterator<Map.Entry<Local, ArrayObject>> it = arraySizes.entrySet().iterator();
            while (it.hasNext()) {
                for (int i = 0; i < MAX && it.hasNext(); i++) {
                    Map.Entry<Local, ArrayObject> e = it.next();
                    keptInPart.put(e.getKey(), e.getValue());
                    it.remove();
                    arrays.add(e.getKey());
                }
                makeSureArrayUsedAfterAllElementAssigned0(method, keptInPart);
                for (Local local : arrays) {
                    local._ls_index = -1;
                }
                arrays.clear();
                keptInAll.putAll(keptInPart);
                keptInPart.clear();
            }
            arraySizes.putAll(keptInAll);
        }",iterator
local,"for (Local local : arraySizes.keySet()) {
            local._ls_index = i++;
        }",iterator
local,"{
                            ArrayObjectValue aov = new ArrayObjectValue(arc.local);
                            values.add(aov);
                            aov.array = arc.array;
                            aov.parent = arc;
                            aov.pos = (BitSet) arc.pos.clone();
                            distFrame[i] = aov;
                        }",iterator
local,"{
                        Local local = (Local) stmt.getOp1();
                        if (local._ls_index >= 0) {
                            ArrayObjectValue av = tmp[local._ls_index];
                            Constant cst = (Constant) stmt.getOp2();
                            int endPos = Array.getLength(cst.value);
                            av.pos.set(0, endPos);
                        }
                    }",iterator
local,"{
                        Local local = (Local) ae.getOp1();
                        if (local._ls_index >= 0) {
                            int index = ((Number) ((Constant) ae.getOp2()).value).intValue();
                            ArrayObjectValue av = tmp[local._ls_index];
                            av.pos.set(index);
                        } else {
                            use(ae);
                        }
                    }",iterator
local,"{
                    Local local = (Local) stmt.getOp1();
                    use(stmt.getOp2());

                    if (local._ls_index >= 0) {
                        ArrayObjectValue aov = new ArrayObjectValue(local);
                        aov.array = arraySizes.get(local);
                        aov.pos = new BitSet();
                        values.add(aov);
                        tmp[local._ls_index] = aov;
                    }
                }",iterator
local,"{
                        Local local = (Local) v;
                        if (local._ls_index >= 0) {
                            ArrayObjectValue aov = tmp[local._ls_index];
                            aov.array.used.add(currentStmt);
                            aov.used = true;
                        }
                    }",iterator
local,"{
                arraySizes.remove(avo.local);
            }",iterator
local,"{
                            arraySizes.remove(avo.local);
                            break;
                        }",iterator
local,"for (Iterator<Map.Entry<Local, ArrayObject>> it = arraySizes.entrySet().iterator(); it.hasNext();) {
            Map.Entry<Local, ArrayObject> e = it.next();
            Local local = e.getKey();
            ArrayObject arrayObject = e.getValue();
            for (Stmt use : arrayObject.used) {
                ArrayObjectValue frame[] = (ArrayObjectValue[]) use.frame;
                ArrayObjectValue aov = frame[local._ls_index];
                BitSet pos = aov.pos;
                if (pos.nextClearBit(0) < arrayObject.size || pos.nextSetBit(arrayObject.size) >= 0) {
                    it.remove();
                    break;
                }
            }
        }",iterator
i,"{
        int i = 0;
        for (Local local : arraySizes.keySet()) {
            local._ls_index = i++;
        }

        final int size = i;
        final List<ArrayObjectValue> values = new ArrayList<>();
        Cfg.dfs(method.stmts, new Cfg.FrameVisitor<ArrayObjectValue[]>() {

            @Override
            public ArrayObjectValue[] merge(ArrayObjectValue[] srcFrame, ArrayObjectValue[] distFrame, Stmt src,
                    Stmt dist) {
                if (distFrame == null) {
                    distFrame = new ArrayObjectValue[size];
                    for (int i = 0; i < size; i++) {
                        ArrayObjectValue arc = srcFrame[i];
                        if (arc != null) {
                            ArrayObjectValue aov = new ArrayObjectValue(arc.local);
                            values.add(aov);
                            aov.array = arc.array;
                            aov.parent = arc;
                            aov.pos = (BitSet) arc.pos.clone();
                            distFrame[i] = aov;
                        }
                    }
                } else {
                    for (int i = 0; i < size; i++) {
                        ArrayObjectValue arc = srcFrame[i];
                        ArrayObjectValue aov = distFrame[i];
                        if (arc != null && aov != null) {
                            if (aov.otherParent == null) {
                                aov.otherParent = new HashSet<>();
                            }
                            aov.otherParent.add(arc);
                        }
                    }
                }
                return distFrame;
            }

            @Override
            public ArrayObjectValue[] initFirstFrame(Stmt first) {
                return new ArrayObjectValue[size];
            }

            ArrayObjectValue tmp[] = initFirstFrame(null);
            Stmt currentStmt;

            @Override
            public ArrayObjectValue[] exec(ArrayObjectValue[] frame, Stmt stmt) {
                currentStmt = stmt;
                System.arraycopy(frame, 0, tmp, 0, size);
                if (stmt.st == Stmt.ST.FILL_ARRAY_DATA) {
                    if (stmt.getOp1().vt == Value.VT.LOCAL) {
                        Local local = (Local) stmt.getOp1();
                        if (local._ls_index >= 0) {
                            ArrayObjectValue av = tmp[local._ls_index];
                            Constant cst = (Constant) stmt.getOp2();
                            int endPos = Array.getLength(cst.value);
                            av.pos.set(0, endPos);
                        }
                    } else {
                        use(stmt.getOp1());
                    }
                } else if (stmt.st == Stmt.ST.ASSIGN && stmt.getOp1().vt == Value.VT.ARRAY) {
                    use(stmt.getOp2());
                    ArrayExpr ae = (ArrayExpr) stmt.getOp1();
                    if (ae.getOp1().vt == Value.VT.LOCAL) {
                        Local local = (Local) ae.getOp1();
                        if (local._ls_index >= 0) {
                            int index = ((Number) ((Constant) ae.getOp2()).value).intValue();
                            ArrayObjectValue av = tmp[local._ls_index];
                            av.pos.set(index);
                        } else {
                            use(ae);
                        }
                    } else {
                        use(ae);
                    }
                } else if (stmt.st == Stmt.ST.ASSIGN && stmt.getOp1().vt == Value.VT.LOCAL) {
                    Local local = (Local) stmt.getOp1();
                    use(stmt.getOp2());

                    if (local._ls_index >= 0) {
                        ArrayObjectValue aov = new ArrayObjectValue(local);
                        aov.array = arraySizes.get(local);
                        aov.pos = new BitSet();
                        values.add(aov);
                        tmp[local._ls_index] = aov;
                    }
                } else {
                    switch (stmt.et) {
                    case E0:
                        break;
                    case E1:
                        use(stmt.getOp());
                        break;
                    case E2:
                        use(stmt.getOp1());
                        use(stmt.getOp2());
                        break;
                    case En:
                        throw new RuntimeException();
                    }
                }
                return tmp;
            }

            private void use(Value v) {
                switch (v.et) {
                case E0:
                    if (v.vt == Value.VT.LOCAL) {
                        Local local = (Local) v;
                        if (local._ls_index >= 0) {
                            ArrayObjectValue aov = tmp[local._ls_index];
                            aov.array.used.add(currentStmt);
                            aov.used = true;
                        }
                    }
                    break;
                case E1:
                    use(v.getOp());
                    break;
                case E2:
                    use(v.getOp1());
                    use(v.getOp2());
                    break;
                case En:
                    for (Value op : v.getOps()) {
                        use(op);
                    }
                    break;
                }
            }
        });

        Set<ArrayObjectValue> used = markUsed(values);

        // check if ArrayObjectValue have different parent assignment
        for (ArrayObjectValue avo : used) {
            if (avo.array.used.size() > 1) {
                arraySizes.remove(avo.local);
            } else {
                if (avo.parent != null && avo.otherParent != null) {
                    // BitSet bs = avo.pos;
                    BitSet p = avo.parent.pos;
                    for (ArrayObjectValue ps : avo.otherParent) {
                        if (!p.equals(ps.pos)) {
                            arraySizes.remove(avo.local);
                            break;
                        }
                    }
                }
            }
        }
        // check for un full init array
        for (Iterator<Map.Entry<Local, ArrayObject>> it = arraySizes.entrySet().iterator(); it.hasNext();) {
            Map.Entry<Local, ArrayObject> e = it.next();
            Local local = e.getKey();
            ArrayObject arrayObject = e.getValue();
            for (Stmt use : arrayObject.used) {
                ArrayObjectValue frame[] = (ArrayObjectValue[]) use.frame;
                ArrayObjectValue aov = frame[local._ls_index];
                BitSet pos = aov.pos;
                if (pos.nextClearBit(0) < arrayObject.size || pos.nextSetBit(arrayObject.size) >= 0) {
                    it.remove();
                    break;
                }
            }
        }

        // clean up
        for (Stmt stmt : method.stmts) {
            stmt.frame = null;
        }
    }",loop_control
op,"for (Value op : v.getOps()) {
                        use(op);
                    }",iterator
avo,"for (ArrayObjectValue avo : used) {
            if (avo.array.used.size() > 1) {
                arraySizes.remove(avo.local);
            } else {
                if (avo.parent != null && avo.otherParent != null) {
                    // BitSet bs = avo.pos;
                    BitSet p = avo.parent.pos;
                    for (ArrayObjectValue ps : avo.otherParent) {
                        if (!p.equals(ps.pos)) {
                            arraySizes.remove(avo.local);
                            break;
                        }
                    }
                }
            }
        }",iterator
ps,"for (ArrayObjectValue ps : avo.otherParent) {
                        if (!p.equals(ps.pos)) {
                            arraySizes.remove(avo.local);
                            break;
                        }
                    }",iterator
it,"for (Iterator<Map.Entry<Local, ArrayObject>> it = arraySizes.entrySet().iterator(); it.hasNext();) {
            Map.Entry<Local, ArrayObject> e = it.next();
            Local local = e.getKey();
            ArrayObject arrayObject = e.getValue();
            for (Stmt use : arrayObject.used) {
                ArrayObjectValue frame[] = (ArrayObjectValue[]) use.frame;
                ArrayObjectValue aov = frame[local._ls_index];
                BitSet pos = aov.pos;
                if (pos.nextClearBit(0) < arrayObject.size || pos.nextSetBit(arrayObject.size) >= 0) {
                    it.remove();
                    break;
                }
            }
        }",iterator
use,"{
                        use(stmt.getOp1());
                    }",iterator
use,"{
                    use(stmt.getOp2());
                    ArrayExpr ae = (ArrayExpr) stmt.getOp1();
                    if (ae.getOp1().vt == Value.VT.LOCAL) {
                        Local local = (Local) ae.getOp1();
                        if (local._ls_index >= 0) {
                            int index = ((Number) ((Constant) ae.getOp2()).value).intValue();
                            ArrayObjectValue av = tmp[local._ls_index];
                            av.pos.set(index);
                        } else {
                            use(ae);
                        }
                    } else {
                        use(ae);
                    }
                }",iterator
use,"{
                    Local local = (Local) stmt.getOp1();
                    use(stmt.getOp2());

                    if (local._ls_index >= 0) {
                        ArrayObjectValue aov = new ArrayObjectValue(local);
                        aov.array = arraySizes.get(local);
                        aov.pos = new BitSet();
                        values.add(aov);
                        tmp[local._ls_index] = aov;
                    }
                }",iterator
use,"{
                    case E0:
                        break;
                    case E1:
                        use(stmt.getOp());
                        break;
                    case E2:
                        use(stmt.getOp1());
                        use(stmt.getOp2());
                        break;
                    case En:
                        throw new RuntimeException();
                    }",iterator
use,"{

            @Override
            public ArrayObjectValue[] merge(ArrayObjectValue[] srcFrame, ArrayObjectValue[] distFrame, Stmt src,
                    Stmt dist) {
                if (distFrame == null) {
                    distFrame = new ArrayObjectValue[size];
                    for (int i = 0; i < size; i++) {
                        ArrayObjectValue arc = srcFrame[i];
                        if (arc != null) {
                            ArrayObjectValue aov = new ArrayObjectValue(arc.local);
                            values.add(aov);
                            aov.array = arc.array;
                            aov.parent = arc;
                            aov.pos = (BitSet) arc.pos.clone();
                            distFrame[i] = aov;
                        }
                    }
                } else {
                    for (int i = 0; i < size; i++) {
                        ArrayObjectValue arc = srcFrame[i];
                        ArrayObjectValue aov = distFrame[i];
                        if (arc != null && aov != null) {
                            if (aov.otherParent == null) {
                                aov.otherParent = new HashSet<>();
                            }
                            aov.otherParent.add(arc);
                        }
                    }
                }
                return distFrame;
            }

            @Override
            public ArrayObjectValue[] initFirstFrame(Stmt first) {
                return new ArrayObjectValue[size];
            }

            ArrayObjectValue tmp[] = initFirstFrame(null);
            Stmt currentStmt;

            @Override
            public ArrayObjectValue[] exec(ArrayObjectValue[] frame, Stmt stmt) {
                currentStmt = stmt;
                System.arraycopy(frame, 0, tmp, 0, size);
                if (stmt.st == Stmt.ST.FILL_ARRAY_DATA) {
                    if (stmt.getOp1().vt == Value.VT.LOCAL) {
                        Local local = (Local) stmt.getOp1();
                        if (local._ls_index >= 0) {
                            ArrayObjectValue av = tmp[local._ls_index];
                            Constant cst = (Constant) stmt.getOp2();
                            int endPos = Array.getLength(cst.value);
                            av.pos.set(0, endPos);
                        }
                    } else {
                        use(stmt.getOp1());
                    }
                } else if (stmt.st == Stmt.ST.ASSIGN && stmt.getOp1().vt == Value.VT.ARRAY) {
                    use(stmt.getOp2());
                    ArrayExpr ae = (ArrayExpr) stmt.getOp1();
                    if (ae.getOp1().vt == Value.VT.LOCAL) {
                        Local local = (Local) ae.getOp1();
                        if (local._ls_index >= 0) {
                            int index = ((Number) ((Constant) ae.getOp2()).value).intValue();
                            ArrayObjectValue av = tmp[local._ls_index];
                            av.pos.set(index);
                        } else {
                            use(ae);
                        }
                    } else {
                        use(ae);
                    }
                } else if (stmt.st == Stmt.ST.ASSIGN && stmt.getOp1().vt == Value.VT.LOCAL) {
                    Local local = (Local) stmt.getOp1();
                    use(stmt.getOp2());

                    if (local._ls_index >= 0) {
                        ArrayObjectValue aov = new ArrayObjectValue(local);
                        aov.array = arraySizes.get(local);
                        aov.pos = new BitSet();
                        values.add(aov);
                        tmp[local._ls_index] = aov;
                    }
                } else {
                    switch (stmt.et) {
                    case E0:
                        break;
                    case E1:
                        use(stmt.getOp());
                        break;
                    case E2:
                        use(stmt.getOp1());
                        use(stmt.getOp2());
                        break;
                    case En:
                        throw new RuntimeException();
                    }
                }
                return tmp;
            }

            private void use(Value v) {
                switch (v.et) {
                case E0:
                    if (v.vt == Value.VT.LOCAL) {
                        Local local = (Local) v;
                        if (local._ls_index >= 0) {
                            ArrayObjectValue aov = tmp[local._ls_index];
                            aov.array.used.add(currentStmt);
                            aov.used = true;
                        }
                    }
                    break;
                case E1:
                    use(v.getOp());
                    break;
                case E2:
                    use(v.getOp1());
                    use(v.getOp2());
                    break;
                case En:
                    for (Value op : v.getOps()) {
                        use(op);
                    }
                    break;
                }
            }
        }",iterator
use,"for (Stmt use : arrayObject.used) {
                ArrayObjectValue frame[] = (ArrayObjectValue[]) use.frame;
                ArrayObjectValue aov = frame[local._ls_index];
                BitSet pos = aov.pos;
                if (pos.nextClearBit(0) < arrayObject.size || pos.nextSetBit(arrayObject.size) >= 0) {
                    it.remove();
                    break;
                }
            }",iterator
q,"{
        Set<ArrayObjectValue> used = new HashSet<>(values.size() / 2);
        Queue<ArrayObjectValue> q = new UniqueQueue<>();
        q.addAll(values);
        values.clear();
        while (!q.isEmpty()) {
            ArrayObjectValue v = q.poll();
            if (v.used) {
                if (used.contains(v)) {
                    continue;
                }
                used.add(v);
                {
                    ArrayObjectValue p = v.parent;
                    if (p != null) {
                        if (!p.used) {
                            p.used = true;
                            q.add(p);
                        }
                    }
                }
                if (v.otherParent != null) {
                    for (ArrayObjectValue p : v.otherParent) {
                        if (!p.used) {
                            p.used = true;
                            q.add(p);
                        }
                    }
                }
            }
        }

        return used;
    }",maybe_loop_control
p,"{
                    ArrayObjectValue p = v.parent;
                    if (p != null) {
                        if (!p.used) {
                            p.used = true;
                            q.add(p);
                        }
                    }
                }",iterator
p,"for (ArrayObjectValue p : v.otherParent) {
                        if (!p.used) {
                            p.used = true;
                            q.add(p);
                        }
                    }",iterator
it,"for (Iterator<Map.Entry<Local, ArrayObject>> it = arraySizes.entrySet().iterator(); it.hasNext();) {
            Map.Entry<Local, ArrayObject> e = it.next();
            ArrayObject arrayObject = e.getValue();
            boolean needRemove = false;
            for (Stmt p : arrayObject.putItem) {
                if (p.st == Stmt.ST.FILL_ARRAY_DATA) {
                    int endPos = Array.getLength(((Constant) p.getOp2()).value);
                    int next = pos.nextSetBit(0);
                    if (next < 0 || next >= endPos) {// not set in range
                        pos.set(0, endPos);
                    } else {// setted in range
                        needRemove = true;
                        break;
                    }
                } else { // ASSIGN
                    ArrayExpr ae = (ArrayExpr) p.getOp1();
                    int idx = ((Number) ((Constant) ae.getOp2()).value).intValue();
                    if (!pos.get(idx)) {
                        pos.set(idx);
                    } else {
                        needRemove = true;
                        break;
                    }
                }
            }
            if (needRemove || pos.nextClearBit(0) < arrayObject.size || pos.nextSetBit(arrayObject.size) >= 0) {
                it.remove();
            }
            pos.clear();
        }",iterator
p,"for (Stmt p : arrayObject.putItem) {
                if (p.st == Stmt.ST.FILL_ARRAY_DATA) {
                    int endPos = Array.getLength(((Constant) p.getOp2()).value);
                    int next = pos.nextSetBit(0);
                    if (next < 0 || next >= endPos) {// not set in range
                        pos.set(0, endPos);
                    } else {// setted in range
                        needRemove = true;
                        break;
                    }
                } else { // ASSIGN
                    ArrayExpr ae = (ArrayExpr) p.getOp1();
                    int idx = ((Number) ((Constant) ae.getOp2()).value).intValue();
                    if (!pos.get(idx)) {
                        pos.set(idx);
                    } else {
                        needRemove = true;
                        break;
                    }
                }
            }",iterator
labelStmt,"for (LabelStmt labelStmt : method.phiLabels) {
                    if (labelStmt.phis != null) {
                        for (AssignStmt as : labelStmt.phis) {
                            set.add((Local) as.getOp1());
                            for (Value v : as.getOp2().getOps()) {
                                set.add((Local) v);
                            }
                        }
                    }
                }",iterator
as,"for (AssignStmt as : labelStmt.phis) {
                            set.add((Local) as.getOp1());
                            for (Value v : as.getOp2().getOps()) {
                                set.add((Local) v);
                            }
                        }",iterator
v,"for (Value v : as.getOp2().getOps()) {
                                set.add((Local) v);
                            }",iterator
local,"{
                            Local local = (Local) ae.getOp1();
                            ArrayObject arrayObject = arraySizes.get(local);
                            if (arrayObject != null) {
                                if (ae.getOp2().vt == Value.VT.CONSTANT) {
                                    arrayObject.putItem.add(p);
                                } else {
                                    arraySizes.remove(local);
                                }
                            }
                        }",iterator
local,"{
                        Local local = (Local) p.getOp1();
                        ArrayObject arrayObject = arraySizes.get(local);
                        if (arrayObject != null) {
                            arrayObject.putItem.add(p);
                        }
                    }",iterator
local,"for (Local local : set) {
                    arraySizes.remove(local);
                }",iterator
p,"for (Stmt p = irMethod.stmts.getFirst(); p != null;) {
            if (arrayNPE(p)) {
                Stmt q = p.getNext();
                replaceNPE(irMethod.stmts, irMethod.locals, p);
                p = q;
                continue;
            }
            p = p.getNext();
        }",maybe_loop_control
value,"for (Value value : values) {
            switch (value.vt) {
            case CONSTANT:
            case LOCAL:
                break;
            default:
                Local n = Exprs.nLocal(""xxx"");
                locals.add(n);
                stmts.insertBefore(p, Stmts.nAssign(n, value));
            }
        }",iterator
vb,"for (Value vb : ((EnExpr) value).ops) {
                    if (!tryAdd(vb.trim(), values)) {
                        break;
                    }
                }",iterator
vb,"for (Value vb : ((EnExpr) value).ops) {
                if (arrayNPE(vb.trim())) {
                    return true;
                }
            }",iterator
vb,"for (Value vb : ((EnExpr) value).ops) {
                if (arrayNPE(vb.trim())) {
                    return true;
                }
            }",break_loop_control
local,"for (Local local : method.locals) {
            local._ls_index = -1;
        }",iterator
local,"for (Local local : arrays) {
            local._ls_index = i++;
        }",iterator
local,"{
                        Local local = (Local) stmt.getOp1();
                        use(stmt.getOp2());
                        if (local._ls_index >= 0) {
                            Value op2 = stmt.getOp2();
                            if (op2.vt == Value.VT.NEW_ARRAY) {
                                ArrayValue av = new ArrayValue();
                                av.s = ArrayValue.S.DEFAULT;
                                av.size = op2.getOp();
                                values.add(av);
                                tmp[local._ls_index] = av;
                            } else if (op2.vt == Value.VT.FILLED_ARRAY) {
                                ArrayValue av = new ArrayValue();
                                av.s = ArrayValue.S.DEFAULT;
                                av.indexType = ArrayValue.IndexType.CONST;
                                av.stmt = stmt;
                                FilledArrayExpr fae = (FilledArrayExpr) stmt.getOp2();
                                av.size = Exprs.nInt(fae.getOps().length);
                                Value[] ops = fae.getOps();
                                for (int i = 0; i < ops.length; i++) {
                                    av.elements1.put(i, ops[i]);
                                }
                                values.add(av);
                                tmp[local._ls_index] = av;
                            } else if (op2.vt == Value.VT.CONSTANT) {
                                Object cst = ((Constant) op2).value;
                                if (cst != null && !cst.equals(Constant.Null) && cst.getClass().isArray()) {
                                    ArrayValue av = new ArrayValue();
                                    av.s = ArrayValue.S.DEFAULT;
                                    av.indexType = ArrayValue.IndexType.CONST;
                                    av.stmt = stmt;
                                    int size = Array.getLength(cst);
                                    av.size = Exprs.nInt(size);
                                    for (int i = 0; i < size; i++) {
                                        av.elements1.put(i, Exprs.nConstant(Array.get(cst, size)));
                                    }
                                    values.add(av);
                                    tmp[local._ls_index] = av;
                                } else {
                                    ArrayValue av = new ArrayValue();
                                    values.add(av);
                                    av.s = ArrayValue.S.UNKNOWN;
                                    av.indexType = ArrayValue.IndexType.NONE;
                                    av.stmt = stmt;
                                    tmp[local._ls_index] = av;
                                }
                            } else {
                                ArrayValue av = new ArrayValue();
                                values.add(av);
                                av.s = ArrayValue.S.UNKNOWN;
                                av.indexType = ArrayValue.IndexType.NONE;
                                av.stmt = stmt;
                                tmp[local._ls_index] = av;
                            }
                        }
                        // assign index1
                    }",iterator
local,"{
                            Local local = (Local) ae.getOp1();
                            Value index = ae.getOp2();
                            if (local._ls_index >= 0) {
                                if (index.vt == Value.VT.CONSTANT) {
                                    ArrayValue parent = tmp[local._ls_index];
                                    ArrayValue av = new ArrayValue();
                                    values.add(av);
                                    av.parent = parent;
                                    av.elements1.put(((Number) (((Constant) index).value)).intValue(), stmt.getOp2());
                                    av.indexType = ArrayValue.IndexType.CONST;
                                    av.s = ArrayValue.S.INHERIT;
                                    av.stmt = stmt;
                                    tmp[local._ls_index] = av;
                                } else if (index.vt == Value.VT.LOCAL) {
                                    ArrayValue parent = tmp[local._ls_index];
                                    ArrayValue av = new ArrayValue();
                                    values.add(av);
                                    av.parent = parent;
                                    av.elements1.put(index, stmt.getOp2());
                                    av.indexType = ArrayValue.IndexType.LOCAL;
                                    av.s = ArrayValue.S.INHERIT;
                                    av.stmt = stmt;
                                    tmp[local._ls_index] = av;
                                } else {
                                    ArrayValue av = new ArrayValue();
                                    values.add(av);
                                    av.s = ArrayValue.S.UNKNOWN;
                                    av.indexType = ArrayValue.IndexType.NONE;
                                    av.stmt = stmt;
                                    tmp[local._ls_index] = av;
                                }
                            } else {
                                use(stmt.getOp1());
                            }
                        }",iterator
local,"{
                        Local local = (Local) stmt.getOp1();
                        if (local._ls_index >= 0) {
                            Object array = ((Constant) stmt.getOp2()).value;
                            ArrayValue parent = tmp[local._ls_index];
                            ArrayValue av = new ArrayValue();
                            values.add(av);
                            av.parent = parent;
                            int size = Array.getLength(array);
                            av.size = Exprs.nInt(size);
                            for (int i = 0; i < size; i++) {
                                av.elements1.put(i, Exprs.nConstant(Array.get(array, i)));
                            }
                            av.indexType = ArrayValue.IndexType.CONST;
                            av.s = ArrayValue.S.INHERIT;
                            av.stmt = stmt;
                            tmp[local._ls_index] = av;
                        }
                    }",iterator
local,"{
                                Local local = (Local) op1;
                                if (local._ls_index > 0) {
                                    used.add(currentStmt);
                                }
                            }",iterator
phi,"for (AssignStmt phi : labelStmt.phis) {
                            int idx = ((Local) phi.getOp1())._ls_index;
                            if (idx >= 0) {
                                phis.add(idx);
                            }
                        }",iterator
i,"{

        Set<Local> arrays = searchForArrayObject(method);
        if (arrays.size() == 0) {
            return false;
        }
        for (Local local : method.locals) {
            local._ls_index = -1;
        }
        int i = 0;
        for (Local local : arrays) {
            local._ls_index = i++;
        }
        final int size = i;
        Cfg.createCFG(method);
        final List<ArrayValue> values = new ArrayList<>();
        final List<Stmt> used = new ArrayList<>();
        Cfg.dfs(method.stmts, new Cfg.FrameVisitor<ArrayValue[]>() {

            Set<Integer> phis = new HashSet<>();

            @Override
            public ArrayValue[] merge(ArrayValue[] srcFrame, ArrayValue[] distFrame, Stmt src, Stmt dist) {
                if (dist.st == Stmt.ST.LABEL) {
                    LabelStmt labelStmt = (LabelStmt) dist;
                    if (labelStmt.phis != null) {
                        for (AssignStmt phi : labelStmt.phis) {
                            int idx = ((Local) phi.getOp1())._ls_index;
                            if (idx >= 0) {
                                phis.add(idx);
                            }
                        }
                    }
                }
                if (distFrame == null) {
                    distFrame = new ArrayValue[size];
                    for (int i = 0; i < size; i++) {
                        if (phis.contains(i)) {
                            ArrayValue aov = new ArrayValue();
                            values.add(aov);
                            aov.s = ArrayValue.S.UNKNOWN;
                            aov.indexType = ArrayValue.IndexType.NONE;
                            aov.stmt = dist;
                            distFrame[i] = aov;
                        } else {
                            ArrayValue arc = srcFrame[i];
                            if (arc != null) {
                                ArrayValue aov = new ArrayValue();
                                values.add(aov);
                                aov.s = ArrayValue.S.INHERIT;
                                aov.indexType = ArrayValue.IndexType.NONE;
                                aov.stmt = dist;
                                aov.parent = arc;
                                distFrame[i] = aov;
                            }
                        }
                    }
                } else {
                    for (int i = 0; i < size; i++) {
                        if (phis.contains(i)) {
                            continue;
                        }
                        ArrayValue arc = srcFrame[i];
                        ArrayValue aov = distFrame[i];
                        if (arc != null && aov != null) {
                            if (aov.parent == null) {
                                aov.parent = arc;
                            } else if (!aov.parent.equals(arc)) {
                                if (aov.otherParents == null) {
                                    aov.otherParents = new HashSet<>();
                                }
                                aov.otherParents.add(arc);
                            }
                        }
                    }
                }
                phis.clear();
                return distFrame;
            }

            @Override
            public ArrayValue[] initFirstFrame(Stmt first) {
                return new ArrayValue[size];
            }

            ArrayValue[] tmp = new ArrayValue[size];
            Stmt currentStmt;


            @Override
            public ArrayValue[] exec(ArrayValue[] frame, Stmt stmt) {
                currentStmt = stmt;
                System.arraycopy(frame, 0, tmp, 0, size);
                if (stmt.st == Stmt.ST.ASSIGN) {
                    // create an array
                    if (stmt.getOp1().vt == Value.VT.LOCAL) {
                        Local local = (Local) stmt.getOp1();
                        use(stmt.getOp2());
                        if (local._ls_index >= 0) {
                            Value op2 = stmt.getOp2();
                            if (op2.vt == Value.VT.NEW_ARRAY) {
                                ArrayValue av = new ArrayValue();
                                av.s = ArrayValue.S.DEFAULT;
                                av.size = op2.getOp();
                                values.add(av);
                                tmp[local._ls_index] = av;
                            } else if (op2.vt == Value.VT.FILLED_ARRAY) {
                                ArrayValue av = new ArrayValue();
                                av.s = ArrayValue.S.DEFAULT;
                                av.indexType = ArrayValue.IndexType.CONST;
                                av.stmt = stmt;
                                FilledArrayExpr fae = (FilledArrayExpr) stmt.getOp2();
                                av.size = Exprs.nInt(fae.getOps().length);
                                Value[] ops = fae.getOps();
                                for (int i = 0; i < ops.length; i++) {
                                    av.elements1.put(i, ops[i]);
                                }
                                values.add(av);
                                tmp[local._ls_index] = av;
                            } else if (op2.vt == Value.VT.CONSTANT) {
                                Object cst = ((Constant) op2).value;
                                if (cst != null && !cst.equals(Constant.Null) && cst.getClass().isArray()) {
                                    ArrayValue av = new ArrayValue();
                                    av.s = ArrayValue.S.DEFAULT;
                                    av.indexType = ArrayValue.IndexType.CONST;
                                    av.stmt = stmt;
                                    int size = Array.getLength(cst);
                                    av.size = Exprs.nInt(size);
                                    for (int i = 0; i < size; i++) {
                                        av.elements1.put(i, Exprs.nConstant(Array.get(cst, size)));
                                    }
                                    values.add(av);
                                    tmp[local._ls_index] = av;
                                } else {
                                    ArrayValue av = new ArrayValue();
                                    values.add(av);
                                    av.s = ArrayValue.S.UNKNOWN;
                                    av.indexType = ArrayValue.IndexType.NONE;
                                    av.stmt = stmt;
                                    tmp[local._ls_index] = av;
                                }
                            } else {
                                ArrayValue av = new ArrayValue();
                                values.add(av);
                                av.s = ArrayValue.S.UNKNOWN;
                                av.indexType = ArrayValue.IndexType.NONE;
                                av.stmt = stmt;
                                tmp[local._ls_index] = av;
                            }
                        }
                        // assign index1
                    } else if (stmt.getOp1().vt == Value.VT.ARRAY) {
                        use(stmt.getOp2());
                        ArrayExpr ae = (ArrayExpr) stmt.getOp1();
                        if (ae.getOp1().vt == Value.VT.LOCAL) {
                            Local local = (Local) ae.getOp1();
                            Value index = ae.getOp2();
                            if (local._ls_index >= 0) {
                                if (index.vt == Value.VT.CONSTANT) {
                                    ArrayValue parent = tmp[local._ls_index];
                                    ArrayValue av = new ArrayValue();
                                    values.add(av);
                                    av.parent = parent;
                                    av.elements1.put(((Number) (((Constant) index).value)).intValue(), stmt.getOp2());
                                    av.indexType = ArrayValue.IndexType.CONST;
                                    av.s = ArrayValue.S.INHERIT;
                                    av.stmt = stmt;
                                    tmp[local._ls_index] = av;
                                } else if (index.vt == Value.VT.LOCAL) {
                                    ArrayValue parent = tmp[local._ls_index];
                                    ArrayValue av = new ArrayValue();
                                    values.add(av);
                                    av.parent = parent;
                                    av.elements1.put(index, stmt.getOp2());
                                    av.indexType = ArrayValue.IndexType.LOCAL;
                                    av.s = ArrayValue.S.INHERIT;
                                    av.stmt = stmt;
                                    tmp[local._ls_index] = av;
                                } else {
                                    ArrayValue av = new ArrayValue();
                                    values.add(av);
                                    av.s = ArrayValue.S.UNKNOWN;
                                    av.indexType = ArrayValue.IndexType.NONE;
                                    av.stmt = stmt;
                                    tmp[local._ls_index] = av;
                                }
                            } else {
                                use(stmt.getOp1());
                            }
                        } else {
                            use(stmt.getOp1());
                        }

                    } else {
                        use(stmt.getOp1());
                        use(stmt.getOp2());
                    }
                    // assign index2
                } else if (stmt.st == Stmt.ST.FILL_ARRAY_DATA) {
                    if (stmt.getOp1().vt == Value.VT.LOCAL) {
                        Local local = (Local) stmt.getOp1();
                        if (local._ls_index >= 0) {
                            Object array = ((Constant) stmt.getOp2()).value;
                            ArrayValue parent = tmp[local._ls_index];
                            ArrayValue av = new ArrayValue();
                            values.add(av);
                            av.parent = parent;
                            int size = Array.getLength(array);
                            av.size = Exprs.nInt(size);
                            for (int i = 0; i < size; i++) {
                                av.elements1.put(i, Exprs.nConstant(Array.get(array, i)));
                            }
                            av.indexType = ArrayValue.IndexType.CONST;
                            av.s = ArrayValue.S.INHERIT;
                            av.stmt = stmt;
                            tmp[local._ls_index] = av;
                        }
                    } else {
                        use(stmt.getOp1());
                    }
                } else {
                    switch (stmt.et) {
                        case E0:
                            break;
                        case E1:
                            use(stmt.getOp());
                            break;
                        case E2:
                            use(stmt.getOp1());
                            use(stmt.getOp2());
                            break;
                        case En:
                            throw new RuntimeException();
                    }
                }

                return tmp;
            }

            private void use(Value v) {
                switch (v.et) {
                    case E0:
                        break;
                    case E1:
                        use(v.getOp());
                        break;
                    case E2:
                        Value op1 = v.getOp1();
                        Value op2 = v.getOp2();
                        use(op1);
                        use(op2);
                        if (v.vt == Value.VT.ARRAY) {
                            if (op1.vt == Value.VT.LOCAL && (op2.vt == Value.VT.LOCAL || op2.vt == Value.VT.CONSTANT)) {
                                Local local = (Local) op1;
                                if (local._ls_index > 0) {
                                    used.add(currentStmt);
                                }
                            }
                        }
                        break;
                    case En:
                        for (Value op : v.getOps()) {
                            use(op);
                        }
                        break;
                }
            }
        });


        // TODO travel stmt to find must-be array element

        for (Stmt p : method.stmts) {

        }
        new StmtTraveler() {
            @Override
            public Value travel(Value op) {
                op = super.travel(op);
                if (op.vt == Value.VT.ARRAY) {

                }
                return op;
            }
        }.travel(method.stmts);

        return false;
    }",loop_control
op,"for (Value op : v.getOps()) {
                            use(op);
                        }",iterator
op,"{
            @Override
            public Value travel(Value op) {
                op = super.travel(op);
                if (op.vt == Value.VT.ARRAY) {

                }
                return op;
            }
        }",iterator
stmt,"for (Stmt stmt : method.stmts) {
            if (stmt.st == Stmt.ST.ASSIGN) {
                // create an array
                if (stmt.getOp1().vt == Value.VT.LOCAL) {
                    Local local = (Local) stmt.getOp1();
                    if (stmt.getOp2().vt == Value.VT.NEW_ARRAY || stmt.getOp2().vt == Value.VT.FILLED_ARRAY) {
                        arrays.add(local);
                    }
                    // assign index1
                } else if (stmt.getOp1().vt == Value.VT.ARRAY) {
                    ArrayExpr ae = (ArrayExpr) stmt.getOp1();
                    if (ae.getOp1().vt == Value.VT.LOCAL) {
                        Local local = (Local) ae.getOp1();
                        arrays.add(local);
                    }

                }
                // assign index2
            } else if (stmt.st == Stmt.ST.FILL_ARRAY_DATA) {
                if (stmt.getOp1().vt == Value.VT.LOCAL) {
                    Local local = (Local) stmt.getOp1();
                    arrays.add(local);
                }
            }
        }",iterator
sv,"for (SimpleLiveValue sv : aValues) {
            if (sv.used) {
                q.add(sv);
                while (!q.isEmpty()) {
                    SimpleLiveValue v = q.poll();
                    if (v.used) {
                        if (used.contains(v)) {
                            continue;
                        }
                        used.add(v);
                        {
                            SimpleLiveValue p = v.parent;
                            if (p != null) {
                                if (!p.used) {
                                    p.used = true;
                                    q.add(p);
                                }
                            }
                        }
                        if (v.otherParents != null) {
                            for (SimpleLiveValue p : v.otherParents) {
                                if (!p.used) {
                                    p.used = true;
                                    q.add(p);
                                }
                            }
                            v.otherParents = null;
                        }
                    }
                }
            }
        }",iterator
q,"{
        Set<SimpleLiveValue> used = new HashSet<SimpleLiveValue>(aValues.size() / 2);
        Queue<SimpleLiveValue> q = new UniqueQueue<>();
        for (SimpleLiveValue sv : aValues) {
            if (sv.used) {
                q.add(sv);
                while (!q.isEmpty()) {
                    SimpleLiveValue v = q.poll();
                    if (v.used) {
                        if (used.contains(v)) {
                            continue;
                        }
                        used.add(v);
                        {
                            SimpleLiveValue p = v.parent;
                            if (p != null) {
                                if (!p.used) {
                                    p.used = true;
                                    q.add(p);
                                }
                            }
                        }
                        if (v.otherParents != null) {
                            for (SimpleLiveValue p : v.otherParents) {
                                if (!p.used) {
                                    p.used = true;
                                    q.add(p);
                                }
                            }
                            v.otherParents = null;
                        }
                    }
                }
            }
        }

        return used;
    }",maybe_loop_control
p,"{
                            SimpleLiveValue p = v.parent;
                            if (p != null) {
                                if (!p.used) {
                                    p.used = true;
                                    q.add(p);
                                }
                            }
                        }",iterator
p,"for (SimpleLiveValue p : v.otherParents) {
                                if (!p.used) {
                                    p.used = true;
                                    q.add(p);
                                }
                            }",iterator
i,"for (int i = 0; i < srcFrame.length; i++) {
                SimpleLiveValue sV = srcFrame[i];
                if (sV != null) {
                    SimpleLiveValue dV = new SimpleLiveValue();
                    aValues.add(dV);
                    dV.parent = sV;
                    distFrame[i] = dV;
                }
            }",loop_control
i,"for (int i = 0; i < srcFrame.length; i++) {
                SimpleLiveValue sV = srcFrame[i];
                SimpleLiveValue dV = distFrame[i];
                if (sV != null && dV != null) {
                    List<SimpleLiveValue> ps = dV.otherParents;
                    if (ps == null) {
                        dV.otherParents = ps = new ArrayList<>(3);
                    }
                    ps.add(sV);
                }
            }",loop_control
local,"for (Local local : method.locals) {
                if (local._ls_index > maxReg) {
                    maxReg = local._ls_index;
                }
            }",iterator
local,"for (Local local : method.locals) {
                local._ls_index = index;
                index++;
            }",iterator
s,"for (Stmt s : method.stmts) {
                if (s.st == Stmt.ST.LABEL) {
                    LabelStmt label = (LabelStmt) s;
                    label.displayName = ""L"" + idx++;
                }
            }",iterator
stmt,"for (Stmt stmt = method.stmts.getFirst(); stmt != null; stmt = stmt.getNext()) {
            T[] frame = (T[]) stmt.frame;
            if (frame != null) {
                for (T p : frame) {
                    if (p == null) {
                        sb.append('.');
                    } else {
                        sb.append(p.toRsp());
                    }
                }
                sb.append("" | "");
            }
            sb.append(stmt.toString()).append('\n');
        }",maybe_loop_control
p,"for (T p : frame) {
                    if (p == null) {
                        sb.append('.');
                    } else {
                        sb.append(p.toRsp());
                    }
                }",iterator
i,"for (int i = 0; i < v.length; i++) {
            vb[i] = v[i].trim();
        }",loop_control
i,"for (int i = 0; i < ops.length; i++) {
            sb.append(ops[i]).append("", "");
        }",loop_control
i,"{
        StringBuilder sb = new StringBuilder();
        int i = 0;
        sb.append(ops[i++]).append('.').append(this.method.getName());
        String[] argTypes = getProto().getParameterTypes();
        sb.append('(');
        int j = 0;
        boolean first = true;
        for (; i < ops.length; i++) {
            if (first) {
                first = false;
            } else {
                sb.append(',');
            }
            sb.append(""("").append(Util.toShortClassName(argTypes[j++])).append("")"").append(ops[i]);
        }
        sb.append(')');

        return sb.toString();
    }",loop_control
i,"{
        StringBuilder sb = new StringBuilder();

        int i = 0;
        if (super.vt == VT.INVOKE_NEW) {
            sb.append(""new "").append(Util.toShortClassName(method.getOwner()));
        } else if (super.vt == VT.INVOKE_STATIC) {
            sb.append(Util.toShortClassName(method.getOwner())).append('.')
                    .append(this.method.getName());
        } else {
            sb.append(ops[i++]).append('.').append(this.method.getName());
        }
        sb.append('(');
        boolean first = true;
        for (; i < ops.length; i++) {
            if (first) {
                first = false;
            } else {
                sb.append(',');
            }
            sb.append(ops[i]);
        }
        sb.append(')');
        return sb.toString();
    }",loop_control
i,"for (int i = 0; i < nOps.length; i++) {
                nOps[i] = ops[i].trim().clone();
            }",loop_control
i,"for (int i = 0; i < nOps.length; i++) {
                nOps[i] = ops[i].clone(mapper);
            }",loop_control
a,"{
        Value a = this;
        while (a.next != null) {
            Value b = a.next;
            a.next = b;
            a = b;
        }
        return a;
    }",maybe_loop_control
dimension,"{
                int dimension = 1;
                while (type.charAt(dimension) == '[') {
                    dimension++;
                }
                StringBuilder sb = new StringBuilder(""new "")
                        .append(Util.toShortClassName(type.substring(dimension))).append(""["").append(op)
                        .append(""]"");
                for (int i = 0; i < dimension; i++) {
                    sb.append(""[]"");
                }
                return sb.toString();
            }",loop_control
i,"for (int i = 0; i < dimension; i++) {
                    sb.append(""[]"");
                }",loop_control
i,"for (int i = 0; i < size; i++) {
                sb.append(Array.get(value, i)).append("","");
            }",loop_control
vb,"for (Value vb : ops) {
            if (first) {
                first = false;
            } else {
                sb.append("", "");
            }
            sb.append(vb);
        }",iterator
op,"for (Value op : ops) {
            sb.append('[').append(op).append(']');
        }",iterator
i,"for (int i = ops.length; i < dimension; i++) {
            sb.append(""[]"");
        }",loop_control
stmt,"for (Stmt stmt : list) {
            insertLast(stmt);
        }",iterator
stmt,"for (Stmt stmt : this) {
            nList.add(stmt.clone(mapper));
        }",iterator
s,"for (Stmt s : this) {
            if (s.st == ST.LABEL) {
                sb.append(""\n"");
            }
            sb.append(s).append(""\n"");
        }",iterator
i,"for (int i = 0; i < nTargets.length; i++) {
            nTargets[i] = mapper.map(targets[i]);
        }",loop_control
i,"for (int i = 0; i < targets.length; i++) {
            sb.append(""\n case "").append(lowIndex + i).append("": GOTO "").append(targets[i].getDisplayName())
                    .append("";"");
        }",loop_control
i,"for (int i = 0; i < nTargets.length; i++) {
            nTargets[i] = mapper.map(targets[i]);
        }",loop_control
i,"for (int i = 0; i < lookupValues.length; i++) {
            sb.append(""\n case "").append(lookupValues[i]).append("": GOTO "").append(targets[i].getDisplayName())
                    .append("";"");
        }",loop_control
phi,"for (AssignStmt phi : phis) {
                labelStmt.phis.add((AssignStmt) phi.clone(mapper));
            }",iterator
v,"for (Object v : (Object[]) value) {
                    s.visit(null, v);
                }",iterator
s,"for (String s : owner.getParameterTypes()) {
            switch (s.charAt(0)) {
            case 'J':
            case 'D':
                in_reg_size += 2;
                break;
            default:
                in_reg_size++;
                break;
            }
        }",iterator
s,"for (short s : data) {
                b.putShort(s);
            }",iterator
s,"for (int s : data) {
                b.putInt(s);
            }",iterator
s,"for (float s : data) {
                b.putInt(Float.floatToIntBits(s));
            }",iterator
s,"for (long s : data) {
                b.putLong(s);
            }",iterator
s,"for (double s : data) {
                b.putLong(Double.doubleToLongBits(s));
            }",iterator
i,"for (int i = 0; i < labels.length; i++) {
                    out.putInt(getLabel(labels[i]).offset - jumpOp.offset);
                }",loop_control
i,"for (int i = 0; i < cases.length; i++) {
                    out.putInt(cases[i]);
                }",loop_control
i,"for (int i = 0; i < cases.length; i++) {
                    out.putInt(getLabel(labels[i]).offset - jumpOp.offset);
                }",loop_control
i,"for (int i = 0; i < types.length; i++) {
            String type = types[i];
            Label label = getLabel(handlers[i]);
            if (type == null) {
                ech.catchAll = label;
            } else {
                ech.addPairs.add(new CodeItem.EncodedCatchHandler.AddrPair(cp.uniqType(type), label));
            }
        }",loop_control
i,"for (int i = 1; i < args.length; i++) {
                    if (start + i != args[i]) {
                        throw new CantNotFixContentException(op, ""a"", args[i]);
                    }
                }",loop_control
i,"for (int i = 0; i < indent; i++) {
                        sb.append(""  "");
                    }",loop_control
i,"for (int i = 0; i < size; i++) {
                                sb.append(String.format(""%02x"",
                                        data[start + i] & 0xff));
                                if (i != size - 1) {
                                    sb.append("", "");
                                }
                            }",loop_control
arg,"for (Object arg : args) {
                        if (arg instanceof byte[]) {
                            byte[] data = (byte[]) arg;
                            sb.append(""0x["");
                            int start = 0;
                            int size = data.length;
                            if (args.length > 2) {
                                start = (Integer) args[2];
                                size = (Integer) args[3];
                            }
                            for (int i = 0; i < size; i++) {
                                sb.append(String.format(""%02x"",
                                        data[start + i] & 0xff));
                                if (i != size - 1) {
                                    sb.append("", "");
                                }
                            }

                            sb.append(""], "");
                        } else {
                            sb.append(arg).append("", "");
                        }

                    }",iterator
i,"for (int i = 0; i < list.size(); i++) {
            SectionItem<?> section = list.get(i);
            list.set(i, null);
            BaseItem.addPadding(out, out.offset(),
                    section.sectionType.alignment);
            if (out.offset() != section.offset) {
                throw new RuntimeException(section.sectionType
                        + "" start with different position, planned:""
                        + section.offset + "", but is:"" + out.offset());
            }
            section.write(out);
        }",loop_control
section,"for (SectionItem<?> section : mapItem.items) {

            offset = BaseItem.padding(offset, section.sectionType.alignment);
            section.offset = offset;
            // section.index = index;
            // index++;
            offset = section.place(offset);
        }",iterator
ae,"for (AnnotationElement ae : elements) {
            offset += BaseItem.lengthOfUleb128(ae.name.index);
            offset = ae.value.place(offset);
        }",iterator
ae,"for (AnnotationElement ae : elements) {
            out.uleb128(""name_idx"", ae.name.index);
            ae.value.write(out);
        }",iterator
i,"for (int i = 0; i < requiredBytes; i++) {
            s[i] = ((byte) value);
            value >>= 8;
        }",loop_control
ev,"for (EncodedValue ev : values) {
            offset = ev.place(offset);
        }",iterator
ev,"for (EncodedValue ev : values) {
            ev.write(out);
        }",iterator
remaining,"{
        int remaining = value >>> 7;

        while (remaining != 0) {
            buffer.put((byte) ((value & 0x7f) | 0x80));
            value = remaining;
            remaining >>>= 7;
        }

        buffer.put((byte) (value & 0x7f));
    }",loop_control
hasMore,"{
        int remaining = value >> 7;
        boolean hasMore = true;
        int end = ((value & Integer.MIN_VALUE) == 0) ? 0 : -1;

        while (hasMore) {
            hasMore = (remaining != end)
                    || ((remaining & 1) != ((value >> 6) & 1));

            buffer.put((byte) ((value & 0x7f) | (hasMore ? 0x80 : 0)));
            value = remaining;
            remaining >>= 7;
        }

    }",maybe_loop_control
s,"for (String s : types2) {
            if (s.length() == 1) {
                sb.append(s);
            } else {
                sb.append(""L"");
            }
        }",iterator
c,"for (ClassDefItem c : classDefs.values()) {
            if (added.contains(c)) {
                continue;
            }
            children.add(c);
            stack1.push(iterateParent(c));

            while (!stack1.empty()) {
                PE e = stack1.peek();
                boolean canPop = true;
                while (e.it.hasNext()) {
                    TypeIdItem tid = e.it.next();
                    if (tid == null) {
                        continue;
                    }
                    ClassDefItem superDef = classDefs.get(tid);
                    if (superDef != null && !added.contains(superDef)) {
                        if (children.contains(superDef)) {
                            System.err.println(""WARN: dep-loop "" + e.owner.clazz.descriptor.stringData.string + "" -> ""
                                    + superDef.clazz.descriptor.stringData.string);
                        } else {
                            canPop = false;
                            children.add(superDef);
                            stack1.push(iterateParent(superDef));
                            break;
                        }
                    }
                }
                if (canPop) {
                    stack1.pop();
                    added.add(e.owner);
                    children.remove(e.owner);
                }
            }
            children.clear();
        }",iterator
stack1,"{
        List<ClassDefItem> added = new ArrayList<>();
        Stack<PE> stack1 = new Stack<>();
        Set<ClassDefItem> children = new HashSet<>();

        for (ClassDefItem c : classDefs.values()) {
            if (added.contains(c)) {
                continue;
            }
            children.add(c);
            stack1.push(iterateParent(c));

            while (!stack1.empty()) {
                PE e = stack1.peek();
                boolean canPop = true;
                while (e.it.hasNext()) {
                    TypeIdItem tid = e.it.next();
                    if (tid == null) {
                        continue;
                    }
                    ClassDefItem superDef = classDefs.get(tid);
                    if (superDef != null && !added.contains(superDef)) {
                        if (children.contains(superDef)) {
                            System.err.println(""WARN: dep-loop "" + e.owner.clazz.descriptor.stringData.string + "" -> ""
                                    + superDef.clazz.descriptor.stringData.string);
                        } else {
                            canPop = false;
                            children.add(superDef);
                            stack1.push(iterateParent(superDef));
                            break;
                        }
                    }
                }
                if (canPop) {
                    stack1.pop();
                    added.add(e.owner);
                    children.remove(e.owner);
                }
            }
            children.clear();
        }
        return added;
    }",maybe_loop_control
e,"{
                PE e = stack1.peek();
                boolean canPop = true;
                while (e.it.hasNext()) {
                    TypeIdItem tid = e.it.next();
                    if (tid == null) {
                        continue;
                    }
                    ClassDefItem superDef = classDefs.get(tid);
                    if (superDef != null && !added.contains(superDef)) {
                        if (children.contains(superDef)) {
                            System.err.println(""WARN: dep-loop "" + e.owner.clazz.descriptor.stringData.string + "" -> ""
                                    + superDef.clazz.descriptor.stringData.string);
                        } else {
                            canPop = false;
                            children.add(superDef);
                            stack1.push(iterateParent(superDef));
                            break;
                        }
                    }
                }
                if (canPop) {
                    stack1.pop();
                    added.add(e.owner);
                    children.remove(e.owner);
                }
            }",maybe_loop_control
s,"for (String s : subList) {
            idItems.add(uniqType(s));
        }",iterator
s,"for (String s : subList) {
            idItems.add(uniqType(s));
        }",iterator
annotationItem,"for (AnnotationItem annotationItem : copy) {
            key.annotations.add(uniqAnnotationItem(annotationItem));
        }",iterator
i,"for (int i = 0; i < key.annotationSets.length; i++) {
            AnnotationSetItem anno = key.annotationSets[i];
            if (anno != null) {
                key.annotationSets[i] = uniqAnnotationSetItem(anno);
            }
        }",loop_control
item,"for (AnnotationSetItem item : annotationSets) {
            out.uint(""annotations_off"", item == null ? 0 : item.offset);
        }",iterator
s,"for (StringIdItem s : parameterNames) {
                offset += lengthOfUleb128(1 + (s == null ? -1 : s.index));
            }",iterator
opNode,"for (DNode opNode : debugNodes) {
            switch (opNode.op) {
            case DBG_START_LOCAL_EXTENDED:
                offset += lengthOfUleb128(opNode.sig.index + 1);
                // through;
            case DBG_START_LOCAL: {
                int pcData = opNode.label.offset - addr;
                if (pcData < 0) {
                    throw new RuntimeException();
                } else if (pcData > 0) {
                    // add an addvance_PC
                    offset += 1;
                    offset += lengthOfUleb128(pcData);
                }
                addr = opNode.label.offset;
            }
                offset += 1;// op;
                offset += lengthOfUleb128(opNode.reg);
                offset += lengthOfUleb128(opNode.name.index + 1);
                offset += lengthOfUleb128(opNode.type.index + 1);
                break;
            case DBG_RESTART_LOCAL:
            case DBG_END_LOCAL: {
                int pcData = opNode.label.offset - addr;
                if (pcData < 0) {
                    throw new RuntimeException();
                } else if (pcData > 0) {
                    // add an addvance_PC
                    offset += 1;
                    offset += lengthOfUleb128(pcData);
                }
                addr = opNode.label.offset;
            }
                offset += 1;// op;
                offset += lengthOfUleb128(opNode.reg);
                break;
            case DBG_SET_EPILOGUE_BEGIN:
            case DBG_SET_PROLOGUE_END:
                offset += 1;
                break;
            case DBG_SET_FILE:
                throw new RuntimeException();
            default:
                int lineDelta = opNode.line - line;
                int addrDelta = opNode.label.offset - addr;
                if (addrDelta < 0) {
                    throw new RuntimeException();
                }
                if (opNode.label.offset == 0 && lineDelta == 0 && addrDelta == 0) { // first line;
                    break;
                }
                if ((lineDelta >= -4 && lineDelta <= 10) && addrDelta <= 15) {
                    // do nothing
                } else {
                    if (addrDelta > 15) { // pc not ok, add addvance_PC
                        offset += 1;
                        offset += lengthOfUleb128(addrDelta);
                        addrDelta = 0;
                    }
                    if (lineDelta < -4 || lineDelta > 10) { // line not ok, add DBG_ADVANCE_LINE
                        offset += 1;
                        offset += lengthOfSleb128(lineDelta);
                        lineDelta = 0;
                    }
                }
                // int op = lineDelta + 4 + addrDelta * DBG_LINE_RANGE + DBG_FIRST_SPECIAL;
                offset += 1;
                line = opNode.line;
                addr = opNode.label.offset;
                break;
            }

        }",iterator
opNode,"for (DNode opNode : debugNodes) {
            switch (opNode.op) {
            case DBG_START_LOCAL_EXTENDED: {
                int pcDelta = opNode.label.offset - addr;
                if (pcDelta < 0) {
                    throw new RuntimeException();
                } else if (pcDelta > 0) {
                    addAdvancePC(out, pcDelta);
                }
                addr = opNode.label.offset;
            }
                out.sbyte(""DBG_START_LOCAL_EXTENDED"", DBG_START_LOCAL_EXTENDED);
                out.uleb128(""reg"", opNode.reg);
                out.uleb128p1(""name"", opNode.name.index);
                out.uleb128p1(""type"", opNode.type.index);
                out.uleb128p1(""sig"", opNode.sig.index);
                break;
            case DBG_START_LOCAL: {
                int pcDelta = opNode.label.offset - addr;
                if (pcDelta < 0) {
                    throw new RuntimeException();
                } else if (pcDelta > 0) {
                    addAdvancePC(out, pcDelta);
                }
                addr = opNode.label.offset;
            }
                out.sbyte(""DBG_START_LOCAL"", DBG_START_LOCAL);
                out.uleb128(""reg"", opNode.reg);
                out.uleb128p1(""name"", opNode.name.index);
                out.uleb128p1(""type"", opNode.type.index);

                break;
            case DBG_RESTART_LOCAL: {
                int pcDelta = opNode.label.offset - addr;
                if (pcDelta < 0) {
                    throw new RuntimeException();
                } else if (pcDelta > 0) {
                    addAdvancePC(out, pcDelta);
                }
                addr = opNode.label.offset;
            }

                out.sbyte(""DBG_RESTART_LOCAL"", DBG_RESTART_LOCAL);
                out.uleb128(""reg"", opNode.reg);
                break;
            case DBG_END_LOCAL: {
                int pcDelta = opNode.label.offset - addr;
                if (pcDelta < 0) {
                    throw new RuntimeException();
                } else if (pcDelta > 0) {
                    addAdvancePC(out, pcDelta);
                }
                addr = opNode.label.offset;
            }

                out.sbyte(""DBG_END_LOCAL"", DBG_END_LOCAL);
                out.uleb128(""reg"", opNode.reg);
                break;
            case DBG_SET_EPILOGUE_BEGIN:
                out.sbyte(""DBG_SET_EPILOGUE_BEGIN"", DBG_SET_EPILOGUE_BEGIN);
                break;
            case DBG_SET_PROLOGUE_END:
                out.sbyte(""DBG_SET_PROLOGUE_END"", DBG_SET_PROLOGUE_END);
                break;
            case DBG_SET_FILE:
                throw new RuntimeException();
            default:
                int lineDelta = opNode.line - line;
                int addrDelta = opNode.label.offset - addr;
                if (addrDelta < 0) {
                    throw new RuntimeException();
                }
                if (opNode.label.offset == 0 && lineDelta == 0 && addrDelta == 0) { // first line;
                    break;
                }
                if ((lineDelta >= -4 && lineDelta <= 10) && addrDelta <= 15) {
                    // do nothing
                } else {
                    if (addrDelta > 15) { // pc not ok, add addvance_PC
                        addAdvancePC(out, addrDelta);
                        addrDelta = 0;
                    }
                    if (lineDelta < -4 || lineDelta > 10) { // line not ok, add DBG_ADVANCE_LINE
                        addAdvanceLine(out, lineDelta);
                        lineDelta = 0;
                    }
                }
                int op = lineDelta + 4 + addrDelta * DBG_LINE_RANGE + DBG_FIRST_SPECIAL;
                out.sbyte(""DEBUG_OP_X"", op);
                line = opNode.line;
                addr = opNode.label.offset;
                break;
            }
        }",iterator
item,"for (AnnotationItem item : annotations) {
            out.uint(""annotation_off"", item.offset);
        }",iterator
h,"for (EncodedCatchHandler h : handlers) {
                    h.handler_off = offset - base;
                    int size = h.addPairs.size();
                    offset += lengthOfSleb128(h.catchAll != null ? -size : size);
                    for (AddrPair ap : h.addPairs) {
                        offset += lengthOfUleb128(ap.type.index) + lengthOfUleb128(ap.addr.offset);
                    }
                    if (h.catchAll != null) {
                        offset += lengthOfUleb128(h.catchAll.offset);
                    }
                }",iterator
ap,"for (AddrPair ap : h.addPairs) {
                        offset += lengthOfUleb128(ap.type.index) + lengthOfUleb128(ap.addr.offset);
                    }",iterator
insn,"{
        out.ushort(""registers_size"", registersSize);
        out.ushort(""ins_size"", insSize);
        out.ushort(""outs_size"", outsSize);
        out.ushort(""tries_size"", tries == null ? 0 : tries.size());
        out.uint(""debug_info_off"", debugInfo == null ? 0 : debugInfo.offset);
        out.uint(""insn_size"", insn_size);
        ByteBuffer b = ByteBuffer.allocate(insn_size * 2).order(ByteOrder.LITTLE_ENDIAN);
        for (Insn insn : insns) {
            insn.write(b);
        }
        out.bytes(""insn"", b.array());
        if (tries != null && tries.size() > 0) {
            if ((insn_size & 0x01) != 0) {// padding
                out.skip(""padding"", 2);
            }
            int lastEnd = 0;
            for (TryItem ti : tries) {
                if (ti.start.offset < lastEnd) {
                    System.err.println(""'Out-of-order try' may throwed by libdex"");
                }
                out.uint(""start_addr"", ti.start.offset);
                out.ushort(""insn_count"", ti.end.offset - ti.start.offset);
                lastEnd = ti.end.offset;
                out.ushort(""handler_off"", ti.handler.handler_off);
            }
            if (handlers.size() > 0) {
                out.uleb128(""size"", handlers.size());
                for (EncodedCatchHandler h : handlers) {

                    int size = h.addPairs.size();
                    out.sleb128(""size"", (h.catchAll != null ? -size : size));
                    for (AddrPair ap : h.addPairs) {
                        out.uleb128(""type_idx"", (ap.type.index));
                        out.uleb128(""addr"", (ap.addr.offset));
                    }
                    if (h.catchAll != null) {
                        out.uleb128(""catch_all_addr"", (h.catchAll.offset));
                    }
                }
            }
        }
    }",iterator
ti,"for (TryItem ti : tries) {
                if (ti.start.offset < lastEnd) {
                    System.err.println(""'Out-of-order try' may throwed by libdex"");
                }
                out.uint(""start_addr"", ti.start.offset);
                out.ushort(""insn_count"", ti.end.offset - ti.start.offset);
                lastEnd = ti.end.offset;
                out.ushort(""handler_off"", ti.handler.handler_off);
            }",iterator
h,"for (EncodedCatchHandler h : handlers) {

                    int size = h.addPairs.size();
                    out.sleb128(""size"", (h.catchAll != null ? -size : size));
                    for (AddrPair ap : h.addPairs) {
                        out.uleb128(""type_idx"", (ap.type.index));
                        out.uleb128(""addr"", (ap.addr.offset));
                    }
                    if (h.catchAll != null) {
                        out.uleb128(""catch_all_addr"", (h.catchAll.offset));
                    }
                }",iterator
ap,"for (AddrPair ap : h.addPairs) {
                        out.uleb128(""type_idx"", (ap.type.index));
                        out.uleb128(""addr"", (ap.addr.offset));
                    }",iterator
tryItem,"for (CodeItem.TryItem tryItem : _tryItems) {
                    if (!set.contains(tryItem)) {
                        uniqTrys.add(tryItem);
                        set.add(tryItem);
                    } else {
                        for (TryItem t : uniqTrys) {
                            if (t.equals(tryItem)) {
                                mergeExceptionHandler(t.handler, tryItem.handler);
                            }
                        }
                    }
                }",iterator
tryItem,"for (CodeItem.TryItem tryItem : uniqTrys) {
                    CodeItem.EncodedCatchHandler d = tryItem.handler;
                    CodeItem.EncodedCatchHandler uH = map.get(d);
                    if (uH != null) {
                        tryItem.handler = uH;
                    } else {
                        uniqHanders.add(d);
                        map.put(d, d);
                    }
                }",iterator
t,"for (TryItem t : uniqTrys) {
                            if (t.equals(tryItem)) {
                                mergeExceptionHandler(t.handler, tryItem.handler);
                            }
                        }",iterator
pair,"for (AddrPair pair : from.addPairs) {
            if (!to.addPairs.contains(pair)) {
                to.addPairs.add(pair);
            }
        }",iterator
insn,"for (Insn insn : _ops) {
            if (insn instanceof CodeWriter.IndexedInsn) {
                ((CodeWriter.IndexedInsn) insn).fit();
            } else  if(insn instanceof JumpOp){
                jumpOps.add((JumpOp)insn);
            }
        }",iterator
insn,"for (Insn insn : _ops) {
                insn.offset = codeSize;
                codeSize += insn.getCodeUnitSize();
            }",iterator
insn,"for (Insn insn : _tailOps) {
            if ((codeSize & 1) != 0) { // not 32bit alignment
                Insn nop = new PreBuildInsn(new byte[] { (byte) Op.NOP.opcode, 0 }); // f10x
                insn.offset = codeSize;
                codeSize += nop.getCodeUnitSize();
                _ops.add(nop);
            }
            insn.offset = codeSize;
            codeSize += insn.getCodeUnitSize();
            _ops.add(insn);
        }",iterator
insn,"{
        List<JumpOp> jumpOps=new ArrayList<>();
        for (Insn insn : _ops) {
            if (insn instanceof CodeWriter.IndexedInsn) {
                ((CodeWriter.IndexedInsn) insn).fit();
            } else  if(insn instanceof JumpOp){
                jumpOps.add((JumpOp)insn);
            }
        }

        int codeSize = 0;
        while (true) {
            for (Insn insn : _ops) {
                insn.offset = codeSize;
                codeSize += insn.getCodeUnitSize();
            }
            boolean allfit = true;
            for (JumpOp jop : jumpOps) {
                if (!jop.fit()) {
                    allfit = false;
                }
            }
            if (allfit) {
                break;
            }
            codeSize = 0;
        }
        for (Insn insn : _tailOps) {
            if ((codeSize & 1) != 0) { // not 32bit alignment
                Insn nop = new PreBuildInsn(new byte[] { (byte) Op.NOP.opcode, 0 }); // f10x
                insn.offset = codeSize;
                codeSize += nop.getCodeUnitSize();
                _ops.add(nop);
            }
            insn.offset = codeSize;
            codeSize += insn.getCodeUnitSize();
            _ops.add(insn);
        }
        _tailOps.clear();
        this.insns = _ops;
        this.insn_size = codeSize;
    }",iterator
jop,"for (JumpOp jop : jumpOps) {
                if (!jop.fit()) {
                    allfit = false;
                }
            }",iterator
i,"for (int i = 0; i < length; i++) {
            char ch = s.charAt(i);
            if (ch != 0 && ch <= 127) { // U+0000 uses two bytes.
                out.write(ch);
            } else if (ch <= 2047) {
                out.write((0xc0 | (0x1f & (ch >> 6))));
                out.write((0x80 | (0x3f & ch)));
            } else {
                out.write((0xe0 | (0x0f & (ch >> 12))));
                out.write((0x80 | (0x3f & (ch >> 6))));
                out.write((0x80 | (0x3f & ch)));
            }
        }",loop_control
i,"for (int i = 0; i < length; ++i) {
            char ch = s.charAt(i);
            if (ch != 0 && ch <= 127) { // U+0000 uses two bytes.
                ++result;
            } else if (ch <= 2047) {
                result += 2;
            } else {
                result += 3;
            }
        }",loop_control
fe,"for (Entry<FieldIdItem, AnnotationSetItem> fe : fieldAnnotations.entrySet()) {
                out.uint(""field_idx"", fe.getKey().index);
                out.uint(""annotations_off"", fe.getValue().offset);
            }",iterator
fe,"for (Entry<MethodIdItem, AnnotationSetItem> fe : methodAnnotations.entrySet()) {
                out.uint(""method_idx"", fe.getKey().index);
                out.uint(""annotations_off"", fe.getValue().offset);
            }",iterator
fe,"for (Entry<MethodIdItem, AnnotationSetRefListItem> fe : parameterAnnotations.entrySet()) {
                out.uint(""method_idx"", fe.getKey().index);
                out.uint(""annotations_off"", fe.getValue().offset);
            }",iterator
it,"for (Iterator<SectionItem<?>> it = items.iterator(); it.hasNext(); ) {
            SectionItem<?> i = it.next();
            if (i == null || i.items.size() < 1) {
                it.remove();
            }
        }",iterator
t,"for (SectionItem<?> t : items) {
            writeMapItem(out, t.sectionType.code, t.items.size(), t.offset);
        }",iterator
hasMore,"{
        int remaining = value >> 7;
        boolean hasMore = true;
        int end = ((value & Integer.MIN_VALUE) == 0) ? 0 : -1;
        int count = 0;
        while (hasMore) {
            hasMore = (remaining != end)
                    || ((remaining & 1) != ((value >> 6) & 1));
            count++;
            value = remaining;
            remaining >>= 7;
        }
        return count;
    }",maybe_loop_control
remaining,"{
        int remaining = value >>> 7;
        int length = 1;
        while (remaining != 0) {
            length++;
            remaining >>>= 7;
        }
        return length;
    }",loop_control
i,"for (int i = 0; i < fs.size(); i++) {
            EncodedField f = fs.get(i);
            EncodedValue ev = f.staticValue;
            if (ev != null) {
                if (!ev.isDefaultValueForType()) {
                    count = i;
                }
            }
        }",loop_control
i,"for (int i = 0; i <= count; i++) {
                EncodedField f = fs.get(i);
                EncodedValue ev = f.staticValue;
                if (ev == null) {
                    array.values.add(EncodedValue.defaultValueForType(f.field.getTypeString()));
                } else {
                    array.values.add(ev);
                }
            }",loop_control
m,"for (EncodedMethod m : ms) {
            if (m.annotationSetItem != null) {
                methodAnnotations.put(m.method, cp.uniqAnnotationSetItem(m.annotationSetItem));
            }
            if (m.parameterAnnotation != null) {
                parameterAnnotations.put(m.method, cp.uniqAnnotationSetRefListItem(m.parameterAnnotation));
            }
        }",iterator
f,"for (EncodedField f : fs) {
            if (f.annotationSetItem != null) {
                fieldAnnotations.put(f.field, cp.uniqAnnotationSetItem(f.annotationSetItem));
            }
        }",iterator
idItem,"for (TypeIdItem idItem : items) {
            out.ushort(""type_idx"", idItem.index);
        }",iterator
i,"for (int i = 0; i < min; i++) {
            int x = items.get(i).compareTo(o.items.get(i));
            if (x != 0) {
                return x;
            }
        }",loop_control
x,"for (int i = 0; i < min; i++) {
            int x = items.get(i).compareTo(o.items.get(i));
            if (x != 0) {
                return x;
            }
        }",break_loop_control
f,"for (Field f : SectionItem.class.getFields()) {
            if (f.getType().equals(int.class)) {
                if (0 != (f.getModifiers() & Modifier.STATIC)) {
                    System.out.printf(""%s(0x%04x,0,0),//\n"", f.getName(), f.get(null));
                }
            }
        }",iterator
t,"for (T t : items) {
            offset = padding(offset, sectionType.alignment);
            t.offset = offset;
            t.index = index;
            index++;
            offset = t.place(offset);
        }",iterator
i,"for (int i = 0; i < items.size(); i++) {
                T t = items.get(i);
                items.set(i, null);
                addPadding(out, sectionType.alignment);
                if (out.offset() != t.offset) {
                    throw new RuntimeException();
                }
                StringDataItem stringDataItem = (StringDataItem) t;
                stringDataItem.write(out, buff);
                buff.reset();
            }",loop_control
i,"for (int i = 0; i < items.size(); i++) {
                T t = items.get(i);
                items.set(i, null);
                addPadding(out, sectionType.alignment);
                if (out.offset() != t.offset) {
                    System.err.println(""Error for type:"" + this.sectionType + "", "" + t.index);
                    throw new RuntimeException();
                }
                t.write(out);
            }",loop_control
f,"for (EncodedMethod f : methods) {
            offset += lengthOfUleb128(f.method.index - lastIdx);
            offset += lengthOfUleb128(f.accessFlags);
            offset += lengthOfUleb128(f.code == null ? 0 : f.code.offset);
            lastIdx = f.method.index;
        }",iterator
f,"for (EncodedField f : fields) {
            offset += lengthOfUleb128(f.field.index - lastIdx);
            offset += lengthOfUleb128(f.accessFlags);

            lastIdx = f.field.index;
        }",iterator
f,"for (EncodedMethod f : methods) {
            out.uleb128(""method_idx_diff"", f.method.index - lastIdx);
            out.uleb128(""access_flags"", f.accessFlags);
            out.uleb128(""code_off"", f.code == null ? 0 : f.code.offset);
            lastIdx = f.method.index;
        }",iterator
f,"for (EncodedField f : fields) {
            out.uleb128(""field_idx_diff"", f.field.index - lastIdx);
            out.uleb128(""access_flags"", f.accessFlags);
            lastIdx = f.field.index;
        }",iterator
dcn,"for (DexClassNode dcn : dfn.clzs) {
            BufferedWriter w = new BufferedWriter(new OutputStreamWriter(System.out));
            new BaksmaliDumper(true, true).baksmaliClass(dcn, new BaksmaliDumpOut(w));
            w.flush();
        }",iterator
c,"for (DexClassNode c : dexFileNode.clzs) {
            map.put(c.className, c);
        }",iterator
f,"for (File f : fs) {
                if (f.getName().endsWith("".dex"") || f.getName().endsWith("".apk"")) {
                    System.out.println(f.getName());
                    dotest(f);
                }
            }",iterator
def,"for (DexBackedClassDef def : dex.getClasses()) {
            String type = def.getType();
            System.out.println(type);
            DexClassNode dexClassNode = map.get(type);
            Assert.assertNotNull(dexClassNode);
            String smali = baksmali(def); // original

            Smali.smaliFile2Node(""fake.smali"", smali);

            {
                byte[] data = toDex(dexClassNode);
                DexBackedClassDef def2 = new DexBackedDexFile(new Opcodes(14, false), data).getClasses().iterator().next();
                String baksmali3 = baksmali(def2); // original
                Assert.assertEquals(smali, baksmali3);
            }

            String psmali = pbaksmali(dexClassNode);
            DexClassNode dexClassNode2 = Smali.smaliFile2Node(""fake.smali"", psmali);
            Assert.assertEquals(""cmp smalip"", psmali, pbaksmali(dexClassNode2));

            {
                byte[] data = toDex(dexClassNode2);
                DexBackedClassDef def2 = new DexBackedDexFile(new Opcodes(14, false), data).getClasses().iterator().next();
                String baksmali3 = baksmali(def2); // original
                Assert.assertEquals(smali, baksmali3);
            }
        }",iterator
f,"for (File f : fs) {
                if (f.getName().endsWith("".dex"") || f.getName().endsWith("".apk"")) {
                    dotest(f.toPath());
                }
            }",iterator
i,"for (int i = 0; i < id.length(); ++i) {
            char c = id.charAt(i);
            escape1(sb, c);
        }",loop_control
i,"for (int i = 0; i < id.length(); ++i) {
            char c = id.charAt(i);
            if (c == '-') {
                sb.append(c);
            } else {
                escape1(sb, c);
            }
        }",loop_control
t,"for (String t : m.getParameterTypes()) {
            escapeType0(escapeBuff, t);
        }",iterator
ann,"for (DexAnnotationNode ann : anns) {
            dumpAnn(ann, out);
        }",iterator
i,"for (int i = 0; i < vs.length; i++) {
                Object v = vs[i];
                dumpItem(null, v, out, i != vs.length - 1);
            }",loop_control
item,"for (Item item : dexAnnotationNode.items) {
                dumpItem(item.name, item.value, out, false);
            }",iterator
item,"for (Item item : ann.items) {
            dumpItem(item.name, item.value, out, false);
        }",iterator
itf,"for (String itf : n.interfaceNames) {
                out.s("".implements %s"", escapeType(itf));
            }",iterator
f,"for (DexFieldNode f : n.fields) {
                out.s("""");
                buff.setLength(0);
                buff.append("".field "");
                appendAccess(f.access | ACCESS_FIELD, buff);
                Field field = f.field;
                buff.append(escapeId(f.field.getName())).append("":"").append(escapeType(field.getType()));
                if (f.cst != null) {
                    buff.append("" = "");
                    buff.append(escapeValue(f.cst));
                }
                out.s(buff.toString());

                if (f.anns != null) {
                    out.push();
                    dumpAnns(f.anns, out);
                    out.pop();
                    out.s("".end field"");
                }
            }",iterator
i,"for (int i = 0; i < m.parameterAnns.length; i++) {
                List<DexAnnotationNode> ps = m.parameterAnns[i];
                if (ps != null && ps.size() > 0) {
                    annoMax = i + 1;
                }
            }",loop_control
i,"for (int i = 0; i < max; i++) {
            String type = method.getParameterTypes()[i];
            String debugName = parameterNames == null ? null : i < parameterNames.size() ? parameterNames.get(i) : null;
            if (debugName != null) {
                out.s("".parameter \"""" + escapeId(debugName) + ""\"" # "" + type);
            } else {
                out.s("".parameter # "" + type);
            }
            List<DexAnnotationNode> ps = m.parameterAnns == null ? null : m.parameterAnns[i];
            if (ps != null && ps.size() != 0) {
                out.push();
                dumpAnns(ps, out);
                out.pop();
                out.s("".end parameter"");
            }
            // FIXME support '.param' REGISTER, STRING
        }",loop_control
opNode,"for (DexDebugNode.DexDebugOpNode opNode : debugNode.debugNodes) {
                List<DexDebugNode.DexDebugOpNode> list = debugLabelMap.get(opNode.label);
                if (list == null) {
                    list = new ArrayList<>(3);
                    debugLabelMap.put(opNode.label, list);
                }
                list.add(opNode);
            }",iterator
label,"{
            @Override
            public void visitJumpStmt(Op op, int a, int b, DexLabel label) {
                usedLabel.add(label);
            }

            @Override
            public void visitPackedSwitchStmt(Op op, int aA, int first_case, DexLabel[] labels) {
                usedLabel.addAll(Arrays.asList(labels));
            }

            @Override
            public void visitTryCatch(DexLabel start, DexLabel end, DexLabel[] handler, String[] type) {
                usedLabel.add(start);
                usedLabel.add(end);
                usedLabel.addAll(Arrays.asList(handler));
            }

            @Override
            public void visitLabel(DexLabel label) {
                allLabel.add(label);
            }

            @Override
            public void visitSparseSwitchStmt(Op op, int ra, int[] cases, DexLabel[] labels) {
                usedLabel.addAll(Arrays.asList(labels));
            }
        }",iterator
label,"for (DexDebugNode.DexDebugOpNode opNode : debugNode.debugNodes) {
                List<DexDebugNode.DexDebugOpNode> list = debugLabelMap.get(opNode.label);
                if (list == null) {
                    list = new ArrayList<>(3);
                    debugLabelMap.put(opNode.label, list);
                }
                list.add(opNode);
            }",iterator
label,"for (DexLabel label : allLabel) {
            if (usedLabel.contains(label)) {
                label.displayName = ""L"" + nextLabelNumber++;
            }
        }",iterator
n,"for (TryCatchNode n : code.tryStmts) {
                n.accept(v);
            }",iterator
n,"for (DexStmtNode n : code.stmts) {
            if (n instanceof DexLabelStmtNode) {
                n.accept(v);
            } else {
                out.push();
                n.accept(v);
                out.pop();
            }

        }",iterator
i,"for (int i = 0; i < needCareStmts.size(); i++) {
            DexStmtNode s = needCareStmts.get(i);
            if (s instanceof DexLabelStmtNode) {
                DexLabelStmtNode ss = (DexLabelStmtNode) s;
                if (ss.label == label) {
                    labelIndex = i;
                }
            }
        }",loop_control
i,"for (int i = 0; i < vs1.length; i++) {
                            vs1[i] = (short) ((vs[i * 2] & 0xFF) | ((vs[i * 2 + 1] & 0xFF) << 8));
                        }",loop_control
i,"for (int i = 0; i < vs1.length; i++) {
                            int base = i * 4;
                            vs1[i] = (vs[base + 0] & 0xFF) | ((vs[base + 1] & 0xFF) << 8)
                                    | ((vs[base + 2] & 0xFF) << 16) | ((vs[base + 3] & 0xFF) << 24);
                        }",loop_control
i,"for (int i = 0; i < vs1.length; i++) {
                            int base = i * 8;
                            int a = ((vs[base + 0] & 0xFF) << 0) | ((vs[base + 1] & 0xFF) << 8)
                                    | ((vs[base + 2] & 0xFF) << 16) | ((vs[base + 3] & 0xFF) << 24);
                            int b = ((vs[base + 4] & 0xFF) << 0) | ((vs[base + 5] & 0xFF) << 8)
                                    | ((vs[base + 6] & 0xFF) << 16) | ((vs[base + 7] & 0xFF) << 24);
                            vs1[i] = (((long) b) << 32) | a;
                        }",loop_control
s,"for (String s : remainingArgs) {
            Path file = new File(s).toPath();
            if (!Files.exists(file)) {
                System.err.println(""skip "" + file + "", it is not a dir or a file"");
            } else {
                System.err.println(""smali "" + s + "" -> "" + output);
                smali.smali(file, fv);
            }
        }",iterator
i,"for (int i = 0; i < itfs.size(); i++) {
                interfaceNames[i] = Utils.unEscapeId(itfs.get(i).name.getText());
            }",loop_control
ctx,"for (SmaliParser.SMethodContext ctx : sMethodContexts) {
            acceptMethod(ctx, className, dexClassVisitor);
        }",iterator
i,"for (int i = 0; i < paramTypes.length; i++) {
                char t = paramTypes[i].charAt(0);
                map[start++] = i;
                if (t == 'J' || t == 'D') {
                    map[start++] = i;
                }
            }",loop_control
instructionContext,"for (SmaliParser.SInstructionContext instructionContext : instructionContexts) {
            ParserRuleContext parserRuleContext = (ParserRuleContext) instructionContext.getChild(0);
            if (parserRuleContext != null) {
                int ruleIndex = parserRuleContext.getRuleIndex();
                if (ruleIndex == SmaliParser.RULE_fregisters) {
                    totalRegisters = parseInt(((SmaliParser.FregistersContext) parserRuleContext).xregisters.getText());
                    break;
                } else if (ruleIndex == SmaliParser.RULE_flocals) {
                    totalRegisters = ins + parseInt(((SmaliParser.FlocalsContext) parserRuleContext).xlocals.getText());
                    break;
                }
            }
        }",iterator
ctx,"for (SmaliParser.SParameterContext ctx : sParameterContexts) {
            if (ctx.param != null) {
                hasParam = true;
            }
            if (ctx.parameter != null) {
                hasParamter = true;
            }
        }",iterator
ctx,"for (int i = 0; i < sParameterContexts.size(); i++) {
            SmaliParser.SParameterContext ctx = sParameterContexts.get(i);
            int index;
            if (ctx.param != null) {
                index = m.regToParamIdx(m.pareReg(ctx.r.getText()));
            } else {
                index = i;
            }
            if (ctx.name != null) {
                m.setNameByIdx(index, unescapeStr(ctx.name.getText()));
            }
            List<SmaliParser.SAnnotationContext> annotationContexts = ctx.sAnnotation();
            if (annotationContexts.size() > 0) {
                acceptAnnotations(annotationContexts, dexMethodVisitor.visitParameterAnnotation(index));
            }
        }",iterator
i,"for (int i = 0; i < sParameterContexts.size(); i++) {
            SmaliParser.SParameterContext ctx = sParameterContexts.get(i);
            int index;
            if (ctx.param != null) {
                index = m.regToParamIdx(m.pareReg(ctx.r.getText()));
            } else {
                index = i;
            }
            if (ctx.name != null) {
                m.setNameByIdx(index, unescapeStr(ctx.name.getText()));
            }
            List<SmaliParser.SAnnotationContext> annotationContexts = ctx.sAnnotation();
            if (annotationContexts.size() > 0) {
                acceptAnnotations(annotationContexts, dexMethodVisitor.visitParameterAnnotation(index));
            }
        }",loop_control
ctx,"for (SmaliParser.SFieldContext ctx : sFieldContexts) {
            acceptField(ctx, className, dexClassVisitor);
        }",iterator
ctx,"for (SmaliParser.SAnnotationContext ctx : sAnnotationContexts) {
                Visibility visibility = Utils.getAnnVisibility(ctx.visibility.getText());
                String type = Utils.unEscapeId(ctx.type.getText());
                DexAnnotationVisitor dexAnnotationVisitor = dexAnnotationAble.visitAnnotation(type, visibility);
                if (dexAnnotationVisitor != null) {
                    List<SmaliParser.SAnnotationKeyNameContext> keys = ctx.sAnnotationKeyName();
                    if (keys.size() > 0) {
                        List<SmaliParser.SAnnotationValueContext> values = ctx.sAnnotationValue();
                        for (int i = 0; i < keys.size(); i++) {
                            acceptAnnotation(dexAnnotationVisitor, Utils.unEscapeId(keys.get(i).getText()), values.get(i));
                        }
                    }
                    dexAnnotationVisitor.visitEnd();
                }
            }",iterator
i,"for (int i = 0; i < keys.size(); i++) {
                            acceptAnnotation(dexAnnotationVisitor, Utils.unEscapeId(keys.get(i).getText()), values.get(i));
                        }",loop_control
i,"for (int i = 0; i < keys.size(); i++) {
                            acceptAnnotation(annotationVisitor, Utils.unEscapeId(keys.get(i).getText()), values.get(i));
                        }",loop_control
annotationValueContext,"for (SmaliParser.SAnnotationValueContext annotationValueContext : arrayValueContext
                            .sAnnotationValue()) {
                        acceptAnnotation(annotationVisitor, null, annotationValueContext);
                    }",iterator
acc,"for (TerminalNode acc : ctx.ACC()) {
            access |= Utils.getAcc(acc.getSymbol().getText());
        }",iterator
ctx,"for (SmaliParser.SFileContext ctx : parser.sFiles().sFile()) {
            AntlrSmaliUtil.acceptFile(ctx, dcv);
        }",iterator
i,"for (int i = 0; i < this.i; i++) {
                writer.append(indent);
            }",loop_control
i,"for (int i = 0; i < this.i; i++) {
                writer.append(indent);
            }",loop_control
o,"for (Object o : (ArrayList) value) {
                doAccept(a, null, o);
            }",iterator
e,"for (Map.Entry<String, Object> e : ann.elements) {
                doAccept(a, e.getKey(), e.getValue());
            }",iterator
i,"{
        List<String> list = new ArrayList(5);
        if (desc == null) {
            return list;
        }
        char[] chars = desc.toCharArray();
        int i = 0;
        while (i < chars.length) {
            switch (chars[i]) {
                case 'V':
                case 'Z':
                case 'C':
                case 'B':
                case 'S':
                case 'I':
                case 'F':
                case 'J':
                case 'D':
                    list.add(Character.toString(chars[i]));
                    i++;
                    break;
                case '[': {
                    int count = 1;
                    while (chars[i + count] == '[') {
                        count++;
                    }
                    if (chars[i + count] == 'L') {
                        count++;
                        while (chars[i + count] != ';') {
                            count++;
                        }
                    }
                    count++;
                    list.add(new String(chars, i, count));
                    i += count;
                    break;
                }
                case 'L': {
                    int count = 1;
                    while (chars[i + count] != ';') {
                        ++count;
                    }
                    count++;
                    list.add(new String(chars, i, count));
                    i += count;
                    break;
                }
                default:
                    throw new RuntimeException(""can't parse type list: "" + desc);
            }
        }
        return list;
    }",loop_control
count,"{
                    int count = 1;
                    while (chars[i + count] == '[') {
                        count++;
                    }
                    if (chars[i + count] == 'L') {
                        count++;
                        while (chars[i + count] != ';') {
                            count++;
                        }
                    }
                    count++;
                    list.add(new String(chars, i, count));
                    i += count;
                    break;
                }",loop_control
count,"{
                    int count = 1;
                    while (chars[i + count] != ';') {
                        ++count;
                    }
                    count++;
                    list.add(new String(chars, i, count));
                    i += count;
                    break;
                }",loop_control
i,"for (int i = 0; i < ss.size(); i++) {
            vs[i] = parseInt(ss.get(i));
        }",loop_control
i,"for (int i = 0; i < ss.size(); i++) {
            vs[i] = ((Number) (ss.get(i))).byteValue();
        }",loop_control
op,"for (Op op : Op.values()) {
            ops.put(op.displayName, op);
        }",iterator
i,"for (int i = start; i < end; ) {
            char c = str.charAt(i);
            if (c == '\\') {
                char d = str.charAt(i + 1);
                switch (d) {
                    // ('b'|'t'|'n'|'f'|'r'|'\""'|'\''|'\\')
                    case 'b':
                        sb.append('\b');
                        i += 2;
                        break;
                    case 't':
                        sb.append('\t');
                        i += 2;
                        break;
                    case 'n':
                        sb.append('\n');
                        i += 2;
                        break;
                    case 'f':
                        sb.append('\f');
                        i += 2;
                        break;
                    case 'r':
                        sb.append('\r');
                        i += 2;
                        break;
                    case '\""':
                        sb.append('\""');
                        i += 2;
                        break;
                    case '\'':
                        sb.append('\'');
                        i += 2;
                        break;
                    case '\\':
                        sb.append('\\');
                        i += 2;
                        break;
                    case 'u':
                        String sub = str.substring(i + 2, i + 6);
                        sb.append((char) Integer.parseInt(sub, 16));
                        i += 6;
                        break;
                    default:
                        int x = 0;
                        while (x < 3) {
                            char e = str.charAt(i + 1 + x);
                            if (e >= '0' && e <= '7') {
                                x++;
                            } else {
                                break;
                            }
                        }
                        if (x == 0) {
                            throw new RuntimeException(""can't pase string"");
                        }
                        sb.append((char) Integer.parseInt(str.substring(i + 1, i + 1 + x), 8));
                        i += 1 + x;
                }

            } else {
                sb.append(c);
                i++;
            }
        }",loop_control
x,"{
                    // ('b'|'t'|'n'|'f'|'r'|'\""'|'\''|'\\')
                    case 'b':
                        sb.append('\b');
                        i += 2;
                        break;
                    case 't':
                        sb.append('\t');
                        i += 2;
                        break;
                    case 'n':
                        sb.append('\n');
                        i += 2;
                        break;
                    case 'f':
                        sb.append('\f');
                        i += 2;
                        break;
                    case 'r':
                        sb.append('\r');
                        i += 2;
                        break;
                    case '\""':
                        sb.append('\""');
                        i += 2;
                        break;
                    case '\'':
                        sb.append('\'');
                        i += 2;
                        break;
                    case '\\':
                        sb.append('\\');
                        i += 2;
                        break;
                    case 'u':
                        String sub = str.substring(i + 2, i + 6);
                        sb.append((char) Integer.parseInt(sub, 16));
                        i += 6;
                        break;
                    default:
                        int x = 0;
                        while (x < 3) {
                            char e = str.charAt(i + 1 + x);
                            if (e >= '0' && e <= '7') {
                                x++;
                            } else {
                                break;
                            }
                        }
                        if (x == 0) {
                            throw new RuntimeException(""can't pase string"");
                        }
                        sb.append((char) Integer.parseInt(str.substring(i + 1, i + 1 + x), 8));
                        i += 1 + x;
                }",loop_control
t,"for (String t : m.getParameterTypes()) {
            switch (t.charAt(0)) {
                case 'J':
                case 'D':
                    a += 2;
                    break;
                default:
                    a += 1;
                    break;
            }
        }",iterator
i,"for (int i = 0, parameterTypesLength = parameterTypes.length; i < parameterTypesLength; i++) {

            if (x == a) {
                return i;
            }

            String t = parameterTypes[i];
            switch (t.charAt(0)) {
                case 'J':
                case 'D':
                    a += 2;
                    break;
                default:
                    a += 1;
                    break;
            }
        }",loop_control
i,"for (int i = 0; i < params.length; i++) {
            params[i] = unEscapeId(params[i]);
        }",loop_control
name,"for (String name : names) {
            JarEntry inEntry = in.getJarEntry(name);
            JarEntry outEntry = null;
            if (inEntry.getMethod() == JarEntry.STORED) {
                // Preserve the STORED method of the input entry.
                outEntry = new JarEntry(inEntry);
            } else {
                // Create a new entry so that the compressed len is recomputed.
                outEntry = new JarEntry(name);
            }
            outEntry.setTime(timestamp);
            out.putNextEntry(outEntry);

            InputStream data = in.getInputStream(inEntry);
            while ((num = data.read(buffer)) > 0) {
                out.write(buffer, 0, num);
            }
            out.flush();
        }",iterator
num,"{
        byte[] buffer = new byte[4096];
        int num;

        Map<String, Attributes> entries = manifest.getEntries();
        List<String> names = new ArrayList<>(entries.keySet());
        Collections.sort(names);
        for (String name : names) {
            JarEntry inEntry = in.getJarEntry(name);
            JarEntry outEntry = null;
            if (inEntry.getMethod() == JarEntry.STORED) {
                // Preserve the STORED method of the input entry.
                outEntry = new JarEntry(inEntry);
            } else {
                // Create a new entry so that the compressed len is recomputed.
                outEntry = new JarEntry(name);
            }
            outEntry.setTime(timestamp);
            out.putNextEntry(outEntry);

            InputStream data = in.getInputStream(inEntry);
            while ((num = data.read(buffer)) > 0) {
                out.write(buffer, 0, num);
            }
            out.flush();
        }
    }",maybe_loop_control
entry,"for (Enumeration<JarEntry> e = jar.entries(); e.hasMoreElements();) {
            JarEntry entry = e.nextElement();
            byName.put(entry.getName(), entry);
        }",iterator
entry,"for (JarEntry entry : byName.values()) {
            String name = entry.getName();
            if (!entry.isDirectory() && !name.equals(JarFile.MANIFEST_NAME) && !stripPattern.matcher(name).matches()) {
                InputStream data = jar.getInputStream(entry);
                while ((num = data.read(buffer)) > 0) {
                    md.update(buffer, 0, num);
                }

                Attributes attr = null;
                if (input != null) {
                    attr = input.getAttributes(name);
                }
                attr = attr != null ? new Attributes(attr) : new Attributes();
                attr.putValue(digName, encodeBase64(md.digest()));
                output.getEntries().put(name, attr);
            }
        }",iterator
e,"for (Enumeration<JarEntry> e = jar.entries(); e.hasMoreElements();) {
            JarEntry entry = e.nextElement();
            byName.put(entry.getName(), entry);
        }",iterator
num,"{
        Manifest input = jar.getManifest();
        Manifest output = new Manifest();
        Attributes main = output.getMainAttributes();
        if (input != null) {
            main.putAll(input.getMainAttributes());
        }
        main.putValue(""Manifest-Version"", ""1.0"");
        main.putValue(""Created-By"", ""1.6.0_21 (d2j-"" + AbstractJarSign.class.getPackage().getImplementationVersion() + "")"");

        MessageDigest md = MessageDigest.getInstance(digestAlg);
        byte[] buffer = new byte[4096];
        int num;

        // We sort the input entries by name, and add them to the
        // output manifest in sorted order. We expect that the output
        // map will be deterministic.

        TreeMap<String, JarEntry> byName = new TreeMap<String, JarEntry>();

        for (Enumeration<JarEntry> e = jar.entries(); e.hasMoreElements();) {
            JarEntry entry = e.nextElement();
            byName.put(entry.getName(), entry);
        }

        String digName = digestAlg + ""-Digest"";
        for (JarEntry entry : byName.values()) {
            String name = entry.getName();
            if (!entry.isDirectory() && !name.equals(JarFile.MANIFEST_NAME) && !stripPattern.matcher(name).matches()) {
                InputStream data = jar.getInputStream(entry);
                while ((num = data.read(buffer)) > 0) {
                    md.update(buffer, 0, num);
                }

                Attributes attr = null;
                if (input != null) {
                    attr = input.getAttributes(name);
                }
                attr = attr != null ? new Attributes(attr) : new Attributes();
                attr.putValue(digName, encodeBase64(md.digest()));
                output.getEntries().put(name, attr);
            }
        }

        return output;
    }",maybe_loop_control
entry,"for (Map.Entry<String, Attributes> entry : entries.entrySet()) {
            // Digest of the manifest stanza for this entry.
            print.write(NAMES);
            print.write(entry.getKey().getBytes(StandardCharsets.UTF_8));
            print.write(EOL);
            for (Map.Entry<Object, Object> att : entry.getValue().entrySet()) {
                print.write(att.getKey().toString().getBytes(StandardCharsets.UTF_8));
                print.write(COL);
                print.write(att.getKey().toString().getBytes(StandardCharsets.UTF_8));
                print.write(EOL);
            }
            print.write(EOL);
            print.flush();

            Attributes sfAttr = new Attributes();
            sfAttr.putValue(digName, encodeBase64(md.digest()));
            sf.getEntries().put(entry.getKey(), sfAttr);
        }",iterator
att,"for (Map.Entry<Object, Object> att : entry.getValue().entrySet()) {
                print.write(att.getKey().toString().getBytes(StandardCharsets.UTF_8));
                print.write(COL);
                print.write(att.getKey().toString().getBytes(StandardCharsets.UTF_8));
                print.write(EOL);
            }",iterator
p,"{
            if (this.state == 6) return false;

            int p = offset;
            len += offset;

            // Using local variables makes the decoder about 12%
            // faster than if we manipulate the member variables in
            // the loop.  (Even alphabet makes a measurable
            // difference, which is somewhat surprising to me since
            // the member variable is final.)
            int state = this.state;
            int value = this.value;
            int op = 0;
            final byte[] output = this.output;
            final int[] alphabet = this.alphabet;

            while (p < len) {
                // Try the fast path:  we're starting a new tuple and the
                // next four bytes of the input stream are all data
                // bytes.  This corresponds to going through states
                // 0-1-2-3-0.  We expect to use this method for most of
                // the data.
                //
                // If any of the next four bytes of input are non-data
                // (whitespace, etc.), value will end up negative.  (All
                // the non-data values in decode are small negative
                // numbers, so shifting any of them up and or'ing them
                // together will result in a value with its top bit set.)
                //
                // You can remove this whole block and the output should
                // be the same, just slower.
                if (state == 0) {
                    while (p+4 <= len &&
                           (value = ((alphabet[input[p] & 0xff] << 18) |
                                     (alphabet[input[p+1] & 0xff] << 12) |
                                     (alphabet[input[p+2] & 0xff] << 6) |
                                     (alphabet[input[p+3] & 0xff]))) >= 0) {
                        output[op+2] = (byte) value;
                        output[op+1] = (byte) (value >> 8);
                        output[op] = (byte) (value >> 16);
                        op += 3;
                        p += 4;
                    }
                    if (p >= len) break;
                }

                // The fast path isn't available -- either we've read a
                // partial tuple, or the next four input bytes aren't all
                // data, or whatever.  Fall back to the slower state
                // machine implementation.

                int d = alphabet[input[p++] & 0xff];

                switch (state) {
                case 0:
                    if (d >= 0) {
                        value = d;
                        ++state;
                    } else if (d != SKIP) {
                        this.state = 6;
                        return false;
                    }
                    break;

                case 1:
                    if (d >= 0) {
                        value = (value << 6) | d;
                        ++state;
                    } else if (d != SKIP) {
                        this.state = 6;
                        return false;
                    }
                    break;

                case 2:
                    if (d >= 0) {
                        value = (value << 6) | d;
                        ++state;
                    } else if (d == EQUALS) {
                        // Emit the last (partial) output tuple;
                        // expect exactly one more padding character.
                        output[op++] = (byte) (value >> 4);
                        state = 4;
                    } else if (d != SKIP) {
                        this.state = 6;
                        return false;
                    }
                    break;

                case 3:
                    if (d >= 0) {
                        // Emit the output triple and return to state 0.
                        value = (value << 6) | d;
                        output[op+2] = (byte) value;
                        output[op+1] = (byte) (value >> 8);
                        output[op] = (byte) (value >> 16);
                        op += 3;
                        state = 0;
                    } else if (d == EQUALS) {
                        // Emit the last (partial) output tuple;
                        // expect no further data or padding characters.
                        output[op+1] = (byte) (value >> 2);
                        output[op] = (byte) (value >> 10);
                        op += 2;
                        state = 5;
                    } else if (d != SKIP) {
                        this.state = 6;
                        return false;
                    }
                    break;

                case 4:
                    if (d == EQUALS) {
                        ++state;
                    } else if (d != SKIP) {
                        this.state = 6;
                        return false;
                    }
                    break;

                case 5:
                    if (d != SKIP) {
                        this.state = 6;
                        return false;
                    }
                    break;
                }
            }

            if (!finish) {
                // We're out of input, but a future call could provide
                // more.
                this.state = state;
                this.value = value;
                this.op = op;
                return true;
            }

            // Done reading input.  Now figure out where we are left in
            // the state machine and finish up.

            switch (state) {
            case 0:
                // Output length is a multiple of three.  Fine.
                break;
            case 1:
                // Read one extra input byte, which isn't enough to
                // make another output byte.  Illegal.
                this.state = 6;
                return false;
            case 2:
                // Read two extra input bytes, enough to emit 1 more
                // output byte.  Fine.
                output[op++] = (byte) (value >> 4);
                break;
            case 3:
                // Read three extra input bytes, enough to emit 2 more
                // output bytes.  Fine.
                output[op++] = (byte) (value >> 10);
                output[op++] = (byte) (value >> 2);
                break;
            case 4:
                // Read one padding '=' when we expected 2.  Illegal.
                this.state = 6;
                return false;
            case 5:
                // Read all the padding '='s we expected and no more.
                // Fine.
                break;
            }

            this.state = state;
            this.op = op;
            return true;
        }",loop_control
value,"{
            if (this.state == 6) return false;

            int p = offset;
            len += offset;

            // Using local variables makes the decoder about 12%
            // faster than if we manipulate the member variables in
            // the loop.  (Even alphabet makes a measurable
            // difference, which is somewhat surprising to me since
            // the member variable is final.)
            int state = this.state;
            int value = this.value;
            int op = 0;
            final byte[] output = this.output;
            final int[] alphabet = this.alphabet;

            while (p < len) {
                // Try the fast path:  we're starting a new tuple and the
                // next four bytes of the input stream are all data
                // bytes.  This corresponds to going through states
                // 0-1-2-3-0.  We expect to use this method for most of
                // the data.
                //
                // If any of the next four bytes of input are non-data
                // (whitespace, etc.), value will end up negative.  (All
                // the non-data values in decode are small negative
                // numbers, so shifting any of them up and or'ing them
                // together will result in a value with its top bit set.)
                //
                // You can remove this whole block and the output should
                // be the same, just slower.
                if (state == 0) {
                    while (p+4 <= len &&
                           (value = ((alphabet[input[p] & 0xff] << 18) |
                                     (alphabet[input[p+1] & 0xff] << 12) |
                                     (alphabet[input[p+2] & 0xff] << 6) |
                                     (alphabet[input[p+3] & 0xff]))) >= 0) {
                        output[op+2] = (byte) value;
                        output[op+1] = (byte) (value >> 8);
                        output[op] = (byte) (value >> 16);
                        op += 3;
                        p += 4;
                    }
                    if (p >= len) break;
                }

                // The fast path isn't available -- either we've read a
                // partial tuple, or the next four input bytes aren't all
                // data, or whatever.  Fall back to the slower state
                // machine implementation.

                int d = alphabet[input[p++] & 0xff];

                switch (state) {
                case 0:
                    if (d >= 0) {
                        value = d;
                        ++state;
                    } else if (d != SKIP) {
                        this.state = 6;
                        return false;
                    }
                    break;

                case 1:
                    if (d >= 0) {
                        value = (value << 6) | d;
                        ++state;
                    } else if (d != SKIP) {
                        this.state = 6;
                        return false;
                    }
                    break;

                case 2:
                    if (d >= 0) {
                        value = (value << 6) | d;
                        ++state;
                    } else if (d == EQUALS) {
                        // Emit the last (partial) output tuple;
                        // expect exactly one more padding character.
                        output[op++] = (byte) (value >> 4);
                        state = 4;
                    } else if (d != SKIP) {
                        this.state = 6;
                        return false;
                    }
                    break;

                case 3:
                    if (d >= 0) {
                        // Emit the output triple and return to state 0.
                        value = (value << 6) | d;
                        output[op+2] = (byte) value;
                        output[op+1] = (byte) (value >> 8);
                        output[op] = (byte) (value >> 16);
                        op += 3;
                        state = 0;
                    } else if (d == EQUALS) {
                        // Emit the last (partial) output tuple;
                        // expect no further data or padding characters.
                        output[op+1] = (byte) (value >> 2);
                        output[op] = (byte) (value >> 10);
                        op += 2;
                        state = 5;
                    } else if (d != SKIP) {
                        this.state = 6;
                        return false;
                    }
                    break;

                case 4:
                    if (d == EQUALS) {
                        ++state;
                    } else if (d != SKIP) {
                        this.state = 6;
                        return false;
                    }
                    break;

                case 5:
                    if (d != SKIP) {
                        this.state = 6;
                        return false;
                    }
                    break;
                }
            }

            if (!finish) {
                // We're out of input, but a future call could provide
                // more.
                this.state = state;
                this.value = value;
                this.op = op;
                return true;
            }

            // Done reading input.  Now figure out where we are left in
            // the state machine and finish up.

            switch (state) {
            case 0:
                // Output length is a multiple of three.  Fine.
                break;
            case 1:
                // Read one extra input byte, which isn't enough to
                // make another output byte.  Illegal.
                this.state = 6;
                return false;
            case 2:
                // Read two extra input bytes, enough to emit 1 more
                // output byte.  Fine.
                output[op++] = (byte) (value >> 4);
                break;
            case 3:
                // Read three extra input bytes, enough to emit 2 more
                // output bytes.  Fine.
                output[op++] = (byte) (value >> 10);
                output[op++] = (byte) (value >> 2);
                break;
            case 4:
                // Read one padding '=' when we expected 2.  Illegal.
                this.state = 6;
                return false;
            case 5:
                // Read all the padding '='s we expected and no more.
                // Fine.
                break;
            }

            this.state = state;
            this.op = op;
            return true;
        }",loop_control
tailLen,"{
            // Using local variables makes the encoder about 9% faster.
            final byte[] alphabet = this.alphabet;
            final byte[] output = this.output;
            int op = 0;
            int count = this.count;

            int p = offset;
            len += offset;
            int v = -1;

            // First we need to concatenate the tail of the previous call
            // with any input bytes available now and see if we can empty
            // the tail.

            switch (tailLen) {
                case 0:
                    // There was no tail.
                    break;

                case 1:
                    if (p+2 <= len) {
                        // A 1-byte tail with at least 2 bytes of
                        // input available now.
                        v = ((tail[0] & 0xff) << 16) |
                            ((input[p++] & 0xff) << 8) |
                            (input[p++] & 0xff);
                        tailLen = 0;
                    };
                    break;

                case 2:
                    if (p+1 <= len) {
                        // A 2-byte tail with at least 1 byte of input.
                        v = ((tail[0] & 0xff) << 16) |
                            ((tail[1] & 0xff) << 8) |
                            (input[p++] & 0xff);
                        tailLen = 0;
                    }
                    break;
            }

            if (v != -1) {
                output[op++] = alphabet[(v >> 18) & 0x3f];
                output[op++] = alphabet[(v >> 12) & 0x3f];
                output[op++] = alphabet[(v >> 6) & 0x3f];
                output[op++] = alphabet[v & 0x3f];
                if (--count == 0) {
                    if (do_cr) output[op++] = '\r';
                    output[op++] = '\n';
                    count = LINE_GROUPS;
                }
            }

            // At this point either there is no tail, or there are fewer
            // than 3 bytes of input available.

            // The main loop, turning 3 input bytes into 4 output bytes on
            // each iteration.
            while (p+3 <= len) {
                v = ((input[p] & 0xff) << 16) |
                    ((input[p+1] & 0xff) << 8) |
                    (input[p+2] & 0xff);
                output[op] = alphabet[(v >> 18) & 0x3f];
                output[op+1] = alphabet[(v >> 12) & 0x3f];
                output[op+2] = alphabet[(v >> 6) & 0x3f];
                output[op+3] = alphabet[v & 0x3f];
                p += 3;
                op += 4;
                if (--count == 0) {
                    if (do_cr) output[op++] = '\r';
                    output[op++] = '\n';
                    count = LINE_GROUPS;
                }
            }

            if (finish) {
                // Finish up the tail of the input.  Note that we need to
                // consume any bytes in tail before any bytes
                // remaining in input; there should be at most two bytes
                // total.

                if (p-tailLen == len-1) {
                    int t = 0;
                    v = ((tailLen > 0 ? tail[t++] : input[p++]) & 0xff) << 4;
                    tailLen -= t;
                    output[op++] = alphabet[(v >> 6) & 0x3f];
                    output[op++] = alphabet[v & 0x3f];
                    if (do_padding) {
                        output[op++] = '=';
                        output[op++] = '=';
                    }
                    if (do_newline) {
                        if (do_cr) output[op++] = '\r';
                        output[op++] = '\n';
                    }
                } else if (p-tailLen == len-2) {
                    int t = 0;
                    v = (((tailLen > 1 ? tail[t++] : input[p++]) & 0xff) << 10) |
                        (((tailLen > 0 ? tail[t++] : input[p++]) & 0xff) << 2);
                    tailLen -= t;
                    output[op++] = alphabet[(v >> 12) & 0x3f];
                    output[op++] = alphabet[(v >> 6) & 0x3f];
                    output[op++] = alphabet[v & 0x3f];
                    if (do_padding) {
                        output[op++] = '=';
                    }
                    if (do_newline) {
                        if (do_cr) output[op++] = '\r';
                        output[op++] = '\n';
                    }
                } else if (do_newline && op > 0 && count != LINE_GROUPS) {
                    if (do_cr) output[op++] = '\r';
                    output[op++] = '\n';
                }

                assert tailLen == 0;
                assert p == len;
            } else {
                // Save the leftovers in tail to be consumed on the next
                // call to encodeInternal.

                if (p == len-1) {
                    tail[tailLen++] = input[p];
                } else if (p == len-2) {
                    tail[tailLen++] = input[p];
                    tail[tailLen++] = input[p+1];
                }
            }

            this.op = op;
            this.count = count;

            return true;
        }",loop_control
p,"for (AbstractInsnNode p = this.instructions.getFirst(); p != null; p = p.getNext()) {
                                    //looking for  NEW,DUP,LDC,PUTSTATUS

                                    if (status == 0) {  // init
                                        if (p.getOpcode() == NEW) {
                                            TypeInsnNode ti = (TypeInsnNode) p;
                                            if (thisDesc.equals(ti.desc)) {
                                                status = 1;
                                            }
                                        }
                                    } else if (status == 1) {  // find NEW
                                        if (p.getOpcode() == DUP) {
                                            status = 2;
                                        } else {
                                            status = 0;
                                        }
                                    } else if (status == 2) {  //find DUP
                                        if (p.getOpcode() == LDC) {
                                            LdcInsnNode ldc = (LdcInsnNode) p;
                                            if (ldc.cst instanceof String) {
                                                eFieldName = (String) ldc.cst;
                                                status = 3;
                                            } else {
                                                status = 0;
                                            }
                                        } else {
                                            status = 0;
                                        }
                                    } else if (status == 3) {  //find LDC
                                        if (p.getOpcode() == PUTSTATIC) {
                                            FieldInsnNode fin = (FieldInsnNode) p;
                                            if (fin.owner.equals(thisDesc) && fin.desc.equals(thisDesc)) {
                                                if (!fin.name.equals(eFieldName)) {
                                                    enumFieldMap.put(fin.name, eFieldName);
                                                }
                                                eFieldName = null;
                                                status = 0;
                                            }
                                        }
                                    }
                                }",iterator
e,"for (Map.Entry<String, String> e : enumFieldMap.entrySet()) {
                        String name = e.getKey();
                        String suggestName = e.getValue();
                        for (MemberInfo mi : clz.fields) {
                            if (isFinal(mi.access) && isStatic(mi.access)
                                    && mi.name.equals(name) && mi.desc.equals(thisDesc)) {
                                mi.suggestName = suggestName;
                            }
                        }
                    }",iterator
mi,"{
                MemberInfo mi = clz.addField(access, name, desc);
                if (initEnumNames && isEnum
                        && isPrivate(access) && isFinal(access) && isSynthetic(access)
                        && !ENUM_VALUES_FIELD_NAME.equals(name)
                        && (""[L"" + clz.name + "";"").equals(desc)) {
                    mi.suggestName = ENUM_VALUES_FIELD_NAME;
                }
                if (initAssertionNames && isSynthetic(access) && isStatic(access)
                        && !isPrivate(access) && !isPublic(access) && !isProtected(access)
                        && desc.equals(""Z"") && !ASSERTION_DISABLED_FIELD_NAME.equals(name)) {
                    mi.suggestName = ASSERTION_DISABLED_FIELD_NAME;
                }

                return null;
            }",iterator
mi,"for (MemberInfo mi : clz.fields) {
                            if (isFinal(mi.access) && isStatic(mi.access)
                                    && mi.name.equals(name) && mi.desc.equals(thisDesc)) {
                                mi.suggestName = suggestName;
                            }
                        }",iterator
it,"{
        Iterator<MemberInfo> it = members.iterator();
        if (it.hasNext()) {
            MemberInfo current = it.next();
            while (true) {
                if (it.hasNext()) {
                    MemberInfo next = it.next();
                    if (current.name.equals(next.name)) {
                        int x = 1;
                        doMember(owner, current, x++);
                        doMember(owner, next, x++);
                        while (it.hasNext()) {
                            next = it.next();
                            if (current.name.equals(next.name)) {
                                doMember(owner, next, x++);
                            } else {
                                current = next;
                                break;
                            }
                        }
                    } else {
                        doMember(owner, current, 0);
                        current = next;
                    }
                } else {
                    doMember(owner, current, 0);
                    break;
                }
            }
        }
    }",iterator
ci,"for (ClassInfo ci : classInfoList) {
            doClass0(ci.name);
            Collections.sort(ci.fields, comparator);
            transformerMember(ci.name, ci.fields);
            Collections.sort(ci.methods, comparator);
            transformerMember(ci.name, ci.methods);
        }",iterator
ln,"for (String ln = r.readLine(); ln != null; ln = r.readLine()) {
                list.add(ln);
            }",maybe_loop_control
ln,"for (String ln : lines) {
            withConfig(ln);
        }",iterator
i,"for (int i = 0; i < args.length; i++) {
                        mv.visitInsn(DUP);
                        mv.visitLdcInsn(i);
                        mv.visitVarInsn(args[i].getOpcode(ILOAD), i + start);
                        box(args[i], mv);
                        mv.visitInsn(AASTORE);
                    }",loop_control
i,"for (int i = 0; i < args.length; i++) {
                    mv.visitVarInsn(ALOAD, start);
                    mv.visitLdcInsn(i);
                    mv.visitInsn(AALOAD);
                    unBox(args[i], OBJECT_TYPE, mv);
                }",loop_control
i,"{
                                rmv.visitCode();
                                int n, i;
                                n = tryCatchBlocks == null ? 0 : tryCatchBlocks.size();

                                for (i = 0; i < n; ++i) {
                                    tryCatchBlocks.get(i).accept(rmv);
                                }
                                instructions.accept(rmv);
                                n = localVariables == null ? 0 : localVariables.size();

                                for (i = 0; i < n; ++i) {
                                    localVariables.get(i).accept(rmv);
                                }
                                rmv.visitMaxs(-1, -1);
                                rmv.visitEnd();
                            }",loop_control
i,"for (int i = 0; i < orgArgs.length; i++) {
                                        if (!orgArgs[i].equals(nArgs[i + 1])) {
                                            throw new RuntimeException(""arguments not equal: "" + owner + ""."" + name
                                                    + desc + "" <> "" + mapTo.owner + ""."" + mapTo.name + mapTo.desc);
                                        }
                                    }",loop_control
i,"for (int i = 0; i < labels.length; i++) {
                labels[i] = new Label();
            }",loop_control
i,"for (int i = 0; i < labels.length; i++) {
                mv.visitLabel(labels[i]);
                Callback cb = callbacks.get(i);
                MtdInfo m = (MtdInfo) cb.callback;
                if (cb.isStatic) {
                    mv.visitVarInsn(ALOAD, 0);
                    mv.visitFieldInsn(GETFIELD, typeName, ""args"", ""[Ljava/lang/Object;"");
                    mv.visitMethodInsn(INVOKESTATIC, toInternal(m.owner), m.name, m.desc);
                } else if (cb.isSpecial) {
                    mv.visitVarInsn(ALOAD, 0);
                    mv.visitFieldInsn(GETFIELD, typeName, ""thiz"", ""Ljava/lang/Object;"");
                    mv.visitTypeInsn(CHECKCAST, toInternal(m.owner));
                    mv.visitVarInsn(ALOAD, 0);
                    mv.visitFieldInsn(GETFIELD, typeName, ""args"", ""[Ljava/lang/Object;"");
                    mv.visitMethodInsn(INVOKEVIRTUAL, toInternal(m.owner), m.name, m.desc);
                } else {
                    mv.visitVarInsn(ALOAD, 0);
                    mv.visitFieldInsn(GETFIELD, typeName, ""thiz"", ""Ljava/lang/Object;"");
                    mv.visitVarInsn(ALOAD, 0);
                    mv.visitFieldInsn(GETFIELD, typeName, ""args"", ""[Ljava/lang/Object;"");
                    mv.visitMethodInsn(INVOKESTATIC, toInternal(m.owner), m.name, m.desc);
                }
                Type ret = Type.getReturnType(m.desc);
                box(ret, mv);
                mv.visitInsn(ret.getOpcode(IRETURN));
            }",loop_control
i,"for (int i = 0; i < labels.length; i++) {
            Callback cb = callbacks.get(i);
            String key = callback.getKey((MtdInfo) cb.target);
            Label label = strMap.get(key);
            if (label == null) {
                label = new Label();
                strMap.put(key, label);
            }
            labels[i] = label;
        }",loop_control
e,"for (Map.Entry<String, Label> e : strMap.entrySet()) {
            mv.visitLabel(e.getValue());
            mv.visitLdcInsn(e.getKey());
            mv.visitInsn(ARETURN);
        }",iterator
i,"for (int i = 0; i < labels.length; i++) {
                labels[i] = new DexLabel();
            }",loop_control
i,"for (int i = 0; i < labels.length; i++) {
                code.visitLabel(labels[i]);
                Callback callback = callbacks.get(i);
                Method mCallback = (Method) callback.callback;
                if (callback.isStatic) {
                    code.visitMethodStmt(Op.INVOKE_STATIC, new int[]{1}, mCallback);
                } else if (callback.isSpecial) {
                    code.visitTypeStmt(Op.CHECK_CAST, 0, -1, mCallback.getOwner());
                    code.visitMethodStmt(Op.INVOKE_VIRTUAL, new int[]{0, 1}, mCallback);
                } else {
                    code.visitMethodStmt(Op.INVOKE_STATIC, new int[]{0, 1}, mCallback);
                }
                code.visitStmt1R(Op.MOVE_RESULT_OBJECT, 0);
                code.visitStmt1R(Op.RETURN_OBJECT, 0);
            }",loop_control
i,"for (int i = 0; i < labels.length; i++) {
            Callback cb = callbacks.get(i);
            String key = callback.getKey((Method) cb.target);
            DexLabel label = strMap.get(key);
            if (label == null) {
                label = new DexLabel();
                strMap.put(key, label);
            }
            labels[i] = label;
        }",loop_control
e,"for (Map.Entry<String, DexLabel> e : strMap.entrySet()) {
            code.visitLabel(e.getValue());
            code.visitConstStmt(Op.CONST_STRING, 0, e.getKey());
            code.visitStmt1R(Op.RETURN_OBJECT, 0);
        }",iterator
i,"for (int i = 0; i < ss.length; i++) {
            ss[i] = ts[i].getDescriptor();
        }",loop_control
arg,"for (String arg : t.getParameterTypes()) {
            char type = arg.charAt(0);
            if (type == 'J' || type == 'D') {
                i += 2;
            } else {
                i += 1;
            }
        }",iterator
i,"for (String i : ignores) {
                        if (s.startsWith(i)) {
                            ignore = true;
                            break;
                        }
                    }",iterator
key,"for (Object key : p.keySet()) {
            String name = key.toString();
            Path path = out.resolve(key.toString() + "".sh"");
            BaseCmd.createParentDirectories(path);
            try (BufferedWriter bw = Files.newBufferedWriter(path, StandardCharsets.UTF_8, StandardOpenOption.CREATE,
                    StandardOpenOption.WRITE)) {
                String s = sh.replaceAll(""__@class_name@__"", p.getProperty(name));
                bw.append(s);
            }

            setExec(path);

            path = out.resolve(key.toString() + "".bat"");
            BaseCmd.createParentDirectories(path);
            try (BufferedWriter bw = Files.newBufferedWriter(path, StandardCharsets.UTF_8, StandardOpenOption.CREATE,
                    StandardOpenOption.WRITE)) {
                String s = bat.replaceAll(""__@class_name@__"", p.getProperty(name));
                bw.append(s);
            }
        }",iterator
fileIt,"{
        List<String> f = new ArrayList<>();
        f.addAll(Arrays.asList(remainingArgs));
        if (fileList != null) {
            f.addAll(Files.readAllLines(fileList, StandardCharsets.UTF_8));
        }
        if (f.size() < 1) {
            throw new HelpException();
        }

        final ExecutorService executorService = Executors.newFixedThreadPool(multiThread);

        final Iterator<String> fileIt = f.iterator();
        executorService.submit(new Runnable() {
            @Override
            public void run() {
                if (fileIt.hasNext()) {
                    String fileName = fileIt.next();
                    try {
                        run0(fileName, executorService);
                    } catch (Exception e) {
                        e.printStackTrace();
                    } finally {
                        executorService.submit(this); // run this job again
                    }
                } else {
                    executorService.shutdown();
                }
            }
        });
        executorService.awaitTermination(Integer.MAX_VALUE, TimeUnit.SECONDS);
    }",iterator
result,"for (Future<?> result : results) {
                                try {
                                    result.get();
                                } catch (InterruptedException | ExecutionException e) {
                                    e.printStackTrace();
                                }
                            }",iterator
ln,"for (String ln : Files.readAllLines(config, StandardCharsets.UTF_8)) {
            if (ln.startsWith(""#"") || ln.length() == 0) {
                continue;
            }
            String[] x = ln.split(""="");
            map.put(x[0], parseMethod(x[1]));
        }",iterator
f,"for (String f : remainingArgs) {
            byte[] data = ZipUtil.readDex(new File(f).toPath());
            DexFileReader r = new DexFileReader(data);
            r.accept(fv);
        }",iterator
x,"for (String x : remainingArgs) {
                System.err.println(""Processing "" + x + "" ..."");
                ByteBuffer bs = ByteBuffer.wrap(Files.readAllBytes(new File(x).toPath()))
                        .order(ByteOrder.LITTLE_ENDIAN);
                int magic = bs.getInt(0) & 0x00FFFFFF;
                if (magic == MAGIC_ODEX) {
                    int offset = bs.getInt(8);
                    int length = bs.getInt(12);
                    bs.position(offset);
                    ByteBuffer n = (ByteBuffer) bs.slice().limit(length);
                    doDex(n, out);
                } else if (magic == MAGIC_DEX) {
                    doDex(bs, out);
                } else {
                    throw new RuntimeException(""File "" + x + "" is not an dex or odex"");
                }

            }",iterator
j,"for (int j = 0; j < method.instructions.size(); ++j) {
            method.instructions.get(j).accept(mv);

            StringBuffer s = new StringBuffer();
            Frame f = frames[j];
            if (f == null) {
                s.append('?');
            } else {
                for (int k = 0; k < f.getLocals(); ++k) {
                    s.append(getShortName(f.getLocal(k).toString()));
                }
                s.append("" : "");
                for (int k = 0; k < f.getStackSize(); ++k) {
                    s.append(getShortName(f.getStack(k).toString()));
                }
            }
            try {
                pw.printf(format, j, s, buf.get(t)); // mv.text.get(j));
            } catch (IllegalAccessException e) {
                e.printStackTrace();
            }
        }",loop_control
k,"for (int k = 0; k < f.getLocals(); ++k) {
                    s.append(getShortName(f.getLocal(k).toString()));
                }",loop_control
k,"for (int k = 0; k < f.getStackSize(); ++k) {
                    s.append(getShortName(f.getStack(k).toString()));
                }",loop_control
fn,"for (String fn : remainingArgs) {
            Path file = new File(fn).toPath();
            if (!Files.exists(file)) {
                System.err.println(fn + "" doesn't exist"");
                usage();
                return;
            }
            files.add(file);
        }",iterator
file,"for (String fn : remainingArgs) {
            Path file = new File(fn).toPath();
            if (!Files.exists(file)) {
                System.err.println(fn + "" doesn't exist"");
                usage();
                return;
            }
            files.add(file);
        }",break_loop_control
file,"for (Path file : files) {
            System.out.println(""verify "" + file);
            walkJarOrDir(file, new FileVisitorX() {
                @Override
                public void visitFile(Path file, String relative) throws IOException {
                    if (file.getFileName().toString().endsWith("".class"")) {
                        ClassReader cr = new ClassReader(Files.readAllBytes(file));
                        ClassNode cn = new ClassNode();
                        cr.accept(new CheckClassAdapter(cn, false),
                                ClassReader.SKIP_DEBUG | ClassReader.EXPAND_FRAMES | ClassReader.SKIP_FRAMES);
                        for (MethodNode method : cn.methods) {
                            BasicVerifier verifier = new BasicVerifier();
                            Analyzer<BasicValue> a = new Analyzer<>(verifier);
                            try {
                                a.analyze(cn.name, method);
                            } catch (Exception ex) {
                                System.err.println(""Error verify method "" + cr.getClassName() + ""."" + method.name + "" ""
                                        + method.desc);
                                if (detail) {
                                    ex.printStackTrace(System.err);
                                    printAnalyzerResult(method, a, new PrintWriter(new OutputStreamWriter(System.err, StandardCharsets.UTF_8)));
                                }
                            }
                        }
                    }
                }
            });
        }",break_loop_control
method,"for (MethodNode method : cn.methods) {
                            BasicVerifier verifier = new BasicVerifier();
                            Analyzer<BasicValue> a = new Analyzer<>(verifier);
                            try {
                                a.analyze(cn.name, method);
                            } catch (Exception ex) {
                                System.err.println(""Error verify method "" + cr.getClassName() + ""."" + method.name + "" ""
                                        + method.desc);
                                if (detail) {
                                    ex.printStackTrace(System.err);
                                    printAnalyzerResult(method, a, new PrintWriter(new OutputStreamWriter(System.err, StandardCharsets.UTF_8)));
                                }
                            }
                        }",iterator
pos,"for (long pos : possibleOdexs) {
            System.err.println(String.format("">> Check for %08x"", pos));
            channel.position(pos);
            head.position(0);
            int c = channel.read(head);
            head.position(0);
            if (c == buffSize) {
                int version = head.getInt(4);
                if (version == 0x00363330 || version == 0x00353330) { // odexVersion
                    int dexOffset = head.getInt(8);
                    int dexLength = head.getInt(12);
                    int depsOffset = head.getInt(16);
                    int depsLength = head.getInt(20);
                    int optOffset = head.getInt(24);
                    int optLength = head.getInt(28);
                    int flags = head.getInt(32);
                    int checksum = head.getInt(36);
                    if (dexOffset != 0x28) {
                        System.err.println(String.format("">>> dex offset is not 0x28""));
                    } else {
                        int dexMagic = head.getInt(dexOffset + 0);
                        int dexVersion = head.getInt(dexOffset + 4);
                        if (dexMagic != 0x0a786564 || !(dexVersion == 0x00363330 || dexVersion == 0x00353330)) {
                            System.err.println(String.format("">>> dex magic is not dex.036 or dex.035: 0x%08x 0x%08x"", dexMagic, dexVersion));
                        } else {
                            int fileSize = head.getInt(dexOffset + 32);
                            if (fileSize != dexLength) {
                                System.err.println(String.format("">>> dex file size is same with dexLength in odex %d vs %d"", fileSize, dexLength));
                            } else {
                                int endian = head.getInt(dexOffset + 40);
                                if (endian != 0x12345678) {
                                    System.err.println(String.format("">>> dex endian is not 0x12345678""));
                                } else {
                                    // find new dex
                                    Path nFile = new File(String.format(""%s-%02d.odex"", namePrefix, dexIndex++)).toPath();
                                    System.out.println(String.format("">>>> extract 0x%08x to %s"", pos, nFile));
                                    try (SeekableByteChannel channel2 = Files.newByteChannel(nFile, StandardOpenOption.CREATE, StandardOpenOption.WRITE);) {

                                        odexHead.rewind();
                                        odexHead.putInt(0x0a796564);// dey
                                        odexHead.putInt(0x00363330);// 036
                                        odexHead.putInt(0x28);
                                        odexHead.putInt(fileSize);
                                        int nDepsOffset = 0x28 + fileSize;
                                        int nDepsPadding = 0;
                                        if (nDepsOffset % 8 != 0) {
                                            nDepsPadding = 8 - (nDepsOffset % 8);
                                            nDepsOffset += nDepsPadding;
                                        }
                                        odexHead.putInt(nDepsOffset);
                                        odexHead.putInt(depsLength);
                                        int nOptOffset = nDepsOffset + depsLength;
                                        int nOptPadding = 0;
                                        if (nOptOffset % 8 != 0) {
                                            nOptPadding = 8 - (nOptOffset % 8);
                                            nOptOffset += nOptPadding;
                                        }
                                        odexHead.putInt(nOptOffset);
                                        odexHead.putInt(optLength);
                                        odexHead.putInt(flags);
                                        odexHead.putInt(checksum);
                                        odexHead.position(0);
                                        channel2.write(odexHead);

                                        // copy dex
                                        channel.position(pos + dexOffset);
                                        copy(channel, channel2, copyBuff, fileSize);

                                        if (nDepsPadding != 0) {
                                            channel2.write(ByteBuffer.allocate(nDepsPadding));
                                        }
                                        // copy deps
                                        channel.position(pos + depsOffset);
                                        copy(channel, channel2, copyBuff, depsLength);

                                        if (nOptPadding != 0) {
                                            channel2.write(ByteBuffer.allocate(nOptPadding));
                                        }
                                        // copy opts
                                        channel.position(pos + optOffset);
                                        copy(channel, channel2, copyBuff, optLength);
                                    }
                                }
                            }
                        }
                    }

                }
            }
        }",iterator
remain,"{
        int remain = fileSize;

        while (remain > 0) {
            copyBuff.rewind();
            copyBuff.limit(Math.min(remain, copyBuff.capacity()));
            int read = channel.read(copyBuff);
            copyBuff.position(0);
            channel2.write(copyBuff);
            remain -= read;
        }

    }",loop_control
count,"{
            long position = channel.position();
            //System.out.printf(""load @%x\n"", position);
            int count = channel.read(buffer);
            if (count <= 0) {
                break;
            }
            int s = count / 4;
            for (int i = 0; i < s; i++) {
                int u4 = intBuffer.get(i);
                if (u4 == 0x0a796564) {// dey
                    if (i + 1 < s) {
                        int v4 = intBuffer.get(i + 1);
                        if (v4 == 0x00363330 || v4 == 0x00353330) {
                            possibleOdexs.add(position + 4 * i);
                            System.err.println(String.format(""> Possible %08x | %08x %08x"", position + i * 4, u4, v4));
                        }
                    } else {
                        possibleOdexs.add(position + 4 * i);
                        System.err.println(String.format(""> Possible %08x | %08x"", position + i * 4, u4));
                    }
                }
            }
            buffer.position(0);
            intBuffer.position(0);
        }",break_loop_control
i,"for (int i = 0; i < s; i++) {
                int u4 = intBuffer.get(i);
                if (u4 == 0x0a796564) {// dey
                    if (i + 1 < s) {
                        int v4 = intBuffer.get(i + 1);
                        if (v4 == 0x00363330 || v4 == 0x00353330) {
                            possibleOdexs.add(position + 4 * i);
                            System.err.println(String.format(""> Possible %08x | %08x %08x"", position + i * 4, u4, v4));
                        }
                    } else {
                        possibleOdexs.add(position + 4 * i);
                        System.err.println(String.format(""> Possible %08x | %08x"", position + i * 4, u4));
                    }
                }
            }",loop_control
e,"for (Enumeration<? extends ZipEntry> e = zip.entries(); e.hasMoreElements(); ) {
                ZipEntry zipEntry = e.nextElement();
                zos.putNextEntry(new ZipEntry(zipEntry.getName()));
                if (!zipEntry.isDirectory()) {
                    try (InputStream is = zip.getInputStream(zipEntry)) {
                        if (zipEntry.getName().endsWith("".class"")) {
                            ClassReader cr = new ClassReader(is);
                            ClassWriter cw = new ClassWriter(0);
                            ClassVisitor cv = new ClassVisitor(Opcodes.ASM4, cw) {
                                @Override
                                public void visit(int version, int access, String name, String signature, String superName, String[] interfaces) {
                                    super.visit(jVersion, access, name, signature, superName, interfaces);
                                }
                            };
                            cr.accept(cv, ClassReader.EXPAND_FRAMES|ClassReader.SKIP_FRAMES);
                            zos.write(cw.toByteArray());
                        } else {
                            for (int c = is.read(buff); c > 0; c = is.read(buff)) {
                                zos.write(buff, 0, c);
                            }
                        }
                    }

                }
                zos.closeEntry();
            }",iterator
c,"for (int c = is.read(buff); c > 0; c = is.read(buff)) {
                                zos.write(buff, 0, c);
                            }",maybe_loop_control
e,"for (Map.Entry<DexMethodNode, Exception> e : exceptionMap.entrySet()) {
            DexMethodNode dexMethodNode = e.getKey();
            Exception ex = e.getValue();
            writer.newLine();
            writer.write(""================= "" + i++ + "" ==================="");
            writer.newLine();
            dumpMethod(writer, dexMethodNode, ex);
        }",iterator
key,"for (String key : properties.stringPropertyNames()) {
            if (key.startsWith(""java."") && !key.toLowerCase().contains(""pass"")) {
                writer.append(key).append("": "").append(properties.getProperty(key));
                writer.newLine();
            }
        }",iterator
ex,"for (Exception ex : fileExceptions) {
            ex.printStackTrace(p);
        }",iterator
e,"for (com.googlecode.d2j.util.zip.ZipEntry e : zipFile.entries()) {
                    ZipEntry nEntry = new ZipEntry(e.getName());

                    nEntry.setMethod(e.getMethod() == com.googlecode.d2j.util.zip.ZipEntry.STORED ? ZipEntry.STORED
                            : ZipEntry.DEFLATED);
                    zos.putNextEntry(nEntry);

                    if (!nEntry.isDirectory()) {
                        try (InputStream is = zipFile.getInputStream(e)) {
                            while (true) {
                                int c = is.read(buffer);
                                if (c < 0) {
                                    break;
                                }
                                zos.write(buffer, 0, c);
                            }
                        }
                    }
                    zos.closeEntry();
                }",iterator
c,"{
                                int c = is.read(buffer);
                                if (c < 0) {
                                    break;
                                }
                                zos.write(buffer, 0, c);
                            }",break_loop_control
fileName,"for (String fileName : remainingArgs) {
                Path file = currentDir.resolve(getBaseName(new File(fileName).toPath()) + ""-dex2jar.jar"");
                if (Files.exists(file) && !forceOverwrite) {
                    System.err.println(file + "" exists, use --force to overwrite"");
                    return;
                }
            }",iterator
fileName,"for (String fileName : remainingArgs) {
            // long baseTS = System.currentTimeMillis();
            String baseName = getBaseName(new File(fileName).toPath());
            Path file = output == null ? currentDir.resolve(baseName + ""-dex2jar.jar"") : output;
            System.err.println(""dex2jar "" + fileName + "" -> "" + file);

            BaseDexFileReader reader = MultiDexFileReader.open(Files.readAllBytes(new File(fileName).toPath()));
            BaksmaliBaseDexExceptionHandler handler = notHandleException ? null : new BaksmaliBaseDexExceptionHandler();
            Dex2jar.from(reader).withExceptionHandler(handler).reUseReg(reuseReg).topoLogicalSort()
                    .skipDebug(!debugInfo).optimizeSynchronized(this.optmizeSynchronized).printIR(printIR)
                    .noCode(noCode).skipExceptions(skipExceptions).to(file);

            if (!notHandleException) {
                if (handler.hasException()) {
                    Path errorFile = exceptionFile == null ? currentDir.resolve(baseName + ""-error.zip"")
                            : exceptionFile;
                    System.err.println(""Detail Error Information in File "" + errorFile);
                    System.err.println(BaksmaliBaseDexExceptionHandler.REPORT_MESSAGE);
                    handler.dump(errorFile, orginalArgs);
                }
            }
            // long endTS = System.currentTimeMillis();
            // System.err.println(String.format(""%.2f"", (float) (endTS - baseTS) / 1000));
        }",iterator
file,"for (String fileName : remainingArgs) {
                Path file = currentDir.resolve(getBaseName(new File(fileName).toPath()) + ""-dex2jar.jar"");
                if (Files.exists(file) && !forceOverwrite) {
                    System.err.println(file + "" exists, use --force to overwrite"");
                    return;
                }
            }",break_loop_control
file,"for (String fileName : remainingArgs) {
            // long baseTS = System.currentTimeMillis();
            String baseName = getBaseName(new File(fileName).toPath());
            Path file = output == null ? currentDir.resolve(baseName + ""-dex2jar.jar"") : output;
            System.err.println(""dex2jar "" + fileName + "" -> "" + file);

            BaseDexFileReader reader = MultiDexFileReader.open(Files.readAllBytes(new File(fileName).toPath()));
            BaksmaliBaseDexExceptionHandler handler = notHandleException ? null : new BaksmaliBaseDexExceptionHandler();
            Dex2jar.from(reader).withExceptionHandler(handler).reUseReg(reuseReg).topoLogicalSort()
                    .skipDebug(!debugInfo).optimizeSynchronized(this.optmizeSynchronized).printIR(printIR)
                    .noCode(noCode).skipExceptions(skipExceptions).to(file);

            if (!notHandleException) {
                if (handler.hasException()) {
                    Path errorFile = exceptionFile == null ? currentDir.resolve(baseName + ""-error.zip"")
                            : exceptionFile;
                    System.err.println(""Detail Error Information in File "" + errorFile);
                    System.err.println(BaksmaliBaseDexExceptionHandler.REPORT_MESSAGE);
                    handler.dump(errorFile, orginalArgs);
                }
            }
            // long endTS = System.currentTimeMillis();
            // System.err.println(String.format(""%.2f"", (float) (endTS - baseTS) / 1000));
        }",break_loop_control
forceOverwrite,"{
            if (Files.exists(output) && !forceOverwrite) {
                System.err.println(output + "" exists, use --force to overwrite"");
                return;
            }
        }",break_loop_control
forceOverwrite,"for (String fileName : remainingArgs) {
                Path file = currentDir.resolve(getBaseName(new File(fileName).toPath()) + ""-dex2jar.jar"");
                if (Files.exists(file) && !forceOverwrite) {
                    System.err.println(file + "" exists, use --force to overwrite"");
                    return;
                }
            }",break_loop_control
str,"for (String str : remainingArgs) {
                Path p = new File(str).toPath();
                System.err.println(p + "" -> "" + output);
                if (Files.isDirectory(p)) {
                    invocationWeaver.wave(p, outRoot);
                } else {
                    try (FileSystem fs2 = openZip(p)) {
                        invocationWeaver.wave(fs2.getPath(""/""), outRoot);
                    }
                }
            }",iterator
it,"for (Iterator<MethodNode> it = cn.methods.iterator(); it.hasNext(); ) {
            MethodNode m = it.next();
            if (m.instructions == null) {
                continue;
            }
            key.owner = cn.name;
            key.name = m.name;
            key.desc = m.desc;
            if (map.containsKey(key)) {
                if (deleteMethod) {
                    it.remove();
                }
                continue;
            }


            if (false && verbose) {
                System.out.println();
                System.out.println(""==============="");
                System.out.println(""on method "" + cn.name + "";->"" + m.name + m.desc);
            }

            boolean find = false;
            // search for the decrypt method
            for (AbstractInsnNode p = m.instructions.getFirst(); p != null; p = p.getNext()) {
                if (p.getOpcode() == Opcodes.INVOKESTATIC) {
                    MethodInsnNode mn = (MethodInsnNode) p;
                    key.owner = mn.owner;
                    key.name = mn.name;
                    key.desc = mn.desc;
                    MethodConfig config = map.get(key);
                    if (config != null) {
                        find = true;
                    }
                }
            }
            if (find) {
                try {
                    // copy m to m2 for cleanup debug info
                    MethodNode m2 = new MethodNode();
                    m2.tryCatchBlocks = new ArrayList<>();
                    m2.name = m.name;
                    m2.access = m.access;
                    m2.desc = m.desc;
                    m.accept(m2);
                    cleanDebug(m2);
                    // convert m2 to ir
                    IrMethod irMethod = J2IRConverter.convert(cn.name, m2);
                    // opt and decrypt
                    optAndDecrypt(irMethod, map);

                    // convert ir to m3
                    MethodNode m3 = new MethodNode();
                    m3.tryCatchBlocks = new ArrayList<>();
                    new IR2JConverter()
                            .ir(irMethod)
                            .asm(m3)
                            .convert();

                    // copy back m3 to m
                    m.maxLocals = -1;
                    m.maxLocals = -1;
                    m.instructions = m3.instructions;
                    m.tryCatchBlocks = m3.tryCatchBlocks;
                    m.localVariables = null;
                    changed = true;
                } catch (Exception ex) {
                    if(verbose) {
                        ex.printStackTrace();
                    }
                }
            }
        }",iterator
p,"for (AbstractInsnNode p = m.instructions.getFirst(); p != null; p = p.getNext()) {
                if (p.getOpcode() == Opcodes.INVOKESTATIC) {
                    MethodInsnNode mn = (MethodInsnNode) p;
                    key.owner = mn.owner;
                    key.name = mn.name;
                    key.desc = mn.desc;
                    MethodConfig config = map.get(key);
                    if (config != null) {
                        find = true;
                    }
                }
            }",maybe_loop_control
it,"for (Iterator<MethodNode> it = cn.methods.iterator(); it.hasNext(); ) {
            MethodNode m = it.next();
            if (m.instructions == null) {
                continue;
            }
            key.owner = cn.name;
            key.name = m.name;
            key.desc = m.desc;
            if (map.containsKey(key)) {
                if (deleteMethod) {
                    it.remove();
                }
                continue;
            }

            if (false && verbose) {
                System.out.println();
                System.out.println(""==============="");
                System.out.println(""on method "" + cn.name + "";->"" + m.name + m.desc);
            }

            AbstractInsnNode p = m.instructions.getFirst();
            while (p != null) {
                if (p.getOpcode() == Opcodes.INVOKESTATIC) {
                    MethodInsnNode mn = (MethodInsnNode) p;
                    key.owner = mn.owner;
                    key.name = mn.name;
                    key.desc = mn.desc;
                    MethodConfig config = map.get(key);
                    if (config != null) {
                        //here we are, given that the decryption method is successfully recognised
                        Method jmethod = config.jmethod;
                        try {
                            int pSize = jmethod.getParameterTypes().length;
                            // arguments' list. each parameter's value is retrieved by reading bytecode backwards, starting from the INVOKESTATIC statement
                            Object[] as = readArgumentValues(mn, jmethod, pSize);
                            if (verbose) {
                                System.out.println("" > calling "" + jmethod + "" with arguments "" + v(as));
                            }
                            //decryption routine invocation
                            String newValue = (String) jmethod.invoke(null, as);
                            if (verbose) {
                                System.out.println(""  -> "" + Escape.v(newValue));
                            }
                            //LDC statement generation
                            LdcInsnNode nLdc = new LdcInsnNode(newValue);
                            //insertion of the decrypted string's LDC statement, after INVOKESTATIC statement
                            m.instructions.insert(mn, nLdc);
                            //removal of INVOKESTATIC and previous push statements
                            removeInsts(m, mn, pSize);
                            p = nLdc;
                            changed = true;
                        } catch (InvocationTargetException ex){
                            if(verbose){
                                ex.getTargetException().printStackTrace();
                            }
                        } catch (Exception ex) {
                            if (verbose) {
                                ex.printStackTrace();
                            }
                        }
                    }
                }
                p = p.getNext();
            }
        }",iterator
p,"for (Iterator<MethodNode> it = cn.methods.iterator(); it.hasNext(); ) {
            MethodNode m = it.next();
            if (m.instructions == null) {
                continue;
            }
            key.owner = cn.name;
            key.name = m.name;
            key.desc = m.desc;
            if (map.containsKey(key)) {
                if (deleteMethod) {
                    it.remove();
                }
                continue;
            }

            if (false && verbose) {
                System.out.println();
                System.out.println(""==============="");
                System.out.println(""on method "" + cn.name + "";->"" + m.name + m.desc);
            }

            AbstractInsnNode p = m.instructions.getFirst();
            while (p != null) {
                if (p.getOpcode() == Opcodes.INVOKESTATIC) {
                    MethodInsnNode mn = (MethodInsnNode) p;
                    key.owner = mn.owner;
                    key.name = mn.name;
                    key.desc = mn.desc;
                    MethodConfig config = map.get(key);
                    if (config != null) {
                        //here we are, given that the decryption method is successfully recognised
                        Method jmethod = config.jmethod;
                        try {
                            int pSize = jmethod.getParameterTypes().length;
                            // arguments' list. each parameter's value is retrieved by reading bytecode backwards, starting from the INVOKESTATIC statement
                            Object[] as = readArgumentValues(mn, jmethod, pSize);
                            if (verbose) {
                                System.out.println("" > calling "" + jmethod + "" with arguments "" + v(as));
                            }
                            //decryption routine invocation
                            String newValue = (String) jmethod.invoke(null, as);
                            if (verbose) {
                                System.out.println(""  -> "" + Escape.v(newValue));
                            }
                            //LDC statement generation
                            LdcInsnNode nLdc = new LdcInsnNode(newValue);
                            //insertion of the decrypted string's LDC statement, after INVOKESTATIC statement
                            m.instructions.insert(mn, nLdc);
                            //removal of INVOKESTATIC and previous push statements
                            removeInsts(m, mn, pSize);
                            p = nLdc;
                            changed = true;
                        } catch (InvocationTargetException ex){
                            if(verbose){
                                ex.getTargetException().printStackTrace();
                            }
                        } catch (Exception ex) {
                            if (verbose) {
                                ex.printStackTrace();
                            }
                        }
                    }
                }
                p = p.getNext();
            }
        }",maybe_loop_control
i,"for (int i = 0; i < args.length; i++) {
                                args[i] = convertIr2Jobj(ie.getOps()[i], ie.getArgs()[i]);
                            }",loop_control
obj,"for (Object obj : vs) {
            if (first) {
                first = false;
            } else {
                sb.append("","");
            }
            if(obj instanceof String) {
                sb.append(Escape.v(obj));
            }else {
                sb.append(obj);
            }
        }",iterator
i,"for (int i = 0; i < b.length; i++) {
                            b[i] = ((Number) Array.get(obj, i)).intValue() != 0;
                        }",loop_control
i,"for (int i = 0; i < b.length; i++) {
                        Object obj = ((Constant) value.getOps()[i]).value;
                        if (obj instanceof Boolean) {
                            b[i] = ((Boolean) obj).booleanValue();
                        } else {
                            b[i] = ((Number) obj).intValue() != 0;
                        }
                    }",loop_control
i,"for (int i = 0; i < b.length; i++) {
                            b[i] = ((Number) Array.get(obj, i)).byteValue();
                        }",loop_control
i,"for (int i = 0; i < b.length; i++) {
                        Object obj = ((Constant) value.getOps()[i]).value;
                        b[i] = ((Number) obj).byteValue();
                    }",loop_control
i,"for (int i = 0; i < b.length; i++) {
                            b[i] = ((Number) Array.get(obj, i)).shortValue();
                        }",loop_control
i,"for (int i = 0; i < b.length; i++) {
                        Object obj = ((Constant) value.getOps()[i]).value;
                        b[i] = ((Number) obj).shortValue();
                    }",loop_control
i,"for (int i = 0; i < b.length; i++) {
                            b[i] = (char) ((Number) Array.get(obj, i)).intValue();
                        }",loop_control
i,"for (int i = 0; i < b.length; i++) {
                        Object obj = ((Constant) value.getOps()[i]).value;
                        b[i] = obj instanceof Character ? ((Character) obj).charValue() : (char) ((Number) obj).intValue();
                    }",loop_control
i,"for (int i = 0; i < b.length; i++) {
                            b[i] = ((Number) Array.get(obj, i)).intValue();
                        }",loop_control
i,"for (int i = 0; i < b.length; i++) {
                        Object obj = ((Constant) value.getOps()[i]).value;
                        b[i] = ((Number) obj).intValue();
                    }",loop_control
i,"for (int i = 0; i < b.length; i++) {
                            b[i] = ((Number) Array.get(obj, i)).longValue();
                        }",loop_control
i,"for (int i = 0; i < b.length; i++) {
                        Object obj = ((Constant) value.getOps()[i]).value;
                        b[i] = ((Number) obj).longValue();
                    }",loop_control
i,"for (int i = 0; i < b.length; i++) {
                            b[i] = (char) ((Number) Array.get(obj, i)).intValue();
                        }",loop_control
i,"for (int i = 0; i < b.length; i++) {
                        Object obj = ((Constant) value.getOps()[i]).value;
                        b[i] = obj instanceof Float ? ((Float) obj).floatValue() : Float.intBitsToFloat(((Number) obj).intValue());
                    }",loop_control
i,"for (int i = 0; i < b.length; i++) {
                            b[i] = (char) ((Number) Array.get(obj, i)).intValue();
                        }",loop_control
i,"for (int i = 0; i < b.length; i++) {
                        Object obj = ((Constant) value.getOps()[i]).value;
                        b[i] = obj instanceof Double ? ((Double) obj).doubleValue() : Double.longBitsToDouble(((Number) obj).longValue());
                    }",loop_control
i,"for (int i = 0; i < b.length; i++) {
                        Object obj = ((Constant) value.getOps()[i]).value;
                        if (obj instanceof String) {
                            b[i] = (String) obj;
                        } else if (Constant.Null.equals(obj)) {
                            b[i] = null;
                        } else {
                            throw new RuntimeException();
                        }
                    }",loop_control
s,"for (String s : args) {
            sb.append(s);
        }",iterator
p,"for (AbstractInsnNode p = mn.instructions.getFirst(); p != null; ) {
            if (p.getType() == AbstractInsnNode.LINE) {
                AbstractInsnNode q = p.getNext();
                mn.instructions.remove(p);
                p = q;
            } else {
                p = p.getNext();
            }
        }",maybe_loop_control
i,"for (int i = 0; i < pSize; i++) {
            m.instructions.remove(mn.getPrevious());
        }",loop_control
i,"for (int i = pSize - 1; i >= 0; i--) {
            q = q.getPrevious();
            Object object = readCst(q);
            as[i] = convert(object, jmethod.getParameterTypes()[i]);
        }",loop_control
i,"for (int i = 0; i < list.size(); i++) {
            urls[i] = new File(list.get(i)).toURI().toURL();
        }",loop_control
config,"for (MethodConfig config : methodConfigs) {
            Method jmethod;
            try {
                Class<?> clz = cl.loadClass(config.owner.replace('/', '.'));
                if (clz == null) {
                    System.err.println(""clz is null:"" + config.owner);
                }
                jmethod = findAnyMethodMatch(clz, config.name,
                        toJavaType(Type.getArgumentTypes(config.desc)));
            } catch (Exception ex) {
                System.err.println(""can't load method: L"" + config.owner + "";->"" + config.name + config.desc);
                throw ex;
            }
            if (jmethod != null) {
                jmethod.setAccessible(true);
                config.jmethod = jmethod;
                map.put(config, config);
            } else {
                throw new NoSuchMethodException(""can't find method "" + config.name + config.desc + "" on class "" + config.owner + "" or its parent"");
            }
        }",iterator
line,"for (String line : Files.readAllLines(this.method, StandardCharsets.UTF_8)) {
                if (line.length() == 0 || line.startsWith(""#"")) {
                    continue;
                }
                methodConfigs.add(this.build(line));
            }",iterator
i,"for (int i = 0; i < type_list.length; i++) {
                    switch (type_list[i]) {
                        case ""boolean"":
                            sb.append(""Z"");
                            break;
                        case ""byte"":
                            sb.append(""B"");
                            break;
                        case ""short"":
                            sb.append(""S"");
                            break;
                        case ""char"":
                            sb.append(""C"");
                            break;
                        case ""int"":
                            sb.append(""I"");
                            break;
                        case ""long"":
                            sb.append(""J"");
                            break;
                        case ""float"":
                            sb.append(""F"");
                            break;
                        case ""double"":
                            sb.append(""D"");
                            break;
                        case ""string"":
                            sb.append(""Ljava/lang/String;"");
                            break;

                        default:
                            throw new RuntimeException(""not support type "" + type_list[i] + "" on -t/--arg-types"");
                    }
                }",loop_control
itf,"for (Class<?> itf : itfs) {
                Method m = findAnyMethodMatch(itf, name, classes);
                if (m != null) {
                    return m;
                }
            }",iterator
i,"for (int i = 0; i < pt.length; i++) {
            jt[i] = toJavaType(pt[i]);
        }",loop_control
e,"for (ZipArchiveEntry e = zis.getNextZipEntry(); e != null; e = zis.getNextZipEntry()) {
            e.getGeneralPurposeBit().useEncryption(false);
            if (!e.isDirectory()) {
                zis.read();
                System.out.println(e.getName());
            }
        }",maybe_loop_control
e,"for (com.googlecode.d2j.util.zip.ZipEntry e : zip.entries()) {
                System.out.println(e);
                if (!e.isDirectory()) {
                    zip.getInputStream(e).read();
                }
            }",iterator
i,"for (int i = 0; i < size; i++) {
                int type = in.getShort() & 0xFFFF;
                in.getShort(); // unused;
                int item_size = in.getInt();
                int item_offset = in.getInt();
                switch (type) {
                case TYPE_CALL_SITE_ID_ITEM:
                    call_site_ids_off = item_offset;
                    call_site_ids_size = item_size;
                    break;
                case TYPE_METHOD_HANDLE_ITEM:
                    method_handle_ids_off = item_offset;
                    method_handle_ids_size = item_size;
                    break;
                default:
                    break;
                }
            }",loop_control
c,"for (int c = is.read(buff); c > 0; c = is.read(buff)) {
            out.write(buff, 0, c);
        }",maybe_loop_control
i,"for (int i = 0; i < deep + 1; i++) {
            sb.append(""."");
        }",loop_control
j,"for (int j = 0; j < length; j++) {
            value |= ((long) (0xFF & in.get())) << (j * 8);
        }",loop_control
j,"for (int j = 0; j < length; j++) {
            value |= ((long) (0xFF & in.get())) << (j * 8);
        }",loop_control
i,"for (int i = 0; i < bytes; ++i) {
            result |= ((long) (0xFF & in.get())) << (i * 8);
        }",loop_control
b,"{
        int value = 0;
        int count = 0;
        int b = in.get();
        while ((b & 0x80) != 0) {
            value |= (b & 0x7f) << count;
            count += 7;
            b = in.get();
        }
        value |= (b & 0x7f) << count;
        return value;
    }",maybe_loop_control
inp,"{
            int inp = in.get();
            vln |= (inp & 0x7F) << bitpos;
            bitpos += 7;
            if ((inp & 0x80) == 0) {
                break;
            }
        }",break_loop_control
paramType,"for (String paramType : method.getParameterTypes()) {
            if (paramType.equals(""J"") || paramType.equals(""D"")) {
                argsSize += 2;
            } else {
                argsSize += 1;
            }
        }",iterator
paramType,"for (int i = 0; i < szParams; i++) {
            String paramType = params[i];
            LocalEntry le;

            int nameIdx = readStringIndex(in);
            String name = getString(nameIdx);
            le = new LocalEntry(name, paramType);
            lastEntryForReg[curReg] = le;
            if (name != null) {
                dcv.visitParameterName(i, name);
            }
            DEBUG_DEBUG(""v%d :%s, %s"", curReg, name, paramType);
            curReg += 1;
            if (paramType.equals(""J"") || paramType.equals(""D"")) {
                curReg += 1;
            }
        }",iterator
i,"for (int i = 0; i < szParams; i++) {
            String paramType = params[i];
            LocalEntry le;

            int nameIdx = readStringIndex(in);
            String name = getString(nameIdx);
            le = new LocalEntry(name, paramType);
            lastEntryForReg[curReg] = le;
            if (name != null) {
                dcv.visitParameterName(i, name);
            }
            DEBUG_DEBUG(""v%d :%s, %s"", curReg, name, paramType);
            curReg += 1;
            if (paramType.equals(""J"") || paramType.equals(""D"")) {
                curReg += 1;
            }
        }",loop_control
cid,"for (int cid = 0; cid < class_defs_size; cid++) {
            in.position(cid * 32);
            String className = this.getType(in.getInt());
            names.add(className);
        }",loop_control
cid,"for (int cid = 0; cid < class_defs_size; cid++) {
            accept(dv, cid, config);
        }",loop_control
i,"for (int i = 0; i < field_annotation_size; i++) {
                    int field_idx = annotationsDirectoryItemIn.getInt();
                    int field_annotations_offset = annotationsDirectoryItemIn.getInt();
                    fieldAnnotationPositions.put(field_idx, field_annotations_offset);
                }",loop_control
i,"for (int i = 0; i < method_annotation_size; i++) {
                    int method_idx = annotationsDirectoryItemIn.getInt();
                    int method_annotation_offset = annotationsDirectoryItemIn.getInt();
                    methodAnnotationPositions.put(method_idx, method_annotation_offset);
                }",loop_control
i,"for (int i = 0; i < parameter_annotation_size; i++) {
                    int method_idx = annotationsDirectoryItemIn.getInt();
                    int parameter_annotation_offset = annotationsDirectoryItemIn.getInt();
                    paramAnnotationPositions.put(method_idx, parameter_annotation_offset);
                }",loop_control
i,"for (int i = 0; i < static_fields; i++) {
                        Object value = null;
                        if (constant != null && i < constant.length) {
                            value = constant[i];
                        }
                        lastIndex = acceptField(in, lastIndex, dcv, fieldAnnotationPositions, value, config);
                    }",loop_control
i,"for (int i = 0; i < instance_fields; i++) {
                    lastIndex = acceptField(in, lastIndex, dcv, fieldAnnotationPositions, null, config);
                }",loop_control
i,"for (int i = 0; i < direct_methods; i++) {
                    lastIndex = acceptMethod(in, lastIndex, dcv, methodAnnotationPositions, paramAnnotationPositions,
                            config, firstMethod);
                    firstMethod = false;
                }",loop_control
i,"for (int i = 0; i < virtual_methods; i++) {
                    lastIndex = acceptMethod(in, lastIndex, dcv, methodAnnotationPositions, paramAnnotationPositions,
                            config, firstMethod);
                    firstMethod = false;
                }",loop_control
i,"for (int i = 0; i < size; i++) {
            constant[i] = readEncodedValue(in);
        }",loop_control
j,"for (int j = 0; j < size; j++) {
            int annotation_off = in.getInt();
            read_annotation_item(annotation_off, daa);
        }",loop_control
i,"for (int i = 0; i < size; i++) {
            int name_idx = readULeb128i(in);
            String nameString = getString(name_idx);
            Object value = readEncodedValue(in);
            ann.items.add(new DexAnnotationNode.Item(nameString, value));
        }",loop_control
i,"for (int i = 0; i < size; i++) {
            types[i] = getType(0xFFFF & typeListIn.getShort());
        }",loop_control
j,"for (int j = 0; j < size; j++) {
            int param_annotation_offset = in.getInt();
            if (param_annotation_offset == 0) {
                continue;
            }
            DexAnnotationAble dpav = dmv.visitParameterAnnotation(j);
            try {
                if (dpav != null) {
                    read_annotation_set_item(param_annotation_offset, dpav);
                }
            } catch (Exception e) {
                throw new DexException(e, ""While accepting parameter annotation in parameter: [%d]"", j);
            }
        }",loop_control
q,"{
        Queue<Integer> q = new LinkedList<Integer>();
        q.add(0);
        q.addAll(handlers);
        handlers.clear();
        while (!q.isEmpty()) {
            int offset = q.poll();
            if (nextBit.get(offset)) {
                continue;
            } else {
                nextBit.set(offset);
            }
            try {
                travelInsn(labelsMap, q, insns, offset);
            } catch (IndexOutOfBoundsException indexOutOfRange){
                badOps.set(offset);
                WARN(""GLITCH: %04x %s | not enough space for reading instruction"", offset, method.toString());
            } catch (BadOpException badOp){
                badOps.set(offset);
                WARN(""GLITCH: %04x %s | %s"", offset, method.toString(), badOp.getMessage());
            }
        }
    }",maybe_loop_control
i,"for (int i = 0; i < size; i++) {
                                target = offset + sint(insns, b + i * 4);
                                if (target < 0 || target * 2 > insns.length ) {
                                    throw new BadOpException(""jump out of insns %s -> %04x"", op, target);
                                }
                                q.add(target);
                                order(labelsMap, target);
                            }",loop_control
i,"for (int i = 0; i < size; i++) {
                                target = offset + sint(insns, b + i * 4);
                                if (target < 0 || target * 2 > insns.length ) {
                                    throw new BadOpException(""jump out of insns %s -> %04x"", op, target);
                                }
                                q.add(target);
                                order(labelsMap, target);
                            }",loop_control
i,"for (int i = 0; i < tries_size; i++) { // try_item
            int start_addr = in.getInt();
            int insn_count = 0xFFFF & in.getShort();
            int handler_offset = 0xFFFF & in.getShort();
            if (start_addr > insn_size) {
                continue;
            }
            order(labelsMap, start_addr);
            int end = start_addr + insn_count;
            order(labelsMap, end);

            handlerIn.position(encoded_catch_handler_list + handler_offset);// move to encoded_catch_handler

            boolean catchAll = false;
            int listSize = (int) readLeb128i(handlerIn);
            int handlerCount = listSize;
            if (listSize <= 0) {
                listSize = -listSize;
                handlerCount = listSize + 1;
                catchAll = true;
            }
            DexLabel labels[] = new DexLabel[handlerCount];
            String types[] = new String[handlerCount];
            for (int k = 0; k < listSize; k++) {
                int type_id = (int) readULeb128i(handlerIn);
                int handler = (int) readULeb128i(handlerIn);
                order(labelsMap, handler);
                handlers.add(handler);
                types[k] = getType(type_id);
                labels[k] = labelsMap.get(handler);
            }
            if (catchAll) {
                int handler = (int) readULeb128i(handlerIn);
                order(labelsMap, handler);
                handlers.add(handler);
                labels[listSize] = labelsMap.get(handler);
            }
            dcv.visitTryCatch(labelsMap.get(start_addr), labelsMap.get(end), labels, types);
        }",loop_control
k,"for (int k = 0; k < listSize; k++) {
                int type_id = (int) readULeb128i(handlerIn);
                int handler = (int) readULeb128i(handlerIn);
                order(labelsMap, handler);
                handlers.add(handler);
                types[k] = getType(type_id);
                labels[k] = labelsMap.get(handler);
            }",loop_control
nextLabelOffset,"{
        Iterator<Integer> labelOffsetIterator = labelsMap.keySet().iterator();
        Integer nextLabelOffset = labelOffsetIterator.hasNext() ? labelOffsetIterator.next() : null;
        Op[] values = Op.ops;
        for (int offset = nextInsn.nextSetBit(0); offset >= 0; offset = nextInsn.nextSetBit(offset + 1)) {
            // issue 65, a label may `inside` an instruction
            // visit all label with offset <= currentOffset
            while (nextLabelOffset != null) {
                if (nextLabelOffset <= offset) {
                    dcv.visitLabel(labelsMap.get(nextLabelOffset));
                    nextLabelOffset = labelOffsetIterator.hasNext() ? labelOffsetIterator.next() : null;
                } else {
                    // the label is after this instruction
                    break;
                }
            }

            if(badOps.get(offset)){
                dcv.visitStmt0R(Op.BAD_OP);
                continue;
            }

            int u1offset = offset * 2;
            int opcode = 0xFF & insns[u1offset];

            Op op = values[opcode];

            int a, b, c, target;
            switch (op.format) {
            // case kFmt00x: break;
            case kFmt10x:
                dcv.visitStmt0R(op);
                break;

            case kFmt11x:
                dcv.visitStmt1R(op, 0xFF & insns[u1offset + 1]);
                break;
            case kFmt12x:
                a = ubyte(insns, u1offset + 1);
                dcv.visitStmt2R(op, a & 0xF, a >> 4);
                break;
            // case kFmt20bc:break;
            case kFmt10t:
                target = offset + insns[u1offset + 1];
                dcv.visitJumpStmt(op, -1, -1, labelsMap.get(target));
                break;
            case kFmt20t:
                target = offset + sshort(insns, u1offset + 2);
                dcv.visitJumpStmt(op, -1, -1, labelsMap.get(target));
                break;
            case kFmt21t:
                target = offset + sshort(insns, u1offset + 2);
                dcv.visitJumpStmt(op, ubyte(insns, u1offset + 1), -1, labelsMap.get(target));
                break;
            case kFmt22t:
                target = offset + sshort(insns, u1offset + 2);
                a = ubyte(insns, u1offset + 1);
                b = a & 0x0F;
                c = a >> 4;
                boolean ignore = false;
                if (b == c) {
                    switch (op) {
                    case IF_EQ:
                    case IF_GE:
                    case IF_LE:
                        // means always jump, equals to goto
                        dcv.visitJumpStmt(Op.GOTO, 0, 0, labelsMap.get(target));
                        ignore = true;
                        break;
                    case IF_NE:
                    case IF_GT:
                    case IF_LT:
                        // means always not jump
                        ignore = true;
                        break;
                    default:
                        break;
                    }
                }
                if (!ignore) {
                    dcv.visitJumpStmt(op, b, c, labelsMap.get(target));
                }
                break;
            case kFmt30t:
                target = offset + sint(insns, u1offset + 2);
                dcv.visitJumpStmt(op, -1, -1, labelsMap.get(target));
                break;
            case kFmt31t:
                target = offset + sint(insns, u1offset + 2);
                a = ubyte(insns, u1offset + 1);
                int u1SwitchData = 2 * target;
                if (op == Op.FILL_ARRAY_DATA) {
                    int element_width = ushort(insns, u1SwitchData + 2);
                    int size = uint(insns, u1SwitchData + 4);
                    switch (element_width) {
                    case 1: {
                        byte[] data = new byte[size];
                        System.arraycopy(insns, u1SwitchData + 8, data, 0, size);
                        dcv.visitFillArrayDataStmt(op, a, data);
                    }
                        break;
                    case 2: {
                        short[] data = new short[size];
                        for (int i = 0; i < size; i++) {
                            data[i] = (short) sshort(insns, u1SwitchData + 8 + 2 * i);
                        }
                        dcv.visitFillArrayDataStmt(op, a, data);
                    }
                        break;
                    case 4: {
                        int[] data = new int[size];
                        for (int i = 0; i < size; i++) {
                            data[i] = sint(insns, u1SwitchData + 8 + 4 * i);
                        }
                        dcv.visitFillArrayDataStmt(op, a, data);
                    }
                        break;
                    case 8: {
                        long[] data = new long[size];
                        for (int i = 0; i < size; i++) {
                            int t = u1SwitchData + 8 + 8 * i;
                            long z = 0;
                            z |= ((long) ushort(insns, t + 0)) << 0;
                            z |= ((long) ushort(insns, t + 2)) << 16;
                            z |= ((long) ushort(insns, t + 4)) << 32;
                            z |= ((long) ushort(insns, t + 6)) << 48;
                            data[i] = z;
                        }
                        dcv.visitFillArrayDataStmt(op, a, data);
                    }
                        break;
                    }
                } else if (op == Op.SPARSE_SWITCH) {
                    int size = sshort(insns, u1SwitchData + 2);
                    int keys[] = new int[size];
                    DexLabel labels[] = new DexLabel[size];
                    int z = u1SwitchData + 4;
                    for (int i = 0; i < size; i++) {
                        keys[i] = sint(insns, z + i * 4);
                    }
                    z += size * 4;
                    for (int i = 0; i < size; i++) {
                        labels[i] = labelsMap.get(offset + sint(insns, z + i * 4));
                    }
                    dcv.visitSparseSwitchStmt(op, a, keys, labels);
                } else {
                    int size = sshort(insns, u1SwitchData + 2);
                    int first_key = sint(insns, u1SwitchData + 4);
                    DexLabel labels[] = new DexLabel[size];
                    int z = u1SwitchData + 8;
                    for (int i = 0; i < size; i++) {
                        labels[i] = labelsMap.get(offset + sint(insns, z));
                        z += 4;
                    }
                    dcv.visitPackedSwitchStmt(op, a, first_key, labels);
                }
                break;
            case kFmt21c:
                a = ubyte(insns, u1offset + 1);
                b = ushort(insns, u1offset + 2);
                switch (op.indexType) {
                case kIndexStringRef:
                    dcv.visitConstStmt(op, a, getString(b));
                    break;
                case kIndexFieldRef:
                    dcv.visitFieldStmt(op, a, -1, getField(b));
                    break;
                case kIndexTypeRef:
                    if (op == Op.CONST_CLASS) {
                        dcv.visitConstStmt(op, a, new DexType(getType(b)));
                    } else {
                        dcv.visitTypeStmt(op, a, -1, getType(b));
                    }
                    break;
                default:
                    break;
                }
                break;
            case kFmt22c:
                a = ubyte(insns, u1offset + 1);
                b = ushort(insns, u1offset + 2);
                switch (op.indexType) {
                case kIndexFieldRef:
                    dcv.visitFieldStmt(op, a & 0xF, a >> 4, getField(b));
                    break;
                case kIndexTypeRef:
                    dcv.visitTypeStmt(op, a & 0xF, a >> 4, getType(b));
                    break;
                default:
                    break;
                }
                break;
            case kFmt31c:
                if (op.indexType == InstructionIndexType.kIndexStringRef) {
                    a = ubyte(insns, u1offset + 1);
                    b = uint(insns, u1offset + 2);
                    dcv.visitConstStmt(op, a, getString(b));
                }
                break;
            case kFmt35c: {
                a = ubyte(insns, u1offset + 1);
                b = ushort(insns, u1offset + 2);
                int dc = ubyte(insns, u1offset + 4); // DC
                int fe = ubyte(insns, u1offset + 5); // FE

                int regs[] = new int[a >> 4];
                switch (a >> 4) {
                case 5:
                    regs[4] = a & 0xF;// G
                case 4:
                    regs[3] = 0xF & (fe >> 4);// F
                case 3:
                    regs[2] = 0xF & (fe >> 0);// E
                case 2:
                    regs[1] = 0xF & (dc >> 4);// D
                case 1:
                    regs[0] = 0xF & (dc >> 0);// C
                }
                if (op.indexType == InstructionIndexType.kIndexTypeRef) {
                    dcv.visitFilledNewArrayStmt(op, regs, getType(b));
                } else if (op.indexType == InstructionIndexType.kIndexCallSiteRef) {
                    Object[] callsite = getCallSite(b);
                    Object[] constArgs = Arrays.copyOfRange(callsite, 3, callsite.length);
                    dcv.visitMethodStmt(op, regs, (String) callsite[1], (Proto) callsite[2], (MethodHandle) callsite[0], constArgs);
                } else {
                    dcv.visitMethodStmt(op, regs, getMethod(b));
                }
            }
                break;
            case kFmt3rc: {
                a = ubyte(insns, u1offset + 1);
                b = ushort(insns, u1offset + 2);
                c = ushort(insns, u1offset + 4);
                int regs[] = new int[a];
                for (int i = 0; i < a; i++) {
                    regs[i] = c + i;
                }
                if (op.indexType == InstructionIndexType.kIndexTypeRef) {
                    dcv.visitFilledNewArrayStmt(op, regs, getType(b));
                } else if (op.indexType == InstructionIndexType.kIndexCallSiteRef) {
                    Object[] callsite = getCallSite(b);
                    Object[] constArgs = Arrays.copyOfRange(callsite, 3, callsite.length - 3);
                    dcv.visitMethodStmt(op, regs, (String) callsite[1], (Proto) callsite[2], (MethodHandle) callsite[0], constArgs);
                } else {
                    dcv.visitMethodStmt(op, regs, getMethod(b));
                }
            }
                break;
            case kFmt45cc: {
                a = ubyte(insns, u1offset + 1);
                b = ushort(insns, u1offset + 2);
                int dc = ubyte(insns, u1offset + 4); // DC
                int fe = ubyte(insns, u1offset + 5); // FE
                int h = ushort(insns, u1offset + 6);

                int regs[] = new int[a >> 4];
                switch (a >> 4) {
                case 5:
                    regs[4] = a & 0xF;// G
                case 4:
                    regs[3] = 0xF & (fe >> 4);// F
                case 3:
                    regs[2] = 0xF & (fe >> 0);// E
                case 2:
                    regs[1] = 0xF & (dc >> 4);// D
                case 1:
                    regs[0] = 0xF & (dc >> 0);// C
                }
                dcv.visitMethodStmt(op, regs, getMethod(b), getProto(h));
            }
            break;
            case kFmt4rcc: {
                a = ubyte(insns, u1offset + 1);
                b = ushort(insns, u1offset + 2);
                c = ushort(insns, u1offset + 4);
                int h = ushort(insns, u1offset + 6);
                int regs[] = new int[a];
                for (int i = 0; i < a; i++) {
                    regs[i] = c + i;
                }
                dcv.visitMethodStmt(op, regs, getMethod(b), getProto(h));
            }
            break;
            case kFmt22x:
                a = ubyte(insns, u1offset + 1);
                b = ushort(insns, u1offset + 2);
                dcv.visitStmt2R(op, a, b);
                break;
            case kFmt23x:
                a = ubyte(insns, u1offset + 1);
                b = ubyte(insns, u1offset + 2);
                c = ubyte(insns, u1offset + 3);
                dcv.visitStmt3R(op, a, b, c);
                break;
            case kFmt32x:
                a = ushort(insns, u1offset + 2);
                b = ushort(insns, u1offset + 4);
                dcv.visitStmt2R(op, a, b);
                break;
            case kFmt11n:
                a = insns[u1offset + 1];
                dcv.visitConstStmt(op, a & 0xF, a >> 4);
                break;
            case kFmt21h:
                a = ubyte(insns, u1offset + 1);
                b = sshort(insns, u1offset + 2);
                if (op == Op.CONST_HIGH16) {
                    dcv.visitConstStmt(op, a, b << 16);
                } else {
                    dcv.visitConstStmt(op, a, ((long) b) << 48);
                }
                break;
            case kFmt21s:
                a = ubyte(insns, u1offset + 1);
                b = sshort(insns, u1offset + 2);
                if (op == Op.CONST_16) {
                    dcv.visitConstStmt(op, a, b);
                } else {
                    dcv.visitConstStmt(op, a, (long) b);
                }
                break;
            case kFmt22b:
                a = ubyte(insns, u1offset + 1);
                b = ubyte(insns, u1offset + 2);
                c = sbyte(insns, u1offset + 3);
                dcv.visitStmt2R1N(op, a, b, c);
                break;
            case kFmt22s:
                a = ubyte(insns, u1offset + 1);
                b = sshort(insns, u1offset + 2);
                dcv.visitStmt2R1N(op, a & 0xF, a >> 4, b);
                break;
            // case kFmt22cs:break;
            case kFmt31i:
                a = ubyte(insns, u1offset + 1);
                b = sint(insns, u1offset + 2);
                if (op == Op.CONST) {
                    dcv.visitConstStmt(op, a, b);
                } else {
                    dcv.visitConstStmt(op, a, (long) b);
                }
                break;
            case kFmt51l:
                a = ubyte(insns, u1offset + 1);
                long z = 0;
                z |= ((long) ushort(insns, u1offset + 2)) << 0;
                z |= ((long) ushort(insns, u1offset + 4)) << 16;
                z |= ((long) ushort(insns, u1offset + 6)) << 32;
                z |= ((long) ushort(insns, u1offset + 8)) << 48;
                dcv.visitConstStmt(op, a, z);
                break;
            }
        }

        while (nextLabelOffset != null) {
            dcv.visitLabel(labelsMap.get(nextLabelOffset));
            if (labelOffsetIterator.hasNext()) {
                nextLabelOffset = labelOffsetIterator.next();
            } else {
                break;
            }
        }
    }",maybe_loop_control
nextLabelOffset,"{
        Iterator<Integer> labelOffsetIterator = labelsMap.keySet().iterator();
        Integer nextLabelOffset = labelOffsetIterator.hasNext() ? labelOffsetIterator.next() : null;
        Op[] values = Op.ops;
        for (int offset = nextInsn.nextSetBit(0); offset >= 0; offset = nextInsn.nextSetBit(offset + 1)) {
            // issue 65, a label may `inside` an instruction
            // visit all label with offset <= currentOffset
            while (nextLabelOffset != null) {
                if (nextLabelOffset <= offset) {
                    dcv.visitLabel(labelsMap.get(nextLabelOffset));
                    nextLabelOffset = labelOffsetIterator.hasNext() ? labelOffsetIterator.next() : null;
                } else {
                    // the label is after this instruction
                    break;
                }
            }

            if(badOps.get(offset)){
                dcv.visitStmt0R(Op.BAD_OP);
                continue;
            }

            int u1offset = offset * 2;
            int opcode = 0xFF & insns[u1offset];

            Op op = values[opcode];

            int a, b, c, target;
            switch (op.format) {
            // case kFmt00x: break;
            case kFmt10x:
                dcv.visitStmt0R(op);
                break;

            case kFmt11x:
                dcv.visitStmt1R(op, 0xFF & insns[u1offset + 1]);
                break;
            case kFmt12x:
                a = ubyte(insns, u1offset + 1);
                dcv.visitStmt2R(op, a & 0xF, a >> 4);
                break;
            // case kFmt20bc:break;
            case kFmt10t:
                target = offset + insns[u1offset + 1];
                dcv.visitJumpStmt(op, -1, -1, labelsMap.get(target));
                break;
            case kFmt20t:
                target = offset + sshort(insns, u1offset + 2);
                dcv.visitJumpStmt(op, -1, -1, labelsMap.get(target));
                break;
            case kFmt21t:
                target = offset + sshort(insns, u1offset + 2);
                dcv.visitJumpStmt(op, ubyte(insns, u1offset + 1), -1, labelsMap.get(target));
                break;
            case kFmt22t:
                target = offset + sshort(insns, u1offset + 2);
                a = ubyte(insns, u1offset + 1);
                b = a & 0x0F;
                c = a >> 4;
                boolean ignore = false;
                if (b == c) {
                    switch (op) {
                    case IF_EQ:
                    case IF_GE:
                    case IF_LE:
                        // means always jump, equals to goto
                        dcv.visitJumpStmt(Op.GOTO, 0, 0, labelsMap.get(target));
                        ignore = true;
                        break;
                    case IF_NE:
                    case IF_GT:
                    case IF_LT:
                        // means always not jump
                        ignore = true;
                        break;
                    default:
                        break;
                    }
                }
                if (!ignore) {
                    dcv.visitJumpStmt(op, b, c, labelsMap.get(target));
                }
                break;
            case kFmt30t:
                target = offset + sint(insns, u1offset + 2);
                dcv.visitJumpStmt(op, -1, -1, labelsMap.get(target));
                break;
            case kFmt31t:
                target = offset + sint(insns, u1offset + 2);
                a = ubyte(insns, u1offset + 1);
                int u1SwitchData = 2 * target;
                if (op == Op.FILL_ARRAY_DATA) {
                    int element_width = ushort(insns, u1SwitchData + 2);
                    int size = uint(insns, u1SwitchData + 4);
                    switch (element_width) {
                    case 1: {
                        byte[] data = new byte[size];
                        System.arraycopy(insns, u1SwitchData + 8, data, 0, size);
                        dcv.visitFillArrayDataStmt(op, a, data);
                    }
                        break;
                    case 2: {
                        short[] data = new short[size];
                        for (int i = 0; i < size; i++) {
                            data[i] = (short) sshort(insns, u1SwitchData + 8 + 2 * i);
                        }
                        dcv.visitFillArrayDataStmt(op, a, data);
                    }
                        break;
                    case 4: {
                        int[] data = new int[size];
                        for (int i = 0; i < size; i++) {
                            data[i] = sint(insns, u1SwitchData + 8 + 4 * i);
                        }
                        dcv.visitFillArrayDataStmt(op, a, data);
                    }
                        break;
                    case 8: {
                        long[] data = new long[size];
                        for (int i = 0; i < size; i++) {
                            int t = u1SwitchData + 8 + 8 * i;
                            long z = 0;
                            z |= ((long) ushort(insns, t + 0)) << 0;
                            z |= ((long) ushort(insns, t + 2)) << 16;
                            z |= ((long) ushort(insns, t + 4)) << 32;
                            z |= ((long) ushort(insns, t + 6)) << 48;
                            data[i] = z;
                        }
                        dcv.visitFillArrayDataStmt(op, a, data);
                    }
                        break;
                    }
                } else if (op == Op.SPARSE_SWITCH) {
                    int size = sshort(insns, u1SwitchData + 2);
                    int keys[] = new int[size];
                    DexLabel labels[] = new DexLabel[size];
                    int z = u1SwitchData + 4;
                    for (int i = 0; i < size; i++) {
                        keys[i] = sint(insns, z + i * 4);
                    }
                    z += size * 4;
                    for (int i = 0; i < size; i++) {
                        labels[i] = labelsMap.get(offset + sint(insns, z + i * 4));
                    }
                    dcv.visitSparseSwitchStmt(op, a, keys, labels);
                } else {
                    int size = sshort(insns, u1SwitchData + 2);
                    int first_key = sint(insns, u1SwitchData + 4);
                    DexLabel labels[] = new DexLabel[size];
                    int z = u1SwitchData + 8;
                    for (int i = 0; i < size; i++) {
                        labels[i] = labelsMap.get(offset + sint(insns, z));
                        z += 4;
                    }
                    dcv.visitPackedSwitchStmt(op, a, first_key, labels);
                }
                break;
            case kFmt21c:
                a = ubyte(insns, u1offset + 1);
                b = ushort(insns, u1offset + 2);
                switch (op.indexType) {
                case kIndexStringRef:
                    dcv.visitConstStmt(op, a, getString(b));
                    break;
                case kIndexFieldRef:
                    dcv.visitFieldStmt(op, a, -1, getField(b));
                    break;
                case kIndexTypeRef:
                    if (op == Op.CONST_CLASS) {
                        dcv.visitConstStmt(op, a, new DexType(getType(b)));
                    } else {
                        dcv.visitTypeStmt(op, a, -1, getType(b));
                    }
                    break;
                default:
                    break;
                }
                break;
            case kFmt22c:
                a = ubyte(insns, u1offset + 1);
                b = ushort(insns, u1offset + 2);
                switch (op.indexType) {
                case kIndexFieldRef:
                    dcv.visitFieldStmt(op, a & 0xF, a >> 4, getField(b));
                    break;
                case kIndexTypeRef:
                    dcv.visitTypeStmt(op, a & 0xF, a >> 4, getType(b));
                    break;
                default:
                    break;
                }
                break;
            case kFmt31c:
                if (op.indexType == InstructionIndexType.kIndexStringRef) {
                    a = ubyte(insns, u1offset + 1);
                    b = uint(insns, u1offset + 2);
                    dcv.visitConstStmt(op, a, getString(b));
                }
                break;
            case kFmt35c: {
                a = ubyte(insns, u1offset + 1);
                b = ushort(insns, u1offset + 2);
                int dc = ubyte(insns, u1offset + 4); // DC
                int fe = ubyte(insns, u1offset + 5); // FE

                int regs[] = new int[a >> 4];
                switch (a >> 4) {
                case 5:
                    regs[4] = a & 0xF;// G
                case 4:
                    regs[3] = 0xF & (fe >> 4);// F
                case 3:
                    regs[2] = 0xF & (fe >> 0);// E
                case 2:
                    regs[1] = 0xF & (dc >> 4);// D
                case 1:
                    regs[0] = 0xF & (dc >> 0);// C
                }
                if (op.indexType == InstructionIndexType.kIndexTypeRef) {
                    dcv.visitFilledNewArrayStmt(op, regs, getType(b));
                } else if (op.indexType == InstructionIndexType.kIndexCallSiteRef) {
                    Object[] callsite = getCallSite(b);
                    Object[] constArgs = Arrays.copyOfRange(callsite, 3, callsite.length);
                    dcv.visitMethodStmt(op, regs, (String) callsite[1], (Proto) callsite[2], (MethodHandle) callsite[0], constArgs);
                } else {
                    dcv.visitMethodStmt(op, regs, getMethod(b));
                }
            }
                break;
            case kFmt3rc: {
                a = ubyte(insns, u1offset + 1);
                b = ushort(insns, u1offset + 2);
                c = ushort(insns, u1offset + 4);
                int regs[] = new int[a];
                for (int i = 0; i < a; i++) {
                    regs[i] = c + i;
                }
                if (op.indexType == InstructionIndexType.kIndexTypeRef) {
                    dcv.visitFilledNewArrayStmt(op, regs, getType(b));
                } else if (op.indexType == InstructionIndexType.kIndexCallSiteRef) {
                    Object[] callsite = getCallSite(b);
                    Object[] constArgs = Arrays.copyOfRange(callsite, 3, callsite.length - 3);
                    dcv.visitMethodStmt(op, regs, (String) callsite[1], (Proto) callsite[2], (MethodHandle) callsite[0], constArgs);
                } else {
                    dcv.visitMethodStmt(op, regs, getMethod(b));
                }
            }
                break;
            case kFmt45cc: {
                a = ubyte(insns, u1offset + 1);
                b = ushort(insns, u1offset + 2);
                int dc = ubyte(insns, u1offset + 4); // DC
                int fe = ubyte(insns, u1offset + 5); // FE
                int h = ushort(insns, u1offset + 6);

                int regs[] = new int[a >> 4];
                switch (a >> 4) {
                case 5:
                    regs[4] = a & 0xF;// G
                case 4:
                    regs[3] = 0xF & (fe >> 4);// F
                case 3:
                    regs[2] = 0xF & (fe >> 0);// E
                case 2:
                    regs[1] = 0xF & (dc >> 4);// D
                case 1:
                    regs[0] = 0xF & (dc >> 0);// C
                }
                dcv.visitMethodStmt(op, regs, getMethod(b), getProto(h));
            }
            break;
            case kFmt4rcc: {
                a = ubyte(insns, u1offset + 1);
                b = ushort(insns, u1offset + 2);
                c = ushort(insns, u1offset + 4);
                int h = ushort(insns, u1offset + 6);
                int regs[] = new int[a];
                for (int i = 0; i < a; i++) {
                    regs[i] = c + i;
                }
                dcv.visitMethodStmt(op, regs, getMethod(b), getProto(h));
            }
            break;
            case kFmt22x:
                a = ubyte(insns, u1offset + 1);
                b = ushort(insns, u1offset + 2);
                dcv.visitStmt2R(op, a, b);
                break;
            case kFmt23x:
                a = ubyte(insns, u1offset + 1);
                b = ubyte(insns, u1offset + 2);
                c = ubyte(insns, u1offset + 3);
                dcv.visitStmt3R(op, a, b, c);
                break;
            case kFmt32x:
                a = ushort(insns, u1offset + 2);
                b = ushort(insns, u1offset + 4);
                dcv.visitStmt2R(op, a, b);
                break;
            case kFmt11n:
                a = insns[u1offset + 1];
                dcv.visitConstStmt(op, a & 0xF, a >> 4);
                break;
            case kFmt21h:
                a = ubyte(insns, u1offset + 1);
                b = sshort(insns, u1offset + 2);
                if (op == Op.CONST_HIGH16) {
                    dcv.visitConstStmt(op, a, b << 16);
                } else {
                    dcv.visitConstStmt(op, a, ((long) b) << 48);
                }
                break;
            case kFmt21s:
                a = ubyte(insns, u1offset + 1);
                b = sshort(insns, u1offset + 2);
                if (op == Op.CONST_16) {
                    dcv.visitConstStmt(op, a, b);
                } else {
                    dcv.visitConstStmt(op, a, (long) b);
                }
                break;
            case kFmt22b:
                a = ubyte(insns, u1offset + 1);
                b = ubyte(insns, u1offset + 2);
                c = sbyte(insns, u1offset + 3);
                dcv.visitStmt2R1N(op, a, b, c);
                break;
            case kFmt22s:
                a = ubyte(insns, u1offset + 1);
                b = sshort(insns, u1offset + 2);
                dcv.visitStmt2R1N(op, a & 0xF, a >> 4, b);
                break;
            // case kFmt22cs:break;
            case kFmt31i:
                a = ubyte(insns, u1offset + 1);
                b = sint(insns, u1offset + 2);
                if (op == Op.CONST) {
                    dcv.visitConstStmt(op, a, b);
                } else {
                    dcv.visitConstStmt(op, a, (long) b);
                }
                break;
            case kFmt51l:
                a = ubyte(insns, u1offset + 1);
                long z = 0;
                z |= ((long) ushort(insns, u1offset + 2)) << 0;
                z |= ((long) ushort(insns, u1offset + 4)) << 16;
                z |= ((long) ushort(insns, u1offset + 6)) << 32;
                z |= ((long) ushort(insns, u1offset + 8)) << 48;
                dcv.visitConstStmt(op, a, z);
                break;
            }
        }

        while (nextLabelOffset != null) {
            dcv.visitLabel(labelsMap.get(nextLabelOffset));
            if (labelOffsetIterator.hasNext()) {
                nextLabelOffset = labelOffsetIterator.next();
            } else {
                break;
            }
        }
    }",break_loop_control
i,"for (int i = 0; i < size; i++) {
                            data[i] = (short) sshort(insns, u1SwitchData + 8 + 2 * i);
                        }",loop_control
i,"for (int i = 0; i < size; i++) {
                            data[i] = sint(insns, u1SwitchData + 8 + 4 * i);
                        }",loop_control
i,"for (int i = 0; i < size; i++) {
                            int t = u1SwitchData + 8 + 8 * i;
                            long z = 0;
                            z |= ((long) ushort(insns, t + 0)) << 0;
                            z |= ((long) ushort(insns, t + 2)) << 16;
                            z |= ((long) ushort(insns, t + 4)) << 32;
                            z |= ((long) ushort(insns, t + 6)) << 48;
                            data[i] = z;
                        }",loop_control
i,"for (int i = 0; i < size; i++) {
                        keys[i] = sint(insns, z + i * 4);
                    }",loop_control
i,"for (int i = 0; i < size; i++) {
                        labels[i] = labelsMap.get(offset + sint(insns, z + i * 4));
                    }",loop_control
i,"for (int i = 0; i < size; i++) {
                        labels[i] = labelsMap.get(offset + sint(insns, z));
                        z += 4;
                    }",loop_control
i,"for (int i = 0; i < a; i++) {
                    regs[i] = c + i;
                }",loop_control
i,"for (int i = 0; i < a; i++) {
                    regs[i] = c + i;
                }",loop_control
labelOffsetIterator,"{
        Iterator<Integer> labelOffsetIterator = labelsMap.keySet().iterator();
        Integer nextLabelOffset = labelOffsetIterator.hasNext() ? labelOffsetIterator.next() : null;
        Op[] values = Op.ops;
        for (int offset = nextInsn.nextSetBit(0); offset >= 0; offset = nextInsn.nextSetBit(offset + 1)) {
            // issue 65, a label may `inside` an instruction
            // visit all label with offset <= currentOffset
            while (nextLabelOffset != null) {
                if (nextLabelOffset <= offset) {
                    dcv.visitLabel(labelsMap.get(nextLabelOffset));
                    nextLabelOffset = labelOffsetIterator.hasNext() ? labelOffsetIterator.next() : null;
                } else {
                    // the label is after this instruction
                    break;
                }
            }

            if(badOps.get(offset)){
                dcv.visitStmt0R(Op.BAD_OP);
                continue;
            }

            int u1offset = offset * 2;
            int opcode = 0xFF & insns[u1offset];

            Op op = values[opcode];

            int a, b, c, target;
            switch (op.format) {
            // case kFmt00x: break;
            case kFmt10x:
                dcv.visitStmt0R(op);
                break;

            case kFmt11x:
                dcv.visitStmt1R(op, 0xFF & insns[u1offset + 1]);
                break;
            case kFmt12x:
                a = ubyte(insns, u1offset + 1);
                dcv.visitStmt2R(op, a & 0xF, a >> 4);
                break;
            // case kFmt20bc:break;
            case kFmt10t:
                target = offset + insns[u1offset + 1];
                dcv.visitJumpStmt(op, -1, -1, labelsMap.get(target));
                break;
            case kFmt20t:
                target = offset + sshort(insns, u1offset + 2);
                dcv.visitJumpStmt(op, -1, -1, labelsMap.get(target));
                break;
            case kFmt21t:
                target = offset + sshort(insns, u1offset + 2);
                dcv.visitJumpStmt(op, ubyte(insns, u1offset + 1), -1, labelsMap.get(target));
                break;
            case kFmt22t:
                target = offset + sshort(insns, u1offset + 2);
                a = ubyte(insns, u1offset + 1);
                b = a & 0x0F;
                c = a >> 4;
                boolean ignore = false;
                if (b == c) {
                    switch (op) {
                    case IF_EQ:
                    case IF_GE:
                    case IF_LE:
                        // means always jump, equals to goto
                        dcv.visitJumpStmt(Op.GOTO, 0, 0, labelsMap.get(target));
                        ignore = true;
                        break;
                    case IF_NE:
                    case IF_GT:
                    case IF_LT:
                        // means always not jump
                        ignore = true;
                        break;
                    default:
                        break;
                    }
                }
                if (!ignore) {
                    dcv.visitJumpStmt(op, b, c, labelsMap.get(target));
                }
                break;
            case kFmt30t:
                target = offset + sint(insns, u1offset + 2);
                dcv.visitJumpStmt(op, -1, -1, labelsMap.get(target));
                break;
            case kFmt31t:
                target = offset + sint(insns, u1offset + 2);
                a = ubyte(insns, u1offset + 1);
                int u1SwitchData = 2 * target;
                if (op == Op.FILL_ARRAY_DATA) {
                    int element_width = ushort(insns, u1SwitchData + 2);
                    int size = uint(insns, u1SwitchData + 4);
                    switch (element_width) {
                    case 1: {
                        byte[] data = new byte[size];
                        System.arraycopy(insns, u1SwitchData + 8, data, 0, size);
                        dcv.visitFillArrayDataStmt(op, a, data);
                    }
                        break;
                    case 2: {
                        short[] data = new short[size];
                        for (int i = 0; i < size; i++) {
                            data[i] = (short) sshort(insns, u1SwitchData + 8 + 2 * i);
                        }
                        dcv.visitFillArrayDataStmt(op, a, data);
                    }
                        break;
                    case 4: {
                        int[] data = new int[size];
                        for (int i = 0; i < size; i++) {
                            data[i] = sint(insns, u1SwitchData + 8 + 4 * i);
                        }
                        dcv.visitFillArrayDataStmt(op, a, data);
                    }
                        break;
                    case 8: {
                        long[] data = new long[size];
                        for (int i = 0; i < size; i++) {
                            int t = u1SwitchData + 8 + 8 * i;
                            long z = 0;
                            z |= ((long) ushort(insns, t + 0)) << 0;
                            z |= ((long) ushort(insns, t + 2)) << 16;
                            z |= ((long) ushort(insns, t + 4)) << 32;
                            z |= ((long) ushort(insns, t + 6)) << 48;
                            data[i] = z;
                        }
                        dcv.visitFillArrayDataStmt(op, a, data);
                    }
                        break;
                    }
                } else if (op == Op.SPARSE_SWITCH) {
                    int size = sshort(insns, u1SwitchData + 2);
                    int keys[] = new int[size];
                    DexLabel labels[] = new DexLabel[size];
                    int z = u1SwitchData + 4;
                    for (int i = 0; i < size; i++) {
                        keys[i] = sint(insns, z + i * 4);
                    }
                    z += size * 4;
                    for (int i = 0; i < size; i++) {
                        labels[i] = labelsMap.get(offset + sint(insns, z + i * 4));
                    }
                    dcv.visitSparseSwitchStmt(op, a, keys, labels);
                } else {
                    int size = sshort(insns, u1SwitchData + 2);
                    int first_key = sint(insns, u1SwitchData + 4);
                    DexLabel labels[] = new DexLabel[size];
                    int z = u1SwitchData + 8;
                    for (int i = 0; i < size; i++) {
                        labels[i] = labelsMap.get(offset + sint(insns, z));
                        z += 4;
                    }
                    dcv.visitPackedSwitchStmt(op, a, first_key, labels);
                }
                break;
            case kFmt21c:
                a = ubyte(insns, u1offset + 1);
                b = ushort(insns, u1offset + 2);
                switch (op.indexType) {
                case kIndexStringRef:
                    dcv.visitConstStmt(op, a, getString(b));
                    break;
                case kIndexFieldRef:
                    dcv.visitFieldStmt(op, a, -1, getField(b));
                    break;
                case kIndexTypeRef:
                    if (op == Op.CONST_CLASS) {
                        dcv.visitConstStmt(op, a, new DexType(getType(b)));
                    } else {
                        dcv.visitTypeStmt(op, a, -1, getType(b));
                    }
                    break;
                default:
                    break;
                }
                break;
            case kFmt22c:
                a = ubyte(insns, u1offset + 1);
                b = ushort(insns, u1offset + 2);
                switch (op.indexType) {
                case kIndexFieldRef:
                    dcv.visitFieldStmt(op, a & 0xF, a >> 4, getField(b));
                    break;
                case kIndexTypeRef:
                    dcv.visitTypeStmt(op, a & 0xF, a >> 4, getType(b));
                    break;
                default:
                    break;
                }
                break;
            case kFmt31c:
                if (op.indexType == InstructionIndexType.kIndexStringRef) {
                    a = ubyte(insns, u1offset + 1);
                    b = uint(insns, u1offset + 2);
                    dcv.visitConstStmt(op, a, getString(b));
                }
                break;
            case kFmt35c: {
                a = ubyte(insns, u1offset + 1);
                b = ushort(insns, u1offset + 2);
                int dc = ubyte(insns, u1offset + 4); // DC
                int fe = ubyte(insns, u1offset + 5); // FE

                int regs[] = new int[a >> 4];
                switch (a >> 4) {
                case 5:
                    regs[4] = a & 0xF;// G
                case 4:
                    regs[3] = 0xF & (fe >> 4);// F
                case 3:
                    regs[2] = 0xF & (fe >> 0);// E
                case 2:
                    regs[1] = 0xF & (dc >> 4);// D
                case 1:
                    regs[0] = 0xF & (dc >> 0);// C
                }
                if (op.indexType == InstructionIndexType.kIndexTypeRef) {
                    dcv.visitFilledNewArrayStmt(op, regs, getType(b));
                } else if (op.indexType == InstructionIndexType.kIndexCallSiteRef) {
                    Object[] callsite = getCallSite(b);
                    Object[] constArgs = Arrays.copyOfRange(callsite, 3, callsite.length);
                    dcv.visitMethodStmt(op, regs, (String) callsite[1], (Proto) callsite[2], (MethodHandle) callsite[0], constArgs);
                } else {
                    dcv.visitMethodStmt(op, regs, getMethod(b));
                }
            }
                break;
            case kFmt3rc: {
                a = ubyte(insns, u1offset + 1);
                b = ushort(insns, u1offset + 2);
                c = ushort(insns, u1offset + 4);
                int regs[] = new int[a];
                for (int i = 0; i < a; i++) {
                    regs[i] = c + i;
                }
                if (op.indexType == InstructionIndexType.kIndexTypeRef) {
                    dcv.visitFilledNewArrayStmt(op, regs, getType(b));
                } else if (op.indexType == InstructionIndexType.kIndexCallSiteRef) {
                    Object[] callsite = getCallSite(b);
                    Object[] constArgs = Arrays.copyOfRange(callsite, 3, callsite.length - 3);
                    dcv.visitMethodStmt(op, regs, (String) callsite[1], (Proto) callsite[2], (MethodHandle) callsite[0], constArgs);
                } else {
                    dcv.visitMethodStmt(op, regs, getMethod(b));
                }
            }
                break;
            case kFmt45cc: {
                a = ubyte(insns, u1offset + 1);
                b = ushort(insns, u1offset + 2);
                int dc = ubyte(insns, u1offset + 4); // DC
                int fe = ubyte(insns, u1offset + 5); // FE
                int h = ushort(insns, u1offset + 6);

                int regs[] = new int[a >> 4];
                switch (a >> 4) {
                case 5:
                    regs[4] = a & 0xF;// G
                case 4:
                    regs[3] = 0xF & (fe >> 4);// F
                case 3:
                    regs[2] = 0xF & (fe >> 0);// E
                case 2:
                    regs[1] = 0xF & (dc >> 4);// D
                case 1:
                    regs[0] = 0xF & (dc >> 0);// C
                }
                dcv.visitMethodStmt(op, regs, getMethod(b), getProto(h));
            }
            break;
            case kFmt4rcc: {
                a = ubyte(insns, u1offset + 1);
                b = ushort(insns, u1offset + 2);
                c = ushort(insns, u1offset + 4);
                int h = ushort(insns, u1offset + 6);
                int regs[] = new int[a];
                for (int i = 0; i < a; i++) {
                    regs[i] = c + i;
                }
                dcv.visitMethodStmt(op, regs, getMethod(b), getProto(h));
            }
            break;
            case kFmt22x:
                a = ubyte(insns, u1offset + 1);
                b = ushort(insns, u1offset + 2);
                dcv.visitStmt2R(op, a, b);
                break;
            case kFmt23x:
                a = ubyte(insns, u1offset + 1);
                b = ubyte(insns, u1offset + 2);
                c = ubyte(insns, u1offset + 3);
                dcv.visitStmt3R(op, a, b, c);
                break;
            case kFmt32x:
                a = ushort(insns, u1offset + 2);
                b = ushort(insns, u1offset + 4);
                dcv.visitStmt2R(op, a, b);
                break;
            case kFmt11n:
                a = insns[u1offset + 1];
                dcv.visitConstStmt(op, a & 0xF, a >> 4);
                break;
            case kFmt21h:
                a = ubyte(insns, u1offset + 1);
                b = sshort(insns, u1offset + 2);
                if (op == Op.CONST_HIGH16) {
                    dcv.visitConstStmt(op, a, b << 16);
                } else {
                    dcv.visitConstStmt(op, a, ((long) b) << 48);
                }
                break;
            case kFmt21s:
                a = ubyte(insns, u1offset + 1);
                b = sshort(insns, u1offset + 2);
                if (op == Op.CONST_16) {
                    dcv.visitConstStmt(op, a, b);
                } else {
                    dcv.visitConstStmt(op, a, (long) b);
                }
                break;
            case kFmt22b:
                a = ubyte(insns, u1offset + 1);
                b = ubyte(insns, u1offset + 2);
                c = sbyte(insns, u1offset + 3);
                dcv.visitStmt2R1N(op, a, b, c);
                break;
            case kFmt22s:
                a = ubyte(insns, u1offset + 1);
                b = sshort(insns, u1offset + 2);
                dcv.visitStmt2R1N(op, a & 0xF, a >> 4, b);
                break;
            // case kFmt22cs:break;
            case kFmt31i:
                a = ubyte(insns, u1offset + 1);
                b = sint(insns, u1offset + 2);
                if (op == Op.CONST) {
                    dcv.visitConstStmt(op, a, b);
                } else {
                    dcv.visitConstStmt(op, a, (long) b);
                }
                break;
            case kFmt51l:
                a = ubyte(insns, u1offset + 1);
                long z = 0;
                z |= ((long) ushort(insns, u1offset + 2)) << 0;
                z |= ((long) ushort(insns, u1offset + 4)) << 16;
                z |= ((long) ushort(insns, u1offset + 6)) << 32;
                z |= ((long) ushort(insns, u1offset + 8)) << 48;
                dcv.visitConstStmt(op, a, z);
                break;
            }
        }

        while (nextLabelOffset != null) {
            dcv.visitLabel(labelsMap.get(nextLabelOffset));
            if (labelOffsetIterator.hasNext()) {
                nextLabelOffset = labelOffsetIterator.next();
            } else {
                break;
            }
        }
    }",iterator
c,"for (int c = is.read(buff); c > 0; c = is.read(buff)) {
            out.write(buff, 0, c);
        }",maybe_loop_control
e,"for (ZipEntry e : zipFile.entries()) {
                    String entryName = e.getName();
                    if (entryName.startsWith(""classes"") && entryName.endsWith("".dex"")) {
                        if (!dexFileReaders.containsKey(entryName)) { // only the first one
                            dexFileReaders.put(entryName, new DexFileReader(toByteArray(zipFile.getInputStream(e))));
                        }
                    }
                }",iterator
reader,"for (DexFileReader reader : readers) {
            List<String> classNames = reader.getClassNames();
            for (int i = 0; i < classNames.size(); i++) {
                String className = classNames.get(i);
                if (classes.add(className)) {
                    items.add(new Item(i, reader, className));
                }
            }
        }",iterator
i,"for (int i = 0; i < classNames.size(); i++) {
                String className = classNames.get(i);
                if (classes.add(className)) {
                    items.add(new Item(i, reader, className));
                }
            }",loop_control
r,"for (DexFileReader r : readers) {
            int v = r.getDexVersion();
            if (v > max) {
                max = v;
            }
        }",iterator
i,"for (int i = 0; i < size; i++) {
            accept(dv, i, config);
        }",loop_control
c,"for (int c = is.read(buff); c > 0; c = is.read(buff)) {
            out.write(buff, 0, c);
        }",maybe_loop_control
a,"{
            char a = (char) (in.get() & 0xff);
            if (a == 0) {
                return sb.toString();
            }

            if (a < '\u0080') {
                sb.append(a);
            } else if ((a & 0xe0) == 0xc0) {
                int b = in.get() & 0xff;
                if ((b & 0xC0) != 0x80) {
                    throw new UTFDataFormatException(""bad second byte"");
                }
                sb.append((char) (((a & 0x1F) << 6) | (b & 0x3F)));
            } else if ((a & 0xf0) == 0xe0) {
                int b = in.get() & 0xff;
                int c = in.get() & 0xff;
                if (((b & 0xC0) != 0x80) || ((c & 0xC0) != 0x80)) {
                    throw new UTFDataFormatException(""bad second or third byte"");
                }
                sb.append((char) (((a & 0x0F) << 12) | ((b & 0x3F) << 6) | (c & 0x3F)));
            } else {
                throw new UTFDataFormatException(""bad byte"");
            }
        }",break_loop_control
i,"for (int i = 0; i < length; ++i) {
            char ch = s.charAt(i);
            if (ch != 0 && ch <= 127) { // U+0000 uses two bytes.
                ++result;
            } else if (ch <= 2047) {
                result += 2;
            } else {
                result += 3;
            }
            if (shortLength && result > 65535) {
                throw new UTFDataFormatException(""String more than 65535 UTF bytes long"");
            }
        }",loop_control
i,"for (int i = 0; i < length; i++) {
            char ch = s.charAt(i);
            if (ch != 0 && ch <= 127) { // U+0000 uses two bytes.
                dst[offset++] = (byte) ch;
            } else if (ch <= 2047) {
                dst[offset++] = (byte) (0xc0 | (0x1f & (ch >> 6)));
                dst[offset++] = (byte) (0x80 | (0x3f & ch));
            } else {
                dst[offset++] = (byte) (0xe0 | (0x0f & (ch >> 12)));
                dst[offset++] = (byte) (0x80 | (0x3f & (ch >> 6)));
                dst[offset++] = (byte) (0x80 | (0x3f & ch));
            }
        }",loop_control
s,"for (String s : args) {
            System.out.println(""asmifier "" + s);
            doFile(new File(s).toPath());
        }",iterator
i,"for (int i = 0; i < out.array.size(); i++) {
            sb.setLength(0);
            int p = out.is.get(i);
            for (int j = 0; j < p; j++) {
                sb.append(""    "");
            }
            sb.append(out.array.get(i));
            list.add(sb.toString());
        }",loop_control
j,"for (int j = 0; j < p; j++) {
                sb.append(""    "");
            }",loop_control
obj,"for (int obj : vs) {
            if (first) {
                first = false;
            } else {
                sb.append("","");
            }
            sb.append(obj);
        }",iterator
obj,"for (byte obj : vs) {
            if (first) {
                first = false;
            } else {
                sb.append("","");
            }
            sb.append(""(byte)"").append(obj);
        }",iterator
obj,"for (String obj : vs) {
            if (first) {
                first = false;
            } else {
                sb.append("","");
            }
            sb.append(v(obj));
        }",iterator
obj,"for (Object obj : vs) {
            if (first) {
                first = false;
            } else {
                sb.append("","");
            }
            sb.append(v(obj));
        }",iterator
i,"for (int i : (int[]) obj) {
                if (first) {
                    first = false;
                } else {
                    sb.append("","");
                }
                sb.append(i);
            }",iterator
i,"for (int i : (short[]) obj) {
                if (first) {
                    first = false;
                } else {
                    sb.append("","");
                }
                sb.append(""(short)"").append(i);
            }",iterator
i,"for (long i : (long[]) obj) {
                if (first) {
                    first = false;
                } else {
                    sb.append("","");
                }
                sb.append(i).append(""L"");
            }",iterator
i,"for (float i : (float[]) obj) {
                if (first) {
                    first = false;
                } else {
                    sb.append("","");
                }
                sb.append(i).append(""F"");
            }",iterator
i,"for (int i = 0; i < len; i++) {
            char c = string.charAt(i);
            if ((c != 0) && (c < 0x80)) {
                bytes[outAt] = (byte) c;
                outAt++;
            } else if (c < 0x800) {
                bytes[outAt] = (byte) (((c >> 6) & 0x1f) | 0xc0);
                bytes[outAt + 1] = (byte) ((c & 0x3f) | 0x80);
                outAt += 2;
            } else {
                bytes[outAt] = (byte) (((c >> 12) & 0x0f) | 0xe0);
                bytes[outAt + 1] = (byte) (((c >> 6) & 0x3f) | 0x80);
                bytes[outAt + 2] = (byte) ((c & 0x3f) | 0x80);
                outAt += 3;
            }
        }",loop_control
at,"for (int at = start; length > 0; /* at */) {
            int v0 = bytes[at] & 0xFF;
            char out;
            switch (v0 >> 4) {
            case 0x00:
            case 0x01:
            case 0x02:
            case 0x03:
            case 0x04:
            case 0x05:
            case 0x06:
            case 0x07: {
                // 0XXXXXXX -- single-byte encoding
                length--;
                if (v0 == 0) {
                    // A single zero byte is illegal.
                    return throwBadUtf8(v0, at);
                }
                out = (char) v0;
                at++;
                break;
            }
            case 0x0c:
            case 0x0d: {
                // 110XXXXX -- two-byte encoding
                length -= 2;
                if (length < 0) {
                    return throwBadUtf8(v0, at);
                }
                int v1 = bytes[at + 1] & 0xFF;
                if ((v1 & 0xc0) != 0x80) {
                    return throwBadUtf8(v1, at + 1);
                }
                int value = ((v0 & 0x1f) << 6) | (v1 & 0x3f);
                if ((value != 0) && (value < 0x80)) {
                    /*
                     * This should have been represented with one-byte encoding.
                     */
                    return throwBadUtf8(v1, at + 1);
                }
                out = (char) value;
                at += 2;
                break;
            }
            case 0x0e: {
                // 1110XXXX -- three-byte encoding
                length -= 3;
                if (length < 0) {
                    return throwBadUtf8(v0, at);
                }
                int v1 = bytes[at + 1] & 0xFF;
                if ((v1 & 0xc0) != 0x80) {
                    return throwBadUtf8(v1, at + 1);
                }
                int v2 = bytes[at + 2] & 0xFF;
                if ((v1 & 0xc0) != 0x80) {
                    return throwBadUtf8(v2, at + 2);
                }
                int value = ((v0 & 0x0f) << 12) | ((v1 & 0x3f) << 6) | (v2 & 0x3f);
                if (value < 0x800) {
                    /*
                     * This should have been represented with one- or two-byte encoding.
                     */
                    return throwBadUtf8(v2, at + 2);
                }
                out = (char) value;
                at += 3;
                break;
            }
            default: {
                // 10XXXXXX, 1111XXXX -- illegal
                return throwBadUtf8(v0, at);
            }
            }
            chars[outAt] = out;
            outAt++;
        }",maybe_loop_control
length,"{
        if (tempBuffer == null || tempBuffer.length < length) {
            tempBuffer = new char[length];
        }
        char[] chars = tempBuffer;
        int outAt = 0;

        for (int at = start; length > 0; /* at */) {
            int v0 = bytes[at] & 0xFF;
            char out;
            switch (v0 >> 4) {
            case 0x00:
            case 0x01:
            case 0x02:
            case 0x03:
            case 0x04:
            case 0x05:
            case 0x06:
            case 0x07: {
                // 0XXXXXXX -- single-byte encoding
                length--;
                if (v0 == 0) {
                    // A single zero byte is illegal.
                    return throwBadUtf8(v0, at);
                }
                out = (char) v0;
                at++;
                break;
            }
            case 0x0c:
            case 0x0d: {
                // 110XXXXX -- two-byte encoding
                length -= 2;
                if (length < 0) {
                    return throwBadUtf8(v0, at);
                }
                int v1 = bytes[at + 1] & 0xFF;
                if ((v1 & 0xc0) != 0x80) {
                    return throwBadUtf8(v1, at + 1);
                }
                int value = ((v0 & 0x1f) << 6) | (v1 & 0x3f);
                if ((value != 0) && (value < 0x80)) {
                    /*
                     * This should have been represented with one-byte encoding.
                     */
                    return throwBadUtf8(v1, at + 1);
                }
                out = (char) value;
                at += 2;
                break;
            }
            case 0x0e: {
                // 1110XXXX -- three-byte encoding
                length -= 3;
                if (length < 0) {
                    return throwBadUtf8(v0, at);
                }
                int v1 = bytes[at + 1] & 0xFF;
                if ((v1 & 0xc0) != 0x80) {
                    return throwBadUtf8(v1, at + 1);
                }
                int v2 = bytes[at + 2] & 0xFF;
                if ((v1 & 0xc0) != 0x80) {
                    return throwBadUtf8(v2, at + 2);
                }
                int value = ((v0 & 0x0f) << 12) | ((v1 & 0x3f) << 6) | (v2 & 0x3f);
                if (value < 0x800) {
                    /*
                     * This should have been represented with one- or two-byte encoding.
                     */
                    return throwBadUtf8(v2, at + 2);
                }
                out = (char) value;
                at += 3;
                break;
            }
            default: {
                // 10XXXXXX, 1111XXXX -- illegal
                return throwBadUtf8(v0, at);
            }
            }
            chars[outAt] = out;
            outAt++;
        }

        return new String(chars, 0, outAt);
    }",maybe_loop_control
dexLabel,"for (DexLabel dexLabel : labels) {
            if (first) {
                first = false;
            } else {
                sb.append("","");
            }
            sb.append(v(dexLabel));
        }",iterator
i,"for (int i : o.is) {
                out.is.add(out.i + i);
            }",iterator
i,"for (int i : o.is) {
                out.is.add(out.i + i);
            }",iterator
o,"for (ArrayOut o : fieldOuts) {
            out.array.addAll(o.array);
            for (int i : o.is) {
                out.is.add(out.i + i);
            }
        }",iterator
o,"for (ArrayOut o : methodOuts) {
            out.array.addAll(o.array);
            for (int i : o.is) {
                out.is.add(out.i + i);
            }
        }",iterator
b,"for (byte b : bytes) {
            if (b == 0) {
                return true;
            }
        }",iterator
e,"for (ZipEntry e : entries) {
            if (e.getName().equals(entryName)) {
                return e;
            }
        }",iterator
e,"for (ZipEntry e : entries) {
            if (e.getName().equals(entryName)) {
                return e;
            }
        }",break_loop_control
raf,"{
        ByteBuffer raf = this.raf;
        // Scan back, looking for the End Of Central Directory field. If the zip file doesn't
        // have an overall comment (unrelated to any per-entry comments), we'll hit the EOCD
        // on the first try.
        // No need to synchronize raf here -- we only do this when we first open the zip file.
        long scanOffset = raf.limit() - ENDHDR;
        if (scanOffset < 0) {
            throw new ZipException(""File too short to be a zip file: "" + raf.limit());
        }

        // not check Magic
        // raf.position(0);
        // final int headerMagic = raf.getInt();
        // if (headerMagic != LOCSIG) {
        // throw new ZipException(""Not a zip archive"");
        // }

        long stopOffset = scanOffset - 65536;
        if (stopOffset < 0) {
            stopOffset = 0;
        }

        while (true) {
            raf.position((int) scanOffset);
            if (raf.getInt() == ENDSIG) {
                break;
            }

            scanOffset--;
            if (scanOffset < stopOffset) {
                throw new ZipException(""End Of Central Directory signature not found"");
            }
        }

        // Read the End Of Central Directory. ENDHDR includes the signature bytes,
        // which we've already read.

        // Pull out the information we need.
        int diskNumber = raf.getShort() & 0xffff;
        int diskWithCentralDir = raf.getShort() & 0xffff;
        int numEntries = raf.getShort() & 0xffff;
        int totalNumEntries = raf.getShort() & 0xffff;
        skip(raf, 4); // Ignore centralDirSize.
        long centralDirOffset = ((long) raf.getInt()) & 0xffffffffL;
        int commentLength = raf.getShort() & 0xffff;

        if (numEntries != totalNumEntries || diskNumber != 0 || diskWithCentralDir != 0) {
            throw new ZipException(""Spanned archives not supported"");
        }
        boolean skipCommentsAndExtra = true;

        if (commentLength > 0) {
            if (commentLength > raf.remaining()) {
                System.err.println(""WARN: the zip comment exceed the zip content"");
            } else {
                if (skipCommentsAndExtra) {
                    skip(raf, commentLength);
                } else {
                    byte[] commentBytes = new byte[commentLength];
                    raf.get(commentBytes);
                    comment = new String(commentBytes, 0, commentBytes.length, StandardCharsets.UTF_8);
                }
            }
        }

        // Seek to the first CDE and read all entries.
        // We have to do this now (from the constructor) rather than lazily because the
        // public API doesn't allow us to throw IOException except from the constructor
        // or from getInputStream.
        ByteBuffer buf = (ByteBuffer) raf.duplicate().order(ByteOrder.LITTLE_ENDIAN).position((int) centralDirOffset);
        entries = new ArrayList<>(numEntries);
        for (int i = 0; i < numEntries; ++i) {
            ZipEntry newEntry = new ZipEntry(buf, skipCommentsAndExtra);
            if (newEntry.localHeaderRelOffset >= centralDirOffset) {
                // Ignore the entry
                // throw new ZipException(""Local file header offset is after central directory"");
            } else {
                entries.add(newEntry);
            }
        }
    }",break_loop_control
i,"for (int i = 0; i < numEntries; ++i) {
            ZipEntry newEntry = new ZipEntry(buf, skipCommentsAndExtra);
            if (newEntry.localHeaderRelOffset >= centralDirOffset) {
                // Ignore the entry
                // throw new ZipException(""Local file header offset is after central directory"");
            } else {
                entries.add(newEntry);
            }
        }",loop_control
