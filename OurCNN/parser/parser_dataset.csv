Name,Code,Category
i,"{
        ArrayList<Room> hotelRooms = new ArrayList<>();
        for (int i = 0; i < 15; i++) {
            hotelRooms.add(new HostelRoom(new StandardRoom(i + 1, 2, RoomType.ECONOMY)));
        }
        for (int i = 0; i < 15; i++) {
            hotelRooms.add(new ExpandableRoom(new StandardRoom(i + 16, 3, RoomType.LUX)));
        }
        Hotel hotel = new Hotel(hotelRooms);
        RoomManager roomManager = new RoomManager();
        StaffManager staffManager = new StaffManager();
        Human client1 = new Human(""Kopeikina"", ""Anna"");
        Human client2 = new Human(""Tyulebaeva"", ""Karina"");
        Human client3 = new Human(""Domrachev"", ""Ivan"");

        Human slave1 = new Human(""Alentev"", ""Igor"");

        Human slave2 = new Human(""Asatullaev"", ""Maruf"");

        staffManager.hireStaff(hotel, new PlumberCreator().createStaff(slave1, StaffType.IRREGULAR));
        staffManager.hireStaff(hotel, new SecurityGuardCreator().createStaff(slave2, StaffType.IRREGULAR));
        for (int i = 0; i < hotel.getStaff().size(); i++) {
            System.out.println(hotel.getStaff().get(i).getPersonalInformation().getName());
        }
        staffManager.makeOrder(Plumber.class, hotel, 2, ""Help, our pump was broken :("");
    }",loop_control
updatedW,"{
        staff = staff.stream().map(w -> {
            for (Staff updatedW : updatedStaff) {
                if (updatedW.getPersonalInformation().getId() == w.getPersonalInformation().getId()) {
                    return updatedW;
                }
            }
            return w;
        }).collect(Collectors.toCollection(ArrayList::new));
    }",iterator
deletedW,"{
        staff = staff.stream().filter(w -> {
            for (Staff deletedW : deletedStaff) {
                if (deletedW.getPersonalInformation().getId() == w.getPersonalInformation().getId()) {
                    return false;
                }
            }
            return true;
        }).collect(Collectors.toCollection(ArrayList::new));
    }",iterator
currentStaff,"{
        staff.addAll(Arrays.stream(createdStaff).filter(w ->
        {
            for (Staff currentStaff : staff) {
                if (currentStaff.getPersonalInformation().getId() == w.getPersonalInformation().getId()) {
                    return false;
                }
            }
            return true;
        }).collect(Collectors.toCollection(ArrayList::new)));
    }",iterator
updatedW,"{
        rooms = rooms.stream().map(w -> {
            for (Room updatedW : updatedRooms) {
                if (updatedW.getNumber() == w.getNumber()) {
                    return updatedW;
                }
            }
            return w;
        }).collect(Collectors.toCollection(ArrayList::new));
    }",iterator
deletedW,"{
        rooms = rooms.stream().filter(w -> {
            for (Room deletedW : deletedRooms) {
                if (deletedW.getNumber() == w.getNumber()) {
                    return false;
                }
            }
            return true;
        }).collect(Collectors.toCollection(ArrayList::new));
    }",iterator
i,"{
        Room currentRoom;
        for (int i = 0; i < access.getRooms().size(); i++) {
            currentRoom = access.getRooms().get(i);
            if (currentRoom.isOccupied()) {
                continue;
            }
            if (currentRoom.getSize() < peopleCount) {
                continue;
            }
            if (currentRoom.getType() != type) {
                continue;
            }
            currentRoom.checkIn(client, peopleCount);
            break;
        }
    }",loop_control
i,"{
        @Param({ ""1"", ""100"", ""1000"" })
        //        @Param({ ""1000"" })
        public int size;

        private Blackhole bh;
        List<Flowable<Integer>> observables;

        @Setup
        public void setup(final Blackhole bh) {
            this.bh = bh;
            observables = new ArrayList<>();
            for (int i = 0; i < size; i++) {
                observables.add(Flowable.just(i));
            }
        }

        public PerfSubscriber newLatchedObserver() {
            return new PerfSubscriber(bh);
        }
    }",loop_control
i,"{
        for (int i = 0; i < 1000; i++) {
            unbounded.onNext(1);
        }
    }",loop_control
i,"{
        for (int i = 0; i < 1000000; i++) {
            unbounded.onNext(1);
        }
    }",loop_control
i,"{
        for (int i = 0; i < 1000; i++) {
            bounded.onNext(1);
        }
    }",loop_control
i,"{
        for (int i = 0; i < 1000000; i++) {
            bounded.onNext(1);
        }
    }",loop_control
i,"{
        for (int i = 0; i < 1000; i++) {
            subject.onNext(1);
        }
    }",loop_control
i,"{
        for (int i = 0; i < 1000000; i++) {
            subject.onNext(1);
        }
    }",loop_control
j,"{
        ToFlowablePerf p = new ToFlowablePerf();
        p.times = 1000000;
        p.setup();

        for (int j = 0; j < 15; j++) {
            for (int i = 0; i < 600; i++) {
                o = p.flowable();
            }
            System.out.println(""--- "" + j);
        }
    }",loop_control
i,"{
        ToFlowablePerf p = new ToFlowablePerf();
        p.times = 1000000;
        p.setup();

        for (int j = 0; j < 15; j++) {
            for (int i = 0; i < 600; i++) {
                o = p.flowable();
            }
            System.out.println(""--- "" + j);
        }
    }",loop_control
items,"{

        flowable = Flowable.range(1, 1000 * 1000).takeUntil(Flowable.fromCallable(new Callable<Object>() {
            @Override
            public Object call() {
                int c = count;
                while (items < c) { }
                return 1;
            }
        }).subscribeOn(Schedulers.single()));

        observable = Observable.range(1, 1000 * 1000).takeUntil(Observable.fromCallable(new Callable<Object>() {
            @Override
            public Object call() {
                int c = count;
                while (items < c) { }
                return 1;
            }
        }).subscribeOn(Schedulers.single()));
    }",loop_control
c,"{

        flowable = Flowable.range(1, 1000 * 1000).takeUntil(Flowable.fromCallable(new Callable<Object>() {
            @Override
            public Object call() {
                int c = count;
                while (items < c) { }
                return 1;
            }
        }).subscribeOn(Schedulers.single()));

        observable = Observable.range(1, 1000 * 1000).takeUntil(Observable.fromCallable(new Callable<Object>() {
            @Override
            public Object call() {
                int c = count;
                while (items < c) { }
                return 1;
            }
        }).subscribeOn(Schedulers.single()));
    }",loop_control
i,"{

        final int size;

        IncrementingPublisher(int size) {
            this.size = size;
        }

        @Override
        public void subscribe(Subscriber<? super Integer> s) {
            s.onSubscribe(EmptySubscription.INSTANCE);
            for (int i = 0; i < size; i++) {
                s.onNext(i);
            }
            s.onComplete();
        }
    }",loop_control
i,"{
        for (int i = 0; i < TestHelper.RACE_DEFAULT_LOOPS; i++) {
            final FutureSubscriber<Integer> fs = new FutureSubscriber<>();

            Runnable r = new Runnable() {
                @Override
                public void run() {
                    fs.cancel(false);
                }
            };

            TestHelper.race(r, r);
        }
    }",loop_control
i,"{
        for (int i = 0; i < TestHelper.RACE_DEFAULT_LOOPS; i++) {
            final FutureSubscriber<Integer> fs = new FutureSubscriber<>();

            final TestException ex = new TestException();

            Runnable r1 = new Runnable() {
                @Override
                public void run() {
                    fs.cancel(false);
                }
            };

            Runnable r2 = new Runnable() {
                @Override
                public void run() {
                    fs.onError(ex);
                }
            };

            TestHelper.race(r1, r2);
        }
    }",loop_control
i,"{
        for (int i = 0; i < TestHelper.RACE_DEFAULT_LOOPS; i++) {
            final FutureSubscriber<Integer> fs = new FutureSubscriber<>();

            if (i % 3 == 0) {
                fs.onSubscribe(new BooleanSubscription());
            }

            if (i % 2 == 0) {
                fs.onNext(1);
            }

            Runnable r1 = new Runnable() {
                @Override
                public void run() {
                    fs.cancel(false);
                }
            };

            Runnable r2 = new Runnable() {
                @Override
                public void run() {
                    fs.onComplete();
                }
            };

            TestHelper.race(r1, r2);
        }
    }",loop_control
i,"{
        Worker w = Schedulers.computation().createWorker();
        try {
            for (int i = 0; i < 10000; i++) {

                final TestSubscriber<Integer> ts = TestSubscriber.create(0L);
                TestingDeferredScalarSubscriber ds = new TestingDeferredScalarSubscriber(ts);
                ds.setupDownstream();
                ds.onNext(1);

                final AtomicInteger ready = new AtomicInteger(2);

                w.schedule(new Runnable() {
                    @Override
                    public void run() {
                        ready.decrementAndGet();
                        while (ready.get() != 0) { }

                        ts.request(1);
                    }
                });

                ready.decrementAndGet();
                while (ready.get() != 0) { }

                ds.onComplete();

                ts.awaitDone(5, TimeUnit.SECONDS);
                ts.assertValues(1);
                ts.assertNoErrors();
                ts.assertComplete();

            }
        } finally {
            w.dispose();
        }
    }",loop_control
i,"{
        Worker w = Schedulers.io().createWorker();
        Worker w2 = Schedulers.io().createWorker();
        int m = 10000;
        if (Runtime.getRuntime().availableProcessors() < 3) {
            m = 1000;
        }
        try {
            for (int i = 0; i < m; i++) {

                final TestSubscriber<Integer> ts = TestSubscriber.create(0L);
                TestingDeferredScalarSubscriber ds = new TestingDeferredScalarSubscriber(ts);
                ds.setupDownstream();
                ds.onNext(1);

                final AtomicInteger ready = new AtomicInteger(3);

                w.schedule(new Runnable() {
                    @Override
                    public void run() {
                        ready.decrementAndGet();
                        while (ready.get() != 0) { }

                        ts.request(1);
                    }
                });

                w2.schedule(new Runnable() {
                    @Override
                    public void run() {
                        ready.decrementAndGet();
                        while (ready.get() != 0) { }

                        ts.request(1);
                    }
                });

                ready.decrementAndGet();
                while (ready.get() != 0) { }

                ds.onComplete();

                ts.awaitDone(5, TimeUnit.SECONDS);
                ts.assertValues(1);
                ts.assertNoErrors();
                ts.assertComplete();

            }
        } finally {
            w.dispose();
            w2.dispose();
        }
    }",loop_control
i,"{
        for (int i = 0; i < TestHelper.RACE_LONG_LOOPS; i++) {

            TestSubscriber<Integer> ts = new TestSubscriber<>(1);
            Disposable d = Disposable.empty();
            final QueueDrainSubscriber<Integer, Integer, Integer> qd = createUnordered(ts, d);
            ts.onSubscribe(new BooleanSubscription());

            qd.requested(Long.MAX_VALUE);
            Runnable r1 = new Runnable() {
                @Override
                public void run() {
                    qd.onNext(1);
                }
            };

            TestHelper.race(r1, r1);

            ts.assertValuesOnly(1, 1);
        }
    }",loop_control
i,"{
        for (int i = 0; i < TestHelper.RACE_LONG_LOOPS; i++) {

            TestSubscriber<Integer> ts = new TestSubscriber<>(1);
            Disposable d = Disposable.empty();
            final QueueDrainSubscriber<Integer, Integer, Integer> qd = createOrdered(ts, d);
            ts.onSubscribe(new BooleanSubscription());

            qd.requested(Long.MAX_VALUE);
            Runnable r1 = new Runnable() {
                @Override
                public void run() {
                    qd.onNext(1);
                }
            };

            TestHelper.race(r1, r1);

            ts.assertValuesOnly(1, 1);
        }
    }",loop_control
i,"{
        for (int i = 0; i < TestHelper.RACE_DEFAULT_LOOPS; i++) {
            final TestSubscriber<Integer> ts = new TestSubscriber<>(0L);

            final SinglePostCompleteSubscriber<Integer, Integer> spc = new SinglePostCompleteSubscriber<Integer, Integer>(ts) {
                private static final long serialVersionUID = -2848918821531562637L;

                @Override
                public void onNext(Integer t) {
                }

                @Override
                public void onError(Throwable t) {
                }

                @Override
                public void onComplete() {
                    complete(1);
                }
            };

            spc.onSubscribe(new BooleanSubscription());

            Runnable r1 = new Runnable() {
                @Override
                public void run() {
                    spc.onComplete();
                }
            };

            Runnable r2 = new Runnable() {
                @Override
                public void run() {
                    ts.request(1);
                }
            };

            TestHelper.race(r1, r2);

            ts.assertResult(1);
        }
    }",loop_control
i,"{
        final TestException ex = new TestException();
        for (int i = 0; i < TestHelper.RACE_LONG_LOOPS; i++) {
            List<Throwable> errors = TestHelper.trackPluginErrors();
            try {
                final PublishProcessor<Integer> pp = PublishProcessor.create();
                final CompletableSubject cs = CompletableSubject.create();

                TestObserver<Void> to = pp.concatMapCompletable(
                        Functions.justFunction(cs)
                )
                .test();

                pp.onNext(1);

                Runnable r1 = new Runnable() {
                    @Override
                    public void run() {
                        pp.onError(ex);
                    }
                };

                Runnable r2 = new Runnable() {
                    @Override
                    public void run() {
                        cs.onError(ex);
                    }
                };

                TestHelper.race(r1, r2);

                to.assertError(new Predicate<Throwable>() {
                    @Override
                    public boolean test(Throwable e) throws Exception {
                        return e instanceof TestException || e instanceof CompositeException;
                    }
                })
                .assertNotComplete();

                if (!errors.isEmpty()) {
                    TestHelper.assertUndeliverable(errors, 0, TestException.class);
                }
            } finally {
                RxJavaPlugins.reset();
            }
        }
    }",loop_control
i,"{
        for (int i = 0; i < TestHelper.RACE_LONG_LOOPS; i++) {
            final PublishProcessor<Integer> pp = PublishProcessor.create();
            final CompletableSubject cs = CompletableSubject.create();

            final TestObserver<Void> to = pp.concatMapCompletable(
                    Functions.justFunction(cs)
            )
            .test();

            pp.onNext(1);

            Runnable r1 = new Runnable() {
                @Override
                public void run() {
                    pp.onNext(2);
                }
            };

            Runnable r2 = new Runnable() {
                @Override
                public void run() {
                    cs.onComplete();
                    to.dispose();
                }
            };

            TestHelper.race(r1, r2);

            to.assertEmpty();
        }
    }",loop_control
i,"{
        final TestException ex = new TestException();
        for (int i = 0; i < TestHelper.RACE_LONG_LOOPS; i++) {
            List<Throwable> errors = TestHelper.trackPluginErrors();
            try {
                final PublishSubject<Integer> ps = PublishSubject.create();
                final CompletableSubject cs = CompletableSubject.create();

                TestObserver<Void> to = ps.concatMapCompletable(
                        Functions.justFunction(cs)
                )
                .test();

                ps.onNext(1);

                Runnable r1 = new Runnable() {
                    @Override
                    public void run() {
                        ps.onError(ex);
                    }
                };

                Runnable r2 = new Runnable() {
                    @Override
                    public void run() {
                        cs.onError(ex);
                    }
                };

                TestHelper.race(r1, r2);

                to.assertError(new Predicate<Throwable>() {
                    @Override
                    public boolean test(Throwable e) throws Exception {
                        return e instanceof TestException || e instanceof CompositeException;
                    }
                })
                .assertNotComplete();

                if (!errors.isEmpty()) {
                    TestHelper.assertUndeliverable(errors, 0, TestException.class);
                }
            } finally {
                RxJavaPlugins.reset();
            }
        }
    }",loop_control
i,"{
        for (int i = 0; i < TestHelper.RACE_LONG_LOOPS; i++) {
            final PublishSubject<Integer> ps = PublishSubject.create();
            final CompletableSubject cs = CompletableSubject.create();

            final TestObserver<Void> to = ps.concatMapCompletable(
                    Functions.justFunction(cs)
            )
            .test();

            ps.onNext(1);

            Runnable r1 = new Runnable() {
                @Override
                public void run() {
                    ps.onNext(2);
                }
            };

            Runnable r2 = new Runnable() {
                @Override
                public void run() {
                    cs.onComplete();
                    to.dispose();
                }
            };

            TestHelper.race(r1, r2);

            to.assertEmpty();
        }
    }",loop_control
i,"{
        TestObserverEx<Integer> to = Observable.range(1, 1024)
        .concatMapMaybe(new Function<Integer, MaybeSource<Integer>>() {
            @Override
            public MaybeSource<Integer> apply(Integer v)
                    throws Exception {
                if (v % 2 == 0) {
                    return Maybe.just(v).subscribeOn(Schedulers.computation());
                }
                return Maybe.<Integer>empty().subscribeOn(Schedulers.computation());
            }
        })
        .to(TestHelper.<Integer>testConsumer())
        .awaitDone(5, TimeUnit.SECONDS)
        .assertValueCount(512)
        .assertNoErrors()
        .assertComplete()
        ;

        for (int i = 0; i < 512; i ++) {
            to.assertValueAt(i, (i + 1) * 2);
        }
    }",loop_control
i,"{
        for (int i = 0; i < TestHelper.RACE_LONG_LOOPS; i++) {

            final MaybeSubject<Integer> ms = MaybeSubject.create();

            final TestObserver<Integer> to = Observable.just(1)
                    .hide()
                    .concatMapMaybe(Functions.justFunction(ms))
                    .test();

            Runnable r1 = new Runnable() {
                @Override
                public void run() {
                    ms.onSuccess(1);
                }
            };
            Runnable r2 = new Runnable() {
                @Override
                public void run() {
                    to.dispose();
                }
            };

            TestHelper.race(r1, r2);

            to.assertNoErrors();
        }
    }",loop_control
i,"{
        for (int i = 0; i < TestHelper.RACE_LONG_LOOPS; i++) {

            final PublishSubject<Integer> ps = PublishSubject.create();

            final MaybeSubject<Integer> ms = MaybeSubject.create();

            final TestObserver<Integer> to = ps.switchMapMaybeDelayError(new Function<Integer, MaybeSource<Integer>>() {
                @Override
                public MaybeSource<Integer> apply(Integer v)
                        throws Exception {
                            return ms;
                        }
            }).test();

            Runnable r1 = new Runnable() {
                @Override
                public void run() {
                    ps.onNext(1);
                }
            };

            Runnable r2 = new Runnable() {
                @Override
                public void run() {
                    to.dispose();
                }
            };

            TestHelper.race(r1, r2);

            to.assertNoErrors()
            .assertNotComplete();
        }
    }",loop_control
i,"{
        final TestException ex = new TestException();

        for (int i = 0; i < TestHelper.RACE_LONG_LOOPS; i++) {

            List<Throwable> errors = TestHelper.trackPluginErrors();
            try {
                final PublishSubject<Integer> ps = PublishSubject.create();

                final MaybeSubject<Integer> ms = MaybeSubject.create();

                final TestObserverEx<Integer> to = ps.switchMapMaybeDelayError(new Function<Integer, MaybeSource<Integer>>() {
                    @Override
                    public MaybeSource<Integer> apply(Integer v)
                            throws Exception {
                        if (v == 1) {
                            return ms;
                        }
                        return Maybe.never();
                    }
                }).to(TestHelper.<Integer>testConsumer());

                ps.onNext(1);

                Runnable r1 = new Runnable() {
                    @Override
                    public void run() {
                        ps.onNext(2);
                    }
                };

                Runnable r2 = new Runnable() {
                    @Override
                    public void run() {
                        ms.onError(ex);
                    }
                };

                TestHelper.race(r1, r2);

                if (to.errors().size() != 0) {
                    assertTrue(errors.isEmpty());
                    to.assertFailure(TestException.class);
                } else if (!errors.isEmpty()) {
                    TestHelper.assertUndeliverable(errors, 0, TestException.class);
                }
            } finally {
                RxJavaPlugins.reset();
            }
        }
    }",loop_control
i,"{
        final TestException ex = new TestException();
        final TestException ex2 = new TestException();

        for (int i = 0; i < TestHelper.RACE_LONG_LOOPS; i++) {

            List<Throwable> errors = TestHelper.trackPluginErrors();
            try {
                final PublishSubject<Integer> ps = PublishSubject.create();

                final MaybeSubject<Integer> ms = MaybeSubject.create();

                final TestObserver<Integer> to = ps.switchMapMaybeDelayError(new Function<Integer, MaybeSource<Integer>>() {
                    @Override
                    public MaybeSource<Integer> apply(Integer v)
                            throws Exception {
                        if (v == 1) {
                            return ms;
                        }
                        return Maybe.never();
                    }
                }).test();

                ps.onNext(1);

                Runnable r1 = new Runnable() {
                    @Override
                    public void run() {
                        ps.onError(ex);
                    }
                };

                Runnable r2 = new Runnable() {
                    @Override
                    public void run() {
                        ms.onError(ex2);
                    }
                };

                TestHelper.race(r1, r2);

                to.assertError(new Predicate<Throwable>() {
                    @Override
                    public boolean test(Throwable e) throws Exception {
                        return e instanceof TestException || e instanceof CompositeException;
                    }
                });

                if (!errors.isEmpty()) {
                    TestHelper.assertUndeliverable(errors, 0, TestException.class);
                }
            } finally {
                RxJavaPlugins.reset();
            }
        }
    }",loop_control
i,"{
        for (int i = 0; i < TestHelper.RACE_LONG_LOOPS; i++) {

            final PublishSubject<Integer> ps = PublishSubject.create();

            final MaybeSubject<Integer> ms = MaybeSubject.create();

            final TestObserver<Integer> to = ps.switchMapMaybeDelayError(new Function<Integer, MaybeSource<Integer>>() {
                @Override
                public MaybeSource<Integer> apply(Integer v)
                        throws Exception {
                            return ms;
                        }
            }).test();

            Runnable r1 = new Runnable() {
                @Override
                public void run() {
                    ps.onNext(1);
                }
            };

            Runnable r2 = new Runnable() {
                @Override
                public void run() {
                    to.dispose();
                }
            };

            TestHelper.race(r1, r2);

            to.assertNoErrors()
            .assertNotComplete();
        }
    }",loop_control
i,"{
        final TestException ex = new TestException();

        for (int i = 0; i < TestHelper.RACE_LONG_LOOPS; i++) {

            List<Throwable> errors = TestHelper.trackPluginErrors();
            try {
                final PublishSubject<Integer> ps = PublishSubject.create();

                final MaybeSubject<Integer> ms = MaybeSubject.create();

                final TestObserverEx<Integer> to = ps.switchMapMaybeDelayError(new Function<Integer, MaybeSource<Integer>>() {
                    @Override
                    public MaybeSource<Integer> apply(Integer v)
                            throws Exception {
                        if (v == 1) {
                            return ms;
                        }
                        return Maybe.never();
                    }
                }).to(TestHelper.<Integer>testConsumer());

                ps.onNext(1);

                Runnable r1 = new Runnable() {
                    @Override
                    public void run() {
                        ps.onNext(2);
                    }
                };

                Runnable r2 = new Runnable() {
                    @Override
                    public void run() {
                        ms.onError(ex);
                    }
                };

                TestHelper.race(r1, r2);

                if (to.errors().size() != 0) {
                    assertTrue(errors.isEmpty());
                    to.assertFailure(TestException.class);
                } else if (!errors.isEmpty()) {
                    TestHelper.assertUndeliverable(errors, 0, TestException.class);
                }
            } finally {
                RxJavaPlugins.reset();
            }
        }
    }",loop_control
i,"{
        final TestException ex = new TestException();
        final TestException ex2 = new TestException();

        for (int i = 0; i < TestHelper.RACE_LONG_LOOPS; i++) {

            List<Throwable> errors = TestHelper.trackPluginErrors();
            try {
                final PublishSubject<Integer> ps = PublishSubject.create();

                final MaybeSubject<Integer> ms = MaybeSubject.create();

                final TestObserver<Integer> to = ps.switchMapMaybeDelayError(new Function<Integer, MaybeSource<Integer>>() {
                    @Override
                    public MaybeSource<Integer> apply(Integer v)
                            throws Exception {
                        if (v == 1) {
                            return ms;
                        }
                        return Maybe.never();
                    }
                }).test();

                ps.onNext(1);

                Runnable r1 = new Runnable() {
                    @Override
                    public void run() {
                        ps.onError(ex);
                    }
                };

                Runnable r2 = new Runnable() {
                    @Override
                    public void run() {
                        ms.onError(ex2);
                    }
                };

                TestHelper.race(r1, r2);

                to.assertError(new Predicate<Throwable>() {
                    @Override
                    public boolean test(Throwable e) throws Exception {
                        return e instanceof TestException || e instanceof CompositeException;
                    }
                });

                if (!errors.isEmpty()) {
                    TestHelper.assertUndeliverable(errors, 0, TestException.class);
                }
            } finally {
                RxJavaPlugins.reset();
            }
        }
    }",loop_control
i,"{
        for (int i = 0; i < TestHelper.RACE_LONG_LOOPS; i++) {

            final PublishSubject<Integer> ps = PublishSubject.create();

            final MaybeSubject<Integer> ms = MaybeSubject.create();

            final TestObserver<Integer> to = ps.switchMapMaybeDelayError(new Function<Integer, MaybeSource<Integer>>() {
                @Override
                public MaybeSource<Integer> apply(Integer v)
                        throws Exception {
                    if (v == 1) {
                            return ms;
                    }
                    return Maybe.empty();
                }
            }).test();

            ps.onNext(1);

            Runnable r1 = new Runnable() {
                @Override
                public void run() {
                    ps.onNext(2);
                }
            };

            Runnable r2 = new Runnable() {
                @Override
                public void run() {
                    ms.onSuccess(3);
                }
            };

            TestHelper.race(r1, r2);

            to.assertNoErrors()
            .assertNotComplete();
        }
    }",loop_control
i,"{
        for (int i = 0; i < TestHelper.RACE_LONG_LOOPS; i++) {

            final PublishProcessor<Integer> pp = PublishProcessor.create();

            final MaybeSubject<Integer> ms = MaybeSubject.create();

            final TestSubscriber<Integer> ts = pp.switchMapMaybeDelayError(new Function<Integer, MaybeSource<Integer>>() {
                @Override
                public MaybeSource<Integer> apply(Integer v)
                        throws Exception {
                            return ms;
                        }
            }).test();

            Runnable r1 = new Runnable() {
                @Override
                public void run() {
                    pp.onNext(1);
                }
            };

            Runnable r2 = new Runnable() {
                @Override
                public void run() {
                    ts.cancel();
                }
            };

            TestHelper.race(r1, r2);

            ts.assertNoErrors()
            .assertNotComplete();
        }
    }",loop_control
i,"{
        final TestException ex = new TestException();

        for (int i = 0; i < TestHelper.RACE_LONG_LOOPS; i++) {

            List<Throwable> errors = TestHelper.trackPluginErrors();
            try {
                final PublishProcessor<Integer> pp = PublishProcessor.create();

                final MaybeSubject<Integer> ms = MaybeSubject.create();

                final TestSubscriberEx<Integer> ts = pp.switchMapMaybeDelayError(new Function<Integer, MaybeSource<Integer>>() {
                    @Override
                    public MaybeSource<Integer> apply(Integer v)
                            throws Exception {
                        if (v == 1) {
                            return ms;
                        }
                        return Maybe.never();
                    }
                }).to(TestHelper.<Integer>testConsumer());

                pp.onNext(1);

                Runnable r1 = new Runnable() {
                    @Override
                    public void run() {
                        pp.onNext(2);
                    }
                };

                Runnable r2 = new Runnable() {
                    @Override
                    public void run() {
                        ms.onError(ex);
                    }
                };

                TestHelper.race(r1, r2);

                if (ts.errors().size() != 0) {
                    assertTrue(errors.isEmpty());
                    ts.assertFailure(TestException.class);
                } else if (!errors.isEmpty()) {
                    TestHelper.assertUndeliverable(errors, 0, TestException.class);
                }
            } finally {
                RxJavaPlugins.reset();
            }
        }
    }",loop_control
i,"{
        final TestException ex = new TestException();
        final TestException ex2 = new TestException();

        for (int i = 0; i < TestHelper.RACE_LONG_LOOPS; i++) {

            List<Throwable> errors = TestHelper.trackPluginErrors();
            try {
                final PublishProcessor<Integer> pp = PublishProcessor.create();

                final MaybeSubject<Integer> ms = MaybeSubject.create();

                final TestSubscriber<Integer> ts = pp.switchMapMaybeDelayError(new Function<Integer, MaybeSource<Integer>>() {
                    @Override
                    public MaybeSource<Integer> apply(Integer v)
                            throws Exception {
                        if (v == 1) {
                            return ms;
                        }
                        return Maybe.never();
                    }
                }).test();

                pp.onNext(1);

                Runnable r1 = new Runnable() {
                    @Override
                    public void run() {
                        pp.onError(ex);
                    }
                };

                Runnable r2 = new Runnable() {
                    @Override
                    public void run() {
                        ms.onError(ex2);
                    }
                };

                TestHelper.race(r1, r2);

                ts.assertError(new Predicate<Throwable>() {
                    @Override
                    public boolean test(Throwable e) throws Exception {
                        return e instanceof TestException || e instanceof CompositeException;
                    }
                });

                if (!errors.isEmpty()) {
                    TestHelper.assertUndeliverable(errors, 0, TestException.class);
                }
            } finally {
                RxJavaPlugins.reset();
            }
        }
    }",loop_control
i,"{
        for (int i = 0; i < TestHelper.RACE_LONG_LOOPS; i++) {

            final PublishProcessor<Integer> pp = PublishProcessor.create();

            final MaybeSubject<Integer> ms = MaybeSubject.create();

            final TestSubscriber<Integer> ts = pp.switchMapMaybeDelayError(new Function<Integer, MaybeSource<Integer>>() {
                @Override
                public MaybeSource<Integer> apply(Integer v)
                        throws Exception {
                    if (v == 1) {
                            return ms;
                    }
                    return Maybe.empty();
                }
            }).test();

            pp.onNext(1);

            Runnable r1 = new Runnable() {
                @Override
                public void run() {
                    pp.onNext(2);
                }
            };

            Runnable r2 = new Runnable() {
                @Override
                public void run() {
                    ms.onSuccess(3);
                }
            };

            TestHelper.race(r1, r2);

            ts.assertNoErrors()
            .assertNotComplete();
        }
    }",loop_control
i,"{
        TestSubscriber<Integer> ts = Flowable.range(1, 1024)
        .concatMapSingle(new Function<Integer, SingleSource<Integer>>() {
            @Override
            public SingleSource<Integer> apply(Integer v)
                    throws Exception {
                return Single.just(v);
            }
        }, 32)
        .test(0);

        for (int i = 1; i <= 1024; i++) {
            ts.assertValueCount(i - 1)
            .assertNoErrors()
            .assertNotComplete()
            .requestMore(1)
            .assertValueCount(i)
            .assertNoErrors();
        }

        ts.assertComplete();
    }",loop_control
i,"{
        for (int i = 0; i < TestHelper.RACE_LONG_LOOPS; i++) {

            final SingleSubject<Integer> ss = SingleSubject.create();

            final TestSubscriber<Integer> ts = Flowable.just(1)
                    .hide()
                    .concatMapSingle(Functions.justFunction(ss))
                    .test();

            Runnable r1 = new Runnable() {
                @Override
                public void run() {
                    ss.onSuccess(1);
                }
            };
            Runnable r2 = new Runnable() {
                @Override
                public void run() {
                    ts.cancel();
                }
            };

            TestHelper.race(r1, r2);

            ts.assertNoErrors();
        }
    }",loop_control
i,"{
        for (int i = 0; i < TestHelper.RACE_LONG_LOOPS; i++) {

            final PublishProcessor<Integer> pp = PublishProcessor.create();

            final SingleSubject<Integer> ms = SingleSubject.create();

            final TestSubscriber<Integer> ts = pp.switchMapSingleDelayError(new Function<Integer, SingleSource<Integer>>() {
                @Override
                public SingleSource<Integer> apply(Integer v)
                        throws Exception {
                            return ms;
                        }
            }).test();

            Runnable r1 = new Runnable() {
                @Override
                public void run() {
                    pp.onNext(1);
                }
            };

            Runnable r2 = new Runnable() {
                @Override
                public void run() {
                    ts.cancel();
                }
            };

            TestHelper.race(r1, r2);

            ts.assertNoErrors()
            .assertNotComplete();
        }
    }",loop_control
i,"{
        final TestException ex = new TestException();

        for (int i = 0; i < TestHelper.RACE_LONG_LOOPS; i++) {

            List<Throwable> errors = TestHelper.trackPluginErrors();
            try {
                final PublishProcessor<Integer> pp = PublishProcessor.create();

                final SingleSubject<Integer> ms = SingleSubject.create();

                final TestSubscriberEx<Integer> ts = pp.switchMapSingleDelayError(new Function<Integer, SingleSource<Integer>>() {
                    @Override
                    public SingleSource<Integer> apply(Integer v)
                            throws Exception {
                        if (v == 1) {
                            return ms;
                        }
                        return Single.never();
                    }
                }).to(TestHelper.<Integer>testConsumer());

                pp.onNext(1);

                Runnable r1 = new Runnable() {
                    @Override
                    public void run() {
                        pp.onNext(2);
                    }
                };

                Runnable r2 = new Runnable() {
                    @Override
                    public void run() {
                        ms.onError(ex);
                    }
                };

                TestHelper.race(r1, r2);

                if (ts.errors().size() != 0) {
                    assertTrue(errors.isEmpty());
                    ts.assertFailure(TestException.class);
                } else if (!errors.isEmpty()) {
                    TestHelper.assertUndeliverable(errors, 0, TestException.class);
                }
            } finally {
                RxJavaPlugins.reset();
            }
        }
    }",loop_control
i,"{
        final TestException ex = new TestException();
        final TestException ex2 = new TestException();

        for (int i = 0; i < TestHelper.RACE_LONG_LOOPS; i++) {

            List<Throwable> errors = TestHelper.trackPluginErrors();
            try {
                final PublishProcessor<Integer> pp = PublishProcessor.create();

                final SingleSubject<Integer> ms = SingleSubject.create();

                final TestSubscriber<Integer> ts = pp.switchMapSingleDelayError(new Function<Integer, SingleSource<Integer>>() {
                    @Override
                    public SingleSource<Integer> apply(Integer v)
                            throws Exception {
                        if (v == 1) {
                            return ms;
                        }
                        return Single.never();
                    }
                }).test();

                pp.onNext(1);

                Runnable r1 = new Runnable() {
                    @Override
                    public void run() {
                        pp.onError(ex);
                    }
                };

                Runnable r2 = new Runnable() {
                    @Override
                    public void run() {
                        ms.onError(ex2);
                    }
                };

                TestHelper.race(r1, r2);

                ts.assertError(new Predicate<Throwable>() {
                    @Override
                    public boolean test(Throwable e) throws Exception {
                        return e instanceof TestException || e instanceof CompositeException;
                    }
                });

                if (!errors.isEmpty()) {
                    TestHelper.assertUndeliverable(errors, 0, TestException.class);
                }
            } finally {
                RxJavaPlugins.reset();
            }
        }
    }",loop_control
i,"{
        for (int i = 0; i < TestHelper.RACE_LONG_LOOPS; i++) {

            final PublishProcessor<Integer> pp = PublishProcessor.create();

            final SingleSubject<Integer> ms = SingleSubject.create();

            final TestSubscriber<Integer> ts = pp.switchMapSingleDelayError(new Function<Integer, SingleSource<Integer>>() {
                @Override
                public SingleSource<Integer> apply(Integer v)
                        throws Exception {
                    if (v == 1) {
                            return ms;
                    }
                    return Single.never();
                }
            }).test();

            pp.onNext(1);

            Runnable r1 = new Runnable() {
                @Override
                public void run() {
                    pp.onNext(2);
                }
            };

            Runnable r2 = new Runnable() {
                @Override
                public void run() {
                    ms.onSuccess(3);
                }
            };

            TestHelper.race(r1, r2);

            ts.assertNoErrors()
            .assertNotComplete();
        }
    }",loop_control
i,"{
        for (int i = 0; i < TestHelper.RACE_LONG_LOOPS; i++) {
            final PublishSubject<Integer> ps = PublishSubject.create();
            final CompletableSubject cs = CompletableSubject.create();

            TestObserver<Void> to = ps.switchMapCompletable(Functions.justFunction(cs)).test();

            ps.onNext(1);

            Runnable r1 = new Runnable() {
                @Override
                public void run() {
                    ps.onNext(2);
                }
            };

            Runnable r2 = new Runnable() {
                @Override
                public void run() {
                    cs.onComplete();
                }
            };

            TestHelper.race(r1, r2);

            to.assertEmpty();
        }
    }",loop_control
i,"{
        final TestException ex = new TestException();
        for (int i = 0; i < TestHelper.RACE_LONG_LOOPS; i++) {
            List<Throwable> errors = TestHelper.trackPluginErrors();
            try {
                final PublishSubject<Integer> ps = PublishSubject.create();
                final CompletableSubject cs = CompletableSubject.create();

                TestObserver<Void> to = ps.switchMapCompletable(Functions.justFunction(cs)).test();

                ps.onNext(1);

                Runnable r1 = new Runnable() {
                    @Override
                    public void run() {
                        ps.onNext(2);
                    }
                };

                Runnable r2 = new Runnable() {
                    @Override
                    public void run() {
                        cs.onError(ex);
                    }
                };

                TestHelper.race(r1, r2);

                to.assertError(new Predicate<Throwable>() {
                    @Override
                    public boolean test(Throwable e) throws Exception {
                        return e instanceof TestException || e instanceof CompositeException;
                    }
                });

                if (!errors.isEmpty()) {
                    TestHelper.assertUndeliverable(errors, 0, TestException.class);
                }
            } finally {
                RxJavaPlugins.reset();
            }
        }
    }",loop_control
i,"{
        final TestException ex0 = new TestException();
        final TestException ex = new TestException();
        for (int i = 0; i < TestHelper.RACE_LONG_LOOPS; i++) {
            List<Throwable> errors = TestHelper.trackPluginErrors();
            try {
                final PublishSubject<Integer> ps = PublishSubject.create();
                final CompletableSubject cs = CompletableSubject.create();

                TestObserver<Void> to = ps.switchMapCompletable(Functions.justFunction(cs)).test();

                ps.onNext(1);

                Runnable r1 = new Runnable() {
                    @Override
                    public void run() {
                        ps.onError(ex0);
                    }
                };

                Runnable r2 = new Runnable() {
                    @Override
                    public void run() {
                        cs.onError(ex);
                    }
                };

                TestHelper.race(r1, r2);

                to.assertError(new Predicate<Throwable>() {
                    @Override
                    public boolean test(Throwable e) throws Exception {
                        return e instanceof TestException || e instanceof CompositeException;
                    }
                });

                if (!errors.isEmpty()) {
                    TestHelper.assertUndeliverable(errors, 0, TestException.class);
                }
            } finally {
                RxJavaPlugins.reset();
            }
        }
    }",loop_control
i,"{
        for (int i = 0; i < TestHelper.RACE_LONG_LOOPS; i++) {

            final PublishSubject<Integer> ps = PublishSubject.create();

            final SingleSubject<Integer> ms = SingleSubject.create();

            final TestObserver<Integer> to = ps.switchMapSingleDelayError(new Function<Integer, SingleSource<Integer>>() {
                @Override
                public SingleSource<Integer> apply(Integer v)
                        throws Exception {
                            return ms;
                        }
            }).test();

            Runnable r1 = new Runnable() {
                @Override
                public void run() {
                    ps.onNext(1);
                }
            };

            Runnable r2 = new Runnable() {
                @Override
                public void run() {
                    to.dispose();
                }
            };

            TestHelper.race(r1, r2);

            to.assertNoErrors()
            .assertNotComplete();
        }
    }",loop_control
i,"{
        final TestException ex = new TestException();

        for (int i = 0; i < TestHelper.RACE_LONG_LOOPS; i++) {

            List<Throwable> errors = TestHelper.trackPluginErrors();
            try {
                final PublishSubject<Integer> ps = PublishSubject.create();

                final SingleSubject<Integer> ms = SingleSubject.create();

                final TestObserverEx<Integer> to = ps.switchMapSingleDelayError(new Function<Integer, SingleSource<Integer>>() {
                    @Override
                    public SingleSource<Integer> apply(Integer v)
                            throws Exception {
                        if (v == 1) {
                            return ms;
                        }
                        return Single.never();
                    }
                }).to(TestHelper.<Integer>testConsumer());

                ps.onNext(1);

                Runnable r1 = new Runnable() {
                    @Override
                    public void run() {
                        ps.onNext(2);
                    }
                };

                Runnable r2 = new Runnable() {
                    @Override
                    public void run() {
                        ms.onError(ex);
                    }
                };

                TestHelper.race(r1, r2);

                if (to.errors().size() != 0) {
                    assertTrue(errors.isEmpty());
                    to.assertFailure(TestException.class);
                } else if (!errors.isEmpty()) {
                    TestHelper.assertUndeliverable(errors, 0, TestException.class);
                }
            } finally {
                RxJavaPlugins.reset();
            }
        }
    }",loop_control
i,"{
        final TestException ex = new TestException();
        final TestException ex2 = new TestException();

        for (int i = 0; i < TestHelper.RACE_LONG_LOOPS; i++) {

            List<Throwable> errors = TestHelper.trackPluginErrors();
            try {
                final PublishSubject<Integer> ps = PublishSubject.create();

                final SingleSubject<Integer> ms = SingleSubject.create();

                final TestObserver<Integer> to = ps.switchMapSingleDelayError(new Function<Integer, SingleSource<Integer>>() {
                    @Override
                    public SingleSource<Integer> apply(Integer v)
                            throws Exception {
                        if (v == 1) {
                            return ms;
                        }
                        return Single.never();
                    }
                }).test();

                ps.onNext(1);

                Runnable r1 = new Runnable() {
                    @Override
                    public void run() {
                        ps.onError(ex);
                    }
                };

                Runnable r2 = new Runnable() {
                    @Override
                    public void run() {
                        ms.onError(ex2);
                    }
                };

                TestHelper.race(r1, r2);

                to.assertError(new Predicate<Throwable>() {
                    @Override
                    public boolean test(Throwable e) throws Exception {
                        return e instanceof TestException || e instanceof CompositeException;
                    }
                });

                if (!errors.isEmpty()) {
                    TestHelper.assertUndeliverable(errors, 0, TestException.class);
                }
            } finally {
                RxJavaPlugins.reset();
            }
        }
    }",loop_control
i,"{
        for (int i = 0; i < TestHelper.RACE_LONG_LOOPS; i++) {

            final PublishSubject<Integer> ps = PublishSubject.create();

            final SingleSubject<Integer> ms = SingleSubject.create();

            final TestObserver<Integer> to = ps.switchMapSingleDelayError(new Function<Integer, SingleSource<Integer>>() {
                @Override
                public SingleSource<Integer> apply(Integer v)
                        throws Exception {
                    if (v == 1) {
                            return ms;
                    }
                    return Single.never();
                }
            }).test();

            ps.onNext(1);

            Runnable r1 = new Runnable() {
                @Override
                public void run() {
                    ps.onNext(2);
                }
            };

            Runnable r2 = new Runnable() {
                @Override
                public void run() {
                    ms.onSuccess(3);
                }
            };

            TestHelper.race(r1, r2);

            to.assertNoErrors()
            .assertNotComplete();
        }
    }",loop_control
i,"{
        for (int i = 0; i < TestHelper.RACE_LONG_LOOPS; i++) {

            final SingleSubject<Integer> ss = SingleSubject.create();

            final TestObserver<Integer> to = Observable.just(1)
                    .hide()
                    .concatMapSingle(Functions.justFunction(ss))
                    .test();

            Runnable r1 = new Runnable() {
                @Override
                public void run() {
                    ss.onSuccess(1);
                }
            };
            Runnable r2 = new Runnable() {
                @Override
                public void run() {
                    to.dispose();
                }
            };

            TestHelper.race(r1, r2);

            to.assertNoErrors();
        }
    }",loop_control
i,"{
        for (int i = 0; i < TestHelper.RACE_LONG_LOOPS; i++) {
            final PublishProcessor<Integer> pp = PublishProcessor.create();
            final CompletableSubject cs = CompletableSubject.create();

            TestObserver<Void> to = pp.switchMapCompletable(Functions.justFunction(cs)).test();

            pp.onNext(1);

            Runnable r1 = new Runnable() {
                @Override
                public void run() {
                    pp.onNext(2);
                }
            };

            Runnable r2 = new Runnable() {
                @Override
                public void run() {
                    cs.onComplete();
                }
            };

            TestHelper.race(r1, r2);

            to.assertEmpty();
        }
    }",loop_control
i,"{
        final TestException ex = new TestException();
        for (int i = 0; i < TestHelper.RACE_LONG_LOOPS; i++) {
            List<Throwable> errors = TestHelper.trackPluginErrors();
            try {
                final PublishProcessor<Integer> pp = PublishProcessor.create();
                final CompletableSubject cs = CompletableSubject.create();

                TestObserver<Void> to = pp.switchMapCompletable(Functions.justFunction(cs)).test();

                pp.onNext(1);

                Runnable r1 = new Runnable() {
                    @Override
                    public void run() {
                        pp.onNext(2);
                    }
                };

                Runnable r2 = new Runnable() {
                    @Override
                    public void run() {
                        cs.onError(ex);
                    }
                };

                TestHelper.race(r1, r2);

                to.assertError(new Predicate<Throwable>() {
                    @Override
                    public boolean test(Throwable e) throws Exception {
                        return e instanceof TestException || e instanceof CompositeException;
                    }
                });

                if (!errors.isEmpty()) {
                    TestHelper.assertUndeliverable(errors, 0, TestException.class);
                }
            } finally {
                RxJavaPlugins.reset();
            }
        }
    }",loop_control
i,"{
        final TestException ex0 = new TestException();
        final TestException ex = new TestException();
        for (int i = 0; i < TestHelper.RACE_LONG_LOOPS; i++) {
            List<Throwable> errors = TestHelper.trackPluginErrors();
            try {
                final PublishProcessor<Integer> pp = PublishProcessor.create();
                final CompletableSubject cs = CompletableSubject.create();

                TestObserver<Void> to = pp.switchMapCompletable(Functions.justFunction(cs)).test();

                pp.onNext(1);

                Runnable r1 = new Runnable() {
                    @Override
                    public void run() {
                        pp.onError(ex0);
                    }
                };

                Runnable r2 = new Runnable() {
                    @Override
                    public void run() {
                        cs.onError(ex);
                    }
                };

                TestHelper.race(r1, r2);

                to.assertError(new Predicate<Throwable>() {
                    @Override
                    public boolean test(Throwable e) throws Exception {
                        return e instanceof TestException || e instanceof CompositeException;
                    }
                });

                if (!errors.isEmpty()) {
                    TestHelper.assertUndeliverable(errors, 0, TestException.class);
                }
            } finally {
                RxJavaPlugins.reset();
            }
        }
    }",loop_control
i,"{
        TestSubscriber<Integer> ts = Flowable.range(1, 1024)
        .concatMapMaybe(new Function<Integer, MaybeSource<Integer>>() {
            @Override
            public MaybeSource<Integer> apply(Integer v)
                    throws Exception {
                return Maybe.just(v);
            }
        }, 32)
        .test(0);

        for (int i = 1; i <= 1024; i++) {
            ts.assertValueCount(i - 1)
            .assertNoErrors()
            .assertNotComplete()
            .requestMore(1)
            .assertValueCount(i)
            .assertNoErrors();
        }

        ts.assertComplete();
    }",loop_control
i,"{
        TestSubscriberEx<Integer> ts = Flowable.range(1, 1024)
        .concatMapMaybe(new Function<Integer, MaybeSource<Integer>>() {
            @Override
            public MaybeSource<Integer> apply(Integer v)
                    throws Exception {
                if (v % 2 == 0) {
                    return Maybe.just(v).subscribeOn(Schedulers.computation());
                }
                return Maybe.<Integer>empty().subscribeOn(Schedulers.computation());
            }
        })
        .to(TestHelper.<Integer>testConsumer())
        .awaitDone(5, TimeUnit.SECONDS)
        .assertValueCount(512)
        .assertNoErrors()
        .assertComplete()
        ;

        for (int i = 0; i < 512; i ++) {
            ts.assertValueAt(i, (i + 1) * 2);
        }
    }",loop_control
i,"{
        for (int i = 0; i < TestHelper.RACE_LONG_LOOPS; i++) {

            final MaybeSubject<Integer> ms = MaybeSubject.create();

            final TestSubscriber<Integer> ts = Flowable.just(1)
                    .hide()
                    .concatMapMaybe(Functions.justFunction(ms))
                    .test();

            Runnable r1 = new Runnable() {
                @Override
                public void run() {
                    ms.onSuccess(1);
                }
            };
            Runnable r2 = new Runnable() {
                @Override
                public void run() {
                    ts.cancel();
                }
            };

            TestHelper.race(r1, r2);

            ts.assertNoErrors();
        }
    }",loop_control
i,"{
        Observable.create(new ObservableOnSubscribe<Object>() {
            @Override
            public void subscribe(ObservableEmitter<Object> e) throws Exception {
                final ObservableEmitter<Object> f = e.serialize();

                Runnable r1 = new Runnable() {
                    @Override
                    public void run() {
                        for (int i = 0; i < TestHelper.RACE_DEFAULT_LOOPS; i++) {
                            f.onNext(1);
                        }
                    }
                };

                TestHelper.race(r1, r1);
            }
        })
        .take(TestHelper.RACE_DEFAULT_LOOPS)
        .to(TestHelper.<Object>testConsumer())
        .assertSubscribed()
        .assertValueCount(TestHelper.RACE_DEFAULT_LOOPS)
        .assertComplete()
        .assertNoErrors();
    }",loop_control
i,"{
        Observable.create(new ObservableOnSubscribe<Object>() {
            @Override
            public void subscribe(ObservableEmitter<Object> e) throws Exception {
                final ObservableEmitter<Object> f = e.serialize();

                Runnable r1 = new Runnable() {
                    @Override
                    public void run() {
                        for (int i = 0; i < 1000; i++) {
                            f.onNext(1);
                        }
                    }
                };

                Runnable r2 = new Runnable() {
                    @Override
                    public void run() {
                        for (int i = 0; i < 100; i++) {
                            f.onNext(1);
                        }
                        f.onError(new TestException());
                    }
                };

                TestHelper.race(r1, r2);
            }
        })
        .to(TestHelper.<Object>testConsumer())
        .assertSubscribed()
        .assertNotComplete()
        .assertError(TestException.class);
    }",loop_control
i,"{
        TestObserverEx<Object> to = Observable.create(new ObservableOnSubscribe<Object>() {
            @Override
            public void subscribe(ObservableEmitter<Object> e) throws Exception {
                final ObservableEmitter<Object> f = e.serialize();

                Runnable r1 = new Runnable() {
                    @Override
                    public void run() {
                        for (int i = 0; i < 1000; i++) {
                            f.onNext(1);
                        }
                    }
                };

                Runnable r2 = new Runnable() {
                    @Override
                    public void run() {
                        for (int i = 0; i < 100; i++) {
                            f.onNext(1);
                        }
                        f.onComplete();
                    }
                };

                TestHelper.race(r1, r2);
            }
        })
        .to(TestHelper.<Object>testConsumer())
        .assertSubscribed()
        .assertComplete()
        .assertNoErrors();

        int c = to.values().size();
        assertTrue("""" + c, c >= 100);
    }",loop_control
i,"{
        Observable<Object> source = Observable.create(new ObservableOnSubscribe<Object>() {
            @Override
            public void subscribe(ObservableEmitter<Object> e) throws Exception {
                final ObservableEmitter<Object> f = e.serialize();

                final TestException ex = new TestException();

                Runnable r1 = new Runnable() {
                    @Override
                    public void run() {
                        f.onError(null);
                    }
                };

                Runnable r2 = new Runnable() {
                    @Override
                    public void run() {
                        f.onError(ex);
                    }
                };

                TestHelper.race(r1, r2);
            }
        });

        List<Throwable> errors = TestHelper.trackPluginErrors();

        try {
            for (int i = 0; i < TestHelper.RACE_DEFAULT_LOOPS; i++) {
                source
                .test()
                .assertFailure(Throwable.class);
            }
        } finally {
            RxJavaPlugins.reset();
        }
        assertFalse(errors.isEmpty());
    }",loop_control
i,"{
        Observable<Object> source = Observable.create(new ObservableOnSubscribe<Object>() {
            @Override
            public void subscribe(ObservableEmitter<Object> e) throws Exception {
                final ObservableEmitter<Object> f = e.serialize();

                Runnable r1 = new Runnable() {
                    @Override
                    public void run() {
                        f.onComplete();
                    }
                };

                Runnable r2 = new Runnable() {
                    @Override
                    public void run() {
                        f.onComplete();
                    }
                };

                TestHelper.race(r1, r2);
            }
        });

        for (int i = 0; i < TestHelper.RACE_DEFAULT_LOOPS; i++) {
            source
            .test()
            .assertResult();
        }
    }",loop_control
i,"{
        for (int i = 0; i < TestHelper.RACE_DEFAULT_LOOPS; i++) {
            TestObserver<Integer> to = new TestObserver<>();
            AtomicReference<ObservableEmitter<Integer>> ref = new AtomicReference<>();

            CountDownLatch cdl = new CountDownLatch(1);

            Observable.<Integer>create(emitter -> {
                emitter = emitter.serialize();
                ref.set(emitter);
                emitter.onNext(1);
            })
            .doOnNext(v -> {
                if (v == 1) {
                    TestHelper.raceOther(() -> {
                        ref.get().onNext(2);
                    }, cdl);
                    ref.get().onNext(3);
                }
            })
            .subscribe(to);

            cdl.await();

            to.assertValueCount(3);
        }
    }",loop_control
i,"{
        for (int i = 0; i < TestHelper.RACE_DEFAULT_LOOPS; i++) {
            TestObserver<Integer> to = new TestObserver<>();
            AtomicReference<ObservableEmitter<Integer>> ref = new AtomicReference<>();

            CountDownLatch cdl = new CountDownLatch(1);

            Observable.<Integer>create(emitter -> {
                emitter = emitter.serialize();
                ref.set(emitter);
                emitter.onNext(1);
            })
            .doOnNext(v -> {
                if (v == 1) {
                    TestHelper.raceOther(() -> {
                        ref.get().onNext(2);
                        ref.get().onComplete();
                    }, cdl);
                    ref.get().onNext(3);
                }
            })
            .subscribe(to);

            cdl.await();
        }
    }",loop_control
i,"{
        for (int i = 0; i < TestHelper.RACE_DEFAULT_LOOPS; i++) {
            final PublishSubject<Object> ps1 = PublishSubject.create();
            final PublishSubject<Object> ps2 = PublishSubject.create();

            List<Throwable> errors = TestHelper.trackPluginErrors();

            try {
                TestObserverEx<Observable<Integer>> to = Observable.just(1)
                .groupJoin(
                    Observable.just(2).concatWith(Observable.<Integer>never()),
                    new Function<Integer, ObservableSource<Object>>() {
                        @Override
                        public ObservableSource<Object> apply(Integer left) throws Exception {
                            return ps1;
                        }
                    },
                    new Function<Integer, ObservableSource<Object>>() {
                        @Override
                        public ObservableSource<Object> apply(Integer right) throws Exception {
                            return ps2;
                        }
                    },
                    new BiFunction<Integer, Observable<Integer>, Observable<Integer>>() {
                        @Override
                        public Observable<Integer> apply(Integer r, Observable<Integer> l) throws Exception {
                            return l;
                        }
                    }
                )
                .to(TestHelper.<Observable<Integer>>testConsumer());

                final TestException ex1 = new TestException();
                final TestException ex2 = new TestException();

                Runnable r1 = new Runnable() {
                    @Override
                    public void run() {
                        ps1.onError(ex1);
                    }
                };
                Runnable r2 = new Runnable() {
                    @Override
                    public void run() {
                        ps2.onError(ex2);
                    }
                };

                TestHelper.race(r1, r2);

                to.assertError(Throwable.class).assertSubscribed().assertNotComplete().assertValueCount(1);

                Throwable exc = to.errors().get(0);

                if (exc instanceof CompositeException) {
                    List<Throwable> es = TestHelper.compositeList(exc);
                    TestHelper.assertError(es, 0, TestException.class);
                    TestHelper.assertError(es, 1, TestException.class);
                } else {
                    to.assertError(TestException.class);
                }

                if (!errors.isEmpty()) {
                    TestHelper.assertUndeliverable(errors, 0, TestException.class);
                }
            } finally {
                RxJavaPlugins.reset();
            }
        }
    }",loop_control
i,"{
        for (int i = 0; i < TestHelper.RACE_DEFAULT_LOOPS; i++) {
            final PublishSubject<Object> ps1 = PublishSubject.create();
            final PublishSubject<Object> ps2 = PublishSubject.create();

            List<Throwable> errors = TestHelper.trackPluginErrors();

            try {
                TestObserverEx<Object> to = ps1
                .groupJoin(
                    ps2,
                    new Function<Object, ObservableSource<Object>>() {
                        @Override
                        public ObservableSource<Object> apply(Object left) throws Exception {
                            return Observable.never();
                        }
                    },
                    new Function<Object, ObservableSource<Object>>() {
                        @Override
                        public ObservableSource<Object> apply(Object right) throws Exception {
                            return Observable.never();
                        }
                    },
                    new BiFunction<Object, Observable<Object>, Observable<Object>>() {
                        @Override
                        public Observable<Object> apply(Object r, Observable<Object> l) throws Exception {
                            return l;
                        }
                    }
                )
                .flatMap(Functions.<Observable<Object>>identity())
                .to(TestHelper.<Object>testConsumer());

                final TestException ex1 = new TestException();
                final TestException ex2 = new TestException();

                Runnable r1 = new Runnable() {
                    @Override
                    public void run() {
                        ps1.onError(ex1);
                    }
                };
                Runnable r2 = new Runnable() {
                    @Override
                    public void run() {
                        ps2.onError(ex2);
                    }
                };

                TestHelper.race(r1, r2);

                to.assertError(Throwable.class).assertSubscribed().assertNotComplete().assertNoValues();

                Throwable exc = to.errors().get(0);

                if (exc instanceof CompositeException) {
                    List<Throwable> es = TestHelper.compositeList(exc);
                    TestHelper.assertError(es, 0, TestException.class);
                    TestHelper.assertError(es, 1, TestException.class);
                } else {
                    to.assertError(TestException.class);
                }

                if (!errors.isEmpty()) {
                    TestHelper.assertUndeliverable(errors, 0, TestException.class);
                }
            } finally {
                RxJavaPlugins.reset();
            }
        }
    }",loop_control
i,"{
        for (int i = 0; i < TestHelper.RACE_DEFAULT_LOOPS; i++) {
            final PublishSubject<Integer> ps = PublishSubject.create();

            final TestObserver<Integer> to = ps.takeLast(1, TimeUnit.DAYS).test();

            Runnable r1 = new Runnable() {
                @Override
                public void run() {
                    ps.onComplete();
                }
            };

            Runnable r2 = new Runnable() {
                @Override
                public void run() {
                    to.dispose();
                }
            };

            TestHelper.race(r1, r2);
        }
    }",loop_control
i,"{
        final AtomicInteger effectCounter = new AtomicInteger();
        Observable<Integer> source = Observable.just(1, 2, 3, 4)
        .doOnNext(new Consumer<Integer>() {
            @Override
            public void accept(Integer v) {
                effectCounter.incrementAndGet();
                System.out.println(""Sideeffect #"" + v);
            }
        });

        Observable<Integer> result = source.replay(
        new Function<Observable<Integer>, Observable<Integer>>() {
            @Override
            public Observable<Integer> apply(Observable<Integer> o) {
                return o.take(2);
            }
        });

        for (int i = 1; i < 3; i++) {
            effectCounter.set(0);
            System.out.printf(""- %d -%n"", i);
            result.subscribe(new Consumer<Integer>() {

                @Override
                public void accept(Integer t1) {
                    System.out.println(t1);
                }

            }, new Consumer<Throwable>() {

                @Override
                public void accept(Throwable t1) {
                    t1.printStackTrace();
                }
            },
            new Action() {
                @Override
                public void run() {
                    System.out.println(""Done"");
                }
            });
            assertEquals(2, effectCounter.get());
        }
    }",loop_control
i,"{
        Observable<Integer> source = Observable.range(0, 1000).replay().autoConnect();

        TestObserverEx<Integer> to = new TestObserverEx<>();

        source.subscribe(to);

        to.assertNoErrors();
        to.assertTerminated();
        List<Integer> onNextEvents = to.values();
        assertEquals(1000, onNextEvents.size());

        for (int i = 0; i < 1000; i++) {
            assertEquals((Integer)i, onNextEvents.get(i));
        }
    }",loop_control
i,"{
        Observable<Integer> source = Observable.range(1, 10000);
        for (int i = 0; i < 100; i++) {
            TestObserverEx<Integer> to1 = new TestObserverEx<>();

            Observable<Integer> cached = source.replay().autoConnect();

            cached.observeOn(Schedulers.computation()).subscribe(to1);

            to1.awaitDone(2, TimeUnit.SECONDS);
            to1.assertNoErrors();
            to1.assertTerminated();
            assertEquals(10000, to1.values().size());

            TestObserverEx<Integer> to2 = new TestObserverEx<>();
            cached.observeOn(Schedulers.computation()).subscribe(to2);

            to2.awaitDone(2, TimeUnit.SECONDS);
            to2.assertNoErrors();
            to2.assertTerminated();
            assertEquals(10000, to2.values().size());
        }
    }",loop_control
to,"{
        Observable<Long> source = Observable.interval(1, 1, TimeUnit.MILLISECONDS)
                .take(1000)
                .subscribeOn(Schedulers.io());
        Observable<Long> cached = source.replay().autoConnect();

        Observable<Long> output = cached.observeOn(Schedulers.computation());

        List<TestObserverEx<Long>> list = new ArrayList<>(100);
        for (int i = 0; i < 100; i++) {
            TestObserverEx<Long> to = new TestObserverEx<>();
            list.add(to);
            output.skip(i * 10).take(10).subscribe(to);
        }

        List<Long> expected = new ArrayList<>();
        for (int i = 0; i < 10; i++) {
            expected.add((long)(i - 10));
        }
        int j = 0;
        for (TestObserverEx<Long> to : list) {
            to.awaitDone(3, TimeUnit.SECONDS);
            to.assertNoErrors();
            to.assertTerminated();

            for (int i = j * 10; i < j * 10 + 10; i++) {
                expected.set(i - j * 10, (long)i);
            }

            to.assertValueSequence(expected);

            j++;
        }
    }",iterator
i,"{
        Observable<Long> source = Observable.interval(1, 1, TimeUnit.MILLISECONDS)
                .take(1000)
                .subscribeOn(Schedulers.io());
        Observable<Long> cached = source.replay().autoConnect();

        Observable<Long> output = cached.observeOn(Schedulers.computation());

        List<TestObserverEx<Long>> list = new ArrayList<>(100);
        for (int i = 0; i < 100; i++) {
            TestObserverEx<Long> to = new TestObserverEx<>();
            list.add(to);
            output.skip(i * 10).take(10).subscribe(to);
        }

        List<Long> expected = new ArrayList<>();
        for (int i = 0; i < 10; i++) {
            expected.add((long)(i - 10));
        }
        int j = 0;
        for (TestObserverEx<Long> to : list) {
            to.awaitDone(3, TimeUnit.SECONDS);
            to.assertNoErrors();
            to.assertTerminated();

            for (int i = j * 10; i < j * 10 + 10; i++) {
                expected.set(i - j * 10, (long)i);
            }

            to.assertValueSequence(expected);

            j++;
        }
    }",loop_control
j,"{
        Observable<Long> source = Observable.interval(1, 1, TimeUnit.MILLISECONDS)
                .take(1000)
                .subscribeOn(Schedulers.io());
        Observable<Long> cached = source.replay().autoConnect();

        Observable<Long> output = cached.observeOn(Schedulers.computation());

        List<TestObserverEx<Long>> list = new ArrayList<>(100);
        for (int i = 0; i < 100; i++) {
            TestObserverEx<Long> to = new TestObserverEx<>();
            list.add(to);
            output.skip(i * 10).take(10).subscribe(to);
        }

        List<Long> expected = new ArrayList<>();
        for (int i = 0; i < 10; i++) {
            expected.add((long)(i - 10));
        }
        int j = 0;
        for (TestObserverEx<Long> to : list) {
            to.awaitDone(3, TimeUnit.SECONDS);
            to.assertNoErrors();
            to.assertTerminated();

            for (int i = j * 10; i < j * 10 + 10; i++) {
                expected.set(i - j * 10, (long)i);
            }

            to.assertValueSequence(expected);

            j++;
        }
    }",loop_control
i,"{
        final int m = 4 * 1000 * 1000;
        Observable<Integer> firehose = Observable.unsafeCreate(new ObservableSource<Integer>() {
            @Override
            public void subscribe(Observer<? super Integer> t) {
                t.onSubscribe(Disposable.empty());
                for (int i = 0; i < m; i++) {
                    t.onNext(i);
                }
                t.onComplete();
            }
        });

        TestObserverEx<Integer> to = new TestObserverEx<>();
        firehose.replay().autoConnect().observeOn(Schedulers.computation()).takeLast(100).subscribe(to);

        to.awaitDone(3, TimeUnit.SECONDS);
        to.assertNoErrors();
        to.assertTerminated();

        assertEquals(100, to.values().size());
    }",loop_control
i,"{
        for (int i = 0; i < TestHelper.RACE_DEFAULT_LOOPS; i++) {
            final ConnectableObservable<Integer> co = Observable.range(1, 3).replay();

            Runnable r = new Runnable() {
                @Override
                public void run() {
                    co.connect();
                }
            };

            TestHelper.race(r, r);
        }
    }",loop_control
i,"{
        for (int i = 0; i < TestHelper.RACE_DEFAULT_LOOPS; i++) {
            final ConnectableObservable<Integer> co = Observable.range(1, 3).replay();

            final TestObserver<Integer> to1 = new TestObserver<>();
            final TestObserver<Integer> to2 = new TestObserver<>();

            Runnable r1 = new Runnable() {
                @Override
                public void run() {
                    co.subscribe(to1);
                }
            };

            Runnable r2 = new Runnable() {
                @Override
                public void run() {
                    co.subscribe(to2);
                }
            };

            TestHelper.race(r1, r2);
        }
    }",loop_control
i,"{
        for (int i = 0; i < TestHelper.RACE_DEFAULT_LOOPS; i++) {
            final ConnectableObservable<Integer> co = Observable.range(1, 3).replay();

            final TestObserver<Integer> to1 = new TestObserver<>();
            final TestObserver<Integer> to2 = new TestObserver<>();

            co.subscribe(to1);

            Runnable r1 = new Runnable() {
                @Override
                public void run() {
                    to1.dispose();
                }
            };

            Runnable r2 = new Runnable() {
                @Override
                public void run() {
                    co.subscribe(to2);
                }
            };

            TestHelper.race(r1, r2);
        }
    }",loop_control
i,"{
        for (int i = 0; i < TestHelper.RACE_DEFAULT_LOOPS; i++) {
            final PublishSubject<Integer> ps = PublishSubject.create();

            final ConnectableObservable<Integer> co = ps.replay();

            final TestObserver<Integer> to1 = new TestObserver<>();

            Runnable r1 = new Runnable() {
                @Override
                public void run() {
                    co.subscribe(to1);
                }
            };

            Runnable r2 = new Runnable() {
                @Override
                public void run() {
                    for (int j = 0; j < 1000; j++) {
                        ps.onNext(j);
                    }
                }
            };

            TestHelper.race(r1, r2);
        }
    }",loop_control
j,"{
        for (int i = 0; i < TestHelper.RACE_DEFAULT_LOOPS; i++) {
            final PublishSubject<Integer> ps = PublishSubject.create();

            final ConnectableObservable<Integer> co = ps.replay();

            final TestObserver<Integer> to1 = new TestObserver<>();

            Runnable r1 = new Runnable() {
                @Override
                public void run() {
                    co.subscribe(to1);
                }
            };

            Runnable r2 = new Runnable() {
                @Override
                public void run() {
                    for (int j = 0; j < 1000; j++) {
                        ps.onNext(j);
                    }
                }
            };

            TestHelper.race(r1, r2);
        }
    }",loop_control
i,"{
        for (int i = 0; i < TestHelper.RACE_DEFAULT_LOOPS; i++) {
            final PublishSubject<Integer> ps = PublishSubject.create();

            final ConnectableObservable<Integer> co = ps.replay();

            final TestObserver<Integer> to1 = new TestObserver<>();

            co.subscribe(to1);

            Runnable r1 = new Runnable() {
                @Override
                public void run() {
                    to1.dispose();
                }
            };

            Runnable r2 = new Runnable() {
                @Override
                public void run() {
                    for (int j = 0; j < 1000; j++) {
                        ps.onNext(j);
                    }
                }
            };

            TestHelper.race(r1, r2);
        }
    }",loop_control
j,"{
        for (int i = 0; i < TestHelper.RACE_DEFAULT_LOOPS; i++) {
            final PublishSubject<Integer> ps = PublishSubject.create();

            final ConnectableObservable<Integer> co = ps.replay();

            final TestObserver<Integer> to1 = new TestObserver<>();

            co.subscribe(to1);

            Runnable r1 = new Runnable() {
                @Override
                public void run() {
                    to1.dispose();
                }
            };

            Runnable r2 = new Runnable() {
                @Override
                public void run() {
                    for (int j = 0; j < 1000; j++) {
                        ps.onNext(j);
                    }
                }
            };

            TestHelper.race(r1, r2);
        }
    }",loop_control
i,"{
        for (int i = 0; i < TestHelper.RACE_DEFAULT_LOOPS; i++) {
            final ConnectableObservable<Integer> co = Observable.range(1, 1000).replay();

            final TestObserver<Integer> to1 = new TestObserver<>();

            co.connect();

            Runnable r1 = new Runnable() {
                @Override
                public void run() {
                    co.subscribe(to1);
                }
            };

            Runnable r2 = new Runnable() {
                @Override
                public void run() {
                    to1.dispose();
                }
            };

            TestHelper.race(r1, r2);
        }
    }",loop_control
t,"{
        stringObserver = TestHelper.mockObserver();

        for (Thread t : Thread.getAllStackTraces().keySet()) {
            if (t.getName().startsWith(""RxNewThread"")) {
                count++;
            }
        }
    }",iterator
t,"{
        try {
            Thread.sleep(100);
        } catch (InterruptedException e) {
            // TODO Auto-generated catch block
            e.printStackTrace();
        }
        for (Thread t : Thread.getAllStackTraces().keySet()) {
            if (t.getName().startsWith(""RxNewThread"")) {
                --count;
            }
        }
        if (count != 0) {
            throw new IllegalStateException(""NewThread leak!"");
        }
    }",iterator
unsubscribed,"{

        final AtomicBoolean unsubscribed = new AtomicBoolean();
        final CountDownLatch latch = new CountDownLatch(1);

        Observable<Observable<Long>> source = Observable.unsafeCreate(new ObservableSource<Observable<Long>>() {

            @Override
            public void subscribe(final Observer<? super Observable<Long>> observer) {
                // verbose on purpose so I can track the inside of it
                final Disposable upstream = Disposable.fromRunnable(new Runnable() {
                    @Override
                    public void run() {
                        System.out.println(""*** unsubscribed"");
                        unsubscribed.set(true);
                    }
                });
                observer.onSubscribe(upstream);

                new Thread(new Runnable() {

                    @Override
                    public void run() {

                        while (!unsubscribed.get()) {
                            observer.onNext(Observable.just(1L, 2L));
                        }
                        System.out.println(""Done looping after unsubscribe: "" + unsubscribed.get());
                        observer.onComplete();

                        // mark that the thread is finished
                        latch.countDown();
                    }
                }).start();
            }

        });

        final AtomicInteger count = new AtomicInteger();
        Observable.merge(source).take(6).blockingForEach(new Consumer<Long>() {

            @Override
            public void accept(Long v) {
                System.out.println(""Value: "" + v);
                int c = count.incrementAndGet();
                if (c > 6) {
                    fail(""Should be only 6"");
                }

            }
        });

        latch.await(1000, TimeUnit.MILLISECONDS);

        System.out.println(""unsubscribed: "" + unsubscribed.get());

        assertTrue(unsubscribed.get());

    }",maybe_loop_control
i,"{
        for (int i = 0; i < 100; i++) {
            System.out.println(""testSynchronizationOfMultipleSequencesLoop > "" + i);
            synchronizationOfMultipleSequences();
        }
    }",loop_control
w,"{
        final TestASynchronousObservable o1 = new TestASynchronousObservable();
        final TestASynchronousObservable o2 = new TestASynchronousObservable();

        // use this latch to cause onNext to wait until we're ready to let it go
        final CountDownLatch endLatch = new CountDownLatch(1);

        final AtomicInteger concurrentCounter = new AtomicInteger();
        final AtomicInteger totalCounter = new AtomicInteger();

        Observable<String> m = Observable.merge(Observable.unsafeCreate(o1), Observable.unsafeCreate(o2));
        m.subscribe(new DefaultObserver<String>() {

            @Override
            public void onComplete() {

            }

            @Override
            public void onError(Throwable e) {
                throw new RuntimeException(""failed"", e);
            }

            @Override
            public void onNext(String v) {
                totalCounter.incrementAndGet();
                concurrentCounter.incrementAndGet();
                try {
                    // avoid deadlocking the main thread
                    if (Thread.currentThread().getName().equals(""TestASynchronousObservable"")) {
                        // wait here until we're done asserting
                        endLatch.await();
                    }
                } catch (InterruptedException e) {
                    e.printStackTrace();
                    throw new RuntimeException(""failed"", e);
                } finally {
                    concurrentCounter.decrementAndGet();
                }
            }

        });

        // wait for both observables to send (one should be blocked)
        o1.onNextBeingSent.await();
        o2.onNextBeingSent.await();

        // I can't think of a way to know for sure that both threads have or are trying to send onNext
        // since I can't use a CountDownLatch for ""after"" onNext since I want to catch during it
        // but I can't know for sure onNext is invoked
        // so I'm unfortunately reverting to using a Thread.sleep to allow the process scheduler time
        // to make sure after o1.onNextBeingSent and o2.onNextBeingSent are hit that the following
        // onNext is invoked.

        int timeout = 20;

        while (timeout-- > 0 && concurrentCounter.get() != 1) {
            Thread.sleep(100);
        }

        try { // in try/finally so threads are released via latch countDown even if assertion fails
            assertEquals(1, concurrentCounter.get());
        } finally {
            // release so it can finish
            endLatch.countDown();
        }

        try {
            o1.t.join();
            o2.t.join();
        } catch (InterruptedException e) {
            throw new RuntimeException(e);
        }

        assertEquals(2, totalCounter.get());
        assertEquals(0, concurrentCounter.get());
    }",loop_control
concurrentCounter,"{
        final TestASynchronousObservable o1 = new TestASynchronousObservable();
        final TestASynchronousObservable o2 = new TestASynchronousObservable();

        // use this latch to cause onNext to wait until we're ready to let it go
        final CountDownLatch endLatch = new CountDownLatch(1);

        final AtomicInteger concurrentCounter = new AtomicInteger();
        final AtomicInteger totalCounter = new AtomicInteger();

        Observable<String> m = Observable.merge(Observable.unsafeCreate(o1), Observable.unsafeCreate(o2));
        m.subscribe(new DefaultObserver<String>() {

            @Override
            public void onComplete() {

            }

            @Override
            public void onError(Throwable e) {
                throw new RuntimeException(""failed"", e);
            }

            @Override
            public void onNext(String v) {
                totalCounter.incrementAndGet();
                concurrentCounter.incrementAndGet();
                try {
                    // avoid deadlocking the main thread
                    if (Thread.currentThread().getName().equals(""TestASynchronousObservable"")) {
                        // wait here until we're done asserting
                        endLatch.await();
                    }
                } catch (InterruptedException e) {
                    e.printStackTrace();
                    throw new RuntimeException(""failed"", e);
                } finally {
                    concurrentCounter.decrementAndGet();
                }
            }

        });

        // wait for both observables to send (one should be blocked)
        o1.onNextBeingSent.await();
        o2.onNextBeingSent.await();

        // I can't think of a way to know for sure that both threads have or are trying to send onNext
        // since I can't use a CountDownLatch for ""after"" onNext since I want to catch during it
        // but I can't know for sure onNext is invoked
        // so I'm unfortunately reverting to using a Thread.sleep to allow the process scheduler time
        // to make sure after o1.onNextBeingSent and o2.onNextBeingSent are hit that the following
        // onNext is invoked.

        int timeout = 20;

        while (timeout-- > 0 && concurrentCounter.get() != 1) {
            Thread.sleep(100);
        }

        try { // in try/finally so threads are released via latch countDown even if assertion fails
            assertEquals(1, concurrentCounter.get());
        } finally {
            // release so it can finish
            endLatch.countDown();
        }

        try {
            o1.t.join();
            o2.t.join();
        } catch (InterruptedException e) {
            throw new RuntimeException(e);
        }

        assertEquals(2, totalCounter.get());
        assertEquals(0, concurrentCounter.get());
    }",maybe_loop_control
s,"{

        String[] valuesToReturn;

        TestErrorObservable(String... values) {
            valuesToReturn = values;
        }

        @Override
        public void subscribe(Observer<? super String> observer) {
            observer.onSubscribe(Disposable.empty());
            for (String s : valuesToReturn) {
                if (s == null) {
                    System.out.println(""throwing exception"");
                    observer.onError(new NullPointerException());
                } else {
                    observer.onNext(s);
                }
            }
            observer.onComplete();
        }
    }",iterator
i,"{
        for (int i = 0; i < 10; i++) {
            TestScheduler scheduler1 = new TestScheduler();
            AtomicBoolean os1 = new AtomicBoolean(false);
            Observable<Long> o1 = createObservableOf5IntervalsOf1SecondIncrementsWithSubscriptionHook(scheduler1, os1);

            TestScheduler scheduler2 = new TestScheduler();
            AtomicBoolean os2 = new AtomicBoolean(false);
            Observable<Long> o2 = createObservableOf5IntervalsOf1SecondIncrementsWithSubscriptionHook(scheduler2, os2);

            TestObserver<Long> to = new TestObserver<>();
            Observable.merge(o1, o2).subscribe(to);

            // we haven't incremented time so nothing should be received yet
            to.assertNoValues();

            scheduler1.advanceTimeBy(3, TimeUnit.SECONDS);
            scheduler2.advanceTimeBy(2, TimeUnit.SECONDS);

            to.assertValues(0L, 1L, 2L, 0L, 1L);
            // not unsubscribed yet
            assertFalse(os1.get());
            assertFalse(os2.get());

            // early unsubscribe
            to.dispose();

            assertTrue(os1.get());
            assertTrue(os2.get());

            to.assertValues(0L, 1L, 2L, 0L, 1L);
            // FIXME not happening anymore
//            ts.assertUnsubscribed();
        }
    }",loop_control
i,"{
        Observable<Integer> o = Observable.range(1, 10000).subscribeOn(Schedulers.newThread());

        for (int i = 0; i < 10; i++) {
            Observable<Integer> merge = Observable.merge(o, o, o);
            TestObserverEx<Integer> to = new TestObserverEx<>();
            merge.subscribe(to);

            to.awaitDone(3, TimeUnit.SECONDS);
            to.assertTerminated();
            to.assertNoErrors();
            to.assertComplete();
            List<Integer> onNextEvents = to.values();
            assertEquals(30000, onNextEvents.size());
            //            System.out.println(""onNext: "" + onNextEvents.size() + "" onComplete: "" + ts.getOnCompletedEvents().size());
        }
    }",loop_control
i,"{

        Observable<Integer> o = Observable.unsafeCreate(new ObservableSource<Integer>() {

            @Override
            public void subscribe(final Observer<? super Integer> observer) {
                Worker inner = Schedulers.newThread().createWorker();
                final CompositeDisposable as = new CompositeDisposable();
                as.add(Disposable.empty());
                as.add(inner);

                observer.onSubscribe(as);

                inner.schedule(new Runnable() {

                    @Override
                    public void run() {
                        try {
                            for (int i = 0; i < 100; i++) {
                                observer.onNext(1);
                                try {
                                    Thread.sleep(1);
                                } catch (InterruptedException e) {
                                    e.printStackTrace();
                                }
                            }
                        } catch (Exception e) {
                            observer.onError(e);
                        }
                        as.dispose();
                        observer.onComplete();
                    }

                });
            }
        });

        for (int i = 0; i < 10; i++) {
            Observable<Integer> merge = Observable.merge(o, o, o);
            TestObserver<Integer> to = new TestObserver<>();
            merge.subscribe(to);

            to.awaitDone(5, TimeUnit.SECONDS);
            to.assertComplete();
            List<Integer> onNextEvents = to.values();
            assertEquals(300, onNextEvents.size());
            //            System.out.println(""onNext: "" + onNextEvents.size() + "" onComplete: "" + ts.getOnCompletedEvents().size());
        }
    }",loop_control
i,"{
        Observable<Integer> o = Observable.unsafeCreate(new ObservableSource<Integer>() {

            @Override
            public void subscribe(final Observer<? super Integer> observer) {
                Worker inner = Schedulers.newThread().createWorker();
                final CompositeDisposable as = new CompositeDisposable();
                as.add(Disposable.empty());
                as.add(inner);

                observer.onSubscribe(as);

                inner.schedule(new Runnable() {

                    @Override
                    public void run() {
                        try {
                            for (int i = 0; i < 10000; i++) {
                                observer.onNext(i);
                            }
                        } catch (Exception e) {
                            observer.onError(e);
                        }
                        as.dispose();
                        observer.onComplete();
                        observer.onComplete();
                        observer.onComplete();
                    }

                });
            }
        });

        for (int i = 0; i < 10; i++) {
            Observable<Integer> merge = Observable.merge(o, o, o);
            TestObserver<Integer> to = new TestObserver<>();
            merge.subscribe(to);

            to.awaitDone(5, TimeUnit.SECONDS);
            to.assertNoErrors();
            to.assertComplete();
            List<Integer> onNextEvents = to.values();
            assertEquals(30000, onNextEvents.size());
            //                System.out.println(""onNext: "" + onNextEvents.size() + "" onComplete: "" + ts.getOnCompletedEvents().size());
        }
    }",loop_control
i,"{
        for (int i = 0; i < 1000; i++) {
            System.err.flush();
            System.out.println(""---"");
            System.out.flush();
            backpressureUpstream2();
        }
    }",loop_control
o,"{
        Observable<Integer> o = Observable.fromIterable(new Iterable<Integer>() {
            @Override
            public Iterator<Integer> iterator() {
                return new Iterator<Integer>() {

                    @Override
                    public void remove() {
                    }

                    @Override
                    public Integer next() {
                        return generated.getAndIncrement();
                    }

                    @Override
                    public boolean hasNext() {
                        return true;
                    }
                };
            }
        });
        return o;
    }",iterator
i,"{
        List<Integer> list = new ArrayList<>();
        for (int i = 0; i < 1000; i++) {
            list.add(i);
        }
        Observable<Integer> source = Observable.fromIterable(list);
        source.flatMap(func).subscribe(to);

        if (to.values().size() != 1000) {
            System.out.println(to.values());
        }

        to.assertTerminated();
        to.assertNoErrors();
        to.assertValueSequence(list);
    }",loop_control
req,"{
        for (final int req : new int[] { 16, 32, 64, 128, 256 }) {
            TestObserverEx<Integer> to = new TestObserverEx<Integer>() {
                int remaining = req;

                @Override
                public void onNext(Integer t) {
                    super.onNext(t);
                    if (--remaining == 0) {
                        remaining = req;
                    }
                }
            };
            runMerge(toScalar, to);
        }
    }",iterator
req,"{
        for (final int req : new int[] { 16, 32, 64, 128, 256 }) {
            TestObserverEx<Integer> to = new TestObserverEx<Integer>() {
                int remaining = req;
                @Override
                public void onNext(Integer t) {
                    super.onNext(t);
                    if (--remaining == 0) {
                        remaining = req;
                    }
                }
            };
            runMerge(toHiddenScalar, to);
        }
    }",iterator
i,"{
        final long durationSeconds = 2;
        final long startTime = System.currentTimeMillis();
        for (int i = 0;; i++) {
            //only run this for a max of ten seconds
            if (System.currentTimeMillis() - startTime > TimeUnit.SECONDS.toMillis(durationSeconds)) {
                return;
            }
            if (i % 1000 == 0) {
                System.out.println(""concatMapRangeAsyncLoop > "" + i);
            }
            TestObserverEx<Integer> to = new TestObserverEx<>();
            Observable.range(0, 1000)
            .concatMap(new Function<Integer, Observable<Integer>>() {
                @Override
                public Observable<Integer> apply(Integer t) {
                    return Observable.fromIterable(Arrays.asList(t));
                }
            }, 2, ImmediateThinScheduler.INSTANCE)
            .observeOn(Schedulers.computation()).subscribe(to);

            to.awaitDone(2500, TimeUnit.MILLISECONDS);
            to.assertTerminated();
            to.assertNoErrors();
            assertEquals(1000, to.values().size());
            assertEquals((Integer)999, to.values().get(999));
        }
    }",loop_control
i,"{
        for (int i = 2; i < 10; i++) {
            Observable<Integer>[] obs = new Observable[i];
            Arrays.fill(obs, Observable.just(1));

            Integer[] expected = new Integer[i];
            Arrays.fill(expected, 1);

            Method m = Observable.class.getMethod(""concatArray"", ObservableSource[].class);

            TestObserver<Integer> to = TestObserver.create();

            ((Observable<Integer>)m.invoke(null, new Object[]{obs})).subscribe(to);

            to.assertValues(expected);
            to.assertNoErrors();
            to.assertComplete();
        }
    }",loop_control
i,"{
        for (int i = 2; i < 10; i++) {
            Object[] obs = new Object[i];
            Arrays.fill(obs, 1);

            Integer[] expected = new Integer[i];
            Arrays.fill(expected, 1);

            Method m = Observable.class.getMethod(""startWithArray"", Object[].class);

            TestObserver<Integer> to = TestObserver.create();

            ((Observable<Integer>)m.invoke(Observable.empty(), new Object[]{obs})).subscribe(to);

            to.assertValues(expected);
            to.assertNoErrors();
            to.assertComplete();
        }
    }",loop_control
i,"{
        for (int i = 0; i < TestHelper.RACE_DEFAULT_LOOPS; i++) {
            List<Throwable> errors = TestHelper.trackPluginErrors();
            try {
                final PublishSubject<Integer> ps1 = PublishSubject.create();
                final PublishSubject<Integer> ps2 = PublishSubject.create();

                TestObserver<Void> to = ps1.concatMapCompletable(new Function<Integer, CompletableSource>() {
                    @Override
                    public CompletableSource apply(Integer v) throws Exception {
                        return Completable.fromObservable(ps2);
                    }
                }).test();

                final TestException ex1 = new TestException();
                final TestException ex2 = new TestException();

                Runnable r1 = new Runnable() {
                    @Override
                    public void run() {
                        ps1.onError(ex1);
                    }
                };
                Runnable r2 = new Runnable() {
                    @Override
                    public void run() {
                        ps2.onError(ex2);
                    }
                };

                TestHelper.race(r1, r2);

                to.assertFailure(TestException.class);

                if (!errors.isEmpty()) {
                    TestHelper.assertError(errors, 0, TestException.class);
                }
            } finally {
                RxJavaPlugins.reset();
            }
        }
    }",loop_control
i,"{
        List<Throwable> errors = TestHelper.trackPluginErrors();

        try {
            final PublishSubject<Integer> source = PublishSubject.create();
            final PublishSubject<Integer> signaller = PublishSubject.create();

            for (int i = 0; i < TestHelper.RACE_DEFAULT_LOOPS; i++) {

                TestObserver<Integer> to = source.take(1)
                .repeatWhen(new Function<Observable<Object>, ObservableSource<Integer>>() {
                    @Override
                    public ObservableSource<Integer> apply(Observable<Object> v)
                            throws Exception {
                        return signaller;
                    }
                }).test();

                Runnable r1 = new Runnable() {
                    @Override
                    public void run() {
                        for (int i = 0; i < TestHelper.RACE_DEFAULT_LOOPS; i++) {
                            source.onNext(1);
                        }
                    }
                };
                Runnable r2 = new Runnable() {
                    @Override
                    public void run() {
                        for (int i = 0; i < TestHelper.RACE_DEFAULT_LOOPS; i++) {
                            signaller.onNext(1);
                        }
                    }
                };

                TestHelper.race(r1, r2);

                to.dispose();
            }

            if (!errors.isEmpty()) {
                for (Throwable e : errors) {
                    e.printStackTrace();
                }
                fail(errors + """");
            }
        } finally {
            RxJavaPlugins.reset();
        }
    }",loop_control
e,"{
        List<Throwable> errors = TestHelper.trackPluginErrors();

        try {
            final PublishSubject<Integer> source = PublishSubject.create();
            final PublishSubject<Integer> signaller = PublishSubject.create();

            for (int i = 0; i < TestHelper.RACE_DEFAULT_LOOPS; i++) {

                TestObserver<Integer> to = source.take(1)
                .repeatWhen(new Function<Observable<Object>, ObservableSource<Integer>>() {
                    @Override
                    public ObservableSource<Integer> apply(Observable<Object> v)
                            throws Exception {
                        return signaller;
                    }
                }).test();

                Runnable r1 = new Runnable() {
                    @Override
                    public void run() {
                        for (int i = 0; i < TestHelper.RACE_DEFAULT_LOOPS; i++) {
                            source.onNext(1);
                        }
                    }
                };
                Runnable r2 = new Runnable() {
                    @Override
                    public void run() {
                        for (int i = 0; i < TestHelper.RACE_DEFAULT_LOOPS; i++) {
                            signaller.onNext(1);
                        }
                    }
                };

                TestHelper.race(r1, r2);

                to.dispose();
            }

            if (!errors.isEmpty()) {
                for (Throwable e : errors) {
                    e.printStackTrace();
                }
                fail(errors + """");
            }
        } finally {
            RxJavaPlugins.reset();
        }
    }",iterator
i,"{
        for (int i = 0; i < TestHelper.RACE_DEFAULT_LOOPS; i++) {
            final PublishSubject<Integer> ps = PublishSubject.create();

            final TestObserver<Integer> to = ps.retry(Functions.alwaysTrue()).test();

            final TestException ex = new TestException();

            Runnable r1 = new Runnable() {
                @Override
                public void run() {
                    ps.onError(ex);
                }
            };

            Runnable r2 = new Runnable() {
                @Override
                public void run() {
                    to.dispose();
                }
            };

            TestHelper.race(r1, r2);

            to.assertEmpty();
        }
    }",loop_control
i,"{
        for (int i = 0; i < TestHelper.RACE_DEFAULT_LOOPS; i++) {
            final PublishSubject<Integer> ps = PublishSubject.create();

            final TestObserver<Integer> to = ps.retry(new BiPredicate<Object, Object>() {
                @Override
                public boolean test(Object t1, Object t2) throws Exception {
                    return true;
                }
            }).test();

            final TestException ex = new TestException();

            Runnable r1 = new Runnable() {
                @Override
                public void run() {
                    ps.onError(ex);
                }
            };

            Runnable r2 = new Runnable() {
                @Override
                public void run() {
                    to.dispose();
                }
            };

            TestHelper.race(r1, r2);

            to.assertEmpty();
        }
    }",loop_control
o,"{
        Observable<Integer> o = Observable.fromIterable(new Iterable<Integer>() {
            @Override
            public Iterator<Integer> iterator() {
                return new Iterator<Integer>() {

                    @Override
                    public void remove() {
                    }

                    @Override
                    public Integer next() {
                        return generated.getAndIncrement();
                    }

                    @Override
                    public boolean hasNext() {
                        return true;
                    }
                };
            }
        });
        return o;
    }",iterator
i,"{
        return Observable.unsafeCreate(new ObservableSource<Integer>() {

            @Override
            public void subscribe(final Observer<? super Integer> o) {
                Disposable d = Disposable.empty();
                o.onSubscribe(d);
                for (int i = 1; i <= 5; i++) {
                    if (d.isDisposed()) {
                        break;
                    }
                    numEmitted.incrementAndGet();
                    o.onNext(i);
                    Thread.yield();
                }
                o.onComplete();
            }

        });
    }",loop_control
d,"{
        return Observable.unsafeCreate(new ObservableSource<Integer>() {

            @Override
            public void subscribe(final Observer<? super Integer> o) {
                final Disposable d = Disposable.empty();
                o.onSubscribe(d);
                Thread t = new Thread(new Runnable() {

                    @Override
                    public void run() {
                        System.out.println(""-------> subscribe to infinite sequence"");
                        System.out.println(""Starting thread: "" + Thread.currentThread());
                        int i = 1;
                        while (!d.isDisposed()) {
                            o.onNext(i++);
                            Thread.yield();
                        }
                        o.onComplete();
                        latch.countDown();
                        System.out.println(""Ending thread: "" + Thread.currentThread());
                    }
                });
                t.start();

            }

        });
    }",maybe_loop_control
i,"{
        // https://github.com/ReactiveX/RxJava/issues/1812
        Observable<Integer> zip1 = Observable.zip(Observable.range(0, 1026), Observable.range(0, 1026),
                new BiFunction<Integer, Integer, Integer>() {

                    @Override
                    public Integer apply(Integer i1, Integer i2) {
                        return i1 + i2;
                    }
                });
        Observable<Integer> zip2 = Observable.zip(zip1, Observable.range(0, 1026),
                new BiFunction<Integer, Integer, Integer>() {

                    @Override
                    public Integer apply(Integer i1, Integer i2) {
                        return i1 + i2;
                    }
                });
        List<Integer> expected = new ArrayList<>();
        for (int i = 0; i < 1026; i++) {
            expected.add(i * 3);
        }
        assertEquals(expected, zip2.toList().blockingGet());
    }",loop_control
i,"{
        long startTime = System.currentTimeMillis();
        Observable<Integer> src = Observable.just(1).subscribeOn(Schedulers.computation());

        // now try and generate a hang by zipping src with itself repeatedly. A
        // time limit of 9 seconds ( 1 second less than the test timeout) is
        // used so that this test will not timeout on slow machines.
        int i = 0;
        while (System.currentTimeMillis() - startTime < 9000 && i++ < 100000) {
            int value = Observable.zip(src, src, new BiFunction<Integer, Integer, Integer>() {
                @Override
                public Integer apply(Integer t1, Integer t2) {
                    return t1 + t2 * 10;
                }
            }).blockingSingle(0);

            Assert.assertEquals(11, value);
        }
    }",loop_control
i,"{
        for (int i = 0; i < 500; i++) {
            TestObserver<List<Object>> to = Observable.zip(
                    Observable.just(1).observeOn(Schedulers.single()).map(new Function<Integer, Object>() {
                        @Override
                        public Object apply(Integer v) throws Exception {
                            return Thread.currentThread().getName().substring(0, 4);
                        }
                    }),
                    Observable.just(1).observeOn(Schedulers.computation()).map(new Function<Integer, Object>() {
                        @Override
                        public Object apply(Integer v) throws Exception {
                            return Thread.currentThread().getName().substring(0, 4);
                        }
                    }),
                    new BiFunction<Object, Object, List<Object>>() {
                        @Override
                        public List<Object> apply(Object t1, Object t2) throws Exception {
                            return Arrays.asList(t1, t2);
                        }
                    }
            )
            .test()
            .awaitDone(5, TimeUnit.SECONDS)
            .assertValueCount(1);

            List<Object> list = to.values().get(0);

            assertTrue(list.toString(), list.contains(""RxSi""));
            assertTrue(list.toString(), list.contains(""RxCo""));
        }
    }",loop_control
i,"{
        for (int i = 0; i < TestHelper.RACE_DEFAULT_LOOPS; i++) {
            List<Throwable> errors = TestHelper.trackPluginErrors();
            try {
                final PublishSubject<Integer> ps1 = PublishSubject.create();
                final PublishSubject<Integer> ps2 = PublishSubject.create();

                TestObserver<Integer> to = ps1.concatMap(new Function<Integer, ObservableSource<Integer>>() {
                    @Override
                    public ObservableSource<Integer> apply(Integer v) throws Exception {
                        return ps2;
                    }
                }).test();

                final TestException ex1 = new TestException();
                final TestException ex2 = new TestException();

                Runnable r1 = new Runnable() {
                    @Override
                    public void run() {
                        ps1.onError(ex1);
                    }
                };
                Runnable r2 = new Runnable() {
                    @Override
                    public void run() {
                        ps2.onError(ex2);
                    }
                };

                TestHelper.race(r1, r2);

                to.assertFailure(TestException.class);

                if (!errors.isEmpty()) {
                    TestHelper.assertError(errors, 0, TestException.class);
                }
            } finally {
                RxJavaPlugins.reset();
            }
        }
    }",loop_control
i,"{
        List<Throwable> errors = TestHelper.trackPluginErrors();
        try {
            final PublishSubject<Integer> ps = PublishSubject.create();

            TestObserver<Integer> to = ps.concatMap(new Function<Integer, Observable<Integer>>() {
                @Override
                public Observable<Integer> apply(Integer v)
                        throws Exception {
                    return Observable.just(v + 1);
                }
            }, 1)
            .subscribeWith(new TestObserver<Integer>() {
                @Override
                public void onNext(Integer t) {
                    super.onNext(t);
                    if (t == 1) {
                        for (int i = 1; i < 10; i++) {
                            ps.onNext(i);
                        }
                        ps.onComplete();
                    }
                }
            });

            ps.onNext(0);

            if (!errors.isEmpty()) {
                to.onError(new CompositeException(errors));
            }

            to.assertResult(1, 2, 3, 4, 5, 6, 7, 8, 9, 10);
        } finally {
            RxJavaPlugins.reset();
        }
    }",loop_control
i,"{
        final PublishSubject<Integer> ps = PublishSubject.create();

        TestObserver<Integer> to = ps.concatMap(new Function<Integer, Observable<Integer>>() {
            @Override
            public Observable<Integer> apply(Integer v)
                    throws Exception {
                return Observable.just(v + 1).hide();
            }
        }, 1)
        .subscribeWith(new TestObserver<Integer>() {
            @Override
            public void onNext(Integer t) {
                super.onNext(t);
                if (t == 1) {
                    for (int i = 1; i < 10; i++) {
                        ps.onNext(i);
                    }
                    ps.onComplete();
                }
            }
        });

        ps.onNext(0);

        to.assertResult(1, 2, 3, 4, 5, 6, 7, 8, 9, 10);
    }",loop_control
i,"{

        final AtomicInteger eventCounter = new AtomicInteger();
        final AtomicInteger subscribeCounter = new AtomicInteger();
        final AtomicInteger groupCounter = new AtomicInteger();
        final CountDownLatch latch = new CountDownLatch(1);
        final int count = 100;
        final int groupCount = 2;

        Observable<Event> es = Observable.unsafeCreate(new ObservableSource<Event>() {

            @Override
            public void subscribe(final Observer<? super Event> observer) {
                observer.onSubscribe(Disposable.empty());
                System.out.println(""*** Subscribing to EventStream ***"");
                subscribeCounter.incrementAndGet();
                new Thread(new Runnable() {

                    @Override
                    public void run() {
                        for (int i = 0; i < count; i++) {
                            Event e = new Event();
                            e.source = i % groupCount;
                            e.message = ""Event-"" + i;
                            observer.onNext(e);
                        }
                        observer.onComplete();
                    }

                }).start();
            }

        });

        es.groupBy(new Function<Event, Integer>() {

            @Override
            public Integer apply(Event e) {
                return e.source;
            }
        }).flatMap(new Function<GroupedObservable<Integer, Event>, Observable<String>>() {

            @Override
            public Observable<String> apply(GroupedObservable<Integer, Event> eventGroupedObservable) {
                System.out.println(""GroupedObservable Key: "" + eventGroupedObservable.getKey());
                groupCounter.incrementAndGet();

                return eventGroupedObservable.map(new Function<Event, String>() {

                    @Override
                    public String apply(Event event) {
                        return ""Source: "" + event.source + ""  Message: "" + event.message;
                    }
                });

            }
        }).subscribe(new DefaultObserver<String>() {

            @Override
            public void onComplete() {
                latch.countDown();
            }

            @Override
            public void onError(Throwable e) {
                e.printStackTrace();
                latch.countDown();
            }

            @Override
            public void onNext(String outputMessage) {
                System.out.println(outputMessage);
                eventCounter.incrementAndGet();
            }
        });

        latch.await(5000, TimeUnit.MILLISECONDS);
        assertEquals(1, subscribeCounter.get());
        assertEquals(groupCount, groupCounter.get());
        assertEquals(count, eventCounter.get());

    }",loop_control
d,"{
        return Observable.unsafeCreate(new ObservableSource<Event>() {

            @Override
            public void subscribe(final Observer<? super Event> op) {
                Disposable d = Disposable.empty();
                op.onSubscribe(d);
                subscribeCounter.incrementAndGet();
                int i = 0;
                while (!d.isDisposed()) {
                    i++;
                    Event e = new Event();
                    e.source = i % numGroups;
                    e.message = ""Event-"" + i;
                    op.onNext(e);
                    sentEventCounter.incrementAndGet();
                }
                op.onComplete();
            }

        });
    }",maybe_loop_control
i,"{
        for (int i = 0; i < TestHelper.RACE_LONG_LOOPS; i++) {

            final TestObserver<Integer> to = new TestObserver<>();

            final PublishSubject<Integer> ps = PublishSubject.create();

            ps.groupBy(new Function<Integer, Integer>() {
                @Override
                public Integer apply(Integer v) throws Throwable {
                    return v % 10;
                }
            })
            .flatMap(new Function<GroupedObservable<Integer, Integer>, ObservableSource<Integer>>() {
                @Override
                public ObservableSource<Integer> apply(GroupedObservable<Integer, Integer> v)
                        throws Throwable {
                    return v;
                }
            })
            .subscribe(to);

            Runnable r1 = new Runnable() {
                @Override
                public void run() {
                    for (int j = 0; j < 1000; j++) {
                        ps.onNext(j);
                    }
                }
            };

            Runnable r2 = new Runnable() {
                @Override
                public void run() {
                    to.dispose();
                }
            };

            TestHelper.race(r1, r2);

            assertFalse(""Round "" + i, ps.hasObservers());
        }
    }",loop_control
j,"{
        for (int i = 0; i < TestHelper.RACE_LONG_LOOPS; i++) {

            final TestObserver<Integer> to = new TestObserver<>();

            final PublishSubject<Integer> ps = PublishSubject.create();

            ps.groupBy(new Function<Integer, Integer>() {
                @Override
                public Integer apply(Integer v) throws Throwable {
                    return v % 10;
                }
            })
            .flatMap(new Function<GroupedObservable<Integer, Integer>, ObservableSource<Integer>>() {
                @Override
                public ObservableSource<Integer> apply(GroupedObservable<Integer, Integer> v)
                        throws Throwable {
                    return v;
                }
            })
            .subscribe(to);

            Runnable r1 = new Runnable() {
                @Override
                public void run() {
                    for (int j = 0; j < 1000; j++) {
                        ps.onNext(j);
                    }
                }
            };

            Runnable r2 = new Runnable() {
                @Override
                public void run() {
                    to.dispose();
                }
            };

            TestHelper.race(r1, r2);

            assertFalse(""Round "" + i, ps.hasObservers());
        }
    }",loop_control
i,"{
        for (int i = 0; i < TestHelper.RACE_LONG_LOOPS; i++) {
            BehaviorSubject<Integer> bs = BehaviorSubject.createDefault(1);
            CountDownLatch cdl = new CountDownLatch(1);

            bs.groupBy(v -> 1)
            .doOnNext(g -> {
                TestHelper.raceOther(() -> {
                    g.test();
                }, cdl);
            })
            .test();

            cdl.await();
        }
    }",loop_control
i,"{
        ArrayList<Integer> list = new ArrayList<>(Flowable.bufferSize() * 2);
        for (int i = 1; i <= Flowable.bufferSize() * 2 + 1; i++) {
            list.add(i);
        }

        Observable<Integer> o = Observable.range(1, list.size());

        TestObserverEx<Integer> to = new TestObserverEx<>();

        o.subscribe(to);

        to.assertValueSequence(list);
        to.assertTerminated();
    }",loop_control
i,"{
        int max = 9;
        for (int i = 0; i <= max; i++) {
            try {
                multiThreadedWithNPE();
                return;
            } catch (AssertionError ex) {
                if (i == max) {
                    throw ex;
                }
            }
            Thread.sleep((long)(1000 * Math.random() + 100));
        }
    }",loop_control
i,"{
        int max = 9;
        for (int i = 0; i <= max; i++) {
            try {
                multiThreadedWithNPEinMiddle();
                return;
            } catch (AssertionError ex) {
                if (i == max) {
                    throw ex;
                }
            }
            Thread.sleep((long)(1000 * Math.random() + 100));
        }
    }",loop_control
i,"{
        boolean lessThan9 = false;
        for (int i = 0; i < 3; i++) {
            TestMultiThreadedObservable onSubscribe = new TestMultiThreadedObservable(""one"", ""two"", ""three"", null, ""four"", ""five"", ""six"", ""seven"", ""eight"", ""nine"");
            Observable<String> w = Observable.unsafeCreate(onSubscribe);

            BusyObserver busyobserver = new BusyObserver();

            w.serialize().subscribe(busyobserver);
            onSubscribe.waitToFinish();

            System.out.println(""maxConcurrentThreads: "" + onSubscribe.maxConcurrentThreads.get());
            // this should not always be the full number of items since the error should (very often)
            // stop it before it completes all 9
            System.out.println(""onNext count: "" + busyobserver.onNextCount.get());
            if (busyobserver.onNextCount.get() < 9) {
                lessThan9 = true;
            }
            assertTrue(busyobserver.onError);
            // no onComplete because onError was invoked
            assertFalse(busyobserver.onComplete);
            // non-deterministic because unsubscribe happens after 'waitToFinish' releases
            // so commenting out for now as this is not a critical thing to test here
            // verify(s, times(1)).unsubscribe();

            // we can have concurrency ...
            int n = onSubscribe.maxConcurrentThreads.get();
            assertTrue("""" + n, n > 1);
            // ... but the onNext execution should be single threaded
            assertEquals(1, busyobserver.maxConcurrentThreads.get());
        }
        assertTrue(lessThan9);
    }",loop_control
i,"{

        private final DefaultObserver<String> observer;
        private final int numStringsToSend;

        OnNextThread(DefaultObserver<String> observer, int numStringsToSend) {
            this.observer = observer;
            this.numStringsToSend = numStringsToSend;
        }

        @Override
        public void run() {
            for (int i = 0; i < numStringsToSend; i++) {
                observer.onNext(""aString"");
            }
        }
    }",loop_control
f,"{

        private final DefaultObserver<String> observer;
        private final TestConcurrencyobserverEvent event;
        private final Future<?>[] waitOnThese;

        CompletionThread(DefaultObserver<String> observer, TestConcurrencyobserverEvent event, Future<?>... waitOnThese) {
            this.observer = observer;
            this.event = event;
            this.waitOnThese = waitOnThese;
        }

        @Override
        public void run() {
            /* if we have 'waitOnThese' futures, we'll wait on them before proceeding */
            if (waitOnThese != null) {
                for (Future<?> f : waitOnThese) {
                    try {
                        f.get();
                    } catch (Throwable e) {
                        System.err.println(""Error while waiting on future in CompletionThread"");
                    }
                }
            }

            /* send the event */
            if (event == TestConcurrencyobserverEvent.onError) {
                observer.onError(new RuntimeException(""mocked exception""));
            } else if (event == TestConcurrencyobserverEvent.onComplete) {
                observer.onComplete();

            } else {
                throw new IllegalArgumentException(""Expecting either onError or onComplete"");
            }
        }
    }",iterator
i,"{
        int max = 9;
        for (int i = 0; i <= max; i++) {
            try {
                multiThreadedWithNPE();
                return;
            } catch (AssertionError ex) {
                if (i == max) {
                    throw ex;
                }
            }
            Thread.sleep((long)(1000 * Math.random() + 100));
        }
    }",loop_control
i,"{
        int max = 9;
        for (int i = 0; i <= max; i++) {
            try {
                multiThreadedWithNPEinMiddle();
                return;
            } catch (AssertionError ex) {
                if (i == max) {
                    throw ex;
                }
            }
            Thread.sleep((long)(1000 * Math.random() + 100));
        }
    }",loop_control
i,"{
        boolean lessThan9 = false;
        for (int i = 0; i < 3; i++) {
            TestMultiThreadedObservable onSubscribe = new TestMultiThreadedObservable(""one"", ""two"", ""three"", null, ""four"", ""five"", ""six"", ""seven"", ""eight"", ""nine"");
            Observable<String> w = Observable.unsafeCreate(onSubscribe);

            BusyObserver busyobserver = new BusyObserver();

            w.serialize().subscribe(busyobserver);
            onSubscribe.waitToFinish();

            System.out.println(""maxConcurrentThreads: "" + onSubscribe.maxConcurrentThreads.get());
            // this should not always be the full number of items since the error should (very often)
            // stop it before it completes all 9
            System.out.println(""onNext count: "" + busyobserver.onNextCount.get());
            if (busyobserver.onNextCount.get() < 9) {
                lessThan9 = true;
            }
            assertTrue(busyobserver.onError);
            // no onComplete because onError was invoked
            assertFalse(busyobserver.onComplete);
            // non-deterministic because unsubscribe happens after 'waitToFinish' releases
            // so commenting out for now as this is not a critical thing to test here
            // verify(s, times(1)).unsubscribe();

            // we can have concurrency ...
            int n = onSubscribe.maxConcurrentThreads.get();
            assertTrue("""" + n, n > 1);
            // ... but the onNext execution should be single threaded
            assertEquals(1, busyobserver.maxConcurrentThreads.get());
        }
        assertTrue(lessThan9);
    }",loop_control
i,"{

        private final DefaultObserver<String> observer;
        private final int numStringsToSend;

        OnNextThread(DefaultObserver<String> observer, int numStringsToSend) {
            this.observer = observer;
            this.numStringsToSend = numStringsToSend;
        }

        @Override
        public void run() {
            for (int i = 0; i < numStringsToSend; i++) {
                observer.onNext(""aString"");
            }
        }
    }",loop_control
f,"{

        private final DefaultObserver<String> observer;
        private final TestConcurrencyobserverEvent event;
        private final Future<?>[] waitOnThese;

        CompletionThread(DefaultObserver<String> observer, TestConcurrencyobserverEvent event, Future<?>... waitOnThese) {
            this.observer = observer;
            this.event = event;
            this.waitOnThese = waitOnThese;
        }

        @Override
        public void run() {
            /* if we have 'waitOnThese' futures, we'll wait on them before proceeding */
            if (waitOnThese != null) {
                for (Future<?> f : waitOnThese) {
                    try {
                        f.get();
                    } catch (Throwable e) {
                        System.err.println(""Error while waiting on future in CompletionThread"");
                    }
                }
            }

            /* send the event */
            if (event == TestConcurrencyobserverEvent.onError) {
                observer.onError(new RuntimeException(""mocked exception""));
            } else if (event == TestConcurrencyobserverEvent.onComplete) {
                observer.onComplete();

            } else {
                throw new IllegalArgumentException(""Expecting either onError or onComplete"");
            }
        }
    }",iterator
s,"{

        final String[] values;
        private Thread t;

        TestSingleThreadedObservable(final String... values) {
            this.values = values;

        }

        @Override
        public void subscribe(final Observer<? super String> observer) {
            observer.onSubscribe(Disposable.empty());
            System.out.println(""TestSingleThreadedObservable subscribed to ..."");
            t = new Thread(new Runnable() {

                @Override
                public void run() {
                    try {
                        System.out.println(""running TestSingleThreadedObservable thread"");
                        for (String s : values) {
                            System.out.println(""TestSingleThreadedObservable onNext: "" + s);
                            observer.onNext(s);
                        }
                        observer.onComplete();
                    } catch (Throwable e) {
                        throw new RuntimeException(e);
                    }
                }

            });
            System.out.println(""starting TestSingleThreadedObservable thread"");
            t.start();
            System.out.println(""done starting TestSingleThreadedObservable thread"");
        }

        public void waitToFinish() {
            try {
                t.join();
            } catch (InterruptedException e) {
                throw new RuntimeException(e);
            }
        }

    }",iterator
s,"{
        final String[] values;
        Thread t;
        AtomicInteger threadsRunning = new AtomicInteger();
        AtomicInteger maxConcurrentThreads = new AtomicInteger();
        ExecutorService threadPool;

        TestMultiThreadedObservable(String... values) {
            this.values = values;
            this.threadPool = Executors.newCachedThreadPool();
        }

        @Override
        public void subscribe(final Observer<? super String> observer) {
            observer.onSubscribe(Disposable.empty());
            System.out.println(""TestMultiThreadedObservable subscribed to ..."");
            final NullPointerException npe = new NullPointerException();
            t = new Thread(new Runnable() {

                @Override
                public void run() {
                    try {
                        System.out.println(""running TestMultiThreadedObservable thread"");
                        for (final String s : values) {
                            threadPool.execute(new Runnable() {

                                @Override
                                public void run() {
                                    threadsRunning.incrementAndGet();
                                    try {
                                        // perform onNext call
                                        if (s == null) {
                                            System.out.println(""TestMultiThreadedObservable onNext: null"");
                                            // force an error
                                            throw npe;
                                        } else {
                                            System.out.println(""TestMultiThreadedObservable onNext: "" + s);
                                        }
                                        observer.onNext(s);
                                        // capture 'maxThreads'
                                        int concurrentThreads = threadsRunning.get();
                                        int maxThreads = maxConcurrentThreads.get();
                                        if (concurrentThreads > maxThreads) {
                                            maxConcurrentThreads.compareAndSet(maxThreads, concurrentThreads);
                                        }
                                    } catch (Throwable e) {
                                        observer.onError(e);
                                    } finally {
                                        threadsRunning.decrementAndGet();
                                    }
                                }
                            });
                        }
                        // we are done spawning threads
                        threadPool.shutdown();
                    } catch (Throwable e) {
                        throw new RuntimeException(e);
                    }

                    // wait until all threads are done, then mark it as COMPLETED
                    try {
                        // wait for all the threads to finish
                        threadPool.awaitTermination(2, TimeUnit.SECONDS);
                    } catch (InterruptedException e) {
                        throw new RuntimeException(e);
                    }
                    observer.onComplete();
                }
            });
            System.out.println(""starting TestMultiThreadedObservable thread"");
            t.start();
            System.out.println(""done starting TestMultiThreadedObservable thread"");
        }

        public void waitToFinish() {
            try {
                t.join();
            } catch (InterruptedException e) {
                throw new RuntimeException(e);
            }
        }
    }",iterator
s,"{
        ScheduledExecutorService exec = Executors.newSingleThreadScheduledExecutor();
        try {
            for (Scheduler s : new Scheduler[] { Schedulers.single(), Schedulers.computation(), Schedulers.newThread(), Schedulers.io(), Schedulers.from(exec) }) {
                final TestObserver<Boolean> observer = TestObserver.create();
                observer.withTag(s.getClass().getSimpleName());

                Observable.<Boolean>create(new ObservableOnSubscribe<Boolean>() {
                    @Override
                    public void subscribe(ObservableEmitter<Boolean> emitter) throws Exception {
                      emitter.onNext(Thread.interrupted());
                      emitter.onComplete();
                    }
                })
                .delaySubscription(100, TimeUnit.MILLISECONDS, s)
                .subscribe(observer);

                observer.awaitDone(5, TimeUnit.SECONDS);
                observer.assertValue(false);
            }
        } finally {
            exec.shutdown();
        }
    }",iterator
s,"{

        final String[] values;
        Thread t;

        TestObservable(Subscription s, String... values) {
            this.values = values;
        }

        @Override
        public void subscribe(final Observer<? super String> observer) {
            System.out.println(""TestObservable subscribed to ..."");
            observer.onSubscribe(Disposable.empty());
            t = new Thread(new Runnable() {

                @Override
                public void run() {
                    try {
                        System.out.println(""running TestObservable thread"");
                        for (String s : values) {
                            System.out.println(""TestObservable onNext: "" + s);
                            observer.onNext(s);
                        }
                        throw new RuntimeException(""Forced Failure"");
                    } catch (Throwable e) {
                        observer.onError(e);
                    }
                }

            });
            System.out.println(""starting TestObservable thread"");
            t.start();
            System.out.println(""done starting TestObservable thread"");
        }

    }",iterator
i,"{
        final AtomicInteger count = new AtomicInteger();
        Observable.unsafeCreate(new ObservableSource<Integer>() {

            @Override
            public void subscribe(Observer<? super Integer> observer) {
                Disposable bs = Disposable.empty();
                observer.onSubscribe(bs);
                for (int i = 0; !bs.isDisposed(); i++) {
                    System.out.println(""Emit: "" + i);
                    count.incrementAndGet();
                    observer.onNext(i);
                }
            }

        }).take(100).take(1).blockingForEach(new Consumer<Integer>() {

            @Override
            public void accept(Integer t1) {
                System.out.println(""Receive: "" + t1);

            }

        });

        assertEquals(1, count.get());
    }",loop_control
s,"{

        final String[] values;
        Thread t;

        TestObservableFunc(String... values) {
            this.values = values;
        }

        @Override
        public void subscribe(final Observer<? super String> observer) {
            observer.onSubscribe(Disposable.empty());
            System.out.println(""TestObservable subscribed to ..."");
            t = new Thread(new Runnable() {

                @Override
                public void run() {
                    try {
                        System.out.println(""running TestObservable thread"");
                        for (String s : values) {
                            System.out.println(""TestObservable onNext: "" + s);
                            observer.onNext(s);
                        }
                        observer.onComplete();
                    } catch (Throwable e) {
                        throw new RuntimeException(e);
                    }
                }

            });
            System.out.println(""starting TestObservable thread"");
            t.start();
            System.out.println(""done starting TestObservable thread"");
        }
    }",iterator
d,"{

        @Override
        public void subscribe(Observer<? super Long> op) {
            Disposable d = Disposable.empty();
            op.onSubscribe(d);
            long l = 1;
            while (!d.isDisposed()) {
                op.onNext(l++);
            }
            op.onComplete();
        }

    }",maybe_loop_control
i,"{
        TestScheduler scheduler = new TestScheduler();
        for (int i = 0; i < TestHelper.RACE_DEFAULT_LOOPS; i++) {
            final PublishSubject<Integer> ps = PublishSubject.create();

            final TestObserver<Integer> to = ps.skipLast(1, TimeUnit.DAYS, scheduler).test();

            Runnable r1 = new Runnable() {
                @Override
                public void run() {
                    ps.onComplete();
                }
            };

            Runnable r2 = new Runnable() {
                @Override
                public void run() {
                    to.dispose();
                }
            };

            TestHelper.race(r1, r2);
        }
    }",loop_control
i,"{
        TestScheduler scheduler = new TestScheduler();
        for (int i = 0; i < TestHelper.RACE_DEFAULT_LOOPS; i++) {
            final PublishSubject<Integer> ps = PublishSubject.create();

            final TestObserver<Integer> to = ps.skipLast(1, TimeUnit.DAYS, scheduler, true).test();

            Runnable r1 = new Runnable() {
                @Override
                public void run() {
                    ps.onComplete();
                }
            };

            Runnable r2 = new Runnable() {
                @Override
                public void run() {
                    to.dispose();
                }
            };

            TestHelper.race(r1, r2);
        }
    }",loop_control
i,"{
        TestScheduler scheduler = new TestScheduler();
        for (int i = 0; i < TestHelper.RACE_DEFAULT_LOOPS; i++) {
            final PublishSubject<Integer> ps = PublishSubject.create();

            final TestObserver<Integer> to = ps.skipLast(1, TimeUnit.DAYS, scheduler).test();

            Runnable r1 = new Runnable() {
                @Override
                public void run() {
                    ps.onNext(1);
                }
            };

            Runnable r2 = new Runnable() {
                @Override
                public void run() {
                    to.dispose();
                }
            };

            TestHelper.race(r1, r2);
        }
    }",loop_control
i,"{
        TestScheduler scheduler = new TestScheduler();
        for (int i = 0; i < TestHelper.RACE_DEFAULT_LOOPS; i++) {
            final PublishSubject<Integer> ps = PublishSubject.create();

            final TestObserver<Integer> to = ps.skipLast(1, TimeUnit.DAYS, scheduler, true).test();

            Runnable r1 = new Runnable() {
                @Override
                public void run() {
                    ps.onNext(1);
                    ps.onComplete();
                }
            };

            Runnable r2 = new Runnable() {
                @Override
                public void run() {
                    to.dispose();
                }
            };

            TestHelper.race(r1, r2);
        }
    }",loop_control
i,"{
        // https://github.com/Netflix/RxJava/issues/1451
        final int expectedCount = 3;
        final AtomicInteger count = new AtomicInteger();
        for (int i = 0; i < expectedCount; i++) {
            Observable
                    .just(Boolean.TRUE, Boolean.FALSE)
                    .takeWhile(new Predicate<Boolean>() {
                        @Override
                        public boolean test(Boolean value) {
                            return value;
                        }
                    })
                    .toList()
                    .doOnSuccess(new Consumer<List<Boolean>>() {
                        @Override
                        public void accept(List<Boolean> booleans) {
                            count.incrementAndGet();
                        }
                    })
                    .subscribe();
        }
        assertEquals(expectedCount, count.get());
    }",loop_control
i,"{
        // https://github.com/Netflix/RxJava/issues/1451
        final int expectedCount = 3;
        final AtomicInteger count = new AtomicInteger();
        for (int i = 0; i < expectedCount; i++) {
            Observable
                    .just(Boolean.TRUE, Boolean.FALSE, Boolean.FALSE)
                    .takeWhile(new Predicate<Boolean>() {
                        @Override
                        public boolean test(Boolean value) {
                            return value;
                        }
                    })
                    .toList()
                    .doOnSuccess(new Consumer<List<Boolean>>() {
                        @Override
                        public void accept(List<Boolean> booleans) {
                            count.incrementAndGet();
                        }
                    })
                    .subscribe();
        }
        assertEquals(expectedCount, count.get());
    }",loop_control
i,"{
        for (int i = 2; i < 10; i++) {
            Observable<Integer>[] obs = new Observable[i];
            Arrays.fill(obs, Observable.just(1));

            Integer[] expected = new Integer[i];
            Arrays.fill(expected, 1);

            Method m = Observable.class.getMethod(""concatArrayEager"", ObservableSource[].class);

            TestObserver<Integer> to = TestObserver.create();

            ((Observable<Integer>)m.invoke(null, new Object[]{obs})).subscribe(to);

            to.assertValues(expected);
            to.assertNoErrors();
            to.assertComplete();
        }
    }",loop_control
i,"{
        for (int i = 0; i < TestHelper.RACE_DEFAULT_LOOPS; i++) {
            List<Throwable> errors = TestHelper.trackPluginErrors();
            try {
                final PublishSubject<Integer> ps1 = PublishSubject.create();
                final PublishSubject<Integer> ps2 = PublishSubject.create();

                TestObserverEx<Integer> to = ps1.concatMapEager(new Function<Integer, ObservableSource<Integer>>() {
                    @Override
                    public ObservableSource<Integer> apply(Integer v) throws Exception {
                        return ps2;
                    }
                }).to(TestHelper.<Integer>testConsumer());

                final TestException ex1 = new TestException();
                final TestException ex2 = new TestException();

                ps1.onNext(1);

                Runnable r1 = new Runnable() {
                    @Override
                    public void run() {
                        ps1.onError(ex1);
                    }
                };
                Runnable r2 = new Runnable() {
                    @Override
                    public void run() {
                        ps2.onError(ex2);
                    }
                };

                TestHelper.race(r1, r2);

                to.assertSubscribed().assertNoValues().assertNotComplete();

                Throwable ex = to.errors().get(0);

                if (ex instanceof CompositeException) {
                    List<Throwable> es = TestHelper.errorList(to);
                    TestHelper.assertError(es, 0, TestException.class);
                    TestHelper.assertError(es, 1, TestException.class);
                } else {
                    to.assertError(TestException.class);
                    if (!errors.isEmpty()) {
                        TestHelper.assertUndeliverable(errors, 0, TestException.class);
                    }
                }
            } finally {
                RxJavaPlugins.reset();
            }
        }
    }",loop_control
i,"{
        for (int i = 0; i < TestHelper.RACE_DEFAULT_LOOPS; i++) {
            final PublishSubject<Integer> ps1 = PublishSubject.create();

            final TestObserver<Integer> to = ps1.concatMapEager(new Function<Integer, ObservableSource<Integer>>() {
                @Override
                public ObservableSource<Integer> apply(Integer v) throws Exception {
                    return Observable.never();
                }
            }).test();

            Runnable r1 = new Runnable() {
                @Override
                public void run() {
                    ps1.onNext(1);
                }
            };
            Runnable r2 = new Runnable() {
                @Override
                public void run() {
                    to.dispose();
                }
            };

            TestHelper.race(r1, r2);

            to.assertEmpty();
        }
    }",loop_control
i,"{
        List<Integer>[] list = new ArrayList[100];
        for (int i = 0; i < 100; i++) {
            List<Integer> lst = new ArrayList<>();
            list[i] = lst;
            for (int k = 1; k <= 10; k++) {
                lst.add((i) * 10 + k);
            }
        }

        Observable.range(1, 1000)
        .buffer(10)
        .concatMapEager(new Function<List<Integer>, ObservableSource<List<Integer>>>() {
            @Override
            public ObservableSource<List<Integer>> apply(List<Integer> v)
                    throws Exception {
                return Observable.just(v)
                        .subscribeOn(Schedulers.io())
                        .doOnNext(new Consumer<List<Integer>>() {
                            @Override
                            public void accept(List<Integer> v)
                                    throws Exception {
                                Thread.sleep(new Random().nextInt(20));
                            }
                        });
            }
        }
                , 2, 3)
        .test()
        .awaitDone(5, TimeUnit.SECONDS)
        .assertResult(list);
    }",loop_control
k,"{
        List<Integer>[] list = new ArrayList[100];
        for (int i = 0; i < 100; i++) {
            List<Integer> lst = new ArrayList<>();
            list[i] = lst;
            for (int k = 1; k <= 10; k++) {
                lst.add((i) * 10 + k);
            }
        }

        Observable.range(1, 1000)
        .buffer(10)
        .concatMapEager(new Function<List<Integer>, ObservableSource<List<Integer>>>() {
            @Override
            public ObservableSource<List<Integer>> apply(List<Integer> v)
                    throws Exception {
                return Observable.just(v)
                        .subscribeOn(Schedulers.io())
                        .doOnNext(new Consumer<List<Integer>>() {
                            @Override
                            public void accept(List<Integer> v)
                                    throws Exception {
                                Thread.sleep(new Random().nextInt(20));
                            }
                        });
            }
        }
                , 2, 3)
        .test()
        .awaitDone(5, TimeUnit.SECONDS)
        .assertResult(list);
    }",loop_control
i,"{
        final AtomicLong counter = new AtomicLong();
        final Integer[] numbers = new Integer[5000];
        for (int i = 0; i < numbers.length; i++) {
            numbers[i] = i + 1;
        }
        final int NITERS = 250;
        final CountDownLatch latch = new CountDownLatch(NITERS);
        for (int iters = 0; iters < NITERS; iters++) {
            final CountDownLatch innerLatch = new CountDownLatch(1);
            final PublishSubject<Void> s = PublishSubject.create();
            final AtomicBoolean completed = new AtomicBoolean();
            Observable.fromArray(numbers)
                    .takeUntil(s)
                    .window(50)
                    .flatMap(new Function<Observable<Integer>, Observable<Object>>() {
                        @Override
                        public Observable<Object> apply(Observable<Integer> integerObservable) {
                                return integerObservable
                                        .subscribeOn(Schedulers.computation())
                                        .map(new Function<Integer, Object>() {
                                            @Override
                                            public Object apply(Integer integer) {
                                                    if (integer >= 5 && completed.compareAndSet(false, true)) {
                                                        s.onComplete();
                                                    }
                                                    // do some work
                                                    Math.pow(Math.random(), Math.random());
                                                    return integer * 2;
                                            }
                                        });
                        }
                    })
                    .toList()
                    .doOnSuccess(new Consumer<List<Object>>() {
                        @Override
                        public void accept(List<Object> integers) {
                                counter.incrementAndGet();
                                latch.countDown();
                                innerLatch.countDown();
                        }
                    })
                    .subscribe();
            if (!innerLatch.await(30, TimeUnit.SECONDS)) {
                Assert.fail(""Failed inner latch wait, iteration "" + iters);
            }
        }
        if (!latch.await(30, TimeUnit.SECONDS)) {
            Assert.fail(""Incomplete! Went through "" + latch.getCount() + "" iterations"");
        } else {
            Assert.assertEquals(NITERS, counter.get());
        }
    }",loop_control
iters,"{
        final AtomicLong counter = new AtomicLong();
        final Integer[] numbers = new Integer[5000];
        for (int i = 0; i < numbers.length; i++) {
            numbers[i] = i + 1;
        }
        final int NITERS = 250;
        final CountDownLatch latch = new CountDownLatch(NITERS);
        for (int iters = 0; iters < NITERS; iters++) {
            final CountDownLatch innerLatch = new CountDownLatch(1);
            final PublishSubject<Void> s = PublishSubject.create();
            final AtomicBoolean completed = new AtomicBoolean();
            Observable.fromArray(numbers)
                    .takeUntil(s)
                    .window(50)
                    .flatMap(new Function<Observable<Integer>, Observable<Object>>() {
                        @Override
                        public Observable<Object> apply(Observable<Integer> integerObservable) {
                                return integerObservable
                                        .subscribeOn(Schedulers.computation())
                                        .map(new Function<Integer, Object>() {
                                            @Override
                                            public Object apply(Integer integer) {
                                                    if (integer >= 5 && completed.compareAndSet(false, true)) {
                                                        s.onComplete();
                                                    }
                                                    // do some work
                                                    Math.pow(Math.random(), Math.random());
                                                    return integer * 2;
                                            }
                                        });
                        }
                    })
                    .toList()
                    .doOnSuccess(new Consumer<List<Object>>() {
                        @Override
                        public void accept(List<Object> integers) {
                                counter.incrementAndGet();
                                latch.countDown();
                                innerLatch.countDown();
                        }
                    })
                    .subscribe();
            if (!innerLatch.await(30, TimeUnit.SECONDS)) {
                Assert.fail(""Failed inner latch wait, iteration "" + iters);
            }
        }
        if (!latch.await(30, TimeUnit.SECONDS)) {
            Assert.fail(""Incomplete! Went through "" + latch.getCount() + "" iterations"");
        } else {
            Assert.assertEquals(NITERS, counter.get());
        }
    }",loop_control
it,"{
        TestScheduler scheduler = new TestScheduler();

        Observable<Long> source = Observable.interval(1, TimeUnit.SECONDS, scheduler).take(10);

        Iterable<Long> iter = source.blockingLatest();

        Iterator<Long> it = iter.iterator();

        // only 9 because take(10) will immediately call onComplete when receiving the 10th item
        // which onComplete will overwrite the previous value
        for (int i = 0; i < 9; i++) {
            scheduler.advanceTimeBy(1, TimeUnit.SECONDS);

            Assert.assertTrue(it.hasNext());

            Assert.assertEquals(Long.valueOf(i), it.next());
        }

        scheduler.advanceTimeBy(1, TimeUnit.SECONDS);
        Assert.assertFalse(it.hasNext());
    }",iterator
i,"{
        TestScheduler scheduler = new TestScheduler();

        Observable<Long> source = Observable.interval(1, TimeUnit.SECONDS, scheduler).take(10);

        Iterable<Long> iter = source.blockingLatest();

        Iterator<Long> it = iter.iterator();

        // only 9 because take(10) will immediately call onComplete when receiving the 10th item
        // which onComplete will overwrite the previous value
        for (int i = 0; i < 9; i++) {
            scheduler.advanceTimeBy(1, TimeUnit.SECONDS);

            Assert.assertTrue(it.hasNext());

            Assert.assertEquals(Long.valueOf(i), it.next());
        }

        scheduler.advanceTimeBy(1, TimeUnit.SECONDS);
        Assert.assertFalse(it.hasNext());
    }",loop_control
j,"{
        TestScheduler scheduler = new TestScheduler();

        Observable<Long> source = Observable.interval(1, TimeUnit.SECONDS, scheduler).take(10);

        Iterable<Long> iter = source.blockingLatest();

        for (int j = 0; j < 3; j++) {
            Iterator<Long> it = iter.iterator();

            // only 9 because take(10) will immediately call onComplete when receiving the 10th item
            // which onComplete will overwrite the previous value
            for (int i = 0; i < 9; i++) {
                scheduler.advanceTimeBy(1, TimeUnit.SECONDS);

                Assert.assertTrue(it.hasNext());

                Assert.assertEquals(Long.valueOf(i), it.next());
            }

            scheduler.advanceTimeBy(1, TimeUnit.SECONDS);
            Assert.assertFalse(it.hasNext());
        }
    }",loop_control
i,"{
        TestScheduler scheduler = new TestScheduler();

        Observable<Long> source = Observable.interval(1, TimeUnit.SECONDS, scheduler).take(10);

        Iterable<Long> iter = source.blockingLatest();

        for (int j = 0; j < 3; j++) {
            Iterator<Long> it = iter.iterator();

            // only 9 because take(10) will immediately call onComplete when receiving the 10th item
            // which onComplete will overwrite the previous value
            for (int i = 0; i < 9; i++) {
                scheduler.advanceTimeBy(1, TimeUnit.SECONDS);

                Assert.assertTrue(it.hasNext());

                Assert.assertEquals(Long.valueOf(i), it.next());
            }

            scheduler.advanceTimeBy(1, TimeUnit.SECONDS);
            Assert.assertFalse(it.hasNext());
        }
    }",loop_control
it,"{
        Observable<Long> source = Observable.<Long> empty();

        Iterable<Long> iter = source.blockingLatest();

        Iterator<Long> it = iter.iterator();

        Assert.assertFalse(it.hasNext());

        it.next();
    }",iterator
it,"{
        TestScheduler scheduler = new TestScheduler();

        Observable<Long> source = Observable.interval(1, TimeUnit.SECONDS, scheduler).take(10);

        Iterable<Long> iter = source.blockingLatest();

        Iterator<Long> it = iter.iterator();

        // only 9 because take(10) will immediately call onComplete when receiving the 10th item
        // which onComplete will overwrite the previous value
        for (int i = 0; i < 10; i++) {
            scheduler.advanceTimeBy(1, TimeUnit.SECONDS);

            Assert.assertEquals(Long.valueOf(i), it.next());
        }
    }",iterator
i,"{
        TestScheduler scheduler = new TestScheduler();

        Observable<Long> source = Observable.interval(1, TimeUnit.SECONDS, scheduler).take(10);

        Iterable<Long> iter = source.blockingLatest();

        Iterator<Long> it = iter.iterator();

        // only 9 because take(10) will immediately call onComplete when receiving the 10th item
        // which onComplete will overwrite the previous value
        for (int i = 0; i < 10; i++) {
            scheduler.advanceTimeBy(1, TimeUnit.SECONDS);

            Assert.assertEquals(Long.valueOf(i), it.next());
        }
    }",loop_control
it,"{
        TestScheduler scheduler = new TestScheduler();

        Observable<Long> source = Observable.<Long> error(new RuntimeException(""Forced failure!"")).subscribeOn(scheduler);

        Iterable<Long> iter = source.blockingLatest();

        Iterator<Long> it = iter.iterator();

        scheduler.advanceTimeBy(1, TimeUnit.SECONDS);

        it.hasNext();
    }",iterator
it,"{
        TestScheduler scheduler = new TestScheduler();

        Observable<Long> source = Observable.interval(1, TimeUnit.SECONDS, scheduler).take(10);

        Iterable<Long> iter = source.blockingLatest();

        Iterator<Long> it = iter.iterator();

        // only 9 because take(10) will immediately call onComplete when receiving the 10th item
        // which onComplete will overwrite the previous value
        for (int i = 0; i < 9; i++) {
            scheduler.advanceTimeBy(1, TimeUnit.SECONDS);

            Assert.assertTrue(it.hasNext());

            Assert.assertEquals(Long.valueOf(i), it.next());
        }

        scheduler.advanceTimeBy(1, TimeUnit.SECONDS);
        Assert.assertFalse(it.hasNext());
    }",iterator
i,"{
        TestScheduler scheduler = new TestScheduler();

        Observable<Long> source = Observable.interval(1, TimeUnit.SECONDS, scheduler).take(10);

        Iterable<Long> iter = source.blockingLatest();

        Iterator<Long> it = iter.iterator();

        // only 9 because take(10) will immediately call onComplete when receiving the 10th item
        // which onComplete will overwrite the previous value
        for (int i = 0; i < 9; i++) {
            scheduler.advanceTimeBy(1, TimeUnit.SECONDS);

            Assert.assertTrue(it.hasNext());

            Assert.assertEquals(Long.valueOf(i), it.next());
        }

        scheduler.advanceTimeBy(1, TimeUnit.SECONDS);
        Assert.assertFalse(it.hasNext());
    }",loop_control
j,"{
        TestScheduler scheduler = new TestScheduler();

        Observable<Long> source = Observable.interval(1, TimeUnit.SECONDS, scheduler).take(10);

        Iterable<Long> iter = source.blockingLatest();

        for (int j = 0; j < 3; j++) {
            Iterator<Long> it = iter.iterator();

            // only 9 because take(10) will immediately call onComplete when receiving the 10th item
            // which onComplete will overwrite the previous value
            for (int i = 0; i < 9; i++) {
                scheduler.advanceTimeBy(1, TimeUnit.SECONDS);

                Assert.assertTrue(it.hasNext());

                Assert.assertEquals(Long.valueOf(i), it.next());
            }

            scheduler.advanceTimeBy(1, TimeUnit.SECONDS);
            Assert.assertFalse(it.hasNext());
        }
    }",loop_control
i,"{
        TestScheduler scheduler = new TestScheduler();

        Observable<Long> source = Observable.interval(1, TimeUnit.SECONDS, scheduler).take(10);

        Iterable<Long> iter = source.blockingLatest();

        for (int j = 0; j < 3; j++) {
            Iterator<Long> it = iter.iterator();

            // only 9 because take(10) will immediately call onComplete when receiving the 10th item
            // which onComplete will overwrite the previous value
            for (int i = 0; i < 9; i++) {
                scheduler.advanceTimeBy(1, TimeUnit.SECONDS);

                Assert.assertTrue(it.hasNext());

                Assert.assertEquals(Long.valueOf(i), it.next());
            }

            scheduler.advanceTimeBy(1, TimeUnit.SECONDS);
            Assert.assertFalse(it.hasNext());
        }
    }",loop_control
it,"{
        Observable<Long> source = Observable.<Long> empty();

        Iterable<Long> iter = source.blockingLatest();

        Iterator<Long> it = iter.iterator();

        Assert.assertFalse(it.hasNext());

        it.next();
    }",iterator
it,"{
        TestScheduler scheduler = new TestScheduler();

        Observable<Long> source = Observable.interval(1, TimeUnit.SECONDS, scheduler).take(10);

        Iterable<Long> iter = source.blockingLatest();

        Iterator<Long> it = iter.iterator();

        // only 9 because take(10) will immediately call onComplete when receiving the 10th item
        // which onComplete will overwrite the previous value
        for (int i = 0; i < 10; i++) {
            scheduler.advanceTimeBy(1, TimeUnit.SECONDS);

            Assert.assertEquals(Long.valueOf(i), it.next());
        }
    }",iterator
i,"{
        TestScheduler scheduler = new TestScheduler();

        Observable<Long> source = Observable.interval(1, TimeUnit.SECONDS, scheduler).take(10);

        Iterable<Long> iter = source.blockingLatest();

        Iterator<Long> it = iter.iterator();

        // only 9 because take(10) will immediately call onComplete when receiving the 10th item
        // which onComplete will overwrite the previous value
        for (int i = 0; i < 10; i++) {
            scheduler.advanceTimeBy(1, TimeUnit.SECONDS);

            Assert.assertEquals(Long.valueOf(i), it.next());
        }
    }",loop_control
it,"{
        TestScheduler scheduler = new TestScheduler();

        Observable<Long> source = Observable.<Long> error(new RuntimeException(""Forced failure!"")).subscribeOn(scheduler);

        Iterable<Long> iter = source.blockingLatest();

        Iterator<Long> it = iter.iterator();

        scheduler.advanceTimeBy(1, TimeUnit.SECONDS);

        it.hasNext();
    }",iterator
it,"{
        TestScheduler scheduler = new TestScheduler();

        Observable<Long> source = Observable.<Long> error(new RuntimeException(""Forced failure!"")).subscribeOn(scheduler);

        Iterable<Long> iter = source.blockingLatest();
        Iterator<Long> it = iter.iterator();

        scheduler.advanceTimeBy(1, TimeUnit.SECONDS);

        it.next();
    }",iterator
it,"{
        PublishSubject<Integer> source = PublishSubject.create();
        Observable<Integer> blocker = source;

        Iterable<Integer> iter = blocker.blockingLatest();
        Iterator<Integer> it = iter.iterator();

        source.onNext(1);

        Assert.assertEquals(Integer.valueOf(1), it.next());

        source.onNext(2);
        source.onNext(3);

        Assert.assertEquals(Integer.valueOf(3), it.next());

        source.onNext(4);
        source.onNext(5);
        source.onNext(6);

        Assert.assertEquals(Integer.valueOf(6), it.next());

        source.onNext(7);
        source.onComplete();

        Assert.assertFalse(it.hasNext());
    }",iterator
i,"{
        Iterator<Object> it = Observable.error(new TestException()).blockingLatest().iterator();

        for (int i = 0; i < 3; i++) {
            try {
                it.hasNext();
                fail(""Should have thrown"");
            } catch (TestException ex) {
                // expected
            }
        }
    }",loop_control
it,"{
        Iterator<Object> it = Observable.error(new TestException()).blockingLatest().iterator();

        for (int i = 0; i < 3; i++) {
            try {
                it.hasNext();
                fail(""Should have thrown"");
            } catch (TestException ex) {
                // expected
            }
        }
    }",iterator
it,"{
        Iterator<Object> it = Observable.never().blockingLatest().iterator();

        Thread.currentThread().interrupt();

        try {
            it.hasNext();
        } catch (RuntimeException ex) {
            assertTrue(ex.toString(), ex.getCause() instanceof InterruptedException);
        }
        Thread.interrupted();
    }",iterator
it,"{
        Iterator<Object> it = Observable.never().blockingLatest().iterator();

        List<Throwable> errors = TestHelper.trackPluginErrors();
        try {
            ((Observer<Object>)it).onError(new TestException());

            TestHelper.assertUndeliverable(errors, 0, TestException.class);
        } finally {
            RxJavaPlugins.reset();
        }
    }",iterator
s,"{

        final Disposable upstream;
        final String[] values;
        Thread t;

        TestObservable(Disposable upstream, String... values) {
            this.upstream = upstream;
            this.values = values;
        }

        @Override
        public void subscribe(final Observer<? super String> observer) {
            System.out.println(""TestObservable subscribed to ..."");
            observer.onSubscribe(upstream);
            t = new Thread(new Runnable() {

                @Override
                public void run() {
                    try {
                        System.out.println(""running TestObservable thread"");
                        for (String s : values) {
                            if (""fail"".equals(s)) {
                                throw new RuntimeException(""Forced Failure"");
                            }
                            System.out.println(""TestObservable onNext: "" + s);
                            observer.onNext(s);
                        }
                        System.out.println(""TestObservable onComplete"");
                        observer.onComplete();
                    } catch (Throwable e) {
                        System.out.println(""TestObservable onError: "" + e);
                        observer.onError(e);
                    }
                }

            });
            System.out.println(""starting TestObservable thread"");
            t.start();
            System.out.println(""done starting TestObservable thread"");
        }
    }",iterator
arg,"{
        List<String> list = new ArrayList<>();
        for (String arg : args) {
            list.add(arg);
        }
        return list;
    }",iterator
i,"{
        for (int i = 0; i < TestHelper.RACE_DEFAULT_LOOPS; i++) {
            final TestScheduler scheduler = new TestScheduler();

            final PublishSubject<Object> ps = PublishSubject.create();

            TestObserver<List<Object>> to = ps.buffer(1, TimeUnit.SECONDS, scheduler, 5).test();

            ps.onNext(1);
            ps.onNext(2);
            ps.onNext(3);
            ps.onNext(4);

            Runnable r1 = new Runnable() {
                @Override
                public void run() {
                    ps.onNext(5);
                }
            };

            Runnable r2 = new Runnable() {
                @Override
                public void run() {
                    scheduler.advanceTimeBy(1, TimeUnit.SECONDS);
                }
            };

            TestHelper.race(r1, r2);

            ps.onComplete();

            int items = 0;
            for (List<Object> o : to.values()) {
                items += o.size();
            }

            assertEquals(""Round: "" + i, 5, items);
        }
    }",loop_control
o,"{
        for (int i = 0; i < TestHelper.RACE_DEFAULT_LOOPS; i++) {
            final TestScheduler scheduler = new TestScheduler();

            final PublishSubject<Object> ps = PublishSubject.create();

            TestObserver<List<Object>> to = ps.buffer(1, TimeUnit.SECONDS, scheduler, 5).test();

            ps.onNext(1);
            ps.onNext(2);
            ps.onNext(3);
            ps.onNext(4);

            Runnable r1 = new Runnable() {
                @Override
                public void run() {
                    ps.onNext(5);
                }
            };

            Runnable r2 = new Runnable() {
                @Override
                public void run() {
                    scheduler.advanceTimeBy(1, TimeUnit.SECONDS);
                }
            };

            TestHelper.race(r1, r2);

            ps.onComplete();

            int items = 0;
            for (List<Object> o : to.values()) {
                items += o.size();
            }

            assertEquals(""Round: "" + i, 5, items);
        }
    }",iterator
i,"{
        for (int i = 0; i < TestHelper.RACE_DEFAULT_LOOPS; i++) {
            BehaviorSubject<Integer> bs = BehaviorSubject.createDefault(1);
            PublishSubject<Integer> ps = PublishSubject.create();

            TestObserver<List<Integer>> to = bs
                    .buffer(BehaviorSubject.createDefault(0), v -> ps)
                    .test();

            TestHelper.race(
                    () -> bs.onComplete(),
                    () -> ps.onComplete()
            );

            to.assertResult(Arrays.asList(1));
        }
    }",loop_control
i,"{
        for (int i = 0; i < 100; i++) {
            List<Observable<String>> os = new ArrayList<>();
            os.add(Observable.just(""one"", ""two"", ""three"", ""four"", ""five"").subscribeOn(Schedulers.newThread()));
            os.add(Observable.just(""one"", ""two"", ""three"", ""four"", ""five"").subscribeOn(Schedulers.newThread()));
            os.add(Observable.just(""one"", ""two"", ""three"", ""four"", ""five"").subscribeOn(Schedulers.newThread()));

            List<String> expected = Arrays.asList(""one"", ""two"", ""three"", ""four"", ""five"", ""one"", ""two"", ""three"", ""four"", ""five"", ""one"", ""two"", ""three"", ""four"", ""five"");
            Iterator<String> iter = Observable.merge(os, 1).blockingIterable().iterator();
            List<String> actual = new ArrayList<>();
            while (iter.hasNext()) {
                actual.add(iter.next());
            }
            assertEquals(expected, actual);
        }
    }",loop_control
times,"{
        for (int times = 0; times < 100; times++) {
            int observableCount = 100;
            // Test maxConcurrent from 2 to 12
            int maxConcurrent = 2 + (times % 10);
            AtomicInteger subscriptionCount = new AtomicInteger(0);

            List<Observable<String>> os = new ArrayList<>();
            List<SubscriptionCheckObservable> scos = new ArrayList<>();
            for (int i = 0; i < observableCount; i++) {
                SubscriptionCheckObservable sco = new SubscriptionCheckObservable(subscriptionCount, maxConcurrent);
                scos.add(sco);
                os.add(Observable.unsafeCreate(sco));
            }

            Iterator<String> iter = Observable.merge(os, maxConcurrent).blockingIterable().iterator();
            List<String> actual = new ArrayList<>();
            while (iter.hasNext()) {
                actual.add(iter.next());
            }
            //            System.out.println(""actual: "" + actual);
            assertEquals(5 * observableCount, actual.size());
            for (SubscriptionCheckObservable sco : scos) {
                assertFalse(sco.failed);
            }
        }
    }",loop_control
i,"{
        for (int times = 0; times < 100; times++) {
            int observableCount = 100;
            // Test maxConcurrent from 2 to 12
            int maxConcurrent = 2 + (times % 10);
            AtomicInteger subscriptionCount = new AtomicInteger(0);

            List<Observable<String>> os = new ArrayList<>();
            List<SubscriptionCheckObservable> scos = new ArrayList<>();
            for (int i = 0; i < observableCount; i++) {
                SubscriptionCheckObservable sco = new SubscriptionCheckObservable(subscriptionCount, maxConcurrent);
                scos.add(sco);
                os.add(Observable.unsafeCreate(sco));
            }

            Iterator<String> iter = Observable.merge(os, maxConcurrent).blockingIterable().iterator();
            List<String> actual = new ArrayList<>();
            while (iter.hasNext()) {
                actual.add(iter.next());
            }
            //            System.out.println(""actual: "" + actual);
            assertEquals(5 * observableCount, actual.size());
            for (SubscriptionCheckObservable sco : scos) {
                assertFalse(sco.failed);
            }
        }
    }",loop_control
sco,"{
        for (int times = 0; times < 100; times++) {
            int observableCount = 100;
            // Test maxConcurrent from 2 to 12
            int maxConcurrent = 2 + (times % 10);
            AtomicInteger subscriptionCount = new AtomicInteger(0);

            List<Observable<String>> os = new ArrayList<>();
            List<SubscriptionCheckObservable> scos = new ArrayList<>();
            for (int i = 0; i < observableCount; i++) {
                SubscriptionCheckObservable sco = new SubscriptionCheckObservable(subscriptionCount, maxConcurrent);
                scos.add(sco);
                os.add(Observable.unsafeCreate(sco));
            }

            Iterator<String> iter = Observable.merge(os, maxConcurrent).blockingIterable().iterator();
            List<String> actual = new ArrayList<>();
            while (iter.hasNext()) {
                actual.add(iter.next());
            }
            //            System.out.println(""actual: "" + actual);
            assertEquals(5 * observableCount, actual.size());
            for (SubscriptionCheckObservable sco : scos) {
                assertFalse(sco.failed);
            }
        }
    }",iterator
i,"{
        int n = 10000;
        List<Observable<Integer>> sourceList = new ArrayList<>(n);
        for (int i = 0; i < n; i++) {
            sourceList.add(Observable.just(i));
        }
        Iterator<Integer> it = Observable.merge(Observable.fromIterable(sourceList), 1).blockingIterable().iterator();
        int j = 0;
        while (it.hasNext()) {
            assertEquals((Integer)j, it.next());
            j++;
        }
        assertEquals(j, n);
    }",loop_control
it,"{
        int n = 10000;
        List<Observable<Integer>> sourceList = new ArrayList<>(n);
        for (int i = 0; i < n; i++) {
            sourceList.add(Observable.just(i));
        }
        Iterator<Integer> it = Observable.merge(Observable.fromIterable(sourceList), 1).blockingIterable().iterator();
        int j = 0;
        while (it.hasNext()) {
            assertEquals((Integer)j, it.next());
            j++;
        }
        assertEquals(j, n);
    }",iterator
i,"{
        int n = 10000;
        List<Observable<Integer>> sourceList = new ArrayList<>(n);
        for (int i = 0; i < n; i++) {
            sourceList.add(Observable.just(i));
        }
        Iterator<Integer> it = Observable.merge(Observable.fromIterable(sourceList), 1).take(n / 2).blockingIterable().iterator();
        int j = 0;
        while (it.hasNext()) {
            assertEquals((Integer)j, it.next());
            j++;
        }
        assertEquals(j, n / 2);
    }",loop_control
it,"{
        int n = 10000;
        List<Observable<Integer>> sourceList = new ArrayList<>(n);
        for (int i = 0; i < n; i++) {
            sourceList.add(Observable.just(i));
        }
        Iterator<Integer> it = Observable.merge(Observable.fromIterable(sourceList), 1).take(n / 2).blockingIterable().iterator();
        int j = 0;
        while (it.hasNext()) {
            assertEquals((Integer)j, it.next());
            j++;
        }
        assertEquals(j, n / 2);
    }",iterator
i,"{
        for (int i = 1; i < 100; i++) {
            TestObserverEx<Integer> to = new TestObserverEx<>();
            List<Observable<Integer>> sourceList = new ArrayList<>(i);
            List<Integer> result = new ArrayList<>(i);
            for (int j = 1; j <= i; j++) {
                sourceList.add(Observable.just(j));
                result.add(j);
            }

            Observable.merge(sourceList, i).subscribe(to);

            to.assertNoErrors();
            to.assertTerminated();
            to.assertValueSequence(result);
        }
    }",loop_control
j,"{
        for (int i = 1; i < 100; i++) {
            TestObserverEx<Integer> to = new TestObserverEx<>();
            List<Observable<Integer>> sourceList = new ArrayList<>(i);
            List<Integer> result = new ArrayList<>(i);
            for (int j = 1; j <= i; j++) {
                sourceList.add(Observable.just(j));
                result.add(j);
            }

            Observable.merge(sourceList, i).subscribe(to);

            to.assertNoErrors();
            to.assertTerminated();
            to.assertValueSequence(result);
        }
    }",loop_control
i,"{
        for (int i = 2; i < 100; i++) {
            TestObserverEx<Integer> to = new TestObserverEx<>();
            List<Observable<Integer>> sourceList = new ArrayList<>(i);
            List<Integer> result = new ArrayList<>(i);
            for (int j = 1; j <= i; j++) {
                sourceList.add(Observable.just(j));
                result.add(j);
            }

            Observable.merge(sourceList, i - 1).subscribe(to);

            to.assertNoErrors();
            to.assertTerminated();
            to.assertValueSequence(result);
        }
    }",loop_control
j,"{
        for (int i = 2; i < 100; i++) {
            TestObserverEx<Integer> to = new TestObserverEx<>();
            List<Observable<Integer>> sourceList = new ArrayList<>(i);
            List<Integer> result = new ArrayList<>(i);
            for (int j = 1; j <= i; j++) {
                sourceList.add(Observable.just(j));
                result.add(j);
            }

            Observable.merge(sourceList, i - 1).subscribe(to);

            to.assertNoErrors();
            to.assertTerminated();
            to.assertValueSequence(result);
        }
    }",loop_control
i,"{
        IoScheduler ios = (IoScheduler)Schedulers.io();
        int c = ios.size();
        for (int i = 0; i < 200; i++) {
            simpleAsync();
            int c1 = ios.size();
            if (c + 60 < c1) {
                throw new AssertionError(""Worker leak: "" + c + "" - "" + c1);
            }
        }
    }",loop_control
i,"{
        for (int i = 1; i < 50; i++) {
            TestObserver<Integer> to = new TestObserver<>();
            List<Observable<Integer>> sourceList = new ArrayList<>(i);
            Set<Integer> expected = new HashSet<>(i);
            for (int j = 1; j <= i; j++) {
                sourceList.add(Observable.just(j).subscribeOn(Schedulers.io()));
                expected.add(j);
            }

            Observable.merge(sourceList, i).subscribe(to);

            to.awaitDone(1, TimeUnit.SECONDS);
            to.assertNoErrors();
            Set<Integer> actual = new HashSet<>(to.values());

            assertEquals(expected, actual);
        }
    }",loop_control
j,"{
        for (int i = 1; i < 50; i++) {
            TestObserver<Integer> to = new TestObserver<>();
            List<Observable<Integer>> sourceList = new ArrayList<>(i);
            Set<Integer> expected = new HashSet<>(i);
            for (int j = 1; j <= i; j++) {
                sourceList.add(Observable.just(j).subscribeOn(Schedulers.io()));
                expected.add(j);
            }

            Observable.merge(sourceList, i).subscribe(to);

            to.awaitDone(1, TimeUnit.SECONDS);
            to.assertNoErrors();
            Set<Integer> actual = new HashSet<>(to.values());

            assertEquals(expected, actual);
        }
    }",loop_control
i,"{
        for (int i = 0; i < 200; i++) {
            simpleOneLessAsync();
        }
    }",loop_control
i,"{
        long t = System.currentTimeMillis();
        for (int i = 2; i < 50; i++) {
            if (System.currentTimeMillis() - t > TimeUnit.SECONDS.toMillis(9)) {
                break;
            }
            TestObserver<Integer> to = new TestObserver<>();
            List<Observable<Integer>> sourceList = new ArrayList<>(i);
            Set<Integer> expected = new HashSet<>(i);
            for (int j = 1; j <= i; j++) {
                sourceList.add(Observable.just(j).subscribeOn(Schedulers.io()));
                expected.add(j);
            }

            Observable.merge(sourceList, i - 1).subscribe(to);

            to.awaitDone(1, TimeUnit.SECONDS);
            to.assertNoErrors();
            Set<Integer> actual = new HashSet<>(to.values());

            assertEquals(expected, actual);
        }
    }",loop_control
j,"{
        long t = System.currentTimeMillis();
        for (int i = 2; i < 50; i++) {
            if (System.currentTimeMillis() - t > TimeUnit.SECONDS.toMillis(9)) {
                break;
            }
            TestObserver<Integer> to = new TestObserver<>();
            List<Observable<Integer>> sourceList = new ArrayList<>(i);
            Set<Integer> expected = new HashSet<>(i);
            for (int j = 1; j <= i; j++) {
                sourceList.add(Observable.just(j).subscribeOn(Schedulers.io()));
                expected.add(j);
            }

            Observable.merge(sourceList, i - 1).subscribe(to);

            to.awaitDone(1, TimeUnit.SECONDS);
            to.assertNoErrors();
            Set<Integer> actual = new HashSet<>(to.values());

            assertEquals(expected, actual);
        }
    }",loop_control
t,"{
//        Observable<String> obs = Observable.just(""one"", null, ""two"", ""three"", ""four"");
        // FIXME null values not allowed
        Observable<String> obs = Observable.just(""one"", ""null"", ""two"", ""three"", ""four"");

        Observer<String> observer = TestHelper.mockObserver();

        InOrder inOrder = inOrder(observer);
        TestObserverEx<String> to = new TestObserverEx<>(observer);

        obs.observeOn(Schedulers.computation()).subscribe(to);

        to.awaitDone(1000, TimeUnit.MILLISECONDS);
        if (to.errors().size() > 0) {
            for (Throwable t : to.errors()) {
                t.printStackTrace();
            }
            fail(""failed with exception"");
        }

        inOrder.verify(observer, times(1)).onNext(""one"");
        inOrder.verify(observer, times(1)).onNext(""null"");
        inOrder.verify(observer, times(1)).onNext(""two"");
        inOrder.verify(observer, times(1)).onNext(""three"");
        inOrder.verify(observer, times(1)).onNext(""four"");
        inOrder.verify(observer, times(1)).onComplete();
        inOrder.verifyNoMoreInteractions();
    }",iterator
j,"{
        for (int j = 0; j < TestHelper.RACE_LONG_LOOPS; j++) {
            List<Throwable> errors = TestHelper.trackPluginErrors();
            try {
                final UnicastSubject<Integer> us = UnicastSubject.create();

                TestObserver<Integer> to = us.hide()
                .observeOn(Schedulers.io())
                .observeOn(Schedulers.single())
                .unsubscribeOn(Schedulers.computation())
                .firstOrError()
                .test();

                for (int i = 0; us.hasObservers() && i < 10000; i++) {
                    us.onNext(i);
                }

                to
                .awaitDone(5, TimeUnit.SECONDS)
                ;

                if (!errors.isEmpty()) {
                    throw new CompositeException(errors);
                }

                to.assertResult(0);
            } finally {
                RxJavaPlugins.reset();
            }
        }
    }",loop_control
i,"{
        for (int j = 0; j < TestHelper.RACE_LONG_LOOPS; j++) {
            List<Throwable> errors = TestHelper.trackPluginErrors();
            try {
                final UnicastSubject<Integer> us = UnicastSubject.create();

                TestObserver<Integer> to = us.hide()
                .observeOn(Schedulers.io())
                .observeOn(Schedulers.single())
                .unsubscribeOn(Schedulers.computation())
                .firstOrError()
                .test();

                for (int i = 0; us.hasObservers() && i < 10000; i++) {
                    us.onNext(i);
                }

                to
                .awaitDone(5, TimeUnit.SECONDS)
                ;

                if (!errors.isEmpty()) {
                    throw new CompositeException(errors);
                }

                to.assertResult(0);
            } finally {
                RxJavaPlugins.reset();
            }
        }
    }",loop_control
arg,"{
        List<String> list = new ArrayList<>();
        for (String arg : args) {
            list.add(arg);
        }
        return list;
    }",iterator
i,"{
        TestHelper.withErrorTracking(errors -> {
            TestException ex1 = new TestException();
            TestException ex2 = new TestException();
            for (int i = 0; i < TestHelper.RACE_DEFAULT_LOOPS; i++) {
                AtomicReference<Observer<? super Integer>> ref1 = new AtomicReference<>();
                AtomicReference<Observer<? super Integer>> ref2 = new AtomicReference<>();

                Observable<Integer> o1 = Observable.<Integer>unsafeCreate(ref1::set);
                Observable<Integer> o2 = Observable.<Integer>unsafeCreate(ref2::set);

                TestObserver<Observable<Integer>> to = BehaviorSubject.createDefault(1)
                .window(o1, v -> o2)
                .doOnNext(w -> w.test())
                .test();

                ref1.get().onSubscribe(Disposable.empty());
                ref1.get().onNext(1);
                ref2.get().onSubscribe(Disposable.empty());

                TestHelper.race(
                        () -> ref1.get().onError(ex1),
                        () -> ref2.get().onError(ex2)
                );

                to.assertError(RuntimeException.class);

                if (!errors.isEmpty()) {
                    TestHelper.assertUndeliverable(errors, 0, TestException.class);
                }

                errors.clear();
            }
        });
    }",loop_control
i,"{
        ObservableCache<Integer> source = new ObservableCache<>(Observable.range(0, 1000), 16);

        assertFalse(""Source is connected!"", source.isConnected());

        TestObserverEx<Integer> to = new TestObserverEx<>();

        source.subscribe(to);

        assertTrue(""Source is not connected!"", source.isConnected());
        assertFalse(""Subscribers retained!"", source.hasObservers());

        to.assertNoErrors();
        to.assertTerminated();
        List<Integer> onNextEvents = to.values();
        assertEquals(1000, onNextEvents.size());

        for (int i = 0; i < 1000; i++) {
            assertEquals((Integer)i, onNextEvents.get(i));
        }
    }",loop_control
i,"{
        Observable<Integer> source = Observable.range(1, 10000);
        for (int i = 0; i < 100; i++) {
            TestObserver<Integer> to1 = new TestObserver<>();

            ObservableCache<Integer> cached = new ObservableCache<>(source, 16);

            cached.observeOn(Schedulers.computation()).subscribe(to1);

            to1.awaitDone(2, TimeUnit.SECONDS);
            to1.assertNoErrors();
            to1.assertComplete();
            assertEquals(10000, to1.values().size());

            TestObserver<Integer> to2 = new TestObserver<>();
            cached.observeOn(Schedulers.computation()).subscribe(to2);

            to2.awaitDone(2, TimeUnit.SECONDS);
            to2.assertNoErrors();
            to2.assertComplete();
            assertEquals(10000, to2.values().size());
        }
    }",loop_control
i,"{
        Observable<Long> source = Observable.interval(1, 1, TimeUnit.MILLISECONDS)
                .take(1000)
                .subscribeOn(Schedulers.io());
        ObservableCache<Long> cached = new ObservableCache<>(source, 16);

        Observable<Long> output = cached.observeOn(Schedulers.computation());

        List<TestObserver<Long>> list = new ArrayList<>(100);
        for (int i = 0; i < 100; i++) {
            TestObserver<Long> to = new TestObserver<>();
            list.add(to);
            output.skip(i * 10).take(10).subscribe(to);
        }

        List<Long> expected = new ArrayList<>();
        for (int i = 0; i < 10; i++) {
            expected.add((long)(i - 10));
        }
        int j = 0;
        for (TestObserver<Long> to : list) {
            to.awaitDone(3, TimeUnit.SECONDS);
            to.assertNoErrors();
            to.assertComplete();

            for (int i = j * 10; i < j * 10 + 10; i++) {
                expected.set(i - j * 10, (long)i);
            }

            to.assertValueSequence(expected);

            j++;
        }
    }",loop_control
to,"{
        Observable<Long> source = Observable.interval(1, 1, TimeUnit.MILLISECONDS)
                .take(1000)
                .subscribeOn(Schedulers.io());
        ObservableCache<Long> cached = new ObservableCache<>(source, 16);

        Observable<Long> output = cached.observeOn(Schedulers.computation());

        List<TestObserver<Long>> list = new ArrayList<>(100);
        for (int i = 0; i < 100; i++) {
            TestObserver<Long> to = new TestObserver<>();
            list.add(to);
            output.skip(i * 10).take(10).subscribe(to);
        }

        List<Long> expected = new ArrayList<>();
        for (int i = 0; i < 10; i++) {
            expected.add((long)(i - 10));
        }
        int j = 0;
        for (TestObserver<Long> to : list) {
            to.awaitDone(3, TimeUnit.SECONDS);
            to.assertNoErrors();
            to.assertComplete();

            for (int i = j * 10; i < j * 10 + 10; i++) {
                expected.set(i - j * 10, (long)i);
            }

            to.assertValueSequence(expected);

            j++;
        }
    }",iterator
j,"{
        Observable<Long> source = Observable.interval(1, 1, TimeUnit.MILLISECONDS)
                .take(1000)
                .subscribeOn(Schedulers.io());
        ObservableCache<Long> cached = new ObservableCache<>(source, 16);

        Observable<Long> output = cached.observeOn(Schedulers.computation());

        List<TestObserver<Long>> list = new ArrayList<>(100);
        for (int i = 0; i < 100; i++) {
            TestObserver<Long> to = new TestObserver<>();
            list.add(to);
            output.skip(i * 10).take(10).subscribe(to);
        }

        List<Long> expected = new ArrayList<>();
        for (int i = 0; i < 10; i++) {
            expected.add((long)(i - 10));
        }
        int j = 0;
        for (TestObserver<Long> to : list) {
            to.awaitDone(3, TimeUnit.SECONDS);
            to.assertNoErrors();
            to.assertComplete();

            for (int i = j * 10; i < j * 10 + 10; i++) {
                expected.set(i - j * 10, (long)i);
            }

            to.assertValueSequence(expected);

            j++;
        }
    }",loop_control
i,"{
        final int m = 4 * 1000 * 1000;
        Observable<Integer> firehose = Observable.unsafeCreate(new ObservableSource<Integer>() {
            @Override
            public void subscribe(Observer<? super Integer> t) {
                t.onSubscribe(Disposable.empty());
                for (int i = 0; i < m; i++) {
                    t.onNext(i);
                }
                t.onComplete();
            }
        });

        TestObserver<Integer> to = new TestObserver<>();
        firehose.cache().observeOn(Schedulers.computation()).takeLast(100).subscribe(to);

        to.awaitDone(3, TimeUnit.SECONDS);
        to.assertNoErrors();
        to.assertComplete();

        assertEquals(100, to.values().size());
    }",loop_control
i,"{
        for (int i = 0; i < TestHelper.RACE_DEFAULT_LOOPS; i++) {
            final PublishSubject<Integer> ps = PublishSubject.<Integer>create();

            final Observable<Integer> cache = ps.cache();

            cache.test();

            final TestObserverEx<Integer> to = new TestObserverEx<>();

            Runnable r1 = new Runnable() {
                @Override
                public void run() {
                    cache.subscribe(to);
                }
            };

            Runnable r2 = new Runnable() {
                @Override
                public void run() {
                    for (int j = 0; j < 500; j++) {
                        ps.onNext(j);
                    }
                    ps.onComplete();
                }
            };

            TestHelper.race(r1, r2);

            to
            .awaitDone(5, TimeUnit.SECONDS)
            .assertSubscribed().assertValueCount(500).assertComplete().assertNoErrors();
        }
    }",loop_control
j,"{
        for (int i = 0; i < TestHelper.RACE_DEFAULT_LOOPS; i++) {
            final PublishSubject<Integer> ps = PublishSubject.<Integer>create();

            final Observable<Integer> cache = ps.cache();

            cache.test();

            final TestObserverEx<Integer> to = new TestObserverEx<>();

            Runnable r1 = new Runnable() {
                @Override
                public void run() {
                    cache.subscribe(to);
                }
            };

            Runnable r2 = new Runnable() {
                @Override
                public void run() {
                    for (int j = 0; j < 500; j++) {
                        ps.onNext(j);
                    }
                    ps.onComplete();
                }
            };

            TestHelper.race(r1, r2);

            to
            .awaitDone(5, TimeUnit.SECONDS)
            .assertSubscribed().assertValueCount(500).assertComplete().assertNoErrors();
        }
    }",loop_control
i,"{
        for (int i = 0; i < TestHelper.RACE_DEFAULT_LOOPS; i++) {
            Observable<Object> o = Observable.never().cache();

            TestObserver<Object> to = o.test();

            TestHelper.race(
                    () -> to.dispose(),
                    () -> o.test()
            );
        }
    }",loop_control
i,"{
        final AtomicInteger effectCounter = new AtomicInteger();
        Observable<Integer> source = Observable.just(1, 2, 3, 4)
        .doOnNext(new Consumer<Integer>() {
            @Override
            public void accept(Integer v) {
                effectCounter.incrementAndGet();
                System.out.println(""Sideeffect #"" + v);
            }
        });

        Observable<Integer> result = source.replay(
        new Function<Observable<Integer>, Observable<Integer>>() {
            @Override
            public Observable<Integer> apply(Observable<Integer> o) {
                return o.take(2);
            }
        });

        for (int i = 1; i < 3; i++) {
            effectCounter.set(0);
            System.out.printf(""- %d -%n"", i);
            result.subscribe(new Consumer<Integer>() {

                @Override
                public void accept(Integer t1) {
                    System.out.println(t1);
                }

            }, new Consumer<Throwable>() {

                @Override
                public void accept(Throwable t1) {
                    t1.printStackTrace();
                }
            },
            new Action() {
                @Override
                public void run() {
                    System.out.println(""Done"");
                }
            });
            assertEquals(2, effectCounter.get());
        }
    }",loop_control
i,"{
        Observable<Integer> source = Observable.range(0, 1000).replay().autoConnect();

        TestObserverEx<Integer> to = new TestObserverEx<>();

        source.subscribe(to);

        to.assertNoErrors();
        to.assertTerminated();
        List<Integer> onNextEvents = to.values();
        assertEquals(1000, onNextEvents.size());

        for (int i = 0; i < 1000; i++) {
            assertEquals((Integer)i, onNextEvents.get(i));
        }
    }",loop_control
i,"{
        Observable<Integer> source = Observable.range(1, 10000);
        for (int i = 0; i < 100; i++) {
            TestObserverEx<Integer> to1 = new TestObserverEx<>();

            Observable<Integer> cached = source.replay().autoConnect();

            cached.observeOn(Schedulers.computation()).subscribe(to1);

            to1.awaitDone(2, TimeUnit.SECONDS);
            to1.assertNoErrors();
            to1.assertTerminated();
            assertEquals(10000, to1.values().size());

            TestObserverEx<Integer> to2 = new TestObserverEx<>();
            cached.observeOn(Schedulers.computation()).subscribe(to2);

            to2.awaitDone(2, TimeUnit.SECONDS);
            to2.assertNoErrors();
            to2.assertTerminated();
            assertEquals(10000, to2.values().size());
        }
    }",loop_control
i,"{
        Observable<Long> source = Observable.interval(1, 1, TimeUnit.MILLISECONDS)
                .take(1000)
                .subscribeOn(Schedulers.io());
        Observable<Long> cached = source.replay().autoConnect();

        Observable<Long> output = cached.observeOn(Schedulers.computation());

        List<TestObserverEx<Long>> list = new ArrayList<>(100);
        for (int i = 0; i < 100; i++) {
            TestObserverEx<Long> to = new TestObserverEx<>();
            list.add(to);
            output.skip(i * 10).take(10).subscribe(to);
        }

        List<Long> expected = new ArrayList<>();
        for (int i = 0; i < 10; i++) {
            expected.add((long)(i - 10));
        }
        int j = 0;
        for (TestObserverEx<Long> to : list) {
            to.awaitDone(3, TimeUnit.SECONDS);
            to.assertNoErrors();
            to.assertTerminated();

            for (int i = j * 10; i < j * 10 + 10; i++) {
                expected.set(i - j * 10, (long)i);
            }

            to.assertValueSequence(expected);

            j++;
        }
    }",loop_control
to,"{
        Observable<Long> source = Observable.interval(1, 1, TimeUnit.MILLISECONDS)
                .take(1000)
                .subscribeOn(Schedulers.io());
        Observable<Long> cached = source.replay().autoConnect();

        Observable<Long> output = cached.observeOn(Schedulers.computation());

        List<TestObserverEx<Long>> list = new ArrayList<>(100);
        for (int i = 0; i < 100; i++) {
            TestObserverEx<Long> to = new TestObserverEx<>();
            list.add(to);
            output.skip(i * 10).take(10).subscribe(to);
        }

        List<Long> expected = new ArrayList<>();
        for (int i = 0; i < 10; i++) {
            expected.add((long)(i - 10));
        }
        int j = 0;
        for (TestObserverEx<Long> to : list) {
            to.awaitDone(3, TimeUnit.SECONDS);
            to.assertNoErrors();
            to.assertTerminated();

            for (int i = j * 10; i < j * 10 + 10; i++) {
                expected.set(i - j * 10, (long)i);
            }

            to.assertValueSequence(expected);

            j++;
        }
    }",iterator
j,"{
        Observable<Long> source = Observable.interval(1, 1, TimeUnit.MILLISECONDS)
                .take(1000)
                .subscribeOn(Schedulers.io());
        Observable<Long> cached = source.replay().autoConnect();

        Observable<Long> output = cached.observeOn(Schedulers.computation());

        List<TestObserverEx<Long>> list = new ArrayList<>(100);
        for (int i = 0; i < 100; i++) {
            TestObserverEx<Long> to = new TestObserverEx<>();
            list.add(to);
            output.skip(i * 10).take(10).subscribe(to);
        }

        List<Long> expected = new ArrayList<>();
        for (int i = 0; i < 10; i++) {
            expected.add((long)(i - 10));
        }
        int j = 0;
        for (TestObserverEx<Long> to : list) {
            to.awaitDone(3, TimeUnit.SECONDS);
            to.assertNoErrors();
            to.assertTerminated();

            for (int i = j * 10; i < j * 10 + 10; i++) {
                expected.set(i - j * 10, (long)i);
            }

            to.assertValueSequence(expected);

            j++;
        }
    }",loop_control
i,"{
        final int m = 4 * 1000 * 1000;
        Observable<Integer> firehose = Observable.unsafeCreate(new ObservableSource<Integer>() {
            @Override
            public void subscribe(Observer<? super Integer> t) {
                t.onSubscribe(Disposable.empty());
                for (int i = 0; i < m; i++) {
                    t.onNext(i);
                }
                t.onComplete();
            }
        });

        TestObserverEx<Integer> to = new TestObserverEx<>();
        firehose.replay().autoConnect().observeOn(Schedulers.computation()).takeLast(100).subscribe(to);

        to.awaitDone(3, TimeUnit.SECONDS);
        to.assertNoErrors();
        to.assertTerminated();

        assertEquals(100, to.values().size());
    }",loop_control
i,"{
        for (int i = 0; i < TestHelper.RACE_DEFAULT_LOOPS; i++) {
            final ConnectableObservable<Integer> co = Observable.range(1, 3).replay();

            Runnable r = new Runnable() {
                @Override
                public void run() {
                    co.connect();
                }
            };

            TestHelper.race(r, r);
        }
    }",loop_control
i,"{
        for (int i = 0; i < TestHelper.RACE_DEFAULT_LOOPS; i++) {
            final ConnectableObservable<Integer> co = Observable.range(1, 3).replay();

            final TestObserver<Integer> to1 = new TestObserver<>();
            final TestObserver<Integer> to2 = new TestObserver<>();

            Runnable r1 = new Runnable() {
                @Override
                public void run() {
                    co.subscribe(to1);
                }
            };

            Runnable r2 = new Runnable() {
                @Override
                public void run() {
                    co.subscribe(to2);
                }
            };

            TestHelper.race(r1, r2);
        }
    }",loop_control
i,"{
        for (int i = 0; i < TestHelper.RACE_DEFAULT_LOOPS; i++) {
            final ConnectableObservable<Integer> co = Observable.range(1, 3).replay();

            final TestObserver<Integer> to1 = new TestObserver<>();
            final TestObserver<Integer> to2 = new TestObserver<>();

            co.subscribe(to1);

            Runnable r1 = new Runnable() {
                @Override
                public void run() {
                    to1.dispose();
                }
            };

            Runnable r2 = new Runnable() {
                @Override
                public void run() {
                    co.subscribe(to2);
                }
            };

            TestHelper.race(r1, r2);
        }
    }",loop_control
i,"{
        for (int i = 0; i < TestHelper.RACE_DEFAULT_LOOPS; i++) {
            final PublishSubject<Integer> ps = PublishSubject.create();

            final ConnectableObservable<Integer> co = ps.replay();

            final TestObserver<Integer> to1 = new TestObserver<>();

            Runnable r1 = new Runnable() {
                @Override
                public void run() {
                    co.subscribe(to1);
                }
            };

            Runnable r2 = new Runnable() {
                @Override
                public void run() {
                    for (int j = 0; j < 1000; j++) {
                        ps.onNext(j);
                    }
                }
            };

            TestHelper.race(r1, r2);
        }
    }",loop_control
j,"{
        for (int i = 0; i < TestHelper.RACE_DEFAULT_LOOPS; i++) {
            final PublishSubject<Integer> ps = PublishSubject.create();

            final ConnectableObservable<Integer> co = ps.replay();

            final TestObserver<Integer> to1 = new TestObserver<>();

            Runnable r1 = new Runnable() {
                @Override
                public void run() {
                    co.subscribe(to1);
                }
            };

            Runnable r2 = new Runnable() {
                @Override
                public void run() {
                    for (int j = 0; j < 1000; j++) {
                        ps.onNext(j);
                    }
                }
            };

            TestHelper.race(r1, r2);
        }
    }",loop_control
i,"{
        for (int i = 0; i < TestHelper.RACE_DEFAULT_LOOPS; i++) {
            final PublishSubject<Integer> ps = PublishSubject.create();

            final ConnectableObservable<Integer> co = ps.replay();

            final TestObserver<Integer> to1 = new TestObserver<>();

            co.subscribe(to1);

            Runnable r1 = new Runnable() {
                @Override
                public void run() {
                    to1.dispose();
                }
            };

            Runnable r2 = new Runnable() {
                @Override
                public void run() {
                    for (int j = 0; j < 1000; j++) {
                        ps.onNext(j);
                    }
                }
            };

            TestHelper.race(r1, r2);
        }
    }",loop_control
j,"{
        for (int i = 0; i < TestHelper.RACE_DEFAULT_LOOPS; i++) {
            final PublishSubject<Integer> ps = PublishSubject.create();

            final ConnectableObservable<Integer> co = ps.replay();

            final TestObserver<Integer> to1 = new TestObserver<>();

            co.subscribe(to1);

            Runnable r1 = new Runnable() {
                @Override
                public void run() {
                    to1.dispose();
                }
            };

            Runnable r2 = new Runnable() {
                @Override
                public void run() {
                    for (int j = 0; j < 1000; j++) {
                        ps.onNext(j);
                    }
                }
            };

            TestHelper.race(r1, r2);
        }
    }",loop_control
i,"{
        for (int i = 0; i < TestHelper.RACE_DEFAULT_LOOPS; i++) {
            final ConnectableObservable<Integer> co = Observable.range(1, 1000).replay();

            final TestObserver<Integer> to1 = new TestObserver<>();

            co.connect();

            Runnable r1 = new Runnable() {
                @Override
                public void run() {
                    co.subscribe(to1);
                }
            };

            Runnable r2 = new Runnable() {
                @Override
                public void run() {
                    to1.dispose();
                }
            };

            TestHelper.race(r1, r2);
        }
    }",loop_control
i,"{
        ArrayList<Long> list = new ArrayList<>(Flowable.bufferSize() * 2);
        for (long i = 1; i <= Flowable.bufferSize() * 2 + 1; i++) {
            list.add(i);
        }

        Observable<Long> o = Observable.rangeLong(1, list.size());

        TestObserverEx<Long> to = new TestObserverEx<>();

        o.subscribe(to);

        to.assertValueSequence(list);
        to.assertTerminated();
    }",loop_control
i,"{
        for (int i = 0; i < TestHelper.RACE_DEFAULT_LOOPS; i++) {
            List<Throwable> errors = TestHelper.trackPluginErrors();
            try {
                final PublishSubject<Integer> ps = PublishSubject.create();

                final Observer<?>[] sub = { null, null };

                final Observable<Integer> pp2 = new Observable<Integer>() {

                    int count;

                    @Override
                    protected void subscribeActual(
                            Observer<? super Integer> observer) {
                        observer.onSubscribe(Disposable.empty());
                        sub[count++] = observer;
                    }
                };

                TestObserver<Integer> to = ps.timeout(Functions.justFunction(pp2)).test();

                ps.onNext(0);

                Runnable r1 = new Runnable() {
                    @Override
                    public void run() {
                        ps.onNext(1);
                    }
                };

                final Throwable ex = new TestException();

                Runnable r2 = new Runnable() {
                    @Override
                    public void run() {
                        sub[0].onError(ex);
                    }
                };

                TestHelper.race(r1, r2);

                to.assertValueAt(0, 0);

                if (!errors.isEmpty()) {
                    TestHelper.assertUndeliverable(errors, 0, TestException.class);
                }
            } finally {
                RxJavaPlugins.reset();
            }
        }
    }",loop_control
i,"{
        for (int i = 0; i < TestHelper.RACE_DEFAULT_LOOPS; i++) {
            List<Throwable> errors = TestHelper.trackPluginErrors();
            try {
                final PublishSubject<Integer> ps = PublishSubject.create();

                final Observer<?>[] sub = { null, null };

                final Observable<Integer> pp2 = new Observable<Integer>() {

                    int count;

                    @Override
                    protected void subscribeActual(
                            Observer<? super Integer> observer) {
                        assertFalse(((Disposable)observer).isDisposed());
                        observer.onSubscribe(Disposable.empty());
                        sub[count++] = observer;
                    }
                };

                TestObserver<Integer> to = ps.timeout(Functions.justFunction(pp2), Observable.<Integer>never()).test();

                ps.onNext(0);

                Runnable r1 = new Runnable() {
                    @Override
                    public void run() {
                        ps.onNext(1);
                    }
                };

                final Throwable ex = new TestException();

                Runnable r2 = new Runnable() {
                    @Override
                    public void run() {
                        sub[0].onError(ex);
                    }
                };

                TestHelper.race(r1, r2);

                to.assertValueAt(0, 0);

                if (!errors.isEmpty()) {
                    TestHelper.assertUndeliverable(errors, 0, TestException.class);
                }
            } finally {
                RxJavaPlugins.reset();
            }
        }
    }",loop_control
i,"{
        for (int i = 0; i < TestHelper.RACE_DEFAULT_LOOPS; i++) {
            List<Throwable> errors = TestHelper.trackPluginErrors();
            try {
                final PublishSubject<Integer> ps = PublishSubject.create();

                final Observer<?>[] sub = { null, null };

                final Observable<Integer> pp2 = new Observable<Integer>() {

                    int count;

                    @Override
                    protected void subscribeActual(
                            Observer<? super Integer> observer) {
                        assertFalse(((Disposable)observer).isDisposed());
                        observer.onSubscribe(Disposable.empty());
                        sub[count++] = observer;
                    }
                };

                TestObserver<Integer> to = ps.timeout(Functions.justFunction(pp2)).test();

                ps.onNext(0);

                final Throwable ex = new TestException();

                Runnable r1 = new Runnable() {
                    @Override
                    public void run() {
                        ps.onError(ex);
                    }
                };

                Runnable r2 = new Runnable() {
                    @Override
                    public void run() {
                        sub[0].onComplete();
                    }
                };

                TestHelper.race(r1, r2);

                to.assertValueAt(0, 0);

                if (!errors.isEmpty()) {
                    TestHelper.assertUndeliverable(errors, 0, TestException.class);
                }
            } finally {
                RxJavaPlugins.reset();
            }
        }
    }",loop_control
i,"{
        for (int i = 0; i < TestHelper.RACE_DEFAULT_LOOPS; i++) {
            List<Throwable> errors = TestHelper.trackPluginErrors();
            try {
                final PublishSubject<Integer> ps = PublishSubject.create();

                final Observer<?>[] sub = { null, null };

                final Observable<Integer> pp2 = new Observable<Integer>() {

                    int count;

                    @Override
                    protected void subscribeActual(
                            Observer<? super Integer> observer) {
                        assertFalse(((Disposable)observer).isDisposed());
                        observer.onSubscribe(Disposable.empty());
                        sub[count++] = observer;
                    }
                };

                TestObserver<Integer> to = ps.timeout(Functions.justFunction(pp2)).test();

                ps.onNext(0);

                Runnable r1 = new Runnable() {
                    @Override
                    public void run() {
                        ps.onComplete();
                    }
                };

                Runnable r2 = new Runnable() {
                    @Override
                    public void run() {
                        sub[0].onComplete();
                    }
                };

                TestHelper.race(r1, r2);

                to.assertValueAt(0, 0);

                if (!errors.isEmpty()) {
                    TestHelper.assertUndeliverable(errors, 0, TestException.class);
                }
            } finally {
                RxJavaPlugins.reset();
            }
        }
    }",loop_control
i,"{
        for (int i = 0; i < TestHelper.RACE_DEFAULT_LOOPS; i++) {
            List<Throwable> errors = TestHelper.trackPluginErrors();
            try {
                final PublishSubject<Integer> ps = PublishSubject.create();

                final Observer<?>[] sub = { null, null };

                final Observable<Integer> pp2 = new Observable<Integer>() {

                    int count;

                    @Override
                    protected void subscribeActual(
                            Observer<? super Integer> observer) {
                        assertFalse(((Disposable)observer).isDisposed());
                        observer.onSubscribe(Disposable.empty());
                        sub[count++] = observer;
                    }
                };

                TestObserver<Integer> to = ps.timeout(Functions.justFunction(pp2), Observable.<Integer>never()).test();

                ps.onNext(0);

                Runnable r1 = new Runnable() {
                    @Override
                    public void run() {
                        ps.onComplete();
                    }
                };

                Runnable r2 = new Runnable() {
                    @Override
                    public void run() {
                        sub[0].onComplete();
                    }
                };

                TestHelper.race(r1, r2);

                to.assertValueAt(0, 0);

                if (!errors.isEmpty()) {
                    TestHelper.assertUndeliverable(errors, 0, TestException.class);
                }
            } finally {
                RxJavaPlugins.reset();
            }
        }
    }",loop_control
item,"{

    final List<T> items;
    final Throwable error;

    Burst(Throwable error, List<T> items) {
        this.error = error;
        this.items = items;
    }

    @Override
    protected void subscribeActual(final Observer<? super T> observer) {
        observer.onSubscribe(Disposable.empty());
        for (T item: items) {
            observer.onNext(item);
        }
        if (error != null) {
            observer.onError(error);
        } else {
            observer.onComplete();
        }
    }

    public static <T> Builder<T> item(T item) {
        return items(item);
    }

    @SafeVarargs
    public static <T> Builder<T> items(T... items) {
        return new Builder<>(Arrays.asList(items));
    }

    public static final class Builder<T> {

        private final List<T> items;
        private Throwable error;

        Builder(List<T> items) {
            this.items = items;
        }

        public Observable<T> error(Throwable e) {
            this.error = e;
            return create();
        }

        public Observable<T> create() {
            return new Burst<>(error, items);
        }

    }

}",iterator
i,"{
        for (int i = 0; i < TestHelper.RACE_DEFAULT_LOOPS; i++) {
            List<Throwable> errors = TestHelper.trackPluginErrors();
            try {

                final PublishSubject<Integer> ps1 = PublishSubject.create();
                final PublishSubject<Integer> ps2 = PublishSubject.create();

                ps1.switchMap(new Function<Integer, ObservableSource<Integer>>() {
                    @Override
                    public ObservableSource<Integer> apply(Integer v) throws Exception {
                        if (v == 1) {
                            return ps2;
                        }
                        return Observable.never();
                    }
                })
                .test();

                Runnable r1 = new Runnable() {
                    @Override
                    public void run() {
                        ps1.onNext(2);
                    }
                };

                final TestException ex = new TestException();

                Runnable r2 = new Runnable() {
                    @Override
                    public void run() {
                        ps2.onError(ex);
                    }
                };

                TestHelper.race(r1, r2);

                for (Throwable e : errors) {
                    assertTrue(e.toString(), e instanceof TestException);
                }
            } finally {
                RxJavaPlugins.reset();
            }
        }
    }",loop_control
e,"{
        for (int i = 0; i < TestHelper.RACE_DEFAULT_LOOPS; i++) {
            List<Throwable> errors = TestHelper.trackPluginErrors();
            try {

                final PublishSubject<Integer> ps1 = PublishSubject.create();
                final PublishSubject<Integer> ps2 = PublishSubject.create();

                ps1.switchMap(new Function<Integer, ObservableSource<Integer>>() {
                    @Override
                    public ObservableSource<Integer> apply(Integer v) throws Exception {
                        if (v == 1) {
                            return ps2;
                        }
                        return Observable.never();
                    }
                })
                .test();

                Runnable r1 = new Runnable() {
                    @Override
                    public void run() {
                        ps1.onNext(2);
                    }
                };

                final TestException ex = new TestException();

                Runnable r2 = new Runnable() {
                    @Override
                    public void run() {
                        ps2.onError(ex);
                    }
                };

                TestHelper.race(r1, r2);

                for (Throwable e : errors) {
                    assertTrue(e.toString(), e instanceof TestException);
                }
            } finally {
                RxJavaPlugins.reset();
            }
        }
    }",iterator
i,"{
        for (int i = 0; i < TestHelper.RACE_LONG_LOOPS; i++) {
            List<Throwable> errors = TestHelper.trackPluginErrors();
            try {

                final PublishSubject<Integer> ps1 = PublishSubject.create();
                final PublishSubject<Integer> ps2 = PublishSubject.create();

                ps1.switchMap(new Function<Integer, ObservableSource<Integer>>() {
                    @Override
                    public ObservableSource<Integer> apply(Integer v) throws Exception {
                        if (v == 1) {
                            return ps2;
                        }
                        return Observable.never();
                    }
                })
                .test();

                ps1.onNext(1);

                final TestException ex1 = new TestException();

                Runnable r1 = new Runnable() {
                    @Override
                    public void run() {
                        ps1.onError(ex1);
                    }
                };

                final TestException ex2 = new TestException();

                Runnable r2 = new Runnable() {
                    @Override
                    public void run() {
                        ps2.onError(ex2);
                    }
                };

                TestHelper.race(r1, r2);

                for (Throwable e : errors) {
                    assertTrue(e.getCause().toString(), e.getCause() instanceof TestException);
                }
            } finally {
                RxJavaPlugins.reset();
            }
        }
    }",loop_control
e,"{
        for (int i = 0; i < TestHelper.RACE_LONG_LOOPS; i++) {
            List<Throwable> errors = TestHelper.trackPluginErrors();
            try {

                final PublishSubject<Integer> ps1 = PublishSubject.create();
                final PublishSubject<Integer> ps2 = PublishSubject.create();

                ps1.switchMap(new Function<Integer, ObservableSource<Integer>>() {
                    @Override
                    public ObservableSource<Integer> apply(Integer v) throws Exception {
                        if (v == 1) {
                            return ps2;
                        }
                        return Observable.never();
                    }
                })
                .test();

                ps1.onNext(1);

                final TestException ex1 = new TestException();

                Runnable r1 = new Runnable() {
                    @Override
                    public void run() {
                        ps1.onError(ex1);
                    }
                };

                final TestException ex2 = new TestException();

                Runnable r2 = new Runnable() {
                    @Override
                    public void run() {
                        ps2.onError(ex2);
                    }
                };

                TestHelper.race(r1, r2);

                for (Throwable e : errors) {
                    assertTrue(e.getCause().toString(), e.getCause() instanceof TestException);
                }
            } finally {
                RxJavaPlugins.reset();
            }
        }
    }",iterator
i,"{
        for (int i = 0; i < TestHelper.RACE_DEFAULT_LOOPS; i++) {
            final PublishSubject<Integer> ps1 = PublishSubject.create();

            final TestObserver<Integer> to = ps1.switchMap(new Function<Integer, ObservableSource<Integer>>() {
                @Override
                public ObservableSource<Integer> apply(Integer v) throws Exception {
                    return Observable.never();
                }
            })
            .test();

            Runnable r1 = new Runnable() {
                @Override
                public void run() {
                    ps1.onNext(2);
                }
            };

            Runnable r2 = new Runnable() {
                @Override
                public void run() {
                    to.dispose();
                }
            };

            TestHelper.race(r1, r2);
        }
    }",loop_control
i,"{
        for (int i = 0; i < TestHelper.RACE_LONG_LOOPS; i++) {
            List<Throwable> errors = TestHelper.trackPluginErrors();
            try {

                final AtomicReference<Observer<? super Integer>> obs1 = new AtomicReference<>();
                final Observable<Integer> ps1 = new Observable<Integer>() {
                    @Override
                    protected void subscribeActual(
                            Observer<? super Integer> observer) {
                        obs1.set(observer);
                    }
                };
                final AtomicReference<Observer<? super Integer>> obs2 = new AtomicReference<>();
                final Observable<Integer> ps2 = new Observable<Integer>() {
                    @Override
                    protected void subscribeActual(
                            Observer<? super Integer> observer) {
                        obs2.set(observer);
                    }
                };

                ps1.switchMap(new Function<Integer, ObservableSource<Integer>>() {
                    @Override
                    public ObservableSource<Integer> apply(Integer v) throws Exception {
                        if (v == 1) {
                            return ps2;
                        }
                        return Observable.never();
                    }
                })
                .test();

                obs1.get().onSubscribe(Disposable.empty());
                obs1.get().onNext(1);

                obs2.get().onSubscribe(Disposable.empty());

                final TestException ex1 = new TestException();

                Runnable r1 = new Runnable() {
                    @Override
                    public void run() {
                        obs1.get().onError(ex1);
                    }
                };

                final TestException ex2 = new TestException();

                Runnable r2 = new Runnable() {
                    @Override
                    public void run() {
                        obs2.get().onError(ex2);
                    }
                };

                TestHelper.race(r1, r2);

                for (Throwable e : errors) {
                    assertTrue(e.toString(), e.getCause() instanceof TestException);
                }
            } finally {
                RxJavaPlugins.reset();
            }
        }
    }",loop_control
e,"{
        for (int i = 0; i < TestHelper.RACE_LONG_LOOPS; i++) {
            List<Throwable> errors = TestHelper.trackPluginErrors();
            try {

                final AtomicReference<Observer<? super Integer>> obs1 = new AtomicReference<>();
                final Observable<Integer> ps1 = new Observable<Integer>() {
                    @Override
                    protected void subscribeActual(
                            Observer<? super Integer> observer) {
                        obs1.set(observer);
                    }
                };
                final AtomicReference<Observer<? super Integer>> obs2 = new AtomicReference<>();
                final Observable<Integer> ps2 = new Observable<Integer>() {
                    @Override
                    protected void subscribeActual(
                            Observer<? super Integer> observer) {
                        obs2.set(observer);
                    }
                };

                ps1.switchMap(new Function<Integer, ObservableSource<Integer>>() {
                    @Override
                    public ObservableSource<Integer> apply(Integer v) throws Exception {
                        if (v == 1) {
                            return ps2;
                        }
                        return Observable.never();
                    }
                })
                .test();

                obs1.get().onSubscribe(Disposable.empty());
                obs1.get().onNext(1);

                obs2.get().onSubscribe(Disposable.empty());

                final TestException ex1 = new TestException();

                Runnable r1 = new Runnable() {
                    @Override
                    public void run() {
                        obs1.get().onError(ex1);
                    }
                };

                final TestException ex2 = new TestException();

                Runnable r2 = new Runnable() {
                    @Override
                    public void run() {
                        obs2.get().onError(ex2);
                    }
                };

                TestHelper.race(r1, r2);

                for (Throwable e : errors) {
                    assertTrue(e.toString(), e.getCause() instanceof TestException);
                }
            } finally {
                RxJavaPlugins.reset();
            }
        }
    }",iterator
o,"{
        String thread = Thread.currentThread().getName();

        TestObserver<Object> to = Observable.range(1, 10000)
        .switchMap(new Function<Integer, ObservableSource<? extends Object>>() {
            @Override
            public ObservableSource<? extends Object> apply(Integer v)
                    throws Exception {
                return Observable.just(2).hide()
                .observeOn(Schedulers.single())
                .map(new Function<Integer, Object>() {
                    @Override
                    public Object apply(Integer w) throws Exception {
                        return Thread.currentThread().getName();
                    }
                });
            }
        })
        .test()
        .awaitDone(5, TimeUnit.SECONDS)
        .assertNoErrors()
        .assertComplete();

        for (Object o : to.values()) {
            assertNotEquals(thread, o);
        }
    }",iterator
i,"{
        for (int i = 0; i < TestHelper.RACE_LONG_LOOPS; i++) {
            AtomicReference<Observer<? super Integer>> ref = new AtomicReference<>();
            Observable<Integer> o = new Observable<Integer>() {
                @Override
                protected void subscribeActual(@NonNull Observer<? super @NonNull Integer> observer) {
                    ref.set(observer);
                }
            };

            TestObserver<Object> to = o.switchMap(v -> Observable.never())
            .test();

            ref.get().onSubscribe(Disposable.empty());

            TestHelper.race(
                    () -> ref.get().onComplete(),
                    () -> to.dispose()
            );
        }
    }",loop_control
i,"{
        TestException ex = new TestException();

        for (int i = 0; i < TestHelper.RACE_LONG_LOOPS; i++) {
            AtomicReference<Observer<? super Integer>> ref1 = new AtomicReference<>();
            Observable<Integer> o1 = new Observable<Integer>() {
                @Override
                protected void subscribeActual(@NonNull Observer<? super @NonNull Integer> observer) {
                    ref1.set(observer);
                }
            };
            AtomicReference<Observer<? super Integer>> ref2 = new AtomicReference<>();
            Observable<Integer> o2 = new Observable<Integer>() {
                @Override
                protected void subscribeActual(@NonNull Observer<? super @NonNull Integer> observer) {
                    ref2.set(observer);
                }
            };

            o1.switchMap(v -> o2)
            .test();

            ref1.get().onSubscribe(Disposable.empty());
            ref1.get().onNext(1);
            ref2.get().onSubscribe(Disposable.empty());

            TestHelper.race(
                    () -> ref1.get().onComplete(),
                    () -> ref2.get().onError(ex)
            );
        }
    }",loop_control
i,"{
        AtomicInteger outer = new AtomicInteger();
        AtomicInteger inner = new AtomicInteger();

        int n = 10_000;
        for (int i = 0; i < n; i++) {
            Observable.<Integer>create(it -> {
                it.onNext(0);
            })
            .switchMap(v -> createObservable(inner))
            .observeOn(Schedulers.computation())
            .doFinally(() -> {
                outer.incrementAndGet();
            })
            .take(1)
            .blockingSubscribe(v -> { }, Throwable::printStackTrace);
        }

        Thread.sleep(100);
        assertEquals(inner.get(), outer.get());
        assertEquals(n, inner.get());
    }",loop_control
i,"{
        Observable<Integer> o = Observable.fromIterable(Arrays.asList(1, 2, 3));

        for (int i = 0; i < 10; i++) {
            TestObserver<Integer> to = new TestObserver<>();

            o.subscribe(to);

            to.assertValues(1, 2, 3);
            to.assertNoErrors();
            to.assertComplete();
        }
    }",loop_control
iterable,"{
        final AtomicBoolean called = new AtomicBoolean(false);
        Iterable<Integer> iterable = new Iterable<Integer>() {

            @Override
            public Iterator<Integer> iterator() {
                return new Iterator<Integer>() {

                    int count = 1;

                    @Override
                    public void remove() {
                        // ignore
                    }

                    @Override
                    public boolean hasNext() {
                        if (count > 1) {
                            called.set(true);
                            return false;
                        }
                        return true;
                    }

                    @Override
                    public Integer next() {
                        return count++;
                    }

                };
            }
        };
        Observable.fromIterable(iterable).take(1).subscribe();
        assertFalse(called.get());
    }",iterator
iterable,"{
        final AtomicBoolean called = new AtomicBoolean(false);
        Iterable<Integer> iterable = new Iterable<Integer>() {

            @Override
            public Iterator<Integer> iterator() {
                return new Iterator<Integer>() {

                    @Override
                    public void remove() {
                        // ignore
                    }

                    int count = 1;

                    @Override
                    public boolean hasNext() {
                        if (count > 1) {
                            called.set(true);
                            return false;
                        }
                        return true;
                    }

                    @Override
                    public Integer next() {
                        return count++;
                    }

                };
            }
        };
        Observable.fromIterable(iterable).subscribe(new DefaultObserver<Integer>() {

            @Override
            public void onComplete() {

            }

            @Override
            public void onError(Throwable e) {

            }

            @Override
            public void onNext(Integer t) {
                // unsubscribe on first emission
                cancel();
            }
        });
        assertFalse(called.get());
    }",iterator
i,"{
        ConnectableObservable<Integer> co = Observable.range(0, 1000).publish();
        Observable<Integer> obs = co.observeOn(Schedulers.computation());
        for (int i = 0; i < 1000; i++) {
            for (int j = 1; j < 6; j++) {
                List<TestObserverEx<Integer>> tos = new ArrayList<>();
                for (int k = 1; k < j; k++) {
                    TestObserverEx<Integer> to = new TestObserverEx<>();
                    tos.add(to);
                    obs.subscribe(to);
                }

                Disposable connection = co.connect();

                for (TestObserverEx<Integer> to : tos) {
                    to.awaitDone(2, TimeUnit.SECONDS);
                    to.assertTerminated();
                    to.assertNoErrors();
                    assertEquals(1000, to.values().size());
                }
                connection.dispose();
            }
        }
    }",loop_control
j,"{
        ConnectableObservable<Integer> co = Observable.range(0, 1000).publish();
        Observable<Integer> obs = co.observeOn(Schedulers.computation());
        for (int i = 0; i < 1000; i++) {
            for (int j = 1; j < 6; j++) {
                List<TestObserverEx<Integer>> tos = new ArrayList<>();
                for (int k = 1; k < j; k++) {
                    TestObserverEx<Integer> to = new TestObserverEx<>();
                    tos.add(to);
                    obs.subscribe(to);
                }

                Disposable connection = co.connect();

                for (TestObserverEx<Integer> to : tos) {
                    to.awaitDone(2, TimeUnit.SECONDS);
                    to.assertTerminated();
                    to.assertNoErrors();
                    assertEquals(1000, to.values().size());
                }
                connection.dispose();
            }
        }
    }",loop_control
k,"{
        ConnectableObservable<Integer> co = Observable.range(0, 1000).publish();
        Observable<Integer> obs = co.observeOn(Schedulers.computation());
        for (int i = 0; i < 1000; i++) {
            for (int j = 1; j < 6; j++) {
                List<TestObserverEx<Integer>> tos = new ArrayList<>();
                for (int k = 1; k < j; k++) {
                    TestObserverEx<Integer> to = new TestObserverEx<>();
                    tos.add(to);
                    obs.subscribe(to);
                }

                Disposable connection = co.connect();

                for (TestObserverEx<Integer> to : tos) {
                    to.awaitDone(2, TimeUnit.SECONDS);
                    to.assertTerminated();
                    to.assertNoErrors();
                    assertEquals(1000, to.values().size());
                }
                connection.dispose();
            }
        }
    }",loop_control
to,"{
        ConnectableObservable<Integer> co = Observable.range(0, 1000).publish();
        Observable<Integer> obs = co.observeOn(Schedulers.computation());
        for (int i = 0; i < 1000; i++) {
            for (int j = 1; j < 6; j++) {
                List<TestObserverEx<Integer>> tos = new ArrayList<>();
                for (int k = 1; k < j; k++) {
                    TestObserverEx<Integer> to = new TestObserverEx<>();
                    tos.add(to);
                    obs.subscribe(to);
                }

                Disposable connection = co.connect();

                for (TestObserverEx<Integer> to : tos) {
                    to.awaitDone(2, TimeUnit.SECONDS);
                    to.assertTerminated();
                    to.assertNoErrors();
                    assertEquals(1000, to.values().size());
                }
                connection.dispose();
            }
        }
    }",iterator
i,"{
        for (int i = 0; i < TestHelper.RACE_DEFAULT_LOOPS; i++) {

            final ConnectableObservable<Integer> co = Observable.<Integer>empty().publish();

            co.connect();

            Runnable r1 = new Runnable() {
                @Override
                public void run() {
                    co.test();
                }
            };

            TestHelper.race(r1, r1);
        }
    }",loop_control
i,"{
        for (int i = 0; i < TestHelper.RACE_DEFAULT_LOOPS; i++) {

            final ConnectableObservable<Integer> co = Observable.<Integer>empty().publish();

            Runnable r1 = new Runnable() {
                @Override
                public void run() {
                    co.connect();
                }
            };

            TestHelper.race(r1, r1);
        }
    }",loop_control
i,"{
        for (int i = 0; i < TestHelper.RACE_DEFAULT_LOOPS; i++) {

            final ConnectableObservable<Integer> co = Observable.<Integer>empty().publish();

            final TestObserver<Integer> to = co.test();

            final TestObserver<Integer> to2 = new TestObserver<>();

            Runnable r1 = new Runnable() {
                @Override
                public void run() {
                    co.subscribe(to2);
                }
            };

            Runnable r2 = new Runnable() {
                @Override
                public void run() {
                    to.dispose();
                }
            };

            TestHelper.race(r1, r2);
        }
    }",loop_control
i,"{
        for (int i = 0; i < TestHelper.RACE_DEFAULT_LOOPS; i++) {

            final PublishSubject<Integer> ps = PublishSubject.create();

            final ConnectableObservable<Integer> co = ps.publish();

            final TestObserver<Integer> to = co.test();

            Runnable r1 = new Runnable() {
                @Override
                public void run() {
                    ps.onNext(1);
                }
            };

            Runnable r2 = new Runnable() {
                @Override
                public void run() {
                    to.dispose();
                }
            };

            TestHelper.race(r1, r2);
        }
    }",loop_control
i,"{
        for (int i = 0; i < TestHelper.RACE_DEFAULT_LOOPS; i++) {

            final PublishSubject<Integer> ps = PublishSubject.create();

            final ConnectableObservable<Integer> co = ps.publish();

            final Disposable d = co.connect();
            final TestObserver<Integer> to = new TestObserver<>();

            Runnable r1 = new Runnable() {
                @Override
                public void run() {
                    d.dispose();
                }
            };

            Runnable r2 = new Runnable() {
                @Override
                public void run() {
                    co.subscribe(to);
                }
            };

            TestHelper.race(r1, r2);
        }
    }",loop_control
i,"{
        for (int i = 0; i < TestHelper.RACE_LONG_LOOPS; i++) {
            final ConnectableObservable<Integer> co =
                    new ObservablePublish<>(Observable.<Integer>never());

            Runnable r = new Runnable() {
                @Override
                public void run() {
                    co.connect();
                }
            };

            TestHelper.race(r, r);
        }
    }",loop_control
i,"{
        List<Throwable> errors = TestHelper.trackPluginErrors();
        try {
            for (int i = 0; i < 1000; i++) {
                Observable.timer(0, TimeUnit.MILLISECONDS).blockingFirst();
            }

            assertTrue(errors.toString(), errors.isEmpty());
        } finally {
            RxJavaPlugins.reset();
        }
    }",loop_control
s,"{
        ScheduledExecutorService exec = Executors.newSingleThreadScheduledExecutor();
        try {
            for (Scheduler s : new Scheduler[] { Schedulers.single(), Schedulers.computation(), Schedulers.newThread(), Schedulers.io(), Schedulers.from(exec, true) }) {
                final AtomicBoolean interrupted = new AtomicBoolean();
                TestObserver<Long> to = Observable.timer(1, TimeUnit.MILLISECONDS, s)
                .map(new Function<Long, Long>() {
                    @Override
                    public Long apply(Long v) throws Exception {
                        try {
                        Thread.sleep(3000);
                        } catch (InterruptedException ex) {
                            interrupted.set(true);
                        }
                        return v;
                    }
                })
                .test();

                Thread.sleep(500);

                to.dispose();

                Thread.sleep(500);

                assertTrue(s.getClass().getSimpleName(), interrupted.get());
            }
        } finally {
            exec.shutdown();
        }
    }",iterator
arg,"{
        List<String> list = new ArrayList<>();
        for (String arg : args) {
            list.add(arg);
        }
        return list;
    }",iterator
d,"{
        return Observable.unsafeCreate(new ObservableSource<Integer>() {
            @Override
            public void subscribe(Observer<? super Integer> observer) {
                Disposable d = Disposable.empty();
                observer.onSubscribe(d);
                while (!d.isDisposed()) {
                    // burst some number of items
                    for (int i = 0; i < Math.random() * 20; i++) {
                        observer.onNext(i);
                    }
                    try {
                        // sleep for a random amount of time
                        // NOTE: Only using Thread.sleep here as an artificial demo.
                        Thread.sleep((long) (Math.random() * 200));
                    } catch (Exception e) {
                        // do nothing
                    }
                }
                System.out.println(""Hot done."");
            }
        }).subscribeOn(Schedulers.newThread()); // use newThread since we are using sleep to block
    }",maybe_loop_control
i,"{
        return Observable.unsafeCreate(new ObservableSource<Integer>() {
            @Override
            public void subscribe(Observer<? super Integer> observer) {
                Disposable d = Disposable.empty();
                observer.onSubscribe(d);
                while (!d.isDisposed()) {
                    // burst some number of items
                    for (int i = 0; i < Math.random() * 20; i++) {
                        observer.onNext(i);
                    }
                    try {
                        // sleep for a random amount of time
                        // NOTE: Only using Thread.sleep here as an artificial demo.
                        Thread.sleep((long) (Math.random() * 200));
                    } catch (Exception e) {
                        // do nothing
                    }
                }
                System.out.println(""Hot done."");
            }
        }).subscribeOn(Schedulers.newThread()); // use newThread since we are using sleep to block
    }",loop_control
i,"{
        TestObserverEx<Integer> to = Observable.range(1, 10)
                .concatWith(Observable.<Integer>error(new TestException()))
        .flatMapMaybe(new Function<Integer, MaybeSource<Integer>>() {
            @Override
            public MaybeSource<Integer> apply(Integer v) throws Exception {
                return Maybe.error(new TestException());
            }
        }, true)
        .to(TestHelper.<Integer>testConsumer())
        .assertFailure(CompositeException.class);

        List<Throwable> errors = TestHelper.compositeList(to.errors().get(0));

        for (int i = 0; i < 11; i++) {
            TestHelper.assertError(errors, i, TestException.class);
        }
    }",loop_control
i,"{
        for (int i = 0; i < TestHelper.RACE_DEFAULT_LOOPS; i++) {
            PublishSubject<Integer> ps1 = PublishSubject.create();

            TestObserver<Integer> to = new TestObserver<>();
            CountDownLatch cdl = new CountDownLatch(1);

            ps1.flatMapMaybe(v -> {
                TestHelper.raceOther(() -> {
                    to.dispose();
                }, cdl);
                return Maybe.just(1);
            })
            .subscribe(to);

            ps1.onNext(1);

            cdl.await();
        }
    }",loop_control
i,"{
        for (int i = 0; i < TestHelper.RACE_LONG_LOOPS; i++) {
            MaybeSubject<Integer> ms1 = MaybeSubject.create();
            MaybeSubject<Integer> ms2 = MaybeSubject.create();

            TestObserver<Integer> to = Observable.just(1, 2)
            .flatMapMaybe(v -> v == 1 ? ms1 : ms2)
            .test();

            TestHelper.race(
                    () -> ms1.onComplete(),
                    () -> ms2.onSuccess(1)
            );

            to.assertResult(1);
        }
    }",loop_control
i,"{
        for (int i = 0; i < TestHelper.RACE_LONG_LOOPS; i++) {
            MaybeSubject<Integer> ms1 = MaybeSubject.create();
            MaybeSubject<Integer> ms2 = MaybeSubject.create();

            TestObserver<Integer> to = Observable.just(1, 2)
            .flatMapMaybe(v -> v == 1 ? ms1 : ms2)
            .test();

            TestHelper.race(
                    () -> ms2.onSuccess(1),
                    () -> ms1.onComplete()
            );

            to.assertResult(1);
        }
    }",loop_control
i,"{
        TestObserverEx<Integer> to = Observable.range(1, 10).concatWith(Observable.<Integer>error(new TestException()))
        .flatMapCompletable(new Function<Integer, CompletableSource>() {
            @Override
            public CompletableSource apply(Integer v) throws Exception {
                return Completable.error(new TestException());
            }
        }, true).<Integer>toObservable()
        .to(TestHelper.<Integer>testConsumer())
        .assertFailure(CompositeException.class);

        List<Throwable> errors = TestHelper.compositeList(to.errors().get(0));

        for (int i = 0; i < 11; i++) {
            TestHelper.assertError(errors, i, TestException.class);
        }
    }",loop_control
i,"{
        TestObserverEx<Integer> to = Observable.range(1, 10)
        .flatMapCompletable(new Function<Integer, CompletableSource>() {
            @Override
            public CompletableSource apply(Integer v) throws Exception {
                return Completable.error(new TestException());
            }
        }, true).<Integer>toObservable()
        .to(TestHelper.<Integer>testConsumer())
        .assertFailure(CompositeException.class);

        List<Throwable> errors = TestHelper.compositeList(to.errors().get(0));

        for (int i = 0; i < 10; i++) {
            TestHelper.assertError(errors, i, TestException.class);
        }
    }",loop_control
i,"{
        TestObserverEx<Void> to = Observable.range(1, 10).concatWith(Observable.<Integer>error(new TestException()))
        .flatMapCompletable(new Function<Integer, CompletableSource>() {
            @Override
            public CompletableSource apply(Integer v) throws Exception {
                return Completable.error(new TestException());
            }
        }, true)
        .to(TestHelper.<Void>testConsumer())
        .assertFailure(CompositeException.class);

        List<Throwable> errors = TestHelper.compositeList(to.errors().get(0));

        for (int i = 0; i < 11; i++) {
            TestHelper.assertError(errors, i, TestException.class);
        }
    }",loop_control
i,"{
        TestObserverEx<Void> to = Observable.range(1, 10)
        .flatMapCompletable(new Function<Integer, CompletableSource>() {
            @Override
            public CompletableSource apply(Integer v) throws Exception {
                return Completable.error(new TestException());
            }
        }, true)
        .to(TestHelper.<Void>testConsumer())
        .assertFailure(CompositeException.class);

        List<Throwable> errors = TestHelper.compositeList(to.errors().get(0));

        for (int i = 0; i < 10; i++) {
            TestHelper.assertError(errors, i, TestException.class);
        }
    }",loop_control
i,"{
        for (int i = 0; i < TestHelper.RACE_DEFAULT_LOOPS; i++) {
            PublishSubject<Integer> ps1 = PublishSubject.create();

            TestObserver<Object> to = new TestObserver<>();
            CountDownLatch cdl = new CountDownLatch(1);

            ps1.flatMapCompletable(v -> {
                TestHelper.raceOther(() -> {
                    to.dispose();
                }, cdl);
                return Completable.complete();
            })
            .toObservable()
            .subscribe(to);

            ps1.onNext(1);

            cdl.await();
        }
    }",loop_control
i,"{
        for (int i = 0; i < TestHelper.RACE_DEFAULT_LOOPS; i++) {
            PublishSubject<Integer> ps1 = PublishSubject.create();

            TestObserver<Void> to = new TestObserver<>();
            CountDownLatch cdl = new CountDownLatch(1);

            ps1.flatMapCompletable(v -> {
                TestHelper.raceOther(() -> {
                    to.dispose();
                }, cdl);
                return Completable.complete();
            })
            .subscribe(to);

            ps1.onNext(1);

            cdl.await();
        }
    }",loop_control
i,"{
        for (int i = 0; i < TestHelper.RACE_DEFAULT_LOOPS; i++) {
            final PublishSubject<Integer> ps = PublishSubject.create();

            final TestObserver<Boolean> to = Observable.sequenceEqual(Observable.never(), ps).test();

            Runnable r1 = new Runnable() {
                @Override
                public void run() {
                    to.dispose();
                }
            };

            Runnable r2 = new Runnable() {
                @Override
                public void run() {
                    ps.onNext(1);
                }
            };

            TestHelper.race(r1, r2);

            to.assertEmpty();
        }
    }",loop_control
i,"{
        for (int i = 0; i < TestHelper.RACE_DEFAULT_LOOPS; i++) {
            final PublishSubject<Integer> ps = PublishSubject.create();

            final TestObserver<Boolean> to = Observable.sequenceEqual(Observable.never(), ps).toObservable().test();

            Runnable r1 = new Runnable() {
                @Override
                public void run() {
                    to.dispose();
                }
            };

            Runnable r2 = new Runnable() {
                @Override
                public void run() {
                    ps.onNext(1);
                }
            };

            TestHelper.race(r1, r2);

            to.assertEmpty();
        }
    }",loop_control
i,"{
        PublishSubject<Integer> source = PublishSubject.create();
        PublishSubject<Integer> boundary = PublishSubject.create();

        final Observer<Object> o = TestHelper.mockObserver();

        final List<Observer<Object>> values = new ArrayList<>();

        Observer<Observable<Integer>> wo = new DefaultObserver<Observable<Integer>>() {
            @Override
            public void onNext(Observable<Integer> args) {
                final Observer<Object> mo = TestHelper.mockObserver();
                values.add(mo);

                args.subscribe(mo);
            }

            @Override
            public void onError(Throwable e) {
                o.onError(e);
            }

            @Override
            public void onComplete() {
                o.onComplete();
            }
        };

        source.window(boundary).subscribe(wo);

        int n = 30;
        for (int i = 0; i < n; i++) {
            source.onNext(i);
            if (i % 3 == 2 && i < n - 1) {
                boundary.onNext(i / 3);
            }
        }
        source.onComplete();

        verify(o, never()).onError(any(Throwable.class));

        assertEquals(n / 3, values.size());

        int j = 0;
        for (Observer<Object> mo : values) {
            verify(mo, never()).onError(any(Throwable.class));
            for (int i = 0; i < 3; i++) {
                verify(mo).onNext(j + i);
            }
            verify(mo).onComplete();
            j += 3;
        }

        verify(o).onComplete();
    }",loop_control
mo,"{
        PublishSubject<Integer> source = PublishSubject.create();
        PublishSubject<Integer> boundary = PublishSubject.create();

        final Observer<Object> o = TestHelper.mockObserver();

        final List<Observer<Object>> values = new ArrayList<>();

        Observer<Observable<Integer>> wo = new DefaultObserver<Observable<Integer>>() {
            @Override
            public void onNext(Observable<Integer> args) {
                final Observer<Object> mo = TestHelper.mockObserver();
                values.add(mo);

                args.subscribe(mo);
            }

            @Override
            public void onError(Throwable e) {
                o.onError(e);
            }

            @Override
            public void onComplete() {
                o.onComplete();
            }
        };

        source.window(boundary).subscribe(wo);

        int n = 30;
        for (int i = 0; i < n; i++) {
            source.onNext(i);
            if (i % 3 == 2 && i < n - 1) {
                boundary.onNext(i / 3);
            }
        }
        source.onComplete();

        verify(o, never()).onError(any(Throwable.class));

        assertEquals(n / 3, values.size());

        int j = 0;
        for (Observer<Object> mo : values) {
            verify(mo, never()).onError(any(Throwable.class));
            for (int i = 0; i < 3; i++) {
                verify(mo).onNext(j + i);
            }
            verify(mo).onComplete();
            j += 3;
        }

        verify(o).onComplete();
    }",iterator
i,"{
        PublishSubject<Integer> source = PublishSubject.create();
        PublishSubject<Integer> boundary = PublishSubject.create();

        final Observer<Object> o = TestHelper.mockObserver();

        final List<Observer<Object>> values = new ArrayList<>();

        Observer<Observable<Integer>> wo = new DefaultObserver<Observable<Integer>>() {
            @Override
            public void onNext(Observable<Integer> args) {
                final Observer<Object> mo = TestHelper.mockObserver();
                values.add(mo);

                args.subscribe(mo);
            }

            @Override
            public void onError(Throwable e) {
                o.onError(e);
            }

            @Override
            public void onComplete() {
                o.onComplete();
            }
        };

        source.window(boundary).subscribe(wo);

        int n = 30;
        for (int i = 0; i < n; i++) {
            source.onNext(i);
            if (i % 3 == 2 && i < n - 1) {
                boundary.onNext(i / 3);
            }
        }
        boundary.onComplete();

        assertEquals(n / 3, values.size());

        int j = 0;
        for (Observer<Object> mo : values) {
            for (int i = 0; i < 3; i++) {
                verify(mo).onNext(j + i);
            }
            verify(mo).onComplete();
            verify(mo, never()).onError(any(Throwable.class));
            j += 3;
        }

        verify(o).onComplete();
        verify(o, never()).onError(any(Throwable.class));
    }",loop_control
mo,"{
        PublishSubject<Integer> source = PublishSubject.create();
        PublishSubject<Integer> boundary = PublishSubject.create();

        final Observer<Object> o = TestHelper.mockObserver();

        final List<Observer<Object>> values = new ArrayList<>();

        Observer<Observable<Integer>> wo = new DefaultObserver<Observable<Integer>>() {
            @Override
            public void onNext(Observable<Integer> args) {
                final Observer<Object> mo = TestHelper.mockObserver();
                values.add(mo);

                args.subscribe(mo);
            }

            @Override
            public void onError(Throwable e) {
                o.onError(e);
            }

            @Override
            public void onComplete() {
                o.onComplete();
            }
        };

        source.window(boundary).subscribe(wo);

        int n = 30;
        for (int i = 0; i < n; i++) {
            source.onNext(i);
            if (i % 3 == 2 && i < n - 1) {
                boundary.onNext(i / 3);
            }
        }
        boundary.onComplete();

        assertEquals(n / 3, values.size());

        int j = 0;
        for (Observer<Object> mo : values) {
            for (int i = 0; i < 3; i++) {
                verify(mo).onNext(j + i);
            }
            verify(mo).onComplete();
            verify(mo, never()).onError(any(Throwable.class));
            j += 3;
        }

        verify(o).onComplete();
        verify(o, never()).onError(any(Throwable.class));
    }",iterator
i,"{
        final TestException ex = new TestException();

        for (int i = 0; i < TestHelper.RACE_LONG_LOOPS; i++) {
            List<Throwable> errors = TestHelper.trackPluginErrors();
            try {
                final AtomicReference<Observer<? super Object>> refMain = new AtomicReference<>();
                final AtomicReference<Observer<? super Object>> ref = new AtomicReference<>();

                TestObserverEx<Observable<Object>> to = new Observable<Object>() {
                    @Override
                    protected void subscribeActual(Observer<? super Object> observer) {
                        observer.onSubscribe(Disposable.empty());
                        refMain.set(observer);
                    }
                }
                .window(new Observable<Object>() {
                    @Override
                    protected void subscribeActual(Observer<? super Object> observer) {
                        observer.onSubscribe(Disposable.empty());
                        ref.set(observer);
                    }
                })
                .to(TestHelper.<Observable<Object>>testConsumer());

                Runnable r1 = new Runnable() {
                    @Override
                    public void run() {
                        refMain.get().onComplete();
                    }
                };
                Runnable r2 = new Runnable() {
                    @Override
                    public void run() {
                        ref.get().onError(ex);
                    }
                };

                TestHelper.race(r1, r2);

                to
                .assertValueCount(1)
                .assertTerminated();

                if (!errors.isEmpty()) {
                    TestHelper.assertUndeliverable(errors, 0, TestException.class);
                }
            } finally {
                RxJavaPlugins.reset();
            }
        }
    }",loop_control
i,"{
        for (int i = 0; i < TestHelper.RACE_LONG_LOOPS; i++) {
            final AtomicReference<Observer<? super Object>> refMain = new AtomicReference<>();
            final AtomicReference<Observer<? super Object>> ref = new AtomicReference<>();

            TestObserver<Observable<Object>> to = new Observable<Object>() {
                @Override
                protected void subscribeActual(Observer<? super Object> observer) {
                    observer.onSubscribe(Disposable.empty());
                    refMain.set(observer);
                }
            }
            .window(new Observable<Object>() {
                @Override
                protected void subscribeActual(Observer<? super Object> observer) {
                    observer.onSubscribe(Disposable.empty());
                    ref.set(observer);
                }
            })
            .test();

            Runnable r1 = new Runnable() {
                @Override
                public void run() {
                    refMain.get().onNext(1);
                }
            };
            Runnable r2 = new Runnable() {
                @Override
                public void run() {
                    ref.get().onNext(1);
                }
            };

            TestHelper.race(r1, r2);

            to
            .assertValueCount(2)
            .assertNotComplete()
            .assertNoErrors();
        }
    }",loop_control
i,"{
        for (int i = 0; i < TestHelper.RACE_LONG_LOOPS; i++) {
            final AtomicReference<Observer<? super Object>> refMain = new AtomicReference<>();
            final AtomicReference<Observer<? super Object>> ref = new AtomicReference<>();

            final TestObserver<Observable<Object>> to = new Observable<Object>() {
                 @Override
                 protected void subscribeActual(Observer<? super Object> observer) {
                     observer.onSubscribe(Disposable.empty());
                     refMain.set(observer);
                 }
             }
             .window(new Observable<Object>() {
                 @Override
                 protected void subscribeActual(Observer<? super Object> observer) {
                     final AtomicInteger counter = new AtomicInteger();
                     observer.onSubscribe(new Disposable() {

                         @Override
                         public void dispose() {
                             // about a microsecond
                             for (int i = 0; i < 100; i++) {
                                 counter.incrementAndGet();
                             }
                         }

                         @Override
                         public boolean isDisposed() {
                             return false;
                         }
                      });
                     ref.set(observer);
                 }
             })
             .test();

             Runnable r1 = new Runnable() {
                 @Override
                 public void run() {
                     to.dispose();
                 }
             };
             Runnable r2 = new Runnable() {
                 @Override
                 public void run() {
                     Observer<Object> o = ref.get();
                     o.onNext(1);
                     o.onComplete();
                 }
             };

             TestHelper.race(r1, r2);
        }
    }",loop_control
i,"{
        final TestException ex = new TestException();

        for (int i = 0; i < TestHelper.RACE_LONG_LOOPS; i++) {
           final AtomicReference<Observer<? super Object>> refMain = new AtomicReference<>();
           final AtomicReference<Observer<? super Object>> ref = new AtomicReference<>();

           final TestObserver<Observable<Object>> to = new Observable<Object>() {
               @Override
               protected void subscribeActual(Observer<? super Object> observer) {
                   observer.onSubscribe(Disposable.empty());
                   refMain.set(observer);
               }
           }
           .window(new Observable<Object>() {
               @Override
               protected void subscribeActual(Observer<? super Object> observer) {
                   final AtomicInteger counter = new AtomicInteger();
                   observer.onSubscribe(new Disposable() {

                       @Override
                       public void dispose() {
                           // about a microsecond
                           for (int i = 0; i < 100; i++) {
                               counter.incrementAndGet();
                           }
                       }

                       @Override
                       public boolean isDisposed() {
                           return false;
                       }
                    });
                   ref.set(observer);
               }
           })
           .test();

            Runnable r1 = new Runnable() {
                @Override
                public void run() {
                    to.dispose();
                }
            };
            Runnable r2 = new Runnable() {
                @Override
                public void run() {
                    Observer<Object> o = ref.get();
                    o.onNext(1);
                    o.onError(ex);
                }
            };

            TestHelper.race(r1, r2);
        }
    }",loop_control
timeout,"{
        List<Throwable> errors = TestHelper.trackPluginErrors();
        try {
            final CountDownLatch cdl1 = new CountDownLatch(1);
            final CountDownLatch cdl2 = new CountDownLatch(1);

            TestObserver<Object> to = Observable.fromCompletable(Completable.fromAction(new Action() {
                @Override
                public void run() throws Exception {
                    cdl1.countDown();
                    cdl2.await(5, TimeUnit.SECONDS);
                }
            })).subscribeOn(Schedulers.single()).test();

            assertTrue(cdl1.await(5, TimeUnit.SECONDS));

            to.dispose();

            int timeout = 10;

            while (timeout-- > 0 && errors.isEmpty()) {
                Thread.sleep(100);
            }

            TestHelper.assertUndeliverable(errors, 0, InterruptedException.class);
        } finally {
            RxJavaPlugins.reset();
        }
    }",loop_control
errors,"{
        List<Throwable> errors = TestHelper.trackPluginErrors();
        try {
            final CountDownLatch cdl1 = new CountDownLatch(1);
            final CountDownLatch cdl2 = new CountDownLatch(1);

            TestObserver<Object> to = Observable.fromCompletable(Completable.fromAction(new Action() {
                @Override
                public void run() throws Exception {
                    cdl1.countDown();
                    cdl2.await(5, TimeUnit.SECONDS);
                }
            })).subscribeOn(Schedulers.single()).test();

            assertTrue(cdl1.await(5, TimeUnit.SECONDS));

            to.dispose();

            int timeout = 10;

            while (timeout-- > 0 && errors.isEmpty()) {
                Thread.sleep(100);
            }

            TestHelper.assertUndeliverable(errors, 0, InterruptedException.class);
        } finally {
            RxJavaPlugins.reset();
        }
    }",maybe_loop_control
terminate,"{

        final AtomicInteger efforts = new AtomicInteger(0);
        final AtomicInteger active = new AtomicInteger(0), maxActive = new AtomicInteger(0);
        final AtomicInteger nextBeforeFailure;

        final String context;

        private final int emitDelay;

        SlowObservable(int emitDelay, int countNext, String context) {
            this.emitDelay = emitDelay;
            this.nextBeforeFailure = new AtomicInteger(countNext);
            this.context = context;
        }

        @Override
        public void subscribe(final Observer<? super Long> observer) {
            final AtomicBoolean terminate = new AtomicBoolean(false);
            observer.onSubscribe(Disposable.fromRunnable(new Runnable() {
                @Override
                public void run() {
                        terminate.set(true);
                        active.decrementAndGet();
                }
            }));
            efforts.getAndIncrement();
            active.getAndIncrement();
            maxActive.set(Math.max(active.get(), maxActive.get()));
            final Thread thread = new Thread(context) {
                @Override
                public void run() {
                    long nr = 0;
                    try {
                        while (!terminate.get()) {
                            Thread.sleep(emitDelay);
                            if (nextBeforeFailure.getAndDecrement() > 0) {
                                observer.onNext(nr++);
                            } else {
                                active.decrementAndGet();
                                observer.onError(new RuntimeException(""expected-failed""));
                                break;
                            }
                        }
                    } catch (InterruptedException t) {
                    }
                }
            };
            thread.start();
        }
    }",maybe_loop_control
j,"{
        final int NUM_LOOPS = 1;
        for (int j = 0; j < NUM_LOOPS; j++) {
            final int NUM_RETRIES = Flowable.bufferSize() * 2;
            for (int i = 0; i < 400; i++) {
                Observer<String> observer = TestHelper.mockObserver();
                Observable<String> origin = Observable.unsafeCreate(new FuncWithErrors(NUM_RETRIES));
                TestObserver<String> to = new TestObserver<>(observer);
                origin.retry().observeOn(Schedulers.computation()).subscribe(to);
                to.awaitDone(5, TimeUnit.SECONDS);

                InOrder inOrder = inOrder(observer);
                // should have no errors
                verify(observer, never()).onError(any(Throwable.class));
                // should show NUM_RETRIES attempts
                inOrder.verify(observer, times(NUM_RETRIES + 1)).onNext(""beginningEveryTime"");
                // should have a single success
                inOrder.verify(observer, times(1)).onNext(""onSuccessOnly"");
                // should have a single successful onComplete
                inOrder.verify(observer, times(1)).onComplete();
                inOrder.verifyNoMoreInteractions();
            }
        }
    }",loop_control
i,"{
        final int NUM_LOOPS = 1;
        for (int j = 0; j < NUM_LOOPS; j++) {
            final int NUM_RETRIES = Flowable.bufferSize() * 2;
            for (int i = 0; i < 400; i++) {
                Observer<String> observer = TestHelper.mockObserver();
                Observable<String> origin = Observable.unsafeCreate(new FuncWithErrors(NUM_RETRIES));
                TestObserver<String> to = new TestObserver<>(observer);
                origin.retry().observeOn(Schedulers.computation()).subscribe(to);
                to.awaitDone(5, TimeUnit.SECONDS);

                InOrder inOrder = inOrder(observer);
                // should have no errors
                verify(observer, never()).onError(any(Throwable.class));
                // should show NUM_RETRIES attempts
                inOrder.verify(observer, times(NUM_RETRIES + 1)).onNext(""beginningEveryTime"");
                // should have a single success
                inOrder.verify(observer, times(1)).onNext(""onSuccessOnly"");
                // should have a single successful onComplete
                inOrder.verify(observer, times(1)).onComplete();
                inOrder.verifyNoMoreInteractions();
            }
        }
    }",loop_control
r,"{
        final int NUM_LOOPS = 1;
        final int NUM_RETRIES = Flowable.bufferSize() * 2;
        int ncpu = Runtime.getRuntime().availableProcessors();
        ExecutorService exec = Executors.newFixedThreadPool(Math.max(ncpu / 2, 2));
        try {
            for (int r = 0; r < NUM_LOOPS; r++) {
                if (r % 10 == 0) {
                    System.out.println(""testRetryWithBackpressureParallelLoop -> "" + r);
                }

                final AtomicInteger timeouts = new AtomicInteger();
                final Map<Integer, List<String>> data = new ConcurrentHashMap<>();

                int m = 5000;
                final CountDownLatch cdl = new CountDownLatch(m);
                for (int i = 0; i < m; i++) {
                    final int j = i;
                    exec.execute(new Runnable() {
                        @Override
                        public void run() {
                            final AtomicInteger nexts = new AtomicInteger();
                            try {
                                Observable<String> origin = Observable.unsafeCreate(new FuncWithErrors(NUM_RETRIES));
                                TestObserverEx<String> to = new TestObserverEx<>();
                                origin.retry()
                                .observeOn(Schedulers.computation()).subscribe(to);
                                to.awaitDone(2500, TimeUnit.MILLISECONDS);
                                List<String> onNextEvents = new ArrayList<>(to.values());
                                if (onNextEvents.size() != NUM_RETRIES + 2) {
                                    for (Throwable t : to.errors()) {
                                        onNextEvents.add(t.toString());
                                    }
                                    for (long err = to.completions(); err != 0; err--) {
                                        onNextEvents.add(""onComplete"");
                                    }
                                    data.put(j, onNextEvents);
                                }
                            } catch (Throwable t) {
                                timeouts.incrementAndGet();
                                System.out.println(j + "" | "" + cdl.getCount() + "" !!! "" + nexts.get());
                            }
                            cdl.countDown();
                        }
                    });
                }
                cdl.await();
                assertEquals(0, timeouts.get());
                if (data.size() > 0) {
                    fail(""Data content mismatch: "" + allSequenceFrequency(data));
                }
            }
        } finally {
            exec.shutdown();
        }
    }",loop_control
i,"{
        final int NUM_LOOPS = 1;
        final int NUM_RETRIES = Flowable.bufferSize() * 2;
        int ncpu = Runtime.getRuntime().availableProcessors();
        ExecutorService exec = Executors.newFixedThreadPool(Math.max(ncpu / 2, 2));
        try {
            for (int r = 0; r < NUM_LOOPS; r++) {
                if (r % 10 == 0) {
                    System.out.println(""testRetryWithBackpressureParallelLoop -> "" + r);
                }

                final AtomicInteger timeouts = new AtomicInteger();
                final Map<Integer, List<String>> data = new ConcurrentHashMap<>();

                int m = 5000;
                final CountDownLatch cdl = new CountDownLatch(m);
                for (int i = 0; i < m; i++) {
                    final int j = i;
                    exec.execute(new Runnable() {
                        @Override
                        public void run() {
                            final AtomicInteger nexts = new AtomicInteger();
                            try {
                                Observable<String> origin = Observable.unsafeCreate(new FuncWithErrors(NUM_RETRIES));
                                TestObserverEx<String> to = new TestObserverEx<>();
                                origin.retry()
                                .observeOn(Schedulers.computation()).subscribe(to);
                                to.awaitDone(2500, TimeUnit.MILLISECONDS);
                                List<String> onNextEvents = new ArrayList<>(to.values());
                                if (onNextEvents.size() != NUM_RETRIES + 2) {
                                    for (Throwable t : to.errors()) {
                                        onNextEvents.add(t.toString());
                                    }
                                    for (long err = to.completions(); err != 0; err--) {
                                        onNextEvents.add(""onComplete"");
                                    }
                                    data.put(j, onNextEvents);
                                }
                            } catch (Throwable t) {
                                timeouts.incrementAndGet();
                                System.out.println(j + "" | "" + cdl.getCount() + "" !!! "" + nexts.get());
                            }
                            cdl.countDown();
                        }
                    });
                }
                cdl.await();
                assertEquals(0, timeouts.get());
                if (data.size() > 0) {
                    fail(""Data content mismatch: "" + allSequenceFrequency(data));
                }
            }
        } finally {
            exec.shutdown();
        }
    }",loop_control
t,"{
        final int NUM_LOOPS = 1;
        final int NUM_RETRIES = Flowable.bufferSize() * 2;
        int ncpu = Runtime.getRuntime().availableProcessors();
        ExecutorService exec = Executors.newFixedThreadPool(Math.max(ncpu / 2, 2));
        try {
            for (int r = 0; r < NUM_LOOPS; r++) {
                if (r % 10 == 0) {
                    System.out.println(""testRetryWithBackpressureParallelLoop -> "" + r);
                }

                final AtomicInteger timeouts = new AtomicInteger();
                final Map<Integer, List<String>> data = new ConcurrentHashMap<>();

                int m = 5000;
                final CountDownLatch cdl = new CountDownLatch(m);
                for (int i = 0; i < m; i++) {
                    final int j = i;
                    exec.execute(new Runnable() {
                        @Override
                        public void run() {
                            final AtomicInteger nexts = new AtomicInteger();
                            try {
                                Observable<String> origin = Observable.unsafeCreate(new FuncWithErrors(NUM_RETRIES));
                                TestObserverEx<String> to = new TestObserverEx<>();
                                origin.retry()
                                .observeOn(Schedulers.computation()).subscribe(to);
                                to.awaitDone(2500, TimeUnit.MILLISECONDS);
                                List<String> onNextEvents = new ArrayList<>(to.values());
                                if (onNextEvents.size() != NUM_RETRIES + 2) {
                                    for (Throwable t : to.errors()) {
                                        onNextEvents.add(t.toString());
                                    }
                                    for (long err = to.completions(); err != 0; err--) {
                                        onNextEvents.add(""onComplete"");
                                    }
                                    data.put(j, onNextEvents);
                                }
                            } catch (Throwable t) {
                                timeouts.incrementAndGet();
                                System.out.println(j + "" | "" + cdl.getCount() + "" !!! "" + nexts.get());
                            }
                            cdl.countDown();
                        }
                    });
                }
                cdl.await();
                assertEquals(0, timeouts.get());
                if (data.size() > 0) {
                    fail(""Data content mismatch: "" + allSequenceFrequency(data));
                }
            }
        } finally {
            exec.shutdown();
        }
    }",iterator
err,"{
        final int NUM_LOOPS = 1;
        final int NUM_RETRIES = Flowable.bufferSize() * 2;
        int ncpu = Runtime.getRuntime().availableProcessors();
        ExecutorService exec = Executors.newFixedThreadPool(Math.max(ncpu / 2, 2));
        try {
            for (int r = 0; r < NUM_LOOPS; r++) {
                if (r % 10 == 0) {
                    System.out.println(""testRetryWithBackpressureParallelLoop -> "" + r);
                }

                final AtomicInteger timeouts = new AtomicInteger();
                final Map<Integer, List<String>> data = new ConcurrentHashMap<>();

                int m = 5000;
                final CountDownLatch cdl = new CountDownLatch(m);
                for (int i = 0; i < m; i++) {
                    final int j = i;
                    exec.execute(new Runnable() {
                        @Override
                        public void run() {
                            final AtomicInteger nexts = new AtomicInteger();
                            try {
                                Observable<String> origin = Observable.unsafeCreate(new FuncWithErrors(NUM_RETRIES));
                                TestObserverEx<String> to = new TestObserverEx<>();
                                origin.retry()
                                .observeOn(Schedulers.computation()).subscribe(to);
                                to.awaitDone(2500, TimeUnit.MILLISECONDS);
                                List<String> onNextEvents = new ArrayList<>(to.values());
                                if (onNextEvents.size() != NUM_RETRIES + 2) {
                                    for (Throwable t : to.errors()) {
                                        onNextEvents.add(t.toString());
                                    }
                                    for (long err = to.completions(); err != 0; err--) {
                                        onNextEvents.add(""onComplete"");
                                    }
                                    data.put(j, onNextEvents);
                                }
                            } catch (Throwable t) {
                                timeouts.incrementAndGet();
                                System.out.println(j + "" | "" + cdl.getCount() + "" !!! "" + nexts.get());
                            }
                            cdl.countDown();
                        }
                    });
                }
                cdl.await();
                assertEquals(0, timeouts.get());
                if (data.size() > 0) {
                    fail(""Data content mismatch: "" + allSequenceFrequency(data));
                }
            }
        } finally {
            exec.shutdown();
        }
    }",loop_control
e,"{
        StringBuilder b = new StringBuilder();
        for (Map.Entry<Integer, List<T>> e : its.entrySet()) {
            if (b.length() > 0) {
                b.append("", "");
            }
            b.append(e.getKey()).append(""={"");
            b.append(sequenceFrequency(e.getValue()));
            b.append(""}"");
        }
        return b;
    }",iterator
curr,"{
        StringBuilder sb = new StringBuilder();

        Object prev = null;
        int cnt = 0;

        for (Object curr : it) {
            if (sb.length() > 0) {
                if (!curr.equals(prev)) {
                    if (cnt > 1) {
                        sb.append("" x "").append(cnt);
                        cnt = 1;
                    }
                    sb.append("", "");
                    sb.append(curr);
                } else {
                    cnt++;
                }
            } else {
                sb.append(curr);
                cnt++;
            }
            prev = curr;
        }
        if (cnt > 1) {
            sb.append("" x "").append(cnt);
        }

        return sb;
    }",iterator
i,"{
        Observer<String> observer = TestHelper.mockObserver();
        final int NUM_MSG = 1034;
        final AtomicInteger count = new AtomicInteger();

        Observable<String> origin = Observable.unsafeCreate(new ObservableSource<String>() {

            @Override
            public void subscribe(Observer<? super String> o) {
                o.onSubscribe(Disposable.empty());
                for (int i = 0; i < NUM_MSG; i++) {
                    o.onNext(""msg:"" + count.incrementAndGet());
                }
                o.onComplete();
            }
        });

        origin.retry()
        .groupBy(new Function<String, String>() {
            @Override
            public String apply(String t1) {
                return t1;
            }
        })
        .flatMap(new Function<GroupedObservable<String, String>, Observable<String>>() {
            @Override
            public Observable<String> apply(GroupedObservable<String, String> t1) {
                return t1.take(1);
            }
        })
        .subscribe(new TestObserver<>(observer));

        InOrder inOrder = inOrder(observer);
        // should show 3 attempts
        inOrder.verify(observer, times(NUM_MSG)).onNext(any(java.lang.String.class));
        //        // should have no errors
        inOrder.verify(observer, never()).onError(any(Throwable.class));
        // should have a single success
        //inOrder.verify(observer, times(1)).onNext(""onSuccessOnly"");
        // should have a single successful onComplete
        inOrder.verify(observer, times(1)).onComplete();
        inOrder.verifyNoMoreInteractions();
    }",loop_control
i,"{
        List<Throwable> errors = TestHelper.trackPluginErrors();

        final TestException error = new TestException();

        try {
            final PublishSubject<Integer> source = PublishSubject.create();
            final PublishSubject<Integer> signaller = PublishSubject.create();

            for (int i = 0; i < TestHelper.RACE_DEFAULT_LOOPS; i++) {

                TestObserver<Integer> to = source.take(1)
                .map(new Function<Integer, Integer>() {
                    @Override
                    public Integer apply(Integer v) throws Exception {
                        throw error;
                    }
                })
                .retryWhen(new Function<Observable<Throwable>, ObservableSource<Integer>>() {
                    @Override
                    public ObservableSource<Integer> apply(Observable<Throwable> v)
                            throws Exception {
                        return signaller;
                    }
                }).test();

                Runnable r1 = new Runnable() {
                    @Override
                    public void run() {
                        for (int i = 0; i < TestHelper.RACE_DEFAULT_LOOPS; i++) {
                            source.onNext(1);
                        }
                    }
                };
                Runnable r2 = new Runnable() {
                    @Override
                    public void run() {
                        for (int i = 0; i < TestHelper.RACE_DEFAULT_LOOPS; i++) {
                            signaller.onNext(1);
                        }
                    }
                };

                TestHelper.race(r1, r2);

                to.dispose();
            }

            if (!errors.isEmpty()) {
                for (Throwable e : errors) {
                    e.printStackTrace();
                }
                fail(errors + """");
            }
        } finally {
            RxJavaPlugins.reset();
        }
    }",loop_control
e,"{
        List<Throwable> errors = TestHelper.trackPluginErrors();

        final TestException error = new TestException();

        try {
            final PublishSubject<Integer> source = PublishSubject.create();
            final PublishSubject<Integer> signaller = PublishSubject.create();

            for (int i = 0; i < TestHelper.RACE_DEFAULT_LOOPS; i++) {

                TestObserver<Integer> to = source.take(1)
                .map(new Function<Integer, Integer>() {
                    @Override
                    public Integer apply(Integer v) throws Exception {
                        throw error;
                    }
                })
                .retryWhen(new Function<Observable<Throwable>, ObservableSource<Integer>>() {
                    @Override
                    public ObservableSource<Integer> apply(Observable<Throwable> v)
                            throws Exception {
                        return signaller;
                    }
                }).test();

                Runnable r1 = new Runnable() {
                    @Override
                    public void run() {
                        for (int i = 0; i < TestHelper.RACE_DEFAULT_LOOPS; i++) {
                            source.onNext(1);
                        }
                    }
                };
                Runnable r2 = new Runnable() {
                    @Override
                    public void run() {
                        for (int i = 0; i < TestHelper.RACE_DEFAULT_LOOPS; i++) {
                            signaller.onNext(1);
                        }
                    }
                };

                TestHelper.race(r1, r2);

                to.dispose();
            }

            if (!errors.isEmpty()) {
                for (Throwable e : errors) {
                    e.printStackTrace();
                }
                fail(errors + """");
            }
        } finally {
            RxJavaPlugins.reset();
        }
    }",iterator
i,"{
        for (int i = 0; i < 500; i++) {
            if (i % 10 == 0) {
                System.out.println(""testNestedAsyncConcat >> "" + i);
            }
            nestedAsyncConcat();
        }
    }",loop_control
i,"{
        final int n = 10000;
        Observable<Observable<Integer>> source = Observable.range(0, n).map(new Function<Integer, Observable<Integer>>() {
            @Override
            public Observable<Integer> apply(Integer v) {
                return Observable.just(v);
            }
        });

        Single<List<Integer>> result = Observable.concat(source).toList();

        SingleObserver<List<Integer>> o = TestHelper.mockSingleObserver();
        InOrder inOrder = inOrder(o);

        result.subscribe(o);

        List<Integer> list = new ArrayList<>(n);
        for (int i = 0; i < n; i++) {
            list.add(i);
        }
        inOrder.verify(o).onSuccess(list);
        verify(o, never()).onError(any(Throwable.class));
    }",loop_control
i,"{
        final int n = 10000;
        Observable<Observable<Integer>> source = Observable.range(0, n).map(new Function<Integer, Observable<Integer>>() {
            @Override
            public Observable<Integer> apply(Integer v) {
                return Observable.just(v);
            }
        });

        Single<List<Integer>> result = Observable.concat(source).take(n / 2).toList();

        SingleObserver<List<Integer>> o = TestHelper.mockSingleObserver();
        InOrder inOrder = inOrder(o);

        result.subscribe(o);

        List<Integer> list = new ArrayList<>(n);
        for (int i = 0; i < n / 2; i++) {
            list.add(i);
        }
        inOrder.verify(o).onSuccess(list);
        verify(o, never()).onError(any(Throwable.class));
    }",loop_control
i,"{
        final long durationSeconds = 2;
        final long startTime = System.currentTimeMillis();
        for (int i = 0;; i++) {
            //only run this for a max of ten seconds
            if (System.currentTimeMillis() - startTime > TimeUnit.SECONDS.toMillis(durationSeconds)) {
                return;
            }
            if (i % 1000 == 0) {
                System.out.println(""concatMapRangeAsyncLoop > "" + i);
            }
            TestObserverEx<Integer> to = new TestObserverEx<>();

            Observable.range(0, 1000)
            .concatMap(new Function<Integer, Observable<Integer>>() {
                @Override
                public Observable<Integer> apply(Integer t) {
                    return Observable.fromIterable(Arrays.asList(t));
                }
            })
            .observeOn(Schedulers.computation())
            .subscribe(to);

            to.awaitDone(2500, TimeUnit.MILLISECONDS);
            to.assertTerminated();
            to.assertNoErrors();
            assertEquals(1000, to.values().size());
            assertEquals((Integer)999, to.values().get(999));
        }
    }",loop_control
r2,"{
        PublishSubject<String> r1 = PublishSubject.create();
        /* define an Observer to receive aggregated events */
        Observer<String> o = TestHelper.mockObserver();
        InOrder io = inOrder(o);

        Iterable<String> r2 = new Iterable<String>() {
            @Override
            public Iterator<String> iterator() {
                throw new TestException();
            }
        };

        r1.zipWith(r2, zipr2).subscribe(o);

        r1.onNext(""one-"");
        r1.onNext(""two-"");
        r1.onError(new TestException());

        io.verify(o).onError(any(TestException.class));

        verify(o, never()).onComplete();
        verify(o, never()).onNext(any(String.class));

    }",iterator
r2,"{
        PublishSubject<String> r1 = PublishSubject.create();
        /* define an Observer to receive aggregated events */
        Observer<String> o = TestHelper.mockObserver();
        InOrder io = inOrder(o);

        Iterable<String> r2 = new Iterable<String>() {

            @Override
            public Iterator<String> iterator() {
                return new Iterator<String>() {
                    int count;

                    @Override
                    public boolean hasNext() {
                        if (count == 0) {
                            return true;
                        }
                        throw new TestException();
                    }

                    @Override
                    public String next() {
                        count++;
                        return ""1"";
                    }

                    @Override
                    public void remove() {
                        throw new UnsupportedOperationException(""Not supported yet."");
                    }

                };
            }

        };

        r1.zipWith(r2, zipr2).subscribe(o);

        r1.onNext(""one-"");
        r1.onError(new TestException());

        io.verify(o).onNext(""one-1"");
        io.verify(o).onError(any(TestException.class));

        verify(o, never()).onComplete();

    }",iterator
r2,"{
        PublishSubject<String> r1 = PublishSubject.create();
        /* define an Observer to receive aggregated events */
        Observer<String> o = TestHelper.mockObserver();
        InOrder io = inOrder(o);

        Iterable<String> r2 = new Iterable<String>() {

            @Override
            public Iterator<String> iterator() {
                return new Iterator<String>() {
                    @Override
                    public boolean hasNext() {
                        return true;
                    }

                    @Override
                    public String next() {
                        throw new TestException();
                    }

                    @Override
                    public void remove() {
                        throw new UnsupportedOperationException(""Not supported yet."");
                    }

                };
            }

        };

        r1.zipWith(r2, zipr2).subscribe(o);

        r1.onError(new TestException());

        io.verify(o).onError(any(TestException.class));

        verify(o, never()).onNext(any(String.class));
        verify(o, never()).onComplete();

    }",iterator
i,"{
        for (int i = 0; i < 50; i++) {
            final TestASynchronous1sDelayedObservable o1 = new TestASynchronous1sDelayedObservable();
            final TestASynchronous1sDelayedObservable o2 = new TestASynchronous1sDelayedObservable();
            Observable<Observable<String>> parentObservable = Observable.unsafeCreate(new ObservableSource<Observable<String>>() {
                @Override
                public void subscribe(Observer<? super Observable<String>> op) {
                    op.onSubscribe(Disposable.empty());
                    op.onNext(Observable.unsafeCreate(o1));
                    op.onNext(Observable.unsafeCreate(o2));
                    op.onError(new NullPointerException(""throwing exception in parent""));
                }
            });

            Observer<String> stringObserver = TestHelper.mockObserver();

            TestObserverEx<String> to = new TestObserverEx<>(stringObserver);
            Observable<String> m = Observable.mergeDelayError(parentObservable);
            m.subscribe(to);
            System.out.println(""testErrorInParentObservableDelayed | "" + i);
            to.awaitDone(2000, TimeUnit.MILLISECONDS);
            to.assertTerminated();

            verify(stringObserver, times(2)).onNext(""hello"");
            verify(stringObserver, times(1)).onError(any(NullPointerException.class));
            verify(stringObserver, never()).onComplete();
        }
    }",loop_control
it,"{
        Subject<String> s = PublishSubject.create();

        Iterator<String> it = mostRecent(s, ""default"").iterator();

        assertTrue(it.hasNext());
        assertEquals(""default"", it.next());
        assertEquals(""default"", it.next());

        s.onNext(""one"");
        assertTrue(it.hasNext());
        assertEquals(""one"", it.next());
        assertEquals(""one"", it.next());

        s.onNext(""two"");
        assertTrue(it.hasNext());
        assertEquals(""two"", it.next());
        assertEquals(""two"", it.next());

        s.onComplete();
        assertFalse(it.hasNext());

    }",iterator
it,"{
        Subject<String> s = PublishSubject.create();

        Iterator<String> it = mostRecent(s, ""default"").iterator();

        assertTrue(it.hasNext());
        assertEquals(""default"", it.next());
        assertEquals(""default"", it.next());

        s.onError(new TestException());
        assertTrue(it.hasNext());

        it.next();
    }",iterator
j,"{
        TestScheduler scheduler = new TestScheduler();
        Observable<Long> source = Observable.interval(1, TimeUnit.SECONDS, scheduler).take(10);

        Iterable<Long> iter = source.blockingMostRecent(-1L);

        for (int j = 0; j < 3; j++) {
            Iterator<Long> it = iter.iterator();

            Assert.assertEquals(Long.valueOf(-1), it.next());

            for (int i = 0; i < 9; i++) {
                scheduler.advanceTimeBy(1, TimeUnit.SECONDS);

                Assert.assertTrue(it.hasNext());
                Assert.assertEquals(Long.valueOf(i), it.next());
            }
            scheduler.advanceTimeBy(1, TimeUnit.SECONDS);

            Assert.assertFalse(it.hasNext());
        }

    }",loop_control
i,"{
        TestScheduler scheduler = new TestScheduler();
        Observable<Long> source = Observable.interval(1, TimeUnit.SECONDS, scheduler).take(10);

        Iterable<Long> iter = source.blockingMostRecent(-1L);

        for (int j = 0; j < 3; j++) {
            Iterator<Long> it = iter.iterator();

            Assert.assertEquals(Long.valueOf(-1), it.next());

            for (int i = 0; i < 9; i++) {
                scheduler.advanceTimeBy(1, TimeUnit.SECONDS);

                Assert.assertTrue(it.hasNext());
                Assert.assertEquals(Long.valueOf(i), it.next());
            }
            scheduler.advanceTimeBy(1, TimeUnit.SECONDS);

            Assert.assertFalse(it.hasNext());
        }

    }",loop_control
it,"{
        TestScheduler scheduler = new TestScheduler();
        Observable<Long> source = Observable.interval(1, TimeUnit.SECONDS, scheduler).take(10);

        Iterable<Long> iter = source.blockingMostRecent(-1L);

        for (int j = 0; j < 3; j++) {
            Iterator<Long> it = iter.iterator();

            Assert.assertEquals(Long.valueOf(-1), it.next());

            for (int i = 0; i < 9; i++) {
                scheduler.advanceTimeBy(1, TimeUnit.SECONDS);

                Assert.assertTrue(it.hasNext());
                Assert.assertEquals(Long.valueOf(i), it.next());
            }
            scheduler.advanceTimeBy(1, TimeUnit.SECONDS);

            Assert.assertFalse(it.hasNext());
        }

    }",iterator
it,"{
        Iterator<Integer> it = Observable.<Integer>empty()
        .blockingMostRecent(1)
        .iterator();

        try {
            it.next();
            fail(""Should have thrown"");
        } catch (NoSuchElementException ex) {
            // expected
        }

        try {
            it.remove();
            fail(""Should have thrown"");
        } catch (UnsupportedOperationException ex) {
            // expected
        }
    }",iterator
i,"{
        for (int i = 0; i < 1000; i++) {
            if (i % 100 == 0) {
                System.out.println(""testFlatMapTransformsMaxConcurrentNormalLoop => "" + i);
            }
            flatMapTransformsMaxConcurrentNormal();
        }
    }",loop_control
i,"{
        for (int i = 0; i < 2000; i++) {
            if (i % 10 == 0) {
                System.out.println(""flatMapRangeAsyncLoop > "" + i);
            }
            TestObserverEx<Integer> to = new TestObserverEx<>();
            Observable.range(0, 1000)
            .flatMap(new Function<Integer, Observable<Integer>>() {
                final Random rnd = new Random();
                @Override
                public Observable<Integer> apply(Integer t) {
                    Observable<Integer> r = Observable.just(t);
                    if (rnd.nextBoolean()) {
                        r = r.hide();
                    }
                    return r;
                }
            })
            .observeOn(Schedulers.computation())
            .subscribe(to);

            to.awaitDone(2500, TimeUnit.MILLISECONDS);
            if (to.completions() == 0) {
                System.out.println(to.values().size());
            }
            to.assertTerminated();
            to.assertNoErrors();
            List<Integer> list = to.values();
            if (list.size() < 1000) {
                Set<Integer> set = new HashSet<>(list);
                for (int j = 0; j < 1000; j++) {
                    if (!set.contains(j)) {
                        System.out.println(j + "" missing"");
                    }
                }
            }
            assertEquals(1000, list.size());
        }
    }",loop_control
j,"{
        for (int i = 0; i < 2000; i++) {
            if (i % 10 == 0) {
                System.out.println(""flatMapRangeAsyncLoop > "" + i);
            }
            TestObserverEx<Integer> to = new TestObserverEx<>();
            Observable.range(0, 1000)
            .flatMap(new Function<Integer, Observable<Integer>>() {
                final Random rnd = new Random();
                @Override
                public Observable<Integer> apply(Integer t) {
                    Observable<Integer> r = Observable.just(t);
                    if (rnd.nextBoolean()) {
                        r = r.hide();
                    }
                    return r;
                }
            })
            .observeOn(Schedulers.computation())
            .subscribe(to);

            to.awaitDone(2500, TimeUnit.MILLISECONDS);
            if (to.completions() == 0) {
                System.out.println(to.values().size());
            }
            to.assertTerminated();
            to.assertNoErrors();
            List<Integer> list = to.values();
            if (list.size() < 1000) {
                Set<Integer> set = new HashSet<>(list);
                for (int j = 0; j < 1000; j++) {
                    if (!set.contains(j)) {
                        System.out.println(j + "" missing"");
                    }
                }
            }
            assertEquals(1000, list.size());
        }
    }",loop_control
i,"{
        for (int i = 0; i < 1000; i++) {
            TestObserver<Integer> to = new TestObserver<>();

            Observable.range(1, 1000).flatMap(new Function<Integer, Observable<Integer>>() {
                @Override
                public Observable<Integer> apply(Integer t) {
                    return Observable.just(1).subscribeOn(Schedulers.computation());
                }
            }).subscribe(to);

            to.awaitDone(5, TimeUnit.SECONDS);
            to.assertNoErrors();
            to.assertComplete();
            to.assertValueCount(1000);
        }
    }",loop_control
n,"{
        for (final int n : new int[] { 1, 1000, 1000000 }) {
            TestObserver<Integer> to = new TestObserver<>();

            Observable.just(1, 2).flatMap(new Function<Integer, Observable<Integer>>() {
                @Override
                public Observable<Integer> apply(Integer t) {
                    return Observable.range(1, n);
                }
            }).subscribe(to);

            System.out.println(""flatMapTwoNestedSync >> @ "" + n);
            to.assertNoErrors();
            to.assertComplete();
            to.assertValueCount(n * 2);
        }
    }",iterator
i,"{
        for (int i = 0; i < TestHelper.RACE_DEFAULT_LOOPS; i++) {
            final PublishSubject<Integer> ps = PublishSubject.create();

            final TestObserver<Integer> to = Observable.merge(Observable.just(ps)).test();

            Runnable r1 = new Runnable() {
                @Override
                public void run() {
                    ps.onComplete();
                }
            };

            Runnable r2 = new Runnable() {
                @Override
                public void run() {
                    to.dispose();
                }
            };

            TestHelper.race(r1, r2);
        }
    }",loop_control
i,"{
        for (int i = 0; i < 500; i++) {
            TestObserver<Object> to = Observable.merge(
                    Observable.just(1).observeOn(Schedulers.single()).map(new Function<Integer, Object>() {
                        @Override
                        public Object apply(Integer v) throws Exception {
                            return Thread.currentThread().getName().substring(0, 4);
                        }
                    }),
                    Observable.just(1).observeOn(Schedulers.computation()).map(new Function<Integer, Object>() {
                        @Override
                        public Object apply(Integer v) throws Exception {
                            return Thread.currentThread().getName().substring(0, 4);
                        }
                    })
            )
            .test()
            .awaitDone(5, TimeUnit.SECONDS)
            .assertValueCount(2);

            List<Object> list = to.values();

            assertTrue(list.toString(), list.contains(""RxSi""));
            assertTrue(list.toString(), list.contains(""RxCo""));
        }
    }",loop_control
i,"{
        for (int i = 0; i < TestHelper.RACE_DEFAULT_LOOPS; i++) {
            List<Throwable> errors = TestHelper.trackPluginErrors();
            try {

                final PublishSubject<Observable<Integer>> ps = PublishSubject.create();

                final TestObserver<Integer> to = ps.flatMap(Functions.<Observable<Integer>>identity()).test();

                Runnable r1 = new Runnable() {
                    @Override
                    public void run() {
                        to.dispose();
                    }
                };
                Runnable r2 = new Runnable() {
                    @Override
                    public void run() {
                        ps.onComplete();
                    }
                };

                TestHelper.race(r1, r2);

                assertTrue(errors.toString(), errors.isEmpty());
            } finally {
                RxJavaPlugins.reset();
            }
        }
    }",loop_control
i,"{
        for (int i = 0; i < TestHelper.RACE_DEFAULT_LOOPS; i++) {
            for (int j = 1; j < 50; j += 5) {
                List<Throwable> errors = TestHelper.trackPluginErrors();
                try {

                    final PublishSubject<Observable<Integer>> ps = PublishSubject.create();

                    final TestObserver<Integer> to = ps.flatMap(Functions.<Observable<Integer>>identity()).test();

                    final PublishSubject<Integer> just = PublishSubject.create();
                    final PublishSubject<Integer> just2 = PublishSubject.create();
                    ps.onNext(just);
                    ps.onNext(just2);

                    Runnable r1 = new Runnable() {
                        @Override
                        public void run() {
                            just2.onNext(1);
                            to.dispose();
                        }
                    };
                    Runnable r2 = new Runnable() {
                        @Override
                        public void run() {
                            just.onNext(1);
                        }
                    };

                    TestHelper.race(r1, r2);

                    assertTrue(errors.toString(), errors.isEmpty());
                } finally {
                    RxJavaPlugins.reset();
                }
            }
        }
    }",loop_control
j,"{
        for (int i = 0; i < TestHelper.RACE_DEFAULT_LOOPS; i++) {
            for (int j = 1; j < 50; j += 5) {
                List<Throwable> errors = TestHelper.trackPluginErrors();
                try {

                    final PublishSubject<Observable<Integer>> ps = PublishSubject.create();

                    final TestObserver<Integer> to = ps.flatMap(Functions.<Observable<Integer>>identity()).test();

                    final PublishSubject<Integer> just = PublishSubject.create();
                    final PublishSubject<Integer> just2 = PublishSubject.create();
                    ps.onNext(just);
                    ps.onNext(just2);

                    Runnable r1 = new Runnable() {
                        @Override
                        public void run() {
                            just2.onNext(1);
                            to.dispose();
                        }
                    };
                    Runnable r2 = new Runnable() {
                        @Override
                        public void run() {
                            just.onNext(1);
                        }
                    };

                    TestHelper.race(r1, r2);

                    assertTrue(errors.toString(), errors.isEmpty());
                } finally {
                    RxJavaPlugins.reset();
                }
            }
        }
    }",loop_control
i,"{
        List<Throwable> errors = TestHelper.trackPluginErrors();
        try {
            final PublishSubject<Integer> ps = PublishSubject.create();

            TestObserver<Integer> to = ps.flatMap(new Function<Integer, Observable<Integer>>() {
                @Override
                public Observable<Integer> apply(Integer v)
                        throws Exception {
                    return Observable.just(v + 1);
                }
            }, 1)
            .subscribeWith(new TestObserver<Integer>() {
                @Override
                public void onNext(Integer t) {
                    super.onNext(t);
                    if (t == 1) {
                        for (int i = 1; i < 10; i++) {
                            ps.onNext(i);
                        }
                        ps.onComplete();
                    }
                }
            });

            ps.onNext(0);

            if (!errors.isEmpty()) {
                to.onError(new CompositeException(errors));
            }

            to.assertResult(1, 2, 3, 4, 5, 6, 7, 8, 9, 10);
        } finally {
            RxJavaPlugins.reset();
        }
    }",loop_control
i,"{
        final PublishSubject<Integer> ps = PublishSubject.create();

        TestObserver<Integer> to = ps.flatMap(new Function<Integer, Observable<Integer>>() {
            @Override
            public Observable<Integer> apply(Integer v)
                    throws Exception {
                return Observable.just(v + 1).hide();
            }
        }, 1)
        .subscribeWith(new TestObserver<Integer>() {
            @Override
            public void onNext(Integer t) {
                super.onNext(t);
                if (t == 1) {
                    for (int i = 1; i < 10; i++) {
                        ps.onNext(i);
                    }
                    ps.onComplete();
                }
            }
        });

        ps.onNext(0);

        to.assertResult(1, 2, 3, 4, 5, 6, 7, 8, 9, 10);
    }",loop_control
i,"{
        for (int i = 0; i < TestHelper.RACE_DEFAULT_LOOPS; i++) {
            Observable
            .range(0, 20)
            .flatMap(
                    integer -> {
                        if (integer % 5 != 0) {
                            return Observable
                                    .just(integer);
                        }

                        return Observable
                                .just(-integer)
                                .observeOn(Schedulers.computation());
                    },
                    false,
                    1
            )
            .ignoreElements()
            .blockingAwait();
        }
    }",loop_control
i,"{
        TestObserverEx<Integer> to = Observable.range(1, 10).concatWith(Observable.<Integer>error(new TestException()))
        .flatMapSingle(new Function<Integer, SingleSource<Integer>>() {
            @Override
            public SingleSource<Integer> apply(Integer v) throws Exception {
                return Single.error(new TestException());
            }
        }, true)
        .to(TestHelper.<Integer>testConsumer())
        .assertFailure(CompositeException.class);

        List<Throwable> errors = TestHelper.compositeList(to.errors().get(0));

        for (int i = 0; i < 11; i++) {
            TestHelper.assertError(errors, i, TestException.class);
        }
    }",loop_control
i,"{
        TestException ex = new TestException();
        for (int i = 0; i < TestHelper.RACE_DEFAULT_LOOPS; i++) {
            PublishSubject<Integer> ps1 = PublishSubject.create();
            SingleSubject<Integer> ps2 = SingleSubject.create();

            TestObserver<Integer> to = ps1.flatMapSingle(v -> ps2)
            .test();

            ps1.onNext(1);

            TestHelper.race(
                    () -> ps1.onComplete(),
                    () -> ps2.onError(ex)
            );

            to.assertFailure(TestException.class);
        }
    }",loop_control
i,"{
        for (int i = 0; i < TestHelper.RACE_DEFAULT_LOOPS; i++) {
            PublishSubject<Integer> ps1 = PublishSubject.create();

            TestObserver<Integer> to = new TestObserver<>();
            CountDownLatch cdl = new CountDownLatch(1);

            ps1.flatMapSingle(v -> {
                TestHelper.raceOther(() -> {
                    to.dispose();
                }, cdl);
                return Single.just(1);
            })
            .subscribe(to);

            ps1.onNext(1);

            cdl.await();
        }
    }",loop_control
arg,"{
        List<String> list = new ArrayList<>();
        for (String arg : args) {
            list.add(arg);
        }
        return list;
    }",iterator
i,"{
        for (int i = 0; i < TestHelper.RACE_DEFAULT_LOOPS; i++) {
            TestScheduler scheduler = new TestScheduler();

            PublishSubject<Integer> ps = PublishSubject.create();

            TestObserver<Observable<Integer>> to = ps.window(1, TimeUnit.MINUTES, scheduler, 1)
            .test();

            TestHelper.race(
                    () -> ps.onNext(1),
                    () -> to.dispose()
            );
        }
    }",loop_control
i,"{
        Observable<Integer> src = Observable.range(1, 10).skipWhile(LESS_THAN_FIVE);
        int n = 5;
        for (int i = 0; i < n; i++) {
            Observer<Object> o = TestHelper.mockObserver();
            InOrder inOrder = inOrder(o);

            src.subscribe(o);

            for (int j = 5; j < 10; j++) {
                inOrder.verify(o).onNext(j);
            }
            inOrder.verify(o).onComplete();
            verify(o, never()).onError(any(Throwable.class));
        }
    }",loop_control
j,"{
        Observable<Integer> src = Observable.range(1, 10).skipWhile(LESS_THAN_FIVE);
        int n = 5;
        for (int i = 0; i < n; i++) {
            Observer<Object> o = TestHelper.mockObserver();
            InOrder inOrder = inOrder(o);

            src.subscribe(o);

            for (int j = 5; j < 10; j++) {
                inOrder.verify(o).onNext(j);
            }
            inOrder.verify(o).onComplete();
            verify(o, never()).onError(any(Throwable.class));
        }
    }",loop_control
i,"{
        int n = 30;
        Function<Object[], List<Object>> func = new Function<Object[], List<Object>>() {

            @Override
            public List<Object> apply(Object[] args) {
                return Arrays.asList(args);
            }
        };
        for (int i = 1; i <= n; i++) {
            System.out.println(""test1ToNSources: "" + i + "" sources"");
            List<Observable<Integer>> sources = new ArrayList<>();
            List<Object> values = new ArrayList<>();
            for (int j = 0; j < i; j++) {
                sources.add(Observable.just(j));
                values.add(j);
            }

            Observable<List<Object>> result = Observable.combineLatest(sources, func);

            Observer<List<Object>> o = TestHelper.mockObserver();

            result.subscribe(o);

            verify(o).onNext(values);
            verify(o).onComplete();
            verify(o, never()).onError(any(Throwable.class));
        }
    }",loop_control
j,"{
        int n = 30;
        Function<Object[], List<Object>> func = new Function<Object[], List<Object>>() {

            @Override
            public List<Object> apply(Object[] args) {
                return Arrays.asList(args);
            }
        };
        for (int i = 1; i <= n; i++) {
            System.out.println(""test1ToNSources: "" + i + "" sources"");
            List<Observable<Integer>> sources = new ArrayList<>();
            List<Object> values = new ArrayList<>();
            for (int j = 0; j < i; j++) {
                sources.add(Observable.just(j));
                values.add(j);
            }

            Observable<List<Object>> result = Observable.combineLatest(sources, func);

            Observer<List<Object>> o = TestHelper.mockObserver();

            result.subscribe(o);

            verify(o).onNext(values);
            verify(o).onComplete();
            verify(o, never()).onError(any(Throwable.class));
        }
    }",loop_control
i,"{
        int n = 10;
        Function<Object[], List<Object>> func = new Function<Object[], List<Object>>() {

            @Override
            public List<Object> apply(Object[] args) {
                return Arrays.asList(args);
            }
        };
        for (int i = 1; i <= n; i++) {
            System.out.println(""test1ToNSourcesScheduled: "" + i + "" sources"");
            List<Observable<Integer>> sources = new ArrayList<>();
            List<Object> values = new ArrayList<>();
            for (int j = 0; j < i; j++) {
                sources.add(Observable.just(j).subscribeOn(Schedulers.io()));
                values.add(j);
            }

            Observable<List<Object>> result = Observable.combineLatest(sources, func);

            final Observer<List<Object>> o = TestHelper.mockObserver();

            final CountDownLatch cdl = new CountDownLatch(1);

            Observer<List<Object>> observer = new DefaultObserver<List<Object>>() {

                @Override
                public void onNext(List<Object> t) {
                    o.onNext(t);
                }

                @Override
                public void onError(Throwable e) {
                    o.onError(e);
                    cdl.countDown();
                }

                @Override
                public void onComplete() {
                    o.onComplete();
                    cdl.countDown();
                }
            };

            result.subscribe(observer);

            cdl.await();

            verify(o).onNext(values);
            verify(o).onComplete();
            verify(o, never()).onError(any(Throwable.class));
        }
    }",loop_control
j,"{
        int n = 10;
        Function<Object[], List<Object>> func = new Function<Object[], List<Object>>() {

            @Override
            public List<Object> apply(Object[] args) {
                return Arrays.asList(args);
            }
        };
        for (int i = 1; i <= n; i++) {
            System.out.println(""test1ToNSourcesScheduled: "" + i + "" sources"");
            List<Observable<Integer>> sources = new ArrayList<>();
            List<Object> values = new ArrayList<>();
            for (int j = 0; j < i; j++) {
                sources.add(Observable.just(j).subscribeOn(Schedulers.io()));
                values.add(j);
            }

            Observable<List<Object>> result = Observable.combineLatest(sources, func);

            final Observer<List<Object>> o = TestHelper.mockObserver();

            final CountDownLatch cdl = new CountDownLatch(1);

            Observer<List<Object>> observer = new DefaultObserver<List<Object>>() {

                @Override
                public void onNext(List<Object> t) {
                    o.onNext(t);
                }

                @Override
                public void onError(Throwable e) {
                    o.onError(e);
                    cdl.countDown();
                }

                @Override
                public void onComplete() {
                    o.onComplete();
                    cdl.countDown();
                }
            };

            result.subscribe(observer);

            cdl.await();

            verify(o).onNext(values);
            verify(o).onComplete();
            verify(o, never()).onError(any(Throwable.class));
        }
    }",loop_control
i,"{
        for (int i = 0; i < TestHelper.RACE_DEFAULT_LOOPS; i++) {
            List<Throwable> errors = TestHelper.trackPluginErrors();
            try {
                final PublishSubject<Integer> ps1 = PublishSubject.create();
                final PublishSubject<Integer> ps2 = PublishSubject.create();

                TestObserverEx<Integer> to = Observable.combineLatest(ps1, ps2, new BiFunction<Integer, Integer, Integer>() {
                    @Override
                    public Integer apply(Integer a, Integer b) throws Exception {
                        return a;
                    }
                }).to(TestHelper.<Integer>testConsumer());

                final TestException ex1 = new TestException();
                final TestException ex2 = new TestException();

                Runnable r1 = new Runnable() {
                    @Override
                    public void run() {
                        ps1.onError(ex1);
                    }
                };
                Runnable r2 = new Runnable() {
                    @Override
                    public void run() {
                        ps2.onError(ex2);
                    }
                };

                TestHelper.race(r1, r2);

                if (to.errors().size() != 0) {
                    if (to.errors().get(0) instanceof CompositeException) {
                        to.assertSubscribed()
                        .assertNotComplete()
                        .assertNoValues();

                        for (Throwable e : TestHelper.errorList(to)) {
                            assertTrue(e.toString(), e instanceof TestException);
                        }

                    } else {
                        to.assertFailure(TestException.class);
                    }
                }

                for (Throwable e : errors) {
                    assertTrue(e.toString(), e.getCause() instanceof TestException);
                }
            } finally {
                RxJavaPlugins.reset();
            }
        }
    }",loop_control
e,"{
        for (int i = 0; i < TestHelper.RACE_DEFAULT_LOOPS; i++) {
            List<Throwable> errors = TestHelper.trackPluginErrors();
            try {
                final PublishSubject<Integer> ps1 = PublishSubject.create();
                final PublishSubject<Integer> ps2 = PublishSubject.create();

                TestObserverEx<Integer> to = Observable.combineLatest(ps1, ps2, new BiFunction<Integer, Integer, Integer>() {
                    @Override
                    public Integer apply(Integer a, Integer b) throws Exception {
                        return a;
                    }
                }).to(TestHelper.<Integer>testConsumer());

                final TestException ex1 = new TestException();
                final TestException ex2 = new TestException();

                Runnable r1 = new Runnable() {
                    @Override
                    public void run() {
                        ps1.onError(ex1);
                    }
                };
                Runnable r2 = new Runnable() {
                    @Override
                    public void run() {
                        ps2.onError(ex2);
                    }
                };

                TestHelper.race(r1, r2);

                if (to.errors().size() != 0) {
                    if (to.errors().get(0) instanceof CompositeException) {
                        to.assertSubscribed()
                        .assertNotComplete()
                        .assertNoValues();

                        for (Throwable e : TestHelper.errorList(to)) {
                            assertTrue(e.toString(), e instanceof TestException);
                        }

                    } else {
                        to.assertFailure(TestException.class);
                    }
                }

                for (Throwable e : errors) {
                    assertTrue(e.toString(), e.getCause() instanceof TestException);
                }
            } finally {
                RxJavaPlugins.reset();
            }
        }
    }",iterator
i,"{
        for (int i = 0; i < TestHelper.RACE_DEFAULT_LOOPS; i++) {

            TestObserver<Integer> to = new TestObserver<>();
            PublishSubject<Integer> ps = PublishSubject.create();

            Observable.combineLatest(ps, Observable.never(), (a, b) -> a)
            .subscribe(to);

            TestHelper.race(() -> ps.onComplete(), () -> to.dispose());
        }
    }",loop_control
i,"{
        TestHelper.withErrorTracking(errors -> {
            TestException ex = new TestException();

            for (int i = 0; i < TestHelper.RACE_DEFAULT_LOOPS; i++) {

                TestObserverEx<Object[]> to = new TestObserverEx<>();
                AtomicReference<Observer<? super Object>> ref = new AtomicReference<>();
                Observable<Object> o = new Observable<Object>() {
                    @Override
                    public void subscribeActual(Observer<? super Object> observer) {
                        ref.set(observer);
                    }
                };

                Observable.combineLatestDelayError(Arrays.asList(o, Observable.never()), (a) -> a)
                .subscribe(to);

                ref.get().onSubscribe(Disposable.empty());

                TestHelper.race(() -> ref.get().onError(ex), () -> to.dispose());

                if (to.errors().isEmpty()) {
                    TestHelper.assertUndeliverable(errors, 0, TestException.class);
                }
            }
        });
    }",loop_control
value,"{
        return Observable.unsafeCreate(new ObservableSource<String>() {

            @Override
            public void subscribe(final Observer<? super String> observer) {
                CompositeDisposable parentSubscription = new CompositeDisposable();

                observer.onSubscribe(parentSubscription);

                long delay = interval;
                for (final String value : values) {
                    parentSubscription.add(innerScheduler.schedule(new Runnable() {
                        @Override
                        public void run() {
                            observer.onNext(value);
                        }
                    }
                    , delay, TimeUnit.MILLISECONDS));
                    delay += interval;
                }
                parentSubscription.add(innerScheduler.schedule(new Runnable() {
                    @Override
                    public void run() {
                            if (e == null) {
                                observer.onComplete();
                            } else {
                                observer.onError(e);
                            }
                    }
                }, delay, TimeUnit.MILLISECONDS));
            }
        });
    }",iterator
i,"{
        for (int i = 0; i < TestHelper.RACE_DEFAULT_LOOPS; i++) {
            final PublishSubject<Integer> ps1 = PublishSubject.create();
            final PublishSubject<Integer> ps2 = PublishSubject.create();

            TestObserverEx<Integer> to = Observable.ambArray(ps1, ps2).to(TestHelper.<Integer>testConsumer());

            Runnable r1 = new Runnable() {
                @Override
                public void run() {
                    ps1.onNext(1);
                }
            };
            Runnable r2 = new Runnable() {
                @Override
                public void run() {
                    ps2.onNext(1);
                }
            };

            TestHelper.race(r1, r2);

            to.assertSubscribed()
            .assertNoErrors()
            .assertNotComplete()
            .assertValueCount(1);
        }
    }",loop_control
i,"{
        for (int i = 0; i < TestHelper.RACE_DEFAULT_LOOPS; i++) {
            final PublishSubject<Integer> ps1 = PublishSubject.create();
            final PublishSubject<Integer> ps2 = PublishSubject.create();

            TestObserver<Integer> to = Observable.ambArray(ps1, ps2).test();

            Runnable r1 = new Runnable() {
                @Override
                public void run() {
                    ps1.onComplete();
                }
            };
            Runnable r2 = new Runnable() {
                @Override
                public void run() {
                    ps2.onComplete();
                }
            };

            TestHelper.race(r1, r2);

            to.assertResult();
        }
    }",loop_control
i,"{
        for (int i = 0; i < TestHelper.RACE_DEFAULT_LOOPS; i++) {
            final PublishSubject<Integer> ps1 = PublishSubject.create();
            final PublishSubject<Integer> ps2 = PublishSubject.create();

            TestObserver<Integer> to = Observable.ambArray(ps1, ps2).test();

            final Throwable ex = new TestException();

            Runnable r1 = new Runnable() {
                @Override
                public void run() {
                    ps1.onError(ex);
                }
            };
            Runnable r2 = new Runnable() {
                @Override
                public void run() {
                    ps2.onError(ex);
                }
            };

            List<Throwable> errors = TestHelper.trackPluginErrors();
            try {
                TestHelper.race(r1, r2);
            } finally {
                RxJavaPlugins.reset();
            }

            to.assertFailure(TestException.class);
            if (!errors.isEmpty()) {
                TestHelper.assertUndeliverable(errors, 0, TestException.class);
            }
        }
    }",loop_control
i,"{
        for (int i = 0; i < TestHelper.RACE_LONG_LOOPS; i++) {
            final AtomicBoolean interrupted = new AtomicBoolean();
            final CountDownLatch cdl = new CountDownLatch(1);

            Observable.ambArray(
                Observable.just(1)
                    .subscribeOn(Schedulers.single())
                    .observeOn(Schedulers.computation()),
                Observable.never()
            )
            .subscribe(new Consumer<Object>() {
                @Override
                public void accept(Object v) throws Exception {
                    interrupted.set(Thread.currentThread().isInterrupted());
                    cdl.countDown();
                }
            });

            assertTrue(cdl.await(500, TimeUnit.SECONDS));
            assertFalse(""Interrupted!"", interrupted.get());
        }
    }",loop_control
i,"{
        final TestException ex = new TestException();
        for (int i = 0; i < TestHelper.RACE_LONG_LOOPS; i++) {
            final AtomicBoolean interrupted = new AtomicBoolean();
            final CountDownLatch cdl = new CountDownLatch(1);

            Observable.ambArray(
                Observable.error(ex)
                    .subscribeOn(Schedulers.single())
                    .observeOn(Schedulers.computation()),
                Observable.never()
            )
            .subscribe(Functions.emptyConsumer(), new Consumer<Throwable>() {
                @Override
                public void accept(Throwable e) throws Exception {
                    interrupted.set(Thread.currentThread().isInterrupted());
                    cdl.countDown();
                }
            });

            assertTrue(cdl.await(500, TimeUnit.SECONDS));
            assertFalse(""Interrupted!"", interrupted.get());
        }
    }",loop_control
i,"{
        for (int i = 0; i < TestHelper.RACE_LONG_LOOPS; i++) {
            final AtomicBoolean interrupted = new AtomicBoolean();
            final CountDownLatch cdl = new CountDownLatch(1);

            Observable.ambArray(
                Observable.empty()
                    .subscribeOn(Schedulers.single())
                    .observeOn(Schedulers.computation()),
                Observable.never()
            )
            .subscribe(Functions.emptyConsumer(), Functions.emptyConsumer(), new Action() {
                @Override
                public void run() throws Exception {
                    interrupted.set(Thread.currentThread().isInterrupted());
                    cdl.countDown();
                }
            });

            assertTrue(cdl.await(500, TimeUnit.SECONDS));
            assertFalse(""Interrupted!"", interrupted.get());
        }
    }",loop_control
i,"{
        for (int i = 0; i < 10000; i++) {
            final PublishSubject<Integer> ps = PublishSubject.create();
            final MaybeSubject<Integer> cs = MaybeSubject.create();

            TestObserver<Integer> to = ps.mergeWith(cs).test();

            Runnable r1 = new Runnable() {
                @Override
                public void run() {
                    ps.onNext(1);
                    ps.onComplete();
                }
            };

            Runnable r2 = new Runnable() {
                @Override
                public void run() {
                    cs.onSuccess(1);
                }
            };

            TestHelper.race(r1, r2);

            to.assertResult(1, 1);
        }
    }",loop_control
timeout,"{
        List<Throwable> errors = TestHelper.trackPluginErrors();
        try {
            final CountDownLatch cdl1 = new CountDownLatch(1);
            final CountDownLatch cdl2 = new CountDownLatch(1);

            TestObserver<Object> to = Observable.fromRunnable(new Runnable() {
                @Override
                public void run() {
                    cdl1.countDown();
                    try {
                        cdl2.await(5, TimeUnit.SECONDS);
                    } catch (InterruptedException e) {
                        e.printStackTrace();
                        throw new TestException(e);
                    }
                }
            }).subscribeOn(Schedulers.single()).test();

            assertTrue(cdl1.await(5, TimeUnit.SECONDS));

            to.dispose();

            int timeout = 10;

            while (timeout-- > 0 && errors.isEmpty()) {
                Thread.sleep(100);
            }

            TestHelper.assertUndeliverable(errors, 0, TestException.class);
        } finally {
            RxJavaPlugins.reset();
        }
    }",loop_control
errors,"{
        List<Throwable> errors = TestHelper.trackPluginErrors();
        try {
            final CountDownLatch cdl1 = new CountDownLatch(1);
            final CountDownLatch cdl2 = new CountDownLatch(1);

            TestObserver<Object> to = Observable.fromRunnable(new Runnable() {
                @Override
                public void run() {
                    cdl1.countDown();
                    try {
                        cdl2.await(5, TimeUnit.SECONDS);
                    } catch (InterruptedException e) {
                        e.printStackTrace();
                        throw new TestException(e);
                    }
                }
            }).subscribeOn(Schedulers.single()).test();

            assertTrue(cdl1.await(5, TimeUnit.SECONDS));

            to.dispose();

            int timeout = 10;

            while (timeout-- > 0 && errors.isEmpty()) {
                Thread.sleep(100);
            }

            TestHelper.assertUndeliverable(errors, 0, TestException.class);
        } finally {
            RxJavaPlugins.reset();
        }
    }",maybe_loop_control
i,"{
        for (int i = 0; i < TestHelper.RACE_DEFAULT_LOOPS; i++) {
            TestObserver<Integer> to = new TestObserver<>();
            final ScalarDisposable<Integer> sd = new ScalarDisposable<>(to, 1);
            to.onSubscribe(sd);

            Runnable r1 = new Runnable() {
                @Override
                public void run() {
                    sd.run();
                }
            };

            Runnable r2 = new Runnable() {
                @Override
                public void run() {
                    sd.dispose();
                }
            };

            TestHelper.race(r1, r2);
        }
    }",loop_control
it,"{
        Subject<String> obs = PublishSubject.create();
        Iterator<String> it = next(obs).iterator();
        fireOnNextInNewThread(obs, ""one"");
        assertTrue(it.hasNext());
        assertEquals(""one"", it.next());

        fireOnNextInNewThread(obs, ""two"");
        assertTrue(it.hasNext());
        assertEquals(""two"", it.next());

        fireOnNextInNewThread(obs, ""three"");
        try {
            assertEquals(""three"", it.next());
        } catch (NoSuchElementException e) {
            fail(""Calling next() without hasNext() should wait for next fire"");
        }

        obs.onComplete();
        assertFalse(it.hasNext());
        try {
            it.next();
            fail(""At the end of an iterator should throw a NoSuchElementException"");
        } catch (NoSuchElementException e) {
        }

        // If the Observable is completed, hasNext always returns false and next always throw a NoSuchElementException.
        assertFalse(it.hasNext());
        try {
            it.next();
            fail(""At the end of an iterator should throw a NoSuchElementException"");
        } catch (NoSuchElementException e) {
        }
    }",iterator
it,"{
        Subject<String> obs = PublishSubject.create();
        Iterator<String> it = next(obs).iterator();
        fireOnNextInNewThread(obs, ""one"");
        assertTrue(it.hasNext());
        assertEquals(""one"", it.next());

        fireOnErrorInNewThread(obs);
        try {
            it.hasNext();
            fail(""Expected an TestException"");
        } catch (TestException e) {
        }

        assertErrorAfterObservableFail(it);
    }",iterator
it,"{
        Observable<String> obs = Observable.<String> empty().observeOn(Schedulers.newThread());
        Iterator<String> it = next(obs).iterator();

        assertFalse(it.hasNext());
        try {
            it.next();
            fail(""At the end of an iterator should throw a NoSuchElementException"");
        } catch (NoSuchElementException e) {
        }

        // If the Observable is completed, hasNext always returns false and next always throw a NoSuchElementException.
        assertFalse(it.hasNext());
        try {
            it.next();
            fail(""At the end of an iterator should throw a NoSuchElementException"");
        } catch (NoSuchElementException e) {
        }
    }",iterator
it,"{
        Subject<String> obs = PublishSubject.create();
        Iterator<String> it = next(obs).iterator();

        obs.onError(new TestException());
        try {
            it.hasNext();
            fail(""Expected an TestException"");
        } catch (TestException e) {
            // successful
        }

        assertErrorAfterObservableFail(it);
    }",iterator
it,"{
        Subject<String> obs = PublishSubject.create();
        Iterator<String> it = next(obs).iterator();

        fireOnErrorInNewThread(obs);

        try {
            it.hasNext();
            fail(""Expected an TestException"");
        } catch (TestException e) {
            // successful
        }

        assertErrorAfterObservableFail(it);
    }",iterator
it,"{
        Subject<String> obs = PublishSubject.create();
        Iterator<String> it = next(obs).iterator();
        fireOnNextInNewThread(obs, ""one"");
        assertEquals(""one"", it.next());

        fireOnNextInNewThread(obs, ""two"");
        assertEquals(""two"", it.next());

        obs.onComplete();
        try {
            it.next();
            fail(""At the end of an iterator should throw a NoSuchElementException"");
        } catch (NoSuchElementException e) {
        }
    }",iterator
it,"{
        Subject<String> obs = PublishSubject.create();
        Iterator<String> it = next(obs).iterator();
        fireOnNextInNewThread(obs, ""one"");
        assertTrue(it.hasNext());
        assertTrue(it.hasNext());
        assertTrue(it.hasNext());
        assertTrue(it.hasNext());
        assertEquals(""one"", it.next());

        obs.onComplete();
        try {
            it.next();
            fail(""At the end of an iterator should throw a NoSuchElementException"");
        } catch (NoSuchElementException e) {
        }
    }",iterator
running,"{
        int repeat = 0;
        for (;;) {
            final SerialDisposable task = new SerialDisposable();
            try {
                final CountDownLatch finished = new CountDownLatch(1);
                final int COUNT = 30;
                final CountDownLatch timeHasPassed = new CountDownLatch(COUNT);
                final AtomicBoolean running = new AtomicBoolean(true);
                final AtomicInteger count = new AtomicInteger(0);
                final Observable<Integer> obs = Observable.unsafeCreate(new ObservableSource<Integer>() {

                    @Override
                    public void subscribe(final Observer<? super Integer> o) {
                        o.onSubscribe(Disposable.empty());
                        task.replace(Schedulers.single().scheduleDirect(new Runnable() {

                            @Override
                            public void run() {
                                try {
                                    while (running.get() && !task.isDisposed()) {
                                        o.onNext(count.incrementAndGet());
                                        timeHasPassed.countDown();
                                    }
                                    o.onComplete();
                                } catch (Throwable e) {
                                    o.onError(e);
                                } finally {
                                    finished.countDown();
                                }
                            }
                        }));
                    }

                });

                Iterator<Integer> it = next(obs).iterator();

                assertTrue(it.hasNext());
                int a = it.next();
                assertTrue(it.hasNext());
                int b = it.next();
                // we should have a different value
                assertTrue(""a and b should be different"", a != b);

                // wait for some time (if times out we are blocked somewhere so fail ... set very high for very slow, constrained machines)
                timeHasPassed.await(8000, TimeUnit.MILLISECONDS);

                assertTrue(it.hasNext());
                int c = it.next();

                assertTrue(""c should not just be the next in sequence"", c != (b + 1));
                assertTrue(""expected that c ["" + c + ""] is higher than or equal to "" + COUNT, c >= COUNT);

                assertTrue(it.hasNext());
                int d = it.next();
                assertTrue(d > c);

                // shut down the thread
                running.set(false);

                finished.await();

                assertFalse(it.hasNext());

                System.out.println(""a: "" + a + "" b: "" + b + "" c: "" + c);
                break;
            } catch (AssertionError ex) {
                if (++repeat == 3) {
                    throw ex;
                }
                Thread.sleep((int)(1000 * Math.pow(2, repeat - 1)));
            } finally {
                task.dispose();
            }
        }
    }",maybe_loop_control
task,"{
        int repeat = 0;
        for (;;) {
            final SerialDisposable task = new SerialDisposable();
            try {
                final CountDownLatch finished = new CountDownLatch(1);
                final int COUNT = 30;
                final CountDownLatch timeHasPassed = new CountDownLatch(COUNT);
                final AtomicBoolean running = new AtomicBoolean(true);
                final AtomicInteger count = new AtomicInteger(0);
                final Observable<Integer> obs = Observable.unsafeCreate(new ObservableSource<Integer>() {

                    @Override
                    public void subscribe(final Observer<? super Integer> o) {
                        o.onSubscribe(Disposable.empty());
                        task.replace(Schedulers.single().scheduleDirect(new Runnable() {

                            @Override
                            public void run() {
                                try {
                                    while (running.get() && !task.isDisposed()) {
                                        o.onNext(count.incrementAndGet());
                                        timeHasPassed.countDown();
                                    }
                                    o.onComplete();
                                } catch (Throwable e) {
                                    o.onError(e);
                                } finally {
                                    finished.countDown();
                                }
                            }
                        }));
                    }

                });

                Iterator<Integer> it = next(obs).iterator();

                assertTrue(it.hasNext());
                int a = it.next();
                assertTrue(it.hasNext());
                int b = it.next();
                // we should have a different value
                assertTrue(""a and b should be different"", a != b);

                // wait for some time (if times out we are blocked somewhere so fail ... set very high for very slow, constrained machines)
                timeHasPassed.await(8000, TimeUnit.MILLISECONDS);

                assertTrue(it.hasNext());
                int c = it.next();

                assertTrue(""c should not just be the next in sequence"", c != (b + 1));
                assertTrue(""expected that c ["" + c + ""] is higher than or equal to "" + COUNT, c >= COUNT);

                assertTrue(it.hasNext());
                int d = it.next();
                assertTrue(d > c);

                // shut down the thread
                running.set(false);

                finished.await();

                assertFalse(it.hasNext());

                System.out.println(""a: "" + a + "" b: "" + b + "" c: "" + c);
                break;
            } catch (AssertionError ex) {
                if (++repeat == 3) {
                    throw ex;
                }
                Thread.sleep((int)(1000 * Math.pow(2, repeat - 1)));
            } finally {
                task.dispose();
            }
        }
    }",maybe_loop_control
it,"{
        int repeat = 0;
        for (;;) {
            final SerialDisposable task = new SerialDisposable();
            try {
                final CountDownLatch finished = new CountDownLatch(1);
                final int COUNT = 30;
                final CountDownLatch timeHasPassed = new CountDownLatch(COUNT);
                final AtomicBoolean running = new AtomicBoolean(true);
                final AtomicInteger count = new AtomicInteger(0);
                final Observable<Integer> obs = Observable.unsafeCreate(new ObservableSource<Integer>() {

                    @Override
                    public void subscribe(final Observer<? super Integer> o) {
                        o.onSubscribe(Disposable.empty());
                        task.replace(Schedulers.single().scheduleDirect(new Runnable() {

                            @Override
                            public void run() {
                                try {
                                    while (running.get() && !task.isDisposed()) {
                                        o.onNext(count.incrementAndGet());
                                        timeHasPassed.countDown();
                                    }
                                    o.onComplete();
                                } catch (Throwable e) {
                                    o.onError(e);
                                } finally {
                                    finished.countDown();
                                }
                            }
                        }));
                    }

                });

                Iterator<Integer> it = next(obs).iterator();

                assertTrue(it.hasNext());
                int a = it.next();
                assertTrue(it.hasNext());
                int b = it.next();
                // we should have a different value
                assertTrue(""a and b should be different"", a != b);

                // wait for some time (if times out we are blocked somewhere so fail ... set very high for very slow, constrained machines)
                timeHasPassed.await(8000, TimeUnit.MILLISECONDS);

                assertTrue(it.hasNext());
                int c = it.next();

                assertTrue(""c should not just be the next in sequence"", c != (b + 1));
                assertTrue(""expected that c ["" + c + ""] is higher than or equal to "" + COUNT, c >= COUNT);

                assertTrue(it.hasNext());
                int d = it.next();
                assertTrue(d > c);

                // shut down the thread
                running.set(false);

                finished.await();

                assertFalse(it.hasNext());

                System.out.println(""a: "" + a + "" b: "" + b + "" c: "" + c);
                break;
            } catch (AssertionError ex) {
                if (++repeat == 3) {
                    throw ex;
                }
                Thread.sleep((int)(1000 * Math.pow(2, repeat - 1)));
            } finally {
                task.dispose();
            }
        }
    }",iterator
repeat,"{
        int repeat = 0;
        for (;;) {
            final SerialDisposable task = new SerialDisposable();
            try {
                final CountDownLatch finished = new CountDownLatch(1);
                final int COUNT = 30;
                final CountDownLatch timeHasPassed = new CountDownLatch(COUNT);
                final AtomicBoolean running = new AtomicBoolean(true);
                final AtomicInteger count = new AtomicInteger(0);
                final Observable<Integer> obs = Observable.unsafeCreate(new ObservableSource<Integer>() {

                    @Override
                    public void subscribe(final Observer<? super Integer> o) {
                        o.onSubscribe(Disposable.empty());
                        task.replace(Schedulers.single().scheduleDirect(new Runnable() {

                            @Override
                            public void run() {
                                try {
                                    while (running.get() && !task.isDisposed()) {
                                        o.onNext(count.incrementAndGet());
                                        timeHasPassed.countDown();
                                    }
                                    o.onComplete();
                                } catch (Throwable e) {
                                    o.onError(e);
                                } finally {
                                    finished.countDown();
                                }
                            }
                        }));
                    }

                });

                Iterator<Integer> it = next(obs).iterator();

                assertTrue(it.hasNext());
                int a = it.next();
                assertTrue(it.hasNext());
                int b = it.next();
                // we should have a different value
                assertTrue(""a and b should be different"", a != b);

                // wait for some time (if times out we are blocked somewhere so fail ... set very high for very slow, constrained machines)
                timeHasPassed.await(8000, TimeUnit.MILLISECONDS);

                assertTrue(it.hasNext());
                int c = it.next();

                assertTrue(""c should not just be the next in sequence"", c != (b + 1));
                assertTrue(""expected that c ["" + c + ""] is higher than or equal to "" + COUNT, c >= COUNT);

                assertTrue(it.hasNext());
                int d = it.next();
                assertTrue(d > c);

                // shut down the thread
                running.set(false);

                finished.await();

                assertFalse(it.hasNext());

                System.out.println(""a: "" + a + "" b: "" + b + "" c: "" + c);
                break;
            } catch (AssertionError ex) {
                if (++repeat == 3) {
                    throw ex;
                }
                Thread.sleep((int)(1000 * Math.pow(2, repeat - 1)));
            } finally {
                task.dispose();
            }
        }
    }",break_loop_control
j,"{
        Observable<Long> o = Observable.interval(250, TimeUnit.MILLISECONDS);
        PublishSubject<Integer> terminal = PublishSubject.create();
        Observable<Long> source = o.takeUntil(terminal);

        Iterable<Long> iter = source.blockingNext();

        for (int j = 0; j < 3; j++) {
            BlockingObservableNext.NextIterator<Long> it = (BlockingObservableNext.NextIterator<Long>)iter.iterator();

            for (long i = 0; i < 10; i++) {
                Assert.assertTrue(it.hasNext());
                Assert.assertEquals(j + ""th iteration next"", Long.valueOf(i), it.next());
            }
            terminal.onNext(1);
        }
    }",loop_control
i,"{
        Observable<Long> o = Observable.interval(250, TimeUnit.MILLISECONDS);
        PublishSubject<Integer> terminal = PublishSubject.create();
        Observable<Long> source = o.takeUntil(terminal);

        Iterable<Long> iter = source.blockingNext();

        for (int j = 0; j < 3; j++) {
            BlockingObservableNext.NextIterator<Long> it = (BlockingObservableNext.NextIterator<Long>)iter.iterator();

            for (long i = 0; i < 10; i++) {
                Assert.assertTrue(it.hasNext());
                Assert.assertEquals(j + ""th iteration next"", Long.valueOf(i), it.next());
            }
            terminal.onNext(1);
        }
    }",loop_control
it,"{
        Iterator<Object> it = Observable.never().blockingNext().iterator();

        try {
            Thread.currentThread().interrupt();
            it.next();
        } catch (RuntimeException ex) {
            assertTrue(ex.toString(), ex.getCause() instanceof InterruptedException);
        }
    }",iterator
i,"{
        for (int i = 0; i < TestHelper.RACE_DEFAULT_LOOPS; i++) {
            final TestScheduler scheduler = new TestScheduler();

            final PublishSubject<Integer> ps = PublishSubject.create();

            TestObserver<Integer> to = ps.sample(1, TimeUnit.SECONDS, scheduler, true)
            .test();

            ps.onNext(1);

            Runnable r1 = new Runnable() {
                @Override
                public void run() {
                    ps.onComplete();
                }
            };

            Runnable r2 = new Runnable() {
                @Override
                public void run() {
                    scheduler.advanceTimeBy(1, TimeUnit.SECONDS);
                }
            };

            TestHelper.race(r1, r2);

            to.assertResult(1);
        }
    }",loop_control
i,"{
        for (int i = 0; i < TestHelper.RACE_DEFAULT_LOOPS; i++) {
            final PublishSubject<Integer> ps = PublishSubject.create();
            final PublishSubject<Integer> sampler = PublishSubject.create();

            TestObserver<Integer> to = ps.sample(sampler, true)
            .test();

            ps.onNext(1);

            Runnable r1 = new Runnable() {
                @Override
                public void run() {
                    ps.onComplete();
                }
            };

            Runnable r2 = new Runnable() {
                @Override
                public void run() {
                    sampler.onNext(1);
                }
            };

            TestHelper.race(r1, r2);

            to.assertResult(1);
        }
    }",loop_control
i,"{
        for (int i = 0; i < TestHelper.RACE_DEFAULT_LOOPS; i++) {
            final PublishSubject<Integer> ps = PublishSubject.create();
            final PublishSubject<Integer> sampler = PublishSubject.create();

            TestObserver<Integer> to = ps.sample(sampler, true).test();

            ps.onNext(1);

            Runnable r1 = new Runnable() {
                @Override
                public void run() {
                    ps.onComplete();
                }
            };

            Runnable r2 = new Runnable() {
                @Override
                public void run() {
                    sampler.onComplete();
                }
            };

            TestHelper.race(r1, r2);

            to.assertResult(1);
        }
    }",loop_control
i,"{
        for (int i = 0; i < TestHelper.RACE_DEFAULT_LOOPS; i++) {
            final TestScheduler sch = new TestScheduler();

            final PublishSubject<Integer> ps = PublishSubject.create();

            TestObserverEx<Integer> to = ps.timeout(1, TimeUnit.SECONDS, sch).to(TestHelper.<Integer>testConsumer());

            Runnable r1 = new Runnable() {
                @Override
                public void run() {
                    ps.onNext(1);
                }
            };

            Runnable r2 = new Runnable() {
                @Override
                public void run() {
                    sch.advanceTimeBy(1, TimeUnit.SECONDS);
                }
            };

            TestHelper.race(r1, r2);

            if (to.values().size() != 0) {
                if (to.errors().size() != 0) {
                    to.assertFailure(TimeoutException.class, 1);
                    to.assertErrorMessage(timeoutMessage(1, TimeUnit.SECONDS));
                } else {
                    to.assertValuesOnly(1);
                }
            } else {
                to.assertFailure(TimeoutException.class);
                to.assertErrorMessage(timeoutMessage(1, TimeUnit.SECONDS));
            }
        }
    }",loop_control
i,"{
        for (int i = 0; i < TestHelper.RACE_DEFAULT_LOOPS; i++) {
            final TestScheduler sch = new TestScheduler();

            final PublishSubject<Integer> ps = PublishSubject.create();

            TestObserverEx<Integer> to = ps.timeout(1, TimeUnit.SECONDS, sch, Observable.just(2)).to(TestHelper.<Integer>testConsumer());

            Runnable r1 = new Runnable() {
                @Override
                public void run() {
                    ps.onNext(1);
                }
            };

            Runnable r2 = new Runnable() {
                @Override
                public void run() {
                    sch.advanceTimeBy(1, TimeUnit.SECONDS);
                }
            };

            TestHelper.race(r1, r2);

            if (to.isTerminated()) {
                int c = to.values().size();
                if (c == 1) {
                    int v = to.values().get(0);
                    assertTrue("""" + v, v == 1 || v == 2);
                } else {
                    to.assertResult(1, 2);
                }
            } else {
                to.assertValuesOnly(1);
            }
        }
    }",loop_control
i,"{
        for (String val : new String[] { ""1"" /*, null*/ }) {
            int n = 35;
            for (int i = 0; i < n; i++) {
                List<Observable<?>> sources = new ArrayList<>();
                List<String> expected = new ArrayList<>();
                expected.add(val);

                for (int j = 0; j < i; j++) {
                    sources.add(Observable.just(val));
                    expected.add(String.valueOf(val));
                }

                TestObserver<String> to = new TestObserver<>();

                PublishSubject<String> main = PublishSubject.create();

                main.withLatestFrom(sources, toArray).subscribe(to);

                to.assertNoValues();

                main.onNext(val);
                main.onComplete();

                to.assertValue(expected.toString());
                to.assertNoErrors();
                to.assertComplete();
            }
        }
    }",loop_control
j,"{
        for (String val : new String[] { ""1"" /*, null*/ }) {
            int n = 35;
            for (int i = 0; i < n; i++) {
                List<Observable<?>> sources = new ArrayList<>();
                List<String> expected = new ArrayList<>();
                expected.add(val);

                for (int j = 0; j < i; j++) {
                    sources.add(Observable.just(val));
                    expected.add(String.valueOf(val));
                }

                TestObserver<String> to = new TestObserver<>();

                PublishSubject<String> main = PublishSubject.create();

                main.withLatestFrom(sources, toArray).subscribe(to);

                to.assertNoValues();

                main.onNext(val);
                main.onComplete();

                to.assertValue(expected.toString());
                to.assertNoErrors();
                to.assertComplete();
            }
        }
    }",loop_control
val,"{
        for (String val : new String[] { ""1"" /*, null*/ }) {
            int n = 35;
            for (int i = 0; i < n; i++) {
                List<Observable<?>> sources = new ArrayList<>();
                List<String> expected = new ArrayList<>();
                expected.add(val);

                for (int j = 0; j < i; j++) {
                    sources.add(Observable.just(val));
                    expected.add(String.valueOf(val));
                }

                TestObserver<String> to = new TestObserver<>();

                PublishSubject<String> main = PublishSubject.create();

                main.withLatestFrom(sources, toArray).subscribe(to);

                to.assertNoValues();

                main.onNext(val);
                main.onComplete();

                to.assertValue(expected.toString());
                to.assertNoErrors();
                to.assertComplete();
            }
        }
    }",iterator
i,"{
        // Flaky
        for (int i = 0; i < 10; i++) {
            try {
                refCountAsyncActual();
                return;
            } catch (AssertionError ex) {
                if (i == 9) {
                    throw ex;
                }
                Thread.sleep((int)(200 * (Math.random() * 10 + 1)));
            }
        }
    }",loop_control
i,"{
        final AtomicInteger subscribeCount = new AtomicInteger();
        final AtomicInteger unsubscribeCount = new AtomicInteger();
        Observable<Long> r = Observable.interval(0, 1, TimeUnit.MILLISECONDS)
                .doOnSubscribe(new Consumer<Disposable>() {
                    @Override
                    public void accept(Disposable d) {
                            System.out.println(""******************************* Subscribe received"");
                            // when we are subscribed
                            subscribeCount.incrementAndGet();
                    }
                })
                .doOnDispose(new Action() {
                    @Override
                    public void run() {
                            System.out.println(""******************************* Unsubscribe received"");
                            // when we are unsubscribed
                            unsubscribeCount.incrementAndGet();
                    }
                })
                .publish().refCount();

        for (int i = 0; i < 10; i++) {
            TestObserver<Long> to1 = new TestObserver<>();
            TestObserver<Long> to2 = new TestObserver<>();
            r.subscribe(to1);
            r.subscribe(to2);
            try {
                Thread.sleep(50);
            } catch (InterruptedException e) {
            }
            to1.dispose();
            to2.dispose();
            to1.assertNoErrors();
            to2.assertNoErrors();
            assertTrue(to1.values().size() > 0);
            assertTrue(to2.values().size() > 0);
        }

        assertEquals(10, subscribeCount.get());
        assertEquals(10, unsubscribeCount.get());
    }",loop_control
i,"{
        for (int i = 0; i < 100; i++) {
            connectUnsubscribeRaceCondition();
        }
    }",loop_control
subUnsubCount,"{
        final AtomicInteger subUnsubCount = new AtomicInteger();
        Observable<Long> o = synchronousInterval()
                .doOnDispose(new Action() {
                    @Override
                    public void run() {
                            System.out.println(""******************************* Unsubscribe received"");
                            // when we are unsubscribed
                            subUnsubCount.decrementAndGet();
                    }
                })
                .doOnSubscribe(new Consumer<Disposable>() {
                    @Override
                    public void accept(Disposable d) {
                            System.out.println(""******************************* SUBSCRIBE received"");
                            subUnsubCount.incrementAndGet();
                    }
                });

        TestObserverEx<Long> observer = new TestObserverEx<>();

        o.publish().refCount().subscribeOn(Schedulers.computation()).subscribe(observer);
        System.out.println(""send unsubscribe"");
        // now immediately unsubscribe while subscribeOn is racing to subscribe
        observer.dispose();

        // this generally will mean it won't even subscribe as it is already unsubscribed by the time connect() gets scheduled
        // give time to the counter to update
        Thread.sleep(10);

        // make sure we wait a bit in case the counter is still nonzero
        int counter = 200;
        while (subUnsubCount.get() != 0 && counter-- != 0) {
            Thread.sleep(10);
        }
        // either we subscribed and then unsubscribed, or we didn't ever even subscribe
        assertEquals(0, subUnsubCount.get());

        System.out.println(""DONE sending unsubscribe ... now waiting"");
        System.out.println(""Errors: "" + observer.errors());
        if (observer.errors().size() > 0) {
            observer.errors().get(0).printStackTrace();
        }
        observer.assertNoErrors();
    }",maybe_loop_control
counter,"{
        final AtomicInteger subUnsubCount = new AtomicInteger();
        Observable<Long> o = synchronousInterval()
                .doOnDispose(new Action() {
                    @Override
                    public void run() {
                            System.out.println(""******************************* Unsubscribe received"");
                            // when we are unsubscribed
                            subUnsubCount.decrementAndGet();
                    }
                })
                .doOnSubscribe(new Consumer<Disposable>() {
                    @Override
                    public void accept(Disposable d) {
                            System.out.println(""******************************* SUBSCRIBE received"");
                            subUnsubCount.incrementAndGet();
                    }
                });

        TestObserverEx<Long> observer = new TestObserverEx<>();

        o.publish().refCount().subscribeOn(Schedulers.computation()).subscribe(observer);
        System.out.println(""send unsubscribe"");
        // now immediately unsubscribe while subscribeOn is racing to subscribe
        observer.dispose();

        // this generally will mean it won't even subscribe as it is already unsubscribed by the time connect() gets scheduled
        // give time to the counter to update
        Thread.sleep(10);

        // make sure we wait a bit in case the counter is still nonzero
        int counter = 200;
        while (subUnsubCount.get() != 0 && counter-- != 0) {
            Thread.sleep(10);
        }
        // either we subscribed and then unsubscribed, or we didn't ever even subscribe
        assertEquals(0, subUnsubCount.get());

        System.out.println(""DONE sending unsubscribe ... now waiting"");
        System.out.println(""Errors: "" + observer.errors());
        if (observer.errors().size() > 0) {
            observer.errors().get(0).printStackTrace();
        }
        observer.assertNoErrors();
    }",loop_control
cancel,"{
        return Observable.unsafeCreate(new ObservableSource<Long>() {
            @Override
            public void subscribe(Observer<? super Long> observer) {
                final AtomicBoolean cancel = new AtomicBoolean();
                observer.onSubscribe(Disposable.fromRunnable(new Runnable() {
                    @Override
                    public void run() {
                        cancel.set(true);
                    }
                }));
                for (;;) {
                    if (cancel.get()) {
                        break;
                    }
                    try {
                        Thread.sleep(100);
                    } catch (InterruptedException e) {
                    }
                    observer.onNext(1L);
                }
            }
        });
    }",break_loop_control
emitter,"{
        BehaviorSubject<Integer> bs = BehaviorSubject.createDefault(1);

        Observable<Integer> o = bs
        .replay(1)
        .refCount();

        o.subscribe();

        final AtomicBoolean interrupted = new AtomicBoolean();

        o.switchMap(new Function<Integer, ObservableSource<? extends Object>>() {
            @Override
            public ObservableSource<? extends Object> apply(Integer v) throws Exception {
                return Observable.create(new ObservableOnSubscribe<Object>() {
                    @Override
                    public void subscribe(ObservableEmitter<Object> emitter) throws Exception {
                        while (!emitter.isDisposed()) {
                            Thread.sleep(100);
                        }
                        interrupted.set(true);
                    }
                });
            }
        })
        .take(500, TimeUnit.MILLISECONDS)
        .test()
        .awaitDone(5, TimeUnit.SECONDS)
        .assertResult();

        assertTrue(interrupted.get());
    }",maybe_loop_control
i,"{
        final int[] subscriptions = { 0 };

        Observable<Integer> source = Observable.range(1, 5)
        .doOnSubscribe(new Consumer<Disposable>() {
            @Override
            public void accept(Disposable d) throws Exception {
                subscriptions[0]++;
            }
        })
        .publish()
        .refCount(2);

        for (int i = 0; i < 3; i++) {
            TestObserver<Integer> to1 = source.test();

            to1.withTag(""to1 "" + i);
            to1.assertEmpty();

            TestObserver<Integer> to2 = source.test();

            to2.withTag(""to2 "" + i);

            to1.assertResult(1, 2, 3, 4, 5);
            to2.assertResult(1, 2, 3, 4, 5);
        }

        assertEquals(3, subscriptions[0]);
    }",loop_control
i,"{
        PublishSubject<Integer> ps = PublishSubject.create();

        Observable<Integer> source = ps
        .publish()
        .refCount(1);

        TestObserver<Integer> to1 = source.test();

        assertTrue(ps.hasObservers());

        for (int i = 0; i < 3; i++) {
            TestObserver<Integer> to2 = source.test();
            to1.dispose();
            to1 = to2;
        }

        to1.dispose();

        assertFalse(ps.hasObservers());
    }",loop_control
i,"{
        for (int i = 0; i < 1000; i++) {

            final Observable<Integer> source = Observable.range(1, 5)
                    .replay()
                    .refCount(1)
                    ;

            final TestObserver<Integer> to1 = source.test();

            final TestObserver<Integer> to2 = new TestObserver<>();

            Runnable r1 = new Runnable() {
                @Override
                public void run() {
                    to1.dispose();
                }
            };

            Runnable r2 = new Runnable() {
                @Override
                public void run() {
                    source.subscribe(to2);
                }
            };

            TestHelper.race(r1, r2, Schedulers.single());

            to2
            .withTag(""Round: "" + i)
            .assertResult(1, 2, 3, 4, 5);
        }
    }",loop_control
i,"{
        for (int i = 0; i < TestHelper.RACE_LONG_LOOPS; i++) {
            Observable<Integer> observable = Observable.just(1).replay(1).refCount();

            TestObserver<Integer> observer1 = observable
                    .subscribeOn(Schedulers.io())
                    .test();

            TestObserver<Integer> observer2 = observable
                    .subscribeOn(Schedulers.io())
                    .test();

            observer1
            .withTag("""" + i)
            .awaitDone(5, TimeUnit.SECONDS)
            .assertResult(1);

            observer2
            .withTag("""" + i)
            .awaitDone(5, TimeUnit.SECONDS)
            .assertResult(1);
        }
    }",loop_control
i,"{
        for (int i = 0; i < TestHelper.RACE_LONG_LOOPS; i++) {
            Observable<Integer> observable = Observable.just(1).publish().refCount();

            TestObserver<Integer> observer1 = observable
                    .subscribeOn(Schedulers.io())
                    .test();

            TestObserver<Integer> observer2 = observable
                    .subscribeOn(Schedulers.io())
                    .test();

            observer1
            .withTag(""observer1 "" + i)
            .awaitDone(5, TimeUnit.SECONDS)
            .assertNoErrors()
            .assertComplete();

            observer2
            .withTag(""observer2 "" + i)
            .awaitDone(5, TimeUnit.SECONDS)
            .assertNoErrors()
            .assertComplete();
        }
    }",loop_control
timeout,"{
        List<Throwable> errors = TestHelper.trackPluginErrors();
        try {
            final CountDownLatch cdl1 = new CountDownLatch(1);
            final CountDownLatch cdl2 = new CountDownLatch(1);

            TestObserver<Object> to = Observable.fromAction(new Action() {
                @Override
                public void run() throws Exception {
                    cdl1.countDown();
                    cdl2.await(5, TimeUnit.SECONDS);
                }
            }).subscribeOn(Schedulers.single()).test();

            assertTrue(cdl1.await(5, TimeUnit.SECONDS));

            to.dispose();

            int timeout = 10;

            while (timeout-- > 0 && errors.isEmpty()) {
                Thread.sleep(100);
            }

            TestHelper.assertUndeliverable(errors, 0, InterruptedException.class);
        } finally {
            RxJavaPlugins.reset();
        }
    }",loop_control
errors,"{
        List<Throwable> errors = TestHelper.trackPluginErrors();
        try {
            final CountDownLatch cdl1 = new CountDownLatch(1);
            final CountDownLatch cdl2 = new CountDownLatch(1);

            TestObserver<Object> to = Observable.fromAction(new Action() {
                @Override
                public void run() throws Exception {
                    cdl1.countDown();
                    cdl2.await(5, TimeUnit.SECONDS);
                }
            }).subscribeOn(Schedulers.single()).test();

            assertTrue(cdl1.await(5, TimeUnit.SECONDS));

            to.dispose();

            int timeout = 10;

            while (timeout-- > 0 && errors.isEmpty()) {
                Thread.sleep(100);
            }

            TestHelper.assertUndeliverable(errors, 0, InterruptedException.class);
        } finally {
            RxJavaPlugins.reset();
        }
    }",maybe_loop_control
i,"{
        PublishSubject<Integer> source = PublishSubject.create();
        final List<PublishSubject<Integer>> delays = new ArrayList<>();
        final int n = 10;
        for (int i = 0; i < n; i++) {
            PublishSubject<Integer> delay = PublishSubject.create();
            delays.add(delay);
        }

        Function<Integer, Observable<Integer>> delayFunc = new Function<Integer, Observable<Integer>>() {
            @Override
            public Observable<Integer> apply(Integer t1) {
                return delays.get(t1);
            }
        };

        Observer<Object> o = TestHelper.mockObserver();
        InOrder inOrder = inOrder(o);

        source.delay(delayFunc).subscribe(o);

        for (int i = 0; i < n; i++) {
            source.onNext(i);
            delays.get(i).onNext(i);
            inOrder.verify(o).onNext(i);
        }
        source.onComplete();

        inOrder.verify(o).onComplete();
        inOrder.verifyNoMoreInteractions();

        verify(o, never()).onError(any(Throwable.class));
    }",loop_control
i,"{
        int n = 3;

        PublishSubject<Integer> source = PublishSubject.create();
        final List<PublishSubject<Integer>> subjects = new ArrayList<>();
        for (int i = 0; i < n; i++) {
            subjects.add(PublishSubject.<Integer> create());
        }

        Observable<Integer> result = source.delay(new Function<Integer, Observable<Integer>>() {

            @Override
            public Observable<Integer> apply(Integer t1) {
                return subjects.get(t1);
            }
        });

        Observer<Object> o = TestHelper.mockObserver();
        InOrder inOrder = inOrder(o);

        result.subscribe(o);

        for (int i = 0; i < n; i++) {
            source.onNext(i);
        }
        source.onComplete();

        inOrder.verify(o, never()).onNext(anyInt());
        inOrder.verify(o, never()).onComplete();

        for (int i = n - 1; i >= 0; i--) {
            subjects.get(i).onComplete();
            inOrder.verify(o).onNext(i);
        }

        inOrder.verify(o).onComplete();

        verify(o, never()).onError(any(Throwable.class));
    }",loop_control
i,"{
        for (int i = 0; i < 10000; i++) {
            final PublishSubject<Integer> ps = PublishSubject.create();
            final SingleSubject<Integer> cs = SingleSubject.create();

            TestObserver<Integer> to = ps.mergeWith(cs).test();

            Runnable r1 = new Runnable() {
                @Override
                public void run() {
                    ps.onNext(1);
                    ps.onComplete();
                }
            };

            Runnable r2 = new Runnable() {
                @Override
                public void run() {
                    cs.onSuccess(1);
                }
            };

            TestHelper.race(r1, r2);

            to.assertResult(1, 1);
        }
    }",loop_control
it,"{
        Observable<String> obs = Observable.just(""one"", ""two"", ""three"");

        Iterator<String> it = obs.blockingIterable().iterator();

        assertTrue(it.hasNext());
        assertEquals(""one"", it.next());

        assertTrue(it.hasNext());
        assertEquals(""two"", it.next());

        assertTrue(it.hasNext());
        assertEquals(""three"", it.next());

        assertFalse(it.hasNext());

    }",iterator
it,"{
        Observable<String> obs = Observable.unsafeCreate(new ObservableSource<String>() {

            @Override
            public void subscribe(Observer<? super String> observer) {
                observer.onSubscribe(Disposable.empty());
                observer.onNext(""one"");
                observer.onError(new TestException());
            }
        });

        Iterator<String> it = obs.blockingIterable().iterator();

        assertTrue(it.hasNext());
        assertEquals(""one"", it.next());

        assertTrue(it.hasNext());
        it.next();
    }",iterator
it,"{
        BlockingObservableIterator<Integer> it = new BlockingObservableIterator<>(128);

        assertFalse(it.isDisposed());

        it.dispose();

        assertTrue(it.isDisposed());
    }",iterator
it,"{
        BlockingObservableIterator<Integer> it = new BlockingObservableIterator<>(128);

        try {
            Thread.currentThread().interrupt();

            it.hasNext();
        } catch (RuntimeException ex) {
            assertTrue(ex.toString(), ex.getCause() instanceof InterruptedException);
        }
    }",iterator
it,"{
        BlockingObservableIterator<Integer> it = new BlockingObservableIterator<>(128);
        it.onComplete();
        it.next();
    }",iterator
it,"{
        BlockingObservableIterator<Integer> it = new BlockingObservableIterator<>(128);
        it.remove();
    }",iterator
it,"{
        Iterator<Integer> it = PublishSubject.<Integer>create()
                .blockingIterable().iterator();
        ((Disposable)it).dispose();
        assertFalse(it.hasNext());
        it.next();
    }",iterator
it,"{
        final Iterator<Integer> it = PublishSubject.<Integer>create()
                .blockingIterable().iterator();

        Schedulers.single().scheduleDirect(new Runnable() {
            @Override
            public void run() {
                ((Disposable)it).dispose();
            }
        }, 1, TimeUnit.SECONDS);

        assertFalse(it.hasNext());
    }",iterator
it,"{
        Iterator<Object> it = Observable.error(new TestException()).blockingIterable().iterator();

        ((Disposable)it).dispose();

        it.hasNext();
    }",iterator
to,"{
        final TestObserver<Object> to = new TestObserver<>();
        final Observer[] s = { null };

        Schedulers.single().scheduleDirect(new Runnable() {
            @SuppressWarnings(""unchecked"")
            @Override
            public void run() {
                to.dispose();
                s[0].onNext(1);
            }
        }, 200, TimeUnit.MILLISECONDS);

        new Observable<Integer>() {
            @Override
            protected void subscribeActual(Observer<? super Integer> observer) {
                observer.onSubscribe(Disposable.empty());
                s[0] = observer;
            }
        }.blockingSubscribe(to);

        while (!to.isDisposed()) {
            Thread.sleep(100);
        }

        to.assertEmpty();
    }",maybe_loop_control
i,"{
        for (int i = 0; i < 1000; i++) {
            final PublishSubject<Integer> ps = PublishSubject.create();
            final CompletableSubject cs = CompletableSubject.create();

            TestObserver<Integer> to = ps.mergeWith(cs).test();

            Runnable r1 = new Runnable() {
                @Override
                public void run() {
                    ps.onNext(1);
                    ps.onComplete();
                }
            };

            Runnable r2 = new Runnable() {
                @Override
                public void run() {
                    cs.onComplete();
                }
            };

            TestHelper.race(r1, r2);

            to.assertResult(1);
        }
    }",loop_control
i,"{
        for (int i = 0; i < TestHelper.RACE_DEFAULT_LOOPS; i++) {
            List<Throwable> errors = TestHelper.trackPluginErrors();
            try {
                final PublishProcessor<Integer> pp0 = PublishProcessor.create();
                final PublishProcessor<Integer> pp1 = PublishProcessor.create();

                final TestObserver<Object> to = Maybe.zip(
                        Arrays.asList(pp0.singleElement(), pp1.singleElement()), addString)
                .test();

                final TestException ex = new TestException();

                Runnable r1 = new Runnable() {
                    @Override
                    public void run() {
                        pp0.onError(ex);
                    }
                };

                Runnable r2 = new Runnable() {
                    @Override
                    public void run() {
                        pp1.onError(ex);
                    }
                };

                TestHelper.race(r1, r2);

                to.assertFailure(TestException.class);

                if (!errors.isEmpty()) {
                    TestHelper.assertUndeliverable(errors, 0, TestException.class);
                }
            } finally {
                RxJavaPlugins.reset();
            }
        }
    }",loop_control
times,"{
        PublishProcessor<Integer> pp = PublishProcessor.create();

        final String[] name = { null };

        final CountDownLatch cdl = new CountDownLatch(1);

        pp.doOnCancel(new Action() {
            @Override
            public void run() throws Exception {
                name[0] = Thread.currentThread().getName();
                cdl.countDown();
            }
        })
        .singleElement()
        .unsubscribeOn(Schedulers.single())
        .test(true)
        ;

        assertTrue(cdl.await(5, TimeUnit.SECONDS));

        int times = 10;

        while (times-- > 0 && pp.hasSubscribers()) {
            Thread.sleep(100);
        }

        assertFalse(pp.hasSubscribers());

        assertNotEquals(Thread.currentThread().getName(), name[0]);
    }",loop_control
pp,"{
        PublishProcessor<Integer> pp = PublishProcessor.create();

        final String[] name = { null };

        final CountDownLatch cdl = new CountDownLatch(1);

        pp.doOnCancel(new Action() {
            @Override
            public void run() throws Exception {
                name[0] = Thread.currentThread().getName();
                cdl.countDown();
            }
        })
        .singleElement()
        .unsubscribeOn(Schedulers.single())
        .test(true)
        ;

        assertTrue(cdl.await(5, TimeUnit.SECONDS));

        int times = 10;

        while (times-- > 0 && pp.hasSubscribers()) {
            Thread.sleep(100);
        }

        assertFalse(pp.hasSubscribers());

        assertNotEquals(Thread.currentThread().getName(), name[0]);
    }",maybe_loop_control
i,"{
        for (int i = 0; i < TestHelper.RACE_DEFAULT_LOOPS; i++) {
            PublishProcessor<Integer> pp = PublishProcessor.create();

            final Disposable[] ds = { null };
            pp.singleElement().unsubscribeOn(Schedulers.computation())
            .subscribe(new MaybeObserver<Integer>() {
                @Override
                public void onSubscribe(Disposable d) {
                    ds[0] = d;
                }

                @Override
                public void onSuccess(Integer value) {

                }

                @Override
                public void onError(Throwable e) {

                }

                @Override
                public void onComplete() {

                }
            });

            Runnable r = new Runnable() {
                @Override
                public void run() {
                    ds[0].dispose();
                }
            };

            TestHelper.race(r, r);
        }
    }",loop_control
i,"{
        for (int i = 0; i < TestHelper.RACE_DEFAULT_LOOPS; i++) {

            final PublishProcessor<Integer> pp = PublishProcessor.create();

            final TestSubscriber<Integer> ts = Maybe.concat(Arrays.asList(pp.singleElement()))
            .test();

            pp.onNext(1);

            Runnable r1 = new Runnable() {
                @Override
                public void run() {
                    ts.cancel();
                }
            };

            Runnable r2 = new Runnable() {
                @Override
                public void run() {
                    pp.onComplete();
                }
            };

            TestHelper.race(r1, r2);
        }
    }",loop_control
i,"{
        for (int i = 0; i < TestHelper.RACE_DEFAULT_LOOPS; i++) {
            List<Throwable> errors = TestHelper.trackPluginErrors();
            try {
                final PublishProcessor<Integer> pp0 = PublishProcessor.create();
                final PublishProcessor<Integer> pp1 = PublishProcessor.create();

                final TestObserver<Object> to = Maybe.zip(pp0.singleElement(), pp1.singleElement(), addString)
                .test();

                final TestException ex = new TestException();

                Runnable r1 = new Runnable() {
                    @Override
                    public void run() {
                        pp0.onError(ex);
                    }
                };

                Runnable r2 = new Runnable() {
                    @Override
                    public void run() {
                        pp1.onError(ex);
                    }
                };

                TestHelper.race(r1, r2);

                to.assertFailure(TestException.class);

                if (!errors.isEmpty()) {
                    TestHelper.assertUndeliverable(errors, 0, TestException.class);
                }
            } finally {
                RxJavaPlugins.reset();
            }
        }
    }",loop_control
i,"{
        List<Maybe<Integer>> ms = new ArrayList<>();

        for (int i = 0; i < 32; i++) {
            ms.add(Maybe.<Integer>never());
        }

        ms.add(Maybe.just(1));

        Maybe.amb(ms)
        .test()
        .assertResult(1);
    }",loop_control
i,"{
        for (int i = 0; i < TestHelper.RACE_DEFAULT_LOOPS; i++) {
            List<Throwable> errors = TestHelper.trackPluginErrors();
            try {
                final PublishProcessor<Integer> pp0 = PublishProcessor.create();
                final PublishProcessor<Integer> pp1 = PublishProcessor.create();

                final TestObserver<Integer> to = Maybe.amb(Arrays.asList(pp0.singleElement(), pp1.singleElement()))
                .test();

                final TestException ex = new TestException();

                Runnable r1 = new Runnable() {
                    @Override
                    public void run() {
                        pp0.onError(ex);
                    }
                };

                Runnable r2 = new Runnable() {
                    @Override
                    public void run() {
                        pp1.onError(ex);
                    }
                };

                TestHelper.race(r1, r2);

                to.assertFailure(TestException.class);

                if (!errors.isEmpty()) {
                    TestHelper.assertUndeliverable(errors, 0, TestException.class);
                }
            } finally {
                RxJavaPlugins.reset();
            }
        }
    }",loop_control
i,"{
        for (int i = 0; i < TestHelper.RACE_LONG_LOOPS; i++) {
            final AtomicBoolean interrupted = new AtomicBoolean();
            final CountDownLatch cdl = new CountDownLatch(1);

            Maybe.ambArray(
                Maybe.just(1)
                    .subscribeOn(Schedulers.single())
                    .observeOn(Schedulers.computation()),
                Maybe.never()
            )
            .subscribe(new Consumer<Object>() {
                @Override
                public void accept(Object v) throws Exception {
                    interrupted.set(Thread.currentThread().isInterrupted());
                    cdl.countDown();
                }
            });

            assertTrue(cdl.await(500, TimeUnit.SECONDS));
            assertFalse(""Interrupted!"", interrupted.get());
        }
    }",loop_control
i,"{
        final TestException ex = new TestException();
        for (int i = 0; i < TestHelper.RACE_LONG_LOOPS; i++) {
            final AtomicBoolean interrupted = new AtomicBoolean();
            final CountDownLatch cdl = new CountDownLatch(1);

            Maybe.ambArray(
                Maybe.error(ex)
                    .subscribeOn(Schedulers.single())
                    .observeOn(Schedulers.computation()),
                Maybe.never()
            )
            .subscribe(Functions.emptyConsumer(), new Consumer<Throwable>() {
                @Override
                public void accept(Throwable e) throws Exception {
                    interrupted.set(Thread.currentThread().isInterrupted());
                    cdl.countDown();
                }
            });

            assertTrue(cdl.await(500, TimeUnit.SECONDS));
            assertFalse(""Interrupted!"", interrupted.get());
        }
    }",loop_control
i,"{
        for (int i = 0; i < TestHelper.RACE_LONG_LOOPS; i++) {
            final AtomicBoolean interrupted = new AtomicBoolean();
            final CountDownLatch cdl = new CountDownLatch(1);

            Maybe.ambArray(
                Maybe.empty()
                    .subscribeOn(Schedulers.single())
                    .observeOn(Schedulers.computation()),
                Maybe.never()
            )
            .subscribe(Functions.emptyConsumer(), Functions.emptyConsumer(), new Action() {
                @Override
                public void run() throws Exception {
                    interrupted.set(Thread.currentThread().isInterrupted());
                    cdl.countDown();
                }
            });

            assertTrue(cdl.await(500, TimeUnit.SECONDS));
            assertFalse(""Interrupted!"", interrupted.get());
        }
    }",loop_control
i,"{
        for (int i = 0; i < TestHelper.RACE_DEFAULT_LOOPS; i++) {
            List<Throwable> errors = TestHelper.trackPluginErrors();

            try {

                final Subject<Integer> ps = ReplaySubject.create();
                ps.onNext(1);

                final Maybe<Integer> source = Maybe.ambArray(ps.singleElement(),
                        Maybe.<Integer>never(), Maybe.<Integer>never(), null);

                Runnable r1 = new Runnable() {
                    @Override
                    public void run() {
                        source.test();
                    }
                };

                Runnable r2 = new Runnable() {
                    @Override
                    public void run() {
                        ps.onComplete();
                    }
                };

                TestHelper.race(r1, r2);

                if (!errors.isEmpty()) {
                    TestHelper.assertError(errors, 0, NullPointerException.class);
                }
            } finally {
                RxJavaPlugins.reset();
            }
        }
    }",loop_control
i,"{
        final AtomicInteger count = new AtomicInteger();
        @SuppressWarnings(""unchecked"")
        Maybe<Integer>[] sources = new Maybe[3];
        for (int i = 0; i < 3; i++) {
            final int j = i + 1;
            sources[i] = Maybe.fromCallable(new Callable<Integer>() {
                @Override
                public Integer call() throws Exception {
                    return count.incrementAndGet() - j;
                }
            })
            .subscribeOn(Schedulers.io());
        }

        for (int i = 0; i < 1000; i++) {
            count.set(0);
            Maybe.mergeDelayError(
                    Flowable.fromArray(sources), 1)
            .test()
            .awaitDone(5, TimeUnit.SECONDS)
            .assertResult(0, 0, 0);
        }
    }",loop_control
i,"{
        final AtomicInteger count = new AtomicInteger();
        @SuppressWarnings(""unchecked"")
        Maybe<Integer>[] sources = new Maybe[3];
        for (int i = 0; i < 3; i++) {
            final int j = i + 1;
            sources[i] = Maybe.fromCallable(new Callable<Integer>() {
                @Override
                public Integer call() throws Exception {
                    return count.incrementAndGet() - j;
                }
            })
            .subscribeOn(Schedulers.io());
        }
        sources[1] = Maybe.fromCallable(new Callable<Integer>() {
            @Override
            public Integer call() throws Exception {
                throw new TestException("""" + count.incrementAndGet());
            }
        })
        .subscribeOn(Schedulers.io());

        for (int i = 0; i < 1000; i++) {
            count.set(0);
            Maybe.mergeDelayError(
                    Flowable.fromArray(sources), 1)
            .to(TestHelper.<Integer>testConsumer())
            .awaitDone(5, TimeUnit.SECONDS)
            .assertFailureAndMessage(TestException.class, ""2"", 0, 0);
        }
    }",loop_control
s,"{
        ScheduledExecutorService exec = Executors.newSingleThreadScheduledExecutor();
        try {
            for (Scheduler s : new Scheduler[] { Schedulers.single(), Schedulers.computation(), Schedulers.newThread(), Schedulers.io(), Schedulers.from(exec, true) }) {
                final AtomicBoolean interrupted = new AtomicBoolean();
                TestObserver<Long> to = Maybe.timer(1, TimeUnit.MILLISECONDS, s)
                .map(new Function<Long, Long>() {
                    @Override
                    public Long apply(Long v) throws Exception {
                        try {
                        Thread.sleep(3000);
                        } catch (InterruptedException ex) {
                            interrupted.set(true);
                        }
                        return v;
                    }
                })
                .test();

                Thread.sleep(500);

                to.dispose();

                Thread.sleep(500);

                assertTrue(s.getClass().getSimpleName(), interrupted.get());
            }
        } finally {
            exec.shutdown();
        }
    }",iterator
i,"{
        for (int i = 0; i < TestHelper.RACE_DEFAULT_LOOPS; i++) {
            PublishProcessor<Integer> pp = PublishProcessor.create();

            final Maybe<Integer> source = pp.singleElement().cache();

            Runnable r = new Runnable() {
                @Override
                public void run() {
                    source.test();
                }
            };

            TestHelper.race(r, r);
        }
    }",loop_control
i,"{
        for (int i = 0; i < TestHelper.RACE_DEFAULT_LOOPS; i++) {
            PublishProcessor<Integer> pp = PublishProcessor.create();

            final Maybe<Integer> source = pp.singleElement().cache();

            final TestObserver<Integer> to1 = source.test();
            final TestObserver<Integer> to2 = source.test();

            Runnable r1 = new Runnable() {
                @Override
                public void run() {
                    to1.dispose();
                }
            };

            Runnable r2 = new Runnable() {
                @Override
                public void run() {
                    to2.dispose();
                }
            };

            TestHelper.race(r1, r2);
        }
    }",loop_control
timeout,"{
        List<Throwable> errors = TestHelper.trackPluginErrors();
        try {
            final CountDownLatch cdl1 = new CountDownLatch(1);
            final CountDownLatch cdl2 = new CountDownLatch(1);

            TestObserver<Object> to = Maybe.fromAction(new Action() {
                @Override
                public void run() throws Exception {
                    cdl1.countDown();
                    cdl2.await(5, TimeUnit.SECONDS);
                }
            }).subscribeOn(Schedulers.single()).test();

            assertTrue(cdl1.await(5, TimeUnit.SECONDS));

            to.dispose();

            int timeout = 10;

            while (timeout-- > 0 && errors.isEmpty()) {
                Thread.sleep(100);
            }

            TestHelper.assertUndeliverable(errors, 0, InterruptedException.class);
        } finally {
            RxJavaPlugins.reset();
        }
    }",loop_control
errors,"{
        List<Throwable> errors = TestHelper.trackPluginErrors();
        try {
            final CountDownLatch cdl1 = new CountDownLatch(1);
            final CountDownLatch cdl2 = new CountDownLatch(1);

            TestObserver<Object> to = Maybe.fromAction(new Action() {
                @Override
                public void run() throws Exception {
                    cdl1.countDown();
                    cdl2.await(5, TimeUnit.SECONDS);
                }
            }).subscribeOn(Schedulers.single()).test();

            assertTrue(cdl1.await(5, TimeUnit.SECONDS));

            to.dispose();

            int timeout = 10;

            while (timeout-- > 0 && errors.isEmpty()) {
                Thread.sleep(100);
            }

            TestHelper.assertUndeliverable(errors, 0, InterruptedException.class);
        } finally {
            RxJavaPlugins.reset();
        }
    }",maybe_loop_control
i,"{
        for (int i = 0; i < TestHelper.RACE_DEFAULT_LOOPS; i++) {
            final PublishProcessor<Integer> pp = PublishProcessor.create();

            final TestObserver<Integer> to = pp.singleElement().switchIfEmpty(Single.just(2)).test();

            Runnable r1 = new Runnable() {
                @Override
                public void run() {
                    pp.onComplete();
                }
            };

            Runnable r2 = new Runnable() {
                @Override
                public void run() {
                    to.dispose();
                }
            };

            TestHelper.race(r1, r2);
        }
    }",loop_control
timeout,"{
        List<Throwable> errors = TestHelper.trackPluginErrors();
        try {
            final CountDownLatch cdl1 = new CountDownLatch(1);
            final CountDownLatch cdl2 = new CountDownLatch(1);

            TestObserver<Integer> to = Maybe.fromCallable(new Callable<Integer>() {
                @Override
                public Integer call() throws Exception {
                    cdl1.countDown();
                    cdl2.await(5, TimeUnit.SECONDS);
                    return 1;
                }
            }).subscribeOn(Schedulers.single()).test();

            assertTrue(cdl1.await(5, TimeUnit.SECONDS));

            to.dispose();

            int timeout = 10;

            while (timeout-- > 0 && errors.isEmpty()) {
                Thread.sleep(100);
            }

            TestHelper.assertUndeliverable(errors, 0, InterruptedException.class);
        } finally {
            RxJavaPlugins.reset();
        }
    }",loop_control
errors,"{
        List<Throwable> errors = TestHelper.trackPluginErrors();
        try {
            final CountDownLatch cdl1 = new CountDownLatch(1);
            final CountDownLatch cdl2 = new CountDownLatch(1);

            TestObserver<Integer> to = Maybe.fromCallable(new Callable<Integer>() {
                @Override
                public Integer call() throws Exception {
                    cdl1.countDown();
                    cdl2.await(5, TimeUnit.SECONDS);
                    return 1;
                }
            }).subscribeOn(Schedulers.single()).test();

            assertTrue(cdl1.await(5, TimeUnit.SECONDS));

            to.dispose();

            int timeout = 10;

            while (timeout-- > 0 && errors.isEmpty()) {
                Thread.sleep(100);
            }

            TestHelper.assertUndeliverable(errors, 0, InterruptedException.class);
        } finally {
            RxJavaPlugins.reset();
        }
    }",maybe_loop_control
i,"{
        for (int i = 0; i < TestHelper.RACE_DEFAULT_LOOPS; i++) {
            final PublishProcessor<Integer> pp = PublishProcessor.create();

            final TestObserver<Integer> to = pp.singleElement().switchIfEmpty(Maybe.just(2)).test();

            Runnable r1 = new Runnable() {
                @Override
                public void run() {
                    pp.onComplete();
                }
            };

            Runnable r2 = new Runnable() {
                @Override
                public void run() {
                    to.dispose();
                }
            };

            TestHelper.race(r1, r2);
        }
    }",loop_control
i,"{
        for (int i = 0; i < TestHelper.RACE_DEFAULT_LOOPS; i++) {
            final PublishProcessor<Integer> pp1 = PublishProcessor.create();
            final PublishProcessor<Integer> pp2 = PublishProcessor.create();

            TestObserver<Integer> to = pp1.singleElement().takeUntil(pp2).test();

            final TestException ex1 = new TestException();
            final TestException ex2 = new TestException();

            List<Throwable> errors = TestHelper.trackPluginErrors();
            try {

                Runnable r1 = new Runnable() {
                    @Override
                    public void run() {
                        pp1.onError(ex1);
                    }
                };
                Runnable r2 = new Runnable() {
                    @Override
                    public void run() {
                        pp2.onError(ex2);
                    }
                };

                TestHelper.race(r1, r2);

                to.assertFailure(TestException.class);

                if (!errors.isEmpty()) {
                    TestHelper.assertUndeliverable(errors, 0, TestException.class);
                }

            } finally {
                RxJavaPlugins.reset();
            }

        }
    }",loop_control
i,"{
        for (int i = 0; i < TestHelper.RACE_DEFAULT_LOOPS; i++) {
            final PublishProcessor<Integer> pp1 = PublishProcessor.create();
            final PublishProcessor<Integer> pp2 = PublishProcessor.create();

            TestObserver<Integer> to = pp1.singleElement().takeUntil(pp2).test();

            Runnable r1 = new Runnable() {
                @Override
                public void run() {
                    pp1.onComplete();
                }
            };
            Runnable r2 = new Runnable() {
                @Override
                public void run() {
                    pp2.onComplete();
                }
            };

            TestHelper.race(r1, r2);

            to.assertResult();
        }
    }",loop_control
i,"{
        for (int i = 0; i < TestHelper.RACE_DEFAULT_LOOPS; i++) {
            List<Throwable> errors = TestHelper.trackPluginErrors();

            try {
                final PublishSubject<Integer> ps1 = PublishSubject.create();
                final PublishSubject<Integer> ps2 = PublishSubject.create();

                TestSubscriber<Integer> ts = Maybe.mergeArray(ps1.singleElement(), ps2.singleElement())
                .test();

                final TestException ex = new TestException();

                Runnable r1 = new Runnable() {
                    @Override
                    public void run() {
                        ps1.onError(ex);
                    }
                };

                Runnable r2 = new Runnable() {
                    @Override
                    public void run() {
                        ps2.onError(ex);
                    }
                };

                TestHelper.race(r1, r2);

                ts.assertFailure(Throwable.class);

                if (!errors.isEmpty()) {
                    TestHelper.assertUndeliverable(errors, 0, TestException.class);
                }
            } finally {
                RxJavaPlugins.reset();
            }
        }
    }",loop_control
i,"{
        for (int i = 0; i < TestHelper.RACE_DEFAULT_LOOPS; i++) {
            final PublishProcessor<Integer> pp1 = PublishProcessor.create();
            final PublishProcessor<Integer> pp2 = PublishProcessor.create();

            TestObserver<Integer> to = pp1.singleElement().takeUntil(pp2.singleElement()).test();

            final TestException ex1 = new TestException();
            final TestException ex2 = new TestException();

            List<Throwable> errors = TestHelper.trackPluginErrors();
            try {

                Runnable r1 = new Runnable() {
                    @Override
                    public void run() {
                        pp1.onError(ex1);
                    }
                };
                Runnable r2 = new Runnable() {
                    @Override
                    public void run() {
                        pp2.onError(ex2);
                    }
                };

                TestHelper.race(r1, r2);

                to.assertFailure(TestException.class);

                if (!errors.isEmpty()) {
                    TestHelper.assertUndeliverable(errors, 0, TestException.class);
                }

            } finally {
                RxJavaPlugins.reset();
            }

        }
    }",loop_control
i,"{
        for (int i = 0; i < TestHelper.RACE_DEFAULT_LOOPS; i++) {
            final PublishProcessor<Integer> pp1 = PublishProcessor.create();
            final PublishProcessor<Integer> pp2 = PublishProcessor.create();

            TestObserver<Integer> to = pp1.singleElement().takeUntil(pp2.singleElement()).test();

            Runnable r1 = new Runnable() {
                @Override
                public void run() {
                    pp1.onComplete();
                }
            };
            Runnable r2 = new Runnable() {
                @Override
                public void run() {
                    pp2.onComplete();
                }
            };

            TestHelper.race(r1, r2);

            to.assertResult();
        }
    }",loop_control
i,"{
        for (int i = 0; i < TestHelper.RACE_DEFAULT_LOOPS; i++) {
            final TestSubscriber<Integer> ts = Maybe.concatArray(Maybe.just(1), Maybe.just(2))
                    .test(0L);

            Runnable r1 = new Runnable() {
                @Override
                public void run() {
                    ts.cancel();
                }
            };

            Runnable r2 = new Runnable() {
                @Override
                public void run() {
                    ts.request(1);
                }
            };

            TestHelper.race(r1, r2);
        }
    }",loop_control
i,"{
        for (int i = 0; i < TestHelper.RACE_DEFAULT_LOOPS; i++) {
            final TestSubscriber<Integer> ts = Maybe.concatArrayDelayError(Maybe.just(1), Maybe.just(2))
                    .test(0L);

            Runnable r1 = new Runnable() {
                @Override
                public void run() {
                    ts.cancel();
                }
            };

            Runnable r2 = new Runnable() {
                @Override
                public void run() {
                    ts.request(1);
                }
            };

            TestHelper.race(r1, r2);
        }
    }",loop_control
timeout,"{
        List<Throwable> errors = TestHelper.trackPluginErrors();
        try {
            final CountDownLatch cdl1 = new CountDownLatch(1);
            final CountDownLatch cdl2 = new CountDownLatch(1);

            TestObserver<Object> to = Maybe.fromRunnable(new Runnable() {
                @Override
                public void run() {
                    cdl1.countDown();
                    try {
                        cdl2.await(5, TimeUnit.SECONDS);
                    } catch (InterruptedException ex) {
                        throw new RuntimeException(ex);
                    }
                }
            }).subscribeOn(Schedulers.single()).test();

            assertTrue(cdl1.await(5, TimeUnit.SECONDS));

            to.dispose();

            int timeout = 10;

            while (timeout-- > 0 && errors.isEmpty()) {
                Thread.sleep(100);
            }

            TestHelper.assertUndeliverable(errors, 0, RuntimeException.class);

            assertTrue(errors.get(0).toString(), errors.get(0).getCause().getCause() instanceof InterruptedException);
        } finally {
            RxJavaPlugins.reset();
        }
    }",loop_control
errors,"{
        List<Throwable> errors = TestHelper.trackPluginErrors();
        try {
            final CountDownLatch cdl1 = new CountDownLatch(1);
            final CountDownLatch cdl2 = new CountDownLatch(1);

            TestObserver<Object> to = Maybe.fromRunnable(new Runnable() {
                @Override
                public void run() {
                    cdl1.countDown();
                    try {
                        cdl2.await(5, TimeUnit.SECONDS);
                    } catch (InterruptedException ex) {
                        throw new RuntimeException(ex);
                    }
                }
            }).subscribeOn(Schedulers.single()).test();

            assertTrue(cdl1.await(5, TimeUnit.SECONDS));

            to.dispose();

            int timeout = 10;

            while (timeout-- > 0 && errors.isEmpty()) {
                Thread.sleep(100);
            }

            TestHelper.assertUndeliverable(errors, 0, RuntimeException.class);

            assertTrue(errors.get(0).toString(), errors.get(0).getCause().getCause() instanceof InterruptedException);
        } finally {
            RxJavaPlugins.reset();
        }
    }",maybe_loop_control
i,"{
        for (int i = 0; i < TestHelper.RACE_DEFAULT_LOOPS; i++) {

            final PublishSubject<Integer> ps = PublishSubject.create();

            final TestObserver<Integer> to = Maybe.using(new Supplier<Object>() {
                @Override
                public Object get() throws Exception {
                    return 1;
                }
            }, new Function<Object, MaybeSource<Integer>>() {
                @Override
                public MaybeSource<Integer> apply(Object v) throws Exception {
                    return ps.lastElement();
                }
            }, new Consumer<Object>() {
                @Override
                public void accept(Object d) throws Exception {
                }
            }, true)
            .test();

            ps.onNext(1);

            Runnable r1 = new Runnable() {
                @Override
                public void run() {
                    to.dispose();
                }
            };

            Runnable r2 = new Runnable() {
                @Override
                public void run() {
                    ps.onComplete();
                }
            };

            TestHelper.race(r1, r2);
        }
    }",loop_control
i,"{
        for (int i = 0; i < TestHelper.RACE_DEFAULT_LOOPS; i++) {

            final PublishSubject<Integer> ps = PublishSubject.create();

            final TestObserver<Integer> to = Maybe.using(new Supplier<Object>() {
                @Override
                public Object get() throws Exception {
                    return 1;
                }
            }, new Function<Object, MaybeSource<Integer>>() {
                @Override
                public MaybeSource<Integer> apply(Object v) throws Exception {
                    return ps.firstElement();
                }
            }, new Consumer<Object>() {
                @Override
                public void accept(Object d) throws Exception {
                }
            }, true)
            .test();

            final TestException ex = new TestException();

            Runnable r1 = new Runnable() {
                @Override
                public void run() {
                    to.dispose();
                }
            };

            Runnable r2 = new Runnable() {
                @Override
                public void run() {
                    ps.onError(ex);
                }
            };

            TestHelper.race(r1, r2);
        }
    }",loop_control
i,"{
        for (int i = 0; i < TestHelper.RACE_DEFAULT_LOOPS; i++) {

            final PublishSubject<Integer> ps = PublishSubject.create();

            final TestObserver<Integer> to = Maybe.using(new Supplier<Object>() {
                @Override
                public Object get() throws Exception {
                    return 1;
                }
            }, new Function<Object, MaybeSource<Integer>>() {
                @Override
                public MaybeSource<Integer> apply(Object v) throws Exception {
                    return ps.firstElement();
                }
            }, new Consumer<Object>() {
                @Override
                public void accept(Object d) throws Exception {

                }
            }, true)
            .test();

            Runnable r1 = new Runnable() {
                @Override
                public void run() {
                    to.dispose();
                }
            };

            Runnable r2 = new Runnable() {
                @Override
                public void run() {
                    ps.onComplete();
                }
            };

            TestHelper.race(r1, r2);
        }
    }",loop_control
i,"{
        for (int i = 0; i < TestHelper.RACE_DEFAULT_LOOPS; i++) {
            TestHelper.trackPluginErrors();
            try {
                final PublishProcessor<Integer> pp1 = PublishProcessor.create();
                final PublishProcessor<Integer> pp2 = PublishProcessor.create();

                TestObserver<Integer> to = pp1.singleElement().timeout(pp2).test();

                final TestException ex = new TestException();

                Runnable r1 = new Runnable() {
                    @Override
                    public void run() {
                        pp1.onError(ex);
                    }
                };
                Runnable r2 = new Runnable() {
                    @Override
                    public void run() {
                        pp2.onError(ex);
                    }
                };

                TestHelper.race(r1, r2);

                to.assertFailure(TestException.class);
            } finally {
                RxJavaPlugins.reset();
            }
        }
    }",loop_control
i,"{
        for (int i = 0; i < TestHelper.RACE_DEFAULT_LOOPS; i++) {
            final PublishProcessor<Integer> pp1 = PublishProcessor.create();
            final PublishProcessor<Integer> pp2 = PublishProcessor.create();

            TestObserverEx<Integer> to = pp1.singleElement().timeout(pp2).to(TestHelper.<Integer>testConsumer());

            Runnable r1 = new Runnable() {
                @Override
                public void run() {
                    pp1.onComplete();
                }
            };
            Runnable r2 = new Runnable() {
                @Override
                public void run() {
                    pp2.onComplete();
                }
            };

            TestHelper.race(r1, r2);

            to.assertSubscribed().assertNoValues();

            if (to.errors().size() != 0) {
                to.assertError(TimeoutException.class).assertNotComplete();
            } else {
                to.assertNoErrors().assertComplete();
            }
        }
    }",loop_control
i,"{
        for (int i = 0; i < 500; i++) {
            final PublishSubject<Integer> ps = PublishSubject.create();

            ps.singleElement().flattenAsFlowable(
            new Function<Integer, Iterable<Integer>>() {
                @Override
                public Iterable<Integer> apply(Integer v) throws Exception {
                    return Arrays.asList(1, 2, 3);
                }
            })
            .test(5L)
            .assertEmpty();
        }
    }",loop_control
i,"{
        final Integer[] a = new Integer[1000];
        Arrays.fill(a, 1);

        for (int i = 0; i < TestHelper.RACE_DEFAULT_LOOPS; i++) {
            final PublishSubject<Integer> ps = PublishSubject.create();

            ps.onNext(1);

            final TestSubscriber<Integer> ts = ps.singleElement().flattenAsFlowable(
            new Function<Integer, Iterable<Integer>>() {
                @Override
                public Iterable<Integer> apply(Integer v) throws Exception {
                    return Arrays.asList(a);
                }
            })
            .test(0L);

            Runnable r1 = new Runnable() {
                @Override
                public void run() {
                    ps.onComplete();
                    for (int i = 0; i < 500; i++) {
                        ts.request(1);
                    }
                }
            };

            Runnable r2 = new Runnable() {
                @Override
                public void run() {
                    for (int i = 0; i < 500; i++) {
                        ts.request(1);
                    }
                }
            };

            TestHelper.race(r1, r2);
        }
    }",loop_control
i,"{
        for (int i = 0; i < TestHelper.RACE_DEFAULT_LOOPS; i++) {
            final PublishSubject<Integer> ps = PublishSubject.create();

            ps.onNext(1);

            final TestSubscriber<Integer> ts = ps.singleElement().flattenAsFlowable(
            new Function<Integer, Iterable<Integer>>() {
                @Override
                public Iterable<Integer> apply(Integer v) throws Exception {
                    return Arrays.asList(1, 2, 3);
                }
            })
            .test(0L);

            Runnable r1 = new Runnable() {
                @Override
                public void run() {
                    ps.onComplete();
                }
            };

            Runnable r2 = new Runnable() {
                @Override
                public void run() {
                    ts.cancel();
                }
            };

            TestHelper.race(r1, r2);
        }
    }",loop_control
i,"{
        List<Object> list = Arrays.asList(1);
        for (int i = 0; i < TestHelper.RACE_DEFAULT_LOOPS; i++) {

            MaybeSubject<Integer> ms = MaybeSubject.create();

            TestSubscriber<Object> ts = ms.flattenAsFlowable(v -> list)
            .test(0L);

            TestHelper.race(
                    () -> ms.onSuccess(1),
                    () -> ts.request(1)
            );

            ts.assertResult(1);
        }
    }",loop_control
i,"{
        for (int i = 0; i < TestHelper.RACE_DEFAULT_LOOPS; i++) {
            TestHelper.trackPluginErrors();
            try {
                final PublishProcessor<Integer> pp1 = PublishProcessor.create();
                final PublishProcessor<Integer> pp2 = PublishProcessor.create();

                TestObserver<Integer> to = pp1.singleElement().timeout(pp2.singleElement()).test();

                final TestException ex = new TestException();

                Runnable r1 = new Runnable() {
                    @Override
                    public void run() {
                        pp1.onError(ex);
                    }
                };
                Runnable r2 = new Runnable() {
                    @Override
                    public void run() {
                        pp2.onError(ex);
                    }
                };

                TestHelper.race(r1, r2);

                to.assertFailure(TestException.class);
            } finally {
                RxJavaPlugins.reset();
            }
        }
    }",loop_control
i,"{
        for (int i = 0; i < TestHelper.RACE_DEFAULT_LOOPS; i++) {
            final PublishProcessor<Integer> pp1 = PublishProcessor.create();
            final PublishProcessor<Integer> pp2 = PublishProcessor.create();

            TestObserverEx<Integer> to = pp1.singleElement().timeout(pp2.singleElement()).to(TestHelper.<Integer>testConsumer());

            Runnable r1 = new Runnable() {
                @Override
                public void run() {
                    pp1.onComplete();
                }
            };
            Runnable r2 = new Runnable() {
                @Override
                public void run() {
                    pp2.onComplete();
                }
            };

            TestHelper.race(r1, r2);

            to.assertSubscribed().assertNoValues();

            if (to.errors().size() != 0) {
                to.assertError(TimeoutException.class).assertNotComplete();
            } else {
                to.assertNoErrors().assertComplete();
            }
        }
    }",loop_control
timeout,"{
        List<Throwable> errors = TestHelper.trackPluginErrors();
        try {
            final CountDownLatch cdl1 = new CountDownLatch(1);
            final CountDownLatch cdl2 = new CountDownLatch(1);

            TestObserver<Integer> to = Maybe.fromSupplier(new Supplier<Integer>() {
                @Override
                public Integer get() throws Exception {
                    cdl1.countDown();
                    cdl2.await(5, TimeUnit.SECONDS);
                    return 1;
                }
            }).subscribeOn(Schedulers.single()).test();

            assertTrue(cdl1.await(5, TimeUnit.SECONDS));

            to.dispose();

            int timeout = 10;

            while (timeout-- > 0 && errors.isEmpty()) {
                Thread.sleep(100);
            }

            TestHelper.assertUndeliverable(errors, 0, InterruptedException.class);
        } finally {
            RxJavaPlugins.reset();
        }
    }",loop_control
errors,"{
        List<Throwable> errors = TestHelper.trackPluginErrors();
        try {
            final CountDownLatch cdl1 = new CountDownLatch(1);
            final CountDownLatch cdl2 = new CountDownLatch(1);

            TestObserver<Integer> to = Maybe.fromSupplier(new Supplier<Integer>() {
                @Override
                public Integer get() throws Exception {
                    cdl1.countDown();
                    cdl2.await(5, TimeUnit.SECONDS);
                    return 1;
                }
            }).subscribeOn(Schedulers.single()).test();

            assertTrue(cdl1.await(5, TimeUnit.SECONDS));

            to.dispose();

            int timeout = 10;

            while (timeout-- > 0 && errors.isEmpty()) {
                Thread.sleep(100);
            }

            TestHelper.assertUndeliverable(errors, 0, InterruptedException.class);
        } finally {
            RxJavaPlugins.reset();
        }
    }",maybe_loop_control
i,"{
        for (int i = 1; i < 100; i++) {
            Single<Integer>[] array = new Single[i];

            Arrays.fill(array, Single.just(1));

            Single.concatArray(array)
            .to(TestHelper.<Integer>testConsumer())
            .assertSubscribed()
            .assertValueCount(i)
            .assertNoErrors()
            .assertComplete();
        }
    }",loop_control
i,"{
        for (int i = 1; i < 100; i++) {
            Single<Integer>[] array = new Single[i];

            Arrays.fill(array, Single.just(1));

            Single.concat(Observable.fromArray(array))
            .to(TestHelper.<Integer>testConsumer())
            .assertSubscribed()
            .assertValueCount(i)
            .assertNoErrors()
            .assertComplete();
        }
    }",loop_control
s,"{
        ScheduledExecutorService exec = Executors.newSingleThreadScheduledExecutor();
        try {
            for (Scheduler s : new Scheduler[] { Schedulers.single(), Schedulers.computation(), Schedulers.newThread(), Schedulers.io(), Schedulers.from(exec, true) }) {
                final AtomicBoolean interrupted = new AtomicBoolean();
                TestObserver<Long> to = Single.timer(1, TimeUnit.MILLISECONDS, s)
                .map(new Function<Long, Long>() {
                    @Override
                    public Long apply(Long v) throws Exception {
                        try {
                        Thread.sleep(3000);
                        } catch (InterruptedException ex) {
                            interrupted.set(true);
                        }
                        return v;
                    }
                })
                .test();

                Thread.sleep(500);

                to.dispose();

                Thread.sleep(500);

                assertTrue(s.getClass().getSimpleName(), interrupted.get());
            }
        } finally {
            exec.shutdown();
        }
    }",iterator
i,"{
        for (int i = 0; i < TestHelper.RACE_DEFAULT_LOOPS; i++) {
            final SingleSubject<Integer> subj = SingleSubject.create();
            SingleSubject<Integer> fallback = SingleSubject.create();

            final TestScheduler sch = new TestScheduler();

            TestObserver<Integer> to = subj.timeout(1, TimeUnit.MILLISECONDS, sch, fallback).test();

            Runnable r1 = new Runnable() {
                @Override
                public void run() {
                    subj.onSuccess(1);
                }
            };

            Runnable r2 = new Runnable() {
                @Override
                public void run() {
                    sch.advanceTimeBy(1, TimeUnit.MILLISECONDS);
                }
            };

            TestHelper.race(r1, r2);

            if (!fallback.hasObservers()) {
                to.assertResult(1);
            } else {
                to.assertEmpty();
            }
        }
    }",loop_control
i,"{
        final TestException ex = new TestException();
        List<Throwable> errors = TestHelper.trackPluginErrors();
        try {

            for (int i = 0; i < TestHelper.RACE_DEFAULT_LOOPS; i++) {
                final SingleSubject<Integer> subj = SingleSubject.create();
                SingleSubject<Integer> fallback = SingleSubject.create();

                final TestScheduler sch = new TestScheduler();

                TestObserver<Integer> to = subj.timeout(1, TimeUnit.MILLISECONDS, sch, fallback).test();

                Runnable r1 = new Runnable() {
                    @Override
                    public void run() {
                        subj.onError(ex);
                    }
                };

                Runnable r2 = new Runnable() {
                    @Override
                    public void run() {
                        sch.advanceTimeBy(1, TimeUnit.MILLISECONDS);
                    }
                };

                TestHelper.race(r1, r2);

                if (!fallback.hasObservers()) {
                    to.assertFailure(TestException.class);
                } else {
                    to.assertEmpty();
                }
                if (!errors.isEmpty()) {
                    TestHelper.assertUndeliverable(errors, 0, TestException.class);
                }
            }
        } finally {
            RxJavaPlugins.reset();
        }
    }",loop_control
timeout,"{
        List<Throwable> errors = TestHelper.trackPluginErrors();
        try {
            final CountDownLatch cdl1 = new CountDownLatch(1);
            final CountDownLatch cdl2 = new CountDownLatch(1);

            TestObserver<Integer> to = Single.fromCallable(new Callable<Integer>() {
                @Override
                public Integer call() throws Exception {
                    cdl1.countDown();
                    cdl2.await(5, TimeUnit.SECONDS);
                    return 1;
                }
            }).subscribeOn(Schedulers.single()).test();

            assertTrue(cdl1.await(5, TimeUnit.SECONDS));

            to.dispose();

            int timeout = 10;

            while (timeout-- > 0 && errors.isEmpty()) {
                Thread.sleep(100);
            }

            TestHelper.assertUndeliverable(errors, 0, InterruptedException.class);
        } finally {
            RxJavaPlugins.reset();
        }
    }",loop_control
errors,"{
        List<Throwable> errors = TestHelper.trackPluginErrors();
        try {
            final CountDownLatch cdl1 = new CountDownLatch(1);
            final CountDownLatch cdl2 = new CountDownLatch(1);

            TestObserver<Integer> to = Single.fromCallable(new Callable<Integer>() {
                @Override
                public Integer call() throws Exception {
                    cdl1.countDown();
                    cdl2.await(5, TimeUnit.SECONDS);
                    return 1;
                }
            }).subscribeOn(Schedulers.single()).test();

            assertTrue(cdl1.await(5, TimeUnit.SECONDS));

            to.dispose();

            int timeout = 10;

            while (timeout-- > 0 && errors.isEmpty()) {
                Thread.sleep(100);
            }

            TestHelper.assertUndeliverable(errors, 0, InterruptedException.class);
        } finally {
            RxJavaPlugins.reset();
        }
    }",maybe_loop_control
i,"{
        for (int i = 0; i < TestHelper.RACE_DEFAULT_LOOPS; i++) {
            List<Throwable> errors = TestHelper.trackPluginErrors();
            try {
                final PublishProcessor<Integer> pp0 = PublishProcessor.create();
                final PublishProcessor<Integer> pp1 = PublishProcessor.create();

                final TestObserver<Object> to = Single.zip(
                        Arrays.asList(pp0.single(0), pp1.single(0)), addString)
                .test();

                final TestException ex = new TestException();

                Runnable r1 = new Runnable() {
                    @Override
                    public void run() {
                        pp0.onError(ex);
                    }
                };

                Runnable r2 = new Runnable() {
                    @Override
                    public void run() {
                        pp1.onError(ex);
                    }
                };

                TestHelper.race(r1, r2);

                to.assertFailure(TestException.class);

                if (!errors.isEmpty()) {
                    TestHelper.assertUndeliverable(errors, 0, TestException.class);
                }
            } finally {
                RxJavaPlugins.reset();
            }
        }
    }",loop_control
i,"{
        for (int i = 0; i < TestHelper.RACE_DEFAULT_LOOPS; i++) {
            List<Throwable> errors = TestHelper.trackPluginErrors();

            try {
                final PublishProcessor<Integer> pp1 = PublishProcessor.create();
                final PublishProcessor<Integer> pp2 = PublishProcessor.create();

                TestObserver<Integer> to = pp1.singleOrError().takeUntil(pp2).test();

                final TestException ex = new TestException();

                Runnable r1 = new Runnable() {
                    @Override
                    public void run() {
                        pp1.onError(ex);
                    }
                };

                Runnable r2 = new Runnable() {
                    @Override
                    public void run() {
                        pp2.onError(ex);
                    }
                };

                TestHelper.race(r1, r2);

                to.assertFailure(TestException.class);

                if (!errors.isEmpty()) {
                    TestHelper.assertUndeliverable(errors, 0, TestException.class);
                }
            } finally {
                RxJavaPlugins.reset();
            }
        }
    }",loop_control
i,"{
        for (int i = 0; i < TestHelper.RACE_DEFAULT_LOOPS; i++) {
            final PublishProcessor<Integer> pp = PublishProcessor.create();

            Disposable d = Disposable.empty();

            final TestObserver<Integer> to = Single.using(Functions.justSupplier(d), new Function<Disposable, SingleSource<Integer>>() {
                @Override
                public SingleSource<Integer> apply(Disposable v) throws Exception {
                    return pp.single(-99);
                }
            }, disposer)
            .test();

            pp.onNext(1);

            Runnable r1 = new Runnable() {
                @Override
                public void run() {
                    pp.onComplete();
                }
            };
            Runnable r2 = new Runnable() {
                @Override
                public void run() {
                    to.dispose();
                }
            };

            TestHelper.race(r1, r2);

            assertTrue(d.isDisposed());
        }
    }",loop_control
i,"{
        for (int i = 0; i < TestHelper.RACE_DEFAULT_LOOPS; i++) {
            final PublishProcessor<Integer> pp = PublishProcessor.create();

            Disposable d = Disposable.empty();

            final TestObserver<Integer> to = Single.using(Functions.justSupplier(d), new Function<Disposable, SingleSource<Integer>>() {
                @Override
                public SingleSource<Integer> apply(Disposable v) throws Exception {
                    return pp.single(-99);
                }
            }, disposer)
            .test();

            final TestException ex = new TestException();

            Runnable r1 = new Runnable() {
                @Override
                public void run() {
                    pp.onError(ex);
                }
            };
            Runnable r2 = new Runnable() {
                @Override
                public void run() {
                    to.dispose();
                }
            };

            TestHelper.race(r1, r2);

            assertTrue(d.isDisposed());
        }
    }",loop_control
i,"{

        Single<Integer> s = Single.defer(new Supplier<Single<Integer>>() {
            int counter;
            @Override
            public Single<Integer> get() throws Exception {
                return Single.just(++counter);
            }
        });

        for (int i = 1; i < 33; i++) {
            s.test().assertResult(i);
        }
    }",loop_control
i,"{
        for (int i = 0; i < 500; i++) {
            final PublishSubject<Integer> ps = PublishSubject.create();

            ps.singleElement().flattenAsFlowable(
            new Function<Integer, Iterable<Integer>>() {
                @Override
                public Iterable<Integer> apply(Integer v) throws Exception {
                    return Arrays.asList(1, 2, 3);
                }
            })
            .test(5L)
            .assertEmpty();
        }
    }",loop_control
i,"{
        final Integer[] a = new Integer[1000];
        Arrays.fill(a, 1);

        for (int i = 0; i < TestHelper.RACE_DEFAULT_LOOPS; i++) {
            final PublishSubject<Integer> ps = PublishSubject.create();

            ps.onNext(1);

            final TestSubscriber<Integer> ts = ps.singleElement().flattenAsFlowable(
            new Function<Integer, Iterable<Integer>>() {
                @Override
                public Iterable<Integer> apply(Integer v) throws Exception {
                    return Arrays.asList(a);
                }
            })
            .test(0L);

            Runnable r1 = new Runnable() {
                @Override
                public void run() {
                    ps.onComplete();
                    for (int i = 0; i < 500; i++) {
                        ts.request(1);
                    }
                }
            };

            Runnable r2 = new Runnable() {
                @Override
                public void run() {
                    for (int i = 0; i < 500; i++) {
                        ts.request(1);
                    }
                }
            };

            TestHelper.race(r1, r2);
        }
    }",loop_control
i,"{
        for (int i = 0; i < TestHelper.RACE_DEFAULT_LOOPS; i++) {
            final PublishSubject<Integer> ps = PublishSubject.create();

            ps.onNext(1);

            final TestSubscriber<Integer> ts = ps.singleElement().flattenAsFlowable(
            new Function<Integer, Iterable<Integer>>() {
                @Override
                public Iterable<Integer> apply(Integer v) throws Exception {
                    return Arrays.asList(1, 2, 3);
                }
            })
            .test(0L);

            Runnable r1 = new Runnable() {
                @Override
                public void run() {
                    ps.onComplete();
                }
            };

            Runnable r2 = new Runnable() {
                @Override
                public void run() {
                    ts.cancel();
                }
            };

            TestHelper.race(r1, r2);
        }
    }",loop_control
i,"{
        final Integer[] a = new Integer[1000];
        Arrays.fill(a, 1);

        for (int i = 0; i < TestHelper.RACE_DEFAULT_LOOPS; i++) {
            final PublishSubject<Integer> ps = PublishSubject.create();

            final TestSubscriber<Integer> ts = ps.singleOrError().flattenAsFlowable(new Function<Integer, Iterable<Integer>>() {
                @Override
                public Iterable<Integer> apply(Integer v) throws Exception {
                    return Arrays.asList(a);
                }
            }).test();

            Runnable r1 = new Runnable() {
                @Override
                public void run() {
                    for (int i = 0; i < 1000; i++) {
                        ts.request(1);
                    }
                }
            };

            Runnable r2 = new Runnable() {
                @Override
                public void run() {
                    ps.onNext(1);
                    ps.onComplete();
                }
            };

            TestHelper.race(r1, r2);
        }
    }",loop_control
i,"{
        List<Object> list = Arrays.asList(1);
        for (int i = 0; i < TestHelper.RACE_DEFAULT_LOOPS; i++) {

            SingleSubject<Integer> ss = SingleSubject.create();

            TestSubscriber<Object> ts = ss.flattenAsFlowable(v -> list)
            .test(0L);

            TestHelper.race(
                    () -> ss.onSuccess(1),
                    () -> ts.request(1)
            );

            ts.assertResult(1);
        }
    }",loop_control
i,"{
        for (int i = 0; i < TestHelper.RACE_DEFAULT_LOOPS; i++) {
            PublishProcessor<Integer> pp = PublishProcessor.create();

            final Single<Integer> cached = pp.single(-99).cache();

            final TestObserver<Integer> to1 = cached.test();

            Runnable r1 = new Runnable() {
                @Override
                public void run() {
                    to1.dispose();
                }
            };

            Runnable r2 = new Runnable() {
                @Override
                public void run() {
                    cached.test();
                }
            };

            TestHelper.race(r1, r2);
        }
    }",loop_control
times,"{
        PublishProcessor<Integer> pp = PublishProcessor.create();

        final String[] name = { null };

        final CountDownLatch cdl = new CountDownLatch(1);

        pp.doOnCancel(new Action() {
            @Override
            public void run() throws Exception {
                name[0] = Thread.currentThread().getName();
                cdl.countDown();
            }
        })
        .single(-99)
        .unsubscribeOn(Schedulers.single())
        .test(true)
        ;

        assertTrue(cdl.await(5, TimeUnit.SECONDS));

        int times = 10;

        while (times-- > 0 && pp.hasSubscribers()) {
            Thread.sleep(100);
        }

        assertFalse(pp.hasSubscribers());

        assertNotEquals(Thread.currentThread().getName(), name[0]);
    }",loop_control
pp,"{
        PublishProcessor<Integer> pp = PublishProcessor.create();

        final String[] name = { null };

        final CountDownLatch cdl = new CountDownLatch(1);

        pp.doOnCancel(new Action() {
            @Override
            public void run() throws Exception {
                name[0] = Thread.currentThread().getName();
                cdl.countDown();
            }
        })
        .single(-99)
        .unsubscribeOn(Schedulers.single())
        .test(true)
        ;

        assertTrue(cdl.await(5, TimeUnit.SECONDS));

        int times = 10;

        while (times-- > 0 && pp.hasSubscribers()) {
            Thread.sleep(100);
        }

        assertFalse(pp.hasSubscribers());

        assertNotEquals(Thread.currentThread().getName(), name[0]);
    }",maybe_loop_control
i,"{
        for (int i = 0; i < TestHelper.RACE_DEFAULT_LOOPS; i++) {
            PublishProcessor<Integer> pp = PublishProcessor.create();

            final Disposable[] ds = { null };
            pp.single(-99).unsubscribeOn(Schedulers.computation())
            .subscribe(new SingleObserver<Integer>() {
                @Override
                public void onSubscribe(Disposable d) {
                    ds[0] = d;
                }

                @Override
                public void onSuccess(Integer value) {

                }

                @Override
                public void onError(Throwable e) {

                }
            });

            Runnable r = new Runnable() {
                @Override
                public void run() {
                    ds[0].dispose();
                }
            };

            TestHelper.race(r, r);
        }
    }",loop_control
i,"{
        for (int i = 0; i < TestHelper.RACE_DEFAULT_LOOPS; i++) {
            List<Throwable> errors = TestHelper.trackPluginErrors();
            try {
                final PublishProcessor<Integer> pp0 = PublishProcessor.create();
                final PublishProcessor<Integer> pp1 = PublishProcessor.create();

                final TestObserver<Object> to = Single.zip(pp0.single(0), pp1.single(0), addString)
                .test();

                final TestException ex = new TestException();

                Runnable r1 = new Runnable() {
                    @Override
                    public void run() {
                        pp0.onError(ex);
                    }
                };

                Runnable r2 = new Runnable() {
                    @Override
                    public void run() {
                        pp1.onError(ex);
                    }
                };

                TestHelper.race(r1, r2);

                to.assertFailure(TestException.class);

                if (!errors.isEmpty()) {
                    TestHelper.assertUndeliverable(errors, 0, TestException.class);
                }
            } finally {
                RxJavaPlugins.reset();
            }
        }
    }",loop_control
i,"{
        for (int i = 0; i < TestHelper.RACE_DEFAULT_LOOPS; i++) {
            List<Throwable> errors = TestHelper.trackPluginErrors();

            try {

                final Subject<Integer> ps = ReplaySubject.create();
                ps.onNext(1);

                final Single<Integer> source = Single.ambArray(ps.singleOrError(), Single.<Integer>never(), Single.<Integer>never(), null);

                Runnable r1 = new Runnable() {
                    @Override
                    public void run() {
                        source.test();
                    }
                };

                Runnable r2 = new Runnable() {
                    @Override
                    public void run() {
                        ps.onComplete();
                    }
                };

                TestHelper.race(r1, r2);

                if (!errors.isEmpty()) {
                    TestHelper.assertError(errors, 0, NullPointerException.class);
                }
            } finally {
                RxJavaPlugins.reset();
            }
        }
    }",loop_control
i,"{
        for (int i = 0; i < TestHelper.RACE_DEFAULT_LOOPS; i++) {
            List<Throwable> errors = TestHelper.trackPluginErrors();

            try {

                final Subject<Integer> ps1 = PublishSubject.create();
                final Subject<Integer> ps2 = PublishSubject.create();

                Single.ambArray(ps1.singleOrError(), ps2.singleOrError()).test();

                final TestException ex = new TestException();

                Runnable r1 = new Runnable() {
                    @Override
                    public void run() {
                        ps1.onError(ex);
                    }
                };

                Runnable r2 = new Runnable() {
                    @Override
                    public void run() {
                        ps2.onError(ex);
                    }
                };

                TestHelper.race(r1, r2);

                if (!errors.isEmpty()) {
                    TestHelper.assertUndeliverable(errors, 0, TestException.class);
                }
            } finally {
                RxJavaPlugins.reset();
            }
        }
    }",loop_control
i,"{
        for (int i = 0; i < TestHelper.RACE_DEFAULT_LOOPS; i++) {
            List<Throwable> errors = TestHelper.trackPluginErrors();

            try {

                final Subject<Integer> ps1 = PublishSubject.create();
                final Subject<Integer> ps2 = PublishSubject.create();

                Single.ambArray(ps1.singleOrError(), ps2.singleOrError()).test();

                final TestException ex = new TestException();

                Runnable r1 = new Runnable() {
                    @Override
                    public void run() {
                        ps1.onNext(1);
                        ps1.onComplete();
                    }
                };

                Runnable r2 = new Runnable() {
                    @Override
                    public void run() {
                        ps2.onError(ex);
                    }
                };

                TestHelper.race(r1, r2);

                if (!errors.isEmpty()) {
                    TestHelper.assertUndeliverable(errors, 0, TestException.class);
                }
            } finally {
                RxJavaPlugins.reset();
            }
        }
    }",loop_control
i,"{
        for (int i = 0; i < TestHelper.RACE_LONG_LOOPS; i++) {
            final AtomicBoolean interrupted = new AtomicBoolean();
            final CountDownLatch cdl = new CountDownLatch(1);

            Single.ambArray(
                Single.just(1)
                    .subscribeOn(Schedulers.single())
                    .observeOn(Schedulers.computation()),
                Single.never()
            )
            .subscribe(new BiConsumer<Object, Throwable>() {
                @Override
                public void accept(Object v, Throwable e) throws Exception {
                    assertNotNull(v);
                    assertNull(e);
                    interrupted.set(Thread.currentThread().isInterrupted());
                    cdl.countDown();
                }
            });

            assertTrue(cdl.await(500, TimeUnit.SECONDS));
            assertFalse(""Interrupted!"", interrupted.get());
        }
    }",loop_control
i,"{
        final TestException ex = new TestException();
        for (int i = 0; i < TestHelper.RACE_LONG_LOOPS; i++) {
            final AtomicBoolean interrupted = new AtomicBoolean();
            final CountDownLatch cdl = new CountDownLatch(1);

            Single.ambArray(
                Single.error(ex)
                    .subscribeOn(Schedulers.single())
                    .observeOn(Schedulers.computation()),
                Single.never()
            )
            .subscribe(new BiConsumer<Object, Throwable>() {
                @Override
                public void accept(Object v, Throwable e) throws Exception {
                    assertNull(v);
                    assertNotNull(e);
                    interrupted.set(Thread.currentThread().isInterrupted());
                    cdl.countDown();
                }
            });

            assertTrue(cdl.await(500, TimeUnit.SECONDS));
            assertFalse(""Interrupted!"", interrupted.get());
        }
    }",loop_control
timeout,"{
        List<Throwable> errors = TestHelper.trackPluginErrors();
        try {
            final CountDownLatch cdl1 = new CountDownLatch(1);
            final CountDownLatch cdl2 = new CountDownLatch(1);

            TestObserver<Integer> to = Single.fromSupplier(new Supplier<Integer>() {
                @Override
                public Integer get() throws Exception {
                    cdl1.countDown();
                    cdl2.await(5, TimeUnit.SECONDS);
                    return 1;
                }
            }).subscribeOn(Schedulers.single()).test();

            assertTrue(cdl1.await(5, TimeUnit.SECONDS));

            to.dispose();

            int timeout = 10;

            while (timeout-- > 0 && errors.isEmpty()) {
                Thread.sleep(100);
            }

            TestHelper.assertUndeliverable(errors, 0, InterruptedException.class);
        } finally {
            RxJavaPlugins.reset();
        }
    }",loop_control
errors,"{
        List<Throwable> errors = TestHelper.trackPluginErrors();
        try {
            final CountDownLatch cdl1 = new CountDownLatch(1);
            final CountDownLatch cdl2 = new CountDownLatch(1);

            TestObserver<Integer> to = Single.fromSupplier(new Supplier<Integer>() {
                @Override
                public Integer get() throws Exception {
                    cdl1.countDown();
                    cdl2.await(5, TimeUnit.SECONDS);
                    return 1;
                }
            }).subscribeOn(Schedulers.single()).test();

            assertTrue(cdl1.await(5, TimeUnit.SECONDS));

            to.dispose();

            int timeout = 10;

            while (timeout-- > 0 && errors.isEmpty()) {
                Thread.sleep(100);
            }

            TestHelper.assertUndeliverable(errors, 0, InterruptedException.class);
        } finally {
            RxJavaPlugins.reset();
        }
    }",maybe_loop_control
i,"{
        for (int i = 0; i < TestHelper.RACE_DEFAULT_LOOPS; i++) {

            final PublishSubject<Integer> ps = PublishSubject.create();

            final TestObserverEx<Void> to = Completable.using(new Supplier<Object>() {
                @Override
                public Object get() throws Exception {
                    return 1;
                }
            }, new Function<Object, CompletableSource>() {
                @Override
                public CompletableSource apply(Object v) throws Exception {
                    return ps.ignoreElements();
                }
            }, new Consumer<Object>() {
                @Override
                public void accept(Object d) throws Exception {
                }
            }, true)
            .to(TestHelper.<Void>testConsumer());

            ps.onNext(1);

            Runnable r1 = new Runnable() {
                @Override
                public void run() {
                    to.dispose();
                }
            };

            Runnable r2 = new Runnable() {
                @Override
                public void run() {
                    ps.onComplete();
                }
            };

            TestHelper.race(r1, r2);
        }
    }",loop_control
i,"{
        RxJavaPlugins.setErrorHandler(Functions.emptyConsumer());
        try {
            for (int i = 0; i < TestHelper.RACE_DEFAULT_LOOPS; i++) {

                final PublishSubject<Integer> ps = PublishSubject.create();

                final TestObserver<Void> to = Completable.using(new Supplier<Object>() {
                    @Override
                    public Object get() throws Exception {
                        return 1;
                    }
                }, new Function<Object, CompletableSource>() {
                    @Override
                    public CompletableSource apply(Object v) throws Exception {
                        return ps.ignoreElements();
                    }
                }, new Consumer<Object>() {
                    @Override
                    public void accept(Object d) throws Exception {
                    }
                }, true)
                .test();

                final TestException ex = new TestException();

                Runnable r1 = new Runnable() {
                    @Override
                    public void run() {
                        to.dispose();
                    }
                };

                Runnable r2 = new Runnable() {
                    @Override
                    public void run() {
                        ps.onError(ex);
                    }
                };

                TestHelper.race(r1, r2);
            }
        } finally {
            RxJavaPlugins.reset();
        }
    }",loop_control
i,"{
        for (int i = 0; i < TestHelper.RACE_DEFAULT_LOOPS; i++) {

            final PublishSubject<Integer> ps = PublishSubject.create();

            final TestObserver<Void> to = Completable.using(new Supplier<Object>() {
                @Override
                public Object get() throws Exception {
                    return 1;
                }
            }, new Function<Object, CompletableSource>() {
                @Override
                public CompletableSource apply(Object v) throws Exception {
                    return ps.ignoreElements();
                }
            }, new Consumer<Object>() {
                @Override
                public void accept(Object d) throws Exception {

                }
            }, true)
            .test();

            Runnable r1 = new Runnable() {
                @Override
                public void run() {
                    to.dispose();
                }
            };

            Runnable r2 = new Runnable() {
                @Override
                public void run() {
                    ps.onComplete();
                }
            };

            TestHelper.race(r1, r2);
        }
    }",loop_control
i,"{
        for (int i = 0; i < TestHelper.RACE_DEFAULT_LOOPS; i++) {
            List<Throwable> errors = TestHelper.trackPluginErrors();
            try {
                final PublishSubject<Integer> ps1 = PublishSubject.create();
                final PublishSubject<Integer> ps2 = PublishSubject.create();

                TestObserver<Void> to = Completable.merge(
                        Arrays.asList(ps1.ignoreElements(), ps2.ignoreElements())).test();

                final TestException ex = new TestException();

                Runnable r1 = new Runnable() {
                    @Override
                    public void run() {
                        ps1.onError(ex);
                    }
                };
                Runnable r2 = new Runnable() {
                    @Override
                    public void run() {
                        ps2.onError(ex);
                    }
                };

                TestHelper.race(r1, r2);

                to.assertFailure(TestException.class);

                if (!errors.isEmpty()) {
                    TestHelper.assertUndeliverable(errors, 0, TestException.class);
                }
            } finally {
                RxJavaPlugins.reset();
            }
        }
    }",loop_control
s,"{
        ScheduledExecutorService exec = Executors.newSingleThreadScheduledExecutor();
        try {
            for (Scheduler s : new Scheduler[] { Schedulers.single(), Schedulers.computation(), Schedulers.newThread(), Schedulers.io(), Schedulers.from(exec, true) }) {
                final AtomicBoolean interrupted = new AtomicBoolean();
                TestObserver<Void> to = Completable.timer(1, TimeUnit.MILLISECONDS, s)
                .doOnComplete(new Action() {
                    @Override
                    public void run() throws Exception {
                        try {
                        Thread.sleep(3000);
                        } catch (InterruptedException ex) {
                            interrupted.set(true);
                        }
                    }
                })
                .test();

                Thread.sleep(500);

                to.dispose();

                Thread.sleep(500);

                assertTrue(s.getClass().getSimpleName(), interrupted.get());
            }
        } finally {
            exec.shutdown();
        }
    }",iterator
i,"{
        for (int i = 0; i < TestHelper.RACE_DEFAULT_LOOPS; i++) {
            List<Throwable> errors = TestHelper.trackPluginErrors();
            try {
                final PublishProcessor<Integer> pp1 = PublishProcessor.create();
                final PublishProcessor<Integer> pp2 = PublishProcessor.create();

                TestObserverEx<Void> to = Completable.merge(pp1.map(new Function<Integer, Completable>() {
                    @Override
                    public Completable apply(Integer v) throws Exception {
                        return pp2.ignoreElements();
                    }
                })).to(TestHelper.<Void>testConsumer());

                pp1.onNext(1);

                final Throwable ex1 = new TestException();
                final Throwable ex2 = new TestException();

                Runnable r1 = new Runnable() {
                    @Override
                    public void run() {
                        pp1.onError(ex1);
                    }
                };
                Runnable r2 = new Runnable() {
                    @Override
                    public void run() {
                        pp2.onError(ex2);
                    }
                };

                TestHelper.race(r1, r2);

                Throwable ex = to.errors().get(0);
                if (ex instanceof CompositeException) {
                    to.assertSubscribed().assertNoValues().assertNotComplete();

                    errors = TestHelper.compositeList(ex);
                    TestHelper.assertError(errors, 0, TestException.class);
                    TestHelper.assertError(errors, 1, TestException.class);
                } else {
                    to.assertFailure(TestException.class);

                    if (!errors.isEmpty()) {
                        TestHelper.assertUndeliverable(errors, 0, TestException.class);
                    }
                }
            } finally {
                RxJavaPlugins.reset();
            }
        }
    }",loop_control
i,"{
        for (int i = 0; i < TestHelper.RACE_DEFAULT_LOOPS; i++) {
            final PublishProcessor<Integer> pp1 = PublishProcessor.create();
            final PublishProcessor<Integer> pp2 = PublishProcessor.create();

            TestObserverEx<Void> to = Completable.mergeDelayError(pp1.map(new Function<Integer, Completable>() {
                @Override
                public Completable apply(Integer v) throws Exception {
                    return pp2.ignoreElements();
                }
            })).to(TestHelper.<Void>testConsumer());

            pp1.onNext(1);

            final Throwable ex1 = new TestException();

            Runnable r1 = new Runnable() {
                @Override
                public void run() {
                    pp1.onError(ex1);
                }
            };

            final Throwable ex2 = new TestException();
            Runnable r2 = new Runnable() {
                @Override
                public void run() {
                    pp2.onError(ex2);
                }
            };

            TestHelper.race(r1, r2);

            to.assertFailure(CompositeException.class);

            List<Throwable> errors = TestHelper.compositeList(to.errors().get(0));

            TestHelper.assertError(errors, 0, TestException.class);
            TestHelper.assertError(errors, 1, TestException.class);
        }
    }",loop_control
i,"{
        for (int i = 0; i < TestHelper.RACE_DEFAULT_LOOPS; i++) {
            List<Throwable> errors = TestHelper.trackPluginErrors();
            try {
                final PublishProcessor<Integer> pp1 = PublishProcessor.create();
                final PublishProcessor<Integer> pp2 = PublishProcessor.create();

                TestObserver<Void> to = Completable.mergeArray(pp1.ignoreElements(), pp2.ignoreElements()).test();

                pp1.onNext(1);

                final Throwable ex1 = new TestException();
                final Throwable ex2 = new TestException();

                Runnable r1 = new Runnable() {
                    @Override
                    public void run() {
                        pp1.onError(ex1);
                    }
                };
                Runnable r2 = new Runnable() {
                    @Override
                    public void run() {
                        pp2.onError(ex2);
                    }
                };

                TestHelper.race(r1, r2);

                to.assertFailure(TestException.class);

                if (!errors.isEmpty()) {
                    TestHelper.assertUndeliverable(errors, 0, TestException.class);
                }
            } finally {
                RxJavaPlugins.reset();
            }
        }
    }",loop_control
k,"{
        for (int k = 0; k < 100; k++) {
            final int count = 10;
            final CountDownLatch latch = new CountDownLatch(count);
            final boolean[] interrupted = {false};

            for (int i = 0; i < count; i++) {
                Completable.complete()
                        .subscribeOn(Schedulers.io())
                        .observeOn(Schedulers.io())
                        .andThen(Completable.fromAction(new Action() {
                            @Override
                            public void run() throws Exception {
                                try {
                                    Thread.sleep(30);
                                } catch (InterruptedException e) {
                                    System.out.println(""Interrupted! "" + Thread.currentThread());
                                    interrupted[0] = true;
                                }
                            }
                        }))
                        .subscribe(new Action() {
                            @Override
                            public void run() throws Exception {
                                latch.countDown();
                            }
                        });
            }

            latch.await();
            assertFalse(""The second Completable was interrupted!"", interrupted[0]);
        }
    }",loop_control
i,"{
        for (int k = 0; k < 100; k++) {
            final int count = 10;
            final CountDownLatch latch = new CountDownLatch(count);
            final boolean[] interrupted = {false};

            for (int i = 0; i < count; i++) {
                Completable.complete()
                        .subscribeOn(Schedulers.io())
                        .observeOn(Schedulers.io())
                        .andThen(Completable.fromAction(new Action() {
                            @Override
                            public void run() throws Exception {
                                try {
                                    Thread.sleep(30);
                                } catch (InterruptedException e) {
                                    System.out.println(""Interrupted! "" + Thread.currentThread());
                                    interrupted[0] = true;
                                }
                            }
                        }))
                        .subscribe(new Action() {
                            @Override
                            public void run() throws Exception {
                                latch.countDown();
                            }
                        });
            }

            latch.await();
            assertFalse(""The second Completable was interrupted!"", interrupted[0]);
        }
    }",loop_control
i,"{
        for (int i = 0; i < TestHelper.RACE_DEFAULT_LOOPS; i++) {
            List<Throwable> errors = TestHelper.trackPluginErrors();

            try {
                final TestScheduler scheduler = new TestScheduler();

                final PublishSubject<Integer> ps = PublishSubject.create();

                TestObserverEx<Void> to = ps.ignoreElements()
                        .timeout(1, TimeUnit.MILLISECONDS, scheduler, Completable.complete())
                        .to(TestHelper.<Void>testConsumer());

                final TestException ex = new TestException();

                Runnable r1 = new Runnable() {
                    @Override
                    public void run() {
                        ps.onError(ex);
                    }
                };

                Runnable r2 = new Runnable() {
                    @Override
                    public void run() {
                        scheduler.advanceTimeBy(1, TimeUnit.MILLISECONDS);
                    }
                };

                TestHelper.race(r1, r2);

                to.assertTerminated();

                if (!errors.isEmpty()) {
                    TestHelper.assertUndeliverable(errors, 0, TestException.class);
                }

            } finally {
                RxJavaPlugins.reset();
            }
        }
    }",loop_control
i,"{
        for (int i = 0; i < TestHelper.RACE_DEFAULT_LOOPS; i++) {
            PublishSubject<Integer> ps = PublishSubject.create();

            final Completable c = ps.ignoreElements().cache();

            final TestObserver<Void> to1 = new TestObserver<>();

            final TestObserver<Void> to2 = new TestObserver<>();

            Runnable r1 = new Runnable() {
                @Override
                public void run() {
                    c.subscribe(to1);
                }
            };
            Runnable r2 = new Runnable() {
                @Override
                public void run() {
                    c.subscribe(to2);
                }
            };

            TestHelper.race(r1, r2);

            ps.onComplete();

            to1.assertResult();
            to2.assertResult();
        }
    }",loop_control
i,"{
        for (int i = 0; i < TestHelper.RACE_DEFAULT_LOOPS; i++) {
            PublishSubject<Integer> ps = PublishSubject.create();

            final Completable c = ps.ignoreElements().cache();

            final TestObserver<Void> to1 = c.test();

            final TestObserver<Void> to2 = new TestObserver<>();

            Runnable r1 = new Runnable() {
                @Override
                public void run() {
                    to1.dispose();
                }
            };
            Runnable r2 = new Runnable() {
                @Override
                public void run() {
                    c.subscribe(to2);
                }
            };

            TestHelper.race(r1, r2);

            ps.onComplete();

            to1.assertEmpty();
            to2.assertResult();
        }
    }",loop_control
i,"{
        for (int i = 0; i < TestHelper.RACE_DEFAULT_LOOPS; i++) {
            List<Throwable> errors = TestHelper.trackPluginErrors();

            try {
                final PublishProcessor<Integer> pp1 = PublishProcessor.create();
                final PublishProcessor<Integer> pp2 = PublishProcessor.create();

                TestObserver<Void> to = Completable.concat(pp1.map(new Function<Integer, Completable>() {
                    @Override
                    public Completable apply(Integer v) throws Exception {
                        return pp2.ignoreElements();
                    }
                })).test();

                pp1.onNext(1);

                final TestException ex = new TestException();

                Runnable r1 = new Runnable() {
                    @Override
                    public void run() {
                        pp1.onError(ex);
                    }
                };
                Runnable r2 = new Runnable() {
                    @Override
                    public void run() {
                        pp2.onError(ex);
                    }
                };

                TestHelper.race(r1, r2);

                to.assertFailure(TestException.class);

                if (!errors.isEmpty()) {
                    TestHelper.assertUndeliverable(errors, 0, TestException.class);
                }
            } finally {
                RxJavaPlugins.reset();
            }
        }
    }",loop_control
i,"{
        Completable[] a = new Completable[1024];
        Arrays.fill(a, Completable.complete());

        for (int i = 0; i < TestHelper.RACE_DEFAULT_LOOPS; i++) {

            final Completable c = Completable.concatArray(a);

            final TestObserver<Void> to = new TestObserver<>();

            Runnable r1 = new Runnable() {
                @Override
                public void run() {
                    c.subscribe(to);
                }
            };

            Runnable r2 = new Runnable() {
                @Override
                public void run() {
                    to.dispose();
                }
            };

            TestHelper.race(r1, r2);
        }
    }",loop_control
i,"{
        Completable[] a = new Completable[1024];
        Arrays.fill(a, Completable.complete());

        for (int i = 0; i < TestHelper.RACE_DEFAULT_LOOPS; i++) {

            final Completable c = Completable.concat(Arrays.asList(a));

            final TestObserver<Void> to = new TestObserver<>();

            Runnable r1 = new Runnable() {
                @Override
                public void run() {
                    c.subscribe(to);
                }
            };

            Runnable r2 = new Runnable() {
                @Override
                public void run() {
                    to.dispose();
                }
            };

            TestHelper.race(r1, r2);
        }
    }",loop_control
k,"{
        for (int k = 0; k < 100; k++) {
            final int count = 10;
            final CountDownLatch latch = new CountDownLatch(count);
            final boolean[] interrupted = { false };

            for (int i = 0; i < count; i++) {
                Completable c0 = Completable.fromAction(new Action() {
                    @Override
                    public void run() throws Exception {
                        try {
                            Thread.sleep(30);
                        } catch (InterruptedException e) {
                            System.out.println(""Interrupted! "" + Thread.currentThread());
                            interrupted[0] = true;
                        }
                    }
                });
                Completable.concat(Arrays.asList(Completable.complete()
                    .subscribeOn(Schedulers.io())
                    .observeOn(Schedulers.io()),
                    c0)
                )
                .subscribe(new Action() {
                    @Override
                    public void run() throws Exception {
                        latch.countDown();
                    }
                });
            }

            latch.await();
            assertFalse(""The second Completable was interrupted!"", interrupted[0]);
        }
    }",loop_control
i,"{
        for (int k = 0; k < 100; k++) {
            final int count = 10;
            final CountDownLatch latch = new CountDownLatch(count);
            final boolean[] interrupted = { false };

            for (int i = 0; i < count; i++) {
                Completable c0 = Completable.fromAction(new Action() {
                    @Override
                    public void run() throws Exception {
                        try {
                            Thread.sleep(30);
                        } catch (InterruptedException e) {
                            System.out.println(""Interrupted! "" + Thread.currentThread());
                            interrupted[0] = true;
                        }
                    }
                });
                Completable.concat(Arrays.asList(Completable.complete()
                    .subscribeOn(Schedulers.io())
                    .observeOn(Schedulers.io()),
                    c0)
                )
                .subscribe(new Action() {
                    @Override
                    public void run() throws Exception {
                        latch.countDown();
                    }
                });
            }

            latch.await();
            assertFalse(""The second Completable was interrupted!"", interrupted[0]);
        }
    }",loop_control
i,"{
        List<Completable> ms = new ArrayList<>();

        for (int i = 0; i < 32; i++) {
            ms.add(Completable.never());
        }

        ms.add(Completable.complete());

        Completable.amb(ms)
        .test()
        .assertResult();
    }",loop_control
i,"{
        for (int i = 0; i < TestHelper.RACE_DEFAULT_LOOPS; i++) {
            List<Throwable> errors = TestHelper.trackPluginErrors();
            try {
                final PublishProcessor<Integer> pp0 = PublishProcessor.create();
                final PublishProcessor<Integer> pp1 = PublishProcessor.create();

                final TestObserver<Void> to = Completable.amb(Arrays.asList(pp0.ignoreElements(), pp1.ignoreElements()))
                .test();

                final TestException ex = new TestException();

                Runnable r1 = new Runnable() {
                    @Override
                    public void run() {
                        pp0.onError(ex);
                    }
                };

                Runnable r2 = new Runnable() {
                    @Override
                    public void run() {
                        pp1.onError(ex);
                    }
                };

                TestHelper.race(r1, r2);

                to.assertFailure(TestException.class);

                if (!errors.isEmpty()) {
                    TestHelper.assertUndeliverable(errors, 0, TestException.class);
                }
            } finally {
                RxJavaPlugins.reset();
            }
        }
    }",loop_control
i,"{
        for (int i = 0; i < TestHelper.RACE_DEFAULT_LOOPS; i++) {
            List<Throwable> errors = TestHelper.trackPluginErrors();

            try {

                final Subject<Integer> ps = ReplaySubject.create();
                ps.onNext(1);

                final Completable source = Completable.ambArray(ps.ignoreElements(), Completable.never(), Completable.never(), null);

                Runnable r1 = new Runnable() {
                    @Override
                    public void run() {
                        source.test();
                    }
                };

                Runnable r2 = new Runnable() {
                    @Override
                    public void run() {
                        ps.onComplete();
                    }
                };

                TestHelper.race(r1, r2);

                if (!errors.isEmpty()) {
                    TestHelper.assertError(errors, 0, NullPointerException.class);
                }
            } finally {
                RxJavaPlugins.reset();
            }
        }
    }",loop_control
i,"{
        final TestException ex = new TestException();
        for (int i = 0; i < TestHelper.RACE_LONG_LOOPS; i++) {
            final AtomicBoolean interrupted = new AtomicBoolean();
            final CountDownLatch cdl = new CountDownLatch(1);

            Completable.ambArray(
                    Completable.error(ex)
                    .subscribeOn(Schedulers.single())
                    .observeOn(Schedulers.computation()),
                    Completable.never()
            )
            .subscribe(Functions.EMPTY_ACTION, new Consumer<Throwable>() {
                @Override
                public void accept(Throwable e) throws Exception {
                    interrupted.set(Thread.currentThread().isInterrupted());
                    cdl.countDown();
                }
            });

            assertTrue(cdl.await(500, TimeUnit.SECONDS));
            assertFalse(""Interrupted!"", interrupted.get());
        }
    }",loop_control
i,"{
        for (int i = 0; i < TestHelper.RACE_LONG_LOOPS; i++) {
            final AtomicBoolean interrupted = new AtomicBoolean();
            final CountDownLatch cdl = new CountDownLatch(1);

            Completable.ambArray(
                Completable.complete()
                    .subscribeOn(Schedulers.single())
                    .observeOn(Schedulers.computation()),
                Completable.never()
            )
            .subscribe(new Action() {
                @Override
                public void run() throws Exception {
                    interrupted.set(Thread.currentThread().isInterrupted());
                    cdl.countDown();
                }
            });

            assertTrue(cdl.await(500, TimeUnit.SECONDS));
            assertFalse(""Interrupted!"", interrupted.get());
        }
    }",loop_control
arg,"{
        List<String> list = new ArrayList<>();
        for (String arg : args) {
            list.add(arg);
        }
        return list;
    }",iterator
timeout,"{
        final AtomicBoolean cancel1 = new AtomicBoolean();
        Flowable.intervalRange(1, 1000, 1, 1, TimeUnit.MILLISECONDS)
        .doOnCancel(new Action() {
            @Override
            public void run() throws Exception {
                cancel1.set(true);
            }
        })
        .window(1, TimeUnit.MILLISECONDS, Schedulers.single(), 2, true)
        .flatMap(Functions.<Flowable<Long>>identity())
        .take(500)
        .to(TestHelper.<Long>testConsumer())
        .awaitDone(5, TimeUnit.SECONDS)
        .assertSubscribed()
        .assertValueCount(500)
        .assertNoErrors()
        .assertComplete();

        int timeout = 20;
        while (timeout-- > 0 && !cancel1.get()) {
            Thread.sleep(100);
        }

        assertTrue(""intervalRange was not cancelled!"", cancel1.get());
    }",loop_control
cancel1,"{
        final AtomicBoolean cancel1 = new AtomicBoolean();
        Flowable.intervalRange(1, 1000, 1, 1, TimeUnit.MILLISECONDS)
        .doOnCancel(new Action() {
            @Override
            public void run() throws Exception {
                cancel1.set(true);
            }
        })
        .window(1, TimeUnit.MILLISECONDS, Schedulers.single(), 2, true)
        .flatMap(Functions.<Flowable<Long>>identity())
        .take(500)
        .to(TestHelper.<Long>testConsumer())
        .awaitDone(5, TimeUnit.SECONDS)
        .assertSubscribed()
        .assertValueCount(500)
        .assertNoErrors()
        .assertComplete();

        int timeout = 20;
        while (timeout-- > 0 && !cancel1.get()) {
            Thread.sleep(100);
        }

        assertTrue(""intervalRange was not cancelled!"", cancel1.get());
    }",maybe_loop_control
i,"{
        for (int i = 0; i < TestHelper.RACE_DEFAULT_LOOPS; i++) {
            TestScheduler scheduler = new TestScheduler();

            PublishProcessor<Integer> pp = PublishProcessor.create();

            TestSubscriber<Flowable<Integer>> ts = pp.window(1, TimeUnit.MINUTES, scheduler, 1)
            .test();

            TestHelper.race(
                    () -> pp.onNext(1),
                    () -> ts.cancel()
            );
        }
    }",loop_control
mode,"{
        for (BackpressureStrategy mode : BackpressureStrategy.values()) {
            Flowable.fromObservable(Observable.range(1, 5), mode)
            .test()
            .withTag(""mode: "" + mode)
            .assertResult(1, 2, 3, 4, 5);
        }
    }",iterator
i,"{
        final AtomicInteger effectCounter = new AtomicInteger();
        Flowable<Integer> source = Flowable.just(1, 2, 3, 4)
        .doOnNext(new Consumer<Integer>() {
            @Override
            public void accept(Integer v) {
                effectCounter.incrementAndGet();
                System.out.println(""Sideeffect #"" + v);
            }
        });

        Flowable<Integer> result = source.replay(
        new Function<Flowable<Integer>, Flowable<Integer>>() {
            @Override
            public Flowable<Integer> apply(Flowable<Integer> f) {
                return f.take(2);
            }
        });

        for (int i = 1; i < 3; i++) {
            effectCounter.set(0);
            System.out.printf(""- %d -%n"", i);
            result.subscribe(new Consumer<Integer>() {

                @Override
                public void accept(Integer t1) {
                    System.out.println(t1);
                }

            }, new Consumer<Throwable>() {

                @Override
                public void accept(Throwable t1) {
                    t1.printStackTrace();
                }
            },
            new Action() {
                @Override
                public void run() {
                    System.out.println(""Done"");
                }
            });
            assertEquals(2, effectCounter.get());
        }
    }",loop_control
i,"{
        Flowable<Integer> source = Flowable.range(0, 1000).replay().autoConnect();

        TestSubscriberEx<Integer> ts = new TestSubscriberEx<>();

        source.subscribe(ts);

        ts.assertNoErrors();
        ts.assertTerminated();
        List<Integer> onNextEvents = ts.values();
        assertEquals(1000, onNextEvents.size());

        for (int i = 0; i < 1000; i++) {
            assertEquals((Integer)i, onNextEvents.get(i));
        }
    }",loop_control
i,"{
        Flowable<Integer> source = Flowable.range(0, 1000).replay().autoConnect();

        TestSubscriber<Integer> ts = new TestSubscriber<>(0L);
        ts.request(10);

        source.subscribe(ts);

        ts.assertNoErrors();
        ts.assertNotComplete();
        List<Integer> onNextEvents = ts.values();
        assertEquals(10, onNextEvents.size());

        for (int i = 0; i < 10; i++) {
            assertEquals((Integer)i, onNextEvents.get(i));
        }

        ts.cancel();
    }",loop_control
i,"{
        Flowable<Integer> source = Flowable.range(1, 10000);
        for (int i = 0; i < 100; i++) {
            TestSubscriberEx<Integer> ts1 = new TestSubscriberEx<>();

            Flowable<Integer> cached = source.replay().autoConnect();

            cached.observeOn(Schedulers.computation()).subscribe(ts1);

            ts1.awaitDone(2, TimeUnit.SECONDS);
            ts1.assertNoErrors();
            ts1.assertTerminated();
            assertEquals(10000, ts1.values().size());

            TestSubscriberEx<Integer> ts2 = new TestSubscriberEx<>();
            cached.observeOn(Schedulers.computation()).subscribe(ts2);

            ts2.awaitDone(2, TimeUnit.SECONDS);
            ts2.assertNoErrors();
            ts2.assertTerminated();
            assertEquals(10000, ts2.values().size());
        }
    }",loop_control
i,"{
        Flowable<Long> source = Flowable.interval(1, 1, TimeUnit.MILLISECONDS)
                .take(1000)
                .subscribeOn(Schedulers.io());
        Flowable<Long> cached = source.replay().autoConnect();

        Flowable<Long> output = cached.observeOn(Schedulers.computation(), false, 1024);

        List<TestSubscriberEx<Long>> list = new ArrayList<>(100);
        for (int i = 0; i < 100; i++) {
            TestSubscriberEx<Long> ts = new TestSubscriberEx<>();
            list.add(ts);
            output.skip(i * 10).take(10).subscribe(ts);
        }

        List<Long> expected = new ArrayList<>();
        for (int i = 0; i < 10; i++) {
            expected.add((long)(i - 10));
        }
        int j = 0;
        for (TestSubscriberEx<Long> ts : list) {
            ts.awaitDone(3, TimeUnit.SECONDS);
            ts.assertNoErrors();
            ts.assertTerminated();

            for (int i = j * 10; i < j * 10 + 10; i++) {
                expected.set(i - j * 10, (long)i);
            }

            ts.assertValueSequence(expected);

            j++;
        }
    }",loop_control
ts,"{
        Flowable<Long> source = Flowable.interval(1, 1, TimeUnit.MILLISECONDS)
                .take(1000)
                .subscribeOn(Schedulers.io());
        Flowable<Long> cached = source.replay().autoConnect();

        Flowable<Long> output = cached.observeOn(Schedulers.computation(), false, 1024);

        List<TestSubscriberEx<Long>> list = new ArrayList<>(100);
        for (int i = 0; i < 100; i++) {
            TestSubscriberEx<Long> ts = new TestSubscriberEx<>();
            list.add(ts);
            output.skip(i * 10).take(10).subscribe(ts);
        }

        List<Long> expected = new ArrayList<>();
        for (int i = 0; i < 10; i++) {
            expected.add((long)(i - 10));
        }
        int j = 0;
        for (TestSubscriberEx<Long> ts : list) {
            ts.awaitDone(3, TimeUnit.SECONDS);
            ts.assertNoErrors();
            ts.assertTerminated();

            for (int i = j * 10; i < j * 10 + 10; i++) {
                expected.set(i - j * 10, (long)i);
            }

            ts.assertValueSequence(expected);

            j++;
        }
    }",iterator
j,"{
        Flowable<Long> source = Flowable.interval(1, 1, TimeUnit.MILLISECONDS)
                .take(1000)
                .subscribeOn(Schedulers.io());
        Flowable<Long> cached = source.replay().autoConnect();

        Flowable<Long> output = cached.observeOn(Schedulers.computation(), false, 1024);

        List<TestSubscriberEx<Long>> list = new ArrayList<>(100);
        for (int i = 0; i < 100; i++) {
            TestSubscriberEx<Long> ts = new TestSubscriberEx<>();
            list.add(ts);
            output.skip(i * 10).take(10).subscribe(ts);
        }

        List<Long> expected = new ArrayList<>();
        for (int i = 0; i < 10; i++) {
            expected.add((long)(i - 10));
        }
        int j = 0;
        for (TestSubscriberEx<Long> ts : list) {
            ts.awaitDone(3, TimeUnit.SECONDS);
            ts.assertNoErrors();
            ts.assertTerminated();

            for (int i = j * 10; i < j * 10 + 10; i++) {
                expected.set(i - j * 10, (long)i);
            }

            ts.assertValueSequence(expected);

            j++;
        }
    }",maybe_loop_control
i,"{
        final int m = 4 * 1000 * 1000;
        Flowable<Integer> firehose = Flowable.unsafeCreate(new Publisher<Integer>() {
            @Override
            public void subscribe(Subscriber<? super Integer> t) {
                t.onSubscribe(new BooleanSubscription());
                for (int i = 0; i < m; i++) {
                    t.onNext(i);
                }
                t.onComplete();
            }
        });

        TestSubscriberEx<Integer> ts = new TestSubscriberEx<>();
        firehose.replay().autoConnect().observeOn(Schedulers.computation()).takeLast(100).subscribe(ts);

        ts.awaitDone(3, TimeUnit.SECONDS);
        ts.assertNoErrors();
        ts.assertTerminated();

        assertEquals(100, ts.values().size());
    }",loop_control
i,"{
        for (int i = 0; i < TestHelper.RACE_DEFAULT_LOOPS; i++) {
            final ConnectableFlowable<Integer> cf = Flowable.range(1, 3).replay();

            Runnable r = new Runnable() {
                @Override
                public void run() {
                    cf.connect();
                }
            };

            TestHelper.race(r, r);
        }
    }",loop_control
i,"{
        for (int i = 0; i < TestHelper.RACE_DEFAULT_LOOPS; i++) {
            final ConnectableFlowable<Integer> cf = Flowable.range(1, 3).replay();

            final TestSubscriber<Integer> ts1 = new TestSubscriber<>();
            final TestSubscriber<Integer> ts2 = new TestSubscriber<>();

            Runnable r1 = new Runnable() {
                @Override
                public void run() {
                    cf.subscribe(ts1);
                }
            };

            Runnable r2 = new Runnable() {
                @Override
                public void run() {
                    cf.subscribe(ts2);
                }
            };

            TestHelper.race(r1, r2);
        }
    }",loop_control
i,"{
        for (int i = 0; i < TestHelper.RACE_DEFAULT_LOOPS; i++) {
            final ConnectableFlowable<Integer> cf = Flowable.range(1, 3).replay();

            final TestSubscriber<Integer> ts1 = new TestSubscriber<>();
            final TestSubscriber<Integer> ts2 = new TestSubscriber<>();

            cf.subscribe(ts1);

            Runnable r1 = new Runnable() {
                @Override
                public void run() {
                    ts1.cancel();
                }
            };

            Runnable r2 = new Runnable() {
                @Override
                public void run() {
                    cf.subscribe(ts2);
                }
            };

            TestHelper.race(r1, r2);
        }
    }",loop_control
i,"{
        for (int i = 0; i < TestHelper.RACE_DEFAULT_LOOPS; i++) {
            final PublishProcessor<Integer> pp = PublishProcessor.create();

            final ConnectableFlowable<Integer> cf = pp.replay();

            final TestSubscriber<Integer> ts1 = new TestSubscriber<>();

            Runnable r1 = new Runnable() {
                @Override
                public void run() {
                    cf.subscribe(ts1);
                }
            };

            Runnable r2 = new Runnable() {
                @Override
                public void run() {
                    for (int j = 0; j < 1000; j++) {
                        pp.onNext(j);
                    }
                }
            };

            TestHelper.race(r1, r2);
        }
    }",loop_control
i,"{
        for (int i = 0; i < TestHelper.RACE_DEFAULT_LOOPS; i++) {
            final PublishProcessor<Integer> pp = PublishProcessor.create();

            final ConnectableFlowable<Integer> cf = pp.replay();

            final TestSubscriber<Integer> ts1 = new TestSubscriber<>();

            cf.subscribe(ts1);

            Runnable r1 = new Runnable() {
                @Override
                public void run() {
                    ts1.cancel();
                }
            };

            Runnable r2 = new Runnable() {
                @Override
                public void run() {
                    for (int j = 0; j < 1000; j++) {
                        pp.onNext(j);
                    }
                }
            };

            TestHelper.race(r1, r2);
        }
    }",loop_control
j,"{
        for (int i = 0; i < TestHelper.RACE_DEFAULT_LOOPS; i++) {
            final PublishProcessor<Integer> pp = PublishProcessor.create();

            final ConnectableFlowable<Integer> cf = pp.replay();

            final TestSubscriber<Integer> ts1 = new TestSubscriber<>();

            cf.subscribe(ts1);

            Runnable r1 = new Runnable() {
                @Override
                public void run() {
                    ts1.cancel();
                }
            };

            Runnable r2 = new Runnable() {
                @Override
                public void run() {
                    for (int j = 0; j < 1000; j++) {
                        pp.onNext(j);
                    }
                }
            };

            TestHelper.race(r1, r2);
        }
    }",loop_control
i,"{
        for (int i = 0; i < TestHelper.RACE_DEFAULT_LOOPS; i++) {
            final ConnectableFlowable<Integer> cf = Flowable.range(1, 1000).replay();

            final TestSubscriber<Integer> ts1 = new TestSubscriber<>();

            cf.connect();

            Runnable r1 = new Runnable() {
                @Override
                public void run() {
                    cf.subscribe(ts1);
                }
            };

            Runnable r2 = new Runnable() {
                @Override
                public void run() {
                    ts1.cancel();
                }
            };

            TestHelper.race(r1, r2);
        }
    }",loop_control
current,"{
        int previous = 0;
        for (Integer current : ts.values()) {
            Assert.assertTrue(""The sequence must be increasing [current value="" + previous +
                    "", previous value="" + current + ""]"", previous <= current);
            previous = current;
        }
    }",iterator
i,"{
        TestSubscriberEx<Long> ts = createDelayedSubscriber();
        int m = 100000;
        Flowable.rangeLong(1, m)
                .subscribeOn(Schedulers.computation())
                .onBackpressureReduce(Long::sum)
                .observeOn(Schedulers.io())
                .subscribe(ts);

        ts.awaitDone(2, TimeUnit.SECONDS);
        ts.assertTerminated();
        assertValuesDropped(ts, m);
        long sum = 0;
        for (Long i : ts.values()) {
            sum += i;
        }
        //sum = (A1 + An) * n / 2 = 100_001 * 50_000 = 50_000_00000 + 50_000 = 50_000_50_000
        Assert.assertEquals(""Wrong sum: "" + sum, 5000050000L, sum);
    }",iterator
ts,"{
        final TestSubscriber<Object> ts = new TestSubscriber<>();
        final Subscriber[] s = { null };

        Schedulers.single().scheduleDirect(new Runnable() {
            @SuppressWarnings(""unchecked"")
            @Override
            public void run() {
                ts.cancel();
                s[0].onNext(1);
            }
        }, 200, TimeUnit.MILLISECONDS);

        new Flowable<Integer>() {
            @Override
            protected void subscribeActual(Subscriber<? super Integer> subscriber) {
                subscriber.onSubscribe(new BooleanSubscription());
                s[0] = subscriber;
            }
        }.blockingSubscribe(ts);

        while (!ts.isCancelled()) {
            Thread.sleep(100);
        }

        ts.assertEmpty();
    }",maybe_loop_control
i,"{
        for (int i = 0; i < TestHelper.RACE_DEFAULT_LOOPS; i++) {
            final TestSubscriber<Integer> ts = new TestSubscriber<>();

            final PublishProcessor<Integer> pp = PublishProcessor.create();

            final Runnable r1 = new Runnable() {
                @Override
                public void run() {
                    ts.cancel();
                }
            };

            final Runnable r2 = new Runnable() {
                @Override
                public void run() {
                    pp.onNext(1);
                }
            };

            final AtomicInteger c = new AtomicInteger(2);

            Schedulers.computation().scheduleDirect(new Runnable() {
                @Override
                public void run() {
                    c.decrementAndGet();
                    while (c.get() != 0 && !pp.hasSubscribers()) { }

                    TestHelper.race(r1, r2);
                }
            });

            c.decrementAndGet();
            while (c.get() != 0) { }

            pp
            .blockingSubscribe(ts);
        }
    }",loop_control
c,"{
        for (int i = 0; i < TestHelper.RACE_DEFAULT_LOOPS; i++) {
            final TestSubscriber<Integer> ts = new TestSubscriber<>();

            final PublishProcessor<Integer> pp = PublishProcessor.create();

            final Runnable r1 = new Runnable() {
                @Override
                public void run() {
                    ts.cancel();
                }
            };

            final Runnable r2 = new Runnable() {
                @Override
                public void run() {
                    pp.onNext(1);
                }
            };

            final AtomicInteger c = new AtomicInteger(2);

            Schedulers.computation().scheduleDirect(new Runnable() {
                @Override
                public void run() {
                    c.decrementAndGet();
                    while (c.get() != 0 && !pp.hasSubscribers()) { }

                    TestHelper.race(r1, r2);
                }
            });

            c.decrementAndGet();
            while (c.get() != 0) { }

            pp
            .blockingSubscribe(ts);
        }
    }",maybe_loop_control
pp,"{
        for (int i = 0; i < TestHelper.RACE_DEFAULT_LOOPS; i++) {
            final TestSubscriber<Integer> ts = new TestSubscriber<>();

            final PublishProcessor<Integer> pp = PublishProcessor.create();

            final Runnable r1 = new Runnable() {
                @Override
                public void run() {
                    ts.cancel();
                }
            };

            final Runnable r2 = new Runnable() {
                @Override
                public void run() {
                    pp.onNext(1);
                }
            };

            final AtomicInteger c = new AtomicInteger(2);

            Schedulers.computation().scheduleDirect(new Runnable() {
                @Override
                public void run() {
                    c.decrementAndGet();
                    while (c.get() != 0 && !pp.hasSubscribers()) { }

                    TestHelper.race(r1, r2);
                }
            });

            c.decrementAndGet();
            while (c.get() != 0) { }

            pp
            .blockingSubscribe(ts);
        }
    }",maybe_loop_control
c,"{
        for (int i = 0; i < TestHelper.RACE_DEFAULT_LOOPS; i++) {
            final TestSubscriber<Integer> ts = new TestSubscriber<>();

            final PublishProcessor<Integer> pp = PublishProcessor.create();

            final Runnable r1 = new Runnable() {
                @Override
                public void run() {
                    ts.cancel();
                }
            };

            final Runnable r2 = new Runnable() {
                @Override
                public void run() {
                    pp.onNext(1);
                }
            };

            final AtomicInteger c = new AtomicInteger(2);

            Schedulers.computation().scheduleDirect(new Runnable() {
                @Override
                public void run() {
                    c.decrementAndGet();
                    while (c.get() != 0 && !pp.hasSubscribers()) { }

                    TestHelper.race(r1, r2);
                }
            });

            c.decrementAndGet();
            while (c.get() != 0) { }

            pp
            .blockingSubscribe(ts);
        }
    }",maybe_loop_control
i,"{
        Flowable<Integer> src = Flowable.range(1, 10).skipWhile(LESS_THAN_FIVE);
        int n = 5;
        for (int i = 0; i < n; i++) {
            Subscriber<Object> subscriber = TestHelper.mockSubscriber();
            InOrder inOrder = inOrder(subscriber);

            src.subscribe(subscriber);

            for (int j = 5; j < 10; j++) {
                inOrder.verify(subscriber).onNext(j);
            }
            inOrder.verify(subscriber).onComplete();
            verify(subscriber, never()).onError(any(Throwable.class));
        }
    }",loop_control
j,"{
        Flowable<Integer> src = Flowable.range(1, 10).skipWhile(LESS_THAN_FIVE);
        int n = 5;
        for (int i = 0; i < n; i++) {
            Subscriber<Object> subscriber = TestHelper.mockSubscriber();
            InOrder inOrder = inOrder(subscriber);

            src.subscribe(subscriber);

            for (int j = 5; j < 10; j++) {
                inOrder.verify(subscriber).onNext(j);
            }
            inOrder.verify(subscriber).onComplete();
            verify(subscriber, never()).onError(any(Throwable.class));
        }
    }",loop_control
s,"{
        ScheduledExecutorService exec = Executors.newSingleThreadScheduledExecutor();
        try {
            for (Scheduler s : new Scheduler[] { Schedulers.single(), Schedulers.computation(), Schedulers.newThread(), Schedulers.io(), Schedulers.from(exec) }) {
                final TestSubscriber<Boolean> ts = TestSubscriber.create();
                ts.withTag(s.getClass().getSimpleName());

                Flowable.<Boolean>create(new FlowableOnSubscribe<Boolean>() {
                    @Override
                    public void subscribe(FlowableEmitter<Boolean> emitter) throws Exception {
                      emitter.onNext(Thread.interrupted());
                      emitter.onComplete();
                    }
                }, BackpressureStrategy.MISSING)
                .delaySubscription(100, TimeUnit.MILLISECONDS, s)
                .subscribe(ts);

                ts.awaitDone(5, TimeUnit.SECONDS);
                ts.assertValue(false);
            }
        } finally {
            exec.shutdown();
        }
    }",iterator
i,"{
        for (int i = 0; i < TestHelper.RACE_DEFAULT_LOOPS; i++) {
            final TestSubscriber<Integer> ts = Flowable.range(1, 10)
                    .take(5)
                    .test(0L);

            Runnable r = new Runnable() {
                @Override
                public void run() {
                    ts.request(3);
                }
            };

            TestHelper.race(r, r);

            ts.assertResult(1, 2, 3, 4, 5);
        }
    }",loop_control
i,"{
        for (int i = 0; i < TestHelper.RACE_LONG_LOOPS; i++) {

            final MulticastProcessor<Integer> mp = new MulticastProcessor<>(128, true);

            final MulticastSubscription<Integer> ms1 = new MulticastSubscription<>(null, mp);
            final MulticastSubscription<Integer> ms2 = new MulticastSubscription<>(null, mp);

            assertTrue(mp.add(ms1));

            Runnable r1 = new Runnable() {
                @Override
                public void run() {
                    mp.remove(ms1);
                }
            };

            Runnable r2 = new Runnable() {
                @Override
                public void run() {
                    mp.add(ms2);
                }
            };

            TestHelper.race(r1, r2);
        }
    }",loop_control
i,"{
        // https://github.com/Netflix/RxJava/issues/1451
        final int expectedCount = 3;
        final AtomicInteger count = new AtomicInteger();
        for (int i = 0; i < expectedCount; i++) {
            Flowable
                    .just(Boolean.TRUE, Boolean.FALSE)
                    .takeWhile(new Predicate<Boolean>() {
                        @Override
                        public boolean test(Boolean value) {
                            return value;
                        }
                    })
                    .toList()
                    .doOnSuccess(new Consumer<List<Boolean>>() {
                        @Override
                        public void accept(List<Boolean> booleans) {
                            count.incrementAndGet();
                        }
                    })
                    .subscribe();
        }
        assertEquals(expectedCount, count.get());
    }",loop_control
i,"{
        // https://github.com/Netflix/RxJava/issues/1451
        final int expectedCount = 3;
        final AtomicInteger count = new AtomicInteger();
        for (int i = 0; i < expectedCount; i++) {
            Flowable
                    .just(Boolean.TRUE, Boolean.FALSE, Boolean.FALSE)
                    .takeWhile(new Predicate<Boolean>() {
                        @Override
                        public boolean test(Boolean value) {
                            return value;
                        }
                    })
                    .toList()
                    .doOnSuccess(new Consumer<List<Boolean>>() {
                        @Override
                        public void accept(List<Boolean> booleans) {
                            count.incrementAndGet();
                        }
                    })
                    .subscribe();
        }
        assertEquals(expectedCount, count.get());
    }",loop_control
value,"{
        return Flowable.unsafeCreate(new Publisher<String>() {

            @Override
            public void subscribe(final Subscriber<? super String> subscriber) {
                final CompositeDisposable parentSubscription = new CompositeDisposable();

                subscriber.onSubscribe(new Subscription() {
                    @Override
                    public void request(long n) {

                    }

                    @Override
                    public void cancel() {
                        parentSubscription.dispose();
                    }
                });

                long delay = interval;
                for (final String value : values) {
                    parentSubscription.add(innerScheduler.schedule(new Runnable() {
                        @Override
                        public void run() {
                            subscriber.onNext(value);
                        }
                    }
                    , delay, TimeUnit.MILLISECONDS));
                    delay += interval;
                }
                parentSubscription.add(innerScheduler.schedule(new Runnable() {
                    @Override
                    public void run() {
                            if (e == null) {
                                subscriber.onComplete();
                            } else {
                                subscriber.onError(e);
                            }
                    }
                }, delay, TimeUnit.MILLISECONDS));
            }
        });
    }",iterator
i,"{
        for (int i = 0; i < TestHelper.RACE_DEFAULT_LOOPS; i++) {
            final PublishProcessor<Integer> pp1 = PublishProcessor.create();
            final PublishProcessor<Integer> pp2 = PublishProcessor.create();

            TestSubscriberEx<Integer> ts = Flowable.ambArray(pp1, pp2).to(TestHelper.<Integer>testConsumer());

            Runnable r1 = new Runnable() {
                @Override
                public void run() {
                    pp1.onNext(1);
                }
            };
            Runnable r2 = new Runnable() {
                @Override
                public void run() {
                    pp2.onNext(1);
                }
            };

            TestHelper.race(r1, r2);

            ts.assertSubscribed().assertNoErrors()
            .assertNotComplete().assertValueCount(1);
        }
    }",loop_control
i,"{
        for (int i = 0; i < TestHelper.RACE_DEFAULT_LOOPS; i++) {
            final PublishProcessor<Integer> pp1 = PublishProcessor.create();
            final PublishProcessor<Integer> pp2 = PublishProcessor.create();

            TestSubscriber<Integer> ts = Flowable.ambArray(pp1, pp2).test();

            Runnable r1 = new Runnable() {
                @Override
                public void run() {
                    pp1.onComplete();
                }
            };
            Runnable r2 = new Runnable() {
                @Override
                public void run() {
                    pp2.onComplete();
                }
            };

            TestHelper.race(r1, r2);

            ts.assertResult();
        }
    }",loop_control
i,"{
        for (int i = 0; i < TestHelper.RACE_DEFAULT_LOOPS; i++) {
            final PublishProcessor<Integer> pp1 = PublishProcessor.create();
            final PublishProcessor<Integer> pp2 = PublishProcessor.create();

            TestSubscriber<Integer> ts = Flowable.ambArray(pp1, pp2).test();

            final Throwable ex = new TestException();

            Runnable r1 = new Runnable() {
                @Override
                public void run() {
                    pp1.onError(ex);
                }
            };
            Runnable r2 = new Runnable() {
                @Override
                public void run() {
                    pp2.onError(ex);
                }
            };

            List<Throwable> errors = TestHelper.trackPluginErrors();
            try {
                TestHelper.race(r1, r2);
            } finally {
                RxJavaPlugins.reset();
            }

            ts.assertFailure(TestException.class);
            if (!errors.isEmpty()) {
                TestHelper.assertUndeliverable(errors, 0, TestException.class);
            }
        }
    }",loop_control
i,"{
        for (int i = 0; i < TestHelper.RACE_LONG_LOOPS; i++) {
            final AtomicBoolean interrupted = new AtomicBoolean();
            final CountDownLatch cdl = new CountDownLatch(1);

            Flowable.ambArray(
                Flowable.just(1)
                    .subscribeOn(Schedulers.single())
                    .observeOn(Schedulers.computation()),
                Flowable.never()
            )
            .subscribe(new Consumer<Object>() {
                @Override
                public void accept(Object v) throws Exception {
                    interrupted.set(Thread.currentThread().isInterrupted());
                    cdl.countDown();
                }
            });

            assertTrue(cdl.await(500, TimeUnit.SECONDS));
            assertFalse(""Interrupted!"", interrupted.get());
        }
    }",loop_control
i,"{
        final TestException ex = new TestException();
        for (int i = 0; i < TestHelper.RACE_LONG_LOOPS; i++) {
            final AtomicBoolean interrupted = new AtomicBoolean();
            final CountDownLatch cdl = new CountDownLatch(1);

            Flowable.ambArray(
                Flowable.error(ex)
                    .subscribeOn(Schedulers.single())
                    .observeOn(Schedulers.computation()),
                Flowable.never()
            )
            .subscribe(Functions.emptyConsumer(), new Consumer<Throwable>() {
                @Override
                public void accept(Throwable e) throws Exception {
                    interrupted.set(Thread.currentThread().isInterrupted());
                    cdl.countDown();
                }
            });

            assertTrue(cdl.await(500, TimeUnit.SECONDS));
            assertFalse(""Interrupted!"", interrupted.get());
        }
    }",loop_control
i,"{
        for (int i = 0; i < TestHelper.RACE_LONG_LOOPS; i++) {
            final AtomicBoolean interrupted = new AtomicBoolean();
            final CountDownLatch cdl = new CountDownLatch(1);

            Flowable.ambArray(
                Flowable.empty()
                    .subscribeOn(Schedulers.single())
                    .observeOn(Schedulers.computation()),
                Flowable.never()
            )
            .subscribe(Functions.emptyConsumer(), Functions.emptyConsumer(), new Action() {
                @Override
                public void run() throws Exception {
                    interrupted.set(Thread.currentThread().isInterrupted());
                    cdl.countDown();
                }
            });

            assertTrue(cdl.await(500, TimeUnit.SECONDS));
            assertFalse(""Interrupted!"", interrupted.get());
        }
    }",loop_control
i,"{
        for (int i = 0; i < TestHelper.RACE_DEFAULT_LOOPS; i++) {
            final TestScheduler scheduler = new TestScheduler();

            final PublishProcessor<Integer> pp = PublishProcessor.create();

            TestSubscriber<Integer> ts = pp.sample(1, TimeUnit.SECONDS, scheduler, true)
            .test();

            pp.onNext(1);

            Runnable r1 = new Runnable() {
                @Override
                public void run() {
                    pp.onComplete();
                }
            };

            Runnable r2 = new Runnable() {
                @Override
                public void run() {
                    scheduler.advanceTimeBy(1, TimeUnit.SECONDS);
                }
            };

            TestHelper.race(r1, r2);

            ts.assertResult(1);
        }
    }",loop_control
i,"{
        for (int i = 0; i < TestHelper.RACE_DEFAULT_LOOPS; i++) {
            final PublishProcessor<Integer> pp = PublishProcessor.create();
            final PublishProcessor<Integer> sampler = PublishProcessor.create();

            TestSubscriber<Integer> ts = pp.sample(sampler, true)
            .test();

            pp.onNext(1);

            Runnable r1 = new Runnable() {
                @Override
                public void run() {
                    pp.onComplete();
                }
            };

            Runnable r2 = new Runnable() {
                @Override
                public void run() {
                    sampler.onNext(1);
                }
            };

            TestHelper.race(r1, r2);

            ts.assertResult(1);
        }
    }",loop_control
i,"{
        for (int i = 0; i < TestHelper.RACE_DEFAULT_LOOPS; i++) {
            final PublishProcessor<Integer> pp = PublishProcessor.create();
            final PublishProcessor<Integer> sampler = PublishProcessor.create();

            TestSubscriber<Integer> ts = pp.sample(sampler, true).test();

            pp.onNext(1);

            Runnable r1 = new Runnable() {
                @Override
                public void run() {
                    pp.onComplete();
                }
            };

            Runnable r2 = new Runnable() {
                @Override
                public void run() {
                    sampler.onComplete();
                }
            };

            TestHelper.race(r1, r2);

            ts.assertResult(1);
        }
    }",loop_control
i,"{
        for (int i = 0; i < 10000; i++) {
            final PublishProcessor<Integer> pp = PublishProcessor.create();
            final SingleSubject<Integer> cs = SingleSubject.create();

            TestSubscriber<Integer> ts = pp.mergeWith(cs).test();

            Runnable r1 = new Runnable() {
                @Override
                public void run() {
                    pp.onNext(1);
                    pp.onComplete();
                }
            };

            Runnable r2 = new Runnable() {
                @Override
                public void run() {
                    cs.onSuccess(1);
                }
            };

            TestHelper.race(r1, r2);

            ts.assertResult(1, 1);
        }
    }",loop_control
i,"{
        for (int i = 0; i < 10000; i++) {
            final PublishProcessor<Integer> pp = PublishProcessor.create();
            final SingleSubject<Integer> cs = SingleSubject.create();

            final TestSubscriber<Integer> ts = pp.mergeWith(cs).subscribeWith(new TestSubscriber<>(0));

            Runnable r1 = new Runnable() {
                @Override
                public void run() {
                    cs.onSuccess(1);
                }
            };

            Runnable r2 = new Runnable() {
                @Override
                public void run() {
                    ts.request(2);
                }
            };

            TestHelper.race(r1, r2);

            pp.onNext(2);
            pp.onComplete();

            ts.assertResult(1, 2);
        }
    }",loop_control
i,"{
        for (int i = 0; i < 10000; i++) {
            final PublishProcessor<Integer> pp = PublishProcessor.create();
            final SingleSubject<Integer> cs = SingleSubject.create();

            final TestSubscriber<Integer> ts = pp.mergeWith(cs).test(0);

            pp.onNext(0);

            Runnable r1 = new Runnable() {
                @Override
                public void run() {
                    pp.onNext(1);
                }
            };

            Runnable r2 = new Runnable() {
                @Override
                public void run() {
                    ts.request(3);
                }
            };

            TestHelper.race(r1, r2);

            cs.onSuccess(1);
            pp.onComplete();

            ts.assertResult(0, 1, 1);
        }
    }",loop_control
i,"{
        final PublishProcessor<Integer> pp = PublishProcessor.create();
        final SingleSubject<Integer> cs = SingleSubject.create();

        TestSubscriber<Integer> ts = pp.mergeWith(cs)
                .subscribeWith(new TestSubscriber<Integer>() {
            @Override
            public void onNext(Integer t) {
                super.onNext(t);
                if (t == 1) {
                    for (int i = 0; i < Flowable.bufferSize() - 1; i++) {
                        pp.onNext(i + 2);
                    }
                }
            }
        });

        cs.onSuccess(1);

        pp.onComplete();

        ts.request(2);
        ts.assertValueCount(Flowable.bufferSize());
        ts.assertComplete();
    }",loop_control
timeout,"{
        List<Throwable> errors = TestHelper.trackPluginErrors();
        try {
            final CountDownLatch cdl1 = new CountDownLatch(1);
            final CountDownLatch cdl2 = new CountDownLatch(1);

            TestSubscriber<Object> ts = Flowable.fromCompletable(Completable.fromAction(new Action() {
                @Override
                public void run() throws Exception {
                    cdl1.countDown();
                    cdl2.await(5, TimeUnit.SECONDS);
                }
            }))
            .subscribeOn(Schedulers.single()).test();

            assertTrue(cdl1.await(5, TimeUnit.SECONDS));

            ts.cancel();

            int timeout = 10;

            while (timeout-- > 0 && errors.isEmpty()) {
                Thread.sleep(100);
            }

            TestHelper.assertUndeliverable(errors, 0, InterruptedException.class);
        } finally {
            RxJavaPlugins.reset();
        }
    }",loop_control
errors,"{
        List<Throwable> errors = TestHelper.trackPluginErrors();
        try {
            final CountDownLatch cdl1 = new CountDownLatch(1);
            final CountDownLatch cdl2 = new CountDownLatch(1);

            TestSubscriber<Object> ts = Flowable.fromCompletable(Completable.fromAction(new Action() {
                @Override
                public void run() throws Exception {
                    cdl1.countDown();
                    cdl2.await(5, TimeUnit.SECONDS);
                }
            }))
            .subscribeOn(Schedulers.single()).test();

            assertTrue(cdl1.await(5, TimeUnit.SECONDS));

            ts.cancel();

            int timeout = 10;

            while (timeout-- > 0 && errors.isEmpty()) {
                Thread.sleep(100);
            }

            TestHelper.assertUndeliverable(errors, 0, InterruptedException.class);
        } finally {
            RxJavaPlugins.reset();
        }
    }",maybe_loop_control
i,"{
        PublishProcessor<Integer> source = PublishProcessor.create();
        final List<PublishProcessor<Integer>> delays = new ArrayList<>();
        final int n = 10;
        for (int i = 0; i < n; i++) {
            PublishProcessor<Integer> delay = PublishProcessor.create();
            delays.add(delay);
        }

        Function<Integer, Flowable<Integer>> delayFunc = new Function<Integer, Flowable<Integer>>() {
            @Override
            public Flowable<Integer> apply(Integer t1) {
                return delays.get(t1);
            }
        };

        Subscriber<Object> subscriber = TestHelper.mockSubscriber();
        InOrder inOrder = inOrder(subscriber);

        source.delay(delayFunc).subscribe(subscriber);

        for (int i = 0; i < n; i++) {
            source.onNext(i);
            delays.get(i).onNext(i);
            inOrder.verify(subscriber).onNext(i);
        }
        source.onComplete();

        inOrder.verify(subscriber).onComplete();
        inOrder.verifyNoMoreInteractions();

        verify(subscriber, never()).onError(any(Throwable.class));
    }",loop_control
i,"{
        int n = 3;

        PublishProcessor<Integer> source = PublishProcessor.create();
        final List<PublishProcessor<Integer>> subjects = new ArrayList<>();
        for (int i = 0; i < n; i++) {
            subjects.add(PublishProcessor.<Integer> create());
        }

        Flowable<Integer> result = source.delay(new Function<Integer, Flowable<Integer>>() {

            @Override
            public Flowable<Integer> apply(Integer t1) {
                return subjects.get(t1);
            }
        });

        Subscriber<Object> subscriber = TestHelper.mockSubscriber();
        InOrder inOrder = inOrder(subscriber);

        result.subscribe(subscriber);

        for (int i = 0; i < n; i++) {
            source.onNext(i);
        }
        source.onComplete();

        inOrder.verify(subscriber, never()).onNext(anyInt());
        inOrder.verify(subscriber, never()).onComplete();

        for (int i = n - 1; i >= 0; i--) {
            subjects.get(i).onComplete();
            inOrder.verify(subscriber).onNext(i);
        }

        inOrder.verify(subscriber).onComplete();

        verify(subscriber, never()).onError(any(Throwable.class));
    }",loop_control
i,"{
        Integer[] array = new Integer[n];
        for (int i = 0; i < n; i++) {
            array[i] = i;
        }
        return Flowable.fromArray(array);
    }",loop_control
i,"{
        Flowable<Integer> just = Flowable.just(1);
        int n = 1000;
        for (int i = 0; i < TestHelper.RACE_DEFAULT_LOOPS; i++) {
            PublishProcessor<Flowable<Integer>> source = PublishProcessor.create();

            TestSubscriber<Integer> ts = source
                    .concatMap(v -> v, n + 1)
                    .test(1L);

            TestHelper.race(() -> {
                for (int j = 0; j < n; j++) {
                    source.onNext(just);
                }
            }, () -> {
                for (int j = 0; j < n; j++) {
                    ts.request(1);
                }
            });

            ts.assertValueCount(n);
        }
    }",loop_control
j,"{
        Flowable<Integer> just = Flowable.just(1);
        int n = 1000;
        for (int i = 0; i < TestHelper.RACE_DEFAULT_LOOPS; i++) {
            PublishProcessor<Flowable<Integer>> source = PublishProcessor.create();

            TestSubscriber<Integer> ts = source
                    .concatMap(v -> v, n + 1)
                    .test(1L);

            TestHelper.race(() -> {
                for (int j = 0; j < n; j++) {
                    source.onNext(just);
                }
            }, () -> {
                for (int j = 0; j < n; j++) {
                    ts.request(1);
                }
            });

            ts.assertValueCount(n);
        }
    }",loop_control
i,"{
        Flowable<Integer> just = Flowable.just(1);
        int n = 1000;
        for (int i = 0; i < TestHelper.RACE_DEFAULT_LOOPS; i++) {
            PublishProcessor<Flowable<Integer>> source = PublishProcessor.create();

            TestSubscriber<Integer> ts = source
                    .concatMapDelayError(v -> v, true, n + 1)
                    .test(1L);

            TestHelper.race(() -> {
                for (int j = 0; j < n; j++) {
                    source.onNext(just);
                }
            }, () -> {
                for (int j = 0; j < n; j++) {
                    ts.request(1);
                }
            });

            ts.assertValueCount(n);
        }
    }",loop_control
j,"{
        Flowable<Integer> just = Flowable.just(1);
        int n = 1000;
        for (int i = 0; i < TestHelper.RACE_DEFAULT_LOOPS; i++) {
            PublishProcessor<Flowable<Integer>> source = PublishProcessor.create();

            TestSubscriber<Integer> ts = source
                    .concatMapDelayError(v -> v, true, n + 1)
                    .test(1L);

            TestHelper.race(() -> {
                for (int j = 0; j < n; j++) {
                    source.onNext(just);
                }
            }, () -> {
                for (int j = 0; j < n; j++) {
                    ts.request(1);
                }
            });

            ts.assertValueCount(n);
        }
    }",loop_control
i,"{
        for (int i = 0; i < 10000; i++) {
            final PublishProcessor<Integer> pp = PublishProcessor.create();
            final MaybeSubject<Integer> cs = MaybeSubject.create();

            TestSubscriber<Integer> ts = pp.mergeWith(cs).test();

            Runnable r1 = new Runnable() {
                @Override
                public void run() {
                    pp.onNext(1);
                    pp.onComplete();
                }
            };

            Runnable r2 = new Runnable() {
                @Override
                public void run() {
                    cs.onSuccess(1);
                }
            };

            TestHelper.race(r1, r2);

            ts.assertResult(1, 1);
        }
    }",loop_control
i,"{
        for (int i = 0; i < 10000; i++) {
            final PublishProcessor<Integer> pp = PublishProcessor.create();
            final MaybeSubject<Integer> cs = MaybeSubject.create();

            final TestSubscriber<Integer> ts = pp.mergeWith(cs).subscribeWith(new TestSubscriber<>(0));

            Runnable r1 = new Runnable() {
                @Override
                public void run() {
                    cs.onSuccess(1);
                }
            };

            Runnable r2 = new Runnable() {
                @Override
                public void run() {
                    ts.request(2);
                }
            };

            TestHelper.race(r1, r2);

            pp.onNext(2);
            pp.onComplete();

            ts.assertResult(1, 2);
        }
    }",loop_control
i,"{
        for (int i = 0; i < 10000; i++) {
            final PublishProcessor<Integer> pp = PublishProcessor.create();
            final MaybeSubject<Integer> cs = MaybeSubject.create();

            final TestSubscriber<Integer> ts = pp.mergeWith(cs).test(0);

            pp.onNext(0);

            Runnable r1 = new Runnable() {
                @Override
                public void run() {
                    pp.onNext(1);
                }
            };

            Runnable r2 = new Runnable() {
                @Override
                public void run() {
                    ts.request(3);
                }
            };

            TestHelper.race(r1, r2);

            cs.onSuccess(1);
            pp.onComplete();

            ts.assertResult(0, 1, 1);
        }
    }",loop_control
i,"{
        final PublishProcessor<Integer> pp = PublishProcessor.create();
        final MaybeSubject<Integer> cs = MaybeSubject.create();

        TestSubscriber<Integer> ts = pp.mergeWith(cs)
                .subscribeWith(new TestSubscriber<Integer>() {
            @Override
            public void onNext(Integer t) {
                super.onNext(t);
                if (t == 1) {
                    for (int i = 0; i < Flowable.bufferSize() - 1; i++) {
                        pp.onNext(i + 2);
                    }
                }
            }
        });

        cs.onSuccess(1);

        pp.onComplete();

        ts.request(2);
        ts.assertValueCount(Flowable.bufferSize());
        ts.assertComplete();
    }",loop_control
i,"{
        ArrayList<Integer> list = new ArrayList<>(Flowable.bufferSize() * 2);
        for (int i = 1; i <= Flowable.bufferSize() * 2 + 1; i++) {
            list.add(i);
        }

        Flowable<Integer> f = Flowable.range(1, list.size());

        TestSubscriberEx<Integer> ts = new TestSubscriberEx<>(0L);

        ts.assertNoValues();
        ts.request(Long.MAX_VALUE); // infinite

        f.subscribe(ts);

        ts.assertValueSequence(list);
        ts.assertTerminated();
    }",loop_control
i,"{
        Flowable<Integer> source = Flowable.range(start, 100);

        TestSubscriberEx<Integer> ts = new TestSubscriberEx<>(0L);
        ts.request(1);
        source.subscribe(ts);

        List<Integer> list = new ArrayList<>(100);
        for (int i = 0; i < 100; i++) {
            list.add(i + start);
            ts.request(1);
        }
        ts.assertValueSequence(list);
        ts.assertTerminated();
    }",loop_control
i,"{
        Flowable<Integer> source = Flowable.range(start, 100);

        TestSubscriberEx<Integer> ts = new TestSubscriberEx<>(0L);
        ts.request(100);
        source.subscribe(ts);

        List<Integer> list = new ArrayList<>(100);
        for (int i = 0; i < 100; i++) {
            list.add(i + start);
        }
        ts.assertValueSequence(list);
        ts.assertTerminated();
    }",loop_control
i,"{
        for (int i = 0; i < 100; i++) {
            withBackpressureOneByOne(i);
        }
    }",loop_control
i,"{
        for (int i = 0; i < 100; i++) {
            withBackpressureAllAtOnce(i);
        }
    }",loop_control
i,"{
        Flowable<Integer> source = Flowable.range(50, 100);

        TestSubscriberEx<Integer> ts = new TestSubscriberEx<>(0L);
        ts.request(150);
        source.subscribe(ts);

        List<Integer> list = new ArrayList<>(100);
        for (int i = 0; i < 100; i++) {
            list.add(i + 50);
        }

        ts.request(50); // and then some

        ts.assertValueSequence(list);
        ts.assertTerminated();
    }",loop_control
i,"{
        return Flowable.unsafeCreate(new Publisher<Integer>() {

            @Override
            public void subscribe(final Subscriber<? super Integer> subscriber) {
                BooleanSubscription bs = new BooleanSubscription();
                subscriber.onSubscribe(bs);
                for (int i = 1; i <= 5; i++) {
                    if (bs.isCancelled()) {
                        break;
                    }
                    numEmitted.incrementAndGet();
                    subscriber.onNext(i);
                    Thread.yield();
                }
                subscriber.onComplete();
            }

        });
    }",loop_control
bs,"{
        return Flowable.unsafeCreate(new Publisher<Integer>() {

            @Override
            public void subscribe(final Subscriber<? super Integer> subscriber) {
                BooleanSubscription bs = new BooleanSubscription();
                subscriber.onSubscribe(bs);
                for (int i = 1; i <= 5; i++) {
                    if (bs.isCancelled()) {
                        break;
                    }
                    numEmitted.incrementAndGet();
                    subscriber.onNext(i);
                    Thread.yield();
                }
                subscriber.onComplete();
            }

        });
    }",break_loop_control
bs,"{
        return Flowable.unsafeCreate(new Publisher<Integer>() {

            @Override
            public void subscribe(final Subscriber<? super Integer> subscriber) {
                final BooleanSubscription bs = new BooleanSubscription();
                subscriber.onSubscribe(bs);
                Thread t = new Thread(new Runnable() {

                    @Override
                    public void run() {
                        System.out.println(""-------> subscribe to infinite sequence"");
                        System.out.println(""Starting thread: "" + Thread.currentThread());
                        int i = 1;
                        while (!bs.isCancelled()) {
                            subscriber.onNext(i++);
                            Thread.yield();
                        }
                        subscriber.onComplete();
                        latch.countDown();
                        System.out.println(""Ending thread: "" + Thread.currentThread());
                    }
                });
                t.start();

            }

        });
    }",maybe_loop_control
i,"{
        // https://github.com/ReactiveX/RxJava/issues/1812
        Flowable<Integer> zip1 = Flowable.zip(Flowable.range(0, 1026), Flowable.range(0, 1026),
                new BiFunction<Integer, Integer, Integer>() {

                    @Override
                    public Integer apply(Integer i1, Integer i2) {
                        return i1 + i2;
                    }
                });
        Flowable<Integer> zip2 = Flowable.zip(zip1, Flowable.range(0, 1026),
                new BiFunction<Integer, Integer, Integer>() {

                    @Override
                    public Integer apply(Integer i1, Integer i2) {
                        return i1 + i2;
                    }
                });
        List<Integer> expected = new ArrayList<>();
        for (int i = 0; i < 1026; i++) {
            expected.add(i * 3);
        }
        assertEquals(expected, zip2.toList().blockingGet());
    }",loop_control
i,"{
        long startTime = System.currentTimeMillis();
        Flowable<Integer> src = Flowable.just(1).subscribeOn(Schedulers.computation());

        // now try and generate a hang by zipping src with itself repeatedly. A
        // time limit of 9 seconds ( 1 second less than the test timeout) is
        // used so that this test will not timeout on slow machines.
        int i = 0;
        while (System.currentTimeMillis() - startTime < 9000 && i++ < 100000) {
            int value = Flowable.zip(src, src, new BiFunction<Integer, Integer, Integer>() {
                @Override
                public Integer apply(Integer t1, Integer t2) {
                    return t1 + t2 * 10;
                }
            }).blockingSingle(0);

            Assert.assertEquals(11, value);
        }
    }",loop_control
j,"{
        Flowable source = Flowable.just(1);

        for (int i = 2; i < 10; i++) {
            Class<?>[] types = new Class[i + 1];
            Arrays.fill(types, Publisher.class);
            types[i] = i == 2 ? BiFunction.class : Class.forName(""io.reactivex.rxjava3.functions.Function"" + i);

            Method m = Flowable.class.getMethod(""zip"", types);

            Object[] params = new Object[i + 1];
            Arrays.fill(params, source);
            params[i] = ArgsToString.INSTANCE;

            StringBuilder b = new StringBuilder();
            for (int j = 0; j < i; j++) {
                b.append('1');
            }

            ((Flowable)m.invoke(null, params)).test().assertResult(b.toString());

            for (int j = 0; j < params.length; j++) {
                Object[] params0 = params.clone();
                params0[j] = null;

                try {
                    m.invoke(null, params0);
                    fail(""Should have thrown @ "" + m);
                } catch (InvocationTargetException ex) {
                    assertTrue(ex.toString(), ex.getCause() instanceof NullPointerException);

                    if (j < i) {
                        assertEquals(""source"" + (j + 1) + "" is null"", ex.getCause().getMessage());
                    } else {
                        assertEquals(""zipper is null"", ex.getCause().getMessage());
                    }
                }
            }
        }
    }",loop_control
i,"{
        Flowable source = Flowable.just(1);

        for (int i = 2; i < 10; i++) {
            Class<?>[] types = new Class[i + 1];
            Arrays.fill(types, Publisher.class);
            types[i] = i == 2 ? BiFunction.class : Class.forName(""io.reactivex.rxjava3.functions.Function"" + i);

            Method m = Flowable.class.getMethod(""zip"", types);

            Object[] params = new Object[i + 1];
            Arrays.fill(params, source);
            params[i] = ArgsToString.INSTANCE;

            StringBuilder b = new StringBuilder();
            for (int j = 0; j < i; j++) {
                b.append('1');
            }

            ((Flowable)m.invoke(null, params)).test().assertResult(b.toString());

            for (int j = 0; j < params.length; j++) {
                Object[] params0 = params.clone();
                params0[j] = null;

                try {
                    m.invoke(null, params0);
                    fail(""Should have thrown @ "" + m);
                } catch (InvocationTargetException ex) {
                    assertTrue(ex.toString(), ex.getCause() instanceof NullPointerException);

                    if (j < i) {
                        assertEquals(""source"" + (j + 1) + "" is null"", ex.getCause().getMessage());
                    } else {
                        assertEquals(""zipper is null"", ex.getCause().getMessage());
                    }
                }
            }
        }
    }",loop_control
i,"{
        for (int i = 0; i < 500; i++) {
            TestSubscriber<List<Object>> ts = Flowable.zip(
                    Flowable.just(1).observeOn(Schedulers.single()).map(new Function<Integer, Object>() {
                        @Override
                        public Object apply(Integer v) throws Exception {
                            return Thread.currentThread().getName().substring(0, 4);
                        }
                    }),
                    Flowable.just(1).observeOn(Schedulers.computation()).map(new Function<Integer, Object>() {
                        @Override
                        public Object apply(Integer v) throws Exception {
                            return Thread.currentThread().getName().substring(0, 4);
                        }
                    }),
                    new BiFunction<Object, Object, List<Object>>() {
                        @Override
                        public List<Object> apply(Object t1, Object t2) throws Exception {
                            return Arrays.asList(t1, t2);
                        }
                    }
            )
            .test()
            .awaitDone(5, TimeUnit.SECONDS)
            .assertValueCount(1);

            List<Object> list = ts.values().get(0);

            assertTrue(list.toString(), list.contains(""RxSi""));
            assertTrue(list.toString(), list.contains(""RxCo""));
        }
    }",loop_control
r2,"{
        PublishProcessor<String> r1 = PublishProcessor.create();
        /* define a Subscriber to receive aggregated events */
        Subscriber<String> subscriber = TestHelper.mockSubscriber();
        InOrder io = inOrder(subscriber);

        Iterable<String> r2 = new Iterable<String>() {

            @Override
            public Iterator<String> iterator() {
                return new Iterator<String>() {
                    int count;

                    @Override
                    public boolean hasNext() {
                        if (count == 0) {
                            return true;
                        }
                        throw new TestException();
                    }

                    @Override
                    public String next() {
                        count++;
                        return ""1"";
                    }

                    @Override
                    public void remove() {
                        throw new UnsupportedOperationException(""Not supported yet."");
                    }

                };
            }

        };

        r1.zipWith(r2, zipr2).subscribe(subscriber);

        r1.onNext(""one-"");
        r1.onError(new TestException());

        io.verify(subscriber).onNext(""one-1"");
        io.verify(subscriber).onError(any(TestException.class));

        verify(subscriber, never()).onComplete();

    }",iterator
s,"{

        String[] valuesToReturn;

        TestAsyncErrorObservable(String... values) {
            valuesToReturn = values;
        }

        volatile Thread t;

        @Override
        public void subscribe(final Subscriber<? super String> subscriber) {
            subscriber.onSubscribe(new BooleanSubscription());
            t = new Thread(new Runnable() {

                @Override
                public void run() {
                    for (String s : valuesToReturn) {
                        if (s == null) {
                            System.out.println(""throwing exception"");
                            try {
                                Thread.sleep(100);
                            } catch (Throwable e) {

                            }
                            subscriber.onError(new NullPointerException());
                            return;
                        } else {
                            subscriber.onNext(s);
                        }
                    }
                    System.out.println(""subscription complete"");
                    subscriber.onComplete();
                }

            });
            t.start();
        }
    }",iterator
timeout,"{
        List<Throwable> errors = TestHelper.trackPluginErrors();
        try {
            final CountDownLatch cdl1 = new CountDownLatch(1);
            final CountDownLatch cdl2 = new CountDownLatch(1);

            TestSubscriber<Object> ts = Flowable.fromRunnable(new Runnable() {
                @Override
                public void run() {
                    cdl1.countDown();
                    try {
                        cdl2.await(5, TimeUnit.SECONDS);
                    } catch (InterruptedException e) {
                        e.printStackTrace();
                        throw new TestException(e);
                    }
                }
            }).subscribeOn(Schedulers.single()).test();

            assertTrue(cdl1.await(5, TimeUnit.SECONDS));

            ts.cancel();

            int timeout = 10;

            while (timeout-- > 0 && errors.isEmpty()) {
                Thread.sleep(100);
            }

            TestHelper.assertUndeliverable(errors, 0, TestException.class);
        } finally {
            RxJavaPlugins.reset();
        }
    }",loop_control
errors,"{
        List<Throwable> errors = TestHelper.trackPluginErrors();
        try {
            final CountDownLatch cdl1 = new CountDownLatch(1);
            final CountDownLatch cdl2 = new CountDownLatch(1);

            TestSubscriber<Object> ts = Flowable.fromRunnable(new Runnable() {
                @Override
                public void run() {
                    cdl1.countDown();
                    try {
                        cdl2.await(5, TimeUnit.SECONDS);
                    } catch (InterruptedException e) {
                        e.printStackTrace();
                        throw new TestException(e);
                    }
                }
            }).subscribeOn(Schedulers.single()).test();

            assertTrue(cdl1.await(5, TimeUnit.SECONDS));

            ts.cancel();

            int timeout = 10;

            while (timeout-- > 0 && errors.isEmpty()) {
                Thread.sleep(100);
            }

            TestHelper.assertUndeliverable(errors, 0, TestException.class);
        } finally {
            RxJavaPlugins.reset();
        }
    }",maybe_loop_control
i,"{
        for (int i = 0; i < TestHelper.RACE_DEFAULT_LOOPS; i++) {
            final TestSubscriber<Long> ts = new TestSubscriber<>();

            final TestScheduler scheduler = new TestScheduler();

            Flowable.timer(1, TimeUnit.SECONDS, scheduler)
            .subscribe(ts);

            Runnable r1 = new Runnable() {
                @Override
                public void run() {
                    scheduler.advanceTimeBy(1, TimeUnit.SECONDS);
                }
            };

            Runnable r2 = new Runnable() {
                @Override
                public void run() {
                    ts.cancel();
                }
            };

            TestHelper.race(r1, r2);
        }
    }",loop_control
i,"{
        List<Throwable> errors = TestHelper.trackPluginErrors();
        try {
            for (int i = 0; i < 1000; i++) {
                Flowable.timer(0, TimeUnit.MILLISECONDS).blockingFirst();
            }

            assertTrue(errors.toString(), errors.isEmpty());
        } finally {
            RxJavaPlugins.reset();
        }
    }",loop_control
s,"{
        ScheduledExecutorService exec = Executors.newSingleThreadScheduledExecutor();
        try {
            for (Scheduler s : new Scheduler[] { Schedulers.single(), Schedulers.computation(), Schedulers.newThread(), Schedulers.io(), Schedulers.from(exec, true) }) {
                final AtomicBoolean interrupted = new AtomicBoolean();
                TestSubscriber<Long> ts = Flowable.timer(1, TimeUnit.MILLISECONDS, s)
                .map(new Function<Long, Long>() {
                    @Override
                    public Long apply(Long v) throws Exception {
                        try {
                        Thread.sleep(3000);
                        } catch (InterruptedException ex) {
                            interrupted.set(true);
                        }
                        return v;
                    }
                })
                .test();

                Thread.sleep(500);

                ts.cancel();

                Thread.sleep(500);

                assertTrue(s.getClass().getSimpleName(), interrupted.get());
            }
        } finally {
            exec.shutdown();
        }
    }",iterator
it,"{
        TestScheduler scheduler = new TestScheduler();

        Flowable<Long> source = Flowable.interval(1, TimeUnit.SECONDS, scheduler).take(10);

        Iterable<Long> iter = source.blockingLatest();

        Iterator<Long> it = iter.iterator();

        // only 9 because take(10) will immediately call onComplete when receiving the 10th item
        // which onComplete will overwrite the previous value
        for (int i = 0; i < 9; i++) {
            scheduler.advanceTimeBy(1, TimeUnit.SECONDS);

            Assert.assertTrue(it.hasNext());

            Assert.assertEquals(Long.valueOf(i), it.next());
        }

        scheduler.advanceTimeBy(1, TimeUnit.SECONDS);
        Assert.assertFalse(it.hasNext());
    }",iterator
j,"{
        TestScheduler scheduler = new TestScheduler();

        Flowable<Long> source = Flowable.interval(1, TimeUnit.SECONDS, scheduler).take(10);

        Iterable<Long> iter = source.blockingLatest();

        for (int j = 0; j < 3; j++) {
            Iterator<Long> it = iter.iterator();

            // only 9 because take(10) will immediately call onComplete when receiving the 10th item
            // which onComplete will overwrite the previous value
            for (int i = 0; i < 9; i++) {
                scheduler.advanceTimeBy(1, TimeUnit.SECONDS);

                Assert.assertTrue(it.hasNext());

                Assert.assertEquals(Long.valueOf(i), it.next());
            }

            scheduler.advanceTimeBy(1, TimeUnit.SECONDS);
            Assert.assertFalse(it.hasNext());
        }
    }",loop_control
i,"{
        TestScheduler scheduler = new TestScheduler();

        Flowable<Long> source = Flowable.interval(1, TimeUnit.SECONDS, scheduler).take(10);

        Iterable<Long> iter = source.blockingLatest();

        for (int j = 0; j < 3; j++) {
            Iterator<Long> it = iter.iterator();

            // only 9 because take(10) will immediately call onComplete when receiving the 10th item
            // which onComplete will overwrite the previous value
            for (int i = 0; i < 9; i++) {
                scheduler.advanceTimeBy(1, TimeUnit.SECONDS);

                Assert.assertTrue(it.hasNext());

                Assert.assertEquals(Long.valueOf(i), it.next());
            }

            scheduler.advanceTimeBy(1, TimeUnit.SECONDS);
            Assert.assertFalse(it.hasNext());
        }
    }",loop_control
it,"{
        TestScheduler scheduler = new TestScheduler();

        Flowable<Long> source = Flowable.interval(1, TimeUnit.SECONDS, scheduler).take(10);

        Iterable<Long> iter = source.blockingLatest();

        for (int j = 0; j < 3; j++) {
            Iterator<Long> it = iter.iterator();

            // only 9 because take(10) will immediately call onComplete when receiving the 10th item
            // which onComplete will overwrite the previous value
            for (int i = 0; i < 9; i++) {
                scheduler.advanceTimeBy(1, TimeUnit.SECONDS);

                Assert.assertTrue(it.hasNext());

                Assert.assertEquals(Long.valueOf(i), it.next());
            }

            scheduler.advanceTimeBy(1, TimeUnit.SECONDS);
            Assert.assertFalse(it.hasNext());
        }
    }",iterator
it,"{
        Flowable<Long> source = Flowable.<Long> empty();

        Iterable<Long> iter = source.blockingLatest();

        Iterator<Long> it = iter.iterator();

        Assert.assertFalse(it.hasNext());

        it.next();
    }",iterator
i,"{
        TestScheduler scheduler = new TestScheduler();

        Flowable<Long> source = Flowable.interval(1, TimeUnit.SECONDS, scheduler).take(10);

        Iterable<Long> iter = source.blockingLatest();

        Iterator<Long> it = iter.iterator();

        // only 9 because take(10) will immediately call onComplete when receiving the 10th item
        // which onComplete will overwrite the previous value
        for (int i = 0; i < 10; i++) {
            scheduler.advanceTimeBy(1, TimeUnit.SECONDS);

            Assert.assertEquals(Long.valueOf(i), it.next());
        }
    }",loop_control
it,"{
        TestScheduler scheduler = new TestScheduler();

        Flowable<Long> source = Flowable.interval(1, TimeUnit.SECONDS, scheduler).take(10);

        Iterable<Long> iter = source.blockingLatest();

        Iterator<Long> it = iter.iterator();

        // only 9 because take(10) will immediately call onComplete when receiving the 10th item
        // which onComplete will overwrite the previous value
        for (int i = 0; i < 10; i++) {
            scheduler.advanceTimeBy(1, TimeUnit.SECONDS);

            Assert.assertEquals(Long.valueOf(i), it.next());
        }
    }",iterator
it,"{
        TestScheduler scheduler = new TestScheduler();

        Flowable<Long> source = Flowable.<Long> error(new RuntimeException(""Forced failure!"")).subscribeOn(scheduler);

        Iterable<Long> iter = source.blockingLatest();

        Iterator<Long> it = iter.iterator();

        scheduler.advanceTimeBy(1, TimeUnit.SECONDS);

        it.hasNext();
    }",iterator
it,"{
        TestScheduler scheduler = new TestScheduler();

        Flowable<Long> source = Flowable.<Long> error(new RuntimeException(""Forced failure!"")).subscribeOn(scheduler);

        Iterable<Long> iter = source.blockingLatest();
        Iterator<Long> it = iter.iterator();

        scheduler.advanceTimeBy(1, TimeUnit.SECONDS);

        it.next();
    }",iterator
it,"{
        PublishProcessor<Integer> source = PublishProcessor.create();
        Flowable<Integer> blocker = source;

        Iterable<Integer> iter = blocker.blockingLatest();
        Iterator<Integer> it = iter.iterator();

        source.onNext(1);

        Assert.assertEquals(Integer.valueOf(1), it.next());

        source.onNext(2);
        source.onNext(3);

        Assert.assertEquals(Integer.valueOf(3), it.next());

        source.onNext(4);
        source.onNext(5);
        source.onNext(6);

        Assert.assertEquals(Integer.valueOf(6), it.next());

        source.onNext(7);
        source.onComplete();

        Assert.assertFalse(it.hasNext());
    }",iterator
it,"{
        Iterator<Object> it = Flowable.never().blockingLatest().iterator();

        Thread.currentThread().interrupt();

        try {
            it.hasNext();
        } catch (RuntimeException ex) {
            assertTrue(ex.toString(), ex.getCause() instanceof InterruptedException);
        }
        Thread.interrupted();
    }",iterator
it,"{
        Iterator<Object> it = Flowable.error(new TestException()).blockingLatest().iterator();

        for (int i = 0; i < 3; i++) {
            try {
                it.hasNext();
                fail(""Should have thrown"");
            } catch (TestException ex) {
                // expected
            }
        }
    }",iterator
i,"{
        Iterator<Object> it = Flowable.error(new TestException()).blockingLatest().iterator();

        for (int i = 0; i < 3; i++) {
            try {
                it.hasNext();
                fail(""Should have thrown"");
            } catch (TestException ex) {
                // expected
            }
        }
    }",loop_control
it,"{
        Iterator<Object> it = Flowable.never().blockingLatest().iterator();

        List<Throwable> errors = TestHelper.trackPluginErrors();
        try {
            ((Subscriber<Object>)it).onError(new TestException());

            TestHelper.assertUndeliverable(errors, 0, TestException.class);
        } finally {
            RxJavaPlugins.reset();
        }
    }",iterator
s,"{
        ScheduledExecutorService exec = Executors.newSingleThreadScheduledExecutor();
        try {
            for (Scheduler s : new Scheduler[] { Schedulers.single(), Schedulers.computation(), Schedulers.newThread(), Schedulers.io(), Schedulers.from(exec, true) }) {
                final AtomicBoolean interrupted = new AtomicBoolean();
                TestObserver<Void> to = Completable.timer(1, TimeUnit.MILLISECONDS, s)
                .doOnComplete(new Action() {
                    @Override
                    public void run() throws Exception {
                        try {
                        Thread.sleep(3000);
                        } catch (InterruptedException ex) {
                            interrupted.set(true);
                        }
                    }
                })
                .test();

                Thread.sleep(500);

                to.dispose();

                Thread.sleep(500);

                assertTrue(s.getClass().getSimpleName(), interrupted.get());
            }
        } finally {
            exec.shutdown();
        }
    }",iterator
i,"{
        for (int i = 0; i < TestHelper.RACE_DEFAULT_LOOPS; i++) {
            List<Throwable> errors = TestHelper.trackPluginErrors();
            try {
                final PublishProcessor<Integer> pp1 = PublishProcessor.create();
                final PublishProcessor<Integer> pp2 = PublishProcessor.create();

                TestObserverEx<Void> to = Completable.merge(pp1.map(new Function<Integer, Completable>() {
                    @Override
                    public Completable apply(Integer v) throws Exception {
                        return pp2.ignoreElements();
                    }
                })).to(TestHelper.<Void>testConsumer());

                pp1.onNext(1);

                final Throwable ex1 = new TestException();
                final Throwable ex2 = new TestException();

                Runnable r1 = new Runnable() {
                    @Override
                    public void run() {
                        pp1.onError(ex1);
                    }
                };
                Runnable r2 = new Runnable() {
                    @Override
                    public void run() {
                        pp2.onError(ex2);
                    }
                };

                TestHelper.race(r1, r2);

                Throwable ex = to.errors().get(0);
                if (ex instanceof CompositeException) {
                    to.assertSubscribed().assertNoValues().assertNotComplete();

                    errors = TestHelper.compositeList(ex);
                    TestHelper.assertError(errors, 0, TestException.class);
                    TestHelper.assertError(errors, 1, TestException.class);
                } else {
                    to.assertFailure(TestException.class);

                    if (!errors.isEmpty()) {
                        TestHelper.assertUndeliverable(errors, 0, TestException.class);
                    }
                }
            } finally {
                RxJavaPlugins.reset();
            }
        }
    }",loop_control
i,"{
        for (int i = 0; i < TestHelper.RACE_DEFAULT_LOOPS; i++) {
            final PublishProcessor<Integer> pp1 = PublishProcessor.create();
            final PublishProcessor<Integer> pp2 = PublishProcessor.create();

            TestObserverEx<Void> to = Completable.mergeDelayError(pp1.map(new Function<Integer, Completable>() {
                @Override
                public Completable apply(Integer v) throws Exception {
                    return pp2.ignoreElements();
                }
            })).to(TestHelper.<Void>testConsumer());

            pp1.onNext(1);

            final Throwable ex1 = new TestException();

            Runnable r1 = new Runnable() {
                @Override
                public void run() {
                    pp1.onError(ex1);
                }
            };

            final Throwable ex2 = new TestException();
            Runnable r2 = new Runnable() {
                @Override
                public void run() {
                    pp2.onError(ex2);
                }
            };

            TestHelper.race(r1, r2);

            to.assertFailure(CompositeException.class);

            List<Throwable> errors = TestHelper.compositeList(to.errors().get(0));

            TestHelper.assertError(errors, 0, TestException.class);
            TestHelper.assertError(errors, 1, TestException.class);
        }
    }",loop_control
i,"{
        for (int i = 0; i < TestHelper.RACE_DEFAULT_LOOPS; i++) {
            List<Throwable> errors = TestHelper.trackPluginErrors();
            try {
                final PublishProcessor<Integer> pp1 = PublishProcessor.create();
                final PublishProcessor<Integer> pp2 = PublishProcessor.create();

                TestObserver<Void> to = Completable.mergeArray(pp1.ignoreElements(), pp2.ignoreElements()).test();

                pp1.onNext(1);

                final Throwable ex1 = new TestException();
                final Throwable ex2 = new TestException();

                Runnable r1 = new Runnable() {
                    @Override
                    public void run() {
                        pp1.onError(ex1);
                    }
                };
                Runnable r2 = new Runnable() {
                    @Override
                    public void run() {
                        pp2.onError(ex2);
                    }
                };

                TestHelper.race(r1, r2);

                to.assertFailure(TestException.class);

                if (!errors.isEmpty()) {
                    TestHelper.assertUndeliverable(errors, 0, TestException.class);
                }
            } finally {
                RxJavaPlugins.reset();
            }
        }
    }",loop_control
k,"{
        for (int k = 0; k < 100; k++) {
            final int count = 10;
            final CountDownLatch latch = new CountDownLatch(count);
            final boolean[] interrupted = {false};

            for (int i = 0; i < count; i++) {
                Completable.complete()
                        .subscribeOn(Schedulers.io())
                        .observeOn(Schedulers.io())
                        .andThen(Completable.fromAction(new Action() {
                            @Override
                            public void run() throws Exception {
                                try {
                                    Thread.sleep(30);
                                } catch (InterruptedException e) {
                                    System.out.println(""Interrupted! "" + Thread.currentThread());
                                    interrupted[0] = true;
                                }
                            }
                        }))
                        .subscribe(new Action() {
                            @Override
                            public void run() throws Exception {
                                latch.countDown();
                            }
                        });
            }

            latch.await();
            assertFalse(""The second Completable was interrupted!"", interrupted[0]);
        }
    }",loop_control
i,"{
        for (int k = 0; k < 100; k++) {
            final int count = 10;
            final CountDownLatch latch = new CountDownLatch(count);
            final boolean[] interrupted = {false};

            for (int i = 0; i < count; i++) {
                Completable.complete()
                        .subscribeOn(Schedulers.io())
                        .observeOn(Schedulers.io())
                        .andThen(Completable.fromAction(new Action() {
                            @Override
                            public void run() throws Exception {
                                try {
                                    Thread.sleep(30);
                                } catch (InterruptedException e) {
                                    System.out.println(""Interrupted! "" + Thread.currentThread());
                                    interrupted[0] = true;
                                }
                            }
                        }))
                        .subscribe(new Action() {
                            @Override
                            public void run() throws Exception {
                                latch.countDown();
                            }
                        });
            }

            latch.await();
            assertFalse(""The second Completable was interrupted!"", interrupted[0]);
        }
    }",loop_control
i,"{
        for (int i = 0; i < TestHelper.RACE_DEFAULT_LOOPS; i++) {
            List<Throwable> errors = TestHelper.trackPluginErrors();

            try {
                final TestScheduler scheduler = new TestScheduler();

                final PublishSubject<Integer> ps = PublishSubject.create();

                TestObserverEx<Void> to = ps.ignoreElements()
                        .timeout(1, TimeUnit.MILLISECONDS, scheduler, Completable.complete())
                        .to(TestHelper.<Void>testConsumer());

                final TestException ex = new TestException();

                Runnable r1 = new Runnable() {
                    @Override
                    public void run() {
                        ps.onError(ex);
                    }
                };

                Runnable r2 = new Runnable() {
                    @Override
                    public void run() {
                        scheduler.advanceTimeBy(1, TimeUnit.MILLISECONDS);
                    }
                };

                TestHelper.race(r1, r2);

                to.assertTerminated();

                if (!errors.isEmpty()) {
                    TestHelper.assertUndeliverable(errors, 0, TestException.class);
                }

            } finally {
                RxJavaPlugins.reset();
            }
        }
    }",loop_control
i,"{
        for (int i = 0; i < TestHelper.RACE_DEFAULT_LOOPS; i++) {
            PublishSubject<Integer> ps = PublishSubject.create();

            final Completable c = ps.ignoreElements().cache();

            final TestObserver<Void> to1 = new TestObserver<>();

            final TestObserver<Void> to2 = new TestObserver<>();

            Runnable r1 = new Runnable() {
                @Override
                public void run() {
                    c.subscribe(to1);
                }
            };
            Runnable r2 = new Runnable() {
                @Override
                public void run() {
                    c.subscribe(to2);
                }
            };

            TestHelper.race(r1, r2);

            ps.onComplete();

            to1.assertResult();
            to2.assertResult();
        }
    }",loop_control
i,"{
        for (int i = 0; i < TestHelper.RACE_DEFAULT_LOOPS; i++) {
            PublishSubject<Integer> ps = PublishSubject.create();

            final Completable c = ps.ignoreElements().cache();

            final TestObserver<Void> to1 = c.test();

            final TestObserver<Void> to2 = new TestObserver<>();

            Runnable r1 = new Runnable() {
                @Override
                public void run() {
                    to1.dispose();
                }
            };
            Runnable r2 = new Runnable() {
                @Override
                public void run() {
                    c.subscribe(to2);
                }
            };

            TestHelper.race(r1, r2);

            ps.onComplete();

            to1.assertEmpty();
            to2.assertResult();
        }
    }",loop_control
i,"{
        for (int i = 0; i < TestHelper.RACE_DEFAULT_LOOPS; i++) {
            List<Throwable> errors = TestHelper.trackPluginErrors();

            try {
                final PublishProcessor<Integer> pp1 = PublishProcessor.create();
                final PublishProcessor<Integer> pp2 = PublishProcessor.create();

                TestObserver<Void> to = Completable.concat(pp1.map(new Function<Integer, Completable>() {
                    @Override
                    public Completable apply(Integer v) throws Exception {
                        return pp2.ignoreElements();
                    }
                })).test();

                pp1.onNext(1);

                final TestException ex = new TestException();

                Runnable r1 = new Runnable() {
                    @Override
                    public void run() {
                        pp1.onError(ex);
                    }
                };
                Runnable r2 = new Runnable() {
                    @Override
                    public void run() {
                        pp2.onError(ex);
                    }
                };

                TestHelper.race(r1, r2);

                to.assertFailure(TestException.class);

                if (!errors.isEmpty()) {
                    TestHelper.assertUndeliverable(errors, 0, TestException.class);
                }
            } finally {
                RxJavaPlugins.reset();
            }
        }
    }",loop_control
i,"{
        Completable[] a = new Completable[1024];
        Arrays.fill(a, Completable.complete());

        for (int i = 0; i < TestHelper.RACE_DEFAULT_LOOPS; i++) {

            final Completable c = Completable.concatArray(a);

            final TestObserver<Void> to = new TestObserver<>();

            Runnable r1 = new Runnable() {
                @Override
                public void run() {
                    c.subscribe(to);
                }
            };

            Runnable r2 = new Runnable() {
                @Override
                public void run() {
                    to.dispose();
                }
            };

            TestHelper.race(r1, r2);
        }
    }",loop_control
i,"{
        Completable[] a = new Completable[1024];
        Arrays.fill(a, Completable.complete());

        for (int i = 0; i < TestHelper.RACE_DEFAULT_LOOPS; i++) {

            final Completable c = Completable.concat(Arrays.asList(a));

            final TestObserver<Void> to = new TestObserver<>();

            Runnable r1 = new Runnable() {
                @Override
                public void run() {
                    c.subscribe(to);
                }
            };

            Runnable r2 = new Runnable() {
                @Override
                public void run() {
                    to.dispose();
                }
            };

            TestHelper.race(r1, r2);
        }
    }",loop_control
k,"{
        for (int k = 0; k < 100; k++) {
            final int count = 10;
            final CountDownLatch latch = new CountDownLatch(count);
            final boolean[] interrupted = { false };

            for (int i = 0; i < count; i++) {
                Completable c0 = Completable.fromAction(new Action() {
                    @Override
                    public void run() throws Exception {
                        try {
                            Thread.sleep(30);
                        } catch (InterruptedException e) {
                            System.out.println(""Interrupted! "" + Thread.currentThread());
                            interrupted[0] = true;
                        }
                    }
                });
                Completable.concat(Arrays.asList(Completable.complete()
                    .subscribeOn(Schedulers.io())
                    .observeOn(Schedulers.io()),
                    c0)
                )
                .subscribe(new Action() {
                    @Override
                    public void run() throws Exception {
                        latch.countDown();
                    }
                });
            }

            latch.await();
            assertFalse(""The second Completable was interrupted!"", interrupted[0]);
        }
    }",loop_control
i,"{
        for (int k = 0; k < 100; k++) {
            final int count = 10;
            final CountDownLatch latch = new CountDownLatch(count);
            final boolean[] interrupted = { false };

            for (int i = 0; i < count; i++) {
                Completable c0 = Completable.fromAction(new Action() {
                    @Override
                    public void run() throws Exception {
                        try {
                            Thread.sleep(30);
                        } catch (InterruptedException e) {
                            System.out.println(""Interrupted! "" + Thread.currentThread());
                            interrupted[0] = true;
                        }
                    }
                });
                Completable.concat(Arrays.asList(Completable.complete()
                    .subscribeOn(Schedulers.io())
                    .observeOn(Schedulers.io()),
                    c0)
                )
                .subscribe(new Action() {
                    @Override
                    public void run() throws Exception {
                        latch.countDown();
                    }
                });
            }

            latch.await();
            assertFalse(""The second Completable was interrupted!"", interrupted[0]);
        }
    }",loop_control
i,"{
        List<Completable> ms = new ArrayList<>();

        for (int i = 0; i < 32; i++) {
            ms.add(Completable.never());
        }

        ms.add(Completable.complete());

        Completable.amb(ms)
        .test()
        .assertResult();
    }",loop_control
i,"{
        for (int i = 0; i < TestHelper.RACE_DEFAULT_LOOPS; i++) {
            List<Throwable> errors = TestHelper.trackPluginErrors();
            try {
                final PublishProcessor<Integer> pp0 = PublishProcessor.create();
                final PublishProcessor<Integer> pp1 = PublishProcessor.create();

                final TestObserver<Void> to = Completable.amb(Arrays.asList(pp0.ignoreElements(), pp1.ignoreElements()))
                .test();

                final TestException ex = new TestException();

                Runnable r1 = new Runnable() {
                    @Override
                    public void run() {
                        pp0.onError(ex);
                    }
                };

                Runnable r2 = new Runnable() {
                    @Override
                    public void run() {
                        pp1.onError(ex);
                    }
                };

                TestHelper.race(r1, r2);

                to.assertFailure(TestException.class);

                if (!errors.isEmpty()) {
                    TestHelper.assertUndeliverable(errors, 0, TestException.class);
                }
            } finally {
                RxJavaPlugins.reset();
            }
        }
    }",loop_control
i,"{
        for (int i = 0; i < TestHelper.RACE_DEFAULT_LOOPS; i++) {
            List<Throwable> errors = TestHelper.trackPluginErrors();

            try {

                final Subject<Integer> ps = ReplaySubject.create();
                ps.onNext(1);

                final Completable source = Completable.ambArray(ps.ignoreElements(), Completable.never(), Completable.never(), null);

                Runnable r1 = new Runnable() {
                    @Override
                    public void run() {
                        source.test();
                    }
                };

                Runnable r2 = new Runnable() {
                    @Override
                    public void run() {
                        ps.onComplete();
                    }
                };

                TestHelper.race(r1, r2);

                if (!errors.isEmpty()) {
                    TestHelper.assertError(errors, 0, NullPointerException.class);
                }
            } finally {
                RxJavaPlugins.reset();
            }
        }
    }",loop_control
i,"{
        final TestException ex = new TestException();
        for (int i = 0; i < TestHelper.RACE_LONG_LOOPS; i++) {
            final AtomicBoolean interrupted = new AtomicBoolean();
            final CountDownLatch cdl = new CountDownLatch(1);

            Completable.ambArray(
                    Completable.error(ex)
                    .subscribeOn(Schedulers.single())
                    .observeOn(Schedulers.computation()),
                    Completable.never()
            )
            .subscribe(Functions.EMPTY_ACTION, new Consumer<Throwable>() {
                @Override
                public void accept(Throwable e) throws Exception {
                    interrupted.set(Thread.currentThread().isInterrupted());
                    cdl.countDown();
                }
            });

            assertTrue(cdl.await(500, TimeUnit.SECONDS));
            assertFalse(""Interrupted!"", interrupted.get());
        }
    }",loop_control
i,"{
        for (int i = 0; i < TestHelper.RACE_LONG_LOOPS; i++) {
            final AtomicBoolean interrupted = new AtomicBoolean();
            final CountDownLatch cdl = new CountDownLatch(1);

            Completable.ambArray(
                Completable.complete()
                    .subscribeOn(Schedulers.single())
                    .observeOn(Schedulers.computation()),
                Completable.never()
            )
            .subscribe(new Action() {
                @Override
                public void run() throws Exception {
                    interrupted.set(Thread.currentThread().isInterrupted());
                    cdl.countDown();
                }
            });

            assertTrue(cdl.await(500, TimeUnit.SECONDS));
            assertFalse(""Interrupted!"", interrupted.get());
        }
    }",loop_control
arg,"{
        List<String> list = new ArrayList<>();
        for (String arg : args) {
            list.add(arg);
        }
        return list;
    }",iterator
timeout,"{
        final AtomicBoolean cancel1 = new AtomicBoolean();
        Flowable.intervalRange(1, 1000, 1, 1, TimeUnit.MILLISECONDS)
        .doOnCancel(new Action() {
            @Override
            public void run() throws Exception {
                cancel1.set(true);
            }
        })
        .window(1, TimeUnit.MILLISECONDS, Schedulers.single(), 2, true)
        .flatMap(Functions.<Flowable<Long>>identity())
        .take(500)
        .to(TestHelper.<Long>testConsumer())
        .awaitDone(5, TimeUnit.SECONDS)
        .assertSubscribed()
        .assertValueCount(500)
        .assertNoErrors()
        .assertComplete();

        int timeout = 20;
        while (timeout-- > 0 && !cancel1.get()) {
            Thread.sleep(100);
        }

        assertTrue(""intervalRange was not cancelled!"", cancel1.get());
    }",loop_control
cancel1,"{
        final AtomicBoolean cancel1 = new AtomicBoolean();
        Flowable.intervalRange(1, 1000, 1, 1, TimeUnit.MILLISECONDS)
        .doOnCancel(new Action() {
            @Override
            public void run() throws Exception {
                cancel1.set(true);
            }
        })
        .window(1, TimeUnit.MILLISECONDS, Schedulers.single(), 2, true)
        .flatMap(Functions.<Flowable<Long>>identity())
        .take(500)
        .to(TestHelper.<Long>testConsumer())
        .awaitDone(5, TimeUnit.SECONDS)
        .assertSubscribed()
        .assertValueCount(500)
        .assertNoErrors()
        .assertComplete();

        int timeout = 20;
        while (timeout-- > 0 && !cancel1.get()) {
            Thread.sleep(100);
        }

        assertTrue(""intervalRange was not cancelled!"", cancel1.get());
    }",maybe_loop_control
i,"{
        for (int i = 0; i < TestHelper.RACE_DEFAULT_LOOPS; i++) {
            TestScheduler scheduler = new TestScheduler();

            PublishProcessor<Integer> pp = PublishProcessor.create();

            TestSubscriber<Flowable<Integer>> ts = pp.window(1, TimeUnit.MINUTES, scheduler, 1)
            .test();

            TestHelper.race(
                    () -> pp.onNext(1),
                    () -> ts.cancel()
            );
        }
    }",loop_control
mode,"{
        for (BackpressureStrategy mode : BackpressureStrategy.values()) {
            Flowable.fromObservable(Observable.range(1, 5), mode)
            .test()
            .withTag(""mode: "" + mode)
            .assertResult(1, 2, 3, 4, 5);
        }
    }",iterator
i,"{
        final AtomicInteger effectCounter = new AtomicInteger();
        Flowable<Integer> source = Flowable.just(1, 2, 3, 4)
        .doOnNext(new Consumer<Integer>() {
            @Override
            public void accept(Integer v) {
                effectCounter.incrementAndGet();
                System.out.println(""Sideeffect #"" + v);
            }
        });

        Flowable<Integer> result = source.replay(
        new Function<Flowable<Integer>, Flowable<Integer>>() {
            @Override
            public Flowable<Integer> apply(Flowable<Integer> f) {
                return f.take(2);
            }
        });

        for (int i = 1; i < 3; i++) {
            effectCounter.set(0);
            System.out.printf(""- %d -%n"", i);
            result.subscribe(new Consumer<Integer>() {

                @Override
                public void accept(Integer t1) {
                    System.out.println(t1);
                }

            }, new Consumer<Throwable>() {

                @Override
                public void accept(Throwable t1) {
                    t1.printStackTrace();
                }
            },
            new Action() {
                @Override
                public void run() {
                    System.out.println(""Done"");
                }
            });
            assertEquals(2, effectCounter.get());
        }
    }",loop_control
i,"{
        Flowable<Integer> source = Flowable.range(0, 1000).replay().autoConnect();

        TestSubscriberEx<Integer> ts = new TestSubscriberEx<>();

        source.subscribe(ts);

        ts.assertNoErrors();
        ts.assertTerminated();
        List<Integer> onNextEvents = ts.values();
        assertEquals(1000, onNextEvents.size());

        for (int i = 0; i < 1000; i++) {
            assertEquals((Integer)i, onNextEvents.get(i));
        }
    }",loop_control
i,"{
        Flowable<Integer> source = Flowable.range(0, 1000).replay().autoConnect();

        TestSubscriber<Integer> ts = new TestSubscriber<>(0L);
        ts.request(10);

        source.subscribe(ts);

        ts.assertNoErrors();
        ts.assertNotComplete();
        List<Integer> onNextEvents = ts.values();
        assertEquals(10, onNextEvents.size());

        for (int i = 0; i < 10; i++) {
            assertEquals((Integer)i, onNextEvents.get(i));
        }

        ts.cancel();
    }",loop_control
i,"{
        Flowable<Integer> source = Flowable.range(1, 10000);
        for (int i = 0; i < 100; i++) {
            TestSubscriberEx<Integer> ts1 = new TestSubscriberEx<>();

            Flowable<Integer> cached = source.replay().autoConnect();

            cached.observeOn(Schedulers.computation()).subscribe(ts1);

            ts1.awaitDone(2, TimeUnit.SECONDS);
            ts1.assertNoErrors();
            ts1.assertTerminated();
            assertEquals(10000, ts1.values().size());

            TestSubscriberEx<Integer> ts2 = new TestSubscriberEx<>();
            cached.observeOn(Schedulers.computation()).subscribe(ts2);

            ts2.awaitDone(2, TimeUnit.SECONDS);
            ts2.assertNoErrors();
            ts2.assertTerminated();
            assertEquals(10000, ts2.values().size());
        }
    }",loop_control
i,"{
        Flowable<Long> source = Flowable.interval(1, 1, TimeUnit.MILLISECONDS)
                .take(1000)
                .subscribeOn(Schedulers.io());
        Flowable<Long> cached = source.replay().autoConnect();

        Flowable<Long> output = cached.observeOn(Schedulers.computation(), false, 1024);

        List<TestSubscriberEx<Long>> list = new ArrayList<>(100);
        for (int i = 0; i < 100; i++) {
            TestSubscriberEx<Long> ts = new TestSubscriberEx<>();
            list.add(ts);
            output.skip(i * 10).take(10).subscribe(ts);
        }

        List<Long> expected = new ArrayList<>();
        for (int i = 0; i < 10; i++) {
            expected.add((long)(i - 10));
        }
        int j = 0;
        for (TestSubscriberEx<Long> ts : list) {
            ts.awaitDone(3, TimeUnit.SECONDS);
            ts.assertNoErrors();
            ts.assertTerminated();

            for (int i = j * 10; i < j * 10 + 10; i++) {
                expected.set(i - j * 10, (long)i);
            }

            ts.assertValueSequence(expected);

            j++;
        }
    }",loop_control
ts,"{
        Flowable<Long> source = Flowable.interval(1, 1, TimeUnit.MILLISECONDS)
                .take(1000)
                .subscribeOn(Schedulers.io());
        Flowable<Long> cached = source.replay().autoConnect();

        Flowable<Long> output = cached.observeOn(Schedulers.computation(), false, 1024);

        List<TestSubscriberEx<Long>> list = new ArrayList<>(100);
        for (int i = 0; i < 100; i++) {
            TestSubscriberEx<Long> ts = new TestSubscriberEx<>();
            list.add(ts);
            output.skip(i * 10).take(10).subscribe(ts);
        }

        List<Long> expected = new ArrayList<>();
        for (int i = 0; i < 10; i++) {
            expected.add((long)(i - 10));
        }
        int j = 0;
        for (TestSubscriberEx<Long> ts : list) {
            ts.awaitDone(3, TimeUnit.SECONDS);
            ts.assertNoErrors();
            ts.assertTerminated();

            for (int i = j * 10; i < j * 10 + 10; i++) {
                expected.set(i - j * 10, (long)i);
            }

            ts.assertValueSequence(expected);

            j++;
        }
    }",iterator
j,"{
        Flowable<Long> source = Flowable.interval(1, 1, TimeUnit.MILLISECONDS)
                .take(1000)
                .subscribeOn(Schedulers.io());
        Flowable<Long> cached = source.replay().autoConnect();

        Flowable<Long> output = cached.observeOn(Schedulers.computation(), false, 1024);

        List<TestSubscriberEx<Long>> list = new ArrayList<>(100);
        for (int i = 0; i < 100; i++) {
            TestSubscriberEx<Long> ts = new TestSubscriberEx<>();
            list.add(ts);
            output.skip(i * 10).take(10).subscribe(ts);
        }

        List<Long> expected = new ArrayList<>();
        for (int i = 0; i < 10; i++) {
            expected.add((long)(i - 10));
        }
        int j = 0;
        for (TestSubscriberEx<Long> ts : list) {
            ts.awaitDone(3, TimeUnit.SECONDS);
            ts.assertNoErrors();
            ts.assertTerminated();

            for (int i = j * 10; i < j * 10 + 10; i++) {
                expected.set(i - j * 10, (long)i);
            }

            ts.assertValueSequence(expected);

            j++;
        }
    }",maybe_loop_control
i,"{
        final int m = 4 * 1000 * 1000;
        Flowable<Integer> firehose = Flowable.unsafeCreate(new Publisher<Integer>() {
            @Override
            public void subscribe(Subscriber<? super Integer> t) {
                t.onSubscribe(new BooleanSubscription());
                for (int i = 0; i < m; i++) {
                    t.onNext(i);
                }
                t.onComplete();
            }
        });

        TestSubscriberEx<Integer> ts = new TestSubscriberEx<>();
        firehose.replay().autoConnect().observeOn(Schedulers.computation()).takeLast(100).subscribe(ts);

        ts.awaitDone(3, TimeUnit.SECONDS);
        ts.assertNoErrors();
        ts.assertTerminated();

        assertEquals(100, ts.values().size());
    }",loop_control
i,"{
        for (int i = 0; i < TestHelper.RACE_DEFAULT_LOOPS; i++) {
            final ConnectableFlowable<Integer> cf = Flowable.range(1, 3).replay();

            Runnable r = new Runnable() {
                @Override
                public void run() {
                    cf.connect();
                }
            };

            TestHelper.race(r, r);
        }
    }",loop_control
i,"{
        for (int i = 0; i < TestHelper.RACE_DEFAULT_LOOPS; i++) {
            final ConnectableFlowable<Integer> cf = Flowable.range(1, 3).replay();

            final TestSubscriber<Integer> ts1 = new TestSubscriber<>();
            final TestSubscriber<Integer> ts2 = new TestSubscriber<>();

            Runnable r1 = new Runnable() {
                @Override
                public void run() {
                    cf.subscribe(ts1);
                }
            };

            Runnable r2 = new Runnable() {
                @Override
                public void run() {
                    cf.subscribe(ts2);
                }
            };

            TestHelper.race(r1, r2);
        }
    }",loop_control
i,"{
        for (int i = 0; i < TestHelper.RACE_DEFAULT_LOOPS; i++) {
            final ConnectableFlowable<Integer> cf = Flowable.range(1, 3).replay();

            final TestSubscriber<Integer> ts1 = new TestSubscriber<>();
            final TestSubscriber<Integer> ts2 = new TestSubscriber<>();

            cf.subscribe(ts1);

            Runnable r1 = new Runnable() {
                @Override
                public void run() {
                    ts1.cancel();
                }
            };

            Runnable r2 = new Runnable() {
                @Override
                public void run() {
                    cf.subscribe(ts2);
                }
            };

            TestHelper.race(r1, r2);
        }
    }",loop_control
i,"{
        for (int i = 0; i < TestHelper.RACE_DEFAULT_LOOPS; i++) {
            final PublishProcessor<Integer> pp = PublishProcessor.create();

            final ConnectableFlowable<Integer> cf = pp.replay();

            final TestSubscriber<Integer> ts1 = new TestSubscriber<>();

            Runnable r1 = new Runnable() {
                @Override
                public void run() {
                    cf.subscribe(ts1);
                }
            };

            Runnable r2 = new Runnable() {
                @Override
                public void run() {
                    for (int j = 0; j < 1000; j++) {
                        pp.onNext(j);
                    }
                }
            };

            TestHelper.race(r1, r2);
        }
    }",loop_control
i,"{
        for (int i = 0; i < TestHelper.RACE_DEFAULT_LOOPS; i++) {
            final PublishProcessor<Integer> pp = PublishProcessor.create();

            final ConnectableFlowable<Integer> cf = pp.replay();

            final TestSubscriber<Integer> ts1 = new TestSubscriber<>();

            cf.subscribe(ts1);

            Runnable r1 = new Runnable() {
                @Override
                public void run() {
                    ts1.cancel();
                }
            };

            Runnable r2 = new Runnable() {
                @Override
                public void run() {
                    for (int j = 0; j < 1000; j++) {
                        pp.onNext(j);
                    }
                }
            };

            TestHelper.race(r1, r2);
        }
    }",loop_control
j,"{
        for (int i = 0; i < TestHelper.RACE_DEFAULT_LOOPS; i++) {
            final PublishProcessor<Integer> pp = PublishProcessor.create();

            final ConnectableFlowable<Integer> cf = pp.replay();

            final TestSubscriber<Integer> ts1 = new TestSubscriber<>();

            cf.subscribe(ts1);

            Runnable r1 = new Runnable() {
                @Override
                public void run() {
                    ts1.cancel();
                }
            };

            Runnable r2 = new Runnable() {
                @Override
                public void run() {
                    for (int j = 0; j < 1000; j++) {
                        pp.onNext(j);
                    }
                }
            };

            TestHelper.race(r1, r2);
        }
    }",loop_control
i,"{
        for (int i = 0; i < TestHelper.RACE_DEFAULT_LOOPS; i++) {
            final ConnectableFlowable<Integer> cf = Flowable.range(1, 1000).replay();

            final TestSubscriber<Integer> ts1 = new TestSubscriber<>();

            cf.connect();

            Runnable r1 = new Runnable() {
                @Override
                public void run() {
                    cf.subscribe(ts1);
                }
            };

            Runnable r2 = new Runnable() {
                @Override
                public void run() {
                    ts1.cancel();
                }
            };

            TestHelper.race(r1, r2);
        }
    }",loop_control
current,"{
        int previous = 0;
        for (Integer current : ts.values()) {
            Assert.assertTrue(""The sequence must be increasing [current value="" + previous +
                    "", previous value="" + current + ""]"", previous <= current);
            previous = current;
        }
    }",iterator
i,"{
        TestSubscriberEx<Long> ts = createDelayedSubscriber();
        int m = 100000;
        Flowable.rangeLong(1, m)
                .subscribeOn(Schedulers.computation())
                .onBackpressureReduce(Long::sum)
                .observeOn(Schedulers.io())
                .subscribe(ts);

        ts.awaitDone(2, TimeUnit.SECONDS);
        ts.assertTerminated();
        assertValuesDropped(ts, m);
        long sum = 0;
        for (Long i : ts.values()) {
            sum += i;
        }
        //sum = (A1 + An) * n / 2 = 100_001 * 50_000 = 50_000_00000 + 50_000 = 50_000_50_000
        Assert.assertEquals(""Wrong sum: "" + sum, 5000050000L, sum);
    }",iterator
ts,"{
        final TestSubscriber<Object> ts = new TestSubscriber<>();
        final Subscriber[] s = { null };

        Schedulers.single().scheduleDirect(new Runnable() {
            @SuppressWarnings(""unchecked"")
            @Override
            public void run() {
                ts.cancel();
                s[0].onNext(1);
            }
        }, 200, TimeUnit.MILLISECONDS);

        new Flowable<Integer>() {
            @Override
            protected void subscribeActual(Subscriber<? super Integer> subscriber) {
                subscriber.onSubscribe(new BooleanSubscription());
                s[0] = subscriber;
            }
        }.blockingSubscribe(ts);

        while (!ts.isCancelled()) {
            Thread.sleep(100);
        }

        ts.assertEmpty();
    }",maybe_loop_control
i,"{
        for (int i = 0; i < TestHelper.RACE_DEFAULT_LOOPS; i++) {
            final TestSubscriber<Integer> ts = new TestSubscriber<>();

            final PublishProcessor<Integer> pp = PublishProcessor.create();

            final Runnable r1 = new Runnable() {
                @Override
                public void run() {
                    ts.cancel();
                }
            };

            final Runnable r2 = new Runnable() {
                @Override
                public void run() {
                    pp.onNext(1);
                }
            };

            final AtomicInteger c = new AtomicInteger(2);

            Schedulers.computation().scheduleDirect(new Runnable() {
                @Override
                public void run() {
                    c.decrementAndGet();
                    while (c.get() != 0 && !pp.hasSubscribers()) { }

                    TestHelper.race(r1, r2);
                }
            });

            c.decrementAndGet();
            while (c.get() != 0) { }

            pp
            .blockingSubscribe(ts);
        }
    }",loop_control
c,"{
        for (int i = 0; i < TestHelper.RACE_DEFAULT_LOOPS; i++) {
            final TestSubscriber<Integer> ts = new TestSubscriber<>();

            final PublishProcessor<Integer> pp = PublishProcessor.create();

            final Runnable r1 = new Runnable() {
                @Override
                public void run() {
                    ts.cancel();
                }
            };

            final Runnable r2 = new Runnable() {
                @Override
                public void run() {
                    pp.onNext(1);
                }
            };

            final AtomicInteger c = new AtomicInteger(2);

            Schedulers.computation().scheduleDirect(new Runnable() {
                @Override
                public void run() {
                    c.decrementAndGet();
                    while (c.get() != 0 && !pp.hasSubscribers()) { }

                    TestHelper.race(r1, r2);
                }
            });

            c.decrementAndGet();
            while (c.get() != 0) { }

            pp
            .blockingSubscribe(ts);
        }
    }",maybe_loop_control
pp,"{
        for (int i = 0; i < TestHelper.RACE_DEFAULT_LOOPS; i++) {
            final TestSubscriber<Integer> ts = new TestSubscriber<>();

            final PublishProcessor<Integer> pp = PublishProcessor.create();

            final Runnable r1 = new Runnable() {
                @Override
                public void run() {
                    ts.cancel();
                }
            };

            final Runnable r2 = new Runnable() {
                @Override
                public void run() {
                    pp.onNext(1);
                }
            };

            final AtomicInteger c = new AtomicInteger(2);

            Schedulers.computation().scheduleDirect(new Runnable() {
                @Override
                public void run() {
                    c.decrementAndGet();
                    while (c.get() != 0 && !pp.hasSubscribers()) { }

                    TestHelper.race(r1, r2);
                }
            });

            c.decrementAndGet();
            while (c.get() != 0) { }

            pp
            .blockingSubscribe(ts);
        }
    }",maybe_loop_control
c,"{
        for (int i = 0; i < TestHelper.RACE_DEFAULT_LOOPS; i++) {
            final TestSubscriber<Integer> ts = new TestSubscriber<>();

            final PublishProcessor<Integer> pp = PublishProcessor.create();

            final Runnable r1 = new Runnable() {
                @Override
                public void run() {
                    ts.cancel();
                }
            };

            final Runnable r2 = new Runnable() {
                @Override
                public void run() {
                    pp.onNext(1);
                }
            };

            final AtomicInteger c = new AtomicInteger(2);

            Schedulers.computation().scheduleDirect(new Runnable() {
                @Override
                public void run() {
                    c.decrementAndGet();
                    while (c.get() != 0 && !pp.hasSubscribers()) { }

                    TestHelper.race(r1, r2);
                }
            });

            c.decrementAndGet();
            while (c.get() != 0) { }

            pp
            .blockingSubscribe(ts);
        }
    }",maybe_loop_control
i,"{
        Flowable<Integer> src = Flowable.range(1, 10).skipWhile(LESS_THAN_FIVE);
        int n = 5;
        for (int i = 0; i < n; i++) {
            Subscriber<Object> subscriber = TestHelper.mockSubscriber();
            InOrder inOrder = inOrder(subscriber);

            src.subscribe(subscriber);

            for (int j = 5; j < 10; j++) {
                inOrder.verify(subscriber).onNext(j);
            }
            inOrder.verify(subscriber).onComplete();
            verify(subscriber, never()).onError(any(Throwable.class));
        }
    }",loop_control
j,"{
        Flowable<Integer> src = Flowable.range(1, 10).skipWhile(LESS_THAN_FIVE);
        int n = 5;
        for (int i = 0; i < n; i++) {
            Subscriber<Object> subscriber = TestHelper.mockSubscriber();
            InOrder inOrder = inOrder(subscriber);

            src.subscribe(subscriber);

            for (int j = 5; j < 10; j++) {
                inOrder.verify(subscriber).onNext(j);
            }
            inOrder.verify(subscriber).onComplete();
            verify(subscriber, never()).onError(any(Throwable.class));
        }
    }",loop_control
s,"{
        ScheduledExecutorService exec = Executors.newSingleThreadScheduledExecutor();
        try {
            for (Scheduler s : new Scheduler[] { Schedulers.single(), Schedulers.computation(), Schedulers.newThread(), Schedulers.io(), Schedulers.from(exec) }) {
                final TestSubscriber<Boolean> ts = TestSubscriber.create();
                ts.withTag(s.getClass().getSimpleName());

                Flowable.<Boolean>create(new FlowableOnSubscribe<Boolean>() {
                    @Override
                    public void subscribe(FlowableEmitter<Boolean> emitter) throws Exception {
                      emitter.onNext(Thread.interrupted());
                      emitter.onComplete();
                    }
                }, BackpressureStrategy.MISSING)
                .delaySubscription(100, TimeUnit.MILLISECONDS, s)
                .subscribe(ts);

                ts.awaitDone(5, TimeUnit.SECONDS);
                ts.assertValue(false);
            }
        } finally {
            exec.shutdown();
        }
    }",iterator
i,"{
        for (int i = 0; i < TestHelper.RACE_DEFAULT_LOOPS; i++) {
            final TestSubscriber<Integer> ts = Flowable.range(1, 10)
                    .take(5)
                    .test(0L);

            Runnable r = new Runnable() {
                @Override
                public void run() {
                    ts.request(3);
                }
            };

            TestHelper.race(r, r);

            ts.assertResult(1, 2, 3, 4, 5);
        }
    }",loop_control
i,"{
        for (int i = 0; i < TestHelper.RACE_LONG_LOOPS; i++) {

            final MulticastProcessor<Integer> mp = new MulticastProcessor<>(128, true);

            final MulticastSubscription<Integer> ms1 = new MulticastSubscription<>(null, mp);
            final MulticastSubscription<Integer> ms2 = new MulticastSubscription<>(null, mp);

            assertTrue(mp.add(ms1));

            Runnable r1 = new Runnable() {
                @Override
                public void run() {
                    mp.remove(ms1);
                }
            };

            Runnable r2 = new Runnable() {
                @Override
                public void run() {
                    mp.add(ms2);
                }
            };

            TestHelper.race(r1, r2);
        }
    }",loop_control
i,"{
        // https://github.com/Netflix/RxJava/issues/1451
        final int expectedCount = 3;
        final AtomicInteger count = new AtomicInteger();
        for (int i = 0; i < expectedCount; i++) {
            Flowable
                    .just(Boolean.TRUE, Boolean.FALSE)
                    .takeWhile(new Predicate<Boolean>() {
                        @Override
                        public boolean test(Boolean value) {
                            return value;
                        }
                    })
                    .toList()
                    .doOnSuccess(new Consumer<List<Boolean>>() {
                        @Override
                        public void accept(List<Boolean> booleans) {
                            count.incrementAndGet();
                        }
                    })
                    .subscribe();
        }
        assertEquals(expectedCount, count.get());
    }",loop_control
i,"{
        // https://github.com/Netflix/RxJava/issues/1451
        final int expectedCount = 3;
        final AtomicInteger count = new AtomicInteger();
        for (int i = 0; i < expectedCount; i++) {
            Flowable
                    .just(Boolean.TRUE, Boolean.FALSE, Boolean.FALSE)
                    .takeWhile(new Predicate<Boolean>() {
                        @Override
                        public boolean test(Boolean value) {
                            return value;
                        }
                    })
                    .toList()
                    .doOnSuccess(new Consumer<List<Boolean>>() {
                        @Override
                        public void accept(List<Boolean> booleans) {
                            count.incrementAndGet();
                        }
                    })
                    .subscribe();
        }
        assertEquals(expectedCount, count.get());
    }",loop_control
value,"{
        return Flowable.unsafeCreate(new Publisher<String>() {

            @Override
            public void subscribe(final Subscriber<? super String> subscriber) {
                final CompositeDisposable parentSubscription = new CompositeDisposable();

                subscriber.onSubscribe(new Subscription() {
                    @Override
                    public void request(long n) {

                    }

                    @Override
                    public void cancel() {
                        parentSubscription.dispose();
                    }
                });

                long delay = interval;
                for (final String value : values) {
                    parentSubscription.add(innerScheduler.schedule(new Runnable() {
                        @Override
                        public void run() {
                            subscriber.onNext(value);
                        }
                    }
                    , delay, TimeUnit.MILLISECONDS));
                    delay += interval;
                }
                parentSubscription.add(innerScheduler.schedule(new Runnable() {
                    @Override
                    public void run() {
                            if (e == null) {
                                subscriber.onComplete();
                            } else {
                                subscriber.onError(e);
                            }
                    }
                }, delay, TimeUnit.MILLISECONDS));
            }
        });
    }",iterator
i,"{
        for (int i = 0; i < TestHelper.RACE_DEFAULT_LOOPS; i++) {
            final PublishProcessor<Integer> pp1 = PublishProcessor.create();
            final PublishProcessor<Integer> pp2 = PublishProcessor.create();

            TestSubscriberEx<Integer> ts = Flowable.ambArray(pp1, pp2).to(TestHelper.<Integer>testConsumer());

            Runnable r1 = new Runnable() {
                @Override
                public void run() {
                    pp1.onNext(1);
                }
            };
            Runnable r2 = new Runnable() {
                @Override
                public void run() {
                    pp2.onNext(1);
                }
            };

            TestHelper.race(r1, r2);

            ts.assertSubscribed().assertNoErrors()
            .assertNotComplete().assertValueCount(1);
        }
    }",loop_control
i,"{
        for (int i = 0; i < TestHelper.RACE_DEFAULT_LOOPS; i++) {
            final PublishProcessor<Integer> pp1 = PublishProcessor.create();
            final PublishProcessor<Integer> pp2 = PublishProcessor.create();

            TestSubscriber<Integer> ts = Flowable.ambArray(pp1, pp2).test();

            Runnable r1 = new Runnable() {
                @Override
                public void run() {
                    pp1.onComplete();
                }
            };
            Runnable r2 = new Runnable() {
                @Override
                public void run() {
                    pp2.onComplete();
                }
            };

            TestHelper.race(r1, r2);

            ts.assertResult();
        }
    }",loop_control
i,"{
        for (int i = 0; i < TestHelper.RACE_DEFAULT_LOOPS; i++) {
            final PublishProcessor<Integer> pp1 = PublishProcessor.create();
            final PublishProcessor<Integer> pp2 = PublishProcessor.create();

            TestSubscriber<Integer> ts = Flowable.ambArray(pp1, pp2).test();

            final Throwable ex = new TestException();

            Runnable r1 = new Runnable() {
                @Override
                public void run() {
                    pp1.onError(ex);
                }
            };
            Runnable r2 = new Runnable() {
                @Override
                public void run() {
                    pp2.onError(ex);
                }
            };

            List<Throwable> errors = TestHelper.trackPluginErrors();
            try {
                TestHelper.race(r1, r2);
            } finally {
                RxJavaPlugins.reset();
            }

            ts.assertFailure(TestException.class);
            if (!errors.isEmpty()) {
                TestHelper.assertUndeliverable(errors, 0, TestException.class);
            }
        }
    }",loop_control
i,"{
        for (int i = 0; i < TestHelper.RACE_LONG_LOOPS; i++) {
            final AtomicBoolean interrupted = new AtomicBoolean();
            final CountDownLatch cdl = new CountDownLatch(1);

            Flowable.ambArray(
                Flowable.just(1)
                    .subscribeOn(Schedulers.single())
                    .observeOn(Schedulers.computation()),
                Flowable.never()
            )
            .subscribe(new Consumer<Object>() {
                @Override
                public void accept(Object v) throws Exception {
                    interrupted.set(Thread.currentThread().isInterrupted());
                    cdl.countDown();
                }
            });

            assertTrue(cdl.await(500, TimeUnit.SECONDS));
            assertFalse(""Interrupted!"", interrupted.get());
        }
    }",loop_control
i,"{
        final TestException ex = new TestException();
        for (int i = 0; i < TestHelper.RACE_LONG_LOOPS; i++) {
            final AtomicBoolean interrupted = new AtomicBoolean();
            final CountDownLatch cdl = new CountDownLatch(1);

            Flowable.ambArray(
                Flowable.error(ex)
                    .subscribeOn(Schedulers.single())
                    .observeOn(Schedulers.computation()),
                Flowable.never()
            )
            .subscribe(Functions.emptyConsumer(), new Consumer<Throwable>() {
                @Override
                public void accept(Throwable e) throws Exception {
                    interrupted.set(Thread.currentThread().isInterrupted());
                    cdl.countDown();
                }
            });

            assertTrue(cdl.await(500, TimeUnit.SECONDS));
            assertFalse(""Interrupted!"", interrupted.get());
        }
    }",loop_control
i,"{
        for (int i = 0; i < TestHelper.RACE_LONG_LOOPS; i++) {
            final AtomicBoolean interrupted = new AtomicBoolean();
            final CountDownLatch cdl = new CountDownLatch(1);

            Flowable.ambArray(
                Flowable.empty()
                    .subscribeOn(Schedulers.single())
                    .observeOn(Schedulers.computation()),
                Flowable.never()
            )
            .subscribe(Functions.emptyConsumer(), Functions.emptyConsumer(), new Action() {
                @Override
                public void run() throws Exception {
                    interrupted.set(Thread.currentThread().isInterrupted());
                    cdl.countDown();
                }
            });

            assertTrue(cdl.await(500, TimeUnit.SECONDS));
            assertFalse(""Interrupted!"", interrupted.get());
        }
    }",loop_control
i,"{
        for (int i = 0; i < TestHelper.RACE_DEFAULT_LOOPS; i++) {
            final TestScheduler scheduler = new TestScheduler();

            final PublishProcessor<Integer> pp = PublishProcessor.create();

            TestSubscriber<Integer> ts = pp.sample(1, TimeUnit.SECONDS, scheduler, true)
            .test();

            pp.onNext(1);

            Runnable r1 = new Runnable() {
                @Override
                public void run() {
                    pp.onComplete();
                }
            };

            Runnable r2 = new Runnable() {
                @Override
                public void run() {
                    scheduler.advanceTimeBy(1, TimeUnit.SECONDS);
                }
            };

            TestHelper.race(r1, r2);

            ts.assertResult(1);
        }
    }",loop_control
i,"{
        for (int i = 0; i < TestHelper.RACE_DEFAULT_LOOPS; i++) {
            final PublishProcessor<Integer> pp = PublishProcessor.create();
            final PublishProcessor<Integer> sampler = PublishProcessor.create();

            TestSubscriber<Integer> ts = pp.sample(sampler, true)
            .test();

            pp.onNext(1);

            Runnable r1 = new Runnable() {
                @Override
                public void run() {
                    pp.onComplete();
                }
            };

            Runnable r2 = new Runnable() {
                @Override
                public void run() {
                    sampler.onNext(1);
                }
            };

            TestHelper.race(r1, r2);

            ts.assertResult(1);
        }
    }",loop_control
i,"{
        for (int i = 0; i < TestHelper.RACE_DEFAULT_LOOPS; i++) {
            final PublishProcessor<Integer> pp = PublishProcessor.create();
            final PublishProcessor<Integer> sampler = PublishProcessor.create();

            TestSubscriber<Integer> ts = pp.sample(sampler, true).test();

            pp.onNext(1);

            Runnable r1 = new Runnable() {
                @Override
                public void run() {
                    pp.onComplete();
                }
            };

            Runnable r2 = new Runnable() {
                @Override
                public void run() {
                    sampler.onComplete();
                }
            };

            TestHelper.race(r1, r2);

            ts.assertResult(1);
        }
    }",loop_control
i,"{
        for (int i = 0; i < 10000; i++) {
            final PublishProcessor<Integer> pp = PublishProcessor.create();
            final SingleSubject<Integer> cs = SingleSubject.create();

            TestSubscriber<Integer> ts = pp.mergeWith(cs).test();

            Runnable r1 = new Runnable() {
                @Override
                public void run() {
                    pp.onNext(1);
                    pp.onComplete();
                }
            };

            Runnable r2 = new Runnable() {
                @Override
                public void run() {
                    cs.onSuccess(1);
                }
            };

            TestHelper.race(r1, r2);

            ts.assertResult(1, 1);
        }
    }",loop_control
i,"{
        for (int i = 0; i < 10000; i++) {
            final PublishProcessor<Integer> pp = PublishProcessor.create();
            final SingleSubject<Integer> cs = SingleSubject.create();

            final TestSubscriber<Integer> ts = pp.mergeWith(cs).subscribeWith(new TestSubscriber<>(0));

            Runnable r1 = new Runnable() {
                @Override
                public void run() {
                    cs.onSuccess(1);
                }
            };

            Runnable r2 = new Runnable() {
                @Override
                public void run() {
                    ts.request(2);
                }
            };

            TestHelper.race(r1, r2);

            pp.onNext(2);
            pp.onComplete();

            ts.assertResult(1, 2);
        }
    }",loop_control
i,"{
        for (int i = 0; i < 10000; i++) {
            final PublishProcessor<Integer> pp = PublishProcessor.create();
            final SingleSubject<Integer> cs = SingleSubject.create();

            final TestSubscriber<Integer> ts = pp.mergeWith(cs).test(0);

            pp.onNext(0);

            Runnable r1 = new Runnable() {
                @Override
                public void run() {
                    pp.onNext(1);
                }
            };

            Runnable r2 = new Runnable() {
                @Override
                public void run() {
                    ts.request(3);
                }
            };

            TestHelper.race(r1, r2);

            cs.onSuccess(1);
            pp.onComplete();

            ts.assertResult(0, 1, 1);
        }
    }",loop_control
i,"{
        final PublishProcessor<Integer> pp = PublishProcessor.create();
        final SingleSubject<Integer> cs = SingleSubject.create();

        TestSubscriber<Integer> ts = pp.mergeWith(cs)
                .subscribeWith(new TestSubscriber<Integer>() {
            @Override
            public void onNext(Integer t) {
                super.onNext(t);
                if (t == 1) {
                    for (int i = 0; i < Flowable.bufferSize() - 1; i++) {
                        pp.onNext(i + 2);
                    }
                }
            }
        });

        cs.onSuccess(1);

        pp.onComplete();

        ts.request(2);
        ts.assertValueCount(Flowable.bufferSize());
        ts.assertComplete();
    }",loop_control
timeout,"{
        List<Throwable> errors = TestHelper.trackPluginErrors();
        try {
            final CountDownLatch cdl1 = new CountDownLatch(1);
            final CountDownLatch cdl2 = new CountDownLatch(1);

            TestSubscriber<Object> ts = Flowable.fromCompletable(Completable.fromAction(new Action() {
                @Override
                public void run() throws Exception {
                    cdl1.countDown();
                    cdl2.await(5, TimeUnit.SECONDS);
                }
            }))
            .subscribeOn(Schedulers.single()).test();

            assertTrue(cdl1.await(5, TimeUnit.SECONDS));

            ts.cancel();

            int timeout = 10;

            while (timeout-- > 0 && errors.isEmpty()) {
                Thread.sleep(100);
            }

            TestHelper.assertUndeliverable(errors, 0, InterruptedException.class);
        } finally {
            RxJavaPlugins.reset();
        }
    }",loop_control
errors,"{
        List<Throwable> errors = TestHelper.trackPluginErrors();
        try {
            final CountDownLatch cdl1 = new CountDownLatch(1);
            final CountDownLatch cdl2 = new CountDownLatch(1);

            TestSubscriber<Object> ts = Flowable.fromCompletable(Completable.fromAction(new Action() {
                @Override
                public void run() throws Exception {
                    cdl1.countDown();
                    cdl2.await(5, TimeUnit.SECONDS);
                }
            }))
            .subscribeOn(Schedulers.single()).test();

            assertTrue(cdl1.await(5, TimeUnit.SECONDS));

            ts.cancel();

            int timeout = 10;

            while (timeout-- > 0 && errors.isEmpty()) {
                Thread.sleep(100);
            }

            TestHelper.assertUndeliverable(errors, 0, InterruptedException.class);
        } finally {
            RxJavaPlugins.reset();
        }
    }",maybe_loop_control
i,"{
        PublishProcessor<Integer> source = PublishProcessor.create();
        final List<PublishProcessor<Integer>> delays = new ArrayList<>();
        final int n = 10;
        for (int i = 0; i < n; i++) {
            PublishProcessor<Integer> delay = PublishProcessor.create();
            delays.add(delay);
        }

        Function<Integer, Flowable<Integer>> delayFunc = new Function<Integer, Flowable<Integer>>() {
            @Override
            public Flowable<Integer> apply(Integer t1) {
                return delays.get(t1);
            }
        };

        Subscriber<Object> subscriber = TestHelper.mockSubscriber();
        InOrder inOrder = inOrder(subscriber);

        source.delay(delayFunc).subscribe(subscriber);

        for (int i = 0; i < n; i++) {
            source.onNext(i);
            delays.get(i).onNext(i);
            inOrder.verify(subscriber).onNext(i);
        }
        source.onComplete();

        inOrder.verify(subscriber).onComplete();
        inOrder.verifyNoMoreInteractions();

        verify(subscriber, never()).onError(any(Throwable.class));
    }",loop_control
i,"{
        int n = 3;

        PublishProcessor<Integer> source = PublishProcessor.create();
        final List<PublishProcessor<Integer>> subjects = new ArrayList<>();
        for (int i = 0; i < n; i++) {
            subjects.add(PublishProcessor.<Integer> create());
        }

        Flowable<Integer> result = source.delay(new Function<Integer, Flowable<Integer>>() {

            @Override
            public Flowable<Integer> apply(Integer t1) {
                return subjects.get(t1);
            }
        });

        Subscriber<Object> subscriber = TestHelper.mockSubscriber();
        InOrder inOrder = inOrder(subscriber);

        result.subscribe(subscriber);

        for (int i = 0; i < n; i++) {
            source.onNext(i);
        }
        source.onComplete();

        inOrder.verify(subscriber, never()).onNext(anyInt());
        inOrder.verify(subscriber, never()).onComplete();

        for (int i = n - 1; i >= 0; i--) {
            subjects.get(i).onComplete();
            inOrder.verify(subscriber).onNext(i);
        }

        inOrder.verify(subscriber).onComplete();

        verify(subscriber, never()).onError(any(Throwable.class));
    }",loop_control
i,"{
        Integer[] array = new Integer[n];
        for (int i = 0; i < n; i++) {
            array[i] = i;
        }
        return Flowable.fromArray(array);
    }",loop_control
i,"{
        Flowable<Integer> just = Flowable.just(1);
        int n = 1000;
        for (int i = 0; i < TestHelper.RACE_DEFAULT_LOOPS; i++) {
            PublishProcessor<Flowable<Integer>> source = PublishProcessor.create();

            TestSubscriber<Integer> ts = source
                    .concatMap(v -> v, n + 1)
                    .test(1L);

            TestHelper.race(() -> {
                for (int j = 0; j < n; j++) {
                    source.onNext(just);
                }
            }, () -> {
                for (int j = 0; j < n; j++) {
                    ts.request(1);
                }
            });

            ts.assertValueCount(n);
        }
    }",loop_control
j,"{
        Flowable<Integer> just = Flowable.just(1);
        int n = 1000;
        for (int i = 0; i < TestHelper.RACE_DEFAULT_LOOPS; i++) {
            PublishProcessor<Flowable<Integer>> source = PublishProcessor.create();

            TestSubscriber<Integer> ts = source
                    .concatMap(v -> v, n + 1)
                    .test(1L);

            TestHelper.race(() -> {
                for (int j = 0; j < n; j++) {
                    source.onNext(just);
                }
            }, () -> {
                for (int j = 0; j < n; j++) {
                    ts.request(1);
                }
            });

            ts.assertValueCount(n);
        }
    }",loop_control
i,"{
        Flowable<Integer> just = Flowable.just(1);
        int n = 1000;
        for (int i = 0; i < TestHelper.RACE_DEFAULT_LOOPS; i++) {
            PublishProcessor<Flowable<Integer>> source = PublishProcessor.create();

            TestSubscriber<Integer> ts = source
                    .concatMapDelayError(v -> v, true, n + 1)
                    .test(1L);

            TestHelper.race(() -> {
                for (int j = 0; j < n; j++) {
                    source.onNext(just);
                }
            }, () -> {
                for (int j = 0; j < n; j++) {
                    ts.request(1);
                }
            });

            ts.assertValueCount(n);
        }
    }",loop_control
j,"{
        Flowable<Integer> just = Flowable.just(1);
        int n = 1000;
        for (int i = 0; i < TestHelper.RACE_DEFAULT_LOOPS; i++) {
            PublishProcessor<Flowable<Integer>> source = PublishProcessor.create();

            TestSubscriber<Integer> ts = source
                    .concatMapDelayError(v -> v, true, n + 1)
                    .test(1L);

            TestHelper.race(() -> {
                for (int j = 0; j < n; j++) {
                    source.onNext(just);
                }
            }, () -> {
                for (int j = 0; j < n; j++) {
                    ts.request(1);
                }
            });

            ts.assertValueCount(n);
        }
    }",loop_control
i,"{
        for (int i = 0; i < 10000; i++) {
            final PublishProcessor<Integer> pp = PublishProcessor.create();
            final MaybeSubject<Integer> cs = MaybeSubject.create();

            TestSubscriber<Integer> ts = pp.mergeWith(cs).test();

            Runnable r1 = new Runnable() {
                @Override
                public void run() {
                    pp.onNext(1);
                    pp.onComplete();
                }
            };

            Runnable r2 = new Runnable() {
                @Override
                public void run() {
                    cs.onSuccess(1);
                }
            };

            TestHelper.race(r1, r2);

            ts.assertResult(1, 1);
        }
    }",loop_control
i,"{
        for (int i = 0; i < 10000; i++) {
            final PublishProcessor<Integer> pp = PublishProcessor.create();
            final MaybeSubject<Integer> cs = MaybeSubject.create();

            final TestSubscriber<Integer> ts = pp.mergeWith(cs).subscribeWith(new TestSubscriber<>(0));

            Runnable r1 = new Runnable() {
                @Override
                public void run() {
                    cs.onSuccess(1);
                }
            };

            Runnable r2 = new Runnable() {
                @Override
                public void run() {
                    ts.request(2);
                }
            };

            TestHelper.race(r1, r2);

            pp.onNext(2);
            pp.onComplete();

            ts.assertResult(1, 2);
        }
    }",loop_control
i,"{
        for (int i = 0; i < 10000; i++) {
            final PublishProcessor<Integer> pp = PublishProcessor.create();
            final MaybeSubject<Integer> cs = MaybeSubject.create();

            final TestSubscriber<Integer> ts = pp.mergeWith(cs).test(0);

            pp.onNext(0);

            Runnable r1 = new Runnable() {
                @Override
                public void run() {
                    pp.onNext(1);
                }
            };

            Runnable r2 = new Runnable() {
                @Override
                public void run() {
                    ts.request(3);
                }
            };

            TestHelper.race(r1, r2);

            cs.onSuccess(1);
            pp.onComplete();

            ts.assertResult(0, 1, 1);
        }
    }",loop_control
i,"{
        final PublishProcessor<Integer> pp = PublishProcessor.create();
        final MaybeSubject<Integer> cs = MaybeSubject.create();

        TestSubscriber<Integer> ts = pp.mergeWith(cs)
                .subscribeWith(new TestSubscriber<Integer>() {
            @Override
            public void onNext(Integer t) {
                super.onNext(t);
                if (t == 1) {
                    for (int i = 0; i < Flowable.bufferSize() - 1; i++) {
                        pp.onNext(i + 2);
                    }
                }
            }
        });

        cs.onSuccess(1);

        pp.onComplete();

        ts.request(2);
        ts.assertValueCount(Flowable.bufferSize());
        ts.assertComplete();
    }",loop_control
i,"{
        ArrayList<Integer> list = new ArrayList<>(Flowable.bufferSize() * 2);
        for (int i = 1; i <= Flowable.bufferSize() * 2 + 1; i++) {
            list.add(i);
        }

        Flowable<Integer> f = Flowable.range(1, list.size());

        TestSubscriberEx<Integer> ts = new TestSubscriberEx<>(0L);

        ts.assertNoValues();
        ts.request(Long.MAX_VALUE); // infinite

        f.subscribe(ts);

        ts.assertValueSequence(list);
        ts.assertTerminated();
    }",loop_control
i,"{
        Flowable<Integer> source = Flowable.range(start, 100);

        TestSubscriberEx<Integer> ts = new TestSubscriberEx<>(0L);
        ts.request(1);
        source.subscribe(ts);

        List<Integer> list = new ArrayList<>(100);
        for (int i = 0; i < 100; i++) {
            list.add(i + start);
            ts.request(1);
        }
        ts.assertValueSequence(list);
        ts.assertTerminated();
    }",loop_control
i,"{
        Flowable<Integer> source = Flowable.range(start, 100);

        TestSubscriberEx<Integer> ts = new TestSubscriberEx<>(0L);
        ts.request(100);
        source.subscribe(ts);

        List<Integer> list = new ArrayList<>(100);
        for (int i = 0; i < 100; i++) {
            list.add(i + start);
        }
        ts.assertValueSequence(list);
        ts.assertTerminated();
    }",loop_control
i,"{
        for (int i = 0; i < 100; i++) {
            withBackpressureOneByOne(i);
        }
    }",loop_control
i,"{
        for (int i = 0; i < 100; i++) {
            withBackpressureAllAtOnce(i);
        }
    }",loop_control
i,"{
        Flowable<Integer> source = Flowable.range(50, 100);

        TestSubscriberEx<Integer> ts = new TestSubscriberEx<>(0L);
        ts.request(150);
        source.subscribe(ts);

        List<Integer> list = new ArrayList<>(100);
        for (int i = 0; i < 100; i++) {
            list.add(i + 50);
        }

        ts.request(50); // and then some

        ts.assertValueSequence(list);
        ts.assertTerminated();
    }",loop_control
i,"{
        return Flowable.unsafeCreate(new Publisher<Integer>() {

            @Override
            public void subscribe(final Subscriber<? super Integer> subscriber) {
                BooleanSubscription bs = new BooleanSubscription();
                subscriber.onSubscribe(bs);
                for (int i = 1; i <= 5; i++) {
                    if (bs.isCancelled()) {
                        break;
                    }
                    numEmitted.incrementAndGet();
                    subscriber.onNext(i);
                    Thread.yield();
                }
                subscriber.onComplete();
            }

        });
    }",loop_control
bs,"{
        return Flowable.unsafeCreate(new Publisher<Integer>() {

            @Override
            public void subscribe(final Subscriber<? super Integer> subscriber) {
                BooleanSubscription bs = new BooleanSubscription();
                subscriber.onSubscribe(bs);
                for (int i = 1; i <= 5; i++) {
                    if (bs.isCancelled()) {
                        break;
                    }
                    numEmitted.incrementAndGet();
                    subscriber.onNext(i);
                    Thread.yield();
                }
                subscriber.onComplete();
            }

        });
    }",break_loop_control
bs,"{
        return Flowable.unsafeCreate(new Publisher<Integer>() {

            @Override
            public void subscribe(final Subscriber<? super Integer> subscriber) {
                final BooleanSubscription bs = new BooleanSubscription();
                subscriber.onSubscribe(bs);
                Thread t = new Thread(new Runnable() {

                    @Override
                    public void run() {
                        System.out.println(""-------> subscribe to infinite sequence"");
                        System.out.println(""Starting thread: "" + Thread.currentThread());
                        int i = 1;
                        while (!bs.isCancelled()) {
                            subscriber.onNext(i++);
                            Thread.yield();
                        }
                        subscriber.onComplete();
                        latch.countDown();
                        System.out.println(""Ending thread: "" + Thread.currentThread());
                    }
                });
                t.start();

            }

        });
    }",maybe_loop_control
i,"{
        // https://github.com/ReactiveX/RxJava/issues/1812
        Flowable<Integer> zip1 = Flowable.zip(Flowable.range(0, 1026), Flowable.range(0, 1026),
                new BiFunction<Integer, Integer, Integer>() {

                    @Override
                    public Integer apply(Integer i1, Integer i2) {
                        return i1 + i2;
                    }
                });
        Flowable<Integer> zip2 = Flowable.zip(zip1, Flowable.range(0, 1026),
                new BiFunction<Integer, Integer, Integer>() {

                    @Override
                    public Integer apply(Integer i1, Integer i2) {
                        return i1 + i2;
                    }
                });
        List<Integer> expected = new ArrayList<>();
        for (int i = 0; i < 1026; i++) {
            expected.add(i * 3);
        }
        assertEquals(expected, zip2.toList().blockingGet());
    }",loop_control
i,"{
        long startTime = System.currentTimeMillis();
        Flowable<Integer> src = Flowable.just(1).subscribeOn(Schedulers.computation());

        // now try and generate a hang by zipping src with itself repeatedly. A
        // time limit of 9 seconds ( 1 second less than the test timeout) is
        // used so that this test will not timeout on slow machines.
        int i = 0;
        while (System.currentTimeMillis() - startTime < 9000 && i++ < 100000) {
            int value = Flowable.zip(src, src, new BiFunction<Integer, Integer, Integer>() {
                @Override
                public Integer apply(Integer t1, Integer t2) {
                    return t1 + t2 * 10;
                }
            }).blockingSingle(0);

            Assert.assertEquals(11, value);
        }
    }",loop_control
j,"{
        Flowable source = Flowable.just(1);

        for (int i = 2; i < 10; i++) {
            Class<?>[] types = new Class[i + 1];
            Arrays.fill(types, Publisher.class);
            types[i] = i == 2 ? BiFunction.class : Class.forName(""io.reactivex.rxjava3.functions.Function"" + i);

            Method m = Flowable.class.getMethod(""zip"", types);

            Object[] params = new Object[i + 1];
            Arrays.fill(params, source);
            params[i] = ArgsToString.INSTANCE;

            StringBuilder b = new StringBuilder();
            for (int j = 0; j < i; j++) {
                b.append('1');
            }

            ((Flowable)m.invoke(null, params)).test().assertResult(b.toString());

            for (int j = 0; j < params.length; j++) {
                Object[] params0 = params.clone();
                params0[j] = null;

                try {
                    m.invoke(null, params0);
                    fail(""Should have thrown @ "" + m);
                } catch (InvocationTargetException ex) {
                    assertTrue(ex.toString(), ex.getCause() instanceof NullPointerException);

                    if (j < i) {
                        assertEquals(""source"" + (j + 1) + "" is null"", ex.getCause().getMessage());
                    } else {
                        assertEquals(""zipper is null"", ex.getCause().getMessage());
                    }
                }
            }
        }
    }",loop_control
i,"{
        Flowable source = Flowable.just(1);

        for (int i = 2; i < 10; i++) {
            Class<?>[] types = new Class[i + 1];
            Arrays.fill(types, Publisher.class);
            types[i] = i == 2 ? BiFunction.class : Class.forName(""io.reactivex.rxjava3.functions.Function"" + i);

            Method m = Flowable.class.getMethod(""zip"", types);

            Object[] params = new Object[i + 1];
            Arrays.fill(params, source);
            params[i] = ArgsToString.INSTANCE;

            StringBuilder b = new StringBuilder();
            for (int j = 0; j < i; j++) {
                b.append('1');
            }

            ((Flowable)m.invoke(null, params)).test().assertResult(b.toString());

            for (int j = 0; j < params.length; j++) {
                Object[] params0 = params.clone();
                params0[j] = null;

                try {
                    m.invoke(null, params0);
                    fail(""Should have thrown @ "" + m);
                } catch (InvocationTargetException ex) {
                    assertTrue(ex.toString(), ex.getCause() instanceof NullPointerException);

                    if (j < i) {
                        assertEquals(""source"" + (j + 1) + "" is null"", ex.getCause().getMessage());
                    } else {
                        assertEquals(""zipper is null"", ex.getCause().getMessage());
                    }
                }
            }
        }
    }",loop_control
i,"{
        for (int i = 0; i < 500; i++) {
            TestSubscriber<List<Object>> ts = Flowable.zip(
                    Flowable.just(1).observeOn(Schedulers.single()).map(new Function<Integer, Object>() {
                        @Override
                        public Object apply(Integer v) throws Exception {
                            return Thread.currentThread().getName().substring(0, 4);
                        }
                    }),
                    Flowable.just(1).observeOn(Schedulers.computation()).map(new Function<Integer, Object>() {
                        @Override
                        public Object apply(Integer v) throws Exception {
                            return Thread.currentThread().getName().substring(0, 4);
                        }
                    }),
                    new BiFunction<Object, Object, List<Object>>() {
                        @Override
                        public List<Object> apply(Object t1, Object t2) throws Exception {
                            return Arrays.asList(t1, t2);
                        }
                    }
            )
            .test()
            .awaitDone(5, TimeUnit.SECONDS)
            .assertValueCount(1);

            List<Object> list = ts.values().get(0);

            assertTrue(list.toString(), list.contains(""RxSi""));
            assertTrue(list.toString(), list.contains(""RxCo""));
        }
    }",loop_control
r2,"{
        PublishProcessor<String> r1 = PublishProcessor.create();
        /* define a Subscriber to receive aggregated events */
        Subscriber<String> subscriber = TestHelper.mockSubscriber();
        InOrder io = inOrder(subscriber);

        Iterable<String> r2 = new Iterable<String>() {

            @Override
            public Iterator<String> iterator() {
                return new Iterator<String>() {
                    int count;

                    @Override
                    public boolean hasNext() {
                        if (count == 0) {
                            return true;
                        }
                        throw new TestException();
                    }

                    @Override
                    public String next() {
                        count++;
                        return ""1"";
                    }

                    @Override
                    public void remove() {
                        throw new UnsupportedOperationException(""Not supported yet."");
                    }

                };
            }

        };

        r1.zipWith(r2, zipr2).subscribe(subscriber);

        r1.onNext(""one-"");
        r1.onError(new TestException());

        io.verify(subscriber).onNext(""one-1"");
        io.verify(subscriber).onError(any(TestException.class));

        verify(subscriber, never()).onComplete();

    }",iterator
s,"{

        String[] valuesToReturn;

        TestAsyncErrorObservable(String... values) {
            valuesToReturn = values;
        }

        volatile Thread t;

        @Override
        public void subscribe(final Subscriber<? super String> subscriber) {
            subscriber.onSubscribe(new BooleanSubscription());
            t = new Thread(new Runnable() {

                @Override
                public void run() {
                    for (String s : valuesToReturn) {
                        if (s == null) {
                            System.out.println(""throwing exception"");
                            try {
                                Thread.sleep(100);
                            } catch (Throwable e) {

                            }
                            subscriber.onError(new NullPointerException());
                            return;
                        } else {
                            subscriber.onNext(s);
                        }
                    }
                    System.out.println(""subscription complete"");
                    subscriber.onComplete();
                }

            });
            t.start();
        }
    }",iterator
timeout,"{
        List<Throwable> errors = TestHelper.trackPluginErrors();
        try {
            final CountDownLatch cdl1 = new CountDownLatch(1);
            final CountDownLatch cdl2 = new CountDownLatch(1);

            TestSubscriber<Object> ts = Flowable.fromRunnable(new Runnable() {
                @Override
                public void run() {
                    cdl1.countDown();
                    try {
                        cdl2.await(5, TimeUnit.SECONDS);
                    } catch (InterruptedException e) {
                        e.printStackTrace();
                        throw new TestException(e);
                    }
                }
            }).subscribeOn(Schedulers.single()).test();

            assertTrue(cdl1.await(5, TimeUnit.SECONDS));

            ts.cancel();

            int timeout = 10;

            while (timeout-- > 0 && errors.isEmpty()) {
                Thread.sleep(100);
            }

            TestHelper.assertUndeliverable(errors, 0, TestException.class);
        } finally {
            RxJavaPlugins.reset();
        }
    }",loop_control
errors,"{
        List<Throwable> errors = TestHelper.trackPluginErrors();
        try {
            final CountDownLatch cdl1 = new CountDownLatch(1);
            final CountDownLatch cdl2 = new CountDownLatch(1);

            TestSubscriber<Object> ts = Flowable.fromRunnable(new Runnable() {
                @Override
                public void run() {
                    cdl1.countDown();
                    try {
                        cdl2.await(5, TimeUnit.SECONDS);
                    } catch (InterruptedException e) {
                        e.printStackTrace();
                        throw new TestException(e);
                    }
                }
            }).subscribeOn(Schedulers.single()).test();

            assertTrue(cdl1.await(5, TimeUnit.SECONDS));

            ts.cancel();

            int timeout = 10;

            while (timeout-- > 0 && errors.isEmpty()) {
                Thread.sleep(100);
            }

            TestHelper.assertUndeliverable(errors, 0, TestException.class);
        } finally {
            RxJavaPlugins.reset();
        }
    }",maybe_loop_control
i,"{
        for (int i = 0; i < TestHelper.RACE_DEFAULT_LOOPS; i++) {
            final TestSubscriber<Long> ts = new TestSubscriber<>();

            final TestScheduler scheduler = new TestScheduler();

            Flowable.timer(1, TimeUnit.SECONDS, scheduler)
            .subscribe(ts);

            Runnable r1 = new Runnable() {
                @Override
                public void run() {
                    scheduler.advanceTimeBy(1, TimeUnit.SECONDS);
                }
            };

            Runnable r2 = new Runnable() {
                @Override
                public void run() {
                    ts.cancel();
                }
            };

            TestHelper.race(r1, r2);
        }
    }",loop_control
i,"{
        List<Throwable> errors = TestHelper.trackPluginErrors();
        try {
            for (int i = 0; i < 1000; i++) {
                Flowable.timer(0, TimeUnit.MILLISECONDS).blockingFirst();
            }

            assertTrue(errors.toString(), errors.isEmpty());
        } finally {
            RxJavaPlugins.reset();
        }
    }",loop_control
s,"{
        ScheduledExecutorService exec = Executors.newSingleThreadScheduledExecutor();
        try {
            for (Scheduler s : new Scheduler[] { Schedulers.single(), Schedulers.computation(), Schedulers.newThread(), Schedulers.io(), Schedulers.from(exec, true) }) {
                final AtomicBoolean interrupted = new AtomicBoolean();
                TestSubscriber<Long> ts = Flowable.timer(1, TimeUnit.MILLISECONDS, s)
                .map(new Function<Long, Long>() {
                    @Override
                    public Long apply(Long v) throws Exception {
                        try {
                        Thread.sleep(3000);
                        } catch (InterruptedException ex) {
                            interrupted.set(true);
                        }
                        return v;
                    }
                })
                .test();

                Thread.sleep(500);

                ts.cancel();

                Thread.sleep(500);

                assertTrue(s.getClass().getSimpleName(), interrupted.get());
            }
        } finally {
            exec.shutdown();
        }
    }",iterator
it,"{
        TestScheduler scheduler = new TestScheduler();

        Flowable<Long> source = Flowable.interval(1, TimeUnit.SECONDS, scheduler).take(10);

        Iterable<Long> iter = source.blockingLatest();

        Iterator<Long> it = iter.iterator();

        // only 9 because take(10) will immediately call onComplete when receiving the 10th item
        // which onComplete will overwrite the previous value
        for (int i = 0; i < 9; i++) {
            scheduler.advanceTimeBy(1, TimeUnit.SECONDS);

            Assert.assertTrue(it.hasNext());

            Assert.assertEquals(Long.valueOf(i), it.next());
        }

        scheduler.advanceTimeBy(1, TimeUnit.SECONDS);
        Assert.assertFalse(it.hasNext());
    }",iterator
j,"{
        TestScheduler scheduler = new TestScheduler();

        Flowable<Long> source = Flowable.interval(1, TimeUnit.SECONDS, scheduler).take(10);

        Iterable<Long> iter = source.blockingLatest();

        for (int j = 0; j < 3; j++) {
            Iterator<Long> it = iter.iterator();

            // only 9 because take(10) will immediately call onComplete when receiving the 10th item
            // which onComplete will overwrite the previous value
            for (int i = 0; i < 9; i++) {
                scheduler.advanceTimeBy(1, TimeUnit.SECONDS);

                Assert.assertTrue(it.hasNext());

                Assert.assertEquals(Long.valueOf(i), it.next());
            }

            scheduler.advanceTimeBy(1, TimeUnit.SECONDS);
            Assert.assertFalse(it.hasNext());
        }
    }",loop_control
i,"{
        TestScheduler scheduler = new TestScheduler();

        Flowable<Long> source = Flowable.interval(1, TimeUnit.SECONDS, scheduler).take(10);

        Iterable<Long> iter = source.blockingLatest();

        for (int j = 0; j < 3; j++) {
            Iterator<Long> it = iter.iterator();

            // only 9 because take(10) will immediately call onComplete when receiving the 10th item
            // which onComplete will overwrite the previous value
            for (int i = 0; i < 9; i++) {
                scheduler.advanceTimeBy(1, TimeUnit.SECONDS);

                Assert.assertTrue(it.hasNext());

                Assert.assertEquals(Long.valueOf(i), it.next());
            }

            scheduler.advanceTimeBy(1, TimeUnit.SECONDS);
            Assert.assertFalse(it.hasNext());
        }
    }",loop_control
it,"{
        TestScheduler scheduler = new TestScheduler();

        Flowable<Long> source = Flowable.interval(1, TimeUnit.SECONDS, scheduler).take(10);

        Iterable<Long> iter = source.blockingLatest();

        for (int j = 0; j < 3; j++) {
            Iterator<Long> it = iter.iterator();

            // only 9 because take(10) will immediately call onComplete when receiving the 10th item
            // which onComplete will overwrite the previous value
            for (int i = 0; i < 9; i++) {
                scheduler.advanceTimeBy(1, TimeUnit.SECONDS);

                Assert.assertTrue(it.hasNext());

                Assert.assertEquals(Long.valueOf(i), it.next());
            }

            scheduler.advanceTimeBy(1, TimeUnit.SECONDS);
            Assert.assertFalse(it.hasNext());
        }
    }",iterator
it,"{
        Flowable<Long> source = Flowable.<Long> empty();

        Iterable<Long> iter = source.blockingLatest();

        Iterator<Long> it = iter.iterator();

        Assert.assertFalse(it.hasNext());

        it.next();
    }",iterator
i,"{
        TestScheduler scheduler = new TestScheduler();

        Flowable<Long> source = Flowable.interval(1, TimeUnit.SECONDS, scheduler).take(10);

        Iterable<Long> iter = source.blockingLatest();

        Iterator<Long> it = iter.iterator();

        // only 9 because take(10) will immediately call onComplete when receiving the 10th item
        // which onComplete will overwrite the previous value
        for (int i = 0; i < 10; i++) {
            scheduler.advanceTimeBy(1, TimeUnit.SECONDS);

            Assert.assertEquals(Long.valueOf(i), it.next());
        }
    }",loop_control
it,"{
        TestScheduler scheduler = new TestScheduler();

        Flowable<Long> source = Flowable.interval(1, TimeUnit.SECONDS, scheduler).take(10);

        Iterable<Long> iter = source.blockingLatest();

        Iterator<Long> it = iter.iterator();

        // only 9 because take(10) will immediately call onComplete when receiving the 10th item
        // which onComplete will overwrite the previous value
        for (int i = 0; i < 10; i++) {
            scheduler.advanceTimeBy(1, TimeUnit.SECONDS);

            Assert.assertEquals(Long.valueOf(i), it.next());
        }
    }",iterator
it,"{
        TestScheduler scheduler = new TestScheduler();

        Flowable<Long> source = Flowable.<Long> error(new RuntimeException(""Forced failure!"")).subscribeOn(scheduler);

        Iterable<Long> iter = source.blockingLatest();

        Iterator<Long> it = iter.iterator();

        scheduler.advanceTimeBy(1, TimeUnit.SECONDS);

        it.hasNext();
    }",iterator
it,"{
        TestScheduler scheduler = new TestScheduler();

        Flowable<Long> source = Flowable.<Long> error(new RuntimeException(""Forced failure!"")).subscribeOn(scheduler);

        Iterable<Long> iter = source.blockingLatest();
        Iterator<Long> it = iter.iterator();

        scheduler.advanceTimeBy(1, TimeUnit.SECONDS);

        it.next();
    }",iterator
it,"{
        PublishProcessor<Integer> source = PublishProcessor.create();
        Flowable<Integer> blocker = source;

        Iterable<Integer> iter = blocker.blockingLatest();
        Iterator<Integer> it = iter.iterator();

        source.onNext(1);

        Assert.assertEquals(Integer.valueOf(1), it.next());

        source.onNext(2);
        source.onNext(3);

        Assert.assertEquals(Integer.valueOf(3), it.next());

        source.onNext(4);
        source.onNext(5);
        source.onNext(6);

        Assert.assertEquals(Integer.valueOf(6), it.next());

        source.onNext(7);
        source.onComplete();

        Assert.assertFalse(it.hasNext());
    }",iterator
it,"{
        Iterator<Object> it = Flowable.never().blockingLatest().iterator();

        Thread.currentThread().interrupt();

        try {
            it.hasNext();
        } catch (RuntimeException ex) {
            assertTrue(ex.toString(), ex.getCause() instanceof InterruptedException);
        }
        Thread.interrupted();
    }",iterator
it,"{
        Iterator<Object> it = Flowable.error(new TestException()).blockingLatest().iterator();

        for (int i = 0; i < 3; i++) {
            try {
                it.hasNext();
                fail(""Should have thrown"");
            } catch (TestException ex) {
                // expected
            }
        }
    }",iterator
i,"{
        Iterator<Object> it = Flowable.error(new TestException()).blockingLatest().iterator();

        for (int i = 0; i < 3; i++) {
            try {
                it.hasNext();
                fail(""Should have thrown"");
            } catch (TestException ex) {
                // expected
            }
        }
    }",loop_control
it,"{
        Iterator<Object> it = Flowable.never().blockingLatest().iterator();

        List<Throwable> errors = TestHelper.trackPluginErrors();
        try {
            ((Subscriber<Object>)it).onError(new TestException());

            TestHelper.assertUndeliverable(errors, 0, TestException.class);
        } finally {
            RxJavaPlugins.reset();
        }
    }",iterator
t,"{
        Flowable<String> obs = Flowable.just(""one"", ""null"", ""two"", ""three"", ""four"");

        Subscriber<String> subscriber = TestHelper.mockSubscriber();

        InOrder inOrder = inOrder(subscriber);
        TestSubscriberEx<String> ts = new TestSubscriberEx<>(subscriber);

        obs.observeOn(Schedulers.computation()).subscribe(ts);

        ts.awaitDone(1000, TimeUnit.MILLISECONDS);
        if (ts.errors().size() > 0) {
            for (Throwable t : ts.errors()) {
                t.printStackTrace();
            }
            fail(""failed with exception"");
        }

        inOrder.verify(subscriber, times(1)).onNext(""one"");
        inOrder.verify(subscriber, times(1)).onNext(""null"");
        inOrder.verify(subscriber, times(1)).onNext(""two"");
        inOrder.verify(subscriber, times(1)).onNext(""three"");
        inOrder.verify(subscriber, times(1)).onNext(""four"");
        inOrder.verify(subscriber, times(1)).onComplete();
        inOrder.verifyNoMoreInteractions();
    }",iterator
i,"{
        final CountDownLatch latch = new CountDownLatch(1);
        Flowable<Integer> flowable = Flowable.unsafeCreate(new Publisher<Integer>() {

            @Override
            public void subscribe(Subscriber<? super Integer> subscriber) {
                subscriber.onSubscribe(new BooleanSubscription());
                for (int i = 0; i < Flowable.bufferSize() + 10; i++) {
                    subscriber.onNext(i);
                }
                latch.countDown();
                subscriber.onComplete();
            }

        });

        TestSubscriberEx<Integer> testSubscriber = new TestSubscriberEx<>(new DefaultSubscriber<Integer>() {

            @Override
            public void onComplete() {

            }

            @Override
            public void onError(Throwable e) {

            }

            @Override
            public void onNext(Integer t) {
                // force it to be slow and wait until we have queued everything
                try {
                    latch.await(500, TimeUnit.MILLISECONDS);
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }

        });
        flowable.observeOn(Schedulers.newThread()).subscribe(testSubscriber);

        testSubscriber.awaitDone(5, TimeUnit.SECONDS);
        List<Throwable> errors = testSubscriber.errors();
        assertEquals(1, errors.size());
        System.out.println(""Errors: "" + errors);
        Throwable t = errors.get(0);
        if (t instanceof MissingBackpressureException) {
            // success, we expect this
        } else {
            if (t.getCause() instanceof MissingBackpressureException) {
                // this is also okay
            } else {
                fail(""Expecting MissingBackpressureException"");
            }
        }
    }",loop_control
i,"{
        for (int i = 0; i < 50; i++) {
            final PublishProcessor<Long> processor = PublishProcessor.create();

            final AtomicLong counter = new AtomicLong();
            TestSubscriberEx<Long> ts = new TestSubscriberEx<>(new DefaultSubscriber<Long>() {

                @Override
                public void onComplete() {

                }

                @Override
                public void onError(Throwable e) {

                }

                @Override
                public void onNext(Long t) {
                    // simulate slow consumer to force backpressure failure
                    try {
                        Thread.sleep(1);
                    } catch (InterruptedException e) {
                    }
                }

            });
            processor.observeOn(Schedulers.computation()).subscribe(ts);

            // this will blow up with backpressure
            while (counter.get() < 102400) {
                processor.onNext(counter.get());
                counter.incrementAndGet();
            }

            ts.awaitDone(5, TimeUnit.SECONDS);
            assertEquals(1, ts.errors().size());
            ts.assertError(MissingBackpressureException.class);
            // assert that the values are sequential, that cutting in didn't allow skipping some but emitting others.
            // example [0, 1, 2] not [0, 1, 4]
            List<Long> onNextEvents = ts.values();
            assertTrue(onNextEvents.isEmpty() || onNextEvents.size() == onNextEvents.get(onNextEvents.size() - 1) + 1);
            // we should emit the error without emitting the full buffer size
            assertTrue(onNextEvents.size() < Flowable.bufferSize());
        }
    }",loop_control
counter,"{
        for (int i = 0; i < 50; i++) {
            final PublishProcessor<Long> processor = PublishProcessor.create();

            final AtomicLong counter = new AtomicLong();
            TestSubscriberEx<Long> ts = new TestSubscriberEx<>(new DefaultSubscriber<Long>() {

                @Override
                public void onComplete() {

                }

                @Override
                public void onError(Throwable e) {

                }

                @Override
                public void onNext(Long t) {
                    // simulate slow consumer to force backpressure failure
                    try {
                        Thread.sleep(1);
                    } catch (InterruptedException e) {
                    }
                }

            });
            processor.observeOn(Schedulers.computation()).subscribe(ts);

            // this will blow up with backpressure
            while (counter.get() < 102400) {
                processor.onNext(counter.get());
                counter.incrementAndGet();
            }

            ts.awaitDone(5, TimeUnit.SECONDS);
            assertEquals(1, ts.errors().size());
            ts.assertError(MissingBackpressureException.class);
            // assert that the values are sequential, that cutting in didn't allow skipping some but emitting others.
            // example [0, 1, 2] not [0, 1, 4]
            List<Long> onNextEvents = ts.values();
            assertTrue(onNextEvents.isEmpty() || onNextEvents.size() == onNextEvents.get(onNextEvents.size() - 1) + 1);
            // we should emit the error without emitting the full buffer size
            assertTrue(onNextEvents.size() < Flowable.bufferSize());
        }
    }",maybe_loop_control
i,"{
        for (int i = 1; i <= 1024; i = i * 2) {
            TestSubscriber<Integer> ts = TestSubscriber.create();

            Flowable.range(1, 1000 * 1000).observeOn(Schedulers.computation(), false, i)
            .subscribe(ts);

            ts.awaitDone(5, TimeUnit.SECONDS);
            ts.assertValueCount(1000 * 1000);
            ts.assertComplete();
            ts.assertNoErrors();
        }
    }",loop_control
i,"{
        for (int i = 0; i < TestHelper.RACE_DEFAULT_LOOPS; i++) {
            final TestSubscriberEx<Integer> ts = new TestSubscriberEx<Integer>().setInitialFusionMode(QueueFuseable.ANY);

            final TestScheduler scheduler = new TestScheduler();

            Flowable.just(1).hide()
            .observeOn(scheduler)
            .filter(Functions.alwaysTrue())
            .subscribe(ts);

            Runnable r1 = new Runnable() {
                @Override
                public void run() {
                    ts.cancel();
                }
            };

            Runnable r2 = new Runnable() {
                @Override
                public void run() {
                    scheduler.triggerActions();
                }
            };

            TestHelper.race(r1, r2);

            ts.assertFusionMode(QueueFuseable.ASYNC);

            if (ts.values().size() != 0) {
                ts.assertResult(1);
            }
        }
    }",loop_control
j,"{
        for (int j = 0; j < TestHelper.RACE_LONG_LOOPS; j++) {
            List<Throwable> errors = TestHelper.trackPluginErrors();
            try {
                final UnicastProcessor<Integer> up = UnicastProcessor.create();

                TestObserver<Integer> to = up.hide()
                .observeOn(Schedulers.io())
                .observeOn(Schedulers.single())
                .unsubscribeOn(Schedulers.computation())
                .firstOrError()
                .test();

                for (int i = 0; up.hasSubscribers() && i < 10000; i++) {
                    up.onNext(i);
                }

                to
                .awaitDone(5, TimeUnit.SECONDS)
                ;

                if (!errors.isEmpty()) {
                    throw new CompositeException(errors);
                }

                to.assertResult(0);
            } finally {
                RxJavaPlugins.reset();
            }
        }
    }",loop_control
i,"{
        for (int j = 0; j < TestHelper.RACE_LONG_LOOPS; j++) {
            List<Throwable> errors = TestHelper.trackPluginErrors();
            try {
                final UnicastProcessor<Integer> up = UnicastProcessor.create();

                TestObserver<Integer> to = up.hide()
                .observeOn(Schedulers.io())
                .observeOn(Schedulers.single())
                .unsubscribeOn(Schedulers.computation())
                .firstOrError()
                .test();

                for (int i = 0; up.hasSubscribers() && i < 10000; i++) {
                    up.onNext(i);
                }

                to
                .awaitDone(5, TimeUnit.SECONDS)
                ;

                if (!errors.isEmpty()) {
                    throw new CompositeException(errors);
                }

                to.assertResult(0);
            } finally {
                RxJavaPlugins.reset();
            }
        }
    }",loop_control
i,"{
        FlowableCache<Integer> source = new FlowableCache<>(Flowable.range(0, 1000), 16);

        assertFalse(""Source is connected!"", source.isConnected());

        TestSubscriberEx<Integer> ts = new TestSubscriberEx<>();

        source.subscribe(ts);

        assertTrue(""Source is not connected!"", source.isConnected());
        assertFalse(""Subscribers retained!"", source.hasSubscribers());

        ts.assertNoErrors();
        ts.assertTerminated();
        List<Integer> onNextEvents = ts.values();
        assertEquals(1000, onNextEvents.size());

        for (int i = 0; i < 1000; i++) {
            assertEquals((Integer)i, onNextEvents.get(i));
        }
    }",loop_control
i,"{
        FlowableCache<Integer> source = new FlowableCache<>(Flowable.range(0, 1000), 16);

        assertFalse(""Source is connected!"", source.isConnected());

        TestSubscriber<Integer> ts = new TestSubscriber<>(0L);
        ts.request(10);

        source.subscribe(ts);

        assertTrue(""Source is not connected!"", source.isConnected());
        assertFalse(""Subscribers retained!"", source.hasSubscribers());

        ts.assertNoErrors();
        ts.assertNotComplete();
        List<Integer> onNextEvents = ts.values();
        assertEquals(10, onNextEvents.size());

        for (int i = 0; i < 10; i++) {
            assertEquals((Integer)i, onNextEvents.get(i));
        }

        ts.cancel();
        assertFalse(""Subscribers retained!"", source.hasSubscribers());
    }",loop_control
i,"{
        Flowable<Integer> source = Flowable.range(1, 10000);
        for (int i = 0; i < 100; i++) {
            TestSubscriber<Integer> ts1 = new TestSubscriber<>();

            FlowableCache<Integer> cached = new FlowableCache<>(source, 16);

            cached.observeOn(Schedulers.computation()).subscribe(ts1);

            ts1.awaitDone(2, TimeUnit.SECONDS);
            ts1.assertNoErrors();
            ts1.assertComplete();
            assertEquals(10000, ts1.values().size());

            TestSubscriber<Integer> ts2 = new TestSubscriber<>();
            cached.observeOn(Schedulers.computation()).subscribe(ts2);

            ts2.awaitDone(2, TimeUnit.SECONDS);
            ts2.assertNoErrors();
            ts2.assertComplete();
            assertEquals(10000, ts2.values().size());
        }
    }",loop_control
i,"{
        Flowable<Long> source = Flowable.interval(1, 1, TimeUnit.MILLISECONDS)
                .take(1000)
                .subscribeOn(Schedulers.io());
        FlowableCache<Long> cached = new FlowableCache<>(source, 16);

        Flowable<Long> output = cached.observeOn(Schedulers.computation());

        List<TestSubscriber<Long>> list = new ArrayList<>(100);
        for (int i = 0; i < 100; i++) {
            TestSubscriber<Long> ts = new TestSubscriber<>();
            list.add(ts);
            output.skip(i * 10).take(10).subscribe(ts);
        }

        List<Long> expected = new ArrayList<>();
        for (int i = 0; i < 10; i++) {
            expected.add((long)(i - 10));
        }
        int j = 0;
        for (TestSubscriber<Long> ts : list) {
            ts.awaitDone(3, TimeUnit.SECONDS);
            ts.assertNoErrors();
            ts.assertComplete();

            for (int i = j * 10; i < j * 10 + 10; i++) {
                expected.set(i - j * 10, (long)i);
            }

            ts.assertValueSequence(expected);

            j++;
        }
    }",loop_control
ts,"{
        Flowable<Long> source = Flowable.interval(1, 1, TimeUnit.MILLISECONDS)
                .take(1000)
                .subscribeOn(Schedulers.io());
        FlowableCache<Long> cached = new FlowableCache<>(source, 16);

        Flowable<Long> output = cached.observeOn(Schedulers.computation());

        List<TestSubscriber<Long>> list = new ArrayList<>(100);
        for (int i = 0; i < 100; i++) {
            TestSubscriber<Long> ts = new TestSubscriber<>();
            list.add(ts);
            output.skip(i * 10).take(10).subscribe(ts);
        }

        List<Long> expected = new ArrayList<>();
        for (int i = 0; i < 10; i++) {
            expected.add((long)(i - 10));
        }
        int j = 0;
        for (TestSubscriber<Long> ts : list) {
            ts.awaitDone(3, TimeUnit.SECONDS);
            ts.assertNoErrors();
            ts.assertComplete();

            for (int i = j * 10; i < j * 10 + 10; i++) {
                expected.set(i - j * 10, (long)i);
            }

            ts.assertValueSequence(expected);

            j++;
        }
    }",iterator
j,"{
        Flowable<Long> source = Flowable.interval(1, 1, TimeUnit.MILLISECONDS)
                .take(1000)
                .subscribeOn(Schedulers.io());
        FlowableCache<Long> cached = new FlowableCache<>(source, 16);

        Flowable<Long> output = cached.observeOn(Schedulers.computation());

        List<TestSubscriber<Long>> list = new ArrayList<>(100);
        for (int i = 0; i < 100; i++) {
            TestSubscriber<Long> ts = new TestSubscriber<>();
            list.add(ts);
            output.skip(i * 10).take(10).subscribe(ts);
        }

        List<Long> expected = new ArrayList<>();
        for (int i = 0; i < 10; i++) {
            expected.add((long)(i - 10));
        }
        int j = 0;
        for (TestSubscriber<Long> ts : list) {
            ts.awaitDone(3, TimeUnit.SECONDS);
            ts.assertNoErrors();
            ts.assertComplete();

            for (int i = j * 10; i < j * 10 + 10; i++) {
                expected.set(i - j * 10, (long)i);
            }

            ts.assertValueSequence(expected);

            j++;
        }
    }",maybe_loop_control
i,"{
        final int m = 4 * 1000 * 1000;
        Flowable<Integer> firehose = Flowable.unsafeCreate(new Publisher<Integer>() {
            @Override
            public void subscribe(Subscriber<? super Integer> t) {
                t.onSubscribe(new BooleanSubscription());
                for (int i = 0; i < m; i++) {
                    t.onNext(i);
                }
                t.onComplete();
            }
        });

        TestSubscriber<Integer> ts = new TestSubscriber<>();
        firehose.cache().observeOn(Schedulers.computation()).takeLast(100).subscribe(ts);

        ts.awaitDone(3, TimeUnit.SECONDS);
        ts.assertNoErrors();
        ts.assertComplete();

        assertEquals(100, ts.values().size());
    }",loop_control
i,"{
        for (int i = 0; i < TestHelper.RACE_DEFAULT_LOOPS; i++) {
            final PublishProcessor<Integer> pp = PublishProcessor.<Integer>create();

            final Flowable<Integer> cache = pp.cache();

            cache.test();

            final TestSubscriberEx<Integer> ts = new TestSubscriberEx<>();

            Runnable r1 = new Runnable() {
                @Override
                public void run() {
                    cache.subscribe(ts);
                }
            };

            Runnable r2 = new Runnable() {
                @Override
                public void run() {
                    for (int j = 0; j < 500; j++) {
                        pp.onNext(j);
                    }
                    pp.onComplete();
                }
            };

            TestHelper.race(r1, r2);

            ts
            .awaitDone(5, TimeUnit.SECONDS)
            .assertSubscribed().assertValueCount(500).assertComplete().assertNoErrors();
        }
    }",loop_control
j,"{
        for (int i = 0; i < TestHelper.RACE_DEFAULT_LOOPS; i++) {
            final PublishProcessor<Integer> pp = PublishProcessor.<Integer>create();

            final Flowable<Integer> cache = pp.cache();

            cache.test();

            final TestSubscriberEx<Integer> ts = new TestSubscriberEx<>();

            Runnable r1 = new Runnable() {
                @Override
                public void run() {
                    cache.subscribe(ts);
                }
            };

            Runnable r2 = new Runnable() {
                @Override
                public void run() {
                    for (int j = 0; j < 500; j++) {
                        pp.onNext(j);
                    }
                    pp.onComplete();
                }
            };

            TestHelper.race(r1, r2);

            ts
            .awaitDone(5, TimeUnit.SECONDS)
            .assertSubscribed().assertValueCount(500).assertComplete().assertNoErrors();
        }
    }",loop_control
i,"{
        for (int i = 0; i < TestHelper.RACE_DEFAULT_LOOPS; i++) {
            final Flowable<Integer> cache = Flowable.range(1, 500).cache();

            final TestSubscriberEx<Integer> ts1 = new TestSubscriberEx<>();
            final TestSubscriberEx<Integer> ts2 = new TestSubscriberEx<>();

            Runnable r1 = new Runnable() {
                @Override
                public void run() {
                    cache.subscribe(ts1);
                }
            };

            Runnable r2 = new Runnable() {
                @Override
                public void run() {
                    cache.subscribe(ts2);
                }
            };

            TestHelper.race(r1, r2);

            ts1
            .awaitDone(5, TimeUnit.SECONDS)
            .assertSubscribed()
            .assertValueCount(500)
            .assertComplete()
            .assertNoErrors();

            ts2
            .awaitDone(5, TimeUnit.SECONDS)
            .assertSubscribed()
            .assertValueCount(500)
            .assertComplete()
            .assertNoErrors();
        }
    }",loop_control
i,"{
        for (int i = 0; i < TestHelper.RACE_DEFAULT_LOOPS; i++) {
            final PublishProcessor<Integer> pp = PublishProcessor.<Integer>create();

            final Flowable<Integer> cache = pp.cache();

            cache.test();

            final TestSubscriber<Integer> ts = new TestSubscriber<>();

            Runnable r1 = new Runnable() {
                @Override
                public void run() {
                    cache.subscribe(ts);
                }
            };

            Runnable r2 = new Runnable() {
                @Override
                public void run() {
                    pp.onComplete();
                }
            };

            TestHelper.race(r1, r2);

            ts
            .awaitDone(5, TimeUnit.SECONDS)
            .assertResult();
        }
    }",loop_control
i,"{
        for (int i = 0; i < TestHelper.RACE_DEFAULT_LOOPS; i++) {
            Flowable<Object> f = Flowable.never().cache();

            TestSubscriber<Object> ts = f.test();

            TestHelper.race(
                    () -> ts.cancel(),
                    () -> f.test()
            );
        }
    }",loop_control
it,"{
        FlowableProcessor<String> obs = PublishProcessor.create();
        Iterator<String> it = obs.blockingNext().iterator();
        fireOnNextInNewThread(obs, ""one"");
        assertTrue(it.hasNext());
        assertEquals(""one"", it.next());

        fireOnNextInNewThread(obs, ""two"");
        assertTrue(it.hasNext());
        assertEquals(""two"", it.next());

        fireOnNextInNewThread(obs, ""three"");
        try {
            assertEquals(""three"", it.next());
        } catch (NoSuchElementException e) {
            fail(""Calling next() without hasNext() should wait for next fire"");
        }

        obs.onComplete();
        assertFalse(it.hasNext());
        try {
            it.next();
            fail(""At the end of an iterator should throw a NoSuchElementException"");
        } catch (NoSuchElementException e) {
        }

        // If the observable is completed, hasNext always returns false and next always throw a NoSuchElementException.
        assertFalse(it.hasNext());
        try {
            it.next();
            fail(""At the end of an iterator should throw a NoSuchElementException"");
        } catch (NoSuchElementException e) {
        }
    }",iterator
it,"{
        FlowableProcessor<String> obs = PublishProcessor.create();
        Iterator<String> it = obs.blockingNext().iterator();
        fireOnNextInNewThread(obs, ""one"");
        assertTrue(it.hasNext());
        assertEquals(""one"", it.next());

        fireOnErrorInNewThread(obs);
        try {
            it.hasNext();
            fail(""Expected an TestException"");
        } catch (TestException e) {
        }

        assertErrorAfterObservableFail(it);
    }",iterator
it,"{
        Flowable<String> obs = Flowable.<String> empty().observeOn(Schedulers.newThread());
        Iterator<String> it = obs.blockingNext().iterator();

        assertFalse(it.hasNext());
        try {
            it.next();
            fail(""At the end of an iterator should throw a NoSuchElementException"");
        } catch (NoSuchElementException e) {
        }

        // If the observable is completed, hasNext always returns false and next always throw a NoSuchElementException.
        assertFalse(it.hasNext());
        try {
            it.next();
            fail(""At the end of an iterator should throw a NoSuchElementException"");
        } catch (NoSuchElementException e) {
        }
    }",iterator
it,"{
        FlowableProcessor<String> obs = PublishProcessor.create();
        Iterator<String> it = obs.blockingNext().iterator();

        obs.onError(new TestException());
        try {
            it.hasNext();
            fail(""Expected an TestException"");
        } catch (TestException e) {
            // successful
        }

        assertErrorAfterObservableFail(it);
    }",iterator
it,"{
        FlowableProcessor<String> obs = PublishProcessor.create();
        Iterator<String> it = obs.blockingNext().iterator();

        fireOnErrorInNewThread(obs);

        try {
            it.hasNext();
            fail(""Expected an TestException"");
        } catch (TestException e) {
            // successful
        }

        assertErrorAfterObservableFail(it);
    }",iterator
it,"{
        FlowableProcessor<String> obs = PublishProcessor.create();
        Iterator<String> it = obs.blockingNext().iterator();
        fireOnNextInNewThread(obs, ""one"");
        assertEquals(""one"", it.next());

        fireOnNextInNewThread(obs, ""two"");
        assertEquals(""two"", it.next());

        obs.onComplete();
        try {
            it.next();
            fail(""At the end of an iterator should throw a NoSuchElementException"");
        } catch (NoSuchElementException e) {
        }
    }",iterator
it,"{
        FlowableProcessor<String> obs = PublishProcessor.create();
        Iterator<String> it = obs.blockingNext().iterator();
        fireOnNextInNewThread(obs, ""one"");
        assertTrue(it.hasNext());
        assertTrue(it.hasNext());
        assertTrue(it.hasNext());
        assertTrue(it.hasNext());
        assertEquals(""one"", it.next());

        obs.onComplete();
        try {
            it.next();
            fail(""At the end of an iterator should throw a NoSuchElementException"");
        } catch (NoSuchElementException e) {
        }
    }",iterator
running,"{
        int repeat = 0;
        for (;;) {
            final SerialDisposable task = new SerialDisposable();
            try {
                final CountDownLatch finished = new CountDownLatch(1);
                final int COUNT = 30;
                final CountDownLatch timeHasPassed = new CountDownLatch(COUNT);
                final AtomicBoolean running = new AtomicBoolean(true);
                final AtomicInteger count = new AtomicInteger(0);
                final Flowable<Integer> obs = Flowable.unsafeCreate(new Publisher<Integer>() {

                    @Override
                    public void subscribe(final Subscriber<? super Integer> subscriber) {
                        subscriber.onSubscribe(new BooleanSubscription());
                        task.replace(Schedulers.single().scheduleDirect(new Runnable() {

                            @Override
                            public void run() {
                                try {
                                    while (running.get() && !task.isDisposed()) {
                                        subscriber.onNext(count.incrementAndGet());
                                        timeHasPassed.countDown();
                                    }
                                    subscriber.onComplete();
                                } catch (Throwable e) {
                                    subscriber.onError(e);
                                } finally {
                                    finished.countDown();
                                }
                            }
                        }));
                    }

                });

                Iterator<Integer> it = obs.blockingNext().iterator();

                assertTrue(it.hasNext());
                int a = it.next();
                assertTrue(it.hasNext());
                int b = it.next();
                // we should have a different value
                assertTrue(""a and b should be different"", a != b);

                // wait for some time (if times out we are blocked somewhere so fail ... set very high for very slow, constrained machines)
                timeHasPassed.await(8000, TimeUnit.MILLISECONDS);

                assertTrue(it.hasNext());
                int c = it.next();

                assertTrue(""c should not just be the next in sequence"", c != (b + 1));
                assertTrue(""expected that c ["" + c + ""] is higher than or equal to "" + COUNT, c >= COUNT);

                assertTrue(it.hasNext());
                int d = it.next();
                assertTrue(d > c);

                // shut down the thread
                running.set(false);

                finished.await();

                assertFalse(it.hasNext());

                System.out.println(""a: "" + a + "" b: "" + b + "" c: "" + c);
                break;
            } catch (AssertionError ex) {
                if (++repeat == 3) {
                    throw ex;
                }
                Thread.sleep((int)(1000 * Math.pow(2, repeat - 1)));
            } finally {
                task.dispose();
            }
        }
    }",maybe_loop_control
task,"{
        int repeat = 0;
        for (;;) {
            final SerialDisposable task = new SerialDisposable();
            try {
                final CountDownLatch finished = new CountDownLatch(1);
                final int COUNT = 30;
                final CountDownLatch timeHasPassed = new CountDownLatch(COUNT);
                final AtomicBoolean running = new AtomicBoolean(true);
                final AtomicInteger count = new AtomicInteger(0);
                final Flowable<Integer> obs = Flowable.unsafeCreate(new Publisher<Integer>() {

                    @Override
                    public void subscribe(final Subscriber<? super Integer> subscriber) {
                        subscriber.onSubscribe(new BooleanSubscription());
                        task.replace(Schedulers.single().scheduleDirect(new Runnable() {

                            @Override
                            public void run() {
                                try {
                                    while (running.get() && !task.isDisposed()) {
                                        subscriber.onNext(count.incrementAndGet());
                                        timeHasPassed.countDown();
                                    }
                                    subscriber.onComplete();
                                } catch (Throwable e) {
                                    subscriber.onError(e);
                                } finally {
                                    finished.countDown();
                                }
                            }
                        }));
                    }

                });

                Iterator<Integer> it = obs.blockingNext().iterator();

                assertTrue(it.hasNext());
                int a = it.next();
                assertTrue(it.hasNext());
                int b = it.next();
                // we should have a different value
                assertTrue(""a and b should be different"", a != b);

                // wait for some time (if times out we are blocked somewhere so fail ... set very high for very slow, constrained machines)
                timeHasPassed.await(8000, TimeUnit.MILLISECONDS);

                assertTrue(it.hasNext());
                int c = it.next();

                assertTrue(""c should not just be the next in sequence"", c != (b + 1));
                assertTrue(""expected that c ["" + c + ""] is higher than or equal to "" + COUNT, c >= COUNT);

                assertTrue(it.hasNext());
                int d = it.next();
                assertTrue(d > c);

                // shut down the thread
                running.set(false);

                finished.await();

                assertFalse(it.hasNext());

                System.out.println(""a: "" + a + "" b: "" + b + "" c: "" + c);
                break;
            } catch (AssertionError ex) {
                if (++repeat == 3) {
                    throw ex;
                }
                Thread.sleep((int)(1000 * Math.pow(2, repeat - 1)));
            } finally {
                task.dispose();
            }
        }
    }",maybe_loop_control
it,"{
        int repeat = 0;
        for (;;) {
            final SerialDisposable task = new SerialDisposable();
            try {
                final CountDownLatch finished = new CountDownLatch(1);
                final int COUNT = 30;
                final CountDownLatch timeHasPassed = new CountDownLatch(COUNT);
                final AtomicBoolean running = new AtomicBoolean(true);
                final AtomicInteger count = new AtomicInteger(0);
                final Flowable<Integer> obs = Flowable.unsafeCreate(new Publisher<Integer>() {

                    @Override
                    public void subscribe(final Subscriber<? super Integer> subscriber) {
                        subscriber.onSubscribe(new BooleanSubscription());
                        task.replace(Schedulers.single().scheduleDirect(new Runnable() {

                            @Override
                            public void run() {
                                try {
                                    while (running.get() && !task.isDisposed()) {
                                        subscriber.onNext(count.incrementAndGet());
                                        timeHasPassed.countDown();
                                    }
                                    subscriber.onComplete();
                                } catch (Throwable e) {
                                    subscriber.onError(e);
                                } finally {
                                    finished.countDown();
                                }
                            }
                        }));
                    }

                });

                Iterator<Integer> it = obs.blockingNext().iterator();

                assertTrue(it.hasNext());
                int a = it.next();
                assertTrue(it.hasNext());
                int b = it.next();
                // we should have a different value
                assertTrue(""a and b should be different"", a != b);

                // wait for some time (if times out we are blocked somewhere so fail ... set very high for very slow, constrained machines)
                timeHasPassed.await(8000, TimeUnit.MILLISECONDS);

                assertTrue(it.hasNext());
                int c = it.next();

                assertTrue(""c should not just be the next in sequence"", c != (b + 1));
                assertTrue(""expected that c ["" + c + ""] is higher than or equal to "" + COUNT, c >= COUNT);

                assertTrue(it.hasNext());
                int d = it.next();
                assertTrue(d > c);

                // shut down the thread
                running.set(false);

                finished.await();

                assertFalse(it.hasNext());

                System.out.println(""a: "" + a + "" b: "" + b + "" c: "" + c);
                break;
            } catch (AssertionError ex) {
                if (++repeat == 3) {
                    throw ex;
                }
                Thread.sleep((int)(1000 * Math.pow(2, repeat - 1)));
            } finally {
                task.dispose();
            }
        }
    }",iterator
j,"{
        Flowable<Long> f = Flowable.interval(250, TimeUnit.MILLISECONDS);
        PublishProcessor<Integer> terminal = PublishProcessor.create();
        Flowable<Long> source = f.takeUntil(terminal);

        Iterable<Long> iter = source.blockingNext();

        for (int j = 0; j < 3; j++) {
            BlockingFlowableNext.NextIterator<Long> it = (BlockingFlowableNext.NextIterator<Long>)iter.iterator();

            for (long i = 0; i < 10; i++) {
                Assert.assertTrue(it.hasNext());
                Assert.assertEquals(j + ""th iteration next"", Long.valueOf(i), it.next());
            }
            terminal.onNext(1);
        }
    }",loop_control
i,"{
        Flowable<Long> f = Flowable.interval(250, TimeUnit.MILLISECONDS);
        PublishProcessor<Integer> terminal = PublishProcessor.create();
        Flowable<Long> source = f.takeUntil(terminal);

        Iterable<Long> iter = source.blockingNext();

        for (int j = 0; j < 3; j++) {
            BlockingFlowableNext.NextIterator<Long> it = (BlockingFlowableNext.NextIterator<Long>)iter.iterator();

            for (long i = 0; i < 10; i++) {
                Assert.assertTrue(it.hasNext());
                Assert.assertEquals(j + ""th iteration next"", Long.valueOf(i), it.next());
            }
            terminal.onNext(1);
        }
    }",loop_control
it,"{
        Iterator<Object> it = Flowable.never().blockingNext().iterator();

        try {
            Thread.currentThread().interrupt();
            it.next();
        } catch (RuntimeException ex) {
            assertTrue(ex.toString(), ex.getCause() instanceof InterruptedException);
        }
    }",iterator
s,"{
        Subscriber<Object> subscriber = TestHelper.mockSubscriber();

        final List<Integer> list = Arrays.asList(1, 2, 3);

        Function<Integer, List<Integer>> func = new Function<Integer, List<Integer>>() {
            @Override
            public List<Integer> apply(Integer t1) {
                return list;
            }
        };
        BiFunction<Integer, Integer, Integer> resFunc = new BiFunction<Integer, Integer, Integer>() {

            @Override
            public Integer apply(Integer t1, Integer t2) {
                return t1 | t2;
            }
        };

        List<Integer> source = Arrays.asList(16, 32, 64);

        Flowable.fromIterable(source).flatMapIterable(func, resFunc).subscribe(subscriber);

        for (Integer s : source) {
            for (Integer v : list) {
                verify(subscriber).onNext(s | v);
            }
        }
        verify(subscriber).onComplete();
        verify(subscriber, never()).onError(any(Throwable.class));
    }",iterator
v,"{
        Subscriber<Object> subscriber = TestHelper.mockSubscriber();

        final List<Integer> list = Arrays.asList(1, 2, 3);

        Function<Integer, List<Integer>> func = new Function<Integer, List<Integer>>() {
            @Override
            public List<Integer> apply(Integer t1) {
                return list;
            }
        };
        BiFunction<Integer, Integer, Integer> resFunc = new BiFunction<Integer, Integer, Integer>() {

            @Override
            public Integer apply(Integer t1, Integer t2) {
                return t1 | t2;
            }
        };

        List<Integer> source = Arrays.asList(16, 32, 64);

        Flowable.fromIterable(source).flatMapIterable(func, resFunc).subscribe(subscriber);

        for (Integer s : source) {
            for (Integer v : list) {
                verify(subscriber).onNext(s | v);
            }
        }
        verify(subscriber).onComplete();
        verify(subscriber, never()).onError(any(Throwable.class));
    }",iterator
i,"{
        for (int i = 0; i < 1000; i++) {
            if (i % 100 == 0) {
                System.out.println(""testFlatMapTransformsMaxConcurrentNormalLoop => "" + i);
            }
            flatMapTransformsMaxConcurrentNormal();
        }
    }",loop_control
i,"{
        for (int i = 0; i < 2000; i++) {
            if (i % 10 == 0) {
                System.out.println(""flatMapRangeAsyncLoop > "" + i);
            }
            TestSubscriberEx<Integer> ts = new TestSubscriberEx<>();
            Flowable.range(0, 1000)
            .flatMap(new Function<Integer, Flowable<Integer>>() {
                final Random rnd = new Random();
                @Override
                public Flowable<Integer> apply(Integer t) {
                    Flowable<Integer> r = Flowable.just(t);
                    if (rnd.nextBoolean()) {
                        r = r.hide();
                    }
                    return r;
                }
            })
            .observeOn(Schedulers.computation())
            .subscribe(ts);

            ts.awaitDone(2500, TimeUnit.MILLISECONDS);
            if (ts.completions() == 0) {
                System.out.println(ts.values().size());
            }
            ts.assertTerminated();
            ts.assertNoErrors();
            List<Integer> list = ts.values();
            if (list.size() < 1000) {
                Set<Integer> set = new HashSet<>(list);
                for (int j = 0; j < 1000; j++) {
                    if (!set.contains(j)) {
                        System.out.println(j + "" missing"");
                    }
                }
            }
            assertEquals(1000, list.size());
        }
    }",loop_control
j,"{
        for (int i = 0; i < 2000; i++) {
            if (i % 10 == 0) {
                System.out.println(""flatMapRangeAsyncLoop > "" + i);
            }
            TestSubscriberEx<Integer> ts = new TestSubscriberEx<>();
            Flowable.range(0, 1000)
            .flatMap(new Function<Integer, Flowable<Integer>>() {
                final Random rnd = new Random();
                @Override
                public Flowable<Integer> apply(Integer t) {
                    Flowable<Integer> r = Flowable.just(t);
                    if (rnd.nextBoolean()) {
                        r = r.hide();
                    }
                    return r;
                }
            })
            .observeOn(Schedulers.computation())
            .subscribe(ts);

            ts.awaitDone(2500, TimeUnit.MILLISECONDS);
            if (ts.completions() == 0) {
                System.out.println(ts.values().size());
            }
            ts.assertTerminated();
            ts.assertNoErrors();
            List<Integer> list = ts.values();
            if (list.size() < 1000) {
                Set<Integer> set = new HashSet<>(list);
                for (int j = 0; j < 1000; j++) {
                    if (!set.contains(j)) {
                        System.out.println(j + "" missing"");
                    }
                }
            }
            assertEquals(1000, list.size());
        }
    }",loop_control
i,"{
        for (int i = 0; i < 1000; i++) {
            TestSubscriber<Integer> ts = new TestSubscriber<>();

            Flowable.range(1, 1000).flatMap(new Function<Integer, Flowable<Integer>>() {
                @Override
                public Flowable<Integer> apply(Integer t) {
                    return Flowable.just(1).subscribeOn(Schedulers.computation());
                }
            }).subscribe(ts);

            ts.awaitDone(5, TimeUnit.SECONDS);
            ts.assertNoErrors();
            ts.assertComplete();
            ts.assertValueCount(1000);
        }
    }",loop_control
n,"{
        for (final int n : new int[] { 1, 1000, 1000000 }) {
            TestSubscriber<Integer> ts = new TestSubscriber<>();

            Flowable.just(1, 2).flatMap(new Function<Integer, Flowable<Integer>>() {
                @Override
                public Flowable<Integer> apply(Integer t) {
                    return Flowable.range(1, n);
                }
            }).subscribe(ts);

            System.out.println(""flatMapTwoNestedSync >> @ "" + n);
            ts.assertNoErrors();
            ts.assertComplete();
            ts.assertValueCount(n * 2);
        }
    }",iterator
v,"{
        TestSubscriber<Integer> ts = TestSubscriber.create();

        Flowable.range(0, 4 * Flowable.bufferSize())
        .flatMap(new Function<Integer, Flowable<Integer>>() {
            @Override
            public Flowable<Integer> apply(Integer v) {
                return (v & 1) == 0 ? Flowable.<Integer>empty() : Flowable.just(v);
            }
        })
        .subscribe(ts);

        ts.assertValueCount(2 * Flowable.bufferSize());
        ts.assertNoErrors();
        ts.assertComplete();

        int j = 1;
        for (Integer v : ts.values()) {
            Assert.assertEquals(j, v.intValue());

            j += 2;
        }
    }",iterator
i,"{
        TestSubscriber<Integer> ts = TestSubscriber.create();

        Flowable.range(0, 4 * Flowable.bufferSize())
        .flatMap(new Function<Integer, Flowable<Integer>>() {
            @Override
            public Flowable<Integer> apply(Integer v) {
                return (v & 1) == 0 ? Flowable.<Integer>empty() : Flowable.range(v, 2);
            }
        })
        .subscribe(ts);

        ts.assertValueCount(4 * Flowable.bufferSize());
        ts.assertNoErrors();
        ts.assertComplete();

        int j = 1;
        List<Integer> list = ts.values();
        for (int i = 0; i < list.size(); i += 2) {
            Assert.assertEquals(j, list.get(i).intValue());
            Assert.assertEquals(j + 1, list.get(i + 1).intValue());

            j += 2;
        }
    }",loop_control
v,"{
        TestSubscriber<Integer> ts = TestSubscriber.create();

        Flowable.range(0, 4 * Flowable.bufferSize())
        .flatMap(new Function<Integer, Flowable<Integer>>() {
            @Override
            public Flowable<Integer> apply(Integer v) {
                return (v & 1) == 0 ? Flowable.<Integer>empty() : Flowable.just(v);
            }
        }, 16)
        .subscribe(ts);

        ts.assertValueCount(2 * Flowable.bufferSize());
        ts.assertNoErrors();
        ts.assertComplete();

        int j = 1;
        for (Integer v : ts.values()) {
            Assert.assertEquals(j, v.intValue());

            j += 2;
        }
    }",iterator
i,"{
        TestSubscriber<Integer> ts = TestSubscriber.create();

        Flowable.range(0, 4 * Flowable.bufferSize())
        .flatMap(new Function<Integer, Flowable<Integer>>() {
            @Override
            public Flowable<Integer> apply(Integer v) {
                return (v & 1) == 0 ? Flowable.<Integer>empty() : Flowable.range(v, 2);
            }
        }, 16)
        .subscribe(ts);

        ts.assertValueCount(4 * Flowable.bufferSize());
        ts.assertNoErrors();
        ts.assertComplete();

        int j = 1;
        List<Integer> list = ts.values();
        for (int i = 0; i < list.size(); i += 2) {
            Assert.assertEquals(j, list.get(i).intValue());
            Assert.assertEquals(j + 1, list.get(i + 1).intValue());

            j += 2;
        }
    }",loop_control
i,"{
        for (int i = 0; i < TestHelper.RACE_DEFAULT_LOOPS; i++) {
            final PublishProcessor<Integer> pp = PublishProcessor.create();

            final TestSubscriber<Integer> ts = Flowable.merge(Flowable.just(pp)).test();

            Runnable r1 = new Runnable() {
                @Override
                public void run() {
                    pp.onComplete();
                }
            };

            Runnable r2 = new Runnable() {
                @Override
                public void run() {
                    ts.cancel();
                }
            };

            TestHelper.race(r1, r2);
        }
    }",loop_control
i,"{
        for (int i = 0; i < 500; i++) {
            TestSubscriber<Object> ts = Flowable.merge(
                    Flowable.just(1).observeOn(Schedulers.single()).map(new Function<Integer, Object>() {
                        @Override
                        public Object apply(Integer v) throws Exception {
                            return Thread.currentThread().getName().substring(0, 4);
                        }
                    }),
                    Flowable.just(1).observeOn(Schedulers.computation()).map(new Function<Integer, Object>() {
                        @Override
                        public Object apply(Integer v) throws Exception {
                            return Thread.currentThread().getName().substring(0, 4);
                        }
                    })
            )
            .test()
            .awaitDone(5, TimeUnit.SECONDS)
            .assertValueCount(2);

            List<Object> list = ts.values();

            assertTrue(list.toString(), list.contains(""RxSi""));
            assertTrue(list.toString(), list.contains(""RxCo""));
        }
    }",loop_control
i,"{
        for (int i = 0; i < TestHelper.RACE_DEFAULT_LOOPS; i++) {
            List<Throwable> errors = TestHelper.trackPluginErrors();
            try {

                final PublishProcessor<Flowable<Integer>> pp = PublishProcessor.create();

                final TestSubscriber<Integer> ts = pp.flatMap(Functions.<Flowable<Integer>>identity()).test(0);

                Runnable r1 = new Runnable() {
                    @Override
                    public void run() {
                        ts.cancel();
                    }
                };
                Runnable r2 = new Runnable() {
                    @Override
                    public void run() {
                        pp.onComplete();
                    }
                };

                TestHelper.race(r1, r2);

                assertTrue(errors.toString(), errors.isEmpty());
            } finally {
                RxJavaPlugins.reset();
            }
        }
    }",loop_control
i,"{
        for (int i = 0; i < TestHelper.RACE_DEFAULT_LOOPS; i++) {
            for (int j = 1; j < 50; j += 5) {
                List<Throwable> errors = TestHelper.trackPluginErrors();
                try {

                    final PublishProcessor<Flowable<Integer>> pp = PublishProcessor.create();

                    final TestSubscriber<Integer> ts = pp.flatMap(Functions.<Flowable<Integer>>identity()).test(0);

                    final PublishProcessor<Integer> just = PublishProcessor.create();
                    pp.onNext(just);

                    Runnable r1 = new Runnable() {
                        @Override
                        public void run() {
                            ts.request(1);
                            ts.cancel();
                        }
                    };
                    Runnable r2 = new Runnable() {
                        @Override
                        public void run() {
                            just.onNext(1);
                        }
                    };

                    TestHelper.race(r1, r2);

                    assertTrue(errors.toString(), errors.isEmpty());
                } finally {
                    RxJavaPlugins.reset();
                }
            }
        }
    }",loop_control
j,"{
        for (int i = 0; i < TestHelper.RACE_DEFAULT_LOOPS; i++) {
            for (int j = 1; j < 50; j += 5) {
                List<Throwable> errors = TestHelper.trackPluginErrors();
                try {

                    final PublishProcessor<Flowable<Integer>> pp = PublishProcessor.create();

                    final TestSubscriber<Integer> ts = pp.flatMap(Functions.<Flowable<Integer>>identity()).test(0);

                    final PublishProcessor<Integer> just = PublishProcessor.create();
                    pp.onNext(just);

                    Runnable r1 = new Runnable() {
                        @Override
                        public void run() {
                            ts.request(1);
                            ts.cancel();
                        }
                    };
                    Runnable r2 = new Runnable() {
                        @Override
                        public void run() {
                            just.onNext(1);
                        }
                    };

                    TestHelper.race(r1, r2);

                    assertTrue(errors.toString(), errors.isEmpty());
                } finally {
                    RxJavaPlugins.reset();
                }
            }
        }
    }",loop_control
i,"{
        for (int i = 0; i < TestHelper.RACE_DEFAULT_LOOPS; i++) {
            Flowable
            .range(0, 20)
            .flatMap(
                    integer -> {
                        if (integer % 5 != 0) {
                            return Flowable
                                    .just(integer);
                        }

                        return Flowable
                                .just(-integer)
                                .observeOn(Schedulers.computation());
                    },
                    false,
                    1
            )
            .ignoreElements()
            .blockingAwait();
        }
    }",loop_control
timeout,"{
        List<Throwable> errors = TestHelper.trackPluginErrors();
        try {
            final CountDownLatch cdl1 = new CountDownLatch(1);
            final CountDownLatch cdl2 = new CountDownLatch(1);

            TestSubscriber<Object> ts = Flowable.fromAction(new Action() {
                @Override
                public void run() throws Exception {
                    cdl1.countDown();
                    cdl2.await(5, TimeUnit.SECONDS);
                }
            }).subscribeOn(Schedulers.single()).test();

            assertTrue(cdl1.await(5, TimeUnit.SECONDS));

            ts.cancel();

            int timeout = 10;

            while (timeout-- > 0 && errors.isEmpty()) {
                Thread.sleep(100);
            }

            TestHelper.assertUndeliverable(errors, 0, InterruptedException.class);
        } finally {
            RxJavaPlugins.reset();
        }
    }",loop_control
errors,"{
        List<Throwable> errors = TestHelper.trackPluginErrors();
        try {
            final CountDownLatch cdl1 = new CountDownLatch(1);
            final CountDownLatch cdl2 = new CountDownLatch(1);

            TestSubscriber<Object> ts = Flowable.fromAction(new Action() {
                @Override
                public void run() throws Exception {
                    cdl1.countDown();
                    cdl2.await(5, TimeUnit.SECONDS);
                }
            }).subscribeOn(Schedulers.single()).test();

            assertTrue(cdl1.await(5, TimeUnit.SECONDS));

            ts.cancel();

            int timeout = 10;

            while (timeout-- > 0 && errors.isEmpty()) {
                Thread.sleep(100);
            }

            TestHelper.assertUndeliverable(errors, 0, InterruptedException.class);
        } finally {
            RxJavaPlugins.reset();
        }
    }",maybe_loop_control
arg,"{
        List<String> list = new ArrayList<>();
        for (String arg : args) {
            list.add(arg);
        }
        return list;
    }",iterator
i,"{
        return Flowable.unsafeCreate(new Publisher<Integer>() {
            @Override
            public void subscribe(Subscriber<? super Integer> s) {
                BooleanSubscription bs = new BooleanSubscription();
                s.onSubscribe(bs);
                while (!bs.isCancelled()) {
                    // burst some number of items
                    for (int i = 0; i < Math.random() * 20; i++) {
                        s.onNext(i);
                    }
                    try {
                        // sleep for a random amount of time
                        // NOTE: Only using Thread.sleep here as an artificial demo.
                        Thread.sleep((long) (Math.random() * 200));
                    } catch (Exception e) {
                        // do nothing
                    }
                }
                System.out.println(""Hot done."");
            }
        }).subscribeOn(Schedulers.newThread()); // use newThread since we are using sleep to block
    }",loop_control
i,"{
        Flowable<Integer> just = Flowable.just(1);
        int n = 1000;
        for (int i = 0; i < TestHelper.RACE_DEFAULT_LOOPS; i++) {
            PublishProcessor<Flowable<Integer>> source = PublishProcessor.create();

            TestSubscriber<Integer> ts = source
                    .concatMap(v -> v, n + 1, ImmediateThinScheduler.INSTANCE)
                    .test(1L);

            TestHelper.race(() -> {
                for (int j = 0; j < n; j++) {
                    source.onNext(just);
                }
            }, () -> {
                for (int j = 0; j < n; j++) {
                    ts.request(1);
                }
            });

            ts.assertValueCount(n);
        }
    }",loop_control
j,"{
        Flowable<Integer> just = Flowable.just(1);
        int n = 1000;
        for (int i = 0; i < TestHelper.RACE_DEFAULT_LOOPS; i++) {
            PublishProcessor<Flowable<Integer>> source = PublishProcessor.create();

            TestSubscriber<Integer> ts = source
                    .concatMap(v -> v, n + 1, ImmediateThinScheduler.INSTANCE)
                    .test(1L);

            TestHelper.race(() -> {
                for (int j = 0; j < n; j++) {
                    source.onNext(just);
                }
            }, () -> {
                for (int j = 0; j < n; j++) {
                    ts.request(1);
                }
            });

            ts.assertValueCount(n);
        }
    }",loop_control
i,"{
        Flowable<Integer> just = Flowable.just(1);
        int n = 1000;
        for (int i = 0; i < TestHelper.RACE_DEFAULT_LOOPS; i++) {
            PublishProcessor<Flowable<Integer>> source = PublishProcessor.create();

            TestSubscriber<Integer> ts = source
                    .concatMapDelayError(v -> v, true, n + 1, ImmediateThinScheduler.INSTANCE)
                    .test(1L);

            TestHelper.race(() -> {
                for (int j = 0; j < n; j++) {
                    source.onNext(just);
                }
            }, () -> {
                for (int j = 0; j < n; j++) {
                    ts.request(1);
                }
            });

            ts.assertValueCount(n);
        }
    }",loop_control
j,"{
        Flowable<Integer> just = Flowable.just(1);
        int n = 1000;
        for (int i = 0; i < TestHelper.RACE_DEFAULT_LOOPS; i++) {
            PublishProcessor<Flowable<Integer>> source = PublishProcessor.create();

            TestSubscriber<Integer> ts = source
                    .concatMapDelayError(v -> v, true, n + 1, ImmediateThinScheduler.INSTANCE)
                    .test(1L);

            TestHelper.race(() -> {
                for (int j = 0; j < n; j++) {
                    source.onNext(just);
                }
            }, () -> {
                for (int j = 0; j < n; j++) {
                    ts.request(1);
                }
            });

            ts.assertValueCount(n);
        }
    }",loop_control
i,"{
        final long durationSeconds = 2;
        final long startTime = System.currentTimeMillis();
        for (int i = 0;; i++) {
            //only run this for a max of ten seconds
            if (System.currentTimeMillis() - startTime > TimeUnit.SECONDS.toMillis(durationSeconds)) {
                return;
            }
            if (i % 1000 == 0) {
                System.out.println(""concatMapRangeAsyncLoop > "" + i);
            }
            TestSubscriberEx<Integer> ts = new TestSubscriberEx<>();
            Flowable.range(0, 1000)
            .concatMap(new Function<Integer, Flowable<Integer>>() {
                @Override
                public Flowable<Integer> apply(Integer t) {
                    return Flowable.fromIterable(Arrays.asList(t));
                }
            }, 2, ImmediateThinScheduler.INSTANCE)
            .observeOn(Schedulers.computation()).subscribe(ts);

            ts.awaitDone(2500, TimeUnit.MILLISECONDS);
            ts.assertTerminated();
            ts.assertNoErrors();
            assertEquals(1000, ts.values().size());
            assertEquals((Integer)999, ts.values().get(999));
        }
    }",loop_control
i,"{
        for (int i = 2; i < 10; i++) {
            Flowable<Integer>[] obs = new Flowable[i];
            Arrays.fill(obs, Flowable.just(1));

            Integer[] expected = new Integer[i];
            Arrays.fill(expected, 1);

            Method m = Flowable.class.getMethod(""concatArray"",  Publisher[].class);

            TestSubscriber<Integer> ts = TestSubscriber.create();

            ((Flowable<Integer>)m.invoke(null, new Object[]{obs})).subscribe(ts);

            ts.assertValues(expected);
            ts.assertNoErrors();
            ts.assertComplete();
        }
    }",loop_control
i,"{
        for (int i = 2; i < 10; i++) {
            Object[] obs = new Object[i];
            Arrays.fill(obs, 1);

            Integer[] expected = new Integer[i];
            Arrays.fill(expected, 1);

            Method m = Flowable.class.getMethod(""startWithArray"", Object[].class);

            TestSubscriber<Integer> ts = TestSubscriber.create();

            ((Flowable<Integer>)m.invoke(Flowable.empty(), new Object[]{obs})).subscribe(ts);

            ts.assertValues(expected);
            ts.assertNoErrors();
            ts.assertComplete();
        }
    }",loop_control
i,"{
        new Flowable<Integer>() {
            @Override
            protected void subscribeActual(Subscriber<? super Integer> s) {
                s.onSubscribe(new BooleanSubscription());
                for (int i = 0; i < 10; i++) {
                    s.onNext(i);
                }
            }
        }
        .concatMap(Functions.justFunction(Flowable.just(2)), 8, ImmediateThinScheduler.INSTANCE)
        .test(0L)
        .assertFailure(IllegalStateException.class);
    }",loop_control
i,"{
        TestHelper.withErrorTracking(errors -> {
            TestException ex1 = new TestException();
            TestException ex2 = new TestException();

            for (int i = 0; i < TestHelper.RACE_DEFAULT_LOOPS; i++) {
                AtomicReference<Subscriber<? super Integer>> ref1 = new AtomicReference<>();
                AtomicReference<Subscriber<? super Integer>> ref2 = new AtomicReference<>();

                TestSubscriber<Integer> ts = Flowable.<Integer>fromPublisher(ref1::set)
                .concatMap(v -> Flowable.<Integer>fromPublisher(ref2::set), 2, ImmediateThinScheduler.INSTANCE)
                .test();

                ref1.get().onSubscribe(new BooleanSubscription());
                ref1.get().onNext(1);
                ref2.get().onSubscribe(new BooleanSubscription());

                TestHelper.race(() -> ref1.get().onError(ex1), () -> ref2.get().onError(ex2));

                ts.assertError(RuntimeException.class);
                errors.clear();
            }
        });
    }",loop_control
i,"{
        ArrayList<Long> list = new ArrayList<>(Flowable.bufferSize() * 2);
        for (long i = 1; i <= Flowable.bufferSize() * 2 + 1; i++) {
            list.add(i);
        }

        Flowable<Long> f = Flowable.rangeLong(1, list.size());

        TestSubscriberEx<Long> ts = new TestSubscriberEx<>(0L);

        ts.assertNoValues();
        ts.request(Long.MAX_VALUE); // infinite

        f.subscribe(ts);

        ts.assertValueSequence(list);
        ts.assertTerminated();
    }",loop_control
i,"{
        Flowable<Long> source = Flowable.rangeLong(start, 100);

        TestSubscriberEx<Long> ts = new TestSubscriberEx<>(0L);
        ts.request(1);
        source.subscribe(ts);

        List<Long> list = new ArrayList<>(100);
        for (long i = 0; i < 100; i++) {
            list.add(i + start);
            ts.request(1);
        }
        ts.assertValueSequence(list);
        ts.assertTerminated();
    }",loop_control
i,"{
        Flowable<Long> source = Flowable.rangeLong(start, 100);

        TestSubscriberEx<Long> ts = new TestSubscriberEx<>(0L);
        ts.request(100);
        source.subscribe(ts);

        List<Long> list = new ArrayList<>(100);
        for (long i = 0; i < 100; i++) {
            list.add(i + start);
        }
        ts.assertValueSequence(list);
        ts.assertTerminated();
    }",loop_control
i,"{
        for (long i = 0; i < 100; i++) {
            withBackpressureOneByOne(i);
        }
    }",loop_control
i,"{
        for (long i = 0; i < 100; i++) {
            withBackpressureAllAtOnce(i);
        }
    }",loop_control
i,"{
        Flowable<Long> source = Flowable.rangeLong(50, 100);

        TestSubscriberEx<Long> ts = new TestSubscriberEx<>(0L);
        ts.request(150);
        source.subscribe(ts);

        List<Long> list = new ArrayList<>(100);
        for (long i = 0; i < 100; i++) {
            list.add(i + 50);
        }

        ts.request(50); // and then some

        ts.assertValueSequence(list);
        ts.assertTerminated();
    }",loop_control
i,"{
        int max = 9;
        for (int i = 0; i <= max; i++) {
            try {
                multiThreadedWithNPE();
                return;
            } catch (AssertionError ex) {
                if (i == max) {
                    throw ex;
                }
            }
            Thread.sleep((long)(1000 * Math.random() + 100));
        }
    }",loop_control
i,"{
        int max = 9;
        for (int i = 0; i <= max; i++) {
            try {
                multiThreadedWithNPEinMiddle();
                return;
            } catch (AssertionError ex) {
                if (i == max) {
                    throw ex;
                }
            }
            Thread.sleep((long)(1000 * Math.random() + 100));
        }
    }",loop_control
i,"{
        boolean lessThan9 = false;
        for (int i = 0; i < 3; i++) {
            TestMultiThreadedObservable onSubscribe = new TestMultiThreadedObservable(""one"", ""two"", ""three"", null, ""four"", ""five"", ""six"", ""seven"", ""eight"", ""nine"");
            Flowable<String> w = Flowable.unsafeCreate(onSubscribe);

            BusyObserver busyobserver = new BusyObserver();

            w.serialize().subscribe(busyobserver);
            onSubscribe.waitToFinish();

            System.out.println(""maxConcurrentThreads: "" + onSubscribe.maxConcurrentThreads.get());
            // this should not always be the full number of items since the error should (very often)
            // stop it before it completes all 9
            System.out.println(""onNext count: "" + busyobserver.onNextCount.get());
            if (busyobserver.onNextCount.get() < 9) {
                lessThan9 = true;
            }
            assertTrue(busyobserver.onError);
            // no onComplete because onError was invoked
            assertFalse(busyobserver.onComplete);
            // non-deterministic because unsubscribe happens after 'waitToFinish' releases
            // so commenting out for now as this is not a critical thing to test here
            // verify(s, times(1)).unsubscribe();

            // we can have concurrency ...
            assertTrue(onSubscribe.maxConcurrentThreads.get() > 1);
            // ... but the onNext execution should be single threaded
            assertEquals(1, busyobserver.maxConcurrentThreads.get());
        }
        assertTrue(lessThan9);
    }",loop_control
f,"{

        private final DefaultSubscriber<String> subscriber;
        private final TestConcurrencyobserverEvent event;
        private final Future<?>[] waitOnThese;

        CompletionThread(DefaultSubscriber<String> subscriber, TestConcurrencyobserverEvent event, Future<?>... waitOnThese) {
            this.subscriber = subscriber;
            this.event = event;
            this.waitOnThese = waitOnThese;
        }

        @Override
        public void run() {
            /* if we have 'waitOnThese' futures, we'll wait on them before proceeding */
            if (waitOnThese != null) {
                for (Future<?> f : waitOnThese) {
                    try {
                        f.get();
                    } catch (Throwable e) {
                        System.err.println(""Error while waiting on future in CompletionThread"");
                    }
                }
            }

            /* send the event */
            if (event == TestConcurrencyobserverEvent.onError) {
                subscriber.onError(new RuntimeException(""mocked exception""));
            } else if (event == TestConcurrencyobserverEvent.onComplete) {
                subscriber.onComplete();

            } else {
                throw new IllegalArgumentException(""Expecting either onError or onComplete"");
            }
        }
    }",iterator
i,"{
        for (int i = 0; i < TestHelper.RACE_DEFAULT_LOOPS; i++) {
            List<Throwable> errors = TestHelper.trackPluginErrors();
            try {
                final PublishProcessor<Integer> pp = PublishProcessor.create();

                final Subscriber<?>[] sub = { null, null };

                final Flowable<Integer> pp2 = new Flowable<Integer>() {

                    int count;

                    @Override
                    protected void subscribeActual(
                            Subscriber<? super Integer> s) {
                        s.onSubscribe(new BooleanSubscription());
                        sub[count++] = s;
                    }
                };

                TestSubscriber<Integer> ts = pp.timeout(Functions.justFunction(pp2)).test();

                pp.onNext(0);

                Runnable r1 = new Runnable() {
                    @Override
                    public void run() {
                        pp.onNext(1);
                    }
                };

                final Throwable ex = new TestException();

                Runnable r2 = new Runnable() {
                    @Override
                    public void run() {
                        sub[0].onError(ex);
                    }
                };

                TestHelper.race(r1, r2);

                ts.assertValueAt(0, 0);

                if (!errors.isEmpty()) {
                    TestHelper.assertUndeliverable(errors, 0, TestException.class);
                }
            } finally {
                RxJavaPlugins.reset();
            }
        }
    }",loop_control
i,"{
        for (int i = 0; i < TestHelper.RACE_DEFAULT_LOOPS; i++) {
            List<Throwable> errors = TestHelper.trackPluginErrors();
            try {
                final PublishProcessor<Integer> pp = PublishProcessor.create();

                final Subscriber<?>[] sub = { null, null };

                final Flowable<Integer> pp2 = new Flowable<Integer>() {

                    int count;

                    @Override
                    protected void subscribeActual(
                            Subscriber<? super Integer> s) {
                        assertFalse(((Disposable)s).isDisposed());
                        s.onSubscribe(new BooleanSubscription());
                        sub[count++] = s;
                    }
                };

                TestSubscriber<Integer> ts = pp.timeout(Functions.justFunction(pp2), Flowable.<Integer>never()).test();

                pp.onNext(0);

                Runnable r1 = new Runnable() {
                    @Override
                    public void run() {
                        pp.onNext(1);
                    }
                };

                final Throwable ex = new TestException();

                Runnable r2 = new Runnable() {
                    @Override
                    public void run() {
                        sub[0].onError(ex);
                    }
                };

                TestHelper.race(r1, r2);

                ts.assertValueAt(0, 0);

                if (!errors.isEmpty()) {
                    TestHelper.assertUndeliverable(errors, 0, TestException.class);
                }
            } finally {
                RxJavaPlugins.reset();
            }
        }
    }",loop_control
i,"{
        for (int i = 0; i < TestHelper.RACE_DEFAULT_LOOPS; i++) {
            List<Throwable> errors = TestHelper.trackPluginErrors();
            try {
                final PublishProcessor<Integer> pp = PublishProcessor.create();

                final Subscriber<?>[] sub = { null, null };

                final Flowable<Integer> pp2 = new Flowable<Integer>() {

                    int count;

                    @Override
                    protected void subscribeActual(
                            Subscriber<? super Integer> s) {
                        assertFalse(((Disposable)s).isDisposed());
                        s.onSubscribe(new BooleanSubscription());
                        sub[count++] = s;
                    }
                };

                TestSubscriber<Integer> ts = pp.timeout(Functions.justFunction(pp2)).test();

                pp.onNext(0);

                final Throwable ex = new TestException();

                Runnable r1 = new Runnable() {
                    @Override
                    public void run() {
                        pp.onError(ex);
                    }
                };

                Runnable r2 = new Runnable() {
                    @Override
                    public void run() {
                        sub[0].onComplete();
                    }
                };

                TestHelper.race(r1, r2);

                ts.assertValueAt(0, 0);

                if (!errors.isEmpty()) {
                    TestHelper.assertUndeliverable(errors, 0, TestException.class);
                }
            } finally {
                RxJavaPlugins.reset();
            }
        }
    }",loop_control
i,"{
        for (int i = 0; i < TestHelper.RACE_DEFAULT_LOOPS; i++) {
            List<Throwable> errors = TestHelper.trackPluginErrors();
            try {
                final PublishProcessor<Integer> pp = PublishProcessor.create();

                final Subscriber<?>[] sub = { null, null };

                final Flowable<Integer> pp2 = new Flowable<Integer>() {

                    int count;

                    @Override
                    protected void subscribeActual(
                            Subscriber<? super Integer> s) {
                        assertFalse(((Disposable)s).isDisposed());
                        s.onSubscribe(new BooleanSubscription());
                        sub[count++] = s;
                    }
                };

                TestSubscriber<Integer> ts = pp.timeout(Functions.justFunction(pp2)).test();

                pp.onNext(0);

                Runnable r1 = new Runnable() {
                    @Override
                    public void run() {
                        pp.onComplete();
                    }
                };

                Runnable r2 = new Runnable() {
                    @Override
                    public void run() {
                        sub[0].onComplete();
                    }
                };

                TestHelper.race(r1, r2);

                ts.assertValueAt(0, 0);

                if (!errors.isEmpty()) {
                    TestHelper.assertUndeliverable(errors, 0, TestException.class);
                }
            } finally {
                RxJavaPlugins.reset();
            }
        }
    }",loop_control
i,"{
        for (int i = 0; i < TestHelper.RACE_DEFAULT_LOOPS; i++) {
            List<Throwable> errors = TestHelper.trackPluginErrors();
            try {
                final PublishProcessor<Integer> pp = PublishProcessor.create();

                final Subscriber<?>[] sub = { null, null };

                final Flowable<Integer> pp2 = new Flowable<Integer>() {

                    int count;

                    @Override
                    protected void subscribeActual(
                            Subscriber<? super Integer> s) {
                        assertFalse(((Disposable)s).isDisposed());
                        s.onSubscribe(new BooleanSubscription());
                        sub[count++] = s;
                    }
                };

                TestSubscriber<Integer> ts = pp.timeout(Functions.justFunction(pp2), Flowable.<Integer>never()).test();

                pp.onNext(0);

                Runnable r1 = new Runnable() {
                    @Override
                    public void run() {
                        pp.onComplete();
                    }
                };

                Runnable r2 = new Runnable() {
                    @Override
                    public void run() {
                        sub[0].onComplete();
                    }
                };

                TestHelper.race(r1, r2);

                ts.assertValueAt(0, 0);

                if (!errors.isEmpty()) {
                    TestHelper.assertUndeliverable(errors, 0, TestException.class);
                }
            } finally {
                RxJavaPlugins.reset();
            }
        }
    }",loop_control
j,"{
        final int NUM_LOOPS = 1;
        for (int j = 0; j < NUM_LOOPS; j++) {
            final int numRetries = Flowable.bufferSize() * 2;
            for (int i = 0; i < 400; i++) {
                Subscriber<String> subscriber = TestHelper.mockSubscriber();
                Flowable<String> origin = Flowable.unsafeCreate(new FuncWithErrors(numRetries));
                TestSubscriberEx<String> ts = new TestSubscriberEx<>(subscriber);
                origin.retry().observeOn(Schedulers.computation()).subscribe(ts);
                ts.awaitDone(5, TimeUnit.SECONDS);

                InOrder inOrder = inOrder(subscriber);
                // should have no errors
                verify(subscriber, never()).onError(any(Throwable.class));
                // should show numRetries attempts
                inOrder.verify(subscriber, times(numRetries + 1)).onNext(""beginningEveryTime"");
                // should have a single success
                inOrder.verify(subscriber, times(1)).onNext(""onSuccessOnly"");
                // should have a single successful onComplete
                inOrder.verify(subscriber, times(1)).onComplete();
                inOrder.verifyNoMoreInteractions();
            }
        }
    }",loop_control
i,"{
        final int NUM_LOOPS = 1;
        for (int j = 0; j < NUM_LOOPS; j++) {
            final int numRetries = Flowable.bufferSize() * 2;
            for (int i = 0; i < 400; i++) {
                Subscriber<String> subscriber = TestHelper.mockSubscriber();
                Flowable<String> origin = Flowable.unsafeCreate(new FuncWithErrors(numRetries));
                TestSubscriberEx<String> ts = new TestSubscriberEx<>(subscriber);
                origin.retry().observeOn(Schedulers.computation()).subscribe(ts);
                ts.awaitDone(5, TimeUnit.SECONDS);

                InOrder inOrder = inOrder(subscriber);
                // should have no errors
                verify(subscriber, never()).onError(any(Throwable.class));
                // should show numRetries attempts
                inOrder.verify(subscriber, times(numRetries + 1)).onNext(""beginningEveryTime"");
                // should have a single success
                inOrder.verify(subscriber, times(1)).onNext(""onSuccessOnly"");
                // should have a single successful onComplete
                inOrder.verify(subscriber, times(1)).onComplete();
                inOrder.verifyNoMoreInteractions();
            }
        }
    }",loop_control
r,"{
        final int NUM_LOOPS = 1;
        final int numRetries = Flowable.bufferSize() * 2;
        int ncpu = Runtime.getRuntime().availableProcessors();
        ExecutorService exec = Executors.newFixedThreadPool(Math.max(ncpu / 2, 2));
        try {
            for (int r = 0; r < NUM_LOOPS; r++) {
                if (r % 10 == 0) {
                    System.out.println(""testRetryWithBackpressureParallelLoop -> "" + r);
                }

                final AtomicInteger timeouts = new AtomicInteger();
                final Map<Integer, List<String>> data = new ConcurrentHashMap<>();

                int m = 5000;
                final CountDownLatch cdl = new CountDownLatch(m);
                for (int i = 0; i < m; i++) {
                    final int j = i;
                    exec.execute(new Runnable() {
                        @Override
                        public void run() {
                            final AtomicInteger nexts = new AtomicInteger();
                            try {
                                Flowable<String> origin = Flowable.unsafeCreate(new FuncWithErrors(numRetries));
                                TestSubscriberEx<String> ts = new TestSubscriberEx<>();
                                origin.retry()
                                .observeOn(Schedulers.computation()).subscribe(ts);
                                ts.awaitDone(2500, TimeUnit.MILLISECONDS);
                                List<String> onNextEvents = new ArrayList<>(ts.values());
                                if (onNextEvents.size() != numRetries + 2) {
                                    for (Throwable t : ts.errors()) {
                                        onNextEvents.add(t.toString());
                                    }
                                    for (long err = ts.completions(); err != 0; err--) {
                                        onNextEvents.add(""onComplete"");
                                    }
                                    data.put(j, onNextEvents);
                                }
                            } catch (Throwable t) {
                                timeouts.incrementAndGet();
                                System.out.println(j + "" | "" + cdl.getCount() + "" !!! "" + nexts.get());
                            }
                            cdl.countDown();
                        }
                    });
                }
                cdl.await();
                assertEquals(0, timeouts.get());
                if (data.size() > 0) {
                    fail(""Data content mismatch: "" + allSequenceFrequency(data));
                }
            }
        } finally {
            exec.shutdown();
        }
    }",loop_control
i,"{
        final int NUM_LOOPS = 1;
        final int numRetries = Flowable.bufferSize() * 2;
        int ncpu = Runtime.getRuntime().availableProcessors();
        ExecutorService exec = Executors.newFixedThreadPool(Math.max(ncpu / 2, 2));
        try {
            for (int r = 0; r < NUM_LOOPS; r++) {
                if (r % 10 == 0) {
                    System.out.println(""testRetryWithBackpressureParallelLoop -> "" + r);
                }

                final AtomicInteger timeouts = new AtomicInteger();
                final Map<Integer, List<String>> data = new ConcurrentHashMap<>();

                int m = 5000;
                final CountDownLatch cdl = new CountDownLatch(m);
                for (int i = 0; i < m; i++) {
                    final int j = i;
                    exec.execute(new Runnable() {
                        @Override
                        public void run() {
                            final AtomicInteger nexts = new AtomicInteger();
                            try {
                                Flowable<String> origin = Flowable.unsafeCreate(new FuncWithErrors(numRetries));
                                TestSubscriberEx<String> ts = new TestSubscriberEx<>();
                                origin.retry()
                                .observeOn(Schedulers.computation()).subscribe(ts);
                                ts.awaitDone(2500, TimeUnit.MILLISECONDS);
                                List<String> onNextEvents = new ArrayList<>(ts.values());
                                if (onNextEvents.size() != numRetries + 2) {
                                    for (Throwable t : ts.errors()) {
                                        onNextEvents.add(t.toString());
                                    }
                                    for (long err = ts.completions(); err != 0; err--) {
                                        onNextEvents.add(""onComplete"");
                                    }
                                    data.put(j, onNextEvents);
                                }
                            } catch (Throwable t) {
                                timeouts.incrementAndGet();
                                System.out.println(j + "" | "" + cdl.getCount() + "" !!! "" + nexts.get());
                            }
                            cdl.countDown();
                        }
                    });
                }
                cdl.await();
                assertEquals(0, timeouts.get());
                if (data.size() > 0) {
                    fail(""Data content mismatch: "" + allSequenceFrequency(data));
                }
            }
        } finally {
            exec.shutdown();
        }
    }",loop_control
t,"{
        final int NUM_LOOPS = 1;
        final int numRetries = Flowable.bufferSize() * 2;
        int ncpu = Runtime.getRuntime().availableProcessors();
        ExecutorService exec = Executors.newFixedThreadPool(Math.max(ncpu / 2, 2));
        try {
            for (int r = 0; r < NUM_LOOPS; r++) {
                if (r % 10 == 0) {
                    System.out.println(""testRetryWithBackpressureParallelLoop -> "" + r);
                }

                final AtomicInteger timeouts = new AtomicInteger();
                final Map<Integer, List<String>> data = new ConcurrentHashMap<>();

                int m = 5000;
                final CountDownLatch cdl = new CountDownLatch(m);
                for (int i = 0; i < m; i++) {
                    final int j = i;
                    exec.execute(new Runnable() {
                        @Override
                        public void run() {
                            final AtomicInteger nexts = new AtomicInteger();
                            try {
                                Flowable<String> origin = Flowable.unsafeCreate(new FuncWithErrors(numRetries));
                                TestSubscriberEx<String> ts = new TestSubscriberEx<>();
                                origin.retry()
                                .observeOn(Schedulers.computation()).subscribe(ts);
                                ts.awaitDone(2500, TimeUnit.MILLISECONDS);
                                List<String> onNextEvents = new ArrayList<>(ts.values());
                                if (onNextEvents.size() != numRetries + 2) {
                                    for (Throwable t : ts.errors()) {
                                        onNextEvents.add(t.toString());
                                    }
                                    for (long err = ts.completions(); err != 0; err--) {
                                        onNextEvents.add(""onComplete"");
                                    }
                                    data.put(j, onNextEvents);
                                }
                            } catch (Throwable t) {
                                timeouts.incrementAndGet();
                                System.out.println(j + "" | "" + cdl.getCount() + "" !!! "" + nexts.get());
                            }
                            cdl.countDown();
                        }
                    });
                }
                cdl.await();
                assertEquals(0, timeouts.get());
                if (data.size() > 0) {
                    fail(""Data content mismatch: "" + allSequenceFrequency(data));
                }
            }
        } finally {
            exec.shutdown();
        }
    }",iterator
err,"{
        final int NUM_LOOPS = 1;
        final int numRetries = Flowable.bufferSize() * 2;
        int ncpu = Runtime.getRuntime().availableProcessors();
        ExecutorService exec = Executors.newFixedThreadPool(Math.max(ncpu / 2, 2));
        try {
            for (int r = 0; r < NUM_LOOPS; r++) {
                if (r % 10 == 0) {
                    System.out.println(""testRetryWithBackpressureParallelLoop -> "" + r);
                }

                final AtomicInteger timeouts = new AtomicInteger();
                final Map<Integer, List<String>> data = new ConcurrentHashMap<>();

                int m = 5000;
                final CountDownLatch cdl = new CountDownLatch(m);
                for (int i = 0; i < m; i++) {
                    final int j = i;
                    exec.execute(new Runnable() {
                        @Override
                        public void run() {
                            final AtomicInteger nexts = new AtomicInteger();
                            try {
                                Flowable<String> origin = Flowable.unsafeCreate(new FuncWithErrors(numRetries));
                                TestSubscriberEx<String> ts = new TestSubscriberEx<>();
                                origin.retry()
                                .observeOn(Schedulers.computation()).subscribe(ts);
                                ts.awaitDone(2500, TimeUnit.MILLISECONDS);
                                List<String> onNextEvents = new ArrayList<>(ts.values());
                                if (onNextEvents.size() != numRetries + 2) {
                                    for (Throwable t : ts.errors()) {
                                        onNextEvents.add(t.toString());
                                    }
                                    for (long err = ts.completions(); err != 0; err--) {
                                        onNextEvents.add(""onComplete"");
                                    }
                                    data.put(j, onNextEvents);
                                }
                            } catch (Throwable t) {
                                timeouts.incrementAndGet();
                                System.out.println(j + "" | "" + cdl.getCount() + "" !!! "" + nexts.get());
                            }
                            cdl.countDown();
                        }
                    });
                }
                cdl.await();
                assertEquals(0, timeouts.get());
                if (data.size() > 0) {
                    fail(""Data content mismatch: "" + allSequenceFrequency(data));
                }
            }
        } finally {
            exec.shutdown();
        }
    }",loop_control
e,"{
        StringBuilder b = new StringBuilder();
        for (Map.Entry<Integer, List<T>> e : its.entrySet()) {
            if (b.length() > 0) {
                b.append("", "");
            }
            b.append(e.getKey()).append(""={"");
            b.append(sequenceFrequency(e.getValue()));
            b.append(""}"");
        }
        return b;
    }",iterator
curr,"{
        StringBuilder sb = new StringBuilder();

        Object prev = null;
        int cnt = 0;

        for (Object curr : it) {
            if (sb.length() > 0) {
                if (!curr.equals(prev)) {
                    if (cnt > 1) {
                        sb.append("" x "").append(cnt);
                        cnt = 1;
                    }
                    sb.append("", "");
                    sb.append(curr);
                } else {
                    cnt++;
                }
            } else {
                sb.append(curr);
                cnt++;
            }
            prev = curr;
        }
        if (cnt > 1) {
            sb.append("" x "").append(cnt);
        }

        return sb;
    }",iterator
i,"{
        Subscriber<String> subscriber = TestHelper.mockSubscriber();
        final int NUM_MSG = 1034;
        final AtomicInteger count = new AtomicInteger();

        Flowable<String> origin = Flowable.unsafeCreate(new Publisher<String>() {

            @Override
            public void subscribe(Subscriber<? super String> subscriber) {
                subscriber.onSubscribe(new BooleanSubscription());
                for (int i = 0; i < NUM_MSG; i++) {
                    subscriber.onNext(""msg:"" + count.incrementAndGet());
                }
                subscriber.onComplete();
            }
        });

        origin.retry()
        .groupBy(new Function<String, String>() {
            @Override
            public String apply(String t1) {
                return t1;
            }
        })
        .flatMap(new Function<GroupedFlowable<String, String>, Flowable<String>>() {
            @Override
            public Flowable<String> apply(GroupedFlowable<String, String> t1) {
                return t1.take(1);
            }
        })
        .subscribe(new TestSubscriber<>(subscriber));

        InOrder inOrder = inOrder(subscriber);
        // should show 3 attempts
        inOrder.verify(subscriber, times(NUM_MSG)).onNext(any(java.lang.String.class));
        //        // should have no errors
        inOrder.verify(subscriber, never()).onError(any(Throwable.class));
        // should have a single success
        //inOrder.verify(observer, times(1)).onNext(""onSuccessOnly"");
        // should have a single successful onComplete
        inOrder.verify(subscriber, times(1)).onComplete();
        inOrder.verifyNoMoreInteractions();
    }",loop_control
i,"{
        List<Throwable> errors = TestHelper.trackPluginErrors();

        final TestException error = new TestException();

        try {
            final PublishProcessor<Integer> source = PublishProcessor.create();
            final PublishProcessor<Integer> signaller = PublishProcessor.create();

            for (int i = 0; i < TestHelper.RACE_DEFAULT_LOOPS; i++) {

                TestSubscriber<Integer> ts = source.take(1)
                .map(new Function<Integer, Integer>() {
                    @Override
                    public Integer apply(Integer v) throws Exception {
                        throw error;
                    }
                })
                .retryWhen(new Function<Flowable<Throwable>, Flowable<Integer>>() {
                    @Override
                    public Flowable<Integer> apply(Flowable<Throwable> v)
                            throws Exception {
                        return signaller;
                    }
                }).test();

                Runnable r1 = new Runnable() {
                    @Override
                    public void run() {
                        for (int i = 0; i < TestHelper.RACE_DEFAULT_LOOPS; i++) {
                            source.onNext(1);
                        }
                    }
                };
                Runnable r2 = new Runnable() {
                    @Override
                    public void run() {
                        for (int i = 0; i < TestHelper.RACE_DEFAULT_LOOPS; i++) {
                            signaller.offer(1);
                        }
                    }
                };

                TestHelper.race(r1, r2);

                ts.cancel();
            }

            if (!errors.isEmpty()) {
                for (Throwable e : errors) {
                    e.printStackTrace();
                }
                fail(errors + """");
            }
        } finally {
            RxJavaPlugins.reset();
        }
    }",loop_control
s,"{

        final Subscription upstream;
        final String[] values;
        Thread t;

        TestObservable(Subscription s, String... values) {
            this.upstream = s;
            this.values = values;
        }

        @Override
        public void subscribe(final Subscriber<? super String> subscriber) {
            System.out.println(""TestObservable subscribed to ..."");
            subscriber.onSubscribe(upstream);
            t = new Thread(new Runnable() {

                @Override
                public void run() {
                    try {
                        System.out.println(""running TestObservable thread"");
                        for (String s : values) {
                            if (""fail"".equals(s)) {
                                throw new RuntimeException(""Forced Failure"");
                            }
                            System.out.println(""TestObservable onNext: "" + s);
                            subscriber.onNext(s);
                        }
                        System.out.println(""TestObservable onComplete"");
                        subscriber.onComplete();
                    } catch (Throwable e) {
                        System.out.println(""TestObservable onError: "" + e);
                        subscriber.onError(e);
                    }
                }

            });
            System.out.println(""starting TestObservable thread"");
            t.start();
            System.out.println(""done starting TestObservable thread"");
        }
    }",iterator
i,"{
        TestSubscriberEx<Integer> ts = Flowable.range(1, 10).concatWith(Flowable.<Integer>error(new TestException()))
        .flatMapMaybe(new Function<Integer, MaybeSource<Integer>>() {
            @Override
            public MaybeSource<Integer> apply(Integer v) throws Exception {
                return Maybe.error(new TestException());
            }
        }, true, Integer.MAX_VALUE)
        .to(TestHelper.<Integer>testConsumer())
        .assertFailure(CompositeException.class);

        List<Throwable> errors = TestHelper.compositeList(ts.errors().get(0));

        for (int i = 0; i < 11; i++) {
            TestHelper.assertError(errors, i, TestException.class);
        }
    }",loop_control
i,"{
        for (int i = 0; i < TestHelper.RACE_DEFAULT_LOOPS; i++) {
            final TestSubscriber<Integer> ts = Flowable.just(1).concatWith(Flowable.<Integer>never())
            .flatMapMaybe(Functions.justFunction(Maybe.just(2))).test(0);

            Runnable r1 = new Runnable() {
                @Override
                public void run() {
                    ts.request(1);
                }
            };
            Runnable r2 = new Runnable() {
                @Override
                public void run() {
                    ts.cancel();
                }
            };

            TestHelper.race(r1, r2);
        }
    }",loop_control
i,"{
        for (int i = 0; i < TestHelper.RACE_DEFAULT_LOOPS; i++) {
            MaybeSubject<Integer> ss1 = MaybeSubject.create();
            MaybeSubject<Integer> ss2 = MaybeSubject.create();

            TestSubscriber<Integer> ts = Flowable.just(ss1, ss2).flatMapMaybe(v -> v)
            .test();

            TestHelper.race(
                    () -> ss1.onSuccess(1),
                    () -> ss2.onSuccess(1)
            );

            ts.assertResult(1, 1);
        }
    }",loop_control
i,"{
        for (int i = 0; i < TestHelper.RACE_DEFAULT_LOOPS; i++) {
            MaybeSubject<Integer> ss1 = MaybeSubject.create();
            MaybeSubject<Integer> ss2 = MaybeSubject.create();

            TestSubscriber<Integer> ts = Flowable.just(ss1, ss2).flatMapMaybe(v -> v)
            .test();

            TestHelper.race(
                    () -> ss1.onSuccess(1),
                    () -> ss2.onComplete()
            );

            ts.assertResult(1);
        }
    }",loop_control
arg,"{
        List<String> list = new ArrayList<>();
        for (String arg : args) {
            list.add(arg);
        }
        return list;
    }",iterator
i,"{
        TestHelper.withErrorTracking(errors -> {
            TestException ex1 = new TestException();
            TestException ex2 = new TestException();
            for (int i = 0; i < TestHelper.RACE_DEFAULT_LOOPS; i++) {
                AtomicReference<Subscriber<? super Integer>> ref1 = new AtomicReference<>();
                AtomicReference<Subscriber<? super Integer>> ref2 = new AtomicReference<>();

                Flowable<Integer> f1 = Flowable.<Integer>fromPublisher(ref1::set);
                Flowable<Integer> f2 = Flowable.<Integer>fromPublisher(ref2::set);

                TestSubscriber<Flowable<Integer>> ts = BehaviorProcessor.createDefault(1)
                .window(f1, v -> f2)
                .doOnNext(w -> w.test())
                .test();

                ref1.get().onSubscribe(new BooleanSubscription());
                ref1.get().onNext(1);
                ref2.get().onSubscribe(new BooleanSubscription());

                TestHelper.race(
                        () -> ref1.get().onError(ex1),
                        () -> ref2.get().onError(ex2)
                );

                ts.assertError(RuntimeException.class);

                if (!errors.isEmpty()) {
                    TestHelper.assertUndeliverable(errors, 0, TestException.class);
                }

                errors.clear();
            }
        });
    }",loop_control
i,"{
        for (int i = 0; i < TestHelper.RACE_DEFAULT_LOOPS; i++) {
            List<Throwable> errors = TestHelper.trackPluginErrors();
            try {
                final PublishProcessor<Integer> pp1 = PublishProcessor.create();
                final PublishProcessor<Integer> pp2 = PublishProcessor.create();

                TestSubscriberEx<Integer> ts = pp1.concatMapEager(new Function<Integer, Flowable<Integer>>() {
                    @Override
                    public Flowable<Integer> apply(Integer v) throws Exception {
                        return pp2;
                    }
                }).to(TestHelper.<Integer>testConsumer());

                final TestException ex1 = new TestException();
                final TestException ex2 = new TestException();

                pp1.onNext(1);

                Runnable r1 = new Runnable() {
                    @Override
                    public void run() {
                        pp1.onError(ex1);
                    }
                };
                Runnable r2 = new Runnable() {
                    @Override
                    public void run() {
                        pp2.onError(ex2);
                    }
                };

                TestHelper.race(r1, r2);

                ts.assertSubscribed().assertNoValues().assertNotComplete();

                Throwable ex = ts.errors().get(0);

                if (ex instanceof CompositeException) {
                    List<Throwable> es = TestHelper.errorList(ts);
                    TestHelper.assertError(es, 0, TestException.class);
                    TestHelper.assertError(es, 1, TestException.class);
                } else {
                    ts.assertError(TestException.class);
                    if (!errors.isEmpty()) {
                        TestHelper.assertUndeliverable(errors, 0, TestException.class);
                    }
                }
            } finally {
                RxJavaPlugins.reset();
            }
        }
    }",loop_control
i,"{
        for (int i = 0; i < TestHelper.RACE_DEFAULT_LOOPS; i++) {
            final PublishProcessor<Integer> pp1 = PublishProcessor.create();

            final TestSubscriber<Integer> ts = pp1.concatMapEager(new Function<Integer, Flowable<Integer>>() {
                @Override
                public Flowable<Integer> apply(Integer v) throws Exception {
                    return Flowable.never();
                }
            }).test();

            Runnable r1 = new Runnable() {
                @Override
                public void run() {
                    pp1.onNext(1);
                }
            };
            Runnable r2 = new Runnable() {
                @Override
                public void run() {
                    ts.cancel();
                }
            };

            TestHelper.race(r1, r2);

            ts.assertEmpty();
        }
    }",loop_control
i,"{
        for (int i = 0; i < TestHelper.RACE_DEFAULT_LOOPS; i++) {
            final PublishProcessor<Integer> pp = PublishProcessor.create();

            final TestSubscriber<Integer> ts = new TestSubscriber<>(0L);

            Flowable.just(1)
            .concatMapEager(Functions.justFunction(pp))
            .subscribe(ts);

            Runnable r1 = new Runnable() {
                @Override
                public void run() {
                    pp.onComplete();
                }
            };

            Runnable r2 = new Runnable() {
                @Override
                public void run() {
                    ts.cancel();
                }
            };

            TestHelper.race(r1, r2);
        }
    }",loop_control
i,"{
        List<Integer>[] list = new ArrayList[100];
        for (int i = 0; i < 100; i++) {
            List<Integer> lst = new ArrayList<>();
            list[i] = lst;
            for (int k = 1; k <= 10; k++) {
                lst.add((i) * 10 + k);
            }
        }

        Flowable.range(1, 1000)
        .buffer(10)
        .concatMapEager(new Function<List<Integer>, Flowable<List<Integer>>>() {
            @Override
            public Flowable<List<Integer>> apply(List<Integer> v)
                    throws Exception {
                return Flowable.just(v)
                        .subscribeOn(Schedulers.io())
                        .doOnNext(new Consumer<List<Integer>>() {
                            @Override
                            public void accept(List<Integer> v)
                                    throws Exception {
                                Thread.sleep(new Random().nextInt(20));
                            }
                        });
            }
        }
                , 2, 3)
        .test()
        .awaitDone(5, TimeUnit.SECONDS)
        .assertResult(list);
    }",loop_control
j,"{
        List<Integer>[] list = new ArrayList[100];
        for (int i = 0; i < 100; i++) {
            List<Integer> lst = new ArrayList<>();
            list[i] = lst;
            for (int k = 1; k <= 10; k++) {
                lst.add((i) * 10 + k);
            }
        }

        Flowable.range(1, 1000)
        .buffer(10)
        .concatMapEager(new Function<List<Integer>, Flowable<List<Integer>>>() {
            @Override
            public Flowable<List<Integer>> apply(List<Integer> v)
                    throws Exception {
                return Flowable.just(v)
                        .subscribeOn(Schedulers.io())
                        .doOnNext(new Consumer<List<Integer>>() {
                            @Override
                            public void accept(List<Integer> v)
                                    throws Exception {
                                Thread.sleep(new Random().nextInt(20));
                            }
                        });
            }
        }
                , 2, 3)
        .test()
        .awaitDone(5, TimeUnit.SECONDS)
        .assertResult(list);
    }",loop_control
i,"{
        for (int i = 0; i < 1000; i++) {
            final PublishProcessor<Integer> pp = PublishProcessor.create();
            final CompletableSubject cs = CompletableSubject.create();

            TestSubscriber<Integer> ts = pp.mergeWith(cs).test();

            Runnable r1 = new Runnable() {
                @Override
                public void run() {
                    pp.onNext(1);
                    pp.onComplete();
                }
            };

            Runnable r2 = new Runnable() {
                @Override
                public void run() {
                    cs.onComplete();
                }
            };

            TestHelper.race(r1, r2);

            ts.assertResult(1);
        }
    }",loop_control
i,"{
        PublishProcessor<Integer> source = PublishProcessor.create();
        PublishProcessor<Integer> boundary = PublishProcessor.create();

        final Subscriber<Object> subscriber = TestHelper.mockSubscriber();

        final List<Subscriber<Object>> values = new ArrayList<>();

        Subscriber<Flowable<Integer>> wo = new DefaultSubscriber<Flowable<Integer>>() {
            @Override
            public void onNext(Flowable<Integer> args) {
                final Subscriber<Object> mo = TestHelper.mockSubscriber();
                values.add(mo);

                args.subscribe(mo);
            }

            @Override
            public void onError(Throwable e) {
                subscriber.onError(e);
            }

            @Override
            public void onComplete() {
                subscriber.onComplete();
            }
        };

        source.window(boundary).subscribe(wo);

        int n = 30;
        for (int i = 0; i < n; i++) {
            source.onNext(i);
            if (i % 3 == 2 && i < n - 1) {
                boundary.onNext(i / 3);
            }
        }
        source.onComplete();

        verify(subscriber, never()).onError(any(Throwable.class));

        assertEquals(n / 3, values.size());

        int j = 0;
        for (Subscriber<Object> mo : values) {
            verify(mo, never()).onError(any(Throwable.class));
            for (int i = 0; i < 3; i++) {
                verify(mo).onNext(j + i);
            }
            verify(mo).onComplete();
            j += 3;
        }

        verify(subscriber).onComplete();
    }",loop_control
mo,"{
        PublishProcessor<Integer> source = PublishProcessor.create();
        PublishProcessor<Integer> boundary = PublishProcessor.create();

        final Subscriber<Object> subscriber = TestHelper.mockSubscriber();

        final List<Subscriber<Object>> values = new ArrayList<>();

        Subscriber<Flowable<Integer>> wo = new DefaultSubscriber<Flowable<Integer>>() {
            @Override
            public void onNext(Flowable<Integer> args) {
                final Subscriber<Object> mo = TestHelper.mockSubscriber();
                values.add(mo);

                args.subscribe(mo);
            }

            @Override
            public void onError(Throwable e) {
                subscriber.onError(e);
            }

            @Override
            public void onComplete() {
                subscriber.onComplete();
            }
        };

        source.window(boundary).subscribe(wo);

        int n = 30;
        for (int i = 0; i < n; i++) {
            source.onNext(i);
            if (i % 3 == 2 && i < n - 1) {
                boundary.onNext(i / 3);
            }
        }
        source.onComplete();

        verify(subscriber, never()).onError(any(Throwable.class));

        assertEquals(n / 3, values.size());

        int j = 0;
        for (Subscriber<Object> mo : values) {
            verify(mo, never()).onError(any(Throwable.class));
            for (int i = 0; i < 3; i++) {
                verify(mo).onNext(j + i);
            }
            verify(mo).onComplete();
            j += 3;
        }

        verify(subscriber).onComplete();
    }",iterator
mo,"{
        PublishProcessor<Integer> source = PublishProcessor.create();
        PublishProcessor<Integer> boundary = PublishProcessor.create();

        final Subscriber<Object> subscriber = TestHelper.mockSubscriber();

        final List<Subscriber<Object>> values = new ArrayList<>();

        Subscriber<Flowable<Integer>> wo = new DefaultSubscriber<Flowable<Integer>>() {
            @Override
            public void onNext(Flowable<Integer> args) {
                final Subscriber<Object> mo = TestHelper.mockSubscriber();
                values.add(mo);

                args.subscribe(mo);
            }

            @Override
            public void onError(Throwable e) {
                subscriber.onError(e);
            }

            @Override
            public void onComplete() {
                subscriber.onComplete();
            }
        };

        source.window(boundary).subscribe(wo);

        int n = 30;
        for (int i = 0; i < n; i++) {
            source.onNext(i);
            if (i % 3 == 2 && i < n - 1) {
                boundary.onNext(i / 3);
            }
        }
        boundary.onComplete();

        assertEquals(n / 3, values.size());

        int j = 0;
        for (Subscriber<Object> mo : values) {
            for (int i = 0; i < 3; i++) {
                verify(mo).onNext(j + i);
            }
            verify(mo).onComplete();
            verify(mo, never()).onError(any(Throwable.class));
            j += 3;
        }

        verify(subscriber).onComplete();
        verify(subscriber, never()).onError(any(Throwable.class));
    }",iterator
i,"{
        PublishProcessor<Integer> source = PublishProcessor.create();
        PublishProcessor<Integer> boundary = PublishProcessor.create();

        final Subscriber<Object> subscriber = TestHelper.mockSubscriber();

        final List<Subscriber<Object>> values = new ArrayList<>();

        Subscriber<Flowable<Integer>> wo = new DefaultSubscriber<Flowable<Integer>>() {
            @Override
            public void onNext(Flowable<Integer> args) {
                final Subscriber<Object> mo = TestHelper.mockSubscriber();
                values.add(mo);

                args.subscribe(mo);
            }

            @Override
            public void onError(Throwable e) {
                subscriber.onError(e);
            }

            @Override
            public void onComplete() {
                subscriber.onComplete();
            }
        };

        source.window(boundary).subscribe(wo);

        int n = 30;
        for (int i = 0; i < n; i++) {
            source.onNext(i);
            if (i % 3 == 2 && i < n - 1) {
                boundary.onNext(i / 3);
            }
        }
        boundary.onComplete();

        assertEquals(n / 3, values.size());

        int j = 0;
        for (Subscriber<Object> mo : values) {
            for (int i = 0; i < 3; i++) {
                verify(mo).onNext(j + i);
            }
            verify(mo).onComplete();
            verify(mo, never()).onError(any(Throwable.class));
            j += 3;
        }

        verify(subscriber).onComplete();
        verify(subscriber, never()).onError(any(Throwable.class));
    }",loop_control
i,"{
        final TestException ex = new TestException();

        for (int i = 0; i < TestHelper.RACE_LONG_LOOPS; i++) {
            List<Throwable> errors = TestHelper.trackPluginErrors();
            try {
                final AtomicReference<Subscriber<? super Object>> refMain = new AtomicReference<>();
                final AtomicReference<Subscriber<? super Object>> ref = new AtomicReference<>();

                TestSubscriberEx<Flowable<Object>> ts = new Flowable<Object>() {
                    @Override
                    protected void subscribeActual(Subscriber<? super Object> subscriber) {
                        subscriber.onSubscribe(new BooleanSubscription());
                        refMain.set(subscriber);
                    }
                }
                .window(new Flowable<Object>() {
                    @Override
                    protected void subscribeActual(Subscriber<? super Object> subscriber) {
                        subscriber.onSubscribe(new BooleanSubscription());
                        ref.set(subscriber);
                    }
                })
                .to(TestHelper.<Flowable<Object>>testConsumer());

                Runnable r1 = new Runnable() {
                    @Override
                    public void run() {
                        refMain.get().onComplete();
                    }
                };
                Runnable r2 = new Runnable() {
                    @Override
                    public void run() {
                        ref.get().onError(ex);
                    }
                };

                TestHelper.race(r1, r2);

                ts
                .assertValueCount(1)
                .assertTerminated();

                if (!errors.isEmpty()) {
                    TestHelper.assertUndeliverable(errors, 0, TestException.class);
                }
            } finally {
                RxJavaPlugins.reset();
            }
        }
    }",loop_control
i,"{
        for (int i = 0; i < TestHelper.RACE_LONG_LOOPS; i++) {
            final AtomicReference<Subscriber<? super Object>> refMain = new AtomicReference<>();
            final AtomicReference<Subscriber<? super Object>> ref = new AtomicReference<>();

            TestSubscriber<Flowable<Object>> ts = new Flowable<Object>() {
                @Override
                protected void subscribeActual(Subscriber<? super Object> subscriber) {
                    subscriber.onSubscribe(new BooleanSubscription());
                    refMain.set(subscriber);
                }
            }
            .window(new Flowable<Object>() {
                @Override
                protected void subscribeActual(Subscriber<? super Object> subscriber) {
                    subscriber.onSubscribe(new BooleanSubscription());
                    ref.set(subscriber);
                }
            })
            .test();

            Runnable r1 = new Runnable() {
                @Override
                public void run() {
                    refMain.get().onNext(1);
                }
            };
            Runnable r2 = new Runnable() {
                @Override
                public void run() {
                    ref.get().onNext(1);
                }
            };

            TestHelper.race(r1, r2);

            ts
            .assertValueCount(2)
            .assertNotComplete()
            .assertNoErrors();
        }
    }",loop_control
i,"{
        for (int i = 0; i < TestHelper.RACE_LONG_LOOPS; i++) {
            final AtomicReference<Subscriber<? super Object>> refMain = new AtomicReference<>();
            final AtomicReference<Subscriber<? super Object>> ref = new AtomicReference<>();

            final TestSubscriber<Flowable<Object>> ts = new Flowable<Object>() {
                 @Override
                 protected void subscribeActual(Subscriber<? super Object> subscriber) {
                     subscriber.onSubscribe(new BooleanSubscription());
                     refMain.set(subscriber);
                 }
             }
             .window(new Flowable<Object>() {
                 @Override
                 protected void subscribeActual(Subscriber<? super Object> subscriber) {
                     final AtomicInteger counter = new AtomicInteger();
                     subscriber.onSubscribe(new Subscription() {

                         @Override
                         public void cancel() {
                             // about a microsecond
                             for (int i = 0; i < 100; i++) {
                                 counter.incrementAndGet();
                             }
                         }

                         @Override
                        public void request(long n) {
                        }
                     });
                     ref.set(subscriber);
                 }
             })
             .test();

             Runnable r1 = new Runnable() {
                 @Override
                 public void run() {
                     ts.cancel();
                 }
             };
             Runnable r2 = new Runnable() {
                 @Override
                 public void run() {
                     Subscriber<Object> subscriber = ref.get();
                     subscriber.onNext(1);
                     subscriber.onComplete();
                 }
             };

             TestHelper.race(r1, r2);
        }
    }",loop_control
i,"{
        final TestException ex = new TestException();

        for (int i = 0; i < TestHelper.RACE_LONG_LOOPS; i++) {
           final AtomicReference<Subscriber<? super Object>> refMain = new AtomicReference<>();
           final AtomicReference<Subscriber<? super Object>> ref = new AtomicReference<>();

           final TestSubscriber<Flowable<Object>> ts = new Flowable<Object>() {
               @Override
               protected void subscribeActual(Subscriber<? super Object> subscriber) {
                   subscriber.onSubscribe(new BooleanSubscription());
                   refMain.set(subscriber);
               }
           }
           .window(new Flowable<Object>() {
               @Override
               protected void subscribeActual(Subscriber<? super Object> subscriber) {
                   final AtomicInteger counter = new AtomicInteger();
                   subscriber.onSubscribe(new Subscription() {

                       @Override
                       public void cancel() {
                           // about a microsecond
                           for (int i = 0; i < 100; i++) {
                               counter.incrementAndGet();
                           }
                       }

                       @Override
                      public void request(long n) {
                      }
                   });
                   ref.set(subscriber);
               }
           })
           .test();

            Runnable r1 = new Runnable() {
                @Override
                public void run() {
                    ts.cancel();
                }
            };
            Runnable r2 = new Runnable() {
                @Override
                public void run() {
                    Subscriber<Object> subscriber = ref.get();
                    subscriber.onNext(1);
                    subscriber.onError(ex);
                }
            };

            TestHelper.race(r1, r2);
        }
    }",loop_control
i,"{
        for (String val : new String[] { ""1"" /*, null*/ }) {
            int n = 35;
            for (int i = 0; i < n; i++) {
                List<Flowable<?>> sources = new ArrayList<>();
                List<String> expected = new ArrayList<>();
                expected.add(val);

                for (int j = 0; j < i; j++) {
                    sources.add(Flowable.just(val));
                    expected.add(String.valueOf(val));
                }

                TestSubscriber<String> ts = new TestSubscriber<>();

                PublishProcessor<String> main = PublishProcessor.create();

                main.withLatestFrom(sources, toArray).subscribe(ts);

                ts.assertNoValues();

                main.onNext(val);
                main.onComplete();

                ts.assertValue(expected.toString());
                ts.assertNoErrors();
                ts.assertComplete();
            }
        }
    }",loop_control
j,"{
        for (String val : new String[] { ""1"" /*, null*/ }) {
            int n = 35;
            for (int i = 0; i < n; i++) {
                List<Flowable<?>> sources = new ArrayList<>();
                List<String> expected = new ArrayList<>();
                expected.add(val);

                for (int j = 0; j < i; j++) {
                    sources.add(Flowable.just(val));
                    expected.add(String.valueOf(val));
                }

                TestSubscriber<String> ts = new TestSubscriber<>();

                PublishProcessor<String> main = PublishProcessor.create();

                main.withLatestFrom(sources, toArray).subscribe(ts);

                ts.assertNoValues();

                main.onNext(val);
                main.onComplete();

                ts.assertValue(expected.toString());
                ts.assertNoErrors();
                ts.assertComplete();
            }
        }
    }",loop_control
i,"{
        for (int i = 0; i < TestHelper.RACE_DEFAULT_LOOPS; i++) {
            final PublishProcessor<Integer> pp0 = PublishProcessor.create();
            final PublishProcessor<Integer> pp1 = PublishProcessor.create();
            final PublishProcessor<Integer> pp2 = PublishProcessor.create();
            final PublishProcessor<Integer> pp3 = PublishProcessor.create();

            final Flowable<Object> source = pp0.withLatestFrom(pp1, pp2, pp3, new Function4<Object, Integer, Integer, Integer, Object>() {
                @Override
                public Object apply(Object a, Integer b, Integer c, Integer d)
                        throws Exception {
                    return a;
                }
            });

            final TestSubscriber<Object> ts = new TestSubscriber<>();

            Runnable r1 = new Runnable() {
                @Override
                public void run() {
                    source.subscribe(ts);
                }
            };

            Runnable r2 = new Runnable() {
                @Override
                public void run() {
                    ts.cancel();
                }
            };

            TestHelper.race(r1, r2);

            ts.assertEmpty();

            assertFalse(pp0.hasSubscribers());
            assertFalse(pp1.hasSubscribers());
            assertFalse(pp2.hasSubscribers());
            assertFalse(pp3.hasSubscribers());
        }
    }",loop_control
i,"{
        for (int i = 0; i < TestHelper.RACE_DEFAULT_LOOPS; i++) {
            final PublishProcessor<Integer> pp0 = PublishProcessor.create();
            final PublishProcessor<Integer> pp1 = PublishProcessor.create();
            final PublishProcessor<Integer> pp2 = PublishProcessor.create();
            final PublishProcessor<Integer> pp3 = PublishProcessor.create();

            final Flowable<Object> source = pp0.withLatestFrom(pp1, pp2, pp3, new Function4<Object, Integer, Integer, Integer, Object>() {
                @Override
                public Object apply(Object a, Integer b, Integer c, Integer d)
                        throws Exception {
                    return a;
                }
            });

            final TestSubscriber<Object> ts = new TestSubscriber<>();

            Runnable r1 = new Runnable() {
                @Override
                public void run() {
                    source.subscribe(ts);
                }
            };

            Runnable r2 = new Runnable() {
                @Override
                public void run() {
                    pp1.onComplete();
                }
            };

            TestHelper.race(r1, r2);

            ts.assertResult();

            assertFalse(pp0.hasSubscribers());
            assertFalse(pp1.hasSubscribers());
            assertFalse(pp2.hasSubscribers());
            assertFalse(pp3.hasSubscribers());
        }
    }",loop_control
i,"{
        for (int i = 0; i < TestHelper.RACE_DEFAULT_LOOPS; i++) {
            final TestScheduler sch = new TestScheduler();

            final PublishProcessor<Integer> pp = PublishProcessor.create();

            TestSubscriberEx<Integer> ts = pp.timeout(1, TimeUnit.SECONDS, sch).to(TestHelper.<Integer>testConsumer());

            Runnable r1 = new Runnable() {
                @Override
                public void run() {
                    pp.onNext(1);
                }
            };

            Runnable r2 = new Runnable() {
                @Override
                public void run() {
                    sch.advanceTimeBy(1, TimeUnit.SECONDS);
                }
            };

            TestHelper.race(r1, r2);

            if (ts.values().size() != 0) {
                if (ts.errors().size() != 0) {
                    ts.assertFailure(TimeoutException.class, 1);
                    ts.assertErrorMessage(timeoutMessage(1, TimeUnit.SECONDS));
                } else {
                    ts.assertValuesOnly(1);
                }
            } else {
                ts.assertFailure(TimeoutException.class);
                ts.assertErrorMessage(timeoutMessage(1, TimeUnit.SECONDS));
            }
        }
    }",loop_control
i,"{
        for (int i = 0; i < TestHelper.RACE_DEFAULT_LOOPS; i++) {
            final TestScheduler sch = new TestScheduler();

            final PublishProcessor<Integer> pp = PublishProcessor.create();

            TestSubscriberEx<Integer> ts = pp.timeout(1, TimeUnit.SECONDS, sch, Flowable.just(2)).to(TestHelper.<Integer>testConsumer());

            Runnable r1 = new Runnable() {
                @Override
                public void run() {
                    pp.onNext(1);
                }
            };

            Runnable r2 = new Runnable() {
                @Override
                public void run() {
                    sch.advanceTimeBy(1, TimeUnit.SECONDS);
                }
            };

            TestHelper.race(r1, r2);

            if (ts.isTerminated()) {
                int c = ts.values().size();
                if (c == 1) {
                    int v = ts.values().get(0);
                    assertTrue("""" + v, v == 1 || v == 2);
                } else {
                    ts.assertResult(1, 2);
                }
            } else {
                ts.assertValuesOnly(1);
            }
        }
    }",loop_control
bs,"{

        @Override
        public void subscribe(Subscriber<? super Long> s) {
            BooleanSubscription bs = new BooleanSubscription();
            s.onSubscribe(bs);
            long i = 0;
            while (!bs.isCancelled()) {
                s.onNext(i++);
            }
        }

    }",maybe_loop_control
j,"{
        for (int j = 0; j < TestHelper.RACE_LONG_LOOPS; j++) {
            List<Throwable> errors = TestHelper.trackPluginErrors();
            try {
                final PublishProcessor<Integer> pp = PublishProcessor.create();

                TestObserver<Integer> to = pp.onBackpressureBuffer(4, false, true)
                .observeOn(Schedulers.io())
                .map(Functions.<Integer>identity())
                .observeOn(Schedulers.single())
                .firstOrError()
                .test();

                for (int i = 0; pp.hasSubscribers(); i++) {
                    pp.onNext(i);
                }

                to
                .awaitDone(5, TimeUnit.SECONDS)
                ;

                if (!errors.isEmpty()) {
                    throw new CompositeException(errors);
                }

                to.assertResult(0);
            } finally {
                RxJavaPlugins.reset();
            }
        }
    }",loop_control
i,"{
        for (int j = 0; j < TestHelper.RACE_LONG_LOOPS; j++) {
            List<Throwable> errors = TestHelper.trackPluginErrors();
            try {
                final PublishProcessor<Integer> pp = PublishProcessor.create();

                TestObserver<Integer> to = pp.onBackpressureBuffer(4, false, true)
                .observeOn(Schedulers.io())
                .map(Functions.<Integer>identity())
                .observeOn(Schedulers.single())
                .firstOrError()
                .test();

                for (int i = 0; pp.hasSubscribers(); i++) {
                    pp.onNext(i);
                }

                to
                .awaitDone(5, TimeUnit.SECONDS)
                ;

                if (!errors.isEmpty()) {
                    throw new CompositeException(errors);
                }

                to.assertResult(0);
            } finally {
                RxJavaPlugins.reset();
            }
        }
    }",loop_control
i,"{

        final AtomicInteger eventCounter = new AtomicInteger();
        final AtomicInteger subscribeCounter = new AtomicInteger();
        final AtomicInteger groupCounter = new AtomicInteger();
        final CountDownLatch latch = new CountDownLatch(1);
        final int count = 100;
        final int groupCount = 2;

        Flowable<Event> es = Flowable.unsafeCreate(new Publisher<Event>() {

            @Override
            public void subscribe(final Subscriber<? super Event> subscriber) {
                subscriber.onSubscribe(new BooleanSubscription());
                System.out.println(""*** Subscribing to EventStream ***"");
                subscribeCounter.incrementAndGet();
                new Thread(new Runnable() {

                    @Override
                    public void run() {
                        for (int i = 0; i < count; i++) {
                            Event e = new Event();
                            e.source = i % groupCount;
                            e.message = ""Event-"" + i;
                            subscriber.onNext(e);
                        }
                        subscriber.onComplete();
                    }

                }).start();
            }

        });

        es.groupBy(new Function<Event, Integer>() {

            @Override
            public Integer apply(Event e) {
                return e.source;
            }
        }).flatMap(new Function<GroupedFlowable<Integer, Event>, Flowable<String>>() {

            @Override
            public Flowable<String> apply(GroupedFlowable<Integer, Event> eventGroupedFlowable) {
                System.out.println(""GroupedFlowable Key: "" + eventGroupedFlowable.getKey());
                groupCounter.incrementAndGet();

                return eventGroupedFlowable.map(new Function<Event, String>() {

                    @Override
                    public String apply(Event event) {
                        return ""Source: "" + event.source + ""  Message: "" + event.message;
                    }
                });

            }
        }).subscribe(new DefaultSubscriber<String>() {

            @Override
            public void onComplete() {
                latch.countDown();
            }

            @Override
            public void onError(Throwable e) {
                e.printStackTrace();
                latch.countDown();
            }

            @Override
            public void onNext(String outputMessage) {
                System.out.println(outputMessage);
                eventCounter.incrementAndGet();
            }
        });

        latch.await(5000, TimeUnit.MILLISECONDS);
        assertEquals(1, subscribeCounter.get());
        assertEquals(groupCount, groupCounter.get());
        assertEquals(count, eventCounter.get());

    }",loop_control
bs,"{
        return Flowable.unsafeCreate(new Publisher<Event>() {

            @Override
            public void subscribe(final Subscriber<? super Event> op) {
                BooleanSubscription bs = new BooleanSubscription();
                op.onSubscribe(bs);
                subscribeCounter.incrementAndGet();
                int i = 0;
                while (!bs.isCancelled()) {
                    i++;
                    Event e = new Event();
                    e.source = i % numGroups;
                    e.message = ""Event-"" + i;
                    op.onNext(e);
                    sentEventCounter.incrementAndGet();
                }
                op.onComplete();
            }

        });
    }",maybe_loop_control
j,"{
        int n = 500;
        for (int j = 0; j < 1000; j++) {
            Flowable.merge(
                    Flowable.range(0, n)
                    .groupBy(new Function<Integer, Object>() {
                        @Override
                        public Object apply(Integer i) {
                            return i % (Flowable.bufferSize() + 2);
                        }
                    })
                    .observeOn(Schedulers.computation(), false, n)
            , n)
            .blockingLast();
        }
    }",loop_control
j,"{
        for (int j = 0; j < 1000; j++) {
            Flowable.merge(
                    Flowable.range(0, 500)
                    .groupBy(new Function<Integer, Object>() {
                        @Override
                        public Object apply(Integer i) {
                            return i % (Flowable.bufferSize() + 2);
                        }
                    })
                    .observeOn(Schedulers.computation())
            ).blockingLast();
        }
    }",loop_control
i,"{
        for (int i = 0; i < TestHelper.RACE_LONG_LOOPS; i++) {

            final TestSubscriber<Integer> ts = new TestSubscriber<>();

            final PublishProcessor<Integer> pp = PublishProcessor.create();

            pp.groupBy(new Function<Integer, Integer>() {
                @Override
                public Integer apply(Integer v) throws Throwable {
                    return v % 10;
                }
            }, Functions.<Integer>identity(), false, 2048)
            .flatMap(new Function<GroupedFlowable<Integer, Integer>, GroupedFlowable<Integer, Integer>>() {
                @Override
                public GroupedFlowable<Integer, Integer> apply(GroupedFlowable<Integer, Integer> v)
                        throws Throwable {
                    return v;
                }
            })
            .subscribe(ts);

            Runnable r1 = new Runnable() {
                @Override
                public void run() {
                    for (int j = 0; j < 1000; j++) {
                        pp.onNext(j);
                    }
                }
            };

            Runnable r2 = new Runnable() {
                @Override
                public void run() {
                    ts.cancel();
                }
            };

            TestHelper.race(r1, r2);

            assertFalse(""Round "" + i, pp.hasSubscribers());
        }
    }",loop_control
j,"{
        for (int i = 0; i < TestHelper.RACE_LONG_LOOPS; i++) {

            final TestSubscriber<Integer> ts = new TestSubscriber<>();

            final PublishProcessor<Integer> pp = PublishProcessor.create();

            pp.groupBy(new Function<Integer, Integer>() {
                @Override
                public Integer apply(Integer v) throws Throwable {
                    return v % 10;
                }
            }, Functions.<Integer>identity(), false, 2048)
            .flatMap(new Function<GroupedFlowable<Integer, Integer>, GroupedFlowable<Integer, Integer>>() {
                @Override
                public GroupedFlowable<Integer, Integer> apply(GroupedFlowable<Integer, Integer> v)
                        throws Throwable {
                    return v;
                }
            })
            .subscribe(ts);

            Runnable r1 = new Runnable() {
                @Override
                public void run() {
                    for (int j = 0; j < 1000; j++) {
                        pp.onNext(j);
                    }
                }
            };

            Runnable r2 = new Runnable() {
                @Override
                public void run() {
                    ts.cancel();
                }
            };

            TestHelper.race(r1, r2);

            assertFalse(""Round "" + i, pp.hasSubscribers());
        }
    }",loop_control
done,"{
        final List<TestSubscriber<Integer>> tss = new ArrayList<>();
        final AtomicInteger counter = new AtomicInteger();
        final AtomicBoolean done = new AtomicBoolean();
        Flowable.range(1, 1000)
                .doOnNext(new Consumer<Integer>() {
                    @Override
                    public void accept(Integer v) throws Exception {
                        counter.getAndIncrement();
                    }
                })
                .groupBy(Functions.justFunction(1))
                .subscribe(new Consumer<GroupedFlowable<Integer, Integer>>() {
                    @Override
                    public void accept(GroupedFlowable<Integer, Integer> v) throws Exception {
                        TestSubscriber<Integer> ts = TestSubscriber.create(0L);
                        tss.add(ts);
                        v.subscribe(ts);
                    }
                }, Functions.emptyConsumer(), new Action() {
                    @Override
                    public void run() throws Exception {
                        done.set(true);
                    }
                });

        while (!done.get()) {
            tss.remove(0).cancel();
        }

        assertEquals(1000, counter.get());
    }",maybe_loop_control
i,"{
        for (int i = 0; i < TestHelper.RACE_DEFAULT_LOOPS; i++) {
            PublishProcessor<Integer> pp = PublishProcessor.create();

            TestSubscriber<Integer> ts = TestSubscriber.create();

            CountDownLatch cdl = new CountDownLatch(1);

            pp.groupBy(v -> 1)
            .doOnNext(g -> {
                TestHelper.raceOther(() -> {
                    g.subscribe(ts);
                }, cdl);
            })
            .test();

            pp.onNext(1);

            cdl.await();

            ts.assertValueCount(1);
        }
    }",loop_control
i,"{
        for (int i = 0; i < 1000; i++) {
            issue6974Part2Case2();
        }
    }",loop_control
i,"{
        for (int i = 0; i < 1000; i++) {
            issue6974Part2Case1NoEvict();
        }
    }",loop_control
i,"{
        for (int i = 0; i < 100; i++) {
            issue6974Part2Case1ObserveOnNoCapHide();
        }
    }",loop_control
i,"{
        for (int i = 0; i < 100; i++) {
            issue6974Part2Case1ObserveOnHide();
        }
    }",loop_control
i,"{
        for (int i = 0; i < 200; i++) {
            System.out.println(""issue6982Case1Loop ""  + i);
            issue6982Case1();
        }
    }",loop_control
i,"{
        for (int i = 0; i < 200; i++) {
            System.out.println(""issue6982Case2Loop ""  + i);
            issue6982Case2();
        }
    }",loop_control
bs,"{
        @Override
        public void subscribe(Subscriber<? super Long> s) {
            BooleanSubscription bs = new BooleanSubscription();
            s.onSubscribe(bs);
            long i = 0;
            while (!bs.isCancelled() && i < 500) {
                s.onNext(i++);
            }
            if (!bs.isCancelled()) {
                s.onComplete();
            }
        }
    }",maybe_loop_control
i,"{
        @Override
        public void subscribe(Subscriber<? super Long> s) {
            BooleanSubscription bs = new BooleanSubscription();
            s.onSubscribe(bs);
            long i = 0;
            while (!bs.isCancelled() && i < 500) {
                s.onNext(i++);
            }
            if (!bs.isCancelled()) {
                s.onComplete();
            }
        }
    }",loop_control
t,"{
        stringSubscriber = TestHelper.mockSubscriber();

        for (Thread t : Thread.getAllStackTraces().keySet()) {
            if (t.getName().startsWith(""RxNewThread"")) {
                count++;
            }
        }
    }",iterator
t,"{
        try {
            Thread.sleep(100);
        } catch (InterruptedException e) {
            // TODO Auto-generated catch block
            e.printStackTrace();
        }
        for (Thread t : Thread.getAllStackTraces().keySet()) {
            if (t.getName().startsWith(""RxNewThread"")) {
                --count;
            }
        }
        if (count != 0) {
            throw new IllegalStateException(""NewThread leak!"");
        }
    }",iterator
unsubscribed,"{

        final AtomicBoolean unsubscribed = new AtomicBoolean();
        final CountDownLatch latch = new CountDownLatch(1);

        Flowable<Flowable<Long>> source = Flowable.unsafeCreate(new Publisher<Flowable<Long>>() {

            @Override
            public void subscribe(final Subscriber<? super Flowable<Long>> subscriber) {
                // verbose on purpose so I can track the inside of it
                final Subscription s = new Subscription() {

                    @Override
                    public void request(long n) {

                    }

                    @Override
                    public void cancel() {
                        System.out.println(""*** unsubscribed"");
                        unsubscribed.set(true);
                    }

                };
                subscriber.onSubscribe(s);

                new Thread(new Runnable() {

                    @Override
                    public void run() {

                        while (!unsubscribed.get()) {
                            subscriber.onNext(Flowable.just(1L, 2L));
                        }
                        System.out.println(""Done looping after unsubscribe: "" + unsubscribed.get());
                        subscriber.onComplete();

                        // mark that the thread is finished
                        latch.countDown();
                    }
                }).start();
            }

        });

        final AtomicInteger count = new AtomicInteger();
        Flowable.merge(source).take(6).blockingForEach(new Consumer<Long>() {

            @Override
            public void accept(Long v) {
                System.out.println(""Value: "" + v);
                int c = count.incrementAndGet();
                if (c > 6) {
                    fail(""Should be only 6"");
                }

            }
        });

        latch.await(1000, TimeUnit.MILLISECONDS);

        System.out.println(""unsubscribed: "" + unsubscribed.get());

        assertTrue(unsubscribed.get());

    }",maybe_loop_control
i,"{
        for (int i = 0; i < 100; i++) {
            System.out.println(""testSynchronizationOfMultipleSequencesLoop > "" + i);
            synchronizationOfMultipleSequences();
        }
    }",loop_control
timeout,"{
        final TestASynchronousFlowable f1 = new TestASynchronousFlowable();
        final TestASynchronousFlowable f2 = new TestASynchronousFlowable();

        // use this latch to cause onNext to wait until we're ready to let it go
        final CountDownLatch endLatch = new CountDownLatch(1);

        final AtomicInteger concurrentCounter = new AtomicInteger();
        final AtomicInteger totalCounter = new AtomicInteger();

        final AtomicReference<Throwable> error = new AtomicReference<>();

        Flowable<String> m = Flowable.merge(Flowable.unsafeCreate(f1), Flowable.unsafeCreate(f2));
        m.subscribe(new DefaultSubscriber<String>() {

            @Override
            public void onComplete() {

            }

            @Override
            public void onError(Throwable e) {
                error.set(e);
            }

            @Override
            public void onNext(String v) {
                totalCounter.incrementAndGet();
                concurrentCounter.incrementAndGet();
                try {
                    // avoid deadlocking the main thread
                    if (Thread.currentThread().getName().equals(""TestASynchronousFlowable"")) {
                        // wait here until we're done asserting
                        endLatch.await();
                    }
                } catch (InterruptedException e) {
                    e.printStackTrace();
                    throw new RuntimeException(""failed"", e);
                } finally {
                    concurrentCounter.decrementAndGet();
                }
            }

        });

        // wait for both Flowables to send (one should be blocked)
        f1.onNextBeingSent.await();
        f2.onNextBeingSent.await();

        // I can't think of a way to know for sure that both threads have or are trying to send onNext
        // since I can't use a CountDownLatch for ""after"" onNext since I want to catch during it
        // but I can't know for sure onNext is invoked
        // so I'm unfortunately reverting to using a Thread.sleep to allow the process scheduler time
        // to make sure after o1.onNextBeingSent and o2.onNextBeingSent are hit that the following
        // onNext is invoked.

        int timeout = 20;

        while (timeout-- > 0 && concurrentCounter.get() != 1) {
            Thread.sleep(100);
        }

        try { // in try/finally so threads are released via latch countDown even if assertion fails
            if (error.get() != null) {
                throw ExceptionHelper.wrapOrThrow(error.get());
            }

            assertEquals(1, concurrentCounter.get());
        } finally {
            // release so it can finish
            endLatch.countDown();
        }

        try {
            f1.t.join();
            f2.t.join();
        } catch (InterruptedException e) {
            throw new RuntimeException(e);
        }

        assertEquals(2, totalCounter.get());
        assertEquals(0, concurrentCounter.get());
    }",loop_control
concurrentCounter,"{
        final TestASynchronousFlowable f1 = new TestASynchronousFlowable();
        final TestASynchronousFlowable f2 = new TestASynchronousFlowable();

        // use this latch to cause onNext to wait until we're ready to let it go
        final CountDownLatch endLatch = new CountDownLatch(1);

        final AtomicInteger concurrentCounter = new AtomicInteger();
        final AtomicInteger totalCounter = new AtomicInteger();

        final AtomicReference<Throwable> error = new AtomicReference<>();

        Flowable<String> m = Flowable.merge(Flowable.unsafeCreate(f1), Flowable.unsafeCreate(f2));
        m.subscribe(new DefaultSubscriber<String>() {

            @Override
            public void onComplete() {

            }

            @Override
            public void onError(Throwable e) {
                error.set(e);
            }

            @Override
            public void onNext(String v) {
                totalCounter.incrementAndGet();
                concurrentCounter.incrementAndGet();
                try {
                    // avoid deadlocking the main thread
                    if (Thread.currentThread().getName().equals(""TestASynchronousFlowable"")) {
                        // wait here until we're done asserting
                        endLatch.await();
                    }
                } catch (InterruptedException e) {
                    e.printStackTrace();
                    throw new RuntimeException(""failed"", e);
                } finally {
                    concurrentCounter.decrementAndGet();
                }
            }

        });

        // wait for both Flowables to send (one should be blocked)
        f1.onNextBeingSent.await();
        f2.onNextBeingSent.await();

        // I can't think of a way to know for sure that both threads have or are trying to send onNext
        // since I can't use a CountDownLatch for ""after"" onNext since I want to catch during it
        // but I can't know for sure onNext is invoked
        // so I'm unfortunately reverting to using a Thread.sleep to allow the process scheduler time
        // to make sure after o1.onNextBeingSent and o2.onNextBeingSent are hit that the following
        // onNext is invoked.

        int timeout = 20;

        while (timeout-- > 0 && concurrentCounter.get() != 1) {
            Thread.sleep(100);
        }

        try { // in try/finally so threads are released via latch countDown even if assertion fails
            if (error.get() != null) {
                throw ExceptionHelper.wrapOrThrow(error.get());
            }

            assertEquals(1, concurrentCounter.get());
        } finally {
            // release so it can finish
            endLatch.countDown();
        }

        try {
            f1.t.join();
            f2.t.join();
        } catch (InterruptedException e) {
            throw new RuntimeException(e);
        }

        assertEquals(2, totalCounter.get());
        assertEquals(0, concurrentCounter.get());
    }",maybe_loop_control
s,"{

        String[] valuesToReturn;

        TestErrorFlowable(String... values) {
            valuesToReturn = values;
        }

        @Override
        public void subscribe(Subscriber<? super String> subscriber) {
            subscriber.onSubscribe(new BooleanSubscription());
            for (String s : valuesToReturn) {
                if (s == null) {
                    System.out.println(""throwing exception"");
                    subscriber.onError(new NullPointerException());
                } else {
                    subscriber.onNext(s);
                }
            }
            subscriber.onComplete();
        }
    }",iterator
i,"{
        for (int i = 0; i < 10; i++) {
            TestScheduler scheduler1 = new TestScheduler();
            AtomicBoolean os1 = new AtomicBoolean(false);
            Flowable<Long> f1 = createFlowableOf5IntervalsOf1SecondIncrementsWithSubscriptionHook(scheduler1, os1);

            TestScheduler scheduler2 = new TestScheduler();
            AtomicBoolean os2 = new AtomicBoolean(false);
            Flowable<Long> f2 = createFlowableOf5IntervalsOf1SecondIncrementsWithSubscriptionHook(scheduler2, os2);

            TestSubscriber<Long> ts = new TestSubscriber<>();
            Flowable.merge(f1, f2).subscribe(ts);

            // we haven't incremented time so nothing should be received yet
            ts.assertNoValues();

            scheduler1.advanceTimeBy(3, TimeUnit.SECONDS);
            scheduler2.advanceTimeBy(2, TimeUnit.SECONDS);

            ts.assertValues(0L, 1L, 2L, 0L, 1L);
            // not unsubscribed yet
            assertFalse(os1.get());
            assertFalse(os2.get());

            // early unsubscribe
            ts.cancel();

            assertTrue(os1.get());
            assertTrue(os2.get());

            ts.assertValues(0L, 1L, 2L, 0L, 1L);
        }
    }",loop_control
i,"{
        Flowable<Integer> f = Flowable.range(1, 10000).subscribeOn(Schedulers.newThread());

        for (int i = 0; i < 10; i++) {
            Flowable<Integer> merge = Flowable.merge(f.onBackpressureBuffer(), f.onBackpressureBuffer(), f.onBackpressureBuffer());
            TestSubscriberEx<Integer> ts = new TestSubscriberEx<>();
            merge.subscribe(ts);

            ts.awaitDone(3, TimeUnit.SECONDS);
            ts.assertTerminated();
            ts.assertNoErrors();
            ts.assertComplete();
            List<Integer> onNextEvents = ts.values();
            assertEquals(30000, onNextEvents.size());
            //            System.out.println(""onNext: "" + onNextEvents.size() + "" onComplete: "" + ts.getOnCompletedEvents().size());
        }
    }",loop_control
i,"{

        Flowable<Integer> f = Flowable.unsafeCreate(new Publisher<Integer>() {

            @Override
            public void subscribe(final Subscriber<? super Integer> s) {
                Worker inner = Schedulers.newThread().createWorker();
                final AsyncSubscription as = new AsyncSubscription();
                as.setSubscription(new BooleanSubscription());
                as.setResource(inner);

                s.onSubscribe(as);

                inner.schedule(new Runnable() {

                    @Override
                    public void run() {
                        try {
                            for (int i = 0; i < 100; i++) {
                                s.onNext(1);
                                try {
                                    Thread.sleep(1);
                                } catch (InterruptedException e) {
                                    e.printStackTrace();
                                }
                            }
                        } catch (Exception e) {
                            s.onError(e);
                        }
                        as.dispose();
                        s.onComplete();
                    }

                });
            }
        });

        for (int i = 0; i < 10; i++) {
            Flowable<Integer> merge = Flowable.merge(f, f, f);
            TestSubscriber<Integer> ts = new TestSubscriber<>();
            merge.subscribe(ts);

            ts.awaitDone(10, TimeUnit.SECONDS);
            ts.assertComplete();
            List<Integer> onNextEvents = ts.values();
            assertEquals(300, onNextEvents.size());
            //            System.out.println(""onNext: "" + onNextEvents.size() + "" onComplete: "" + ts.getOnCompletedEvents().size());
        }
    }",loop_control
i,"{
        Flowable<Integer> f = Flowable.unsafeCreate(new Publisher<Integer>() {

            @Override
            public void subscribe(final Subscriber<? super Integer> s) {
                Worker inner = Schedulers.newThread().createWorker();
                final AsyncSubscription as = new AsyncSubscription();
                as.setSubscription(new BooleanSubscription());
                as.setResource(inner);

                s.onSubscribe(as);

                inner.schedule(new Runnable() {

                    @Override
                    public void run() {
                        try {
                            for (int i = 0; i < 10000; i++) {
                                s.onNext(i);
                            }
                        } catch (Exception e) {
                            s.onError(e);
                        }
                        as.dispose();
                        s.onComplete();
                        s.onComplete();
                        s.onComplete();
                    }

                });
            }
        });

        for (int i = 0; i < 10; i++) {
            Flowable<Integer> merge = Flowable.merge(f.onBackpressureBuffer(), f.onBackpressureBuffer(), f.onBackpressureBuffer());
            TestSubscriber<Integer> ts = new TestSubscriber<>();
            merge.subscribe(ts);

            ts.awaitDone(10, TimeUnit.SECONDS);
            ts.assertNoErrors();
            ts.assertComplete();
            List<Integer> onNextEvents = ts.values();
            assertEquals(30000, onNextEvents.size());
            //                System.out.println(""onNext: "" + onNextEvents.size() + "" onComplete: "" + ts.getOnCompletedEvents().size());
        }
    }",loop_control
i,"{
        for (int i = 0; i < 1000; i++) {
            System.err.flush();
            System.out.println(""---"");
            System.out.flush();
            backpressureUpstream2();
        }
    }",loop_control
i,"{
        //for (int i = 0; i < 5000; i++) {
            //System.out.println(i + ""......................................................................."");
            final CountDownLatch latch = new CountDownLatch(1);
            final ConcurrentLinkedQueue<String> messages = new ConcurrentLinkedQueue<>();

            Flowable.range(1, 2)
                    // produce many integers per second
                    .flatMap(new Function<Integer, Flowable<Integer>>() {
                        @Override
                        public Flowable<Integer> apply(final Integer number) {
                            return Flowable.range(1, Integer.MAX_VALUE)
                                    .doOnRequest(new LongConsumer() {

                                        @Override
                                        public void accept(long n) {
                                            messages.add("">>>>>>>> A requested["" + number + ""]: "" + n);
                                        }

                                    })
                                    // pause a bit
                                    .doOnNext(pauseForMs(3))
                                    // buffer on backpressure
                                    .onBackpressureBuffer()
                                    // do in parallel
                                    .subscribeOn(Schedulers.computation())
                                    .doOnRequest(new LongConsumer() {

                                        @Override
                                        public void accept(long n) {
                                            messages.add("">>>>>>>> B requested["" + number + ""]: "" + n);
                                        }

                                    });
                        }

                    })
                    // take a number bigger than 2* Flowable.bufferSize() (used by OperatorMerge)
                    .take(Flowable.bufferSize() * 2 + 1)
                    // log count
                    .doOnNext(printCount())
                    // release latch
                    .doOnComplete(new Action() {
                        @Override
                        public void run() {
                                latch.countDown();
                        }
                    }).subscribe();
            boolean a = latch.await(10, TimeUnit.SECONDS);
            if (!a) {
                for (String s : messages) {
                    System.out.println(""DEBUG => "" + s);
                }
            }
            assertTrue(a);
        //}
    }",loop_control
s,"{
        //for (int i = 0; i < 5000; i++) {
            //System.out.println(i + ""......................................................................."");
            final CountDownLatch latch = new CountDownLatch(1);
            final ConcurrentLinkedQueue<String> messages = new ConcurrentLinkedQueue<>();

            Flowable.range(1, 2)
                    // produce many integers per second
                    .flatMap(new Function<Integer, Flowable<Integer>>() {
                        @Override
                        public Flowable<Integer> apply(final Integer number) {
                            return Flowable.range(1, Integer.MAX_VALUE)
                                    .doOnRequest(new LongConsumer() {

                                        @Override
                                        public void accept(long n) {
                                            messages.add("">>>>>>>> A requested["" + number + ""]: "" + n);
                                        }

                                    })
                                    // pause a bit
                                    .doOnNext(pauseForMs(3))
                                    // buffer on backpressure
                                    .onBackpressureBuffer()
                                    // do in parallel
                                    .subscribeOn(Schedulers.computation())
                                    .doOnRequest(new LongConsumer() {

                                        @Override
                                        public void accept(long n) {
                                            messages.add("">>>>>>>> B requested["" + number + ""]: "" + n);
                                        }

                                    });
                        }

                    })
                    // take a number bigger than 2* Flowable.bufferSize() (used by OperatorMerge)
                    .take(Flowable.bufferSize() * 2 + 1)
                    // log count
                    .doOnNext(printCount())
                    // release latch
                    .doOnComplete(new Action() {
                        @Override
                        public void run() {
                                latch.countDown();
                        }
                    }).subscribe();
            boolean a = latch.await(10, TimeUnit.SECONDS);
            if (!a) {
                for (String s : messages) {
                    System.out.println(""DEBUG => "" + s);
                }
            }
            assertTrue(a);
        //}
    }",iterator
i,"{
        List<Integer> list = new ArrayList<>();
        for (int i = 0; i < 1000; i++) {
            list.add(i);
        }
        Flowable<Integer> source = Flowable.fromIterable(list);
        source.flatMap(func).subscribe(ts);

        if (ts.values().size() != 1000) {
            System.out.println(ts.values());
        }

        ts.assertTerminated();
        ts.assertNoErrors();
        ts.assertValueSequence(list);
    }",loop_control
req,"{
        for (final int req : new int[] { 16, 32, 64, 128, 256 }) {
            TestSubscriberEx<Integer> ts = new TestSubscriberEx<Integer>(req) {
                int remaining = req;

                @Override
                public void onNext(Integer t) {
                    super.onNext(t);
                    if (--remaining == 0) {
                        remaining = req;
                        request(req);
                    }
                }
            };
            runMerge(toScalar, ts);
        }
    }",iterator
req,"{
        for (final int req : new int[] { 16, 32, 64, 128, 256 }) {
            TestSubscriberEx<Integer> ts = new TestSubscriberEx<Integer>(req) {
                int remaining = req;
                @Override
                public void onNext(Integer t) {
                    super.onNext(t);
                    if (--remaining == 0) {
                        remaining = req;
                        request(req);
                    }
                }
            };
            runMerge(toHiddenScalar, ts);
        }
    }",iterator
i,"{
        for (int i = 1; i < 100; i++) {

            @SuppressWarnings(""unchecked"")
            Flowable<Integer>[] sources = new Flowable[i];
            Arrays.fill(sources, Flowable.just(1));
            Integer[] expected = new Integer[i];
            for (int j = 0; j < i; j++) {
                expected[j] = 1;
            }

            Flowable.mergeArray(sources)
            .test()
            .assertResult(expected);
        }
    }",loop_control
j,"{
        for (int i = 1; i < 100; i++) {

            @SuppressWarnings(""unchecked"")
            Flowable<Integer>[] sources = new Flowable[i];
            Arrays.fill(sources, Flowable.just(1));
            Integer[] expected = new Integer[i];
            for (int j = 0; j < i; j++) {
                expected[j] = 1;
            }

            Flowable.mergeArray(sources)
            .test()
            .assertResult(expected);
        }
    }",loop_control
s,"{

        final Subscription upstream;
        final String[] values;
        Thread t;

        TestFlowable(Subscription s, String... values) {
            this.upstream = s;
            this.values = values;
        }

        @Override
        public void subscribe(final Subscriber<? super String> subscriber) {
            System.out.println(""TestFlowable subscribed to ..."");
            subscriber.onSubscribe(upstream);
            t = new Thread(new Runnable() {

                @Override
                public void run() {
                    try {
                        System.out.println(""running TestFlowable thread"");
                        for (String s : values) {
                            System.out.println(""TestFlowable onNext: "" + s);
                            subscriber.onNext(s);
                        }
                        subscriber.onComplete();
                    } catch (Throwable e) {
                        throw new RuntimeException(e);
                    }
                }

            });
            System.out.println(""starting TestFlowable thread"");
            t.start();
            System.out.println(""done starting TestFlowable thread"");
        }
    }",iterator
i,"{
        final AtomicInteger effectCounter = new AtomicInteger();
        Flowable<Integer> source = Flowable.just(1, 2, 3, 4)
        .doOnNext(new Consumer<Integer>() {
            @Override
            public void accept(Integer v) {
                effectCounter.incrementAndGet();
                System.out.println(""Sideeffect #"" + v);
            }
        });

        Flowable<Integer> result = source.replay(
        new Function<Flowable<Integer>, Flowable<Integer>>() {
            @Override
            public Flowable<Integer> apply(Flowable<Integer> f) {
                return f.take(2);
            }
        });

        for (int i = 1; i < 3; i++) {
            effectCounter.set(0);
            System.out.printf(""- %d -%n"", i);
            result.subscribe(new Consumer<Integer>() {

                @Override
                public void accept(Integer t1) {
                    System.out.println(t1);
                }

            }, new Consumer<Throwable>() {

                @Override
                public void accept(Throwable t1) {
                    t1.printStackTrace();
                }
            },
            new Action() {
                @Override
                public void run() {
                    System.out.println(""Done"");
                }
            });
            assertEquals(2, effectCounter.get());
        }
    }",loop_control
i,"{
        Flowable<Integer> source = Flowable.range(0, 1000).replay().autoConnect();

        TestSubscriberEx<Integer> ts = new TestSubscriberEx<>();

        source.subscribe(ts);

        ts.assertNoErrors();
        ts.assertTerminated();
        List<Integer> onNextEvents = ts.values();
        assertEquals(1000, onNextEvents.size());

        for (int i = 0; i < 1000; i++) {
            assertEquals((Integer)i, onNextEvents.get(i));
        }
    }",loop_control
i,"{
        Flowable<Integer> source = Flowable.range(0, 1000).replay().autoConnect();

        TestSubscriber<Integer> ts = new TestSubscriber<>(0L);
        ts.request(10);

        source.subscribe(ts);

        ts.assertNoErrors();
        ts.assertNotComplete();
        List<Integer> onNextEvents = ts.values();
        assertEquals(10, onNextEvents.size());

        for (int i = 0; i < 10; i++) {
            assertEquals((Integer)i, onNextEvents.get(i));
        }

        ts.cancel();
    }",loop_control
i,"{
        Flowable<Integer> source = Flowable.range(1, 10000);
        for (int i = 0; i < 100; i++) {
            TestSubscriberEx<Integer> ts1 = new TestSubscriberEx<>();

            Flowable<Integer> cached = source.replay().autoConnect();

            cached.observeOn(Schedulers.computation()).subscribe(ts1);

            ts1.awaitDone(2, TimeUnit.SECONDS);
            ts1.assertNoErrors();
            ts1.assertTerminated();
            assertEquals(10000, ts1.values().size());

            TestSubscriberEx<Integer> ts2 = new TestSubscriberEx<>();
            cached.observeOn(Schedulers.computation()).subscribe(ts2);

            ts2.awaitDone(2, TimeUnit.SECONDS);
            ts2.assertNoErrors();
            ts2.assertTerminated();
            assertEquals(10000, ts2.values().size());
        }
    }",loop_control
i,"{
        Flowable<Long> source = Flowable.interval(1, 1, TimeUnit.MILLISECONDS)
                .take(1000)
                .subscribeOn(Schedulers.io());
        Flowable<Long> cached = source.replay().autoConnect();

        Flowable<Long> output = cached.observeOn(Schedulers.computation(), false, 1024);

        List<TestSubscriberEx<Long>> list = new ArrayList<>(100);
        for (int i = 0; i < 100; i++) {
            TestSubscriberEx<Long> ts = new TestSubscriberEx<>();
            list.add(ts);
            output.skip(i * 10).take(10).subscribe(ts);
        }

        List<Long> expected = new ArrayList<>();
        for (int i = 0; i < 10; i++) {
            expected.add((long)(i - 10));
        }
        int j = 0;
        for (TestSubscriberEx<Long> ts : list) {
            ts.awaitDone(3, TimeUnit.SECONDS);
            ts.assertNoErrors();
            ts.assertTerminated();

            for (int i = j * 10; i < j * 10 + 10; i++) {
                expected.set(i - j * 10, (long)i);
            }

            ts.assertValueSequence(expected);

            j++;
        }
    }",loop_control
ts,"{
        Flowable<Long> source = Flowable.interval(1, 1, TimeUnit.MILLISECONDS)
                .take(1000)
                .subscribeOn(Schedulers.io());
        Flowable<Long> cached = source.replay().autoConnect();

        Flowable<Long> output = cached.observeOn(Schedulers.computation(), false, 1024);

        List<TestSubscriberEx<Long>> list = new ArrayList<>(100);
        for (int i = 0; i < 100; i++) {
            TestSubscriberEx<Long> ts = new TestSubscriberEx<>();
            list.add(ts);
            output.skip(i * 10).take(10).subscribe(ts);
        }

        List<Long> expected = new ArrayList<>();
        for (int i = 0; i < 10; i++) {
            expected.add((long)(i - 10));
        }
        int j = 0;
        for (TestSubscriberEx<Long> ts : list) {
            ts.awaitDone(3, TimeUnit.SECONDS);
            ts.assertNoErrors();
            ts.assertTerminated();

            for (int i = j * 10; i < j * 10 + 10; i++) {
                expected.set(i - j * 10, (long)i);
            }

            ts.assertValueSequence(expected);

            j++;
        }
    }",iterator
j,"{
        Flowable<Long> source = Flowable.interval(1, 1, TimeUnit.MILLISECONDS)
                .take(1000)
                .subscribeOn(Schedulers.io());
        Flowable<Long> cached = source.replay().autoConnect();

        Flowable<Long> output = cached.observeOn(Schedulers.computation(), false, 1024);

        List<TestSubscriberEx<Long>> list = new ArrayList<>(100);
        for (int i = 0; i < 100; i++) {
            TestSubscriberEx<Long> ts = new TestSubscriberEx<>();
            list.add(ts);
            output.skip(i * 10).take(10).subscribe(ts);
        }

        List<Long> expected = new ArrayList<>();
        for (int i = 0; i < 10; i++) {
            expected.add((long)(i - 10));
        }
        int j = 0;
        for (TestSubscriberEx<Long> ts : list) {
            ts.awaitDone(3, TimeUnit.SECONDS);
            ts.assertNoErrors();
            ts.assertTerminated();

            for (int i = j * 10; i < j * 10 + 10; i++) {
                expected.set(i - j * 10, (long)i);
            }

            ts.assertValueSequence(expected);

            j++;
        }
    }",maybe_loop_control
i,"{
        final int m = 4 * 1000 * 1000;
        Flowable<Integer> firehose = Flowable.unsafeCreate(new Publisher<Integer>() {
            @Override
            public void subscribe(Subscriber<? super Integer> t) {
                t.onSubscribe(new BooleanSubscription());
                for (int i = 0; i < m; i++) {
                    t.onNext(i);
                }
                t.onComplete();
            }
        });

        TestSubscriberEx<Integer> ts = new TestSubscriberEx<>();
        firehose.replay().autoConnect().observeOn(Schedulers.computation()).takeLast(100).subscribe(ts);

        ts.awaitDone(3, TimeUnit.SECONDS);
        ts.assertNoErrors();
        ts.assertTerminated();

        assertEquals(100, ts.values().size());
    }",loop_control
i,"{
        for (int i = 0; i < TestHelper.RACE_DEFAULT_LOOPS; i++) {
            final ConnectableFlowable<Integer> cf = Flowable.range(1, 3).replay();

            Runnable r = new Runnable() {
                @Override
                public void run() {
                    cf.connect();
                }
            };

            TestHelper.race(r, r);
        }
    }",loop_control
i,"{
        for (int i = 0; i < TestHelper.RACE_DEFAULT_LOOPS; i++) {
            final ConnectableFlowable<Integer> cf = Flowable.range(1, 3).replay();

            final TestSubscriber<Integer> ts1 = new TestSubscriber<>();
            final TestSubscriber<Integer> ts2 = new TestSubscriber<>();

            Runnable r1 = new Runnable() {
                @Override
                public void run() {
                    cf.subscribe(ts1);
                }
            };

            Runnable r2 = new Runnable() {
                @Override
                public void run() {
                    cf.subscribe(ts2);
                }
            };

            TestHelper.race(r1, r2);
        }
    }",loop_control
i,"{
        for (int i = 0; i < TestHelper.RACE_DEFAULT_LOOPS; i++) {
            final ConnectableFlowable<Integer> cf = Flowable.range(1, 3).replay();

            final TestSubscriber<Integer> ts1 = new TestSubscriber<>();
            final TestSubscriber<Integer> ts2 = new TestSubscriber<>();

            cf.subscribe(ts1);

            Runnable r1 = new Runnable() {
                @Override
                public void run() {
                    ts1.cancel();
                }
            };

            Runnable r2 = new Runnable() {
                @Override
                public void run() {
                    cf.subscribe(ts2);
                }
            };

            TestHelper.race(r1, r2);
        }
    }",loop_control
i,"{
        for (int i = 0; i < TestHelper.RACE_DEFAULT_LOOPS; i++) {
            final PublishProcessor<Integer> pp = PublishProcessor.create();

            final ConnectableFlowable<Integer> cf = pp.replay();

            final TestSubscriber<Integer> ts1 = new TestSubscriber<>();

            Runnable r1 = new Runnable() {
                @Override
                public void run() {
                    cf.subscribe(ts1);
                }
            };

            Runnable r2 = new Runnable() {
                @Override
                public void run() {
                    for (int j = 0; j < 1000; j++) {
                        pp.onNext(j);
                    }
                }
            };

            TestHelper.race(r1, r2);
        }
    }",loop_control
j,"{
        for (int i = 0; i < TestHelper.RACE_DEFAULT_LOOPS; i++) {
            final PublishProcessor<Integer> pp = PublishProcessor.create();

            final ConnectableFlowable<Integer> cf = pp.replay();

            final TestSubscriber<Integer> ts1 = new TestSubscriber<>();

            Runnable r1 = new Runnable() {
                @Override
                public void run() {
                    cf.subscribe(ts1);
                }
            };

            Runnable r2 = new Runnable() {
                @Override
                public void run() {
                    for (int j = 0; j < 1000; j++) {
                        pp.onNext(j);
                    }
                }
            };

            TestHelper.race(r1, r2);
        }
    }",loop_control
i,"{
        for (int i = 0; i < TestHelper.RACE_DEFAULT_LOOPS; i++) {
            final PublishProcessor<Integer> pp = PublishProcessor.create();

            final ConnectableFlowable<Integer> cf = pp.replay();

            final TestSubscriber<Integer> ts1 = new TestSubscriber<>();

            cf.subscribe(ts1);

            Runnable r1 = new Runnable() {
                @Override
                public void run() {
                    ts1.cancel();
                }
            };

            Runnable r2 = new Runnable() {
                @Override
                public void run() {
                    for (int j = 0; j < 1000; j++) {
                        pp.onNext(j);
                    }
                }
            };

            TestHelper.race(r1, r2);
        }
    }",loop_control
j,"{
        for (int i = 0; i < TestHelper.RACE_DEFAULT_LOOPS; i++) {
            final PublishProcessor<Integer> pp = PublishProcessor.create();

            final ConnectableFlowable<Integer> cf = pp.replay();

            final TestSubscriber<Integer> ts1 = new TestSubscriber<>();

            cf.subscribe(ts1);

            Runnable r1 = new Runnable() {
                @Override
                public void run() {
                    ts1.cancel();
                }
            };

            Runnable r2 = new Runnable() {
                @Override
                public void run() {
                    for (int j = 0; j < 1000; j++) {
                        pp.onNext(j);
                    }
                }
            };

            TestHelper.race(r1, r2);
        }
    }",loop_control
i,"{
        for (int i = 0; i < TestHelper.RACE_DEFAULT_LOOPS; i++) {
            final ConnectableFlowable<Integer> cf = Flowable.range(1, 1000).replay();

            final TestSubscriber<Integer> ts1 = new TestSubscriber<>();

            cf.connect();

            Runnable r1 = new Runnable() {
                @Override
                public void run() {
                    cf.subscribe(ts1);
                }
            };

            Runnable r2 = new Runnable() {
                @Override
                public void run() {
                    ts1.cancel();
                }
            };

            TestHelper.race(r1, r2);
        }
    }",loop_control
i,"{
        TestScheduler scheduler = new TestScheduler();
        for (int i = 0; i < TestHelper.RACE_DEFAULT_LOOPS; i++) {
            final PublishProcessor<Integer> pp = PublishProcessor.create();

            final TestSubscriber<Integer> ts = pp.skipLast(1, TimeUnit.DAYS, scheduler).test();

            Runnable r1 = new Runnable() {
                @Override
                public void run() {
                    pp.onComplete();
                }
            };

            Runnable r2 = new Runnable() {
                @Override
                public void run() {
                    ts.cancel();
                }
            };

            TestHelper.race(r1, r2);
        }
    }",loop_control
i,"{
        final TestException ex = new TestException();
        RxJavaPlugins.setErrorHandler(Functions.emptyConsumer());
        try {
            for (int i = 0; i < TestHelper.RACE_DEFAULT_LOOPS; i++) {
                final PublishProcessor<Integer> pp = PublishProcessor.create();

                final TestSubscriber<Integer> ts = pp.retry(Functions.alwaysTrue()).test();

                Runnable r1 = new Runnable() {
                    @Override
                    public void run() {
                        pp.onError(ex);
                    }
                };

                Runnable r2 = new Runnable() {
                    @Override
                    public void run() {
                        ts.cancel();
                    }
                };

                TestHelper.race(r1, r2);

                ts.assertEmpty();
            }
        } finally {
            RxJavaPlugins.reset();
        }
    }",loop_control
i,"{
        RxJavaPlugins.setErrorHandler(Functions.emptyConsumer());
        try {
            for (int i = 0; i < TestHelper.RACE_DEFAULT_LOOPS; i++) {
                final PublishProcessor<Integer> pp = PublishProcessor.create();

                final TestSubscriber<Integer> ts = pp.retry(new BiPredicate<Object, Object>() {
                    @Override
                    public boolean test(Object t1, Object t2) throws Exception {
                        return true;
                    }
                }).test();

                final TestException ex = new TestException();

                Runnable r1 = new Runnable() {
                    @Override
                    public void run() {
                        pp.onError(ex);
                    }
                };

                Runnable r2 = new Runnable() {
                    @Override
                    public void run() {
                        ts.cancel();
                    }
                };

                TestHelper.race(r1, r2);

                ts.assertEmpty();
            }
        } finally {
            RxJavaPlugins.reset();
        }
    }",loop_control
it,"{
        FlowableProcessor<String> s = PublishProcessor.create();

        Iterator<String> it = s.blockingMostRecent(""default"").iterator();

        assertTrue(it.hasNext());
        assertEquals(""default"", it.next());
        assertEquals(""default"", it.next());

        s.onNext(""one"");
        assertTrue(it.hasNext());
        assertEquals(""one"", it.next());
        assertEquals(""one"", it.next());

        s.onNext(""two"");
        assertTrue(it.hasNext());
        assertEquals(""two"", it.next());
        assertEquals(""two"", it.next());

        s.onComplete();
        assertFalse(it.hasNext());

    }",iterator
it,"{
        FlowableProcessor<String> s = PublishProcessor.create();

        Iterator<String> it = s.blockingMostRecent(""default"").iterator();

        assertTrue(it.hasNext());
        assertEquals(""default"", it.next());
        assertEquals(""default"", it.next());

        s.onError(new TestException());
        assertTrue(it.hasNext());

        it.next();
    }",iterator
j,"{
        TestScheduler scheduler = new TestScheduler();
        Flowable<Long> source = Flowable.interval(1, TimeUnit.SECONDS, scheduler).take(10);

        Iterable<Long> iter = source.blockingMostRecent(-1L);

        for (int j = 0; j < 3; j++) {
            Iterator<Long> it = iter.iterator();

            Assert.assertEquals(Long.valueOf(-1), it.next());

            for (int i = 0; i < 9; i++) {
                scheduler.advanceTimeBy(1, TimeUnit.SECONDS);

                Assert.assertTrue(it.hasNext());
                Assert.assertEquals(Long.valueOf(i), it.next());
            }
            scheduler.advanceTimeBy(1, TimeUnit.SECONDS);

            Assert.assertFalse(it.hasNext());
        }

    }",loop_control
i,"{
        TestScheduler scheduler = new TestScheduler();
        Flowable<Long> source = Flowable.interval(1, TimeUnit.SECONDS, scheduler).take(10);

        Iterable<Long> iter = source.blockingMostRecent(-1L);

        for (int j = 0; j < 3; j++) {
            Iterator<Long> it = iter.iterator();

            Assert.assertEquals(Long.valueOf(-1), it.next());

            for (int i = 0; i < 9; i++) {
                scheduler.advanceTimeBy(1, TimeUnit.SECONDS);

                Assert.assertTrue(it.hasNext());
                Assert.assertEquals(Long.valueOf(i), it.next());
            }
            scheduler.advanceTimeBy(1, TimeUnit.SECONDS);

            Assert.assertFalse(it.hasNext());
        }

    }",loop_control
i,"{
        for (int i = 0; i < TestHelper.RACE_DEFAULT_LOOPS; i++) {
            final PublishProcessor<Integer> pp = PublishProcessor.create();

            final TestSubscriber<Integer> ts = pp.takeLast(1, TimeUnit.DAYS).test();

            Runnable r1 = new Runnable() {
                @Override
                public void run() {
                    pp.onComplete();
                }
            };

            Runnable r2 = new Runnable() {
                @Override
                public void run() {
                    ts.cancel();
                }
            };

            TestHelper.race(r1, r2);
        }
    }",loop_control
i,"{
        final AtomicLong counter = new AtomicLong();
        final Integer[] numbers = new Integer[5000];
        for (int i = 0; i < numbers.length; i++) {
            numbers[i] = i + 1;
        }
        final int NITERS = 250;
        final CountDownLatch latch = new CountDownLatch(NITERS);
        for (int iters = 0; iters < NITERS; iters++) {
            final CountDownLatch innerLatch = new CountDownLatch(1);
            final PublishProcessor<Void> s = PublishProcessor.create();
            final AtomicBoolean completed = new AtomicBoolean();
            Flowable.fromArray(numbers)
                    .takeUntil(s)
                    .window(50)
                    .flatMap(new Function<Flowable<Integer>, Publisher<Object>>() {
                        @Override
                        public Publisher<Object> apply(Flowable<Integer> integerObservable) {
                                return integerObservable
                                        .subscribeOn(Schedulers.computation())
                                        .map(new Function<Integer, Object>() {
                                            @Override
                                            public Object apply(Integer integer) {
                                                    if (integer >= 5 && completed.compareAndSet(false, true)) {
                                                        s.onComplete();
                                                    }
                                                    // do some work
                                                    Math.pow(Math.random(), Math.random());
                                                    return integer * 2;
                                            }
                                        });
                        }
                    })
                    .toList()
                    .doOnSuccess(new Consumer<List<Object>>() {
                        @Override
                        public void accept(List<Object> integers) {
                                counter.incrementAndGet();
                                latch.countDown();
                                innerLatch.countDown();
                        }
                    })
                    .subscribe();
            if (!innerLatch.await(30, TimeUnit.SECONDS)) {
                Assert.fail(""Failed inner latch wait, iteration "" + iters);
            }
        }
        if (!latch.await(30, TimeUnit.SECONDS)) {
            Assert.fail(""Incomplete! Went through "" + latch.getCount() + "" iterations"");
        } else {
            Assert.assertEquals(NITERS, counter.get());
        }
    }",loop_control
iters,"{
        final AtomicLong counter = new AtomicLong();
        final Integer[] numbers = new Integer[5000];
        for (int i = 0; i < numbers.length; i++) {
            numbers[i] = i + 1;
        }
        final int NITERS = 250;
        final CountDownLatch latch = new CountDownLatch(NITERS);
        for (int iters = 0; iters < NITERS; iters++) {
            final CountDownLatch innerLatch = new CountDownLatch(1);
            final PublishProcessor<Void> s = PublishProcessor.create();
            final AtomicBoolean completed = new AtomicBoolean();
            Flowable.fromArray(numbers)
                    .takeUntil(s)
                    .window(50)
                    .flatMap(new Function<Flowable<Integer>, Publisher<Object>>() {
                        @Override
                        public Publisher<Object> apply(Flowable<Integer> integerObservable) {
                                return integerObservable
                                        .subscribeOn(Schedulers.computation())
                                        .map(new Function<Integer, Object>() {
                                            @Override
                                            public Object apply(Integer integer) {
                                                    if (integer >= 5 && completed.compareAndSet(false, true)) {
                                                        s.onComplete();
                                                    }
                                                    // do some work
                                                    Math.pow(Math.random(), Math.random());
                                                    return integer * 2;
                                            }
                                        });
                        }
                    })
                    .toList()
                    .doOnSuccess(new Consumer<List<Object>>() {
                        @Override
                        public void accept(List<Object> integers) {
                                counter.incrementAndGet();
                                latch.countDown();
                                innerLatch.countDown();
                        }
                    })
                    .subscribe();
            if (!innerLatch.await(30, TimeUnit.SECONDS)) {
                Assert.fail(""Failed inner latch wait, iteration "" + iters);
            }
        }
        if (!latch.await(30, TimeUnit.SECONDS)) {
            Assert.fail(""Incomplete! Went through "" + latch.getCount() + "" iterations"");
        } else {
            Assert.assertEquals(NITERS, counter.get());
        }
    }",loop_control
i,"{
        ConnectableFlowable<Integer> cf = Flowable.range(0, 1000).publish();
        Flowable<Integer> obs = cf.observeOn(Schedulers.computation());
        for (int i = 0; i < 1000; i++) {
            for (int j = 1; j < 6; j++) {
                List<TestSubscriberEx<Integer>> tss = new ArrayList<>();
                for (int k = 1; k < j; k++) {
                    TestSubscriberEx<Integer> ts = new TestSubscriberEx<>();
                    tss.add(ts);
                    obs.subscribe(ts);
                }

                Disposable connection = cf.connect();

                for (TestSubscriberEx<Integer> ts : tss) {
                    ts.awaitDone(5, TimeUnit.SECONDS)
                    .assertSubscribed()
                    .assertValueCount(1000)
                    .assertNoErrors()
                    .assertComplete();
                }
                connection.dispose();
            }
        }
    }",loop_control
j,"{
        ConnectableFlowable<Integer> cf = Flowable.range(0, 1000).publish();
        Flowable<Integer> obs = cf.observeOn(Schedulers.computation());
        for (int i = 0; i < 1000; i++) {
            for (int j = 1; j < 6; j++) {
                List<TestSubscriberEx<Integer>> tss = new ArrayList<>();
                for (int k = 1; k < j; k++) {
                    TestSubscriberEx<Integer> ts = new TestSubscriberEx<>();
                    tss.add(ts);
                    obs.subscribe(ts);
                }

                Disposable connection = cf.connect();

                for (TestSubscriberEx<Integer> ts : tss) {
                    ts.awaitDone(5, TimeUnit.SECONDS)
                    .assertSubscribed()
                    .assertValueCount(1000)
                    .assertNoErrors()
                    .assertComplete();
                }
                connection.dispose();
            }
        }
    }",loop_control
k,"{
        ConnectableFlowable<Integer> cf = Flowable.range(0, 1000).publish();
        Flowable<Integer> obs = cf.observeOn(Schedulers.computation());
        for (int i = 0; i < 1000; i++) {
            for (int j = 1; j < 6; j++) {
                List<TestSubscriberEx<Integer>> tss = new ArrayList<>();
                for (int k = 1; k < j; k++) {
                    TestSubscriberEx<Integer> ts = new TestSubscriberEx<>();
                    tss.add(ts);
                    obs.subscribe(ts);
                }

                Disposable connection = cf.connect();

                for (TestSubscriberEx<Integer> ts : tss) {
                    ts.awaitDone(5, TimeUnit.SECONDS)
                    .assertSubscribed()
                    .assertValueCount(1000)
                    .assertNoErrors()
                    .assertComplete();
                }
                connection.dispose();
            }
        }
    }",loop_control
ts,"{
        ConnectableFlowable<Integer> cf = Flowable.range(0, 1000).publish();
        Flowable<Integer> obs = cf.observeOn(Schedulers.computation());
        for (int i = 0; i < 1000; i++) {
            for (int j = 1; j < 6; j++) {
                List<TestSubscriberEx<Integer>> tss = new ArrayList<>();
                for (int k = 1; k < j; k++) {
                    TestSubscriberEx<Integer> ts = new TestSubscriberEx<>();
                    tss.add(ts);
                    obs.subscribe(ts);
                }

                Disposable connection = cf.connect();

                for (TestSubscriberEx<Integer> ts : tss) {
                    ts.awaitDone(5, TimeUnit.SECONDS)
                    .assertSubscribed()
                    .assertValueCount(1000)
                    .assertNoErrors()
                    .assertComplete();
                }
                connection.dispose();
            }
        }
    }",iterator
i,"{
        ConnectableFlowable<Integer> cf = Flowable.range(0, 1000).publish();
        Flowable<Integer> obs = cf.observeOn(ImmediateThinScheduler.INSTANCE);
        for (int i = 0; i < 1000; i++) {
            for (int j = 1; j < 6; j++) {
                List<TestSubscriberEx<Integer>> tss = new ArrayList<>();
                for (int k = 1; k < j; k++) {
                    TestSubscriberEx<Integer> ts = new TestSubscriberEx<>();
                    tss.add(ts);
                    obs.subscribe(ts);
                }

                Disposable connection = cf.connect();

                for (TestSubscriberEx<Integer> ts : tss) {
                    ts.awaitDone(5, TimeUnit.SECONDS)
                    .assertSubscribed()
                    .assertValueCount(1000)
                    .assertNoErrors()
                    .assertComplete();
                }
                connection.dispose();
            }
        }
    }",loop_control
j,"{
        ConnectableFlowable<Integer> cf = Flowable.range(0, 1000).publish();
        Flowable<Integer> obs = cf.observeOn(ImmediateThinScheduler.INSTANCE);
        for (int i = 0; i < 1000; i++) {
            for (int j = 1; j < 6; j++) {
                List<TestSubscriberEx<Integer>> tss = new ArrayList<>();
                for (int k = 1; k < j; k++) {
                    TestSubscriberEx<Integer> ts = new TestSubscriberEx<>();
                    tss.add(ts);
                    obs.subscribe(ts);
                }

                Disposable connection = cf.connect();

                for (TestSubscriberEx<Integer> ts : tss) {
                    ts.awaitDone(5, TimeUnit.SECONDS)
                    .assertSubscribed()
                    .assertValueCount(1000)
                    .assertNoErrors()
                    .assertComplete();
                }
                connection.dispose();
            }
        }
    }",loop_control
k,"{
        ConnectableFlowable<Integer> cf = Flowable.range(0, 1000).publish();
        Flowable<Integer> obs = cf.observeOn(ImmediateThinScheduler.INSTANCE);
        for (int i = 0; i < 1000; i++) {
            for (int j = 1; j < 6; j++) {
                List<TestSubscriberEx<Integer>> tss = new ArrayList<>();
                for (int k = 1; k < j; k++) {
                    TestSubscriberEx<Integer> ts = new TestSubscriberEx<>();
                    tss.add(ts);
                    obs.subscribe(ts);
                }

                Disposable connection = cf.connect();

                for (TestSubscriberEx<Integer> ts : tss) {
                    ts.awaitDone(5, TimeUnit.SECONDS)
                    .assertSubscribed()
                    .assertValueCount(1000)
                    .assertNoErrors()
                    .assertComplete();
                }
                connection.dispose();
            }
        }
    }",loop_control
ts,"{
        ConnectableFlowable<Integer> cf = Flowable.range(0, 1000).publish();
        Flowable<Integer> obs = cf.observeOn(ImmediateThinScheduler.INSTANCE);
        for (int i = 0; i < 1000; i++) {
            for (int j = 1; j < 6; j++) {
                List<TestSubscriberEx<Integer>> tss = new ArrayList<>();
                for (int k = 1; k < j; k++) {
                    TestSubscriberEx<Integer> ts = new TestSubscriberEx<>();
                    tss.add(ts);
                    obs.subscribe(ts);
                }

                Disposable connection = cf.connect();

                for (TestSubscriberEx<Integer> ts : tss) {
                    ts.awaitDone(5, TimeUnit.SECONDS)
                    .assertSubscribed()
                    .assertValueCount(1000)
                    .assertNoErrors()
                    .assertComplete();
                }
                connection.dispose();
            }
        }
    }",iterator
i,"{
        ConnectableFlowable<Integer> cf = Flowable.range(0, 1000).observeOn(ImmediateThinScheduler.INSTANCE).publish();
        for (int i = 0; i < 1000; i++) {
            for (int j = 1; j < 6; j++) {
                List<TestSubscriberEx<Integer>> tss = new ArrayList<>();
                for (int k = 1; k < j; k++) {
                    TestSubscriberEx<Integer> ts = new TestSubscriberEx<>();
                    tss.add(ts);
                    cf.subscribe(ts);
                }

                Disposable connection = cf.connect();

                for (TestSubscriberEx<Integer> ts : tss) {
                    ts.awaitDone(5, TimeUnit.SECONDS)
                    .assertSubscribed()
                    .assertValueCount(1000)
                    .assertNoErrors()
                    .assertComplete();
                }
                connection.dispose();
            }
        }
    }",loop_control
j,"{
        ConnectableFlowable<Integer> cf = Flowable.range(0, 1000).observeOn(ImmediateThinScheduler.INSTANCE).publish();
        for (int i = 0; i < 1000; i++) {
            for (int j = 1; j < 6; j++) {
                List<TestSubscriberEx<Integer>> tss = new ArrayList<>();
                for (int k = 1; k < j; k++) {
                    TestSubscriberEx<Integer> ts = new TestSubscriberEx<>();
                    tss.add(ts);
                    cf.subscribe(ts);
                }

                Disposable connection = cf.connect();

                for (TestSubscriberEx<Integer> ts : tss) {
                    ts.awaitDone(5, TimeUnit.SECONDS)
                    .assertSubscribed()
                    .assertValueCount(1000)
                    .assertNoErrors()
                    .assertComplete();
                }
                connection.dispose();
            }
        }
    }",loop_control
k,"{
        ConnectableFlowable<Integer> cf = Flowable.range(0, 1000).observeOn(ImmediateThinScheduler.INSTANCE).publish();
        for (int i = 0; i < 1000; i++) {
            for (int j = 1; j < 6; j++) {
                List<TestSubscriberEx<Integer>> tss = new ArrayList<>();
                for (int k = 1; k < j; k++) {
                    TestSubscriberEx<Integer> ts = new TestSubscriberEx<>();
                    tss.add(ts);
                    cf.subscribe(ts);
                }

                Disposable connection = cf.connect();

                for (TestSubscriberEx<Integer> ts : tss) {
                    ts.awaitDone(5, TimeUnit.SECONDS)
                    .assertSubscribed()
                    .assertValueCount(1000)
                    .assertNoErrors()
                    .assertComplete();
                }
                connection.dispose();
            }
        }
    }",loop_control
ts,"{
        ConnectableFlowable<Integer> cf = Flowable.range(0, 1000).observeOn(ImmediateThinScheduler.INSTANCE).publish();
        for (int i = 0; i < 1000; i++) {
            for (int j = 1; j < 6; j++) {
                List<TestSubscriberEx<Integer>> tss = new ArrayList<>();
                for (int k = 1; k < j; k++) {
                    TestSubscriberEx<Integer> ts = new TestSubscriberEx<>();
                    tss.add(ts);
                    cf.subscribe(ts);
                }

                Disposable connection = cf.connect();

                for (TestSubscriberEx<Integer> ts : tss) {
                    ts.awaitDone(5, TimeUnit.SECONDS)
                    .assertSubscribed()
                    .assertValueCount(1000)
                    .assertNoErrors()
                    .assertComplete();
                }
                connection.dispose();
            }
        }
    }",iterator
i,"{
        ConnectableFlowable<Integer> cf = Flowable.range(0, 1000).hide().publish();
        Flowable<Integer> obs = cf.observeOn(Schedulers.computation());
        for (int i = 0; i < 1000; i++) {
            for (int j = 1; j < 6; j++) {
                List<TestSubscriberEx<Integer>> tss = new ArrayList<>();
                for (int k = 1; k < j; k++) {
                    TestSubscriberEx<Integer> ts = new TestSubscriberEx<>();
                    tss.add(ts);
                    obs.subscribe(ts);
                }

                Disposable connection = cf.connect();

                for (TestSubscriberEx<Integer> ts : tss) {
                    ts.awaitDone(5, TimeUnit.SECONDS)
                    .assertSubscribed()
                    .assertValueCount(1000)
                    .assertNoErrors()
                    .assertComplete();
                }
                connection.dispose();
            }
        }
    }",loop_control
j,"{
        ConnectableFlowable<Integer> cf = Flowable.range(0, 1000).hide().publish();
        Flowable<Integer> obs = cf.observeOn(Schedulers.computation());
        for (int i = 0; i < 1000; i++) {
            for (int j = 1; j < 6; j++) {
                List<TestSubscriberEx<Integer>> tss = new ArrayList<>();
                for (int k = 1; k < j; k++) {
                    TestSubscriberEx<Integer> ts = new TestSubscriberEx<>();
                    tss.add(ts);
                    obs.subscribe(ts);
                }

                Disposable connection = cf.connect();

                for (TestSubscriberEx<Integer> ts : tss) {
                    ts.awaitDone(5, TimeUnit.SECONDS)
                    .assertSubscribed()
                    .assertValueCount(1000)
                    .assertNoErrors()
                    .assertComplete();
                }
                connection.dispose();
            }
        }
    }",loop_control
k,"{
        ConnectableFlowable<Integer> cf = Flowable.range(0, 1000).hide().publish();
        Flowable<Integer> obs = cf.observeOn(Schedulers.computation());
        for (int i = 0; i < 1000; i++) {
            for (int j = 1; j < 6; j++) {
                List<TestSubscriberEx<Integer>> tss = new ArrayList<>();
                for (int k = 1; k < j; k++) {
                    TestSubscriberEx<Integer> ts = new TestSubscriberEx<>();
                    tss.add(ts);
                    obs.subscribe(ts);
                }

                Disposable connection = cf.connect();

                for (TestSubscriberEx<Integer> ts : tss) {
                    ts.awaitDone(5, TimeUnit.SECONDS)
                    .assertSubscribed()
                    .assertValueCount(1000)
                    .assertNoErrors()
                    .assertComplete();
                }
                connection.dispose();
            }
        }
    }",loop_control
ts,"{
        ConnectableFlowable<Integer> cf = Flowable.range(0, 1000).hide().publish();
        Flowable<Integer> obs = cf.observeOn(Schedulers.computation());
        for (int i = 0; i < 1000; i++) {
            for (int j = 1; j < 6; j++) {
                List<TestSubscriberEx<Integer>> tss = new ArrayList<>();
                for (int k = 1; k < j; k++) {
                    TestSubscriberEx<Integer> ts = new TestSubscriberEx<>();
                    tss.add(ts);
                    obs.subscribe(ts);
                }

                Disposable connection = cf.connect();

                for (TestSubscriberEx<Integer> ts : tss) {
                    ts.awaitDone(5, TimeUnit.SECONDS)
                    .assertSubscribed()
                    .assertValueCount(1000)
                    .assertNoErrors()
                    .assertComplete();
                }
                connection.dispose();
            }
        }
    }",iterator
i,"{
        for (int i = 0; i < TestHelper.RACE_DEFAULT_LOOPS; i++) {

            final ConnectableFlowable<Integer> cf = Flowable.<Integer>empty().publish();

            final TestSubscriber<Integer> ts = cf.test();

            final TestSubscriber<Integer> ts2 = new TestSubscriber<>();

            Runnable r1 = new Runnable() {
                @Override
                public void run() {
                    cf.subscribe(ts2);
                }
            };

            Runnable r2 = new Runnable() {
                @Override
                public void run() {
                    ts.cancel();
                }
            };

            TestHelper.race(r1, r2);
        }
    }",loop_control
i,"{
        for (int i = 0; i < TestHelper.RACE_DEFAULT_LOOPS; i++) {

            final PublishProcessor<Integer> pp = PublishProcessor.create();

            final ConnectableFlowable<Integer> cf = pp.publish();

            final TestSubscriber<Integer> ts = cf.test();

            Runnable r1 = new Runnable() {
                @Override
                public void run() {
                    pp.onNext(1);
                }
            };

            Runnable r2 = new Runnable() {
                @Override
                public void run() {
                    ts.cancel();
                }
            };

            TestHelper.race(r1, r2);
        }
    }",loop_control
i,"{
        for (int i = 0; i < TestHelper.RACE_DEFAULT_LOOPS; i++) {

            final PublishProcessor<Integer> pp = PublishProcessor.create();

            final ConnectableFlowable<Integer> cf = pp.publish();

            final Disposable d = cf.connect();
            final TestSubscriber<Integer> ts = new TestSubscriber<>();

            Runnable r1 = new Runnable() {
                @Override
                public void run() {
                    d.dispose();
                }
            };

            Runnable r2 = new Runnable() {
                @Override
                public void run() {
                    cf.subscribe(ts);
                }
            };

            TestHelper.race(r1, r2);
        }
    }",loop_control
i,"{
        for (int i = 0; i < TestHelper.RACE_DEFAULT_LOOPS; i++) {

            final ConnectableFlowable<Integer> cf = Flowable.<Integer>empty().publish();

            cf.connect();

            Runnable r1 = new Runnable() {
                @Override
                public void run() {
                    cf.test();
                }
            };

            TestHelper.race(r1, r1);
        }
    }",loop_control
i,"{
        for (int i = 0; i < TestHelper.RACE_DEFAULT_LOOPS; i++) {

            final ConnectableFlowable<Integer> cf = Flowable.<Integer>empty().publish();

            Runnable r1 = new Runnable() {
                @Override
                public void run() {
                    cf.connect();
                }
            };

            TestHelper.race(r1, r1);
        }
    }",loop_control
i,"{
        List<Throwable> errors = TestHelper.trackPluginErrors();
        try {
            Flowable.create(new FlowableOnSubscribe<Object>() {
                @Override
                public void subscribe(FlowableEmitter<Object> s) throws Exception {
                    for (int i = 0; i < 10; i++) {
                        s.onNext(i);
                    }
                }
            }, BackpressureStrategy.MISSING)
            .publish(8)
            .autoConnect()
            .test(0L)
            // 3.x emits errors last, even the full queue errors
            .requestMore(10)
            .assertFailure(MissingBackpressureException.class, 0, 1, 2, 3, 4, 5, 6, 7);

            TestHelper.assertError(errors, 0, MissingBackpressureException.class);
        } finally {
            RxJavaPlugins.reset();
        }
    }",loop_control
i,"{
        for (int i = 0; i < TestHelper.RACE_DEFAULT_LOOPS; i++) {

            final AtomicReference<Disposable> ref = new AtomicReference<>();

            final ConnectableFlowable<Integer> cf = new Flowable<Integer>() {
                @Override
                protected void subscribeActual(Subscriber<? super Integer> s) {
                    s.onSubscribe(new BooleanSubscription());
                    ref.set((Disposable)s);
                }
            }.publish();

            cf.connect();

            Runnable r1 = new Runnable() {
                @Override
                public void run() {
                    ref.get().dispose();
                }
            };

            TestHelper.race(r1, r1);
        }
    }",loop_control
i,"{
        for (int i = 0; i < TestHelper.RACE_LONG_LOOPS; i++) {

            final PublishProcessor<Integer> pp = PublishProcessor.create();

            final AtomicReference<Flowable<Integer>> ref = new AtomicReference<>();

            pp.publish(new Function<Flowable<Integer>, Publisher<Integer>>() {
                @Override
                public Publisher<Integer> apply(Flowable<Integer> f) throws Exception {
                    ref.set(f);
                    return Flowable.never();
                }
            }).test();

            final TestSubscriber<Integer> ts1 = ref.get().test();
            TestSubscriber<Integer> ts2 = ref.get().test();

            Runnable r1 = new Runnable() {
                @Override
                public void run() {
                    pp.onNext(1);
                }
            };

            Runnable r2 = new Runnable() {
                @Override
                public void run() {
                    ts1.cancel();
                }
            };

            TestHelper.race(r1, r2);

            ts2.assertValuesOnly(1);
        }
    }",loop_control
i,"{
        for (int i = 0; i < TestHelper.RACE_LONG_LOOPS; i++) {
            final ConnectableFlowable<Integer> cf =
                    new FlowablePublish<>(Flowable.<Integer>never(), 128);

            Runnable r = new Runnable() {
                @Override
                public void run() {
                    cf.connect();
                }
            };

            TestHelper.race(r, r);
        }
    }",loop_control
m,"{
        for (BackpressureStrategy m : BackpressureStrategy.values()) {
            Flowable<Object> source = Flowable.create(new FlowableOnSubscribe<Object>() {
                @Override
                public void subscribe(FlowableEmitter<Object> e) throws Exception {
                    final FlowableEmitter<Object> f = e.serialize();

                    final TestException ex = new TestException();

                    Runnable r1 = new Runnable() {
                        @Override
                        public void run() {
                            f.onError(null);
                        }
                    };

                    Runnable r2 = new Runnable() {
                        @Override
                        public void run() {
                            f.onError(ex);
                        }
                    };

                    TestHelper.race(r1, r2);
                }
            }, m);

            List<Throwable> errors = TestHelper.trackPluginErrors();

            try {
                for (int i = 0; i < TestHelper.RACE_DEFAULT_LOOPS; i++) {
                    source
                    .test()
                    .assertFailure(Throwable.class);
                }
            } finally {
                RxJavaPlugins.reset();
            }
            assertFalse(errors.isEmpty());
        }
    }",iterator
i,"{
        for (BackpressureStrategy m : BackpressureStrategy.values()) {
            Flowable<Object> source = Flowable.create(new FlowableOnSubscribe<Object>() {
                @Override
                public void subscribe(FlowableEmitter<Object> e) throws Exception {
                    final FlowableEmitter<Object> f = e.serialize();

                    final TestException ex = new TestException();

                    Runnable r1 = new Runnable() {
                        @Override
                        public void run() {
                            f.onError(null);
                        }
                    };

                    Runnable r2 = new Runnable() {
                        @Override
                        public void run() {
                            f.onError(ex);
                        }
                    };

                    TestHelper.race(r1, r2);
                }
            }, m);

            List<Throwable> errors = TestHelper.trackPluginErrors();

            try {
                for (int i = 0; i < TestHelper.RACE_DEFAULT_LOOPS; i++) {
                    source
                    .test()
                    .assertFailure(Throwable.class);
                }
            } finally {
                RxJavaPlugins.reset();
            }
            assertFalse(errors.isEmpty());
        }
    }",loop_control
m,"{
        for (BackpressureStrategy m : BackpressureStrategy.values()) {
            Flowable<Object> source = Flowable.create(new FlowableOnSubscribe<Object>() {
                @Override
                public void subscribe(FlowableEmitter<Object> e) throws Exception {
                    final FlowableEmitter<Object> f = e.serialize();

                    Runnable r1 = new Runnable() {
                        @Override
                        public void run() {
                            f.onComplete();
                        }
                    };

                    Runnable r2 = new Runnable() {
                        @Override
                        public void run() {
                            f.onComplete();
                        }
                    };

                    TestHelper.race(r1, r2);
                }
            }, m);

            for (int i = 0; i < TestHelper.RACE_DEFAULT_LOOPS; i++) {
                source
                .test()
                .assertResult();
            }
        }
    }",iterator
i,"{
        for (BackpressureStrategy m : BackpressureStrategy.values()) {
            Flowable<Object> source = Flowable.create(new FlowableOnSubscribe<Object>() {
                @Override
                public void subscribe(FlowableEmitter<Object> e) throws Exception {
                    final FlowableEmitter<Object> f = e.serialize();

                    Runnable r1 = new Runnable() {
                        @Override
                        public void run() {
                            f.onComplete();
                        }
                    };

                    Runnable r2 = new Runnable() {
                        @Override
                        public void run() {
                            f.onComplete();
                        }
                    };

                    TestHelper.race(r1, r2);
                }
            }, m);

            for (int i = 0; i < TestHelper.RACE_DEFAULT_LOOPS; i++) {
                source
                .test()
                .assertResult();
            }
        }
    }",loop_control
m,"{
        for (BackpressureStrategy m : BackpressureStrategy.values()) {
            Flowable.create(new FlowableOnSubscribe<Object>() {
                @Override
                public void subscribe(FlowableEmitter<Object> e) throws Exception {
                    e.onNext(null);
                }
            }, m)
            .test()
            .assertFailure(NullPointerException.class);
        }
    }",iterator
m,"{
        for (BackpressureStrategy m : BackpressureStrategy.values()) {
            System.out.println(m);
            Flowable.create(new FlowableOnSubscribe<Object>() {
                @Override
                public void subscribe(FlowableEmitter<Object> e) throws Exception {
                    e.onError(null);
                }
            }, m)
            .test()
            .assertFailure(NullPointerException.class);
        }
    }",iterator
m,"{
        for (BackpressureStrategy m : BackpressureStrategy.values()) {
            Flowable.create(new FlowableOnSubscribe<Object>() {
                @Override
                public void subscribe(FlowableEmitter<Object> e) throws Exception {
                    final FlowableEmitter<Object> f = e.serialize();

                    Runnable r1 = new Runnable() {
                        @Override
                        public void run() {
                            for (int i = 0; i < 1000; i++) {
                                f.onNext(1);
                            }
                        }
                    };

                    Runnable r2 = new Runnable() {
                        @Override
                        public void run() {
                            for (int i = 0; i < 100; i++) {
                                f.onNext(1);
                            }
                            f.onError(new TestException());
                        }
                    };

                    TestHelper.race(r1, r2);
                }
            }, m)
            .to(TestHelper.<Object>testConsumer())
            .assertSubscribed()
            .assertNotComplete()
            .assertError(TestException.class);
        }
    }",iterator
i,"{
        for (BackpressureStrategy m : BackpressureStrategy.values()) {
            Flowable.create(new FlowableOnSubscribe<Object>() {
                @Override
                public void subscribe(FlowableEmitter<Object> e) throws Exception {
                    final FlowableEmitter<Object> f = e.serialize();

                    Runnable r1 = new Runnable() {
                        @Override
                        public void run() {
                            for (int i = 0; i < 1000; i++) {
                                f.onNext(1);
                            }
                        }
                    };

                    Runnable r2 = new Runnable() {
                        @Override
                        public void run() {
                            for (int i = 0; i < 100; i++) {
                                f.onNext(1);
                            }
                            f.onError(new TestException());
                        }
                    };

                    TestHelper.race(r1, r2);
                }
            }, m)
            .to(TestHelper.<Object>testConsumer())
            .assertSubscribed()
            .assertNotComplete()
            .assertError(TestException.class);
        }
    }",loop_control
m,"{
        for (BackpressureStrategy m : BackpressureStrategy.values()) {
            Flowable.create(new FlowableOnSubscribe<Object>() {
                @Override
                public void subscribe(FlowableEmitter<Object> e) throws Exception {
                    throw new TestException();
                }
            }, m)
            .test()
            .assertFailure(TestException.class);
        }
    }",iterator
m,"{
        for (BackpressureStrategy m : BackpressureStrategy.values()) {
            Flowable.create(new FlowableOnSubscribe<Object>() {
                @Override
                public void subscribe(FlowableEmitter<Object> e) throws Exception {
                    e.serialize().onNext(null);
                }
            }, m)
            .test()
            .assertFailure(NullPointerException.class);
        }
    }",iterator
m,"{
        for (BackpressureStrategy m : BackpressureStrategy.values()) {
            List<Throwable> errors = TestHelper.trackPluginErrors();
            try {
                final Throwable[] error = { null };

                Flowable.create(new FlowableOnSubscribe<Integer>() {
                    @Override
                    public void subscribe(FlowableEmitter<Integer> e) throws Exception {
                        try {
                            e.onNext(null);
                            e.onNext(1);
                            e.onError(new TestException());
                            e.onComplete();
                        } catch (Throwable ex) {
                            error[0] = ex;
                        }
                    }
                }, m)
                .test()
                .assertFailure(NullPointerException.class);

                assertNull(error[0]);

                TestHelper.assertUndeliverable(errors, 0, TestException.class);
            } finally {
                RxJavaPlugins.reset();
            }
        }
    }",iterator
m,"{
        for (BackpressureStrategy m : BackpressureStrategy.values()) {
            Flowable.create(new FlowableOnSubscribe<Object>() {
                @Override
                public void subscribe(FlowableEmitter<Object> e) throws Exception {
                    Disposable d = Disposable.empty();
                    e.setDisposable(d);
                    try {
                        e.onError(new IOException());
                        fail(""Should have thrown"");
                    } catch (TestException ex) {
                        // expected
                    }
                    assertTrue(d.isDisposed());
                }
            }, m)
            .subscribe(new FlowableSubscriber<Object>() {
                @Override
                public void onSubscribe(Subscription s) {
                }

                @Override
                public void onNext(Object value) {
                }

                @Override
                public void onError(Throwable e) {
                    throw new TestException();
                }

                @Override
                public void onComplete() {
                }
            });
        }
    }",iterator
m,"{
        for (BackpressureStrategy m : BackpressureStrategy.values()) {
            Flowable.create(new FlowableOnSubscribe<Object>() {
                @Override
                public void subscribe(FlowableEmitter<Object> e) throws Exception {
                    Disposable d = Disposable.empty();
                    e.setDisposable(d);
                    try {
                        e.onComplete();
                        fail(""Should have thrown"");
                    } catch (TestException ex) {
                        // expected
                    }
                    assertTrue(d.isDisposed());
                }
            }, m)
            .subscribe(new FlowableSubscriber<Object>() {
                @Override
                public void onSubscribe(Subscription s) {
                }

                @Override
                public void onNext(Object value) {
                }

                @Override
                public void onError(Throwable e) {
                }

                @Override
                public void onComplete() {
                    throw new TestException();
                }
            });
        }
    }",iterator
m,"{
        for (BackpressureStrategy m : BackpressureStrategy.values()) {
            List<Throwable> errors = TestHelper.trackPluginErrors();
            try {
                final Throwable[] error = { null };

                Flowable.create(new FlowableOnSubscribe<Integer>() {
                    @Override
                    public void subscribe(FlowableEmitter<Integer> e) throws Exception {
                        e = e.serialize();
                        try {
                            e.onNext(null);
                            e.onNext(1);
                            e.onError(new TestException());
                            e.onComplete();
                        } catch (Throwable ex) {
                            error[0] = ex;
                        }
                    }
                }, m)
                .test()
                .assertFailure(NullPointerException.class);

                assertNull(error[0]);

                TestHelper.assertUndeliverable(errors, 0, TestException.class);
            } finally {
                RxJavaPlugins.reset();
            }
        }
    }",iterator
m,"{
        for (BackpressureStrategy m : BackpressureStrategy.values()) {
            Flowable.create(new FlowableOnSubscribe<Object>() {
                @Override
                public void subscribe(FlowableEmitter<Object> e) throws Exception {
                    e.serialize().onError(null);
                }
            }, m)
            .test()
            .assertFailure(NullPointerException.class);
        }
    }",iterator
m,"{
        for (BackpressureStrategy m : BackpressureStrategy.values()) {
            Flowable.create(new FlowableOnSubscribe<Object>() {
                @Override
                public void subscribe(FlowableEmitter<Object> e) throws Exception {
                    final FlowableEmitter<Object> f = e.serialize();

                    Runnable r1 = new Runnable() {
                        @Override
                        public void run() {
                            for (int i = 0; i < TestHelper.RACE_DEFAULT_LOOPS; i++) {
                                f.onNext(1);
                            }
                        }
                    };

                    TestHelper.race(r1, r1);
                }
            }, m)
            .take(TestHelper.RACE_DEFAULT_LOOPS)
            .to(TestHelper.<Object>testConsumer())
            .assertSubscribed()
            .assertValueCount(TestHelper.RACE_DEFAULT_LOOPS)
            .assertComplete()
            .assertNoErrors();
        }
    }",iterator
i,"{
        for (BackpressureStrategy m : BackpressureStrategy.values()) {
            Flowable.create(new FlowableOnSubscribe<Object>() {
                @Override
                public void subscribe(FlowableEmitter<Object> e) throws Exception {
                    final FlowableEmitter<Object> f = e.serialize();

                    Runnable r1 = new Runnable() {
                        @Override
                        public void run() {
                            for (int i = 0; i < TestHelper.RACE_DEFAULT_LOOPS; i++) {
                                f.onNext(1);
                            }
                        }
                    };

                    TestHelper.race(r1, r1);
                }
            }, m)
            .take(TestHelper.RACE_DEFAULT_LOOPS)
            .to(TestHelper.<Object>testConsumer())
            .assertSubscribed()
            .assertValueCount(TestHelper.RACE_DEFAULT_LOOPS)
            .assertComplete()
            .assertNoErrors();
        }
    }",loop_control
m,"{
        for (BackpressureStrategy m : BackpressureStrategy.values()) {
            TestSubscriberEx<Object> ts = Flowable.create(new FlowableOnSubscribe<Object>() {
                @Override
                public void subscribe(FlowableEmitter<Object> e) throws Exception {
                    final FlowableEmitter<Object> f = e.serialize();

                    Runnable r1 = new Runnable() {
                        @Override
                        public void run() {
                            for (int i = 0; i < 1000; i++) {
                                f.onNext(1);
                            }
                        }
                    };

                    Runnable r2 = new Runnable() {
                        @Override
                        public void run() {
                            for (int i = 0; i < 100; i++) {
                                f.onNext(1);
                            }
                            f.onComplete();
                        }
                    };

                    TestHelper.race(r1, r2);
                }
            }, m)
            .to(TestHelper.<Object>testConsumer())
            .assertSubscribed()
            .assertComplete()
            .assertNoErrors();

            int c = ts.values().size();
            assertTrue("""" + c, c >= 100);
        }
    }",iterator
i,"{
        for (BackpressureStrategy m : BackpressureStrategy.values()) {
            TestSubscriberEx<Object> ts = Flowable.create(new FlowableOnSubscribe<Object>() {
                @Override
                public void subscribe(FlowableEmitter<Object> e) throws Exception {
                    final FlowableEmitter<Object> f = e.serialize();

                    Runnable r1 = new Runnable() {
                        @Override
                        public void run() {
                            for (int i = 0; i < 1000; i++) {
                                f.onNext(1);
                            }
                        }
                    };

                    Runnable r2 = new Runnable() {
                        @Override
                        public void run() {
                            for (int i = 0; i < 100; i++) {
                                f.onNext(1);
                            }
                            f.onComplete();
                        }
                    };

                    TestHelper.race(r1, r2);
                }
            }, m)
            .to(TestHelper.<Object>testConsumer())
            .assertSubscribed()
            .assertComplete()
            .assertNoErrors();

            int c = ts.values().size();
            assertTrue("""" + c, c >= 100);
        }
    }",loop_control
m,"{
        for (BackpressureStrategy m : BackpressureStrategy.values()) {
            List<Throwable> errors = TestHelper.trackPluginErrors();
            try {
                Flowable.create(new FlowableOnSubscribe<Object>() {
                    @Override
                    public void subscribe(FlowableEmitter<Object> e) throws Exception {
                        FlowableEmitter<Object> f = e.serialize();

                        assertSame(f, f.serialize());

                        assertFalse(f.isCancelled());

                        final int[] calls = { 0 };

                        f.setCancellable(new Cancellable() {
                            @Override
                            public void cancel() throws Exception {
                                calls[0]++;
                            }
                        });

                        e.onComplete();

                        assertTrue(f.isCancelled());

                        assertEquals(1, calls[0]);
                    }
                }, m)
                .test()
                .assertResult();

                assertTrue(errors.toString(), errors.isEmpty());
            } finally {
                RxJavaPlugins.reset();
            }
        }
    }",iterator
strategy,"{
        for (BackpressureStrategy strategy : BackpressureStrategy.values()) {
            List<Throwable> errors = TestHelper.trackPluginErrors();
            try {
                final Boolean[] response = { null };
                Flowable.create(new FlowableOnSubscribe<Object>() {
                    @Override
                    public void subscribe(FlowableEmitter<Object> e) throws Exception {
                        e.onNext(1);
                        response[0] = e.tryOnError(new TestException());
                    }
                }, strategy)
                .take(1)
                .test()
                .withTag(strategy.toString())
                .assertResult(1);

                assertFalse(response[0]);

                assertTrue(strategy + "": "" + errors.toString(), errors.isEmpty());
            } finally {
                RxJavaPlugins.reset();
            }
        }
    }",iterator
strategy,"{
        for (BackpressureStrategy strategy : BackpressureStrategy.values()) {
            List<Throwable> errors = TestHelper.trackPluginErrors();
            try {
                final Boolean[] response = { null };
                Flowable.create(new FlowableOnSubscribe<Object>() {
                    @Override
                    public void subscribe(FlowableEmitter<Object> e) throws Exception {
                        e = e.serialize();
                        e.onNext(1);
                        response[0] = e.tryOnError(new TestException());
                    }
                }, strategy)
                .take(1)
                .test()
                .withTag(strategy.toString())
                .assertResult(1);

                assertFalse(response[0]);

                assertTrue(strategy + "": "" + errors.toString(), errors.isEmpty());
            } finally {
                RxJavaPlugins.reset();
            }
        }
    }",iterator
entry,"{
        Map<BackpressureStrategy, Class<? extends FlowableEmitter>> emitterMap =
                new HashMap<>();

        emitterMap.put(BackpressureStrategy.MISSING, FlowableCreate.MissingEmitter.class);
        emitterMap.put(BackpressureStrategy.ERROR, FlowableCreate.ErrorAsyncEmitter.class);
        emitterMap.put(BackpressureStrategy.DROP, FlowableCreate.DropAsyncEmitter.class);
        emitterMap.put(BackpressureStrategy.LATEST, FlowableCreate.LatestAsyncEmitter.class);
        emitterMap.put(BackpressureStrategy.BUFFER, FlowableCreate.BufferAsyncEmitter.class);

        for (final Map.Entry<BackpressureStrategy, Class<? extends FlowableEmitter>> entry : emitterMap.entrySet()) {
            Flowable.create(new FlowableOnSubscribe<Object>() {
                @Override
                public void subscribe(FlowableEmitter<Object> emitter) throws Exception {
                    assertTrue(emitter.toString().contains(entry.getValue().getSimpleName()));
                    assertTrue(emitter.serialize().toString().contains(entry.getValue().getSimpleName()));
                }
            }, entry.getKey()).test().assertEmpty();
        }
    }",iterator
i,"{
        TestSubscriberEx<Integer> ts = new TestSubscriberEx<>(0);

        PublishProcessor<Integer> pp = PublishProcessor.create();

        pp.publish(Functions.identity()).subscribe(ts);

        for (int i = 0; i < Flowable.bufferSize() * 2; i++) {
            pp.onNext(i);
        }

        ts.assertNoValues();
        ts.assertError(MissingBackpressureException.class);
        ts.assertNotComplete();

        Assert.assertEquals(""Could not emit value due to lack of requests"",
                ts.errors().get(0).getMessage());
        Assert.assertFalse(""Source has subscribers?"", pp.hasSubscribers());
    }",loop_control
i,"{
        TestSubscriberEx<Integer> ts = new TestSubscriberEx<>(0);

        PublishProcessor<Integer> pp = PublishProcessor.create();

        new FlowablePublishMulticast<>(pp, Functions.identity(), Flowable.bufferSize(), true).subscribe(ts);

        for (int i = 0; i < Flowable.bufferSize() * 2; i++) {
            pp.onNext(i);
        }

        ts.request(Flowable.bufferSize());

        ts.assertValueCount(Flowable.bufferSize());
        ts.assertError(MissingBackpressureException.class);
        ts.assertNotComplete();

        Assert.assertEquals(""Could not emit value due to lack of requests"", ts.errors().get(0).getMessage());
        Assert.assertFalse(""Source has subscribers?"", pp.hasSubscribers());
    }",loop_control
i,"{
        new Flowable<Integer>() {
            @Override
            protected void subscribeActual(Subscriber<? super Integer> s) {
                s.onSubscribe(new BooleanSubscription());
                for (int i = 0; i < 9; i++) {
                    s.onNext(i);
                }
            }
        }
        .publish(Functions.identity(), 8)
        .test(0)
        .assertFailure(MissingBackpressureException.class);
    }",loop_control
i,"{
        Flowable<Integer> source = Flowable.just(1)
                .publish(f -> f.subscribeOn(Schedulers.single()));

        for (int i = 0; i < 500; i++) {
            source.test()
            .awaitDone(5, TimeUnit.SECONDS)
            .assertResult(1);
        }
    }",loop_control
i,"{
        Flowable<Integer> source = Flowable.just(1).subscribeOn(Schedulers.single())
                .publish(Functions.identity());

        for (int i = 0; i < 500; i++) {
            source.test()
            .awaitDone(5, TimeUnit.SECONDS)
            .assertResult(1);
        }
    }",loop_control
i,"{
        for (int i = 0; i < TestHelper.RACE_DEFAULT_LOOPS; i++) {
            final TestSubscriber<Integer> ts1 = new TestSubscriber<>(0L);

            Flowable.just(1)
                    .publish(f -> {
                        Runnable r1 = () -> f.subscribe(ts1);

                        Runnable r2 = () -> {
                            for (int j = 0; j < 100; j++) {
                                ts1.request(1);
                            }
                        };

                        TestHelper.race(r1, r2);
                        return f;
                    }).test()
                    .assertResult(1);

            ts1.assertResult(1);
        }
    }",loop_control
j,"{
        for (int i = 0; i < TestHelper.RACE_DEFAULT_LOOPS; i++) {
            final TestSubscriber<Integer> ts1 = new TestSubscriber<>(0L);

            Flowable.just(1)
                    .publish(f -> {
                        Runnable r1 = () -> f.subscribe(ts1);

                        Runnable r2 = () -> {
                            for (int j = 0; j < 100; j++) {
                                ts1.request(1);
                            }
                        };

                        TestHelper.race(r1, r2);
                        return f;
                    }).test()
                    .assertResult(1);

            ts1.assertResult(1);
        }
    }",loop_control
i,"{
        for (int i = 0; i < 100; i++) {
            List<Flowable<String>> os = new ArrayList<>();
            os.add(Flowable.just(""one"", ""two"", ""three"", ""four"", ""five"").subscribeOn(Schedulers.newThread()));
            os.add(Flowable.just(""one"", ""two"", ""three"", ""four"", ""five"").subscribeOn(Schedulers.newThread()));
            os.add(Flowable.just(""one"", ""two"", ""three"", ""four"", ""five"").subscribeOn(Schedulers.newThread()));

            List<String> expected = Arrays.asList(""one"", ""two"", ""three"", ""four"", ""five"", ""one"", ""two"", ""three"", ""four"", ""five"", ""one"", ""two"", ""three"", ""four"", ""five"");
            Iterator<String> iter = Flowable.merge(os, 1).blockingIterable().iterator();
            List<String> actual = new ArrayList<>();
            while (iter.hasNext()) {
                actual.add(iter.next());
            }
            assertEquals(expected, actual);
        }
    }",loop_control
i,"{
        for (int i = 0; i < 100; i++) {
            List<Flowable<String>> os = new ArrayList<>();
            os.add(Flowable.just(""one"", ""two"", ""three"", ""four"", ""five"").subscribeOn(Schedulers.newThread()));
            os.add(Flowable.just(""one"", ""two"", ""three"", ""four"", ""five"").subscribeOn(Schedulers.newThread()));
            os.add(Flowable.just(""one"", ""two"", ""three"", ""four"", ""five"").subscribeOn(Schedulers.newThread()));

            List<String> expected = Arrays.asList(""one"", ""two"", ""three"", ""four"", ""five"", ""one"", ""two"", ""three"", ""four"", ""five"", ""one"", ""two"", ""three"", ""four"", ""five"");
            Iterator<String> iter = Flowable.merge(os, 1).blockingIterable().iterator();
            List<String> actual = new ArrayList<>();
            while (iter.hasNext()) {
                actual.add(iter.next());
            }
            assertEquals(expected, actual);
        }
    }",loop_control
times,"{
        for (int times = 0; times < 100; times++) {
            int observableCount = 100;
            // Test maxConcurrent from 2 to 12
            int maxConcurrent = 2 + (times % 10);
            AtomicInteger subscriptionCount = new AtomicInteger(0);

            List<Flowable<String>> os = new ArrayList<>();
            List<SubscriptionCheckObservable> scos = new ArrayList<>();
            for (int i = 0; i < observableCount; i++) {
                SubscriptionCheckObservable sco = new SubscriptionCheckObservable(subscriptionCount, maxConcurrent);
                scos.add(sco);
                os.add(Flowable.unsafeCreate(sco));
            }

            Iterator<String> iter = Flowable.merge(os, maxConcurrent).blockingIterable().iterator();
            List<String> actual = new ArrayList<>();
            while (iter.hasNext()) {
                actual.add(iter.next());
            }
            //            System.out.println(""actual: "" + actual);
            assertEquals(5 * observableCount, actual.size());
            for (SubscriptionCheckObservable sco : scos) {
                assertFalse(sco.failed);
            }
        }
    }",loop_control
i,"{
        for (int times = 0; times < 100; times++) {
            int observableCount = 100;
            // Test maxConcurrent from 2 to 12
            int maxConcurrent = 2 + (times % 10);
            AtomicInteger subscriptionCount = new AtomicInteger(0);

            List<Flowable<String>> os = new ArrayList<>();
            List<SubscriptionCheckObservable> scos = new ArrayList<>();
            for (int i = 0; i < observableCount; i++) {
                SubscriptionCheckObservable sco = new SubscriptionCheckObservable(subscriptionCount, maxConcurrent);
                scos.add(sco);
                os.add(Flowable.unsafeCreate(sco));
            }

            Iterator<String> iter = Flowable.merge(os, maxConcurrent).blockingIterable().iterator();
            List<String> actual = new ArrayList<>();
            while (iter.hasNext()) {
                actual.add(iter.next());
            }
            //            System.out.println(""actual: "" + actual);
            assertEquals(5 * observableCount, actual.size());
            for (SubscriptionCheckObservable sco : scos) {
                assertFalse(sco.failed);
            }
        }
    }",loop_control
iter,"{
        for (int times = 0; times < 100; times++) {
            int observableCount = 100;
            // Test maxConcurrent from 2 to 12
            int maxConcurrent = 2 + (times % 10);
            AtomicInteger subscriptionCount = new AtomicInteger(0);

            List<Flowable<String>> os = new ArrayList<>();
            List<SubscriptionCheckObservable> scos = new ArrayList<>();
            for (int i = 0; i < observableCount; i++) {
                SubscriptionCheckObservable sco = new SubscriptionCheckObservable(subscriptionCount, maxConcurrent);
                scos.add(sco);
                os.add(Flowable.unsafeCreate(sco));
            }

            Iterator<String> iter = Flowable.merge(os, maxConcurrent).blockingIterable().iterator();
            List<String> actual = new ArrayList<>();
            while (iter.hasNext()) {
                actual.add(iter.next());
            }
            //            System.out.println(""actual: "" + actual);
            assertEquals(5 * observableCount, actual.size());
            for (SubscriptionCheckObservable sco : scos) {
                assertFalse(sco.failed);
            }
        }
    }",iterator
sco,"{
        for (int times = 0; times < 100; times++) {
            int observableCount = 100;
            // Test maxConcurrent from 2 to 12
            int maxConcurrent = 2 + (times % 10);
            AtomicInteger subscriptionCount = new AtomicInteger(0);

            List<Flowable<String>> os = new ArrayList<>();
            List<SubscriptionCheckObservable> scos = new ArrayList<>();
            for (int i = 0; i < observableCount; i++) {
                SubscriptionCheckObservable sco = new SubscriptionCheckObservable(subscriptionCount, maxConcurrent);
                scos.add(sco);
                os.add(Flowable.unsafeCreate(sco));
            }

            Iterator<String> iter = Flowable.merge(os, maxConcurrent).blockingIterable().iterator();
            List<String> actual = new ArrayList<>();
            while (iter.hasNext()) {
                actual.add(iter.next());
            }
            //            System.out.println(""actual: "" + actual);
            assertEquals(5 * observableCount, actual.size());
            for (SubscriptionCheckObservable sco : scos) {
                assertFalse(sco.failed);
            }
        }
    }",iterator
i,"{
        int n = 10000;
        List<Flowable<Integer>> sourceList = new ArrayList<>(n);
        for (int i = 0; i < n; i++) {
            sourceList.add(Flowable.just(i));
        }
        Iterator<Integer> it = Flowable.merge(Flowable.fromIterable(sourceList), 1).blockingIterable().iterator();
        int j = 0;
        while (it.hasNext()) {
            assertEquals((Integer)j, it.next());
            j++;
        }
        assertEquals(j, n);
    }",loop_control
it,"{
        int n = 10000;
        List<Flowable<Integer>> sourceList = new ArrayList<>(n);
        for (int i = 0; i < n; i++) {
            sourceList.add(Flowable.just(i));
        }
        Iterator<Integer> it = Flowable.merge(Flowable.fromIterable(sourceList), 1).blockingIterable().iterator();
        int j = 0;
        while (it.hasNext()) {
            assertEquals((Integer)j, it.next());
            j++;
        }
        assertEquals(j, n);
    }",iterator
it,"{
        int n = 10000;
        List<Flowable<Integer>> sourceList = new ArrayList<>(n);
        for (int i = 0; i < n; i++) {
            sourceList.add(Flowable.just(i));
        }
        Iterator<Integer> it = Flowable.merge(Flowable.fromIterable(sourceList), 1).take(n / 2).blockingIterable().iterator();
        int j = 0;
        while (it.hasNext()) {
            assertEquals((Integer)j, it.next());
            j++;
        }
        assertEquals(j, n / 2);
    }",iterator
i,"{
        int n = 10000;
        List<Flowable<Integer>> sourceList = new ArrayList<>(n);
        for (int i = 0; i < n; i++) {
            sourceList.add(Flowable.just(i));
        }
        Iterator<Integer> it = Flowable.merge(Flowable.fromIterable(sourceList), 1).take(n / 2).blockingIterable().iterator();
        int j = 0;
        while (it.hasNext()) {
            assertEquals((Integer)j, it.next());
            j++;
        }
        assertEquals(j, n / 2);
    }",loop_control
i,"{
        for (int i = 1; i < 100; i++) {
            TestSubscriberEx<Integer> ts = new TestSubscriberEx<>();
            List<Flowable<Integer>> sourceList = new ArrayList<>(i);
            List<Integer> result = new ArrayList<>(i);
            for (int j = 1; j <= i; j++) {
                sourceList.add(Flowable.just(j));
                result.add(j);
            }

            Flowable.merge(sourceList, i).subscribe(ts);

            ts.assertNoErrors();
            ts.assertTerminated();
            ts.assertValueSequence(result);
        }
    }",loop_control
j,"{
        for (int i = 1; i < 100; i++) {
            TestSubscriberEx<Integer> ts = new TestSubscriberEx<>();
            List<Flowable<Integer>> sourceList = new ArrayList<>(i);
            List<Integer> result = new ArrayList<>(i);
            for (int j = 1; j <= i; j++) {
                sourceList.add(Flowable.just(j));
                result.add(j);
            }

            Flowable.merge(sourceList, i).subscribe(ts);

            ts.assertNoErrors();
            ts.assertTerminated();
            ts.assertValueSequence(result);
        }
    }",loop_control
i,"{
        for (int i = 2; i < 100; i++) {
            TestSubscriberEx<Integer> ts = new TestSubscriberEx<>();
            List<Flowable<Integer>> sourceList = new ArrayList<>(i);
            List<Integer> result = new ArrayList<>(i);
            for (int j = 1; j <= i; j++) {
                sourceList.add(Flowable.just(j));
                result.add(j);
            }

            Flowable.merge(sourceList, i - 1).subscribe(ts);

            ts.assertNoErrors();
            ts.assertTerminated();
            ts.assertValueSequence(result);
        }
    }",loop_control
j,"{
        for (int i = 2; i < 100; i++) {
            TestSubscriberEx<Integer> ts = new TestSubscriberEx<>();
            List<Flowable<Integer>> sourceList = new ArrayList<>(i);
            List<Integer> result = new ArrayList<>(i);
            for (int j = 1; j <= i; j++) {
                sourceList.add(Flowable.just(j));
                result.add(j);
            }

            Flowable.merge(sourceList, i - 1).subscribe(ts);

            ts.assertNoErrors();
            ts.assertTerminated();
            ts.assertValueSequence(result);
        }
    }",loop_control
i,"{
        IoScheduler ios = (IoScheduler)Schedulers.io();
        int c = ios.size();
        for (int i = 0; i < 200; i++) {
            simpleAsync();
            int c1 = ios.size();
            if (c + 60 < c1) {
                throw new AssertionError(""Worker leak: "" + c + "" - "" + c1);
            }
        }
    }",loop_control
i,"{
        for (int i = 1; i < 50; i++) {
            TestSubscriber<Integer> ts = new TestSubscriber<>();
            List<Flowable<Integer>> sourceList = new ArrayList<>(i);
            Set<Integer> expected = new HashSet<>(i);
            for (int j = 1; j <= i; j++) {
                sourceList.add(Flowable.just(j).subscribeOn(Schedulers.io()));
                expected.add(j);
            }

            Flowable.merge(sourceList, i).subscribe(ts);

            ts.awaitDone(1, TimeUnit.SECONDS);
            ts.assertNoErrors();
            Set<Integer> actual = new HashSet<>(ts.values());

            assertEquals(expected, actual);
        }
    }",loop_control
j,"{
        for (int i = 1; i < 50; i++) {
            TestSubscriber<Integer> ts = new TestSubscriber<>();
            List<Flowable<Integer>> sourceList = new ArrayList<>(i);
            Set<Integer> expected = new HashSet<>(i);
            for (int j = 1; j <= i; j++) {
                sourceList.add(Flowable.just(j).subscribeOn(Schedulers.io()));
                expected.add(j);
            }

            Flowable.merge(sourceList, i).subscribe(ts);

            ts.awaitDone(1, TimeUnit.SECONDS);
            ts.assertNoErrors();
            Set<Integer> actual = new HashSet<>(ts.values());

            assertEquals(expected, actual);
        }
    }",loop_control
i,"{
        for (int i = 0; i < 200; i++) {
            simpleOneLessAsync();
        }
    }",loop_control
i,"{
        long t = System.currentTimeMillis();
        for (int i = 2; i < 50; i++) {
            if (System.currentTimeMillis() - t > TimeUnit.SECONDS.toMillis(9)) {
                break;
            }
            TestSubscriber<Integer> ts = new TestSubscriber<>();
            List<Flowable<Integer>> sourceList = new ArrayList<>(i);
            Set<Integer> expected = new HashSet<>(i);
            for (int j = 1; j <= i; j++) {
                sourceList.add(Flowable.just(j).subscribeOn(Schedulers.io()));
                expected.add(j);
            }

            Flowable.merge(sourceList, i - 1).subscribe(ts);

            ts.awaitDone(1, TimeUnit.SECONDS);
            ts.assertNoErrors();
            Set<Integer> actual = new HashSet<>(ts.values());

            assertEquals(expected, actual);
        }
    }",loop_control
t,"{
        long t = System.currentTimeMillis();
        for (int i = 2; i < 50; i++) {
            if (System.currentTimeMillis() - t > TimeUnit.SECONDS.toMillis(9)) {
                break;
            }
            TestSubscriber<Integer> ts = new TestSubscriber<>();
            List<Flowable<Integer>> sourceList = new ArrayList<>(i);
            Set<Integer> expected = new HashSet<>(i);
            for (int j = 1; j <= i; j++) {
                sourceList.add(Flowable.just(j).subscribeOn(Schedulers.io()));
                expected.add(j);
            }

            Flowable.merge(sourceList, i - 1).subscribe(ts);

            ts.awaitDone(1, TimeUnit.SECONDS);
            ts.assertNoErrors();
            Set<Integer> actual = new HashSet<>(ts.values());

            assertEquals(expected, actual);
        }
    }",break_loop_control
j,"{
        long t = System.currentTimeMillis();
        for (int i = 2; i < 50; i++) {
            if (System.currentTimeMillis() - t > TimeUnit.SECONDS.toMillis(9)) {
                break;
            }
            TestSubscriber<Integer> ts = new TestSubscriber<>();
            List<Flowable<Integer>> sourceList = new ArrayList<>(i);
            Set<Integer> expected = new HashSet<>(i);
            for (int j = 1; j <= i; j++) {
                sourceList.add(Flowable.just(j).subscribeOn(Schedulers.io()));
                expected.add(j);
            }

            Flowable.merge(sourceList, i - 1).subscribe(ts);

            ts.awaitDone(1, TimeUnit.SECONDS);
            ts.assertNoErrors();
            Set<Integer> actual = new HashSet<>(ts.values());

            assertEquals(expected, actual);
        }
    }",loop_control
i,"{
        ArrayList<Integer> list = new ArrayList<>(Flowable.bufferSize());
        for (int i = 1; i <= Flowable.bufferSize() + 1; i++) {
            list.add(i);
        }
        Flowable<Integer> f = Flowable.fromIterable(list);

        TestSubscriberEx<Integer> ts = new TestSubscriberEx<>(0L);

        ts.assertNoValues();
        ts.request(1);

        f.subscribe(ts);

        ts.assertValue(1);
        ts.request(2);
        ts.assertValues(1, 2, 3);
        ts.request(3);
        ts.assertValues(1, 2, 3, 4, 5, 6);
        ts.request(list.size());
        ts.assertTerminated();
    }",loop_control
i,"{
        Flowable<Integer> f = Flowable.fromIterable(Arrays.asList(1, 2, 3));

        for (int i = 0; i < 10; i++) {
            TestSubscriber<Integer> ts = new TestSubscriber<>();

            f.subscribe(ts);

            ts.assertValues(1, 2, 3);
            ts.assertNoErrors();
            ts.assertComplete();
        }
    }",loop_control
i,"{
        for (int i = 0; i < TestHelper.RACE_DEFAULT_LOOPS; i++) {
            final TestSubscriber<Integer> ts = new TestSubscriber<>(0L);

            Runnable r = new Runnable() {
                @Override
                public void run() {
                    ts.request(1);
                }
            };

            Flowable.fromIterable(Arrays.asList(1, 2, 3, 4))
            .filter(Functions.alwaysTrue())
            .subscribe(ts);

            TestHelper.race(r, r);
        }
    }",loop_control
i,"{
        for (int i = 0; i < TestHelper.RACE_DEFAULT_LOOPS; i++) {
            final TestSubscriber<Integer> ts = new TestSubscriber<>(0L);

            Runnable r = new Runnable() {
                @Override
                public void run() {
                    ts.request(1);
                }
            };

            Flowable.fromIterable(Arrays.asList(1, 2, 3, 4))
            .filter(Functions.alwaysFalse())
            .subscribe(ts);

            TestHelper.race(r, r);
        }
    }",loop_control
i,"{
        for (int i = 0; i < TestHelper.RACE_DEFAULT_LOOPS; i++) {
            final TestSubscriber<Integer> ts = new TestSubscriber<>(0L);

            Runnable r1 = new Runnable() {
                @Override
                public void run() {
                    ts.request(1);
                }
            };

            Runnable r2 = new Runnable() {
                @Override
                public void run() {
                    ts.cancel();
                }
            };

            Flowable.fromIterable(Arrays.asList(1, 2, 3, 4))
            .filter(Functions.alwaysTrue())
            .subscribe(ts);

            TestHelper.race(r1, r2);
        }
    }",loop_control
i,"{
        for (int i = 0; i < TestHelper.RACE_DEFAULT_LOOPS; i++) {
            final TestSubscriber<Integer> ts = new TestSubscriber<>(0L);

            Runnable r1 = new Runnable() {
                @Override
                public void run() {
                    ts.request(Long.MAX_VALUE);
                }
            };

            Runnable r2 = new Runnable() {
                @Override
                public void run() {
                    ts.cancel();
                }
            };

            Flowable.fromIterable(Arrays.asList(1, 2, 3, 4))
            .filter(Functions.alwaysTrue())
            .subscribe(ts);

            TestHelper.race(r1, r2);
        }
    }",loop_control
i,"{
        for (int i = 0; i < TestHelper.RACE_DEFAULT_LOOPS; i++) {
            final TestSubscriber<Integer> ts = new TestSubscriber<>(0L);

            Runnable r1 = new Runnable() {
                @Override
                public void run() {
                    ts.request(1);
                }
            };

            Runnable r2 = new Runnable() {
                @Override
                public void run() {
                    ts.cancel();
                }
            };

            Flowable.fromIterable(Arrays.asList(1, 2, 3, 4))
            .subscribe(ts);

            TestHelper.race(r1, r2);
        }
    }",loop_control
i,"{
        for (int i = 0; i < TestHelper.RACE_DEFAULT_LOOPS; i++) {
            final TestSubscriber<Integer> ts = new TestSubscriber<>(0L);

            Runnable r1 = new Runnable() {
                @Override
                public void run() {
                    ts.request(Long.MAX_VALUE);
                }
            };

            Runnable r2 = new Runnable() {
                @Override
                public void run() {
                    ts.cancel();
                }
            };

            Flowable.fromIterable(Arrays.asList(1, 2, 3, 4))
            .subscribe(ts);

            TestHelper.race(r1, r2);
        }
    }",loop_control
i,"{
        for (int i = 0; i < TestHelper.RACE_DEFAULT_LOOPS; i++) {
            final PublishProcessor<Integer> pp = PublishProcessor.create();
            final TestObserver<List<Integer>> to = pp.toList().test();

            Runnable r1 = new Runnable() {
                @Override
                public void run() {
                    pp.onNext(1);
                }
            };
            Runnable r2 = new Runnable() {
                @Override
                public void run() {
                    to.dispose();
                }
            };

            TestHelper.race(r1, r2);
        }
    }",loop_control
i,"{
        for (int i = 0; i < TestHelper.RACE_DEFAULT_LOOPS; i++) {
            final PublishProcessor<Integer> pp = PublishProcessor.create();
            final TestSubscriber<List<Integer>> ts = pp.toList().toFlowable().test();

            Runnable r1 = new Runnable() {
                @Override
                public void run() {
                    pp.onNext(1);
                }
            };
            Runnable r2 = new Runnable() {
                @Override
                public void run() {
                    ts.cancel();
                }
            };

            TestHelper.race(r1, r2);
        }

    }",loop_control
i,"{
        for (int i = 0; i < TestHelper.RACE_DEFAULT_LOOPS; i++) {
            final PublishProcessor<Integer> pp = PublishProcessor.create();
            final TestSubscriber<List<Integer>> ts = pp.toList().toFlowable().test();

            pp.onNext(1);

            Runnable r1 = new Runnable() {
                @Override
                public void run() {
                    pp.onComplete();
                }
            };
            Runnable r2 = new Runnable() {
                @Override
                public void run() {
                    ts.cancel();
                }
            };

            TestHelper.race(r1, r2);

            if (ts.values().size() != 0) {
                ts.assertValue(Arrays.asList(1))
                .assertNoErrors();
            }
        }
    }",loop_control
current,"{
        TestSubscriberEx<Integer> ts = new TestSubscriberEx<Integer>(1L) {
            final Random rnd = new Random();
            @Override
            public void onNext(Integer t) {
                super.onNext(t);
                if (rnd.nextDouble() < 0.001) {
                    try {
                        Thread.sleep(1);
                    } catch (InterruptedException ex) {
                        ex.printStackTrace();
                    }
                }
                request(1);
            }
        };
        int m = 100000;
        Flowable.range(1, m)
        .subscribeOn(Schedulers.computation())
        .onBackpressureLatest()
        .observeOn(Schedulers.io())
        .subscribe(ts);

        ts.awaitDone(2, TimeUnit.SECONDS);
        ts.assertTerminated();
        int n = ts.values().size();
        System.out.println(""testAsynchronousDrop -> "" + n);
        Assert.assertTrue(""All events received?"", n < m);
        int previous = 0;
        for (Integer current : ts.values()) {
            Assert.assertTrue(""The sequence must be increasing [current value="" + previous +
                    "", previous value="" + current + ""]"", previous <= current);
            previous = current;
        }
    }",iterator
current,"{
        int previous = 0;
        for (Integer current : ts.values()) {
            Assert.assertTrue(""The sequence must be increasing [current value="" + previous +
                    "", previous value="" + current + ""]"", previous <= current);
            previous = current;
        }
    }",iterator
i,"{
        TestSubscriberEx<Long> ts = createDelayedSubscriber();
        int m = 100000;
        Flowable.rangeLong(1, m)
                .subscribeOn(Schedulers.computation())
                .onBackpressureReduce(createTestSupplier(), createTestReducer())
                .observeOn(Schedulers.io())
                .concatMap(list -> Flowable.just(list.stream().reduce(Long::sum).orElseThrow(() -> {
                    throw new IllegalArgumentException(""No value in list"");
                })))
                .subscribe(ts);

        ts.awaitDone(2, TimeUnit.SECONDS);
        ts.assertTerminated();
        assertValuesDropped(ts, m);
        long sum = 0;
        for (Long i : ts.values()) {
            sum += i;
        }
        //sum = (A1 + An) * n / 2 = 100_001 * 50_000 = 50_000_00000 + 50_000 = 50_000_50_000
        Assert.assertEquals(""Wrong sum: "" + sum, 5000050000L, sum);
    }",iterator
bs,"{

        @Override
        public void subscribe(Subscriber<? super Long> s) {
            BooleanSubscription bs = new BooleanSubscription();
            s.onSubscribe(bs);
            long i = 0;
            while (!bs.isCancelled()) {
                s.onNext(i++);
            }
        }

    }",maybe_loop_control
i,"{
        return Flowable.unsafeCreate(new Publisher<Long>() {

            @Override
            public void subscribe(Subscriber<? super Long> s) {
                BooleanSubscription bs = new BooleanSubscription();
                s.onSubscribe(bs);
                for (long i = 0; i < n; i++) {
                    if (bs.isCancelled()) {
                        break;
                    }
                    s.onNext(i);
                }
                s.onComplete();
            }

        });
    }",loop_control
bs,"{
        return Flowable.unsafeCreate(new Publisher<Long>() {

            @Override
            public void subscribe(Subscriber<? super Long> s) {
                BooleanSubscription bs = new BooleanSubscription();
                s.onSubscribe(bs);
                for (long i = 0; i < n; i++) {
                    if (bs.isCancelled()) {
                        break;
                    }
                    s.onNext(i);
                }
                s.onComplete();
            }

        });
    }",break_loop_control
bs,"{
        final AtomicInteger count = new AtomicInteger();
        Flowable.unsafeCreate(new Publisher<Integer>() {

            @Override
            public void subscribe(Subscriber<? super Integer> s) {
                BooleanSubscription bs = new BooleanSubscription();
                s.onSubscribe(bs);
                for (int i = 0; !bs.isCancelled(); i++) {
                    System.out.println(""Emit: "" + i);
                    count.incrementAndGet();
                    s.onNext(i);
                }
            }

        }).take(100).take(1).blockingForEach(new Consumer<Integer>() {

            @Override
            public void accept(Integer t1) {
                System.out.println(""Receive: "" + t1);

            }

        });

        assertEquals(1, count.get());
    }",maybe_loop_control
s,"{

        final String[] values;
        Thread t;

        TestFlowableFunc(String... values) {
            this.values = values;
        }

        @Override
        public void subscribe(final Subscriber<? super String> subscriber) {
            subscriber.onSubscribe(new BooleanSubscription());
            System.out.println(""TestFlowable subscribed to ..."");
            t = new Thread(new Runnable() {

                @Override
                public void run() {
                    try {
                        System.out.println(""running TestFlowable thread"");
                        for (String s : values) {
                            System.out.println(""TestFlowable onNext: "" + s);
                            subscriber.onNext(s);
                        }
                        subscriber.onComplete();
                    } catch (Throwable e) {
                        throw new RuntimeException(e);
                    }
                }

            });
            System.out.println(""starting TestFlowable thread"");
            t.start();
            System.out.println(""done starting TestFlowable thread"");
        }
    }",iterator
bs,"{

        @Override
        public void subscribe(Subscriber<? super Long> op) {
            BooleanSubscription bs = new BooleanSubscription();
            op.onSubscribe(bs);
            long l = 1;
            while (!bs.isCancelled()) {
                op.onNext(l++);
            }
            op.onComplete();
        }

    }",maybe_loop_control
i,"{
        for (int i = 0; i < TestHelper.RACE_LONG_LOOPS; i++) {

            final TestSubscriber<Integer> ts = Flowable.range(1, 2).take(2).test(0L);

            Runnable r1 = new Runnable() {
                @Override
                public void run() {
                    ts.request(1);
                }
            };

            TestHelper.race(r1, r1);

            ts.assertResult(1, 2);
        }
    }",loop_control
s,"{

        String[] valuesToReturn;

        TestErrorFlowable(String... values) {
            valuesToReturn = values;
        }

        @Override
        public void subscribe(Subscriber<? super String> subscriber) {
            subscriber.onSubscribe(new BooleanSubscription());
            boolean errorThrown = false;
            for (String s : valuesToReturn) {
                if (s == null) {
                    System.out.println(""throwing exception"");
                    subscriber.onError(new NullPointerException());
                    errorThrown = true;
                    // purposefully not returning here so it will continue calling onNext
                    // so that we also test that we handle bad sequences like this
                } else {
                    subscriber.onNext(s);
                }
            }
            if (!errorThrown) {
                subscriber.onComplete();
            }
        }
    }",iterator
s,"{

        String[] valuesToReturn;

        TestAsyncErrorFlowable(String... values) {
            valuesToReturn = values;
        }

        Thread t;

        @Override
        public void subscribe(final Subscriber<? super String> subscriber) {
            subscriber.onSubscribe(new BooleanSubscription());
            t = new Thread(new Runnable() {

                @Override
                public void run() {
                    for (String s : valuesToReturn) {
                        if (s == null) {
                            System.out.println(""throwing exception"");
                            try {
                                Thread.sleep(100);
                            } catch (Throwable e) {

                            }
                            subscriber.onError(new NullPointerException());
                            return;
                        } else {
                            subscriber.onNext(s);
                        }
                    }
                    System.out.println(""subscription complete"");
                    subscriber.onComplete();
                }

            });
            t.start();
        }
    }",iterator
i,"{
        for (int i = 0; i < 50; i++) {
            final TestASynchronous1sDelayedFlowable f1 = new TestASynchronous1sDelayedFlowable();
            final TestASynchronous1sDelayedFlowable f2 = new TestASynchronous1sDelayedFlowable();
            Flowable<Flowable<String>> parentFlowable = Flowable.unsafeCreate(new Publisher<Flowable<String>>() {
                @Override
                public void subscribe(Subscriber<? super Flowable<String>> op) {
                    op.onSubscribe(new BooleanSubscription());
                    op.onNext(Flowable.unsafeCreate(f1));
                    op.onNext(Flowable.unsafeCreate(f2));
                    op.onError(new NullPointerException(""throwing exception in parent""));
                }
            });

            stringSubscriber = TestHelper.mockSubscriber();

            TestSubscriberEx<String> ts = new TestSubscriberEx<>(stringSubscriber);
            Flowable<String> m = Flowable.mergeDelayError(parentFlowable);
            m.subscribe(ts);
            System.out.println(""testErrorInParentFlowableDelayed | "" + i);
            ts.awaitDone(2000, TimeUnit.MILLISECONDS);
            ts.assertTerminated();

            verify(stringSubscriber, times(2)).onNext(""hello"");
            verify(stringSubscriber, times(1)).onError(any(NullPointerException.class));
            verify(stringSubscriber, never()).onComplete();
        }
    }",loop_control
i,"{
        for (int i = 1; i < 100; i++) {

            @SuppressWarnings(""unchecked"")
            Flowable<Integer>[] sources = new Flowable[i];
            Arrays.fill(sources, Flowable.just(1));
            Integer[] expected = new Integer[i];
            for (int j = 0; j < i; j++) {
                expected[j] = 1;
            }

            Flowable.mergeArrayDelayError(sources)
            .test()
            .assertResult(expected);
        }
    }",loop_control
j,"{
        for (int i = 1; i < 100; i++) {

            @SuppressWarnings(""unchecked"")
            Flowable<Integer>[] sources = new Flowable[i];
            Arrays.fill(sources, Flowable.just(1));
            Integer[] expected = new Integer[i];
            for (int j = 0; j < i; j++) {
                expected[j] = 1;
            }

            Flowable.mergeArrayDelayError(sources)
            .test()
            .assertResult(expected);
        }
    }",loop_control
it,"{
        Flowable<String> obs = Flowable.just(""one"", ""two"", ""three"");

        Iterator<String> it = obs.blockingIterable().iterator();

        assertTrue(it.hasNext());
        assertEquals(""one"", it.next());

        assertTrue(it.hasNext());
        assertEquals(""two"", it.next());

        assertTrue(it.hasNext());
        assertEquals(""three"", it.next());

        assertFalse(it.hasNext());

    }",iterator
it,"{
        Flowable<String> obs = Flowable.unsafeCreate(new Publisher<String>() {

            @Override
            public void subscribe(Subscriber<? super String> subscriber) {
                subscriber.onSubscribe(new BooleanSubscription());
                subscriber.onNext(""one"");
                subscriber.onError(new TestException());
            }
        });

        Iterator<String> it = obs.blockingIterable().iterator();

        assertTrue(it.hasNext());
        assertEquals(""one"", it.next());

        assertTrue(it.hasNext());
        it.next();
    }",iterator
it,"{
        final Counter src = new Counter();

        Flowable<Integer> obs = Flowable.fromIterable(new Iterable<Integer>() {
            @Override
            public Iterator<Integer> iterator() {
                return src;
            }
        });

        Iterator<Integer> it = obs.blockingIterable().iterator();
        while (it.hasNext()) {
            // Correct backpressure should cause this interleaved behavior.
            // We first request RxRingBuffer.SIZE. Then in increments of
            // SubscriberIterator.LIMIT.
            int i = it.next();
            int expected = i - (i % (Flowable.bufferSize() - (Flowable.bufferSize() >> 2))) + Flowable.bufferSize();
            expected = Math.min(expected, Counter.MAX);

            assertEquals(expected, src.count);
        }
    }",iterator
it,"{
        BlockingFlowableIterator<Integer> it = new BlockingFlowableIterator<>(128);
        it.remove();
    }",iterator
it,"{
        BlockingFlowableIterator<Integer> it = new BlockingFlowableIterator<>(128);

        assertFalse(it.isDisposed());

        it.dispose();

        assertTrue(it.isDisposed());
    }",iterator
it,"{
        BlockingFlowableIterator<Integer> it = new BlockingFlowableIterator<>(128);

        try {
            Thread.currentThread().interrupt();

            it.hasNext();
        } catch (RuntimeException ex) {
            assertTrue(ex.toString(), ex.getCause() instanceof InterruptedException);
        }
    }",iterator
it,"{
        BlockingFlowableIterator<Integer> it = new BlockingFlowableIterator<>(128);
        it.onComplete();
        it.next();
    }",iterator
it,"{
        Iterator<Integer> it = new Flowable<Integer>() {
            @Override
            protected void subscribeActual(Subscriber<? super Integer> s) {
                s.onSubscribe(new BooleanSubscription());
                s.onNext(1);
                s.onNext(2);
            }
        }
        .blockingIterable(1)
        .iterator();

        it.next();
    }",iterator
it,"{
        Iterator<Integer> it = PublishProcessor.<Integer>create()
                .blockingIterable().iterator();
        ((Disposable)it).dispose();
        assertFalse(it.hasNext());
        it.next();
    }",iterator
it,"{
        final Iterator<Integer> it = PublishProcessor.<Integer>create()
                .blockingIterable().iterator();

        Schedulers.single().scheduleDirect(new Runnable() {
            @Override
            public void run() {
                ((Disposable)it).dispose();
            }
        }, 1, TimeUnit.SECONDS);

        assertFalse(it.hasNext());
    }",iterator
i,"{
        for (int i = 0; i < TestHelper.RACE_DEFAULT_LOOPS; i++) {
            final PublishProcessor<Integer> pp = PublishProcessor.create();

            final TestObserver<Boolean> to = Flowable.sequenceEqual(Flowable.never(), pp).test();

            Runnable r1 = new Runnable() {
                @Override
                public void run() {
                    to.dispose();
                }
            };

            Runnable r2 = new Runnable() {
                @Override
                public void run() {
                    pp.onNext(1);
                }
            };

            TestHelper.race(r1, r2);

            to.assertEmpty();
        }
    }",loop_control
i,"{
        for (int i = 0; i < TestHelper.RACE_DEFAULT_LOOPS; i++) {
            final PublishProcessor<Integer> pp = PublishProcessor.create();

            final TestSubscriber<Boolean> ts = Flowable.sequenceEqual(Flowable.never(), pp).toFlowable().test();

            Runnable r1 = new Runnable() {
                @Override
                public void run() {
                    ts.cancel();
                }
            };

            Runnable r2 = new Runnable() {
                @Override
                public void run() {
                    pp.onNext(1);
                }
            };

            TestHelper.race(r1, r2);

            ts.assertEmpty();
        }
    }",loop_control
i,"{
        Flowable<Object> neverNever = new Flowable<Object>() {
            @Override
            protected void subscribeActual(Subscriber<? super Object> s) {
            }
        };

        for (int i = 0; i < TestHelper.RACE_DEFAULT_LOOPS; i++) {
            final TestSubscriber<Boolean> ts = new TestSubscriber<>();

            final PublishProcessor<Integer> pp = PublishProcessor.create();

            boolean swap = (i & 1) == 0;

            Flowable.sequenceEqual(swap ? pp : neverNever, swap ? neverNever : pp)
            .toFlowable()
            .subscribe(ts);

            Runnable r1 = new Runnable() {
                @Override
                public void run() {
                    pp.onNext(1);
                }
            };

            Runnable r2 = new Runnable() {
                @Override
                public void run() {
                    ts.cancel();
                }
            };

            TestHelper.race(r1, r2);

            ts.assertEmpty();
        }
    }",loop_control
i,"{
        Flowable.sequenceEqual(Flowable.never(), new Flowable<Object>() {
            @Override
            protected void subscribeActual(Subscriber<? super Object> s) {
                s.onSubscribe(new BooleanSubscription());
                for (int i = 0; i < 10; i++) {
                    s.onNext(i);
                }
            }
        }, 8)
        .toFlowable()
        .test()
        .assertFailure(MissingBackpressureException.class);
    }",loop_control
i,"{
        Flowable<Object> neverNever = new Flowable<Object>() {
            @Override
            protected void subscribeActual(Subscriber<? super Object> s) {
            }
        };

        for (int i = 0; i < TestHelper.RACE_DEFAULT_LOOPS; i++) {
            final TestObserver<Boolean> to = new TestObserver<>();

            final PublishProcessor<Integer> pp = PublishProcessor.create();

            boolean swap = (i & 1) == 0;

            Flowable.sequenceEqual(swap ? pp : neverNever, swap ? neverNever : pp)
            .subscribe(to);

            Runnable r1 = new Runnable() {
                @Override
                public void run() {
                    pp.onNext(1);
                }
            };

            Runnable r2 = new Runnable() {
                @Override
                public void run() {
                    to.dispose();
                }
            };

            TestHelper.race(r1, r2);

            to.assertEmpty();
        }
    }",loop_control
i,"{
        Flowable.sequenceEqual(Flowable.never(), new Flowable<Object>() {
            @Override
            protected void subscribeActual(Subscriber<? super Object> s) {
                s.onSubscribe(new BooleanSubscription());
                for (int i = 0; i < 10; i++) {
                    s.onNext(i);
                }
            }
        }, 8)
        .test()
        .assertFailure(MissingBackpressureException.class);
    }",loop_control
i,"{
        int n = 30;
        Function<Object[], List<Object>> func = new Function<Object[], List<Object>>() {

            @Override
            public List<Object> apply(Object[] args) {
                return Arrays.asList(args);
            }
        };
        for (int i = 1; i <= n; i++) {
            System.out.println(""test1ToNSources: "" + i + "" sources"");
            List<Flowable<Integer>> sources = new ArrayList<>();
            List<Object> values = new ArrayList<>();
            for (int j = 0; j < i; j++) {
                sources.add(Flowable.just(j));
                values.add(j);
            }

            Flowable<List<Object>> result = Flowable.combineLatest(sources, func);

            Subscriber<List<Object>> subscriber = TestHelper.mockSubscriber();

            result.subscribe(subscriber);

            verify(subscriber).onNext(values);
            verify(subscriber).onComplete();
            verify(subscriber, never()).onError(any(Throwable.class));
        }
    }",loop_control
j,"{
        int n = 30;
        Function<Object[], List<Object>> func = new Function<Object[], List<Object>>() {

            @Override
            public List<Object> apply(Object[] args) {
                return Arrays.asList(args);
            }
        };
        for (int i = 1; i <= n; i++) {
            System.out.println(""test1ToNSources: "" + i + "" sources"");
            List<Flowable<Integer>> sources = new ArrayList<>();
            List<Object> values = new ArrayList<>();
            for (int j = 0; j < i; j++) {
                sources.add(Flowable.just(j));
                values.add(j);
            }

            Flowable<List<Object>> result = Flowable.combineLatest(sources, func);

            Subscriber<List<Object>> subscriber = TestHelper.mockSubscriber();

            result.subscribe(subscriber);

            verify(subscriber).onNext(values);
            verify(subscriber).onComplete();
            verify(subscriber, never()).onError(any(Throwable.class));
        }
    }",loop_control
i,"{
        int n = 10;
        Function<Object[], List<Object>> func = new Function<Object[], List<Object>>() {

            @Override
            public List<Object> apply(Object[] args) {
                return Arrays.asList(args);
            }
        };
        for (int i = 1; i <= n; i++) {
            System.out.println(""test1ToNSourcesScheduled: "" + i + "" sources"");
            List<Flowable<Integer>> sources = new ArrayList<>();
            List<Object> values = new ArrayList<>();
            for (int j = 0; j < i; j++) {
                sources.add(Flowable.just(j).subscribeOn(Schedulers.io()));
                values.add(j);
            }

            Flowable<List<Object>> result = Flowable.combineLatest(sources, func);

            final Subscriber<List<Object>> subscriber = TestHelper.mockSubscriber();

            final CountDownLatch cdl = new CountDownLatch(1);

            Subscriber<List<Object>> s = new DefaultSubscriber<List<Object>>() {

                @Override
                public void onNext(List<Object> t) {
                    subscriber.onNext(t);
                }

                @Override
                public void onError(Throwable e) {
                    subscriber.onError(e);
                    cdl.countDown();
                }

                @Override
                public void onComplete() {
                    subscriber.onComplete();
                    cdl.countDown();
                }
            };

            result.subscribe(s);

            cdl.await();

            verify(subscriber).onNext(values);
            verify(subscriber).onComplete();
            verify(subscriber, never()).onError(any(Throwable.class));
        }
    }",loop_control
j,"{
        int n = 10;
        Function<Object[], List<Object>> func = new Function<Object[], List<Object>>() {

            @Override
            public List<Object> apply(Object[] args) {
                return Arrays.asList(args);
            }
        };
        for (int i = 1; i <= n; i++) {
            System.out.println(""test1ToNSourcesScheduled: "" + i + "" sources"");
            List<Flowable<Integer>> sources = new ArrayList<>();
            List<Object> values = new ArrayList<>();
            for (int j = 0; j < i; j++) {
                sources.add(Flowable.just(j).subscribeOn(Schedulers.io()));
                values.add(j);
            }

            Flowable<List<Object>> result = Flowable.combineLatest(sources, func);

            final Subscriber<List<Object>> subscriber = TestHelper.mockSubscriber();

            final CountDownLatch cdl = new CountDownLatch(1);

            Subscriber<List<Object>> s = new DefaultSubscriber<List<Object>>() {

                @Override
                public void onNext(List<Object> t) {
                    subscriber.onNext(t);
                }

                @Override
                public void onError(Throwable e) {
                    subscriber.onError(e);
                    cdl.countDown();
                }

                @Override
                public void onComplete() {
                    subscriber.onComplete();
                    cdl.countDown();
                }
            };

            result.subscribe(s);

            cdl.await();

            verify(subscriber).onNext(values);
            verify(subscriber).onComplete();
            verify(subscriber, never()).onError(any(Throwable.class));
        }
    }",loop_control
i,"{
        for (int i = 0; i < 5000; i++) {
            backpressure();
        }
    }",loop_control
i,"{
        int n = Flowable.bufferSize() * 3;

        List<Flowable<Integer>> sources = new ArrayList<>();

        StringBuilder expected = new StringBuilder(n * 2);

        for (int i = 0; i < n; i++) {
            sources.add(Flowable.just(i));
            expected.append(i);
        }

        TestSubscriber<String> ts = TestSubscriber.create();

        Flowable.combineLatest(sources, new Function<Object[], String>() {
            @Override
            public String apply(Object[] args) {
                StringBuilder b = new StringBuilder();
                for (Object o : args) {
                    b.append(o);
                }
                return b.toString();
            }
        }).subscribe(ts);

        ts.assertNoErrors();
        ts.assertValue(expected.toString());
        ts.assertComplete();
    }",loop_control
o,"{
        int n = Flowable.bufferSize() * 3;

        List<Flowable<Integer>> sources = new ArrayList<>();

        StringBuilder expected = new StringBuilder(n * 2);

        for (int i = 0; i < n; i++) {
            sources.add(Flowable.just(i));
            expected.append(i);
        }

        TestSubscriber<String> ts = TestSubscriber.create();

        Flowable.combineLatest(sources, new Function<Object[], String>() {
            @Override
            public String apply(Object[] args) {
                StringBuilder b = new StringBuilder();
                for (Object o : args) {
                    b.append(o);
                }
                return b.toString();
            }
        }).subscribe(ts);

        ts.assertNoErrors();
        ts.assertValue(expected.toString());
        ts.assertComplete();
    }",iterator
i,"{
        Flowable source = Flowable.just(1);

        for (int i = 2; i < 10; i++) {
            Class<?>[] types = new Class[i + 1];
            Arrays.fill(types, Publisher.class);
            types[i] = i == 2 ? BiFunction.class : Class.forName(""io.reactivex.rxjava3.functions.Function"" + i);

            Method m = Flowable.class.getMethod(""combineLatest"", types);

            Object[] params = new Object[i + 1];
            Arrays.fill(params, source);
            params[i] = ArgsToString.INSTANCE;

            StringBuilder b = new StringBuilder();
            for (int j = 0; j < i; j++) {
                b.append('1');
            }

            ((Flowable)m.invoke(null, params)).test().assertResult(b.toString());

            for (int j = 0; j < params.length; j++) {
                Object[] params0 = params.clone();
                params0[j] = null;

                try {
                    m.invoke(null, params0);
                    fail(""Should have thrown @ "" + m);
                } catch (InvocationTargetException ex) {
                    assertTrue(ex.toString(), ex.getCause() instanceof NullPointerException);

                    if (j < i) {
                        assertEquals(""source"" + (j + 1) + "" is null"", ex.getCause().getMessage());
                    } else {
                        assertEquals(""combiner is null"", ex.getCause().getMessage());
                    }
                }
            }
        }
    }",loop_control
j,"{
        Flowable source = Flowable.just(1);

        for (int i = 2; i < 10; i++) {
            Class<?>[] types = new Class[i + 1];
            Arrays.fill(types, Publisher.class);
            types[i] = i == 2 ? BiFunction.class : Class.forName(""io.reactivex.rxjava3.functions.Function"" + i);

            Method m = Flowable.class.getMethod(""combineLatest"", types);

            Object[] params = new Object[i + 1];
            Arrays.fill(params, source);
            params[i] = ArgsToString.INSTANCE;

            StringBuilder b = new StringBuilder();
            for (int j = 0; j < i; j++) {
                b.append('1');
            }

            ((Flowable)m.invoke(null, params)).test().assertResult(b.toString());

            for (int j = 0; j < params.length; j++) {
                Object[] params0 = params.clone();
                params0[j] = null;

                try {
                    m.invoke(null, params0);
                    fail(""Should have thrown @ "" + m);
                } catch (InvocationTargetException ex) {
                    assertTrue(ex.toString(), ex.getCause() instanceof NullPointerException);

                    if (j < i) {
                        assertEquals(""source"" + (j + 1) + "" is null"", ex.getCause().getMessage());
                    } else {
                        assertEquals(""combiner is null"", ex.getCause().getMessage());
                    }
                }
            }
        }
    }",loop_control
i,"{
        for (int i = 1; i < 100; i++) {
            Flowable<Integer>[] sources = new Flowable[i];
            Arrays.fill(sources, Flowable.just(1));
            List<Object> expected = new ArrayList<>(i);
            for (int j = 1; j <= i; j++) {
                expected.add(1);
            }

            Flowable.combineLatestArray(sources, new Function<Object[], List<Object>>() {
                @Override
                public List<Object> apply(Object[] t) throws Exception {
                    return Arrays.asList(t);
                }
            })
            .test()
            .assertResult(expected);

            Flowable.combineLatestArrayDelayError(sources, new Function<Object[], List<Object>>() {
                @Override
                public List<Object> apply(Object[] t) throws Exception {
                    return Arrays.asList(t);
                }
            })
            .test()
            .assertResult(expected);
        }
    }",loop_control
j,"{
        for (int i = 1; i < 100; i++) {
            Flowable<Integer>[] sources = new Flowable[i];
            Arrays.fill(sources, Flowable.just(1));
            List<Object> expected = new ArrayList<>(i);
            for (int j = 1; j <= i; j++) {
                expected.add(1);
            }

            Flowable.combineLatestArray(sources, new Function<Object[], List<Object>>() {
                @Override
                public List<Object> apply(Object[] t) throws Exception {
                    return Arrays.asList(t);
                }
            })
            .test()
            .assertResult(expected);

            Flowable.combineLatestArrayDelayError(sources, new Function<Object[], List<Object>>() {
                @Override
                public List<Object> apply(Object[] t) throws Exception {
                    return Arrays.asList(t);
                }
            })
            .test()
            .assertResult(expected);
        }
    }",loop_control
i,"{
        for (int i = 0; i < TestHelper.RACE_DEFAULT_LOOPS; i++) {
            List<Throwable> errors = TestHelper.trackPluginErrors();
            try {
                final PublishProcessor<Integer> pp1 = PublishProcessor.create();
                final PublishProcessor<Integer> pp2 = PublishProcessor.create();

                TestSubscriberEx<Integer> ts = Flowable.combineLatest(pp1, pp2, new BiFunction<Integer, Integer, Integer>() {
                    @Override
                    public Integer apply(Integer a, Integer b) throws Exception {
                        return a;
                    }
                }).to(TestHelper.<Integer>testConsumer());

                final TestException ex1 = new TestException();
                final TestException ex2 = new TestException();

                Runnable r1 = new Runnable() {
                    @Override
                    public void run() {
                        pp1.onError(ex1);
                    }
                };
                Runnable r2 = new Runnable() {
                    @Override
                    public void run() {
                        pp2.onError(ex2);
                    }
                };

                TestHelper.race(r1, r2);

                if (ts.errors().size() != 0) {
                    if (ts.errors().get(0) instanceof CompositeException) {
                        ts.assertSubscribed()
                        .assertNotComplete()
                        .assertNoValues();

                        for (Throwable e : TestHelper.errorList(ts)) {
                            assertTrue(e.toString(), e instanceof TestException);
                        }

                    } else {
                        ts.assertFailure(TestException.class);
                    }
                }

                for (Throwable e : errors) {
                    assertTrue(e.toString(), e.getCause() instanceof TestException);
                }
            } finally {
                RxJavaPlugins.reset();
            }
        }
    }",loop_control
e,"{
        for (int i = 0; i < TestHelper.RACE_DEFAULT_LOOPS; i++) {
            List<Throwable> errors = TestHelper.trackPluginErrors();
            try {
                final PublishProcessor<Integer> pp1 = PublishProcessor.create();
                final PublishProcessor<Integer> pp2 = PublishProcessor.create();

                TestSubscriberEx<Integer> ts = Flowable.combineLatest(pp1, pp2, new BiFunction<Integer, Integer, Integer>() {
                    @Override
                    public Integer apply(Integer a, Integer b) throws Exception {
                        return a;
                    }
                }).to(TestHelper.<Integer>testConsumer());

                final TestException ex1 = new TestException();
                final TestException ex2 = new TestException();

                Runnable r1 = new Runnable() {
                    @Override
                    public void run() {
                        pp1.onError(ex1);
                    }
                };
                Runnable r2 = new Runnable() {
                    @Override
                    public void run() {
                        pp2.onError(ex2);
                    }
                };

                TestHelper.race(r1, r2);

                if (ts.errors().size() != 0) {
                    if (ts.errors().get(0) instanceof CompositeException) {
                        ts.assertSubscribed()
                        .assertNotComplete()
                        .assertNoValues();

                        for (Throwable e : TestHelper.errorList(ts)) {
                            assertTrue(e.toString(), e instanceof TestException);
                        }

                    } else {
                        ts.assertFailure(TestException.class);
                    }
                }

                for (Throwable e : errors) {
                    assertTrue(e.toString(), e.getCause() instanceof TestException);
                }
            } finally {
                RxJavaPlugins.reset();
            }
        }
    }",iterator
i,"{
        for (int i = 0; i < TestHelper.RACE_DEFAULT_LOOPS; i++) {

            TestSubscriber<Integer> ts = new TestSubscriber<>();
            PublishProcessor<Integer> pp = PublishProcessor.create();

            Flowable.combineLatest(pp, Flowable.never(), (a, b) -> a)
            .subscribe(ts);

            TestHelper.race(() -> pp.onComplete(), () -> ts.cancel());
        }
    }",loop_control
i,"{
        TestHelper.withErrorTracking(errors -> {
            TestException ex = new TestException();

            for (int i = 0; i < TestHelper.RACE_DEFAULT_LOOPS; i++) {

                TestSubscriberEx<Object[]> ts = new TestSubscriberEx<>();
                AtomicReference<Subscriber<? super Object>> ref = new AtomicReference<>();
                Flowable<Object> f = new Flowable<Object>() {
                    @Override
                    public void subscribeActual(Subscriber<? super Object> s) {
                        ref.set(s);
                    }
                };

                Flowable.combineLatestDelayError(Arrays.asList(f, Flowable.never()), (a) -> a)
                .subscribe(ts);

                ref.get().onSubscribe(new BooleanSubscription());

                TestHelper.race(() -> ref.get().onError(ex), () -> ts.cancel());

                if (ts.errors().isEmpty()) {
                    TestHelper.assertUndeliverable(errors, 0, TestException.class);
                }
            }
        });
    }",loop_control
i,"{
        Flowable<Object> source = Flowable.generate(new Supplier<Object>() {
            @Override
            public Object get() throws Exception {
                return 1;
            }
        }, new BiConsumer<Object, Emitter<Object>>() {
            @Override
            public void accept(Object s, Emitter<Object> e) throws Exception {
                e.onNext(1);
            }
        }, Functions.emptyConsumer());

        for (int i = 0; i < TestHelper.RACE_DEFAULT_LOOPS; i++) {
            final TestSubscriber<Object> ts = source.test(0L);

            Runnable r = new Runnable() {
                @Override
                public void run() {
                    for (int j = 0; j < 500; j++) {
                        ts.request(1);
                    }
                }
            };

            TestHelper.race(r, r);

            ts.assertValueCount(1000);
        }
    }",loop_control
j,"{
        Flowable<Object> source = Flowable.generate(new Supplier<Object>() {
            @Override
            public Object get() throws Exception {
                return 1;
            }
        }, new BiConsumer<Object, Emitter<Object>>() {
            @Override
            public void accept(Object s, Emitter<Object> e) throws Exception {
                e.onNext(1);
            }
        }, Functions.emptyConsumer());

        for (int i = 0; i < TestHelper.RACE_DEFAULT_LOOPS; i++) {
            final TestSubscriber<Object> ts = source.test(0L);

            Runnable r = new Runnable() {
                @Override
                public void run() {
                    for (int j = 0; j < 500; j++) {
                        ts.request(1);
                    }
                }
            };

            TestHelper.race(r, r);

            ts.assertValueCount(1000);
        }
    }",loop_control
i,"{
        for (int i = 0; i < TestHelper.RACE_DEFAULT_LOOPS; i++) {
            final PublishProcessor<Object> pp1 = PublishProcessor.create();
            final PublishProcessor<Object> pp2 = PublishProcessor.create();

            List<Throwable> errors = TestHelper.trackPluginErrors();

            try {
                TestSubscriberEx<Flowable<Integer>> ts = Flowable.just(1)
                .groupJoin(
                    Flowable.just(2).concatWith(Flowable.<Integer>never()),
                    new Function<Integer, Flowable<Object>>() {
                        @Override
                        public Flowable<Object> apply(Integer left) throws Exception {
                            return pp1;
                        }
                    },
                    new Function<Integer, Flowable<Object>>() {
                        @Override
                        public Flowable<Object> apply(Integer right) throws Exception {
                            return pp2;
                        }
                    },
                    new BiFunction<Integer, Flowable<Integer>, Flowable<Integer>>() {
                        @Override
                        public Flowable<Integer> apply(Integer r, Flowable<Integer> l) throws Exception {
                            return l;
                        }
                    }
                )
                .to(TestHelper.<Flowable<Integer>>testConsumer());

                final TestException ex1 = new TestException();
                final TestException ex2 = new TestException();

                Runnable r1 = new Runnable() {
                    @Override
                    public void run() {
                        pp1.onError(ex1);
                    }
                };
                Runnable r2 = new Runnable() {
                    @Override
                    public void run() {
                        pp2.onError(ex2);
                    }
                };

                TestHelper.race(r1, r2);

                ts.assertError(Throwable.class).assertSubscribed().assertNotComplete().assertValueCount(1);

                Throwable exc = ts.errors().get(0);

                if (exc instanceof CompositeException) {
                    List<Throwable> es = TestHelper.compositeList(exc);
                    TestHelper.assertError(es, 0, TestException.class);
                    TestHelper.assertError(es, 1, TestException.class);
                } else {
                    ts.assertError(TestException.class);
                }

                if (!errors.isEmpty()) {
                    TestHelper.assertUndeliverable(errors, 0, TestException.class);
                }
            } finally {
                RxJavaPlugins.reset();
            }
        }
    }",loop_control
i,"{
        for (int i = 0; i < TestHelper.RACE_DEFAULT_LOOPS; i++) {
            final PublishProcessor<Object> pp1 = PublishProcessor.create();
            final PublishProcessor<Object> pp2 = PublishProcessor.create();

            List<Throwable> errors = TestHelper.trackPluginErrors();

            try {
                TestSubscriberEx<Object> ts = pp1
                .groupJoin(
                    pp2,
                    new Function<Object, Flowable<Object>>() {
                        @Override
                        public Flowable<Object> apply(Object left) throws Exception {
                            return Flowable.never();
                        }
                    },
                    new Function<Object, Flowable<Object>>() {
                        @Override
                        public Flowable<Object> apply(Object right) throws Exception {
                            return Flowable.never();
                        }
                    },
                    new BiFunction<Object, Flowable<Object>, Flowable<Object>>() {
                        @Override
                        public Flowable<Object> apply(Object r, Flowable<Object> l) throws Exception {
                            return l;
                        }
                    }
                )
                .flatMap(Functions.<Flowable<Object>>identity())
                .to(TestHelper.<Object>testConsumer());

                final TestException ex1 = new TestException();
                final TestException ex2 = new TestException();

                Runnable r1 = new Runnable() {
                    @Override
                    public void run() {
                        pp1.onError(ex1);
                    }
                };
                Runnable r2 = new Runnable() {
                    @Override
                    public void run() {
                        pp2.onError(ex2);
                    }
                };

                TestHelper.race(r1, r2);

                ts.assertError(Throwable.class).assertSubscribed().assertNotComplete().assertNoValues();

                Throwable exc = ts.errors().get(0);

                if (exc instanceof CompositeException) {
                    List<Throwable> es = TestHelper.compositeList(exc);
                    TestHelper.assertError(es, 0, TestException.class);
                    TestHelper.assertError(es, 1, TestException.class);
                } else {
                    ts.assertError(TestException.class);
                }

                if (!errors.isEmpty()) {
                    TestHelper.assertUndeliverable(errors, 0, TestException.class);
                }
            } finally {
                RxJavaPlugins.reset();
            }
        }
    }",loop_control
i,"{
        for (int i = 0; i < TestHelper.RACE_DEFAULT_LOOPS; i++) {
            TestSubscriber<Integer> ts = new TestSubscriber<>();
            final ScalarSubscription<Integer> sd = new ScalarSubscription<>(ts, 1);
            ts.onSubscribe(sd);

            Runnable r1 = new Runnable() {
                @Override
                public void run() {
                    sd.request(1);
                }
            };

            Runnable r2 = new Runnable() {
                @Override
                public void run() {
                    sd.cancel();
                }
            };

            TestHelper.race(r1, r2);
        }
    }",loop_control
i,"{
        Iterable<Integer> it = Flowable.range(1, 300).blockingIterable();
        for (int i = 0; i < 5; i++) {
            Flowable<Integer> f = Flowable.just(it, it)
            .flatMapIterable(Functions.<Iterable<Integer>>identity());

            for (int j = 0; j < i; j++) {
                f = f.share();
            }

            f
            .count()
            .test()
            .withTag(""Share: "" + i)
            .assertResult(600L);
        }
    }",loop_control
j,"{
        Iterable<Integer> it = Flowable.range(1, 300).blockingIterable();
        for (int i = 0; i < 5; i++) {
            Flowable<Integer> f = Flowable.just(it, it)
            .flatMapIterable(Functions.<Iterable<Integer>>identity());

            for (int j = 0; j < i; j++) {
                f = f.share();
            }

            f
            .count()
            .test()
            .withTag(""Share: "" + i)
            .assertResult(600L);
        }
    }",loop_control
i,"{
        Iterable<Integer> it = Flowable.range(1, 300).blockingIterable();
        for (int i = 0; i < 5; i++) {
            Flowable<Integer> f = Flowable.just(it, it)
            .flatMapIterable(Functions.<Iterable<Integer>>identity())
            .hide();

            for (int j = 0; j < i; j++) {
                f = f.share();
            }

            f
            .count()
            .test()
            .withTag(""Share: "" + i)
            .assertResult(600L);
        }
    }",loop_control
j,"{
        Iterable<Integer> it = Flowable.range(1, 300).blockingIterable();
        for (int i = 0; i < 5; i++) {
            Flowable<Integer> f = Flowable.just(it, it)
            .flatMapIterable(Functions.<Iterable<Integer>>identity())
            .hide();

            for (int j = 0; j < i; j++) {
                f = f.share();
            }

            f
            .count()
            .test()
            .withTag(""Share: "" + i)
            .assertResult(600L);
        }
    }",loop_control
i,"{

        PublishProcessor<String> o1 = PublishProcessor.create();
        PublishProcessor<String> o2 = PublishProcessor.create();
        PublishProcessor<String> o3 = PublishProcessor.create();

        PublishProcessor<PublishProcessor<String>> o = PublishProcessor.create();

        publishNext(o, 0, o1);
        publishNext(o, 5, o2);
        publishNext(o, 10, o3);
        publishCompleted(o, 15);

        for (int i = 0; i < 10; i++) {
            publishNext(o1, i * 5, ""a"" + (i + 1));
            publishNext(o2, 5 + i * 5, ""b"" + (i + 1));
            publishNext(o3, 10 + i * 5, ""c"" + (i + 1));
        }

        publishCompleted(o1, 45);
        publishCompleted(o2, 50);
        publishCompleted(o3, 55);

        final TestSubscriberEx<String> testSubscriber = new TestSubscriberEx<>();
        Flowable.switchOnNext(o).subscribe(new DefaultSubscriber<String>() {

            private int requested;

            @Override
            public void onStart() {
                requested = 3;
                request(3);
                testSubscriber.onSubscribe(new BooleanSubscription());
            }

            @Override
            public void onComplete() {
                testSubscriber.onComplete();
            }

            @Override
            public void onError(Throwable e) {
                testSubscriber.onError(e);
            }

            @Override
            public void onNext(String s) {
                testSubscriber.onNext(s);
                requested--;
                if (requested == 0) {
                    requested = 3;
                    request(3);
                }
            }
        });
        scheduler.advanceTimeBy(1, TimeUnit.SECONDS);
        testSubscriber.assertValues(""a1"", ""b1"", ""c1"", ""c2"", ""c3"", ""c4"", ""c5"", ""c6"", ""c7"", ""c8"", ""c9"", ""c10"");
        testSubscriber.assertNoErrors();
        testSubscriber.assertTerminated();
    }",loop_control
i,"{
        for (int i = 0; i < TestHelper.RACE_DEFAULT_LOOPS; i++) {
            List<Throwable> errors = TestHelper.trackPluginErrors();
            try {

                final PublishProcessor<Integer> pp1 = PublishProcessor.create();
                final PublishProcessor<Integer> pp2 = PublishProcessor.create();

                pp1.switchMap(new Function<Integer, Flowable<Integer>>() {
                    @Override
                    public Flowable<Integer> apply(Integer v) throws Exception {
                        if (v == 1) {
                            return pp2;
                        }
                        return Flowable.never();
                    }
                })
                .test();

                Runnable r1 = new Runnable() {
                    @Override
                    public void run() {
                        pp1.onNext(2);
                    }
                };

                final TestException ex = new TestException();

                Runnable r2 = new Runnable() {
                    @Override
                    public void run() {
                        pp2.onError(ex);
                    }
                };

                TestHelper.race(r1, r2);

                for (Throwable e : errors) {
                    assertTrue(e.toString(), e instanceof TestException);
                }
            } finally {
                RxJavaPlugins.reset();
            }
        }
    }",loop_control
e,"{
        for (int i = 0; i < TestHelper.RACE_DEFAULT_LOOPS; i++) {
            List<Throwable> errors = TestHelper.trackPluginErrors();
            try {

                final PublishProcessor<Integer> pp1 = PublishProcessor.create();
                final PublishProcessor<Integer> pp2 = PublishProcessor.create();

                pp1.switchMap(new Function<Integer, Flowable<Integer>>() {
                    @Override
                    public Flowable<Integer> apply(Integer v) throws Exception {
                        if (v == 1) {
                            return pp2;
                        }
                        return Flowable.never();
                    }
                })
                .test();

                Runnable r1 = new Runnable() {
                    @Override
                    public void run() {
                        pp1.onNext(2);
                    }
                };

                final TestException ex = new TestException();

                Runnable r2 = new Runnable() {
                    @Override
                    public void run() {
                        pp2.onError(ex);
                    }
                };

                TestHelper.race(r1, r2);

                for (Throwable e : errors) {
                    assertTrue(e.toString(), e instanceof TestException);
                }
            } finally {
                RxJavaPlugins.reset();
            }
        }
    }",iterator
i,"{
        for (int i = 0; i < TestHelper.RACE_DEFAULT_LOOPS; i++) {
            List<Throwable> errors = TestHelper.trackPluginErrors();
            try {

                final PublishProcessor<Integer> pp1 = PublishProcessor.create();
                final PublishProcessor<Integer> pp2 = PublishProcessor.create();

                pp1.switchMap(new Function<Integer, Flowable<Integer>>() {
                    @Override
                    public Flowable<Integer> apply(Integer v) throws Exception {
                        if (v == 1) {
                            return pp2;
                        }
                        return Flowable.never();
                    }
                })
                .test();

                final TestException ex1 = new TestException();

                Runnable r1 = new Runnable() {
                    @Override
                    public void run() {
                        pp1.onError(ex1);
                    }
                };

                final TestException ex2 = new TestException();

                Runnable r2 = new Runnable() {
                    @Override
                    public void run() {
                        pp2.onError(ex2);
                    }
                };

                TestHelper.race(r1, r2);

                for (Throwable e : errors) {
                    assertTrue(e.toString(), e instanceof TestException);
                }
            } finally {
                RxJavaPlugins.reset();
            }
        }
    }",loop_control
e,"{
        for (int i = 0; i < TestHelper.RACE_DEFAULT_LOOPS; i++) {
            List<Throwable> errors = TestHelper.trackPluginErrors();
            try {

                final PublishProcessor<Integer> pp1 = PublishProcessor.create();
                final PublishProcessor<Integer> pp2 = PublishProcessor.create();

                pp1.switchMap(new Function<Integer, Flowable<Integer>>() {
                    @Override
                    public Flowable<Integer> apply(Integer v) throws Exception {
                        if (v == 1) {
                            return pp2;
                        }
                        return Flowable.never();
                    }
                })
                .test();

                final TestException ex1 = new TestException();

                Runnable r1 = new Runnable() {
                    @Override
                    public void run() {
                        pp1.onError(ex1);
                    }
                };

                final TestException ex2 = new TestException();

                Runnable r2 = new Runnable() {
                    @Override
                    public void run() {
                        pp2.onError(ex2);
                    }
                };

                TestHelper.race(r1, r2);

                for (Throwable e : errors) {
                    assertTrue(e.toString(), e instanceof TestException);
                }
            } finally {
                RxJavaPlugins.reset();
            }
        }
    }",iterator
i,"{
        for (int i = 0; i < TestHelper.RACE_DEFAULT_LOOPS; i++) {
            final PublishProcessor<Integer> pp1 = PublishProcessor.create();

            final TestSubscriber<Integer> ts = pp1.switchMap(new Function<Integer, Flowable<Integer>>() {
                @Override
                public Flowable<Integer> apply(Integer v) throws Exception {
                    return Flowable.never();
                }
            })
            .test();

            Runnable r1 = new Runnable() {
                @Override
                public void run() {
                    pp1.onNext(2);
                }
            };

            Runnable r2 = new Runnable() {
                @Override
                public void run() {
                    ts.cancel();
                }
            };

            TestHelper.race(r1, r2);
        }
    }",loop_control
i,"{
        Flowable.just(1).hide()
        .switchMap(Functions.justFunction(new Flowable<Integer>() {
            @Override
            protected void subscribeActual(Subscriber<? super Integer> s) {
                s.onSubscribe(new BooleanSubscription());
                for (int i = 0; i < 10; i++) {
                    s.onNext(i);
                }
            }
        }), 8)
        .test(1L)
        .assertFailure(MissingBackpressureException.class, 0);
    }",loop_control
i,"{
        for (int i = 0; i < TestHelper.RACE_DEFAULT_LOOPS; i++) {
            final TestSubscriber<Integer> ts = new TestSubscriber<>();

            final PublishProcessor<Integer> pp = PublishProcessor.create();

            Flowable.just(1).hide()
            .switchMap(Functions.justFunction(pp))
            .subscribe(ts);

            Runnable r1 = new Runnable() {
                @Override
                public void run() {
                    ts.cancel();
                }
            };

            Runnable r2 = new Runnable() {
                @Override
                public void run() {
                    pp.onNext(1);
                }
            };

            TestHelper.race(r1, r2);
        }
    }",loop_control
i,"{
        AtomicInteger outer = new AtomicInteger();
        AtomicInteger inner = new AtomicInteger();

        int n = 10_000;
        for (int i = 0; i < n; i++) {
            Flowable.<Integer>create(it -> {
                it.onNext(0);
            }, BackpressureStrategy.MISSING)
            .switchMap(v -> createFlowable(inner))
            .observeOn(Schedulers.computation())
            .doFinally(() -> {
                outer.incrementAndGet();
            })
            .take(1)
            .blockingSubscribe(v -> { }, Throwable::printStackTrace);
        }

        Thread.sleep(100);
        assertEquals(inner.get(), outer.get());
        assertEquals(n, inner.get());
    }",loop_control
i,"{
        TestSubscriberEx<Integer> ts = Flowable.range(1, 10).concatWith(Flowable.<Integer>error(new TestException()))
        .flatMapSingle(new Function<Integer, SingleSource<Integer>>() {
            @Override
            public SingleSource<Integer> apply(Integer v) throws Exception {
                return Single.error(new TestException());
            }
        }, true, Integer.MAX_VALUE)
        .to(TestHelper.<Integer>testConsumer())
        .assertFailure(CompositeException.class);

        List<Throwable> errors = TestHelper.compositeList(ts.errors().get(0));

        for (int i = 0; i < 11; i++) {
            TestHelper.assertError(errors, i, TestException.class);
        }
    }",loop_control
i,"{
        for (int i = 0; i < TestHelper.RACE_DEFAULT_LOOPS; i++) {
            final TestSubscriber<Integer> ts = Flowable.just(1).concatWith(Flowable.<Integer>never())
            .flatMapSingle(Functions.justFunction(Single.just(2))).test(0);

            Runnable r1 = new Runnable() {
                @Override
                public void run() {
                    ts.request(1);
                }
            };
            Runnable r2 = new Runnable() {
                @Override
                public void run() {
                    ts.cancel();
                }
            };

            TestHelper.race(r1, r2);
        }
    }",loop_control
i,"{
        for (int i = 0; i < TestHelper.RACE_DEFAULT_LOOPS; i++) {
            SingleSubject<Integer> ss1 = SingleSubject.create();
            SingleSubject<Integer> ss2 = SingleSubject.create();

            TestSubscriber<Integer> ts = Flowable.just(ss1, ss2).flatMapSingle(v -> v)
            .test();

            TestHelper.race(
                    () -> ss1.onSuccess(1),
                    () -> ss2.onSuccess(1)
            );

            ts.assertResult(1, 1);
        }
    }",loop_control
i,"{
        for (int i = 0; i < 500; i++) {
            if (i % 10 == 0) {
                System.out.println(""testNestedAsyncConcat >> "" + i);
            }
            nestedAsyncConcat();
        }
    }",loop_control
i,"{
        final int n = 10000;
        Flowable<Flowable<Integer>> source = Flowable.range(0, n).map(new Function<Integer, Flowable<Integer>>() {
            @Override
            public Flowable<Integer> apply(Integer v) {
                return Flowable.just(v);
            }
        });

        Single<List<Integer>> result = Flowable.concat(source).toList();

        SingleObserver<List<Integer>> o = TestHelper.mockSingleObserver();
        InOrder inOrder = inOrder(o);

        result.subscribe(o);

        List<Integer> list = new ArrayList<>(n);
        for (int i = 0; i < n; i++) {
            list.add(i);
        }
        inOrder.verify(o).onSuccess(list);
        verify(o, never()).onError(any(Throwable.class));
    }",loop_control
i,"{
        final int n = 10000;
        Flowable<Flowable<Integer>> source = Flowable.range(0, n).map(new Function<Integer, Flowable<Integer>>() {
            @Override
            public Flowable<Integer> apply(Integer v) {
                return Flowable.just(v);
            }
        });

        Single<List<Integer>> result = Flowable.concat(source).take(n / 2).toList();

        SingleObserver<List<Integer>> o = TestHelper.mockSingleObserver();
        InOrder inOrder = inOrder(o);

        result.subscribe(o);

        List<Integer> list = new ArrayList<>(n);
        for (int i = 0; i < n / 2; i++) {
            list.add(i);
        }
        inOrder.verify(o).onSuccess(list);
        verify(o, never()).onError(any(Throwable.class));
    }",loop_control
i,"{
        for (int i = 2; i < 10; i++) {
            Flowable<Integer>[] obs = new Flowable[i];
            Arrays.fill(obs, Flowable.just(1));

            Integer[] expected = new Integer[i];
            Arrays.fill(expected, 1);

            Method m = Flowable.class.getMethod(""concatArray"", Publisher[].class);

            TestSubscriber<Integer> ts = TestSubscriber.create();

            ((Flowable<Integer>)m.invoke(null, new Object[]{obs})).subscribe(ts);

            ts.assertValues(expected);
            ts.assertNoErrors();
            ts.assertComplete();
        }
    }",loop_control
i,"{
        new Flowable<Integer>() {
            @Override
            protected void subscribeActual(Subscriber<? super Integer> s) {
                s.onSubscribe(new BooleanSubscription());
                for (int i = 0; i < 10; i++) {
                    s.onNext(i);
                }
            }
        }
        .concatMap(Functions.justFunction(Flowable.just(2)), 8)
        .test(0L)
        .assertFailure(IllegalStateException.class);
    }",loop_control
b,"{
        int n = 2 * Flowable.bufferSize();

        for (int b = 1; b <= n; b *= 2) {
            List<Integer> list = Flowable.range(1, n)
            .scan(0, new BiFunction<Integer, Integer, Integer>() {
                @Override
                public Integer apply(Integer a, Integer b) throws Exception {
                    return b;
                }
            })
            .rebatchRequests(b)
            .toList()
            .blockingGet();

            for (int i = 0; i <= n; i++) {
                assertEquals(i, list.get(i).intValue());
            }
        }
    }",loop_control
i,"{
        int n = 2 * Flowable.bufferSize();

        for (int b = 1; b <= n; b *= 2) {
            List<Integer> list = Flowable.range(1, n)
            .scan(0, new BiFunction<Integer, Integer, Integer>() {
                @Override
                public Integer apply(Integer a, Integer b) throws Exception {
                    return b;
                }
            })
            .rebatchRequests(b)
            .toList()
            .blockingGet();

            for (int i = 0; i <= n; i++) {
                assertEquals(i, list.get(i).intValue());
            }
        }
    }",loop_control
s,"{

        final String[] values;
        Thread t;

        TestFlowable(String... values) {
            this.values = values;
        }

        @Override
        public void subscribe(final Subscriber<? super String> subscriber) {
            subscriber.onSubscribe(new BooleanSubscription());
            System.out.println(""TestFlowable subscribed to ..."");
            t = new Thread(new Runnable() {

                @Override
                public void run() {
                    try {
                        System.out.println(""running TestFlowable thread"");
                        for (String s : values) {
                            System.out.println(""TestFlowable onNext: "" + s);
                            subscriber.onNext(s);
                        }
                        throw new RuntimeException(""Forced Failure"");
                    } catch (Throwable e) {
                        subscriber.onError(e);
                    }
                }

            });
            System.out.println(""starting TestFlowable thread"");
            t.start();
            System.out.println(""done starting TestFlowable thread"");
        }
    }",iterator
i,"{
        List<Throwable> errors = TestHelper.trackPluginErrors();

        try {
            final PublishProcessor<Integer> source = PublishProcessor.create();
            final PublishProcessor<Integer> signaller = PublishProcessor.create();

            for (int i = 0; i < TestHelper.RACE_DEFAULT_LOOPS; i++) {

                TestSubscriber<Integer> ts = source.take(1)
                .repeatWhen(new Function<Flowable<Object>, Flowable<Integer>>() {
                    @Override
                    public Flowable<Integer> apply(Flowable<Object> v)
                            throws Exception {
                        return signaller;
                    }
                }).test();

                Runnable r1 = new Runnable() {
                    @Override
                    public void run() {
                        for (int i = 0; i < TestHelper.RACE_DEFAULT_LOOPS; i++) {
                            source.onNext(1);
                        }
                    }
                };
                Runnable r2 = new Runnable() {
                    @Override
                    public void run() {
                        for (int i = 0; i < TestHelper.RACE_DEFAULT_LOOPS; i++) {
                            signaller.offer(1);
                        }
                    }
                };

                TestHelper.race(r1, r2);

                ts.cancel();
            }

            if (!errors.isEmpty()) {
                for (Throwable e : errors) {
                    e.printStackTrace();
                }
                fail(errors + """");
            }
        } finally {
            RxJavaPlugins.reset();
        }
    }",loop_control
e,"{
        List<Throwable> errors = TestHelper.trackPluginErrors();

        try {
            final PublishProcessor<Integer> source = PublishProcessor.create();
            final PublishProcessor<Integer> signaller = PublishProcessor.create();

            for (int i = 0; i < TestHelper.RACE_DEFAULT_LOOPS; i++) {

                TestSubscriber<Integer> ts = source.take(1)
                .repeatWhen(new Function<Flowable<Object>, Flowable<Integer>>() {
                    @Override
                    public Flowable<Integer> apply(Flowable<Object> v)
                            throws Exception {
                        return signaller;
                    }
                }).test();

                Runnable r1 = new Runnable() {
                    @Override
                    public void run() {
                        for (int i = 0; i < TestHelper.RACE_DEFAULT_LOOPS; i++) {
                            source.onNext(1);
                        }
                    }
                };
                Runnable r2 = new Runnable() {
                    @Override
                    public void run() {
                        for (int i = 0; i < TestHelper.RACE_DEFAULT_LOOPS; i++) {
                            signaller.offer(1);
                        }
                    }
                };

                TestHelper.race(r1, r2);

                ts.cancel();
            }

            if (!errors.isEmpty()) {
                for (Throwable e : errors) {
                    e.printStackTrace();
                }
                fail(errors + """");
            }
        } finally {
            RxJavaPlugins.reset();
        }
    }",iterator
i,"{
        TestSubscriberEx<Integer> ts = Flowable.range(1, 10).concatWith(Flowable.<Integer>error(new TestException()))
        .flatMapCompletable(new Function<Integer, CompletableSource>() {
            @Override
            public CompletableSource apply(Integer v) throws Exception {
                return Completable.error(new TestException());
            }
        }, true, Integer.MAX_VALUE).<Integer>toFlowable()
        .to(TestHelper.<Integer>testConsumer())
        .assertFailure(CompositeException.class);

        List<Throwable> errors = TestHelper.compositeList(ts.errors().get(0));

        for (int i = 0; i < 11; i++) {
            TestHelper.assertError(errors, i, TestException.class);
        }
    }",loop_control
i,"{
        TestSubscriberEx<Integer> ts = Flowable.range(1, 10)
        .flatMapCompletable(new Function<Integer, CompletableSource>() {
            @Override
            public CompletableSource apply(Integer v) throws Exception {
                return Completable.error(new TestException());
            }
        }, true, Integer.MAX_VALUE).<Integer>toFlowable()
        .to(TestHelper.<Integer>testConsumer())
        .assertFailure(CompositeException.class);

        List<Throwable> errors = TestHelper.compositeList(ts.errors().get(0));

        for (int i = 0; i < 10; i++) {
            TestHelper.assertError(errors, i, TestException.class);
        }
    }",loop_control
i,"{
        TestObserverEx<Void> to = Flowable.range(1, 10).concatWith(Flowable.<Integer>error(new TestException()))
        .flatMapCompletable(new Function<Integer, CompletableSource>() {
            @Override
            public CompletableSource apply(Integer v) throws Exception {
                return Completable.error(new TestException());
            }
        }, true, Integer.MAX_VALUE)
        .to(TestHelper.<Integer>testConsumer())
        .assertFailure(CompositeException.class);

        List<Throwable> errors = TestHelper.compositeList(to.errors().get(0));

        for (int i = 0; i < 11; i++) {
            TestHelper.assertError(errors, i, TestException.class);
        }
    }",loop_control
i,"{
        TestObserverEx<Void> to = Flowable.range(1, 10)
        .flatMapCompletable(new Function<Integer, CompletableSource>() {
            @Override
            public CompletableSource apply(Integer v) throws Exception {
                return Completable.error(new TestException());
            }
        }, true, Integer.MAX_VALUE)
        .to(TestHelper.<Integer>testConsumer())
        .assertFailure(CompositeException.class);

        List<Throwable> errors = TestHelper.compositeList(to.errors().get(0));

        for (int i = 0; i < 10; i++) {
            TestHelper.assertError(errors, i, TestException.class);
        }
    }",loop_control
itemCount,"{
        for (int itemCount = 1; itemCount <= 100000; itemCount *= 10) {
            for (int concurrency = 1; concurrency <= 256; concurrency *= 2) {
                Flowable.range(1, itemCount)
                .flatMapCompletable(
                        Functions.justFunction(Completable.complete()
                        .subscribeOn(Schedulers.computation()))
                        , false, concurrency)
                .test()
                .withTag(""itemCount="" + itemCount + "", concurrency="" + concurrency)
                .awaitDone(5, TimeUnit.SECONDS)
                .assertResult();
            }
        }
    }",iterator
concurrency,"{
        for (int itemCount = 1; itemCount <= 100000; itemCount *= 10) {
            for (int concurrency = 1; concurrency <= 256; concurrency *= 2) {
                Flowable.range(1, itemCount)
                .flatMapCompletable(
                        Functions.justFunction(Completable.complete()
                        .subscribeOn(Schedulers.computation()))
                        , false, concurrency)
                .test()
                .withTag(""itemCount="" + itemCount + "", concurrency="" + concurrency)
                .awaitDone(5, TimeUnit.SECONDS)
                .assertResult();
            }
        }
    }",iterator
i,"{
        for (int i = 0; i < TestHelper.RACE_DEFAULT_LOOPS; i++) {
            PublishProcessor<Integer> pp1 = PublishProcessor.create();

            TestSubscriber<Object> ts = new TestSubscriber<>();
            CountDownLatch cdl = new CountDownLatch(1);

            pp1.flatMapCompletable(v -> {
                TestHelper.raceOther(() -> {
                    ts.cancel();
                }, cdl);
                return Completable.complete();
            })
            .toFlowable()
            .subscribe(ts);

            pp1.onNext(1);

            cdl.await();
        }
    }",loop_control
i,"{
        for (int i = 0; i < TestHelper.RACE_DEFAULT_LOOPS; i++) {
            PublishProcessor<Integer> pp1 = PublishProcessor.create();

            TestObserver<Void> to = new TestObserver<>();
            CountDownLatch cdl = new CountDownLatch(1);

            pp1.flatMapCompletable(v -> {
                TestHelper.raceOther(() -> {
                    to.dispose();
                }, cdl);
                return Completable.complete();
            })
            .subscribe(to);

            pp1.onNext(1);

            cdl.await();
        }
    }",loop_control
arg,"{
        List<String> list = new ArrayList<>();
        for (String arg : args) {
            list.add(arg);
        }
        return list;
    }",iterator
i,"{
        for (int i = 0; i < TestHelper.RACE_DEFAULT_LOOPS; i++) {
            final TestScheduler scheduler = new TestScheduler();

            final PublishProcessor<Object> pp = PublishProcessor.create();

            TestSubscriber<List<Object>> ts = pp.buffer(1, TimeUnit.SECONDS, scheduler, 5).test();

            pp.onNext(1);
            pp.onNext(2);
            pp.onNext(3);
            pp.onNext(4);

            Runnable r1 = new Runnable() {
                @Override
                public void run() {
                    pp.onNext(5);
                }
            };

            Runnable r2 = new Runnable() {
                @Override
                public void run() {
                    scheduler.advanceTimeBy(1, TimeUnit.SECONDS);
                }
            };

            TestHelper.race(r1, r2);

            pp.onComplete();

            int items = 0;
            for (List<Object> o : ts.values()) {
                items += o.size();
            }

            assertEquals(""Round: "" + i, 5, items);
        }
    }",loop_control
o,"{
        for (int i = 0; i < TestHelper.RACE_DEFAULT_LOOPS; i++) {
            final TestScheduler scheduler = new TestScheduler();

            final PublishProcessor<Object> pp = PublishProcessor.create();

            TestSubscriber<List<Object>> ts = pp.buffer(1, TimeUnit.SECONDS, scheduler, 5).test();

            pp.onNext(1);
            pp.onNext(2);
            pp.onNext(3);
            pp.onNext(4);

            Runnable r1 = new Runnable() {
                @Override
                public void run() {
                    pp.onNext(5);
                }
            };

            Runnable r2 = new Runnable() {
                @Override
                public void run() {
                    scheduler.advanceTimeBy(1, TimeUnit.SECONDS);
                }
            };

            TestHelper.race(r1, r2);

            pp.onComplete();

            int items = 0;
            for (List<Object> o : ts.values()) {
                items += o.size();
            }

            assertEquals(""Round: "" + i, 5, items);
        }
    }",iterator
i,"{
        for (int i = 0; i < TestHelper.RACE_DEFAULT_LOOPS; i++) {
            BehaviorProcessor<Integer> bp = BehaviorProcessor.createDefault(1);
            PublishProcessor<Integer> pp = PublishProcessor.create();

            TestSubscriber<List<Integer>> ts = bp
                    .buffer(BehaviorProcessor.createDefault(0), v -> pp)
                    .test();

            TestHelper.race(
                    () -> bp.onComplete(),
                    () -> pp.onComplete()
            );

            ts.assertResult(Arrays.asList(1));
        }
    }",loop_control
i,"{
        // Flaky
        for (int i = 0; i < 10; i++) {
            try {
                refCountAsyncActual();
                return;
            } catch (AssertionError ex) {
                if (i == 9) {
                    throw ex;
                }
                Thread.sleep((int)(200 * (Math.random() * 10 + 1)));
            }
        }
    }",loop_control
a,"{
        final AtomicInteger subscribeCount = new AtomicInteger();
        final AtomicInteger nextCount = new AtomicInteger();
        Flowable<Long> r = Flowable.interval(0, 20, TimeUnit.MILLISECONDS)
                .doOnSubscribe(new Consumer<Subscription>() {
                    @Override
                    public void accept(Subscription s) {
                        subscribeCount.incrementAndGet();
                    }
                })
                .doOnNext(new Consumer<Long>() {
                    @Override
                    public void accept(Long l) {
                        nextCount.incrementAndGet();
                    }
                })
                .publish().refCount();

        final AtomicInteger receivedCount = new AtomicInteger();
        Disposable d1 = r.subscribe(new Consumer<Long>() {
            @Override
            public void accept(Long l) {
                receivedCount.incrementAndGet();
            }
        });

        Disposable d2 = r.subscribe();

        try {
            Thread.sleep(10);
        } catch (InterruptedException e) {
        }

        for (;;) {
            int a = nextCount.get();
            int b = receivedCount.get();
            if (a > 10 && a < 20 && a == b) {
                break;
            }
            if (a >= 20) {
                break;
            }
            try {
                Thread.sleep(20);
            } catch (InterruptedException e) {
            }
        }
        // give time to emit

        // now unsubscribe
        d2.dispose(); // unsubscribe s2 first as we're counting in 1 and there can be a race between unsubscribe and one subscriber getting a value but not the other
        d1.dispose();

        System.out.println(""onNext: "" + nextCount.get());

        // should emit once for both subscribers
        assertEquals(nextCount.get(), receivedCount.get());
        // only 1 subscribe
        assertEquals(1, subscribeCount.get());
    }",break_loop_control
b,"{
        final AtomicInteger subscribeCount = new AtomicInteger();
        final AtomicInteger nextCount = new AtomicInteger();
        Flowable<Long> r = Flowable.interval(0, 20, TimeUnit.MILLISECONDS)
                .doOnSubscribe(new Consumer<Subscription>() {
                    @Override
                    public void accept(Subscription s) {
                        subscribeCount.incrementAndGet();
                    }
                })
                .doOnNext(new Consumer<Long>() {
                    @Override
                    public void accept(Long l) {
                        nextCount.incrementAndGet();
                    }
                })
                .publish().refCount();

        final AtomicInteger receivedCount = new AtomicInteger();
        Disposable d1 = r.subscribe(new Consumer<Long>() {
            @Override
            public void accept(Long l) {
                receivedCount.incrementAndGet();
            }
        });

        Disposable d2 = r.subscribe();

        try {
            Thread.sleep(10);
        } catch (InterruptedException e) {
        }

        for (;;) {
            int a = nextCount.get();
            int b = receivedCount.get();
            if (a > 10 && a < 20 && a == b) {
                break;
            }
            if (a >= 20) {
                break;
            }
            try {
                Thread.sleep(20);
            } catch (InterruptedException e) {
            }
        }
        // give time to emit

        // now unsubscribe
        d2.dispose(); // unsubscribe s2 first as we're counting in 1 and there can be a race between unsubscribe and one subscriber getting a value but not the other
        d1.dispose();

        System.out.println(""onNext: "" + nextCount.get());

        // should emit once for both subscribers
        assertEquals(nextCount.get(), receivedCount.get());
        // only 1 subscribe
        assertEquals(1, subscribeCount.get());
    }",maybe_loop_control
i,"{
        final AtomicInteger subscribeCount = new AtomicInteger();
        final AtomicInteger unsubscribeCount = new AtomicInteger();
        Flowable<Long> r = Flowable.interval(0, 1, TimeUnit.MILLISECONDS)
                .doOnSubscribe(new Consumer<Subscription>() {
                    @Override
                    public void accept(Subscription s) {
                            System.out.println(""******************************* Subscribe received"");
                            // when we are subscribed
                            subscribeCount.incrementAndGet();
                    }
                })
                .doOnCancel(new Action() {
                    @Override
                    public void run() {
                            System.out.println(""******************************* Unsubscribe received"");
                            // when we are unsubscribed
                            unsubscribeCount.incrementAndGet();
                    }
                })
                .publish().refCount();

        for (int i = 0; i < 10; i++) {
            TestSubscriber<Long> ts1 = new TestSubscriber<>();
            TestSubscriber<Long> ts2 = new TestSubscriber<>();
            r.subscribe(ts1);
            r.subscribe(ts2);
            try {
                Thread.sleep(50);
            } catch (InterruptedException e) {
            }
            ts1.cancel();
            ts2.cancel();
            ts1.assertNoErrors();
            ts2.assertNoErrors();
            assertTrue(ts1.values().size() > 0);
            assertTrue(ts2.values().size() > 0);
        }

        assertEquals(10, subscribeCount.get());
        assertEquals(10, unsubscribeCount.get());
    }",loop_control
i,"{
        for (int i = 0; i < 100; i++) {
            connectUnsubscribeRaceCondition();
        }
    }",loop_control
cancel,"{
        return Flowable.unsafeCreate(new Publisher<Long>() {
            @Override
            public void subscribe(Subscriber<? super Long> subscriber) {
                final AtomicBoolean cancel = new AtomicBoolean();
                subscriber.onSubscribe(new Subscription() {
                    @Override
                    public void request(long n) {

                    }

                    @Override
                    public void cancel() {
                        cancel.set(true);
                    }

                });
                for (;;) {
                    if (cancel.get()) {
                        break;
                    }
                    try {
                        Thread.sleep(100);
                    } catch (InterruptedException e) {
                    }
                    subscriber.onNext(1L);
                }
            }
        });
    }",break_loop_control
emitter,"{
        BehaviorProcessor<Integer> bp = BehaviorProcessor.createDefault(1);

        Flowable<Integer> f = bp
        .replay(1)
        .refCount();

        f.subscribe();

        final AtomicBoolean interrupted = new AtomicBoolean();

        f.switchMap(new Function<Integer, Publisher<? extends Object>>() {
            @Override
            public Publisher<? extends Object> apply(Integer v) throws Exception {
                return Flowable.create(new FlowableOnSubscribe<Object>() {
                    @Override
                    public void subscribe(FlowableEmitter<Object> emitter) throws Exception {
                        while (!emitter.isCancelled()) {
                            Thread.sleep(100);
                        }
                        interrupted.set(true);
                    }
                }, BackpressureStrategy.MISSING);
            }
        })
        .takeUntil(Flowable.timer(500, TimeUnit.MILLISECONDS))
        .test()
        .awaitDone(5, TimeUnit.SECONDS)
        .assertResult();

        assertTrue(interrupted.get());
    }",maybe_loop_control
i,"{
        final int[] subscriptions = { 0 };

        Flowable<Integer> source = Flowable.range(1, 5)
        .doOnSubscribe(new Consumer<Subscription>() {
            @Override
            public void accept(Subscription s) throws Exception {
                subscriptions[0]++;
            }
        })
        .publish()
        .refCount(2);

        for (int i = 0; i < 3; i++) {
            TestSubscriber<Integer> ts1 = source.test();

            ts1.assertEmpty();

            TestSubscriber<Integer> ts2 = source.test();

            ts1.assertResult(1, 2, 3, 4, 5);
            ts2.assertResult(1, 2, 3, 4, 5);
        }

        assertEquals(3, subscriptions[0]);
    }",loop_control
i,"{
        PublishProcessor<Integer> pp = PublishProcessor.create();

        Flowable<Integer> source = pp
        .publish()
        .refCount(1);

        TestSubscriber<Integer> ts1 = source.test(0);

        assertTrue(pp.hasSubscribers());

        for (int i = 0; i < 3; i++) {
            TestSubscriber<Integer> ts2 = source.test();
            ts1.cancel();
            ts1 = ts2;
        }

        ts1.cancel();

        assertFalse(pp.hasSubscribers());
    }",loop_control
i,"{
        for (int i = 0; i < 1000; i++) {

            final Flowable<Integer> source = Flowable.range(1, 5)
                    .replay()
                    .refCount(1)
                    ;

            final TestSubscriber<Integer> ts1 = source.test(0);

            final TestSubscriber<Integer> ts2 = new TestSubscriber<>(0);

            Runnable r1 = new Runnable() {
                @Override
                public void run() {
                    ts1.cancel();
                }
            };

            Runnable r2 = new Runnable() {
                @Override
                public void run() {
                    source.subscribe(ts2);
                }
            };

            TestHelper.race(r1, r2, Schedulers.single());

            ts2.requestMore(6) // FIXME RxJava replay() doesn't issue onComplete without request
            .withTag(""Round: "" + i)
            .assertResult(1, 2, 3, 4, 5);
        }
    }",loop_control
i,"{
        for (int i = 0; i < TestHelper.RACE_LONG_LOOPS; i++) {
            Flowable<Integer> flowable = Flowable.just(1).replay(1).refCount();

            TestSubscriber<Integer> ts1 = flowable
                    .subscribeOn(Schedulers.io())
                    .test();

            TestSubscriber<Integer> ts2 = flowable
                    .subscribeOn(Schedulers.io())
                    .test();

            ts1
            .withTag("""" + i)
            .awaitDone(5, TimeUnit.SECONDS)
            .assertResult(1);

            ts2
            .withTag("""" + i)
            .awaitDone(5, TimeUnit.SECONDS)
            .assertResult(1);
        }
    }",loop_control
i,"{
        for (int i = 0; i < TestHelper.RACE_LONG_LOOPS; i++) {
            Flowable<Integer> flowable = Flowable.just(1).publish().refCount();

            TestSubscriber<Integer> subscriber1 = flowable
                    .subscribeOn(Schedulers.io())
                    .test();

            TestSubscriber<Integer> subscriber2 = flowable
                    .subscribeOn(Schedulers.io())
                    .test();

            subscriber1
            .withTag(""subscriber1 "" + i)
            .awaitDone(5, TimeUnit.SECONDS)
            .assertNoErrors()
            .assertComplete();

            subscriber2
            .withTag(""subscriber2 "" + i)
            .awaitDone(5, TimeUnit.SECONDS)
            .assertNoErrors()
            .assertComplete();
        }
    }",loop_control
i,"{
        TestSubscriber<Integer> ts = new TestSubscriber<>();
        final AtomicInteger count = new AtomicInteger();
        Flowable.unsafeCreate(new Publisher<Integer>() {

            @Override
            public void subscribe(Subscriber<? super Integer> sub) {
                BooleanSubscription bs = new BooleanSubscription();
                sub.onSubscribe(bs);
                for (int i = 1; !bs.isCancelled(); i++) {
                    count.incrementAndGet();
                    sub.onNext(i);
                }
            }

        }).subscribeOn(Schedulers.newThread()).take(10).subscribe(ts);

        ts.awaitDone(1000, TimeUnit.MILLISECONDS);
        ts.cancel();
        Thread.sleep(200); // give time for the loop to continue
        ts.assertValues(1, 2, 3, 4, 5, 6, 7, 8, 9, 10);
        assertEquals(10, count.get());
    }",loop_control
i,"{
        for (int i = 0; i < TestHelper.RACE_DEFAULT_LOOPS; i++) {

            final TestSubscriber<Integer> ts = new TestSubscriber<>(0L);

            Worker w = Schedulers.computation().createWorker();

            final SubscribeOnSubscriber<Integer> so = new SubscribeOnSubscriber<>(ts, w, Flowable.<Integer>never(), true);
            ts.onSubscribe(so);

            final BooleanSubscription bs = new BooleanSubscription();

            try {
                Runnable r1 = new Runnable() {
                    @Override
                    public void run() {
                        so.onSubscribe(bs);
                    }
                };

                Runnable r2 = new Runnable() {
                    @Override
                    public void run() {
                        so.request(1);
                    }
                };

                TestHelper.race(r1, r2);
            } finally {
                w.dispose();
            }
        }
    }",loop_control
i,"{
        TestSubscriber<Object> ts = Flowable.create(new FlowableOnSubscribe<Object>() {
            @Override
            public void subscribe(FlowableEmitter<Object> s) throws Exception {
                for (int i = 1; i < 1001; i++) {
                    s.onNext(i);
                    Thread.sleep(1);
                }
                s.onComplete();
            }
        }, BackpressureStrategy.DROP)
        .subscribeOn(Schedulers.single())
        .observeOn(Schedulers.computation())
        .test()
        .awaitDone(20, TimeUnit.SECONDS)
        .assertNoErrors()
        .assertComplete();

        int c = ts.values().size();

        assertTrue("""" + c, c > Flowable.bufferSize());
    }",loop_control
i,"{
        Flowable.create(new FlowableOnSubscribe<Object>() {
            @Override
            public void subscribe(FlowableEmitter<Object> s) throws Exception {
                for (int i = 1; i < 1001; i++) {
                    s.onNext(i);
                    Thread.sleep(1);
                }
                s.onComplete();
            }
        }, BackpressureStrategy.DROP)
        .map(Functions.identity())
        .subscribeOn(Schedulers.single())
        .observeOn(Schedulers.computation())
        .test()
        .awaitDone(20, TimeUnit.SECONDS)
        .assertValueCount(Flowable.bufferSize())
        .assertNoErrors()
        .assertComplete();
    }",loop_control
i,"{
        TestSubscriber<Object> ts = Flowable.create(new FlowableOnSubscribe<Object>() {
            @Override
            public void subscribe(FlowableEmitter<Object> s) throws Exception {
                for (int i = 1; i < 1001; i++) {
                    s.onNext(i);
                    Thread.sleep(1);
                }
                s.onComplete();
            }
        }, BackpressureStrategy.DROP)
        .map(Functions.identity())
        .subscribeOn(Schedulers.single(), false)
        .observeOn(Schedulers.computation())
        .test()
        .awaitDone(20, TimeUnit.SECONDS)
        .assertNoErrors()
        .assertComplete();

        int c = ts.values().size();

        assertTrue("""" + c, c > Flowable.bufferSize());
    }",loop_control
i,"{
        Flowable.create(new FlowableOnSubscribe<Object>() {
            @Override
            public void subscribe(FlowableEmitter<Object> s) throws Exception {
                for (int i = 1; i < 1001; i++) {
                    s.onNext(i);
                    Thread.sleep(1);
                }
                s.onComplete();
            }
        }, BackpressureStrategy.DROP)
        .map(Functions.identity())
        .subscribeOn(Schedulers.single(), true)
        .observeOn(Schedulers.computation())
        .test()
        .awaitDone(20, TimeUnit.SECONDS)
        .assertValueCount(Flowable.bufferSize())
        .assertNoErrors()
        .assertComplete();
    }",loop_control
i,"{

        for (int i = 0; i < TestHelper.RACE_DEFAULT_LOOPS; i++) {
            final AtomicInteger count = new AtomicInteger();

            Cancellable c = new Cancellable() {
                @Override
                public void cancel() throws Exception {
                    count.getAndIncrement();
                }
            };

            final CancellableDisposable cd = new CancellableDisposable(c);

            Runnable r = new Runnable() {
                @Override
                public void run() {
                    cd.dispose();
                }
            };

            TestHelper.race(r, r);

            assertEquals(1, count.get());
        }
    }",loop_control
i,"{
        for (int i = 0; i < TestHelper.RACE_DEFAULT_LOOPS; i++) {
            final ListCompositeDisposable cd = new ListCompositeDisposable();

            Runnable run = new Runnable() {
                @Override
                public void run() {
                    cd.dispose();
                }
            };

            TestHelper.race(run, run);
        }
    }",loop_control
i,"{
        for (int i = 0; i < TestHelper.RACE_DEFAULT_LOOPS; i++) {
            final ListCompositeDisposable cd = new ListCompositeDisposable();

            Runnable run = new Runnable() {
                @Override
                public void run() {
                    cd.add(Disposable.empty());
                }
            };

            TestHelper.race(run, run);
        }
    }",loop_control
i,"{
        for (int i = 0; i < TestHelper.RACE_DEFAULT_LOOPS; i++) {
            final ListCompositeDisposable cd = new ListCompositeDisposable();

            Runnable run = new Runnable() {
                @Override
                public void run() {
                    cd.addAll(Disposable.empty());
                }
            };

            TestHelper.race(run, run);
        }
    }",loop_control
i,"{
        for (int i = 0; i < TestHelper.RACE_DEFAULT_LOOPS; i++) {
            final ListCompositeDisposable cd = new ListCompositeDisposable();

            final Disposable d1 = Disposable.empty();

            cd.add(d1);

            Runnable run = new Runnable() {
                @Override
                public void run() {
                    cd.remove(d1);
                }
            };

            TestHelper.race(run, run);
        }
    }",loop_control
i,"{
        for (int i = 0; i < TestHelper.RACE_DEFAULT_LOOPS; i++) {
            final ListCompositeDisposable cd = new ListCompositeDisposable();

            final Disposable d1 = Disposable.empty();

            cd.add(d1);

            Runnable run = new Runnable() {
                @Override
                public void run() {
                    cd.delete(d1);
                }
            };

            TestHelper.race(run, run);
        }
    }",loop_control
i,"{
        for (int i = 0; i < TestHelper.RACE_DEFAULT_LOOPS; i++) {
            final ListCompositeDisposable cd = new ListCompositeDisposable();

            final Disposable d1 = Disposable.empty();

            cd.add(d1);

            Runnable run = new Runnable() {
                @Override
                public void run() {
                    cd.clear();
                }
            };

            TestHelper.race(run, run);
        }
    }",loop_control
i,"{
        for (int i = 0; i < TestHelper.RACE_DEFAULT_LOOPS; i++) {
            final ListCompositeDisposable cd = new ListCompositeDisposable();

            Runnable run = new Runnable() {
                @Override
                public void run() {
                    cd.dispose();
                }
            };

            Runnable run2 = new Runnable() {
                @Override
                public void run() {
                    cd.add(Disposable.empty());
                }
            };

            TestHelper.race(run, run2);
        }
    }",loop_control
i,"{
        for (int i = 0; i < TestHelper.RACE_DEFAULT_LOOPS; i++) {
            final ListCompositeDisposable cd = new ListCompositeDisposable();

            Runnable run = new Runnable() {
                @Override
                public void run() {
                    cd.dispose();
                }
            };

            Runnable run2 = new Runnable() {
                @Override
                public void run() {
                    cd.addAll(Disposable.empty());
                }
            };

            TestHelper.race(run, run2);
        }
    }",loop_control
i,"{
        for (int i = 0; i < TestHelper.RACE_DEFAULT_LOOPS; i++) {
            final ListCompositeDisposable cd = new ListCompositeDisposable();

            final Disposable d1 = Disposable.empty();

            cd.add(d1);

            Runnable run = new Runnable() {
                @Override
                public void run() {
                    cd.dispose();
                }
            };

            Runnable run2 = new Runnable() {
                @Override
                public void run() {
                    cd.remove(d1);
                }
            };

            TestHelper.race(run, run2);
        }
    }",loop_control
i,"{
        for (int i = 0; i < TestHelper.RACE_DEFAULT_LOOPS; i++) {
            final ListCompositeDisposable cd = new ListCompositeDisposable();

            final Disposable d1 = Disposable.empty();

            cd.add(d1);

            Runnable run = new Runnable() {
                @Override
                public void run() {
                    cd.dispose();
                }
            };

            Runnable run2 = new Runnable() {
                @Override
                public void run() {
                    cd.delete(d1);
                }
            };

            TestHelper.race(run, run2);
        }
    }",loop_control
i,"{
        for (int i = 0; i < TestHelper.RACE_DEFAULT_LOOPS; i++) {
            final ListCompositeDisposable cd = new ListCompositeDisposable();

            final Disposable d1 = Disposable.empty();

            cd.add(d1);

            Runnable run = new Runnable() {
                @Override
                public void run() {
                    cd.dispose();
                }
            };

            Runnable run2 = new Runnable() {
                @Override
                public void run() {
                    cd.clear();
                }
            };

            TestHelper.race(run, run2);
        }
    }",loop_control
i,"{
        for (int i = 0; i < TestHelper.RACE_DEFAULT_LOOPS; i++) {
            final AtomicReference<Disposable> d = new AtomicReference<>();

            Runnable r = new Runnable() {
                @Override
                public void run() {
                    DisposableHelper.dispose(d);
                }
            };

            TestHelper.race(r, r);
        }
    }",loop_control
i,"{
        for (int i = 0; i < TestHelper.RACE_DEFAULT_LOOPS; i++) {
            final AtomicReference<Disposable> d = new AtomicReference<>();

            Runnable r = new Runnable() {
                @Override
                public void run() {
                    DisposableHelper.replace(d, Disposable.empty());
                }
            };

            TestHelper.race(r, r);
        }
    }",loop_control
i,"{
        for (int i = 0; i < TestHelper.RACE_DEFAULT_LOOPS; i++) {
            final AtomicReference<Disposable> d = new AtomicReference<>();

            Runnable r = new Runnable() {
                @Override
                public void run() {
                    DisposableHelper.set(d, Disposable.empty());
                }
            };

            TestHelper.race(r, r);
        }
    }",loop_control
i,"{
        for (int i = 0; i < TestHelper.RACE_DEFAULT_LOOPS; i++) {
            final ArrayCompositeDisposable acd = new ArrayCompositeDisposable(2);

            Runnable r = new Runnable() {
                @Override
                public void run() {
                    acd.dispose();
                }
            };

            TestHelper.race(r, r);
        }
    }",loop_control
i,"{
        for (int i = 0; i < TestHelper.RACE_DEFAULT_LOOPS; i++) {
            final ArrayCompositeDisposable acd = new ArrayCompositeDisposable(2);

            Runnable r = new Runnable() {
                @Override
                public void run() {
                    acd.replaceResource(0, Disposable.empty());
                }
            };

            TestHelper.race(r, r);
        }
    }",loop_control
i,"{
        for (int i = 0; i < TestHelper.RACE_DEFAULT_LOOPS; i++) {
            final ArrayCompositeDisposable acd = new ArrayCompositeDisposable(2);

            Runnable r = new Runnable() {
                @Override
                public void run() {
                    acd.setResource(0, Disposable.empty());
                }
            };

            TestHelper.race(r, r);
        }
    }",loop_control
o,"{
        // inlined TestHelper.checkEnum due to access restrictions
        try {
            Method m = Functions.HashSetSupplier.class.getMethod(""values"");
            m.setAccessible(true);
            Method e = Functions.HashSetSupplier.class.getMethod(""valueOf"", String.class);
            e.setAccessible(true);

            for (Enum<HashSetSupplier> o : (Enum<HashSetSupplier>[])m.invoke(null)) {
                assertSame(o, e.invoke(null, o.name()));
            }

        } catch (Throwable ex) {
            throw ExceptionHelper.wrapOrThrow(ex);
        }
    }",iterator
o,"{
        // inlined TestHelper.checkEnum due to access restrictions
        try {
            Method m = Functions.NaturalComparator.class.getMethod(""values"");
            m.setAccessible(true);
            Method e = Functions.NaturalComparator.class.getMethod(""valueOf"", String.class);
            e.setAccessible(true);

            for (Enum<NaturalComparator> o : (Enum<NaturalComparator>[])m.invoke(null)) {
                assertSame(o, e.invoke(null, o.name()));
            }

        } catch (Throwable ex) {
            throw ExceptionHelper.wrapOrThrow(ex);
        }
    }",iterator
i,"{
        for (int i = 0; i < TestHelper.RACE_DEFAULT_LOOPS; i++) {
            final Future<?> f = Single.never().toFuture();

            Runnable r = new Runnable() {
                @Override
                public void run() {
                    f.cancel(true);
                }
            };

            TestHelper.race(r, r);
        }
    }",loop_control
i,"{
        for (int i = 0; i < TestHelper.RACE_DEFAULT_LOOPS; i++) {
            final PublishSubject<Integer> ps = PublishSubject.create();

            final Future<?> f = ps.single(-99).toFuture();

            ps.onNext(1);

            Runnable r1 = new Runnable() {
                @Override
                public void run() {
                    f.cancel(true);
                }
            };

            Runnable r2 = new Runnable() {
                @Override
                public void run() {
                    ps.onComplete();
                }
            };

            TestHelper.race(r1, r2);
        }
    }",loop_control
i,"{
        RxJavaPlugins.setErrorHandler(Functions.emptyConsumer());
        try {
            for (int i = 0; i < TestHelper.RACE_DEFAULT_LOOPS; i++) {
                final PublishSubject<Integer> ps = PublishSubject.create();

                final Future<?> f = ps.single(-99).toFuture();

                final TestException ex = new TestException();

                Runnable r1 = new Runnable() {
                    @Override
                    public void run() {
                        f.cancel(true);
                    }
                };

                Runnable r2 = new Runnable() {
                    @Override
                    public void run() {
                        ps.onError(ex);
                    }
                };

                TestHelper.race(r1, r2);
            }
        } finally {
            RxJavaPlugins.reset();
        }
    }",loop_control
i,"{

        fo.dispose();

        assertFalse(fo.isCancelled());
        assertFalse(fo.isDisposed());
        assertFalse(fo.isDone());

        for (int i = 0; i < 2; i++) {
            fo.cancel(i == 0);

            assertTrue(fo.isCancelled());
            assertTrue(fo.isDisposed());
            assertTrue(fo.isDone());
        }

        List<Throwable> errors = TestHelper.trackPluginErrors();
        try {
            fo.onNext(1);
            fo.onError(new TestException(""First""));
            fo.onError(new TestException(""Second""));
            fo.onComplete();

            assertTrue(fo.isCancelled());
            assertTrue(fo.isDisposed());
            assertTrue(fo.isDone());

            TestHelper.assertUndeliverable(errors, 0, TestException.class);
            TestHelper.assertUndeliverable(errors, 1, TestException.class);
        } finally {
            RxJavaPlugins.reset();
        }
    }",loop_control
i,"{
        for (int i = 0; i < TestHelper.RACE_DEFAULT_LOOPS; i++) {
            final FutureObserver<Integer> fo = new FutureObserver<>();

            Runnable r = new Runnable() {
                @Override
                public void run() {
                    fo.cancel(false);
                }
            };

            TestHelper.race(r, r);
        }
    }",loop_control
i,"{
        RxJavaPlugins.setErrorHandler(Functions.emptyConsumer());
        try {
            for (int i = 0; i < TestHelper.RACE_DEFAULT_LOOPS; i++) {
                final FutureObserver<Integer> fo = new FutureObserver<>();

                final TestException ex = new TestException();

                Runnable r1 = new Runnable() {
                    @Override
                    public void run() {
                        fo.cancel(false);
                    }
                };

                Runnable r2 = new Runnable() {
                    @Override
                    public void run() {
                        fo.onError(ex);
                    }
                };

                TestHelper.race(r1, r2);
            }
        } finally {
            RxJavaPlugins.reset();
        }
    }",loop_control
i,"{
        RxJavaPlugins.setErrorHandler(Functions.emptyConsumer());
        try {
            for (int i = 0; i < TestHelper.RACE_DEFAULT_LOOPS; i++) {
                final FutureObserver<Integer> fo = new FutureObserver<>();

                if (i % 3 == 0) {
                    fo.onSubscribe(Disposable.empty());
                }

                if (i % 2 == 0) {
                    fo.onNext(1);
                }

                Runnable r1 = new Runnable() {
                    @Override
                    public void run() {
                        fo.cancel(false);
                    }
                };

                Runnable r2 = new Runnable() {
                    @Override
                    public void run() {
                        fo.onComplete();
                    }
                };

                TestHelper.race(r1, r2);
            }
        } finally {
            RxJavaPlugins.reset();
        }
    }",loop_control
i,"{
        for (int i = 0; i < TestHelper.RACE_DEFAULT_LOOPS; i++) {
            final FutureObserver<Integer> fo = new FutureObserver<>();

            Runnable r = new Runnable() {
                @Override
                public void run() {
                    fo.cancel(false);
                }
            };

            Disposable d = Disposable.empty();

            TestHelper.race(r, () -> fo.onSubscribe(d));
        }
    }",loop_control
i,"{
        for (int i = 0; i < TestHelper.RACE_LONG_LOOPS; i++) {

            TestObserver<Integer> to = new TestObserver<>();
            Disposable d = Disposable.empty();
            final QueueDrainObserver<Integer, Integer, Integer> qd = createUnordered(to, d);
            to.onSubscribe(Disposable.empty());

            Runnable r1 = new Runnable() {
                @Override
                public void run() {
                    qd.onNext(1);
                }
            };

            TestHelper.race(r1, r1);

            to.assertValuesOnly(1, 1);
        }
    }",loop_control
i,"{
        for (int i = 0; i < TestHelper.RACE_LONG_LOOPS; i++) {

            TestObserver<Integer> to = new TestObserver<>();
            Disposable d = Disposable.empty();
            final QueueDrainObserver<Integer, Integer, Integer> qd = createOrdered(to, d);
            to.onSubscribe(Disposable.empty());

            Runnable r1 = new Runnable() {
                @Override
                public void run() {
                    qd.onNext(1);
                }
            };

            TestHelper.race(r1, r1);

            to.assertValuesOnly(1, 1);
        }
    }",loop_control
i,"{
        for (int i = 1; i < 32; i++) {
            Flowable.range(1, 1000)
            .parallel(i)
            .flatMapStream(v -> Stream.of(v, v + 1))
            .sequential()
            .test()
            .withTag(""Parallelism: "" + i)
            .assertValueCount(2000)
            .assertNoErrors()
            .assertComplete();
        }
    }",loop_control
i,"{
        for (int i = 1; i < 32; i++) {
            Flowable.range(1, 1000)
            .parallel(i)
            .flatMapStream(v -> Stream.of())
            .sequential()
            .test()
            .withTag(""Parallelism: "" + i)
            .assertResult();
        }
    }",loop_control
i,"{
        for (int i = 1; i < 32; i++) {
            Flowable.range(1, 1000)
            .parallel(i)
            .flatMapStream(v -> v % 2 == 0 ? Stream.of(v) : Stream.of())
            .sequential()
            .test()
            .withTag(""Parallelism: "" + i)
            .assertValueCount(500)
            .assertNoErrors()
            .assertComplete();
        }
    }",loop_control
i,"{
        for (int i = 0; i < TestHelper.RACE_LONG_LOOPS; i++) {
            MaybeSubject<Integer> ms = MaybeSubject.create();

            TestSubscriber<Integer> ts = new TestSubscriber<>(0L);

            ms.flattenStreamAsFlowable(Stream::of)
            .subscribe(ts);

            Runnable r1 = () -> ms.onSuccess(1);
            Runnable r2 = () -> ts.request(1);

            TestHelper.race(r1, r2);

            ts.assertResult(1);
        }
    }",loop_control
i,"{
        for (int i = 1; i < 32; i++) {
            TestSubscriber<List<Integer>> ts = Flowable.range(1, 1000)
            .parallel(i)
            .runOn(Schedulers.computation())
            .collect(Collectors.toList())
            .test()
            .withTag(""Parallelism: "" + i)
            .awaitDone(5, TimeUnit.SECONDS)
            .assertValueCount(1)
            .assertNoErrors()
            .assertComplete();

            assertEquals(1000, ts.values().get(0).size());

            assertTrue(ts.values().get(0).containsAll(set(1000)));
        }
    }",loop_control
i,"{
        for (int i = 1; i < 32; i++) {
            TestSubscriber<List<Integer>> ts = Flowable.range(1, 1000)
            .hide()
            .parallel(i)
            .runOn(Schedulers.computation())
            .collect(Collectors.toList())
            .test()
            .withTag(""Parallelism: "" + i)
            .awaitDone(5, TimeUnit.SECONDS)
            .assertValueCount(1)
            .assertNoErrors()
            .assertComplete();

            assertEquals(1000, ts.values().get(0).size());

            assertTrue(ts.values().get(0).containsAll(set(1000)));
        }
    }",loop_control
ex,"{
        List<Throwable> errors = TestHelper.trackPluginErrors();
        try {
            new ParallelInvalid()
            .collect(Collectors.toList())
            .test()
            .assertFailure(TestException.class);

            assertFalse(errors.isEmpty());
            for (Throwable ex : errors) {
                assertTrue(ex.toString(), ex.getCause() instanceof TestException);
            }
        } finally {
            RxJavaPlugins.reset();
        }
    }",iterator
i,"{
        long n = 1_000;
        for (int i = 1; i < 32; i++) {
            Flowable.rangeLong(1, n)
            .parallel(i)
            .runOn(Schedulers.computation())
            .collect(Collectors.summingLong(v -> v))
            .test()
            .withTag(""Parallelism: "" + i)
            .awaitDone(5, TimeUnit.SECONDS)
            .assertResult(n * (n + 1) / 2);
        }
    }",loop_control
i,"{
        for (int i = 0; i < TestHelper.RACE_LONG_LOOPS; i++) {
            MaybeSubject<Integer> ms = MaybeSubject.create();

            TestObserver<Integer> to = new TestObserver<>();

            ms.flattenStreamAsObservable(Stream::of)
            .subscribe(to);

            Runnable r1 = () -> ms.onSuccess(1);
            Runnable r2 = () -> to.dispose();

            TestHelper.race(r1, r2);
        }
    }",loop_control
i,"{
        try (Stream<Integer> stream = Flowable.range(1, 1000).subscribeOn(Schedulers.computation()).blockingStream()) {
            List<Integer> list = stream.collect(Collectors.toList());

            assertEquals(1000, list.size());
            for (int i = 1; i <= 1000; i++) {
                assertEquals(i, list.get(i - 1).intValue());
            }
        }
    }",loop_control
i,"{
        try (Stream<Integer> stream = Flowable.range(1, 1000).subscribeOn(Schedulers.computation()).blockingStream(1)) {
            List<Integer> list = stream.collect(Collectors.toList());

            assertEquals(1000, list.size());
            for (int i = 1; i <= 1000; i++) {
                assertEquals(i, list.get(i - 1).intValue());
            }
        }
    }",loop_control
15,"{
        for (int n = 1; n < 2048; n *= 2) {
            Flowable.range(1, 1000)
            .flatMapStream(v -> IntStream.range(v * 1000, v * 1000 + 1000).boxed())
            .rebatchRequests(n)
            .test()
            .withTag(""rebatch: "" + n)
            .assertValueCount(1_000_000)
            .assertNoErrors()
            .assertComplete();
        }
    }",loop_control
n,"{
        for (int n = 1; n < 2048; n *= 2) {
            Flowable.range(1, 1000)
            .hide()
            .flatMapStream(v -> IntStream.range(v * 1000, v * 1000 + 1000).boxed())
            .rebatchRequests(n)
            .test()
            .withTag(""rebatch: "" + n)
            .assertValueCount(1_000_000)
            .assertNoErrors()
            .assertComplete();
        }
    }",loop_control
i,"{
        for (int i = 0; i < TestHelper.RACE_LONG_LOOPS; i++) {
            SingleSubject<Integer> ss = SingleSubject.create();

            TestSubscriber<Integer> ts = new TestSubscriber<>(0L);

            ss.flattenStreamAsFlowable(Stream::of)
            .subscribe(ts);

            Runnable r1 = () -> ss.onSuccess(1);
            Runnable r2 = () -> ts.request(1);

            TestHelper.race(r1, r2);

            ts.assertResult(1);
        }
    }",loop_control
ex,"{
        List<Throwable> errors = TestHelper.trackPluginErrors();
        try {
            new ParallelInvalid()
            .mapOptional(Optional::of)
            .sequential()
            .test()
            .assertFailure(TestException.class);

            assertFalse(errors.isEmpty());
            for (Throwable ex : errors) {
                assertTrue(ex.toString(), ex.getCause() instanceof TestException);
            }
        } finally {
            RxJavaPlugins.reset();
        }
    }",iterator
ex,"{
        List<Throwable> errors = TestHelper.trackPluginErrors();
        try {
            new ParallelInvalid()
            .mapOptional(Optional::of)
            .filter(Functions.alwaysTrue())
            .sequential()
            .test()
            .assertFailure(TestException.class);

            assertFalse(errors.isEmpty());
            for (Throwable ex : errors) {
                assertTrue(ex.toString(), ex.getCause() instanceof TestException);
            }
        } finally {
            RxJavaPlugins.reset();
        }
    }",iterator
i,"{
        ExecutorService exec = Executors.newCachedThreadPool();
        try {
            for (int i = 0; i < TestHelper.RACE_DEFAULT_LOOPS; i++) {

                AtomicInteger counter = new AtomicInteger();

                int max = 100;

                Flowable<Integer> source = Flowable.fromStream(IntStream.rangeClosed(1, max).boxed());
                if (conditional) {
                    source = source.filter(v -> true);
                }

                CountDownLatch cdl = new CountDownLatch(1);

                source
                .subscribe(new FlowableSubscriber<Integer>() {

                    @NonNull Subscription upstream;

                    @Override
                    public void onSubscribe(@NonNull Subscription s) {

                        this.upstream = s;
                        s.request(1);

                    }

                    @Override
                    public void onNext(Integer t) {
                        counter.getAndIncrement();

                        AtomicInteger sync = new AtomicInteger(2);
                        exec.submit(() -> {
                            if (sync.decrementAndGet() != 0) {
                                while (sync.get() != 0) { }
                            }
                            upstream.request(1);
                        });

                        if (sync.decrementAndGet() != 0) {
                            while (sync.get() != 0) { }
                        }
                    }

                    @Override
                    public void onError(Throwable t) {
                        t.printStackTrace();
                        cdl.countDown();
                    }

                    @Override
                    public void onComplete() {
                        counter.getAndIncrement();
                        cdl.countDown();
                    }
                });

                assertTrue(cdl.await(60, TimeUnit.SECONDS));

                assertEquals(max + 1, counter.get());
            }
        } finally {
            exec.shutdown();
        }
    }",loop_control
sync,"{
        ExecutorService exec = Executors.newCachedThreadPool();
        try {
            for (int i = 0; i < TestHelper.RACE_DEFAULT_LOOPS; i++) {

                AtomicInteger counter = new AtomicInteger();

                int max = 100;

                Flowable<Integer> source = Flowable.fromStream(IntStream.rangeClosed(1, max).boxed());
                if (conditional) {
                    source = source.filter(v -> true);
                }

                CountDownLatch cdl = new CountDownLatch(1);

                source
                .subscribe(new FlowableSubscriber<Integer>() {

                    @NonNull Subscription upstream;

                    @Override
                    public void onSubscribe(@NonNull Subscription s) {

                        this.upstream = s;
                        s.request(1);

                    }

                    @Override
                    public void onNext(Integer t) {
                        counter.getAndIncrement();

                        AtomicInteger sync = new AtomicInteger(2);
                        exec.submit(() -> {
                            if (sync.decrementAndGet() != 0) {
                                while (sync.get() != 0) { }
                            }
                            upstream.request(1);
                        });

                        if (sync.decrementAndGet() != 0) {
                            while (sync.get() != 0) { }
                        }
                    }

                    @Override
                    public void onError(Throwable t) {
                        t.printStackTrace();
                        cdl.countDown();
                    }

                    @Override
                    public void onComplete() {
                        counter.getAndIncrement();
                        cdl.countDown();
                    }
                });

                assertTrue(cdl.await(60, TimeUnit.SECONDS));

                assertEquals(max + 1, counter.get());
            }
        } finally {
            exec.shutdown();
        }
    }",maybe_loop_control
i,"{
        try (Stream<Integer> stream = Observable.range(1, 1000).subscribeOn(Schedulers.computation()).blockingStream()) {
            List<Integer> list = stream.collect(Collectors.toList());

            assertEquals(1000, list.size());
            for (int i = 1; i <= 1000; i++) {
                assertEquals(i, list.get(i - 1).intValue());
            }
        }
    }",loop_control
i,"{
        try (Stream<Integer> stream = Observable.range(1, 1000).subscribeOn(Schedulers.computation()).blockingStream(1)) {
            List<Integer> list = stream.collect(Collectors.toList());

            assertEquals(1000, list.size());
            for (int i = 1; i <= 1000; i++) {
                assertEquals(i, list.get(i - 1).intValue());
            }
        }
    }",loop_control
i,"{
        for (int i = 0; i < TestHelper.RACE_LONG_LOOPS; i++) {
            SingleSubject<Integer> ss = SingleSubject.create();

            TestObserver<Integer> to = new TestObserver<>();

            ss.flattenStreamAsObservable(Stream::of)
            .subscribe(to);

            Runnable r1 = () -> ss.onSuccess(1);
            Runnable r2 = () -> to.dispose();

            TestHelper.race(r1, r2);
        }
    }",loop_control
e,"{
        for (ParallelFailureHandling e : ParallelFailureHandling.values()) {
            Flowable.just(1)
            .parallel(1)
            .mapOptional(Optional::of, e)
            .sequential()
            .test()
            .assertResult(1);
        }
    }",iterator
e,"{
        for (ParallelFailureHandling e : ParallelFailureHandling.values()) {
            Flowable.<Integer>error(new TestException())
            .parallel(1)
            .mapOptional(Optional::of, e)
            .sequential()
            .test()
            .assertFailure(TestException.class);
        }
    }",iterator
e,"{
        for (ParallelFailureHandling e : ParallelFailureHandling.values()) {
            Flowable.just(1)
            .parallel(1)
            .mapOptional(Optional::of, e)
            .filter(Functions.alwaysTrue())
            .sequential()
            .test()
            .assertResult(1);
        }
    }",iterator
e,"{
        for (ParallelFailureHandling e : ParallelFailureHandling.values()) {
            Flowable.<Integer>error(new TestException())
            .parallel(1)
            .mapOptional(Optional::of, e)
            .filter(Functions.alwaysTrue())
            .sequential()
            .test()
            .assertFailure(TestException.class);
        }
    }",iterator
i,"{
        for (int i = 0; i < TestHelper.RACE_DEFAULT_LOOPS; i++) {
            final DeferredScalarSubscription<Integer> ds = new DeferredScalarSubscription<>(new TestSubscriber<>());

            Runnable r1 = new Runnable() {
                @Override
                public void run() {
                    ds.complete(1);
                }
            };

            Runnable r2 = new Runnable() {
                @Override
                public void run() {
                    ds.cancel();
                }
            };

            TestHelper.race(r1, r2);
        }
    }",loop_control
i,"{
        for (int i = 0; i < TestHelper.RACE_LONG_LOOPS; i++) {
            TestSubscriber<Integer> ts = new TestSubscriber<>(0L);

            final DeferredScalarSubscription<Integer> ds = new DeferredScalarSubscription<>(ts);
            ts.onSubscribe(ds);
            ds.complete(1);

            Runnable r1 = new Runnable() {
                @Override
                public void run() {
                    ds.request(1);
                }
            };

            Runnable r2 = new Runnable() {
                @Override
                public void run() {
                    ds.value = null;
                }
            };

            TestHelper.race(r1, r2);

            if (ts.values().size() >= 1) {
                ts.assertValue(1);
            }
        }
    }",loop_control
i,"{
        for (int i = 0; i < TestHelper.RACE_LONG_LOOPS; i++) {
            TestSubscriber<Integer> ts = new TestSubscriber<>(0L);

            final DeferredScalarSubscription<Integer> ds = new DeferredScalarSubscription<>(ts);
            ts.onSubscribe(ds);
            ds.complete(1);

            Runnable r1 = new Runnable() {
                @Override
                public void run() {
                    ds.request(1);
                }
            };

            Runnable r2 = new Runnable() {
                @Override
                public void run() {
                    ds.cancel();
                }
            };

            TestHelper.race(r1, r2);

            if (ts.values().size() >= 1) {
                ts.assertValue(1);
            }
        }
    }",loop_control
i,"{
        for (int i = 0; i < TestHelper.RACE_DEFAULT_LOOPS; i++) {
            final AtomicReference<Subscription> atomicSubscription = new AtomicReference<>();

            Runnable r = new Runnable() {
                @Override
                public void run() {
                    SubscriptionHelper.cancel(atomicSubscription);
                }
            };

            TestHelper.race(r, r);
        }
    }",loop_control
i,"{
        for (int i = 0; i < TestHelper.RACE_DEFAULT_LOOPS; i++) {
            final AtomicReference<Subscription> atomicSubscription = new AtomicReference<>();

            final BooleanSubscription bs1 = new BooleanSubscription();
            final BooleanSubscription bs2 = new BooleanSubscription();

            Runnable r1 = new Runnable() {
                @Override
                public void run() {
                    SubscriptionHelper.set(atomicSubscription, bs1);
                }
            };

            Runnable r2 = new Runnable() {
                @Override
                public void run() {
                    SubscriptionHelper.set(atomicSubscription, bs2);
                }
            };

            TestHelper.race(r1, r2);

            assertTrue(bs1.isCancelled() ^ bs2.isCancelled());
        }
    }",loop_control
i,"{
        for (int i = 0; i < TestHelper.RACE_DEFAULT_LOOPS; i++) {
            final AtomicReference<Subscription> atomicSubscription = new AtomicReference<>();

            final BooleanSubscription bs1 = new BooleanSubscription();
            final BooleanSubscription bs2 = new BooleanSubscription();

            Runnable r1 = new Runnable() {
                @Override
                public void run() {
                    SubscriptionHelper.replace(atomicSubscription, bs1);
                }
            };

            Runnable r2 = new Runnable() {
                @Override
                public void run() {
                    SubscriptionHelper.replace(atomicSubscription, bs2);
                }
            };

            TestHelper.race(r1, r2);

            assertFalse(bs1.isCancelled());
            assertFalse(bs2.isCancelled());
        }
    }",loop_control
i,"{
        for (int i = 0; i < TestHelper.RACE_DEFAULT_LOOPS; i++) {
            final AtomicReference<Subscription> atomicSubscription = new AtomicReference<>();
            final AtomicLong r = new AtomicLong();

            final AtomicLong q = new AtomicLong();

            final Subscription a = new Subscription() {
                @Override
                public void request(long n) {
                    q.addAndGet(n);
                }

                @Override
                public void cancel() {

                }
            };

            Runnable r1 = new Runnable() {
                @Override
                public void run() {
                    SubscriptionHelper.deferredSetOnce(atomicSubscription, r, a);
                }
            };

            Runnable r2 = new Runnable() {
                @Override
                public void run() {
                    SubscriptionHelper.deferredRequest(atomicSubscription, r, 1);
                }
            };

            TestHelper.race(r1, r2);

            assertSame(a, atomicSubscription.get());
            assertEquals(1, q.get());
            assertEquals(0, r.get());
        }
    }",loop_control
i,"{
        for (int i = 0; i < TestHelper.RACE_DEFAULT_LOOPS; i++) {
            final ArrayCompositeSubscription ac = new ArrayCompositeSubscription(1000);

            Runnable r = new Runnable() {
                @Override
                public void run() {
                    ac.dispose();
                }
            };

            TestHelper.race(r, r);
        }
    }",loop_control
i,"{
        for (int i = 0; i < TestHelper.RACE_DEFAULT_LOOPS; i++) {
            final ArrayCompositeSubscription ac = new ArrayCompositeSubscription(1);

            final BooleanSubscription s1 = new BooleanSubscription();
            final BooleanSubscription s2 = new BooleanSubscription();

            Runnable r1 = new Runnable() {
                @Override
                public void run() {
                    ac.setResource(0, s1);
                }
            };

            Runnable r2 = new Runnable() {
                @Override
                public void run() {
                    ac.replaceResource(0, s2);
                }
            };

            TestHelper.race(r1, r2);
        }
    }",loop_control
i,"{
        for (int i = 0; i < TestHelper.RACE_DEFAULT_LOOPS; i++) {
            CompositeDisposable set = new CompositeDisposable();
            final ScheduledRunnable run = new ScheduledRunnable(Functions.EMPTY_RUNNABLE, set);
            set.add(run);

            final FutureTask<Object> ft = new FutureTask<>(Functions.EMPTY_RUNNABLE, 0);

            Runnable r1 = new Runnable() {
                @Override
                public void run() {
                    run.setFuture(ft);
                }
            };

            Runnable r2 = new Runnable() {
                @Override
                public void run() {
                    run.dispose();
                }
            };

            TestHelper.race(r1, r2);

            assertEquals(0, set.size());
        }
    }",loop_control
i,"{
        for (int i = 0; i < TestHelper.RACE_DEFAULT_LOOPS; i++) {
            CompositeDisposable set = new CompositeDisposable();
            final ScheduledRunnable run = new ScheduledRunnable(Functions.EMPTY_RUNNABLE, set);
            set.add(run);

            final FutureTask<Object> ft = new FutureTask<>(Functions.EMPTY_RUNNABLE, 0);

            Runnable r1 = new Runnable() {
                @Override
                public void run() {
                    run.setFuture(ft);
                }
            };

            Runnable r2 = new Runnable() {
                @Override
                public void run() {
                    run.run();
                }
            };

            TestHelper.race(r1, r2);

            assertEquals(0, set.size());
        }
    }",loop_control
i,"{
        for (int i = 0; i < TestHelper.RACE_DEFAULT_LOOPS; i++) {
            CompositeDisposable set = new CompositeDisposable();
            final ScheduledRunnable run = new ScheduledRunnable(Functions.EMPTY_RUNNABLE, set);
            set.add(run);

            Runnable r1 = new Runnable() {
                @Override
                public void run() {
                    run.dispose();
                }
            };

            TestHelper.race(r1, r1);

            assertEquals(0, set.size());
        }
    }",loop_control
i,"{
        for (int i = 0; i < TestHelper.RACE_DEFAULT_LOOPS; i++) {
            CompositeDisposable set = new CompositeDisposable();
            final ScheduledRunnable run = new ScheduledRunnable(Functions.EMPTY_RUNNABLE, set);
            set.add(run);

            Runnable r1 = new Runnable() {
                @Override
                public void run() {
                    run.call();
                }
            };

            Runnable r2 = new Runnable() {
                @Override
                public void run() {
                    run.dispose();
                }
            };

            TestHelper.race(r1, r2);

            assertEquals(0, set.size());
        }
    }",loop_control
i,"{
        for (int i = 0; i < TestHelper.RACE_DEFAULT_LOOPS; i++) {
            CompositeDisposable set = new CompositeDisposable();
            final ScheduledRunnable run = new ScheduledRunnable(Functions.EMPTY_RUNNABLE, set);
            set.add(run);

            final FutureTask<Void> ft = new FutureTask<>(Functions.EMPTY_RUNNABLE, null);

            Runnable r1 = new Runnable() {
                @Override
                public void run() {
                    run.call();
                }
            };

            Runnable r2 = new Runnable() {
                @Override
                public void run() {
                    run.setFuture(ft);
                }
            };

            TestHelper.race(r1, r2);
        }
    }",loop_control
i,"{
        for (int i = 0; i < TestHelper.RACE_LONG_LOOPS; i++) {
            final CompositeDisposable set = new CompositeDisposable();
            final AtomicBoolean interrupted = new AtomicBoolean();
            final AtomicInteger sync = new AtomicInteger(2);
            final AtomicInteger syncb = new AtomicInteger(2);

            Runnable r0 = new Runnable() {
                @Override
                public void run() {
                    set.dispose();
                    if (sync.decrementAndGet() != 0) {
                        while (sync.get() != 0) { }
                    }
                    if (syncb.decrementAndGet() != 0) {
                        while (syncb.get() != 0) { }
                    }
                    for (int j = 0; j < 1000; j++) {
                        if (Thread.currentThread().isInterrupted()) {
                            interrupted.set(true);
                            break;
                        }
                    }
                }
            };

            final ScheduledRunnable run = new ScheduledRunnable(r0, set);
            set.add(run);

            final FutureTask<Void> ft = new FutureTask<>(run, null);

            Runnable r2 = new Runnable() {
                @Override
                public void run() {
                    if (sync.decrementAndGet() != 0) {
                        while (sync.get() != 0) { }
                    }
                    run.setFuture(ft);
                    if (syncb.decrementAndGet() != 0) {
                        while (syncb.get() != 0) { }
                    }
                }
            };

            TestHelper.race(ft, r2);

            assertFalse(""The task was interrupted"", interrupted.get());
        }
    }",loop_control
sync,"{
        for (int i = 0; i < TestHelper.RACE_LONG_LOOPS; i++) {
            final CompositeDisposable set = new CompositeDisposable();
            final AtomicBoolean interrupted = new AtomicBoolean();
            final AtomicInteger sync = new AtomicInteger(2);
            final AtomicInteger syncb = new AtomicInteger(2);

            Runnable r0 = new Runnable() {
                @Override
                public void run() {
                    set.dispose();
                    if (sync.decrementAndGet() != 0) {
                        while (sync.get() != 0) { }
                    }
                    if (syncb.decrementAndGet() != 0) {
                        while (syncb.get() != 0) { }
                    }
                    for (int j = 0; j < 1000; j++) {
                        if (Thread.currentThread().isInterrupted()) {
                            interrupted.set(true);
                            break;
                        }
                    }
                }
            };

            final ScheduledRunnable run = new ScheduledRunnable(r0, set);
            set.add(run);

            final FutureTask<Void> ft = new FutureTask<>(run, null);

            Runnable r2 = new Runnable() {
                @Override
                public void run() {
                    if (sync.decrementAndGet() != 0) {
                        while (sync.get() != 0) { }
                    }
                    run.setFuture(ft);
                    if (syncb.decrementAndGet() != 0) {
                        while (syncb.get() != 0) { }
                    }
                }
            };

            TestHelper.race(ft, r2);

            assertFalse(""The task was interrupted"", interrupted.get());
        }
    }",maybe_loop_control
syncb,"{
        for (int i = 0; i < TestHelper.RACE_LONG_LOOPS; i++) {
            final CompositeDisposable set = new CompositeDisposable();
            final AtomicBoolean interrupted = new AtomicBoolean();
            final AtomicInteger sync = new AtomicInteger(2);
            final AtomicInteger syncb = new AtomicInteger(2);

            Runnable r0 = new Runnable() {
                @Override
                public void run() {
                    set.dispose();
                    if (sync.decrementAndGet() != 0) {
                        while (sync.get() != 0) { }
                    }
                    if (syncb.decrementAndGet() != 0) {
                        while (syncb.get() != 0) { }
                    }
                    for (int j = 0; j < 1000; j++) {
                        if (Thread.currentThread().isInterrupted()) {
                            interrupted.set(true);
                            break;
                        }
                    }
                }
            };

            final ScheduledRunnable run = new ScheduledRunnable(r0, set);
            set.add(run);

            final FutureTask<Void> ft = new FutureTask<>(run, null);

            Runnable r2 = new Runnable() {
                @Override
                public void run() {
                    if (sync.decrementAndGet() != 0) {
                        while (sync.get() != 0) { }
                    }
                    run.setFuture(ft);
                    if (syncb.decrementAndGet() != 0) {
                        while (syncb.get() != 0) { }
                    }
                }
            };

            TestHelper.race(ft, r2);

            assertFalse(""The task was interrupted"", interrupted.get());
        }
    }",maybe_loop_control
j,"{
        for (int i = 0; i < TestHelper.RACE_LONG_LOOPS; i++) {
            final CompositeDisposable set = new CompositeDisposable();
            final AtomicBoolean interrupted = new AtomicBoolean();
            final AtomicInteger sync = new AtomicInteger(2);
            final AtomicInteger syncb = new AtomicInteger(2);

            Runnable r0 = new Runnable() {
                @Override
                public void run() {
                    set.dispose();
                    if (sync.decrementAndGet() != 0) {
                        while (sync.get() != 0) { }
                    }
                    if (syncb.decrementAndGet() != 0) {
                        while (syncb.get() != 0) { }
                    }
                    for (int j = 0; j < 1000; j++) {
                        if (Thread.currentThread().isInterrupted()) {
                            interrupted.set(true);
                            break;
                        }
                    }
                }
            };

            final ScheduledRunnable run = new ScheduledRunnable(r0, set);
            set.add(run);

            final FutureTask<Void> ft = new FutureTask<>(run, null);

            Runnable r2 = new Runnable() {
                @Override
                public void run() {
                    if (sync.decrementAndGet() != 0) {
                        while (sync.get() != 0) { }
                    }
                    run.setFuture(ft);
                    if (syncb.decrementAndGet() != 0) {
                        while (syncb.get() != 0) { }
                    }
                }
            };

            TestHelper.race(ft, r2);

            assertFalse(""The task was interrupted"", interrupted.get());
        }
    }",loop_control
i,"{
        for (int i = 0; i < TestHelper.RACE_LONG_LOOPS; i++) {
            final ScheduledAction sa = new ScheduledAction() {

                private static final long serialVersionUID = -672980251643733156L;

                @Override
                protected Disposable callActual(Worker actualWorker,
                        CompletableObserver actionCompletable) {
                    return Disposable.empty();
                }

            };

            assertFalse(sa.isDisposed());

            Runnable r1 = new Runnable() {
                @Override
                public void run() {
                    sa.dispose();
                }
            };

            TestHelper.race(r1, r1);

            assertTrue(sa.isDisposed());
        }
    }",loop_control
i,"{
        final Scheduler s = new SingleScheduler();
        for (int i = 0; i < TestHelper.RACE_DEFAULT_LOOPS; i++) {
            s.shutdown();

            Runnable r1 = new Runnable() {
                @Override
                public void run() {
                    s.start();
                }
            };

            TestHelper.race(r1, r1);
        }
    }",loop_control
d,"{
        final Scheduler s = Schedulers.single();
        Disposable d = s.scheduleDirect(Functions.EMPTY_RUNNABLE);

        while (!d.isDisposed()) {
            Thread.sleep(1);
        }
    }",maybe_loop_control
d,"{
        final Scheduler s = Schedulers.single();

        Disposable d = s.scheduleDirect(new Runnable() {
            @Override
            public void run() {
                throw new IllegalStateException();
            }
        });

        while (!d.isDisposed()) {
            Thread.sleep(1);
        }
    }",maybe_loop_control
d,"{
        final Scheduler s = Schedulers.single();

        Disposable d = s.scheduleDirect(Functions.EMPTY_RUNNABLE, 1, TimeUnit.MILLISECONDS);

        while (!d.isDisposed()) {
            Thread.sleep(1);
        }
    }",maybe_loop_control
i,"{
        ConcurrentLinkedQueue<ThreadWorker> expire = new ConcurrentLinkedQueue<>();
        CompositeDisposable cd = new CompositeDisposable();

        ThreadWorker tw = new ThreadWorker(new RxThreadFactory(""IoExpiryTest""));
        tw.dispose();

        for (int i = 0; i < TestHelper.RACE_DEFAULT_LOOPS; i++) {
            expire.add(tw);
            cd.add(tw);

            TestHelper.race(
                    () -> CachedWorkerPool.evictExpiredWorkers(expire, cd),
                    () -> expire.remove(tw)
            );
        }
    }",loop_control
i,"{
        Scheduler.Worker w = Schedulers.trampoline().createWorker();

        for (int i = 0; i < TestHelper.RACE_DEFAULT_LOOPS; i++) {
            Runnable run = mock(Runnable.class);

            AtomicInteger sync = new AtomicInteger(2);

            w.schedule(() -> {
                Disposable d = w.schedule(run);

                Schedulers.single().scheduleDirect(() -> {
                    if (sync.decrementAndGet() != 0) {
                        while (sync.get() != 0) { }
                    }
                    d.dispose();
                });
                if (sync.decrementAndGet() != 0) {
                    while (sync.get() != 0) { }
                }
            });
        }
    }",loop_control
sync,"{
        Scheduler.Worker w = Schedulers.trampoline().createWorker();

        for (int i = 0; i < TestHelper.RACE_DEFAULT_LOOPS; i++) {
            Runnable run = mock(Runnable.class);

            AtomicInteger sync = new AtomicInteger(2);

            w.schedule(() -> {
                Disposable d = w.schedule(run);

                Schedulers.single().scheduleDirect(() -> {
                    if (sync.decrementAndGet() != 0) {
                        while (sync.get() != 0) { }
                    }
                    d.dispose();
                });
                if (sync.decrementAndGet() != 0) {
                    while (sync.get() != 0) { }
                }
            });
        }
    }",maybe_loop_control
i,"{
        ExecutorService exec = Executors.newSingleThreadExecutor();
        try {
            for (int i = 0; i < TestHelper.RACE_LONG_LOOPS; i++) {
                final InstantPeriodicTask task = new InstantPeriodicTask(new Runnable() {
                    @Override
                    public void run() {
                        throw new TestException();
                    }
                }, exec);

                final FutureTask<Void> f1 = new FutureTask<>(Functions.EMPTY_RUNNABLE, null);
                Runnable r1 = new Runnable() {
                    @Override
                    public void run() {
                        task.setFirst(f1);
                    }
                };
                Runnable r2 = new Runnable() {
                    @Override
                    public void run() {
                        task.dispose();
                    }
                };

                TestHelper.race(r1, r2);

                assertTrue(f1.isCancelled());
                assertTrue(task.isDisposed());
            }
        } finally {
            exec.shutdownNow();
            RxJavaPlugins.reset();
        }
    }",loop_control
i,"{
        ExecutorService exec = Executors.newSingleThreadExecutor();
        try {
            for (int i = 0; i < TestHelper.RACE_LONG_LOOPS; i++) {
                final InstantPeriodicTask task = new InstantPeriodicTask(new Runnable() {
                    @Override
                    public void run() {
                        throw new TestException();
                    }
                }, exec);

                final FutureTask<Void> f1 = new FutureTask<>(Functions.EMPTY_RUNNABLE, null);
                Runnable r1 = new Runnable() {
                    @Override
                    public void run() {
                        task.setRest(f1);
                    }
                };
                Runnable r2 = new Runnable() {
                    @Override
                    public void run() {
                        task.dispose();
                    }
                };

                TestHelper.race(r1, r2);

                assertTrue(f1.isCancelled());
                assertTrue(task.isDisposed());
            }
        } finally {
            exec.shutdownNow();
            RxJavaPlugins.reset();
        }
    }",loop_control
w,"{
        final List<Worker> list = new ArrayList<>();

        ComputationScheduler.NONE.createWorkers(max * 2, new WorkerCallback() {
            @Override
            public void onWorker(int i, Worker w) {
                list.add(w);
            }
        });

        assertEquals(max * 2, list.size());

        for (Worker w : list) {
            assertEquals(ComputationScheduler.SHUTDOWN_WORKER, w);
        }
    }",iterator
i,"{
        for (int i = 0; i < TestHelper.RACE_DEFAULT_LOOPS; i++) {

            final CompositeDisposable composite = new CompositeDisposable();

            try {
                final CountDownLatch cdl = new CountDownLatch(max * 2);

                final Set<String> threads1 = Collections.synchronizedSet(new HashSet<>());

                final Set<String> threads2 = Collections.synchronizedSet(new HashSet<>());

                Runnable parallel1 = new Runnable() {
                    @Override
                    public void run() {
                        final List<Worker> list1 = new ArrayList<>();

                        SchedulerMultiWorkerSupport mws = (SchedulerMultiWorkerSupport)Schedulers.computation();

                        mws.createWorkers(max, new WorkerCallback() {
                            @Override
                            public void onWorker(int i, Worker w) {
                                list1.add(w);
                                composite.add(w);
                            }
                        });

                        Runnable run = new Runnable() {
                            @Override
                            public void run() {
                                threads1.add(Thread.currentThread().getName());
                                cdl.countDown();
                            }
                        };

                        for (Worker w : list1) {
                            w.schedule(run);
                        }
                    }
                };

                Runnable parallel2 = new Runnable() {
                    @Override
                    public void run() {
                        final List<Worker> list2 = new ArrayList<>();

                        SchedulerMultiWorkerSupport mws = (SchedulerMultiWorkerSupport)Schedulers.computation();

                        mws.createWorkers(max, new WorkerCallback() {
                            @Override
                            public void onWorker(int i, Worker w) {
                                list2.add(w);
                                composite.add(w);
                            }
                        });

                        Runnable run = new Runnable() {
                            @Override
                            public void run() {
                                threads2.add(Thread.currentThread().getName());
                                cdl.countDown();
                            }
                        };

                        for (Worker w : list2) {
                            w.schedule(run);
                        }
                    }
                };

                TestHelper.race(parallel1, parallel2);

                assertTrue(cdl.await(5, TimeUnit.SECONDS));

                assertEquals(threads1.toString(), max, threads1.size());
                assertEquals(threads2.toString(), max, threads2.size());
            } finally {
                composite.dispose();
            }
        }
    }",loop_control
w,"{
        for (int i = 0; i < TestHelper.RACE_DEFAULT_LOOPS; i++) {

            final CompositeDisposable composite = new CompositeDisposable();

            try {
                final CountDownLatch cdl = new CountDownLatch(max * 2);

                final Set<String> threads1 = Collections.synchronizedSet(new HashSet<>());

                final Set<String> threads2 = Collections.synchronizedSet(new HashSet<>());

                Runnable parallel1 = new Runnable() {
                    @Override
                    public void run() {
                        final List<Worker> list1 = new ArrayList<>();

                        SchedulerMultiWorkerSupport mws = (SchedulerMultiWorkerSupport)Schedulers.computation();

                        mws.createWorkers(max, new WorkerCallback() {
                            @Override
                            public void onWorker(int i, Worker w) {
                                list1.add(w);
                                composite.add(w);
                            }
                        });

                        Runnable run = new Runnable() {
                            @Override
                            public void run() {
                                threads1.add(Thread.currentThread().getName());
                                cdl.countDown();
                            }
                        };

                        for (Worker w : list1) {
                            w.schedule(run);
                        }
                    }
                };

                Runnable parallel2 = new Runnable() {
                    @Override
                    public void run() {
                        final List<Worker> list2 = new ArrayList<>();

                        SchedulerMultiWorkerSupport mws = (SchedulerMultiWorkerSupport)Schedulers.computation();

                        mws.createWorkers(max, new WorkerCallback() {
                            @Override
                            public void onWorker(int i, Worker w) {
                                list2.add(w);
                                composite.add(w);
                            }
                        });

                        Runnable run = new Runnable() {
                            @Override
                            public void run() {
                                threads2.add(Thread.currentThread().getName());
                                cdl.countDown();
                            }
                        };

                        for (Worker w : list2) {
                            w.schedule(run);
                        }
                    }
                };

                TestHelper.race(parallel1, parallel2);

                assertTrue(cdl.await(5, TimeUnit.SECONDS));

                assertEquals(threads1.toString(), max, threads1.size());
                assertEquals(threads2.toString(), max, threads2.size());
            } finally {
                composite.dispose();
            }
        }
    }",iterator
i,"{
        for (int i = 0; i < TestHelper.RACE_DEFAULT_LOOPS; i++) {
            final AbstractDirectTask task = new AbstractDirectTask(Functions.EMPTY_RUNNABLE, true) {
                private static final long serialVersionUID = 208585707945686116L;
            };

            final Boolean[] interrupted = { null };
            final FutureTask<Void> ft = new FutureTask<Void>(Functions.EMPTY_RUNNABLE, null) {
                @Override
                public boolean cancel(boolean mayInterruptIfRunning) {
                    interrupted[0] = mayInterruptIfRunning;
                    return super.cancel(mayInterruptIfRunning);
                }
            };

            Runnable r1 = new Runnable() {
                @Override
                public void run() {
                    task.dispose();
                }
            };

            Runnable r2 = new Runnable() {
                @Override
                public void run() {
                    task.setFuture(ft);
                }
            };

            TestHelper.race(r1, r2);
        }
    }",loop_control
i,"{
        boolean savedScheduledRelease = IoScheduler.USE_SCHEDULED_RELEASE;
        IoScheduler.USE_SCHEDULED_RELEASE = true;
        try {
            Flowable.just(""item"")
                    .observeOn(Schedulers.io())
                    .firstOrError()
                    .map(item -> {
                        for (int i = 0; i < 50; i++) {
                            Completable.complete()
                                    .observeOn(Schedulers.io())
                                    .blockingAwait();
                        }
                        return ""Done"";
                    })
                    .ignoreElement()
                    .test()
                    .awaitDone(5, TimeUnit.SECONDS)
                    .assertComplete();
        } finally {
            IoScheduler.USE_SCHEDULED_RELEASE = savedScheduledRelease;
        }
    }",loop_control
i,"{
        for (int i = 0; i < TestHelper.RACE_DEFAULT_LOOPS; i++) {

            final AtomicInteger wip = new AtomicInteger();
            final AtomicThrowable error = new AtomicThrowable();

            final TestSubscriber<Integer> ts = new TestSubscriber<>();
            ts.onSubscribe(new BooleanSubscription());

            Runnable r1 = new Runnable() {
                @Override
                public void run() {
                    HalfSerializer.onNext(ts, 1, wip, error);
                }
            };

            Runnable r2 = new Runnable() {
                @Override
                public void run() {
                    HalfSerializer.onComplete(ts, wip, error);
                }
            };

            TestHelper.race(r1, r2);

            ts.assertComplete().assertNoErrors();

            assertTrue(ts.values().size() <= 1);
        }
    }",loop_control
i,"{
        for (int i = 0; i < TestHelper.RACE_DEFAULT_LOOPS; i++) {

            final AtomicInteger wip = new AtomicInteger();
            final AtomicThrowable error = new AtomicThrowable();

            final TestSubscriberEx<Integer> ts = new TestSubscriberEx<>();

            ts.onSubscribe(new BooleanSubscription());

            final TestException ex = new TestException();

            Runnable r1 = new Runnable() {
                @Override
                public void run() {
                    HalfSerializer.onError(ts, ex, wip, error);
                }
            };

            Runnable r2 = new Runnable() {
                @Override
                public void run() {
                    HalfSerializer.onComplete(ts, wip, error);
                }
            };

            TestHelper.race(r1, r2);

            if (ts.completions() != 0) {
                ts.assertResult();
            } else {
                ts.assertFailure(TestException.class);
            }
        }
    }",loop_control
i,"{
        for (int i = 1; i > 0; i *= 2) {
            assertTrue(Pow2.isPowerOfTwo(i));
        }

        assertFalse(Pow2.isPowerOfTwo(3));
        assertFalse(Pow2.isPowerOfTwo(5));
        assertFalse(Pow2.isPowerOfTwo(6));
        assertFalse(Pow2.isPowerOfTwo(7));
    }",loop_control
clazz,"{
        for (Class<?> clazz : CLASSES) {
            String clazzName = clazz.getSimpleName();
            String packageName = clazz.getPackage().getName();
            File f = TestHelper.findSource(clazzName, packageName);

            List<String> lines = Files.readAllLines(f.toPath());

            for (int i = 1; i < lines.size(); i++) {
                String line = lines.get(i).trim();

                if (line.startsWith(""/**"")) {
                    boolean found = false;
                    for (int j = i + 1; j < lines.size(); j++) {

                        String line2 = lines.get(j).trim();
                        if (line2.startsWith(""public"")) {
                            if (line2.endsWith(""() {"")) {
                                found = true;
                            }
                            break;
                        }
                        if (line2.startsWith(""* @throws"")) {
                            found = true;
                            break;
                        }
                    }

                    if (!found) {
                        System.out.printf("" at %s.%s.method(%s.java:%s)%n%n"", packageName, clazzName, clazzName, i + 1);
                    }
                }
            }
        }
    }",iterator
i,"{
        for (Class<?> clazz : CLASSES) {
            String clazzName = clazz.getSimpleName();
            String packageName = clazz.getPackage().getName();
            File f = TestHelper.findSource(clazzName, packageName);

            List<String> lines = Files.readAllLines(f.toPath());

            for (int i = 1; i < lines.size(); i++) {
                String line = lines.get(i).trim();

                if (line.startsWith(""/**"")) {
                    boolean found = false;
                    for (int j = i + 1; j < lines.size(); j++) {

                        String line2 = lines.get(j).trim();
                        if (line2.startsWith(""public"")) {
                            if (line2.endsWith(""() {"")) {
                                found = true;
                            }
                            break;
                        }
                        if (line2.startsWith(""* @throws"")) {
                            found = true;
                            break;
                        }
                    }

                    if (!found) {
                        System.out.printf("" at %s.%s.method(%s.java:%s)%n%n"", packageName, clazzName, clazzName, i + 1);
                    }
                }
            }
        }
    }",loop_control
j,"{
        for (Class<?> clazz : CLASSES) {
            String clazzName = clazz.getSimpleName();
            String packageName = clazz.getPackage().getName();
            File f = TestHelper.findSource(clazzName, packageName);

            List<String> lines = Files.readAllLines(f.toPath());

            for (int i = 1; i < lines.size(); i++) {
                String line = lines.get(i).trim();

                if (line.startsWith(""/**"")) {
                    boolean found = false;
                    for (int j = i + 1; j < lines.size(); j++) {

                        String line2 = lines.get(j).trim();
                        if (line2.startsWith(""public"")) {
                            if (line2.endsWith(""() {"")) {
                                found = true;
                            }
                            break;
                        }
                        if (line2.startsWith(""* @throws"")) {
                            found = true;
                            break;
                        }
                    }

                    if (!found) {
                        System.out.printf("" at %s.%s.method(%s.java:%s)%n%n"", packageName, clazzName, clazzName, i + 1);
                    }
                }
            }
        }
    }",loop_control
i,"{
        for (int i = 0; i < TestHelper.RACE_DEFAULT_LOOPS; i++) {
            final TestSubscriber<Integer> ts = new TestSubscriber<>();
            final ArrayDeque<Integer> queue = new ArrayDeque<>();
            final AtomicLong state = new AtomicLong();
            final BooleanSupplier isCancelled = new BooleanSupplier() {
                @Override
                public boolean getAsBoolean() throws Exception {
                    return false;
                }
            };

            ts.onSubscribe(new BooleanSubscription());
            queue.offer(1);

            Runnable r1 = new Runnable() {
                @Override
                public void run() {
                    QueueDrainHelper.postCompleteRequest(1, ts, queue, state, isCancelled);
                }
            };

            Runnable r2 = new Runnable() {
                @Override
                public void run() {
                    QueueDrainHelper.postComplete(ts, queue, state, isCancelled);
                }
            };

            TestHelper.race(r1, r2);

            ts.assertResult(1);
        }
    }",loop_control
clazz,"{

    /** Helper program. */
    private MarbleDimensions() {
        throw new IllegalStateException(""No instances!"");
    }

    public static void main(String[] args) throws Throwable {
        Pattern p = Pattern.compile(""\\s*\\*\\s*\\<img\\s+width\\=('|\"")(\\d+)('|\"")\\s+height\\=('|\"")(\\d+)('|\"")\\s+src\\=('|\"")(.+?)('|\"").*"");

        Map<String, Integer[]> dimensions = new HashMap<>();

        for (Class<?> clazz : CLASSES) {
            String simpleName = clazz.getSimpleName();
            System.out.println(simpleName);
            System.out.println(""----"");
            String packageName = clazz.getPackage().getName();

            File f = TestHelper.findSource(clazz.getSimpleName(), packageName);
            if (f == null) {
                System.err.println(""Unable to locate "" + clazz);
                continue;
            }

            List<String> lines = Files.readAllLines(f.toPath());

            for (int i = 0; i < lines.size(); i++) {
                Matcher m = p.matcher(lines.get(i));
                if (m.matches()) {
                    int width = Integer.parseInt(m.group(2));
                    int height = Integer.parseInt(m.group(5));
                    String url = m.group(8);

                    Integer[] imageDim = dimensions.get(url);
                    if (imageDim == null) {
                        Thread.sleep(SLEEP_PER_IMAGE_MILLIS);

                        try {
                            BufferedImage bimg = ImageIO.read(new URL(url));

                            if (bimg == null) {
                                throw new IOException(""not found"");
                            }
                            imageDim = new Integer[] { 0, 0 };
                            imageDim[0] = bimg.getWidth();
                            imageDim[1] = bimg.getHeight();

                            dimensions.put(url, imageDim);
                        } catch (IOException ex) {
                            System.err.printf(""%s => %s%n"", url, ex);
                            System.err.printf("" at %s.%s.method(%s.java:%d)%n"", packageName, simpleName, simpleName, i + 1);
                        }
                    }

                    if (imageDim != null) {
                        int expectedHeight = (int)Math.round(1.0 * width / imageDim[0] * imageDim[1]);

                        if (expectedHeight != height) {
                            System.out.printf(""    %d => %d%n"", height, expectedHeight);
                            System.out.printf("" at %s.%s.method(%s.java:%d)%n"", packageName, simpleName, simpleName, i + 1);
                        }
                    }
                    // System.out.printf(""%d: %d x %d => %s%n"", i + 1, width, height, url);
                }
            }
        }
    }

    static final int SLEEP_PER_IMAGE_MILLIS = 25;

    static final Class<?>[] CLASSES = {
            Flowable.class, Observable.class, Maybe.class, Single.class, Completable.class, ParallelFlowable.class
    };
}",iterator
i,"{

    /** Helper program. */
    private MarbleDimensions() {
        throw new IllegalStateException(""No instances!"");
    }

    public static void main(String[] args) throws Throwable {
        Pattern p = Pattern.compile(""\\s*\\*\\s*\\<img\\s+width\\=('|\"")(\\d+)('|\"")\\s+height\\=('|\"")(\\d+)('|\"")\\s+src\\=('|\"")(.+?)('|\"").*"");

        Map<String, Integer[]> dimensions = new HashMap<>();

        for (Class<?> clazz : CLASSES) {
            String simpleName = clazz.getSimpleName();
            System.out.println(simpleName);
            System.out.println(""----"");
            String packageName = clazz.getPackage().getName();

            File f = TestHelper.findSource(clazz.getSimpleName(), packageName);
            if (f == null) {
                System.err.println(""Unable to locate "" + clazz);
                continue;
            }

            List<String> lines = Files.readAllLines(f.toPath());

            for (int i = 0; i < lines.size(); i++) {
                Matcher m = p.matcher(lines.get(i));
                if (m.matches()) {
                    int width = Integer.parseInt(m.group(2));
                    int height = Integer.parseInt(m.group(5));
                    String url = m.group(8);

                    Integer[] imageDim = dimensions.get(url);
                    if (imageDim == null) {
                        Thread.sleep(SLEEP_PER_IMAGE_MILLIS);

                        try {
                            BufferedImage bimg = ImageIO.read(new URL(url));

                            if (bimg == null) {
                                throw new IOException(""not found"");
                            }
                            imageDim = new Integer[] { 0, 0 };
                            imageDim[0] = bimg.getWidth();
                            imageDim[1] = bimg.getHeight();

                            dimensions.put(url, imageDim);
                        } catch (IOException ex) {
                            System.err.printf(""%s => %s%n"", url, ex);
                            System.err.printf("" at %s.%s.method(%s.java:%d)%n"", packageName, simpleName, simpleName, i + 1);
                        }
                    }

                    if (imageDim != null) {
                        int expectedHeight = (int)Math.round(1.0 * width / imageDim[0] * imageDim[1]);

                        if (expectedHeight != height) {
                            System.out.printf(""    %d => %d%n"", height, expectedHeight);
                            System.out.printf("" at %s.%s.method(%s.java:%d)%n"", packageName, simpleName, simpleName, i + 1);
                        }
                    }
                    // System.out.printf(""%d: %d x %d => %s%n"", i + 1, width, height, url);
                }
            }
        }
    }

    static final int SLEEP_PER_IMAGE_MILLIS = 25;

    static final Class<?>[] CLASSES = {
            Flowable.class, Observable.class, Maybe.class, Single.class, Completable.class, ParallelFlowable.class
    };
}",loop_control
clazz,"{
        // className -> methodName -> overloads -> arguments
        Map<String, Map<String, List<List<ArgumentNameAndType>>>> map = new HashMap<>();

        for (Class<?> clazz : CLASSES) {
            Map<String, List<List<ArgumentNameAndType>>> classMethods = map.computeIfAbsent(clazz.getSimpleName(), v -> new HashMap<>());
            for (Method method : clazz.getDeclaredMethods()) {
                if (method.getDeclaringClass() == clazz && method.getParameterCount() != 0) {
                    List<List<ArgumentNameAndType>> overloads = classMethods.computeIfAbsent(method.getName(), v -> new ArrayList<>());

                    List<ArgumentNameAndType> overload = new ArrayList<>();
                    overloads.add(overload);

                    for (Parameter param : method.getParameters()) {
                        String typeName;
                        Class<?> type = param.getType();
                        if (type.isArray()) {
                            Class<?> componentType = type.getComponentType();
                            if (BASE_TYPE_SET.contains(componentType)) {
                                typeName = ""BaseType"";
                            } else {
                                typeName = type.getComponentType().getSimpleName() + ""[]"";
                            }
                        } else
                        if (BASE_TYPE_SET.contains(type)) {
                            typeName = ""BaseType"";
                        } else {
                            typeName = type.getSimpleName();
                        }
                        String name = param.getName();
                        if (name.equals(""bufferSize"") || name.equals(""prefetch"") || name.equals(""capacityHint"")) {
                            name = ""bufferSize|prefetch|capacityHint"";
                        }
                        if (name.equals(""subscriber"") || name.equals(""observer"")) {
                            name = ""subscriber|observer"";
                        }
                        if (name.contains(""onNext"")) {
                            name = name.replace(""onNext"", ""onNext|onSuccess"");
                        } else
                        if (name.contains(""onSuccess"")) {
                            name = name.replace(""onSuccess"", ""onNext|onSuccess"");
                        }
                        overload.add(new ArgumentNameAndType(typeName, name));
                    }
                }
            }
        }

        int counter = 0;

        for (int i = 0; i < CLASSES.length - 1; i++) {
            String firstName = CLASSES[i].getSimpleName();
            Map<String, List<List<ArgumentNameAndType>>> firstClassMethods = map.get(firstName);
            for (int j = i + 1; j < CLASSES.length; j++) {
                String secondName = CLASSES[j].getSimpleName();
                Map<String, List<List<ArgumentNameAndType>>> secondClassMethods = map.get(secondName);

                for (Map.Entry<String, List<List<ArgumentNameAndType>>> methodOverloadsFirst : firstClassMethods.entrySet()) {

                    List<List<ArgumentNameAndType>> methodOverloadsSecond = secondClassMethods.get(methodOverloadsFirst.getKey());

                    if (methodOverloadsSecond != null) {
                        for (List<ArgumentNameAndType> overloadFirst : methodOverloadsFirst.getValue()) {
                            for (List<ArgumentNameAndType> overloadSecond : methodOverloadsSecond) {
                                if (overloadFirst.size() == overloadSecond.size()) {
                                    // Argument types match?
                                    boolean match = true;
                                    for (int k = 0; k < overloadFirst.size(); k++) {
                                        if (!overloadFirst.get(k).type.equals(overloadSecond.get(k).type)) {
                                            match = false;
                                            break;
                                        }
                                    }
                                    // Argument names match?
                                    if (match) {
                                        for (int k = 0; k < overloadFirst.size(); k++) {
                                            if (!overloadFirst.get(k).name.equals(overloadSecond.get(k).name)) {
                                                System.out.print(""Argument naming mismatch #"");
                                                System.out.println(++counter);

                                                System.out.print(""  "");
                                                System.out.print(Strings.padEnd(firstName, Math.max(firstName.length(), secondName.length()) + 1, ' '));
                                                System.out.print(methodOverloadsFirst.getKey());
                                                System.out.print(""  "");
                                                System.out.println(overloadFirst);

                                                System.out.print(""  "");
                                                System.out.print(Strings.padEnd(secondName, Math.max(firstName.length(), secondName.length()) + 1, ' '));
                                                System.out.print(methodOverloadsFirst.getKey());
                                                System.out.print(""  "");
                                                System.out.println(overloadSecond);
                                                System.out.println();
                                                break;
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
            }
        }
    }",iterator
method,"{
        // className -> methodName -> overloads -> arguments
        Map<String, Map<String, List<List<ArgumentNameAndType>>>> map = new HashMap<>();

        for (Class<?> clazz : CLASSES) {
            Map<String, List<List<ArgumentNameAndType>>> classMethods = map.computeIfAbsent(clazz.getSimpleName(), v -> new HashMap<>());
            for (Method method : clazz.getDeclaredMethods()) {
                if (method.getDeclaringClass() == clazz && method.getParameterCount() != 0) {
                    List<List<ArgumentNameAndType>> overloads = classMethods.computeIfAbsent(method.getName(), v -> new ArrayList<>());

                    List<ArgumentNameAndType> overload = new ArrayList<>();
                    overloads.add(overload);

                    for (Parameter param : method.getParameters()) {
                        String typeName;
                        Class<?> type = param.getType();
                        if (type.isArray()) {
                            Class<?> componentType = type.getComponentType();
                            if (BASE_TYPE_SET.contains(componentType)) {
                                typeName = ""BaseType"";
                            } else {
                                typeName = type.getComponentType().getSimpleName() + ""[]"";
                            }
                        } else
                        if (BASE_TYPE_SET.contains(type)) {
                            typeName = ""BaseType"";
                        } else {
                            typeName = type.getSimpleName();
                        }
                        String name = param.getName();
                        if (name.equals(""bufferSize"") || name.equals(""prefetch"") || name.equals(""capacityHint"")) {
                            name = ""bufferSize|prefetch|capacityHint"";
                        }
                        if (name.equals(""subscriber"") || name.equals(""observer"")) {
                            name = ""subscriber|observer"";
                        }
                        if (name.contains(""onNext"")) {
                            name = name.replace(""onNext"", ""onNext|onSuccess"");
                        } else
                        if (name.contains(""onSuccess"")) {
                            name = name.replace(""onSuccess"", ""onNext|onSuccess"");
                        }
                        overload.add(new ArgumentNameAndType(typeName, name));
                    }
                }
            }
        }

        int counter = 0;

        for (int i = 0; i < CLASSES.length - 1; i++) {
            String firstName = CLASSES[i].getSimpleName();
            Map<String, List<List<ArgumentNameAndType>>> firstClassMethods = map.get(firstName);
            for (int j = i + 1; j < CLASSES.length; j++) {
                String secondName = CLASSES[j].getSimpleName();
                Map<String, List<List<ArgumentNameAndType>>> secondClassMethods = map.get(secondName);

                for (Map.Entry<String, List<List<ArgumentNameAndType>>> methodOverloadsFirst : firstClassMethods.entrySet()) {

                    List<List<ArgumentNameAndType>> methodOverloadsSecond = secondClassMethods.get(methodOverloadsFirst.getKey());

                    if (methodOverloadsSecond != null) {
                        for (List<ArgumentNameAndType> overloadFirst : methodOverloadsFirst.getValue()) {
                            for (List<ArgumentNameAndType> overloadSecond : methodOverloadsSecond) {
                                if (overloadFirst.size() == overloadSecond.size()) {
                                    // Argument types match?
                                    boolean match = true;
                                    for (int k = 0; k < overloadFirst.size(); k++) {
                                        if (!overloadFirst.get(k).type.equals(overloadSecond.get(k).type)) {
                                            match = false;
                                            break;
                                        }
                                    }
                                    // Argument names match?
                                    if (match) {
                                        for (int k = 0; k < overloadFirst.size(); k++) {
                                            if (!overloadFirst.get(k).name.equals(overloadSecond.get(k).name)) {
                                                System.out.print(""Argument naming mismatch #"");
                                                System.out.println(++counter);

                                                System.out.print(""  "");
                                                System.out.print(Strings.padEnd(firstName, Math.max(firstName.length(), secondName.length()) + 1, ' '));
                                                System.out.print(methodOverloadsFirst.getKey());
                                                System.out.print(""  "");
                                                System.out.println(overloadFirst);

                                                System.out.print(""  "");
                                                System.out.print(Strings.padEnd(secondName, Math.max(firstName.length(), secondName.length()) + 1, ' '));
                                                System.out.print(methodOverloadsFirst.getKey());
                                                System.out.print(""  "");
                                                System.out.println(overloadSecond);
                                                System.out.println();
                                                break;
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
            }
        }
    }",iterator
param,"{
        // className -> methodName -> overloads -> arguments
        Map<String, Map<String, List<List<ArgumentNameAndType>>>> map = new HashMap<>();

        for (Class<?> clazz : CLASSES) {
            Map<String, List<List<ArgumentNameAndType>>> classMethods = map.computeIfAbsent(clazz.getSimpleName(), v -> new HashMap<>());
            for (Method method : clazz.getDeclaredMethods()) {
                if (method.getDeclaringClass() == clazz && method.getParameterCount() != 0) {
                    List<List<ArgumentNameAndType>> overloads = classMethods.computeIfAbsent(method.getName(), v -> new ArrayList<>());

                    List<ArgumentNameAndType> overload = new ArrayList<>();
                    overloads.add(overload);

                    for (Parameter param : method.getParameters()) {
                        String typeName;
                        Class<?> type = param.getType();
                        if (type.isArray()) {
                            Class<?> componentType = type.getComponentType();
                            if (BASE_TYPE_SET.contains(componentType)) {
                                typeName = ""BaseType"";
                            } else {
                                typeName = type.getComponentType().getSimpleName() + ""[]"";
                            }
                        } else
                        if (BASE_TYPE_SET.contains(type)) {
                            typeName = ""BaseType"";
                        } else {
                            typeName = type.getSimpleName();
                        }
                        String name = param.getName();
                        if (name.equals(""bufferSize"") || name.equals(""prefetch"") || name.equals(""capacityHint"")) {
                            name = ""bufferSize|prefetch|capacityHint"";
                        }
                        if (name.equals(""subscriber"") || name.equals(""observer"")) {
                            name = ""subscriber|observer"";
                        }
                        if (name.contains(""onNext"")) {
                            name = name.replace(""onNext"", ""onNext|onSuccess"");
                        } else
                        if (name.contains(""onSuccess"")) {
                            name = name.replace(""onSuccess"", ""onNext|onSuccess"");
                        }
                        overload.add(new ArgumentNameAndType(typeName, name));
                    }
                }
            }
        }

        int counter = 0;

        for (int i = 0; i < CLASSES.length - 1; i++) {
            String firstName = CLASSES[i].getSimpleName();
            Map<String, List<List<ArgumentNameAndType>>> firstClassMethods = map.get(firstName);
            for (int j = i + 1; j < CLASSES.length; j++) {
                String secondName = CLASSES[j].getSimpleName();
                Map<String, List<List<ArgumentNameAndType>>> secondClassMethods = map.get(secondName);

                for (Map.Entry<String, List<List<ArgumentNameAndType>>> methodOverloadsFirst : firstClassMethods.entrySet()) {

                    List<List<ArgumentNameAndType>> methodOverloadsSecond = secondClassMethods.get(methodOverloadsFirst.getKey());

                    if (methodOverloadsSecond != null) {
                        for (List<ArgumentNameAndType> overloadFirst : methodOverloadsFirst.getValue()) {
                            for (List<ArgumentNameAndType> overloadSecond : methodOverloadsSecond) {
                                if (overloadFirst.size() == overloadSecond.size()) {
                                    // Argument types match?
                                    boolean match = true;
                                    for (int k = 0; k < overloadFirst.size(); k++) {
                                        if (!overloadFirst.get(k).type.equals(overloadSecond.get(k).type)) {
                                            match = false;
                                            break;
                                        }
                                    }
                                    // Argument names match?
                                    if (match) {
                                        for (int k = 0; k < overloadFirst.size(); k++) {
                                            if (!overloadFirst.get(k).name.equals(overloadSecond.get(k).name)) {
                                                System.out.print(""Argument naming mismatch #"");
                                                System.out.println(++counter);

                                                System.out.print(""  "");
                                                System.out.print(Strings.padEnd(firstName, Math.max(firstName.length(), secondName.length()) + 1, ' '));
                                                System.out.print(methodOverloadsFirst.getKey());
                                                System.out.print(""  "");
                                                System.out.println(overloadFirst);

                                                System.out.print(""  "");
                                                System.out.print(Strings.padEnd(secondName, Math.max(firstName.length(), secondName.length()) + 1, ' '));
                                                System.out.print(methodOverloadsFirst.getKey());
                                                System.out.print(""  "");
                                                System.out.println(overloadSecond);
                                                System.out.println();
                                                break;
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
            }
        }
    }",iterator
i,"{
        // className -> methodName -> overloads -> arguments
        Map<String, Map<String, List<List<ArgumentNameAndType>>>> map = new HashMap<>();

        for (Class<?> clazz : CLASSES) {
            Map<String, List<List<ArgumentNameAndType>>> classMethods = map.computeIfAbsent(clazz.getSimpleName(), v -> new HashMap<>());
            for (Method method : clazz.getDeclaredMethods()) {
                if (method.getDeclaringClass() == clazz && method.getParameterCount() != 0) {
                    List<List<ArgumentNameAndType>> overloads = classMethods.computeIfAbsent(method.getName(), v -> new ArrayList<>());

                    List<ArgumentNameAndType> overload = new ArrayList<>();
                    overloads.add(overload);

                    for (Parameter param : method.getParameters()) {
                        String typeName;
                        Class<?> type = param.getType();
                        if (type.isArray()) {
                            Class<?> componentType = type.getComponentType();
                            if (BASE_TYPE_SET.contains(componentType)) {
                                typeName = ""BaseType"";
                            } else {
                                typeName = type.getComponentType().getSimpleName() + ""[]"";
                            }
                        } else
                        if (BASE_TYPE_SET.contains(type)) {
                            typeName = ""BaseType"";
                        } else {
                            typeName = type.getSimpleName();
                        }
                        String name = param.getName();
                        if (name.equals(""bufferSize"") || name.equals(""prefetch"") || name.equals(""capacityHint"")) {
                            name = ""bufferSize|prefetch|capacityHint"";
                        }
                        if (name.equals(""subscriber"") || name.equals(""observer"")) {
                            name = ""subscriber|observer"";
                        }
                        if (name.contains(""onNext"")) {
                            name = name.replace(""onNext"", ""onNext|onSuccess"");
                        } else
                        if (name.contains(""onSuccess"")) {
                            name = name.replace(""onSuccess"", ""onNext|onSuccess"");
                        }
                        overload.add(new ArgumentNameAndType(typeName, name));
                    }
                }
            }
        }

        int counter = 0;

        for (int i = 0; i < CLASSES.length - 1; i++) {
            String firstName = CLASSES[i].getSimpleName();
            Map<String, List<List<ArgumentNameAndType>>> firstClassMethods = map.get(firstName);
            for (int j = i + 1; j < CLASSES.length; j++) {
                String secondName = CLASSES[j].getSimpleName();
                Map<String, List<List<ArgumentNameAndType>>> secondClassMethods = map.get(secondName);

                for (Map.Entry<String, List<List<ArgumentNameAndType>>> methodOverloadsFirst : firstClassMethods.entrySet()) {

                    List<List<ArgumentNameAndType>> methodOverloadsSecond = secondClassMethods.get(methodOverloadsFirst.getKey());

                    if (methodOverloadsSecond != null) {
                        for (List<ArgumentNameAndType> overloadFirst : methodOverloadsFirst.getValue()) {
                            for (List<ArgumentNameAndType> overloadSecond : methodOverloadsSecond) {
                                if (overloadFirst.size() == overloadSecond.size()) {
                                    // Argument types match?
                                    boolean match = true;
                                    for (int k = 0; k < overloadFirst.size(); k++) {
                                        if (!overloadFirst.get(k).type.equals(overloadSecond.get(k).type)) {
                                            match = false;
                                            break;
                                        }
                                    }
                                    // Argument names match?
                                    if (match) {
                                        for (int k = 0; k < overloadFirst.size(); k++) {
                                            if (!overloadFirst.get(k).name.equals(overloadSecond.get(k).name)) {
                                                System.out.print(""Argument naming mismatch #"");
                                                System.out.println(++counter);

                                                System.out.print(""  "");
                                                System.out.print(Strings.padEnd(firstName, Math.max(firstName.length(), secondName.length()) + 1, ' '));
                                                System.out.print(methodOverloadsFirst.getKey());
                                                System.out.print(""  "");
                                                System.out.println(overloadFirst);

                                                System.out.print(""  "");
                                                System.out.print(Strings.padEnd(secondName, Math.max(firstName.length(), secondName.length()) + 1, ' '));
                                                System.out.print(methodOverloadsFirst.getKey());
                                                System.out.print(""  "");
                                                System.out.println(overloadSecond);
                                                System.out.println();
                                                break;
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
            }
        }
    }",loop_control
j,"{
        // className -> methodName -> overloads -> arguments
        Map<String, Map<String, List<List<ArgumentNameAndType>>>> map = new HashMap<>();

        for (Class<?> clazz : CLASSES) {
            Map<String, List<List<ArgumentNameAndType>>> classMethods = map.computeIfAbsent(clazz.getSimpleName(), v -> new HashMap<>());
            for (Method method : clazz.getDeclaredMethods()) {
                if (method.getDeclaringClass() == clazz && method.getParameterCount() != 0) {
                    List<List<ArgumentNameAndType>> overloads = classMethods.computeIfAbsent(method.getName(), v -> new ArrayList<>());

                    List<ArgumentNameAndType> overload = new ArrayList<>();
                    overloads.add(overload);

                    for (Parameter param : method.getParameters()) {
                        String typeName;
                        Class<?> type = param.getType();
                        if (type.isArray()) {
                            Class<?> componentType = type.getComponentType();
                            if (BASE_TYPE_SET.contains(componentType)) {
                                typeName = ""BaseType"";
                            } else {
                                typeName = type.getComponentType().getSimpleName() + ""[]"";
                            }
                        } else
                        if (BASE_TYPE_SET.contains(type)) {
                            typeName = ""BaseType"";
                        } else {
                            typeName = type.getSimpleName();
                        }
                        String name = param.getName();
                        if (name.equals(""bufferSize"") || name.equals(""prefetch"") || name.equals(""capacityHint"")) {
                            name = ""bufferSize|prefetch|capacityHint"";
                        }
                        if (name.equals(""subscriber"") || name.equals(""observer"")) {
                            name = ""subscriber|observer"";
                        }
                        if (name.contains(""onNext"")) {
                            name = name.replace(""onNext"", ""onNext|onSuccess"");
                        } else
                        if (name.contains(""onSuccess"")) {
                            name = name.replace(""onSuccess"", ""onNext|onSuccess"");
                        }
                        overload.add(new ArgumentNameAndType(typeName, name));
                    }
                }
            }
        }

        int counter = 0;

        for (int i = 0; i < CLASSES.length - 1; i++) {
            String firstName = CLASSES[i].getSimpleName();
            Map<String, List<List<ArgumentNameAndType>>> firstClassMethods = map.get(firstName);
            for (int j = i + 1; j < CLASSES.length; j++) {
                String secondName = CLASSES[j].getSimpleName();
                Map<String, List<List<ArgumentNameAndType>>> secondClassMethods = map.get(secondName);

                for (Map.Entry<String, List<List<ArgumentNameAndType>>> methodOverloadsFirst : firstClassMethods.entrySet()) {

                    List<List<ArgumentNameAndType>> methodOverloadsSecond = secondClassMethods.get(methodOverloadsFirst.getKey());

                    if (methodOverloadsSecond != null) {
                        for (List<ArgumentNameAndType> overloadFirst : methodOverloadsFirst.getValue()) {
                            for (List<ArgumentNameAndType> overloadSecond : methodOverloadsSecond) {
                                if (overloadFirst.size() == overloadSecond.size()) {
                                    // Argument types match?
                                    boolean match = true;
                                    for (int k = 0; k < overloadFirst.size(); k++) {
                                        if (!overloadFirst.get(k).type.equals(overloadSecond.get(k).type)) {
                                            match = false;
                                            break;
                                        }
                                    }
                                    // Argument names match?
                                    if (match) {
                                        for (int k = 0; k < overloadFirst.size(); k++) {
                                            if (!overloadFirst.get(k).name.equals(overloadSecond.get(k).name)) {
                                                System.out.print(""Argument naming mismatch #"");
                                                System.out.println(++counter);

                                                System.out.print(""  "");
                                                System.out.print(Strings.padEnd(firstName, Math.max(firstName.length(), secondName.length()) + 1, ' '));
                                                System.out.print(methodOverloadsFirst.getKey());
                                                System.out.print(""  "");
                                                System.out.println(overloadFirst);

                                                System.out.print(""  "");
                                                System.out.print(Strings.padEnd(secondName, Math.max(firstName.length(), secondName.length()) + 1, ' '));
                                                System.out.print(methodOverloadsFirst.getKey());
                                                System.out.print(""  "");
                                                System.out.println(overloadSecond);
                                                System.out.println();
                                                break;
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
            }
        }
    }",loop_control
methodOverloadsFirst,"{
        // className -> methodName -> overloads -> arguments
        Map<String, Map<String, List<List<ArgumentNameAndType>>>> map = new HashMap<>();

        for (Class<?> clazz : CLASSES) {
            Map<String, List<List<ArgumentNameAndType>>> classMethods = map.computeIfAbsent(clazz.getSimpleName(), v -> new HashMap<>());
            for (Method method : clazz.getDeclaredMethods()) {
                if (method.getDeclaringClass() == clazz && method.getParameterCount() != 0) {
                    List<List<ArgumentNameAndType>> overloads = classMethods.computeIfAbsent(method.getName(), v -> new ArrayList<>());

                    List<ArgumentNameAndType> overload = new ArrayList<>();
                    overloads.add(overload);

                    for (Parameter param : method.getParameters()) {
                        String typeName;
                        Class<?> type = param.getType();
                        if (type.isArray()) {
                            Class<?> componentType = type.getComponentType();
                            if (BASE_TYPE_SET.contains(componentType)) {
                                typeName = ""BaseType"";
                            } else {
                                typeName = type.getComponentType().getSimpleName() + ""[]"";
                            }
                        } else
                        if (BASE_TYPE_SET.contains(type)) {
                            typeName = ""BaseType"";
                        } else {
                            typeName = type.getSimpleName();
                        }
                        String name = param.getName();
                        if (name.equals(""bufferSize"") || name.equals(""prefetch"") || name.equals(""capacityHint"")) {
                            name = ""bufferSize|prefetch|capacityHint"";
                        }
                        if (name.equals(""subscriber"") || name.equals(""observer"")) {
                            name = ""subscriber|observer"";
                        }
                        if (name.contains(""onNext"")) {
                            name = name.replace(""onNext"", ""onNext|onSuccess"");
                        } else
                        if (name.contains(""onSuccess"")) {
                            name = name.replace(""onSuccess"", ""onNext|onSuccess"");
                        }
                        overload.add(new ArgumentNameAndType(typeName, name));
                    }
                }
            }
        }

        int counter = 0;

        for (int i = 0; i < CLASSES.length - 1; i++) {
            String firstName = CLASSES[i].getSimpleName();
            Map<String, List<List<ArgumentNameAndType>>> firstClassMethods = map.get(firstName);
            for (int j = i + 1; j < CLASSES.length; j++) {
                String secondName = CLASSES[j].getSimpleName();
                Map<String, List<List<ArgumentNameAndType>>> secondClassMethods = map.get(secondName);

                for (Map.Entry<String, List<List<ArgumentNameAndType>>> methodOverloadsFirst : firstClassMethods.entrySet()) {

                    List<List<ArgumentNameAndType>> methodOverloadsSecond = secondClassMethods.get(methodOverloadsFirst.getKey());

                    if (methodOverloadsSecond != null) {
                        for (List<ArgumentNameAndType> overloadFirst : methodOverloadsFirst.getValue()) {
                            for (List<ArgumentNameAndType> overloadSecond : methodOverloadsSecond) {
                                if (overloadFirst.size() == overloadSecond.size()) {
                                    // Argument types match?
                                    boolean match = true;
                                    for (int k = 0; k < overloadFirst.size(); k++) {
                                        if (!overloadFirst.get(k).type.equals(overloadSecond.get(k).type)) {
                                            match = false;
                                            break;
                                        }
                                    }
                                    // Argument names match?
                                    if (match) {
                                        for (int k = 0; k < overloadFirst.size(); k++) {
                                            if (!overloadFirst.get(k).name.equals(overloadSecond.get(k).name)) {
                                                System.out.print(""Argument naming mismatch #"");
                                                System.out.println(++counter);

                                                System.out.print(""  "");
                                                System.out.print(Strings.padEnd(firstName, Math.max(firstName.length(), secondName.length()) + 1, ' '));
                                                System.out.print(methodOverloadsFirst.getKey());
                                                System.out.print(""  "");
                                                System.out.println(overloadFirst);

                                                System.out.print(""  "");
                                                System.out.print(Strings.padEnd(secondName, Math.max(firstName.length(), secondName.length()) + 1, ' '));
                                                System.out.print(methodOverloadsFirst.getKey());
                                                System.out.print(""  "");
                                                System.out.println(overloadSecond);
                                                System.out.println();
                                                break;
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
            }
        }
    }",iterator
overloadFirst,"{
        // className -> methodName -> overloads -> arguments
        Map<String, Map<String, List<List<ArgumentNameAndType>>>> map = new HashMap<>();

        for (Class<?> clazz : CLASSES) {
            Map<String, List<List<ArgumentNameAndType>>> classMethods = map.computeIfAbsent(clazz.getSimpleName(), v -> new HashMap<>());
            for (Method method : clazz.getDeclaredMethods()) {
                if (method.getDeclaringClass() == clazz && method.getParameterCount() != 0) {
                    List<List<ArgumentNameAndType>> overloads = classMethods.computeIfAbsent(method.getName(), v -> new ArrayList<>());

                    List<ArgumentNameAndType> overload = new ArrayList<>();
                    overloads.add(overload);

                    for (Parameter param : method.getParameters()) {
                        String typeName;
                        Class<?> type = param.getType();
                        if (type.isArray()) {
                            Class<?> componentType = type.getComponentType();
                            if (BASE_TYPE_SET.contains(componentType)) {
                                typeName = ""BaseType"";
                            } else {
                                typeName = type.getComponentType().getSimpleName() + ""[]"";
                            }
                        } else
                        if (BASE_TYPE_SET.contains(type)) {
                            typeName = ""BaseType"";
                        } else {
                            typeName = type.getSimpleName();
                        }
                        String name = param.getName();
                        if (name.equals(""bufferSize"") || name.equals(""prefetch"") || name.equals(""capacityHint"")) {
                            name = ""bufferSize|prefetch|capacityHint"";
                        }
                        if (name.equals(""subscriber"") || name.equals(""observer"")) {
                            name = ""subscriber|observer"";
                        }
                        if (name.contains(""onNext"")) {
                            name = name.replace(""onNext"", ""onNext|onSuccess"");
                        } else
                        if (name.contains(""onSuccess"")) {
                            name = name.replace(""onSuccess"", ""onNext|onSuccess"");
                        }
                        overload.add(new ArgumentNameAndType(typeName, name));
                    }
                }
            }
        }

        int counter = 0;

        for (int i = 0; i < CLASSES.length - 1; i++) {
            String firstName = CLASSES[i].getSimpleName();
            Map<String, List<List<ArgumentNameAndType>>> firstClassMethods = map.get(firstName);
            for (int j = i + 1; j < CLASSES.length; j++) {
                String secondName = CLASSES[j].getSimpleName();
                Map<String, List<List<ArgumentNameAndType>>> secondClassMethods = map.get(secondName);

                for (Map.Entry<String, List<List<ArgumentNameAndType>>> methodOverloadsFirst : firstClassMethods.entrySet()) {

                    List<List<ArgumentNameAndType>> methodOverloadsSecond = secondClassMethods.get(methodOverloadsFirst.getKey());

                    if (methodOverloadsSecond != null) {
                        for (List<ArgumentNameAndType> overloadFirst : methodOverloadsFirst.getValue()) {
                            for (List<ArgumentNameAndType> overloadSecond : methodOverloadsSecond) {
                                if (overloadFirst.size() == overloadSecond.size()) {
                                    // Argument types match?
                                    boolean match = true;
                                    for (int k = 0; k < overloadFirst.size(); k++) {
                                        if (!overloadFirst.get(k).type.equals(overloadSecond.get(k).type)) {
                                            match = false;
                                            break;
                                        }
                                    }
                                    // Argument names match?
                                    if (match) {
                                        for (int k = 0; k < overloadFirst.size(); k++) {
                                            if (!overloadFirst.get(k).name.equals(overloadSecond.get(k).name)) {
                                                System.out.print(""Argument naming mismatch #"");
                                                System.out.println(++counter);

                                                System.out.print(""  "");
                                                System.out.print(Strings.padEnd(firstName, Math.max(firstName.length(), secondName.length()) + 1, ' '));
                                                System.out.print(methodOverloadsFirst.getKey());
                                                System.out.print(""  "");
                                                System.out.println(overloadFirst);

                                                System.out.print(""  "");
                                                System.out.print(Strings.padEnd(secondName, Math.max(firstName.length(), secondName.length()) + 1, ' '));
                                                System.out.print(methodOverloadsFirst.getKey());
                                                System.out.print(""  "");
                                                System.out.println(overloadSecond);
                                                System.out.println();
                                                break;
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
            }
        }
    }",iterator
overloadSecond,"{
        // className -> methodName -> overloads -> arguments
        Map<String, Map<String, List<List<ArgumentNameAndType>>>> map = new HashMap<>();

        for (Class<?> clazz : CLASSES) {
            Map<String, List<List<ArgumentNameAndType>>> classMethods = map.computeIfAbsent(clazz.getSimpleName(), v -> new HashMap<>());
            for (Method method : clazz.getDeclaredMethods()) {
                if (method.getDeclaringClass() == clazz && method.getParameterCount() != 0) {
                    List<List<ArgumentNameAndType>> overloads = classMethods.computeIfAbsent(method.getName(), v -> new ArrayList<>());

                    List<ArgumentNameAndType> overload = new ArrayList<>();
                    overloads.add(overload);

                    for (Parameter param : method.getParameters()) {
                        String typeName;
                        Class<?> type = param.getType();
                        if (type.isArray()) {
                            Class<?> componentType = type.getComponentType();
                            if (BASE_TYPE_SET.contains(componentType)) {
                                typeName = ""BaseType"";
                            } else {
                                typeName = type.getComponentType().getSimpleName() + ""[]"";
                            }
                        } else
                        if (BASE_TYPE_SET.contains(type)) {
                            typeName = ""BaseType"";
                        } else {
                            typeName = type.getSimpleName();
                        }
                        String name = param.getName();
                        if (name.equals(""bufferSize"") || name.equals(""prefetch"") || name.equals(""capacityHint"")) {
                            name = ""bufferSize|prefetch|capacityHint"";
                        }
                        if (name.equals(""subscriber"") || name.equals(""observer"")) {
                            name = ""subscriber|observer"";
                        }
                        if (name.contains(""onNext"")) {
                            name = name.replace(""onNext"", ""onNext|onSuccess"");
                        } else
                        if (name.contains(""onSuccess"")) {
                            name = name.replace(""onSuccess"", ""onNext|onSuccess"");
                        }
                        overload.add(new ArgumentNameAndType(typeName, name));
                    }
                }
            }
        }

        int counter = 0;

        for (int i = 0; i < CLASSES.length - 1; i++) {
            String firstName = CLASSES[i].getSimpleName();
            Map<String, List<List<ArgumentNameAndType>>> firstClassMethods = map.get(firstName);
            for (int j = i + 1; j < CLASSES.length; j++) {
                String secondName = CLASSES[j].getSimpleName();
                Map<String, List<List<ArgumentNameAndType>>> secondClassMethods = map.get(secondName);

                for (Map.Entry<String, List<List<ArgumentNameAndType>>> methodOverloadsFirst : firstClassMethods.entrySet()) {

                    List<List<ArgumentNameAndType>> methodOverloadsSecond = secondClassMethods.get(methodOverloadsFirst.getKey());

                    if (methodOverloadsSecond != null) {
                        for (List<ArgumentNameAndType> overloadFirst : methodOverloadsFirst.getValue()) {
                            for (List<ArgumentNameAndType> overloadSecond : methodOverloadsSecond) {
                                if (overloadFirst.size() == overloadSecond.size()) {
                                    // Argument types match?
                                    boolean match = true;
                                    for (int k = 0; k < overloadFirst.size(); k++) {
                                        if (!overloadFirst.get(k).type.equals(overloadSecond.get(k).type)) {
                                            match = false;
                                            break;
                                        }
                                    }
                                    // Argument names match?
                                    if (match) {
                                        for (int k = 0; k < overloadFirst.size(); k++) {
                                            if (!overloadFirst.get(k).name.equals(overloadSecond.get(k).name)) {
                                                System.out.print(""Argument naming mismatch #"");
                                                System.out.println(++counter);

                                                System.out.print(""  "");
                                                System.out.print(Strings.padEnd(firstName, Math.max(firstName.length(), secondName.length()) + 1, ' '));
                                                System.out.print(methodOverloadsFirst.getKey());
                                                System.out.print(""  "");
                                                System.out.println(overloadFirst);

                                                System.out.print(""  "");
                                                System.out.print(Strings.padEnd(secondName, Math.max(firstName.length(), secondName.length()) + 1, ' '));
                                                System.out.print(methodOverloadsFirst.getKey());
                                                System.out.print(""  "");
                                                System.out.println(overloadSecond);
                                                System.out.println();
                                                break;
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
            }
        }
    }",iterator
k,"{
        // className -> methodName -> overloads -> arguments
        Map<String, Map<String, List<List<ArgumentNameAndType>>>> map = new HashMap<>();

        for (Class<?> clazz : CLASSES) {
            Map<String, List<List<ArgumentNameAndType>>> classMethods = map.computeIfAbsent(clazz.getSimpleName(), v -> new HashMap<>());
            for (Method method : clazz.getDeclaredMethods()) {
                if (method.getDeclaringClass() == clazz && method.getParameterCount() != 0) {
                    List<List<ArgumentNameAndType>> overloads = classMethods.computeIfAbsent(method.getName(), v -> new ArrayList<>());

                    List<ArgumentNameAndType> overload = new ArrayList<>();
                    overloads.add(overload);

                    for (Parameter param : method.getParameters()) {
                        String typeName;
                        Class<?> type = param.getType();
                        if (type.isArray()) {
                            Class<?> componentType = type.getComponentType();
                            if (BASE_TYPE_SET.contains(componentType)) {
                                typeName = ""BaseType"";
                            } else {
                                typeName = type.getComponentType().getSimpleName() + ""[]"";
                            }
                        } else
                        if (BASE_TYPE_SET.contains(type)) {
                            typeName = ""BaseType"";
                        } else {
                            typeName = type.getSimpleName();
                        }
                        String name = param.getName();
                        if (name.equals(""bufferSize"") || name.equals(""prefetch"") || name.equals(""capacityHint"")) {
                            name = ""bufferSize|prefetch|capacityHint"";
                        }
                        if (name.equals(""subscriber"") || name.equals(""observer"")) {
                            name = ""subscriber|observer"";
                        }
                        if (name.contains(""onNext"")) {
                            name = name.replace(""onNext"", ""onNext|onSuccess"");
                        } else
                        if (name.contains(""onSuccess"")) {
                            name = name.replace(""onSuccess"", ""onNext|onSuccess"");
                        }
                        overload.add(new ArgumentNameAndType(typeName, name));
                    }
                }
            }
        }

        int counter = 0;

        for (int i = 0; i < CLASSES.length - 1; i++) {
            String firstName = CLASSES[i].getSimpleName();
            Map<String, List<List<ArgumentNameAndType>>> firstClassMethods = map.get(firstName);
            for (int j = i + 1; j < CLASSES.length; j++) {
                String secondName = CLASSES[j].getSimpleName();
                Map<String, List<List<ArgumentNameAndType>>> secondClassMethods = map.get(secondName);

                for (Map.Entry<String, List<List<ArgumentNameAndType>>> methodOverloadsFirst : firstClassMethods.entrySet()) {

                    List<List<ArgumentNameAndType>> methodOverloadsSecond = secondClassMethods.get(methodOverloadsFirst.getKey());

                    if (methodOverloadsSecond != null) {
                        for (List<ArgumentNameAndType> overloadFirst : methodOverloadsFirst.getValue()) {
                            for (List<ArgumentNameAndType> overloadSecond : methodOverloadsSecond) {
                                if (overloadFirst.size() == overloadSecond.size()) {
                                    // Argument types match?
                                    boolean match = true;
                                    for (int k = 0; k < overloadFirst.size(); k++) {
                                        if (!overloadFirst.get(k).type.equals(overloadSecond.get(k).type)) {
                                            match = false;
                                            break;
                                        }
                                    }
                                    // Argument names match?
                                    if (match) {
                                        for (int k = 0; k < overloadFirst.size(); k++) {
                                            if (!overloadFirst.get(k).name.equals(overloadSecond.get(k).name)) {
                                                System.out.print(""Argument naming mismatch #"");
                                                System.out.println(++counter);

                                                System.out.print(""  "");
                                                System.out.print(Strings.padEnd(firstName, Math.max(firstName.length(), secondName.length()) + 1, ' '));
                                                System.out.print(methodOverloadsFirst.getKey());
                                                System.out.print(""  "");
                                                System.out.println(overloadFirst);

                                                System.out.print(""  "");
                                                System.out.print(Strings.padEnd(secondName, Math.max(firstName.length(), secondName.length()) + 1, ' '));
                                                System.out.print(methodOverloadsFirst.getKey());
                                                System.out.print(""  "");
                                                System.out.println(overloadSecond);
                                                System.out.println();
                                                break;
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
            }
        }
    }",loop_control
overloadFirst,"{
        // className -> methodName -> overloads -> arguments
        Map<String, Map<String, List<List<ArgumentNameAndType>>>> map = new HashMap<>();

        for (Class<?> clazz : CLASSES) {
            Map<String, List<List<ArgumentNameAndType>>> classMethods = map.computeIfAbsent(clazz.getSimpleName(), v -> new HashMap<>());
            for (Method method : clazz.getDeclaredMethods()) {
                if (method.getDeclaringClass() == clazz && method.getParameterCount() != 0) {
                    List<List<ArgumentNameAndType>> overloads = classMethods.computeIfAbsent(method.getName(), v -> new ArrayList<>());

                    List<ArgumentNameAndType> overload = new ArrayList<>();
                    overloads.add(overload);

                    for (Parameter param : method.getParameters()) {
                        String typeName;
                        Class<?> type = param.getType();
                        if (type.isArray()) {
                            Class<?> componentType = type.getComponentType();
                            if (BASE_TYPE_SET.contains(componentType)) {
                                typeName = ""BaseType"";
                            } else {
                                typeName = type.getComponentType().getSimpleName() + ""[]"";
                            }
                        } else
                        if (BASE_TYPE_SET.contains(type)) {
                            typeName = ""BaseType"";
                        } else {
                            typeName = type.getSimpleName();
                        }
                        String name = param.getName();
                        if (name.equals(""bufferSize"") || name.equals(""prefetch"") || name.equals(""capacityHint"")) {
                            name = ""bufferSize|prefetch|capacityHint"";
                        }
                        if (name.equals(""subscriber"") || name.equals(""observer"")) {
                            name = ""subscriber|observer"";
                        }
                        if (name.contains(""onNext"")) {
                            name = name.replace(""onNext"", ""onNext|onSuccess"");
                        } else
                        if (name.contains(""onSuccess"")) {
                            name = name.replace(""onSuccess"", ""onNext|onSuccess"");
                        }
                        overload.add(new ArgumentNameAndType(typeName, name));
                    }
                }
            }
        }

        int counter = 0;

        for (int i = 0; i < CLASSES.length - 1; i++) {
            String firstName = CLASSES[i].getSimpleName();
            Map<String, List<List<ArgumentNameAndType>>> firstClassMethods = map.get(firstName);
            for (int j = i + 1; j < CLASSES.length; j++) {
                String secondName = CLASSES[j].getSimpleName();
                Map<String, List<List<ArgumentNameAndType>>> secondClassMethods = map.get(secondName);

                for (Map.Entry<String, List<List<ArgumentNameAndType>>> methodOverloadsFirst : firstClassMethods.entrySet()) {

                    List<List<ArgumentNameAndType>> methodOverloadsSecond = secondClassMethods.get(methodOverloadsFirst.getKey());

                    if (methodOverloadsSecond != null) {
                        for (List<ArgumentNameAndType> overloadFirst : methodOverloadsFirst.getValue()) {
                            for (List<ArgumentNameAndType> overloadSecond : methodOverloadsSecond) {
                                if (overloadFirst.size() == overloadSecond.size()) {
                                    // Argument types match?
                                    boolean match = true;
                                    for (int k = 0; k < overloadFirst.size(); k++) {
                                        if (!overloadFirst.get(k).type.equals(overloadSecond.get(k).type)) {
                                            match = false;
                                            break;
                                        }
                                    }
                                    // Argument names match?
                                    if (match) {
                                        for (int k = 0; k < overloadFirst.size(); k++) {
                                            if (!overloadFirst.get(k).name.equals(overloadSecond.get(k).name)) {
                                                System.out.print(""Argument naming mismatch #"");
                                                System.out.println(++counter);

                                                System.out.print(""  "");
                                                System.out.print(Strings.padEnd(firstName, Math.max(firstName.length(), secondName.length()) + 1, ' '));
                                                System.out.print(methodOverloadsFirst.getKey());
                                                System.out.print(""  "");
                                                System.out.println(overloadFirst);

                                                System.out.print(""  "");
                                                System.out.print(Strings.padEnd(secondName, Math.max(firstName.length(), secondName.length()) + 1, ' '));
                                                System.out.print(methodOverloadsFirst.getKey());
                                                System.out.print(""  "");
                                                System.out.println(overloadSecond);
                                                System.out.println();
                                                break;
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
            }
        }
    }",break_loop_control
line,"{
        List<String> result = new ArrayList<>();
        try {
            BufferedReader in = new BufferedReader(new FileReader(f));
            try {
                String line;

                while ((line = in.readLine()) != null) {
                    result.add(line);
                }
            } finally {
                in.close();
            }
        } catch (IOException ex) {
            ex.printStackTrace();
        }
        return result;
    }",maybe_loop_control
f,"{
        File[] observables = new File(basepath + ""observable/"").listFiles();

        int count = 0;

        for (File f : observables) {
            if (!f.getName().endsWith("".java"")) {
                continue;
            }
            Class<?> clazz = Class.forName(basepackage + ""observable."" + f.getName().replace("".java"", """"));

            String cn = f.getName().replace("".java"", """").replace(""Observable"", ""Flowable"");

            File f2 = new File(basepath + ""/flowable/"" + cn + "".java"");

            if (!f2.exists()) {
                continue;
            }

            Class<?> clazz2 = Class.forName(basepackage + ""flowable."" + cn);

            Set<String> methods2 = new HashSet<>();

            for (Method m : clazz2.getMethods()) {
                methods2.add(m.getName());
            }

            for (Method m : clazz.getMethods()) {
                if (!methods2.contains(m.getName()) && !methods2.contains(m.getName().replace(""Observable"", ""Flowable""))) {
                    count++;
                    System.out.println();
                    System.out.print(""java.lang.RuntimeException: missing > "");
                    System.out.println(m.getName());
                    System.out.print("" at "");
                    System.out.print(clazz.getName());
                    System.out.print("" ("");
                    System.out.print(clazz.getSimpleName());
                    System.out.print("".java:"");

                    List<String> lines = readAllLines(f);

                    int j = 1;
                    for (int i = 1; i <= lines.size(); i++) {
                        if (lines.get(i - 1).contains(""public void "" + m.getName() + ""("")) {
                            j = i;
                        }
                    }
                    System.out.print(j);
                    System.out.println("")"");

                    System.out.print("" at "");
                    System.out.print(clazz2.getName());
                    System.out.print("" ("");
                    System.out.print(clazz2.getSimpleName());

                    lines = readAllLines(f2);

                    System.out.print("".java:"");
                    System.out.print(lines.size() - 1);
                    System.out.println("")"");
                }
            }
        }

        System.out.println();
        System.out.println(count);
    }",iterator
m,"{
        File[] observables = new File(basepath + ""observable/"").listFiles();

        int count = 0;

        for (File f : observables) {
            if (!f.getName().endsWith("".java"")) {
                continue;
            }
            Class<?> clazz = Class.forName(basepackage + ""observable."" + f.getName().replace("".java"", """"));

            String cn = f.getName().replace("".java"", """").replace(""Observable"", ""Flowable"");

            File f2 = new File(basepath + ""/flowable/"" + cn + "".java"");

            if (!f2.exists()) {
                continue;
            }

            Class<?> clazz2 = Class.forName(basepackage + ""flowable."" + cn);

            Set<String> methods2 = new HashSet<>();

            for (Method m : clazz2.getMethods()) {
                methods2.add(m.getName());
            }

            for (Method m : clazz.getMethods()) {
                if (!methods2.contains(m.getName()) && !methods2.contains(m.getName().replace(""Observable"", ""Flowable""))) {
                    count++;
                    System.out.println();
                    System.out.print(""java.lang.RuntimeException: missing > "");
                    System.out.println(m.getName());
                    System.out.print("" at "");
                    System.out.print(clazz.getName());
                    System.out.print("" ("");
                    System.out.print(clazz.getSimpleName());
                    System.out.print("".java:"");

                    List<String> lines = readAllLines(f);

                    int j = 1;
                    for (int i = 1; i <= lines.size(); i++) {
                        if (lines.get(i - 1).contains(""public void "" + m.getName() + ""("")) {
                            j = i;
                        }
                    }
                    System.out.print(j);
                    System.out.println("")"");

                    System.out.print("" at "");
                    System.out.print(clazz2.getName());
                    System.out.print("" ("");
                    System.out.print(clazz2.getSimpleName());

                    lines = readAllLines(f2);

                    System.out.print("".java:"");
                    System.out.print(lines.size() - 1);
                    System.out.println("")"");
                }
            }
        }

        System.out.println();
        System.out.println(count);
    }",iterator
i,"{
        File[] observables = new File(basepath + ""observable/"").listFiles();

        int count = 0;

        for (File f : observables) {
            if (!f.getName().endsWith("".java"")) {
                continue;
            }
            Class<?> clazz = Class.forName(basepackage + ""observable."" + f.getName().replace("".java"", """"));

            String cn = f.getName().replace("".java"", """").replace(""Observable"", ""Flowable"");

            File f2 = new File(basepath + ""/flowable/"" + cn + "".java"");

            if (!f2.exists()) {
                continue;
            }

            Class<?> clazz2 = Class.forName(basepackage + ""flowable."" + cn);

            Set<String> methods2 = new HashSet<>();

            for (Method m : clazz2.getMethods()) {
                methods2.add(m.getName());
            }

            for (Method m : clazz.getMethods()) {
                if (!methods2.contains(m.getName()) && !methods2.contains(m.getName().replace(""Observable"", ""Flowable""))) {
                    count++;
                    System.out.println();
                    System.out.print(""java.lang.RuntimeException: missing > "");
                    System.out.println(m.getName());
                    System.out.print("" at "");
                    System.out.print(clazz.getName());
                    System.out.print("" ("");
                    System.out.print(clazz.getSimpleName());
                    System.out.print("".java:"");

                    List<String> lines = readAllLines(f);

                    int j = 1;
                    for (int i = 1; i <= lines.size(); i++) {
                        if (lines.get(i - 1).contains(""public void "" + m.getName() + ""("")) {
                            j = i;
                        }
                    }
                    System.out.print(j);
                    System.out.println("")"");

                    System.out.print("" at "");
                    System.out.print(clazz2.getName());
                    System.out.print("" ("");
                    System.out.print(clazz2.getSimpleName());

                    lines = readAllLines(f2);

                    System.out.print("".java:"");
                    System.out.print(lines.size() - 1);
                    System.out.println("")"");
                }
            }
        }

        System.out.println();
        System.out.println(count);
    }",loop_control
i,"{
        List<Integer> list = new VolatileSizeArrayList<>();

        assertTrue(list.isEmpty());
        assertEquals(0, list.size());
        assertFalse(list.contains(1));
        assertFalse(list.remove((Integer)1));

        list = new VolatileSizeArrayList<>(16);
        assertTrue(list.add(1));
        assertTrue(list.addAll(Arrays.asList(3, 4, 7)));
        list.add(1, 2);
        assertTrue(list.addAll(4, Arrays.asList(5, 6)));

        assertTrue(list.contains(2));
        assertFalse(list.remove((Integer)10));

        assertEquals(Arrays.asList(1, 2, 3, 4, 5, 6, 7), list);
        assertFalse(list.isEmpty());
        assertEquals(7, list.size());

        Iterator<Integer> it = list.iterator();
        for (int i = 1; i < 8; i++) {
            assertEquals(i, it.next().intValue());
        }

        assertArrayEquals(new Object[] { 1, 2, 3, 4, 5, 6, 7 }, list.toArray());
        assertArrayEquals(new Integer[] { 1, 2, 3, 4, 5, 6, 7 }, list.toArray(new Integer[7]));

        assertTrue(list.containsAll(Arrays.asList(2, 4, 6)));
        assertFalse(list.containsAll(Arrays.asList(2, 4, 6, 10)));

        assertFalse(list.removeAll(Arrays.asList(10, 11, 12)));

        assertFalse(list.retainAll(Arrays.asList(1, 2, 3, 4, 5, 6, 7)));

        assertEquals(7, list.size());

        for (int i = 1; i < 8; i++) {
            assertEquals(i, list.get(i - 1).intValue());
        }

        for (int i = 1; i < 8; i++) {
            assertEquals(i, list.set(i - 1, i).intValue());
        }

        assertEquals(2, list.indexOf(3));

        assertEquals(5, list.lastIndexOf(6));

        ListIterator<Integer> lit = list.listIterator(7);
        for (int i = 7; i > 0; i--) {
            assertEquals(i, lit.previous().intValue());
        }

        assertEquals(Arrays.asList(3, 4, 5), list.subList(2, 5));

        VolatileSizeArrayList<Integer> list2 = new VolatileSizeArrayList<>();
        list2.addAll(Arrays.asList(1, 2, 3, 4, 5, 6));

        assertNotEquals(list2, list);
        assertNotEquals(list, list2);

        list2.add(7);
        assertEquals(list2, list);
        assertEquals(list, list2);

        List<Integer> list3 = new ArrayList<>();
        list3.addAll(Arrays.asList(1, 2, 3, 4, 5, 6));

        assertNotEquals(list3, list);
        assertNotEquals(list, list3);

        list3.add(7);
        assertEquals(list3, list);
        assertEquals(list, list3);

        assertEquals(list.hashCode(), list3.hashCode());
        assertEquals(list.toString(), list3.toString());

        list.remove(0);
        assertEquals(6, list.size());

        list.clear();
        assertEquals(0, list.size());
        assertTrue(list.isEmpty());
    }",loop_control
it,"{
        List<Integer> list = new VolatileSizeArrayList<>();

        assertTrue(list.isEmpty());
        assertEquals(0, list.size());
        assertFalse(list.contains(1));
        assertFalse(list.remove((Integer)1));

        list = new VolatileSizeArrayList<>(16);
        assertTrue(list.add(1));
        assertTrue(list.addAll(Arrays.asList(3, 4, 7)));
        list.add(1, 2);
        assertTrue(list.addAll(4, Arrays.asList(5, 6)));

        assertTrue(list.contains(2));
        assertFalse(list.remove((Integer)10));

        assertEquals(Arrays.asList(1, 2, 3, 4, 5, 6, 7), list);
        assertFalse(list.isEmpty());
        assertEquals(7, list.size());

        Iterator<Integer> it = list.iterator();
        for (int i = 1; i < 8; i++) {
            assertEquals(i, it.next().intValue());
        }

        assertArrayEquals(new Object[] { 1, 2, 3, 4, 5, 6, 7 }, list.toArray());
        assertArrayEquals(new Integer[] { 1, 2, 3, 4, 5, 6, 7 }, list.toArray(new Integer[7]));

        assertTrue(list.containsAll(Arrays.asList(2, 4, 6)));
        assertFalse(list.containsAll(Arrays.asList(2, 4, 6, 10)));

        assertFalse(list.removeAll(Arrays.asList(10, 11, 12)));

        assertFalse(list.retainAll(Arrays.asList(1, 2, 3, 4, 5, 6, 7)));

        assertEquals(7, list.size());

        for (int i = 1; i < 8; i++) {
            assertEquals(i, list.get(i - 1).intValue());
        }

        for (int i = 1; i < 8; i++) {
            assertEquals(i, list.set(i - 1, i).intValue());
        }

        assertEquals(2, list.indexOf(3));

        assertEquals(5, list.lastIndexOf(6));

        ListIterator<Integer> lit = list.listIterator(7);
        for (int i = 7; i > 0; i--) {
            assertEquals(i, lit.previous().intValue());
        }

        assertEquals(Arrays.asList(3, 4, 5), list.subList(2, 5));

        VolatileSizeArrayList<Integer> list2 = new VolatileSizeArrayList<>();
        list2.addAll(Arrays.asList(1, 2, 3, 4, 5, 6));

        assertNotEquals(list2, list);
        assertNotEquals(list, list2);

        list2.add(7);
        assertEquals(list2, list);
        assertEquals(list, list2);

        List<Integer> list3 = new ArrayList<>();
        list3.addAll(Arrays.asList(1, 2, 3, 4, 5, 6));

        assertNotEquals(list3, list);
        assertNotEquals(list, list3);

        list3.add(7);
        assertEquals(list3, list);
        assertEquals(list, list3);

        assertEquals(list.hashCode(), list3.hashCode());
        assertEquals(list.toString(), list3.toString());

        list.remove(0);
        assertEquals(6, list.size());

        list.clear();
        assertEquals(0, list.size());
        assertTrue(list.isEmpty());
    }",iterator
lit,"{
        List<Integer> list = new VolatileSizeArrayList<>();

        assertTrue(list.isEmpty());
        assertEquals(0, list.size());
        assertFalse(list.contains(1));
        assertFalse(list.remove((Integer)1));

        list = new VolatileSizeArrayList<>(16);
        assertTrue(list.add(1));
        assertTrue(list.addAll(Arrays.asList(3, 4, 7)));
        list.add(1, 2);
        assertTrue(list.addAll(4, Arrays.asList(5, 6)));

        assertTrue(list.contains(2));
        assertFalse(list.remove((Integer)10));

        assertEquals(Arrays.asList(1, 2, 3, 4, 5, 6, 7), list);
        assertFalse(list.isEmpty());
        assertEquals(7, list.size());

        Iterator<Integer> it = list.iterator();
        for (int i = 1; i < 8; i++) {
            assertEquals(i, it.next().intValue());
        }

        assertArrayEquals(new Object[] { 1, 2, 3, 4, 5, 6, 7 }, list.toArray());
        assertArrayEquals(new Integer[] { 1, 2, 3, 4, 5, 6, 7 }, list.toArray(new Integer[7]));

        assertTrue(list.containsAll(Arrays.asList(2, 4, 6)));
        assertFalse(list.containsAll(Arrays.asList(2, 4, 6, 10)));

        assertFalse(list.removeAll(Arrays.asList(10, 11, 12)));

        assertFalse(list.retainAll(Arrays.asList(1, 2, 3, 4, 5, 6, 7)));

        assertEquals(7, list.size());

        for (int i = 1; i < 8; i++) {
            assertEquals(i, list.get(i - 1).intValue());
        }

        for (int i = 1; i < 8; i++) {
            assertEquals(i, list.set(i - 1, i).intValue());
        }

        assertEquals(2, list.indexOf(3));

        assertEquals(5, list.lastIndexOf(6));

        ListIterator<Integer> lit = list.listIterator(7);
        for (int i = 7; i > 0; i--) {
            assertEquals(i, lit.previous().intValue());
        }

        assertEquals(Arrays.asList(3, 4, 5), list.subList(2, 5));

        VolatileSizeArrayList<Integer> list2 = new VolatileSizeArrayList<>();
        list2.addAll(Arrays.asList(1, 2, 3, 4, 5, 6));

        assertNotEquals(list2, list);
        assertNotEquals(list, list2);

        list2.add(7);
        assertEquals(list2, list);
        assertEquals(list, list2);

        List<Integer> list3 = new ArrayList<>();
        list3.addAll(Arrays.asList(1, 2, 3, 4, 5, 6));

        assertNotEquals(list3, list);
        assertNotEquals(list, list3);

        list3.add(7);
        assertEquals(list3, list);
        assertEquals(list, list3);

        assertEquals(list.hashCode(), list3.hashCode());
        assertEquals(list.toString(), list3.toString());

        list.remove(0);
        assertEquals(6, list.size());

        list.clear();
        assertEquals(0, list.size());
        assertTrue(list.isEmpty());
    }",iterator
i,"{
        for (int i = 0; i < TestHelper.RACE_DEFAULT_LOOPS; i++) {

            final AtomicInteger wip = new AtomicInteger();
            final AtomicThrowable error = new AtomicThrowable();

            final TestObserver<Integer> to = new TestObserver<>();
            to.onSubscribe(Disposable.empty());

            Runnable r1 = new Runnable() {
                @Override
                public void run() {
                    HalfSerializer.onNext(to, 1, wip, error);
                }
            };

            Runnable r2 = new Runnable() {
                @Override
                public void run() {
                    HalfSerializer.onComplete(to, wip, error);
                }
            };

            TestHelper.race(r1, r2);

            to.assertComplete().assertNoErrors();

            assertTrue(to.values().size() <= 1);
        }
    }",loop_control
i,"{
        for (int i = 0; i < TestHelper.RACE_DEFAULT_LOOPS; i++) {

            final AtomicInteger wip = new AtomicInteger();
            final AtomicThrowable error = new AtomicThrowable();

            final TestObserverEx<Integer> to = new TestObserverEx<>();

            to.onSubscribe(Disposable.empty());

            final TestException ex = new TestException();

            Runnable r1 = new Runnable() {
                @Override
                public void run() {
                    HalfSerializer.onError(to, ex, wip, error);
                }
            };

            Runnable r2 = new Runnable() {
                @Override
                public void run() {
                    HalfSerializer.onComplete(to, wip, error);
                }
            };

            TestHelper.race(r1, r2);

            if (to.completions() != 0) {
                to.assertResult();
            } else {
                to.assertFailure(TestException.class);
            }
        }
    }",loop_control
i,"{
        for (int i = 0; i < TestHelper.RACE_DEFAULT_LOOPS; i++) {

            final AtomicReference<Throwable> error = new AtomicReference<>();

            final TestException ex = new TestException();

            Runnable r = new Runnable() {
                @Override
                public void run() {
                    assertTrue(ExceptionHelper.addThrowable(error, ex));
                }
            };

            TestHelper.race(r, r);
        }
    }",loop_control
argCount,"{
        @SuppressWarnings(""rawtypes"")
        Class<Observable> clazz = Observable.class;
        for (int argCount = 1; argCount < 10; argCount++) {
            for (int argNull = 1; argNull <= argCount; argNull++) {
                Class<?>[] params = new Class[argCount];
                Arrays.fill(params, Object.class);

                Object[] values = new Object[argCount];
                Arrays.fill(values, 1);
                values[argNull - 1] = null;

                Method m = clazz.getMethod(""just"", params);

                try {
                    m.invoke(null, values);
                    Assert.fail(""No exception for argCount "" + argCount + "" / argNull "" + argNull);
                } catch (InvocationTargetException ex) {
                    if (!(ex.getCause() instanceof NullPointerException)) {
                        Assert.fail(""Unexpected exception for argCount "" + argCount + "" / argNull "" + argNull + "": "" + ex);
                    }
                }
            }
        }
    }",loop_control
argNull,"{
        @SuppressWarnings(""rawtypes"")
        Class<Observable> clazz = Observable.class;
        for (int argCount = 1; argCount < 10; argCount++) {
            for (int argNull = 1; argNull <= argCount; argNull++) {
                Class<?>[] params = new Class[argCount];
                Arrays.fill(params, Object.class);

                Object[] values = new Object[argCount];
                Arrays.fill(values, 1);
                values[argNull - 1] = null;

                Method m = clazz.getMethod(""just"", params);

                try {
                    m.invoke(null, values);
                    Assert.fail(""No exception for argCount "" + argCount + "" / argNull "" + argNull);
                } catch (InvocationTargetException ex) {
                    if (!(ex.getCause() instanceof NullPointerException)) {
                        Assert.fail(""Unexpected exception for argCount "" + argCount + "" / argNull "" + argNull + "": "" + ex);
                    }
                }
            }
        }
    }",loop_control
old,"{
        @Override
        public Observable<Movie> apply(List<List<Movie>> listOfLists) {
            if (listOfLists.size() == 1) {
                return Observable.fromIterable(listOfLists.get(0));
            } else {
                // diff the two
                List<Movie> newList = listOfLists.get(1);
                List<Movie> oldList = new ArrayList<>(listOfLists.get(0));

                Set<Movie> delta = new LinkedHashSet<>();
                delta.addAll(newList);
                // remove all that match in old
                delta.removeAll(oldList);

                // filter oldList to those that aren't in the newList
                oldList.removeAll(newList);

                // for all left in the oldList we'll create DROP events
                for (@SuppressWarnings(""unused"") Movie old : oldList) {
                    delta.add(new Movie());
                }

                return Observable.fromIterable(delta);
            }
        }
    }",iterator
i,"{
        final int expectedCount = 3;
        final AtomicInteger count = new AtomicInteger();
        for (int i = 0; i < expectedCount; i++) {
            Observable
                    .just(Boolean.TRUE, Boolean.FALSE)
                    .takeWhile(new Predicate<Boolean>() {
                        @Override
                        public boolean test(Boolean v) {
                            return v;
                        }
                    })
                    .toList()
                    .doOnSuccess(new Consumer<List<Boolean>>() {
                        @Override
                        public void accept(List<Boolean> booleans) {
                            count.incrementAndGet();
                        }
                    })
                    .subscribe();
        }
        assertEquals(expectedCount, count.get());
    }",loop_control
i,"{
        final List<Observable<Integer>> observables = Arrays.asList(Observable.just(1, 2, 3), Observable.just(1, 2, 3));
        Observable.zip(observables, new Function<Object[], Object>() {
            @Override
            public Object apply(Object[] o) throws Exception {
                int sum = 0;
                for (Object i : o) {
                    sum += (Integer) i;
                }
                return sum;
            }
        }).test().assertResult(2, 4, 6);
    }",iterator
i,"{
        final List<Observable<Integer>> observables = Arrays.asList(Observable.just(1, 2, 3), Observable.just(1, 2, 3));
        Observable.combineLatest(observables, new Function<Object[], Object>() {
            @Override
            public Object apply(final Object[] o) throws Exception {
                int sum = 1;
                for (Object i : o) {
                    sum *= (Integer) i;
                }
                return sum;
            }
        }).test().assertResult(3, 6, 9);
    }",iterator
root,"{
        Throwable root = ex.getCause();
        if (root == null) {
            return null;
        } else {
            while (true) {
                if (root.getCause() == null) {
                    return root;
                } else {
                    root = root.getCause();
                }
            }
        }
    }",break_loop_control
i,"{
        int n = 10;
        for (int i = 0; i < n; i++) {
            TestMultiThreadedObservable onSubscribe = new TestMultiThreadedObservable(""one"", ""two"", ""three"", null,
                    ""four"", ""five"", ""six"", ""seven"", ""eight"", ""nine"");
            Flowable<String> w = Flowable.unsafeCreate(onSubscribe);

            BusySubscriber busySubscriber = new BusySubscriber();
            Subscriber<String> aw = serializedSubscriber(busySubscriber);

            w.subscribe(aw);
            onSubscribe.waitToFinish();

            System.out.println(""OnSubscribe maxConcurrentThreads: "" + onSubscribe.maxConcurrentThreads.get() + ""  Subscriber maxConcurrentThreads: "" + busySubscriber.maxConcurrentThreads.get());

            // we can have concurrency ...
            assertTrue(onSubscribe.maxConcurrentThreads.get() > 1);
            // ... but the onNext execution should be single threaded
            assertEquals(1, busySubscriber.maxConcurrentThreads.get());

            // this should not be the full number of items since the error should stop it before it completes all 9
            System.out.println(""onNext count: "" + busySubscriber.onNextCount.get());
            assertFalse(busySubscriber.onComplete);
            assertTrue(busySubscriber.onError);
            assertTrue(busySubscriber.onNextCount.get() < 9);
            // no onComplete because onError was invoked
            // non-deterministic because unsubscribe happens after 'waitToFinish' releases
            // so commenting out for now as this is not a critical thing to test here
            // verify(s, times(1)).unsubscribe();
        }
    }",loop_control
i,"{
        ExecutorService tp = Executors.newFixedThreadPool(20);
        List<Throwable> errors = TestHelper.trackPluginErrors();
        try {
            TestConcurrencySubscriber tw = new TestConcurrencySubscriber();
            // we need Synchronized + SafeSubscriber to handle synchronization plus life-cycle
            Subscriber<String> w = serializedSubscriber(new SafeSubscriber<>(tw));

            Future<?> f1 = tp.submit(new OnNextThread(w, 12000));
            Future<?> f2 = tp.submit(new OnNextThread(w, 5000));
            Future<?> f3 = tp.submit(new OnNextThread(w, 75000));
            Future<?> f4 = tp.submit(new OnNextThread(w, 13500));
            Future<?> f5 = tp.submit(new OnNextThread(w, 22000));
            Future<?> f6 = tp.submit(new OnNextThread(w, 15000));
            Future<?> f7 = tp.submit(new OnNextThread(w, 7500));
            Future<?> f8 = tp.submit(new OnNextThread(w, 23500));

            Future<?> f10 = tp.submit(new CompletionThread(w, TestConcurrencySubscriberEvent.onComplete, f1, f2, f3, f4));
            try {
                Thread.sleep(1);
            } catch (InterruptedException e) {
                // ignore
            }
            Future<?> f11 = tp.submit(new CompletionThread(w, TestConcurrencySubscriberEvent.onComplete, f4, f6, f7));
            Future<?> f12 = tp.submit(new CompletionThread(w, TestConcurrencySubscriberEvent.onComplete, f4, f6, f7));
            Future<?> f13 = tp.submit(new CompletionThread(w, TestConcurrencySubscriberEvent.onComplete, f4, f6, f7));
            Future<?> f14 = tp.submit(new CompletionThread(w, TestConcurrencySubscriberEvent.onComplete, f4, f6, f7));
            // // the next 4 onError events should wait on same as f10
            Future<?> f15 = tp.submit(new CompletionThread(w, TestConcurrencySubscriberEvent.onError, f1, f2, f3, f4));
            Future<?> f16 = tp.submit(new CompletionThread(w, TestConcurrencySubscriberEvent.onError, f1, f2, f3, f4));
            Future<?> f17 = tp.submit(new CompletionThread(w, TestConcurrencySubscriberEvent.onError, f1, f2, f3, f4));
            Future<?> f18 = tp.submit(new CompletionThread(w, TestConcurrencySubscriberEvent.onError, f1, f2, f3, f4));

            waitOnThreads(f1, f2, f3, f4, f5, f6, f7, f8, f10, f11, f12, f13, f14, f15, f16, f17, f18);
            @SuppressWarnings(""unused"")
            int numNextEvents = tw.assertEvents(null); // no check of type since we don't want to test barging results here, just interleaving behavior
            //            System.out.println(""Number of events executed: "" + numNextEvents);

            for (int i = 0; i < errors.size(); i++) {
                TestHelper.assertUndeliverable(errors, i, RuntimeException.class);
            }
        } catch (Throwable e) {
            fail(""Concurrency test failed: "" + e.getMessage());
            e.printStackTrace();
        } finally {
            tp.shutdown();
            try {
                tp.awaitTermination(5000, TimeUnit.MILLISECONDS);
            } catch (InterruptedException e) {
                e.printStackTrace();
            }

            RxJavaPlugins.reset();
        }
    }",loop_control
i,"{
        ExecutorService tp1 = Executors.newFixedThreadPool(1);
        ExecutorService tp2 = Executors.newFixedThreadPool(1);
        try {
            int n = 10;
            for (int i = 0; i < n; i++) {
                final CountDownLatch firstOnNext = new CountDownLatch(1);
                final CountDownLatch onNextCount = new CountDownLatch(2);
                final CountDownLatch latch = new CountDownLatch(1);
                final CountDownLatch running = new CountDownLatch(2);

                TestSubscriberEx<String> ts = new TestSubscriberEx<>(new DefaultSubscriber<String>() {

                    @Override
                    public void onComplete() {

                    }

                    @Override
                    public void onError(Throwable e) {

                    }

                    @Override
                    public void onNext(String t) {
                        firstOnNext.countDown();
                        // force it to take time when delivering so the second one is enqueued
                        try {
                            latch.await();
                        } catch (InterruptedException e) {
                        }
                    }

                });
                Subscriber<String> subscriber = serializedSubscriber(ts);

                Future<?> f1 = tp1.submit(new OnNextThread(subscriber, 1, onNextCount, running));
                Future<?> f2 = tp2.submit(new OnNextThread(subscriber, 1, onNextCount, running));

                running.await(); // let one of the OnNextThread actually run before proceeding

                firstOnNext.await();

                Thread t1 = ts.lastThread();
                System.out.println(""first onNext on thread: "" + t1);

                latch.countDown();

                waitOnThreads(f1, f2);
                // not completed yet

                assertEquals(2, ts.values().size());

                Thread t2 = ts.lastThread();
                System.out.println(""second onNext on thread: "" + t2);

                assertSame(t1, t2);

                System.out.println(ts.values());
                subscriber.onComplete();
                System.out.println(ts.values());
            }
        } finally {
            tp1.shutdown();
            tp2.shutdown();
        }
    }",loop_control
f,"{
        for (Future<?> f : futures) {
            try {
                f.get(20, TimeUnit.SECONDS);
            } catch (Throwable e) {
                System.err.println(""Failed while waiting on future."");
                e.printStackTrace();
            }
        }
    }",iterator
bs,"{
        return Flowable.unsafeCreate(new Publisher<String>() {

            @Override
            public void subscribe(Subscriber<? super String> s) {
                BooleanSubscription bs = new BooleanSubscription();
                s.onSubscribe(bs);
                while (!bs.isCancelled()) {
                    s.onNext(""onNext"");
                    produced.incrementAndGet();
                }
            }

        }).subscribeOn(Schedulers.newThread());
    }",maybe_loop_control
s,"{

        final String[] values;
        Thread t;
        AtomicInteger threadsRunning = new AtomicInteger();
        AtomicInteger maxConcurrentThreads = new AtomicInteger();
        ExecutorService threadPool;

        TestMultiThreadedObservable(String... values) {
            this.values = values;
            this.threadPool = Executors.newCachedThreadPool();
        }

        @Override
        public void subscribe(final Subscriber<? super String> subscriber) {
            subscriber.onSubscribe(new BooleanSubscription());
            final NullPointerException npe = new NullPointerException();
            System.out.println(""TestMultiThreadedObservable subscribed to ..."");
            t = new Thread(new Runnable() {

                @Override
                public void run() {
                    try {
                        System.out.println(""running TestMultiThreadedObservable thread"");
                        int j = 0;
                        for (final String s : values) {
                            final int fj = ++j;
                            threadPool.execute(new Runnable() {

                                @Override
                                public void run() {
                                    threadsRunning.incrementAndGet();
                                    try {
                                        // perform onNext call
                                        System.out.println(""TestMultiThreadedObservable onNext: "" + s + "" on thread "" + Thread.currentThread().getName());
                                        if (s == null) {
                                            // force an error
                                            throw npe;
                                        } else {
                                             // allow the exception to queue up
                                            int sleep = (fj % 3) * 10;
                                            if (sleep != 0) {
                                                Thread.sleep(sleep);
                                            }
                                        }
                                        subscriber.onNext(s);
                                        // capture 'maxThreads'
                                        int concurrentThreads = threadsRunning.get();
                                        int maxThreads = maxConcurrentThreads.get();
                                        if (concurrentThreads > maxThreads) {
                                            maxConcurrentThreads.compareAndSet(maxThreads, concurrentThreads);
                                        }
                                    } catch (Throwable e) {
                                        subscriber.onError(e);
                                    } finally {
                                        threadsRunning.decrementAndGet();
                                    }
                                }
                            });
                        }
                        // we are done spawning threads
                        threadPool.shutdown();
                    } catch (Throwable e) {
                        throw new RuntimeException(e);
                    }

                    // wait until all threads are done, then mark it as COMPLETED
                    try {
                        // wait for all the threads to finish
                        if (!threadPool.awaitTermination(5, TimeUnit.SECONDS)) {
                            System.out.println(""Threadpool did not terminate in time."");
                        }
                    } catch (InterruptedException e) {
                        throw new RuntimeException(e);
                    }
                    subscriber.onComplete();
                }
            });
            System.out.println(""starting TestMultiThreadedObservable thread"");
            t.start();
            System.out.println(""done starting TestMultiThreadedObservable thread"");
        }

        public void waitToFinish() {
            try {
                t.join();
            } catch (InterruptedException e) {
                throw new RuntimeException(e);
            }
        }
    }",iterator
i,"{
        for (int i = 0; i < TestHelper.RACE_DEFAULT_LOOPS; i++) {
            TestSubscriber<Integer> ts = new TestSubscriber<>();

            final SerializedSubscriber<Integer> so = new SerializedSubscriber<>(ts);

            BooleanSubscription bs = new BooleanSubscription();

            so.onSubscribe(bs);

            Runnable r = new Runnable() {
                @Override
                public void run() {
                    so.onComplete();
                }
            };

            TestHelper.race(r, r);

            ts.awaitDone(5, TimeUnit.SECONDS)
            .assertResult();
        }

    }",loop_control
i,"{
        for (int i = 0; i < TestHelper.RACE_DEFAULT_LOOPS; i++) {
            TestSubscriber<Integer> ts = new TestSubscriber<>();

            final SerializedSubscriber<Integer> so = new SerializedSubscriber<>(ts);

            BooleanSubscription bs = new BooleanSubscription();

            so.onSubscribe(bs);

            Runnable r1 = new Runnable() {
                @Override
                public void run() {
                    so.onComplete();
                }
            };

            Runnable r2 = new Runnable() {
                @Override
                public void run() {
                    so.onNext(1);
                }
            };

            TestHelper.race(r1, r2);

            ts.awaitDone(5, TimeUnit.SECONDS)
            .assertNoErrors()
            .assertComplete();

            assertTrue(ts.values().size() <= 1);
        }

    }",loop_control
i,"{
        for (int i = 0; i < TestHelper.RACE_DEFAULT_LOOPS; i++) {
            TestSubscriber<Integer> ts = new TestSubscriber<>();

            final SerializedSubscriber<Integer> so = new SerializedSubscriber<>(ts);

            BooleanSubscription bs = new BooleanSubscription();

            so.onSubscribe(bs);

            final Throwable ex = new TestException();

            Runnable r1 = new Runnable() {
                @Override
                public void run() {
                    so.onError(ex);
                }
            };

            Runnable r2 = new Runnable() {
                @Override
                public void run() {
                    so.onNext(1);
                }
            };

            TestHelper.race(r1, r2);

            ts.awaitDone(5, TimeUnit.SECONDS)
            .assertError(ex)
            .assertNotComplete();

            assertTrue(ts.values().size() <= 1);
        }

    }",loop_control
i,"{
        for (int i = 0; i < TestHelper.RACE_DEFAULT_LOOPS; i++) {
            TestSubscriber<Integer> ts = new TestSubscriber<>();

            final SerializedSubscriber<Integer> so = new SerializedSubscriber<>(ts, true);

            BooleanSubscription bs = new BooleanSubscription();

            so.onSubscribe(bs);

            final Throwable ex = new TestException();

            Runnable r1 = new Runnable() {
                @Override
                public void run() {
                    so.onError(ex);
                }
            };

            Runnable r2 = new Runnable() {
                @Override
                public void run() {
                    so.onNext(1);
                }
            };

            TestHelper.race(r1, r2);

            ts.awaitDone(5, TimeUnit.SECONDS)
            .assertError(ex)
            .assertNotComplete();

            assertTrue(ts.values().size() <= 1);
        }

    }",loop_control
i,"{
        for (int i = 0; i < TestHelper.RACE_DEFAULT_LOOPS; i++) {
            List<Throwable> errors = TestHelper.trackPluginErrors();
            try {
                TestSubscriberEx<Integer> ts = new TestSubscriberEx<>();

                final SerializedSubscriber<Integer> so = new SerializedSubscriber<>(ts);

                BooleanSubscription bs = new BooleanSubscription();

                so.onSubscribe(bs);

                final Throwable ex = new TestException();

                Runnable r1 = new Runnable() {
                    @Override
                    public void run() {
                        so.onError(ex);
                    }
                };

                Runnable r2 = new Runnable() {
                    @Override
                    public void run() {
                        so.onComplete();
                    }
                };

                TestHelper.race(r1, r2);

                ts.awaitDone(5, TimeUnit.SECONDS);

                if (ts.completions() != 0) {
                    ts.assertResult();
                    TestHelper.assertUndeliverable(errors, 0, TestException.class);
                } else {
                    ts.assertFailure(TestException.class).assertError(ex);
                    assertTrue("""" + errors, errors.isEmpty());
                }
            } finally {
                RxJavaPlugins.reset();
            }
        }

    }",loop_control
i,"{
        try {
            for (int i = 1; i < 3; i++) {
                Flowable.just(i)
                .test()
                .withTag(""testing with item="" + i)
                .assertResult(1)
                ;
            }
            throw new RuntimeException(""Should have thrown!"");
        } catch (AssertionError ex) {
            assertTrue(ex.toString(), ex.toString().contains(""testing with item=2""));
        }
    }",loop_control
i,"{
        Maybe<Integer> source = Maybe.defer(new Supplier<Maybe<Integer>>() {
            int count;
            @Override
            public Maybe<Integer> get() throws Exception {
                return Maybe.just(count++);
            }
        });

        for (int i = 0; i < 128; i++) {
            source.test().assertResult(i);
        }
    }",loop_control
i,"{
        for (int i = 0; i < TestHelper.RACE_DEFAULT_LOOPS; i++) {
            final PublishProcessor<Integer> pp1 = PublishProcessor.create();
            final PublishProcessor<Integer> pp2 = PublishProcessor.create();

            TestSubscriberEx<Integer> ts = new TestSubscriberEx<Integer>().setInitialFusionMode(QueueFuseable.ANY);

            Maybe.mergeArray(pp1.singleElement(), pp2.singleElement()).subscribe(ts);

            ts.assertSubscribed()
            .assertFuseable()
            .assertFusionMode(QueueFuseable.ASYNC)
            ;

            TestHelper.race(new Runnable() {
                @Override
                public void run() {
                    pp1.onNext(1);
                    pp1.onComplete();
                }
            }, new Runnable() {
                @Override
                public void run() {
                    pp2.onNext(1);
                    pp2.onComplete();
                }
            });

            ts
            .awaitDone(5, TimeUnit.SECONDS)
            .assertResult(1, 1);
        }
    }",loop_control
i,"{
        final List<Maybe<Integer>> maybes = Arrays.asList(Maybe.just(1), Maybe.just(4));
        Maybe.zip(maybes, new Function<Object[], Object>() {
            @Override
            public Object apply(final Object[] o) throws Exception {
                int sum = 0;
                for (Object i : o) {
                    sum += (Integer) i;
                }
                return sum;
            }
        }).test().assertResult(5);
    }",iterator
m,"{
        RxJavaPlugins.reset();
        RxJavaPlugins.lockdown();
        try {
            assertTrue(RxJavaPlugins.isLockdown());
            Consumer a1 = Functions.emptyConsumer();
            Supplier f0 = new Supplier() {
                @Override
                public Object get() {
                    return null;
                }
            };
            Function f1 = Functions.identity();
            BiFunction f2 = new BiFunction() {
                @Override
                public Object apply(Object t1, Object t2) {
                    return t2;
                }
            };

            BooleanSupplier bs = new BooleanSupplier() {
                @Override
                public boolean getAsBoolean() throws Exception {
                    return true;
                }
            };

            for (Method m : RxJavaPlugins.class.getMethods()) {
                if (m.getName().startsWith(""set"")) {

                    Method getter;

                    Class<?> paramType = m.getParameterTypes()[0];

                    if (paramType == Boolean.TYPE) {
                        getter = RxJavaPlugins.class.getMethod(""is"" + m.getName().substring(3));
                    } else {
                        getter = RxJavaPlugins.class.getMethod(""get"" + m.getName().substring(3));
                    }

                    Object before = getter.invoke(null);

                    try {
                        if (paramType.isAssignableFrom(Boolean.TYPE)) {
                            m.invoke(null, true);
                        } else
                        if (paramType.isAssignableFrom(Supplier.class)) {
                            m.invoke(null, f0);
                        } else
                        if (paramType.isAssignableFrom(Function.class)) {
                            m.invoke(null, f1);
                        } else
                        if (paramType.isAssignableFrom(Consumer.class)) {
                            m.invoke(null, a1);
                        } else
                        if (paramType.isAssignableFrom(BooleanSupplier.class)) {
                            m.invoke(null, bs);
                        } else {
                            m.invoke(null, f2);
                        }
                        fail(""Should have thrown InvocationTargetException(IllegalStateException)"");
                    } catch (InvocationTargetException ex) {
                        if (ex.getCause() instanceof IllegalStateException) {
                            assertEquals(""Plugins can't be changed anymore"", ex.getCause().getMessage());
                        } else {
                            fail(""Should have thrown InvocationTargetException(IllegalStateException)"");
                        }
                    }

                    Object after = getter.invoke(null);

                    if (paramType.isPrimitive()) {
                        assertEquals(m.toString(), before, after);
                    } else {
                        assertSame(m.toString(), before, after);
                    }
                }
            }
        } finally {
            RxJavaPlugins.unlock();
            RxJavaPlugins.reset();
            assertFalse(RxJavaPlugins.isLockdown());
        }
    }",iterator
argCount,"{
        int maxArgs = 4;

        @SuppressWarnings(""rawtypes"")
        Class<Single> clazz = Single.class;
        for (int argCount = 2; argCount <= maxArgs; argCount++) {
            for (int argNull = 1; argNull <= argCount; argNull++) {
                Class<?>[] params = new Class[argCount];
                Arrays.fill(params, SingleSource.class);

                Object[] values = new Object[argCount];
                Arrays.fill(values, just1);
                values[argNull - 1] = null;

                Method m = clazz.getMethod(""concat"", params);

                try {
                    m.invoke(null, values);
                    Assert.fail(""No exception for argCount "" + argCount + "" / argNull "" + argNull);
                } catch (InvocationTargetException ex) {
                    if (!(ex.getCause() instanceof NullPointerException)) {
                        Assert.fail(""Unexpected exception for argCount "" + argCount + "" / argNull "" + argNull + "": "" + ex);
                    }
                }
            }
        }
    }",loop_control
argNull,"{
        int maxArgs = 4;

        @SuppressWarnings(""rawtypes"")
        Class<Single> clazz = Single.class;
        for (int argCount = 2; argCount <= maxArgs; argCount++) {
            for (int argNull = 1; argNull <= argCount; argNull++) {
                Class<?>[] params = new Class[argCount];
                Arrays.fill(params, SingleSource.class);

                Object[] values = new Object[argCount];
                Arrays.fill(values, just1);
                values[argNull - 1] = null;

                Method m = clazz.getMethod(""concat"", params);

                try {
                    m.invoke(null, values);
                    Assert.fail(""No exception for argCount "" + argCount + "" / argNull "" + argNull);
                } catch (InvocationTargetException ex) {
                    if (!(ex.getCause() instanceof NullPointerException)) {
                        Assert.fail(""Unexpected exception for argCount "" + argCount + "" / argNull "" + argNull + "": "" + ex);
                    }
                }
            }
        }
    }",loop_control
argCount,"{
        int maxArgs = 4;

        @SuppressWarnings(""rawtypes"")
        Class<Single> clazz = Single.class;
        for (int argCount = 2; argCount <= maxArgs; argCount++) {
            for (int argNull = 1; argNull <= argCount; argNull++) {
                Class<?>[] params = new Class[argCount];
                Arrays.fill(params, SingleSource.class);

                Object[] values = new Object[argCount];
                Arrays.fill(values, just1);
                values[argNull - 1] = null;

                Method m = clazz.getMethod(""merge"", params);

                try {
                    m.invoke(null, values);
                    Assert.fail(""No exception for argCount "" + argCount + "" / argNull "" + argNull);
                } catch (InvocationTargetException ex) {
                    if (!(ex.getCause() instanceof NullPointerException)) {
                        Assert.fail(""Unexpected exception for argCount "" + argCount + "" / argNull "" + argNull + "": "" + ex);
                    }
                }
            }
        }
    }",loop_control
argNull,"{
        int maxArgs = 4;

        @SuppressWarnings(""rawtypes"")
        Class<Single> clazz = Single.class;
        for (int argCount = 2; argCount <= maxArgs; argCount++) {
            for (int argNull = 1; argNull <= argCount; argNull++) {
                Class<?>[] params = new Class[argCount];
                Arrays.fill(params, SingleSource.class);

                Object[] values = new Object[argCount];
                Arrays.fill(values, just1);
                values[argNull - 1] = null;

                Method m = clazz.getMethod(""merge"", params);

                try {
                    m.invoke(null, values);
                    Assert.fail(""No exception for argCount "" + argCount + "" / argNull "" + argNull);
                } catch (InvocationTargetException ex) {
                    if (!(ex.getCause() instanceof NullPointerException)) {
                        Assert.fail(""Unexpected exception for argCount "" + argCount + "" / argNull "" + argNull + "": "" + ex);
                    }
                }
            }
        }
    }",loop_control
argCount,"{
        @SuppressWarnings(""rawtypes"")
        Class<Single> clazz = Single.class;
        for (int argCount = 3; argCount < 10; argCount++) {
            for (int argNull = 1; argNull <= argCount; argNull++) {
                Class<?>[] params = new Class[argCount + 1];
                Arrays.fill(params, SingleSource.class);
                Class<?> fniClass = Class.forName(""io.reactivex.rxjava3.functions.Function"" + argCount);
                params[argCount] = fniClass;

                Object[] values = new Object[argCount + 1];
                Arrays.fill(values, just1);
                values[argNull - 1] = null;
                values[argCount] = Proxy.newProxyInstance(getClass().getClassLoader(), new Class[] { fniClass }, new InvocationHandler() {
                    @Override
                    public Object invoke(Object o, Method m, Object[] a) throws Throwable {
                        return 1;
                    }
                });

                Method m = clazz.getMethod(""zip"", params);

                try {
                    m.invoke(null, values);
                    Assert.fail(""No exception for argCount "" + argCount + "" / argNull "" + argNull);
                } catch (InvocationTargetException ex) {
                    if (!(ex.getCause() instanceof NullPointerException)) {
                        Assert.fail(""Unexpected exception for argCount "" + argCount + "" / argNull "" + argNull + "": "" + ex);
                    }
                }

                values[argCount] = Proxy.newProxyInstance(getClass().getClassLoader(), new Class[] { fniClass }, new InvocationHandler() {
                    @Override
                    public Object invoke(Object o, Method m1, Object[] a) throws Throwable {
                        return null;
                    }
                });
                try {
                    ((Single<Object>)m.invoke(null, values)).blockingGet();
                    Assert.fail(""No exception for argCount "" + argCount + "" / argNull "" + argNull);
                } catch (InvocationTargetException ex) {
                    if (!(ex.getCause() instanceof NullPointerException)) {
                        Assert.fail(""Unexpected exception for argCount "" + argCount + "" / argNull "" + argNull + "": "" + ex);
                    }
                }

            }

            Class<?>[] params = new Class[argCount + 1];
            Arrays.fill(params, SingleSource.class);
            Class<?> fniClass = Class.forName(""io.reactivex.rxjava3.functions.Function"" + argCount);
            params[argCount] = fniClass;

            Object[] values = new Object[argCount + 1];
            Arrays.fill(values, just1);
            values[argCount] = null;

            Method m = clazz.getMethod(""zip"", params);

            try {
                m.invoke(null, values);
                Assert.fail(""No exception for argCount "" + argCount + "" / zipper function "");
            } catch (InvocationTargetException ex) {
                if (!(ex.getCause() instanceof NullPointerException)) {
                    Assert.fail(""Unexpected exception for argCount "" + argCount + "" / zipper function: "" + ex);
                }
            }
        }
    }",loop_control
argNull,"{
        @SuppressWarnings(""rawtypes"")
        Class<Single> clazz = Single.class;
        for (int argCount = 3; argCount < 10; argCount++) {
            for (int argNull = 1; argNull <= argCount; argNull++) {
                Class<?>[] params = new Class[argCount + 1];
                Arrays.fill(params, SingleSource.class);
                Class<?> fniClass = Class.forName(""io.reactivex.rxjava3.functions.Function"" + argCount);
                params[argCount] = fniClass;

                Object[] values = new Object[argCount + 1];
                Arrays.fill(values, just1);
                values[argNull - 1] = null;
                values[argCount] = Proxy.newProxyInstance(getClass().getClassLoader(), new Class[] { fniClass }, new InvocationHandler() {
                    @Override
                    public Object invoke(Object o, Method m, Object[] a) throws Throwable {
                        return 1;
                    }
                });

                Method m = clazz.getMethod(""zip"", params);

                try {
                    m.invoke(null, values);
                    Assert.fail(""No exception for argCount "" + argCount + "" / argNull "" + argNull);
                } catch (InvocationTargetException ex) {
                    if (!(ex.getCause() instanceof NullPointerException)) {
                        Assert.fail(""Unexpected exception for argCount "" + argCount + "" / argNull "" + argNull + "": "" + ex);
                    }
                }

                values[argCount] = Proxy.newProxyInstance(getClass().getClassLoader(), new Class[] { fniClass }, new InvocationHandler() {
                    @Override
                    public Object invoke(Object o, Method m1, Object[] a) throws Throwable {
                        return null;
                    }
                });
                try {
                    ((Single<Object>)m.invoke(null, values)).blockingGet();
                    Assert.fail(""No exception for argCount "" + argCount + "" / argNull "" + argNull);
                } catch (InvocationTargetException ex) {
                    if (!(ex.getCause() instanceof NullPointerException)) {
                        Assert.fail(""Unexpected exception for argCount "" + argCount + "" / argNull "" + argNull + "": "" + ex);
                    }
                }

            }

            Class<?>[] params = new Class[argCount + 1];
            Arrays.fill(params, SingleSource.class);
            Class<?> fniClass = Class.forName(""io.reactivex.rxjava3.functions.Function"" + argCount);
            params[argCount] = fniClass;

            Object[] values = new Object[argCount + 1];
            Arrays.fill(values, just1);
            values[argCount] = null;

            Method m = clazz.getMethod(""zip"", params);

            try {
                m.invoke(null, values);
                Assert.fail(""No exception for argCount "" + argCount + "" / zipper function "");
            } catch (InvocationTargetException ex) {
                if (!(ex.getCause() instanceof NullPointerException)) {
                    Assert.fail(""Unexpected exception for argCount "" + argCount + "" / zipper function: "" + ex);
                }
            }
        }
    }",loop_control
iterator,"{
        Iterable<? extends Flowable<Integer>> f = SingleInternalHelper.iterableToFlowable(Arrays.asList(Single.just(1)));

        Iterator<? extends Flowable<Integer>> iterator = f.iterator();
        iterator.next();
        iterator.remove();
    }",iterator
i,"{
        final List<Single<Integer>> singles = Arrays.asList(Single.just(1), Single.just(4));
        Single.zip(singles, new Function<Object[], Object>() {
            @Override
            public Object apply(final Object[] o) throws Exception {
                int sum = 0;
                for (Object i : o) {
                    sum += (Integer) i;
                }
                return sum;
            }
        }).test().assertResult(5);
    }",iterator
i,"{
        SpscLinkedArrayQueue<Integer> q = new SpscLinkedArrayQueue<>(8);
        assertTrue(q.offer(1, 2));
        assertTrue(q.offer(3, 4));
        assertTrue(q.offer(5, 6));
        assertTrue(q.offer(7, 8)); // this should trigger a new buffer

        for (int i = 0; i < 8; i++) {
            assertEquals(i + 1, q.peek().intValue());
            assertEquals(i + 1, q.poll().intValue());
        }

        assertNull(q.peek());
        assertNull(q.poll());
    }",loop_control
c,"{
        final MpscLinkedQueue<Integer> q = new MpscLinkedQueue<>();

        final AtomicInteger c = new AtomicInteger(3);

        Thread t1 = new Thread(new Runnable() {
            int i;
            @Override
            public void run() {
                c.decrementAndGet();
                while (c.get() != 0) { }

                while (i++ < 10000) {
                    q.offer(i);
                }
            }
        });
        t1.start();

        Thread t2 = new Thread(new Runnable() {
            int i = 10000;
            @Override
            public void run() {
                c.decrementAndGet();
                while (c.get() != 0) { }

                while (i++ < 10000) {
                    q.offer(i);
                }
            }
        });
        t2.start();

        Runnable r3 = new Runnable() {
            int i = 20000;
            @Override
            public void run() {
                c.decrementAndGet();
                while (c.get() != 0) { }

                while (--i > 0) {
                    q.poll();
                }
            }
        };

        r3.run();

        t1.join();
        t2.join();
    }",maybe_loop_control
i,"{
        final MpscLinkedQueue<Integer> q = new MpscLinkedQueue<>();

        final AtomicInteger c = new AtomicInteger(3);

        Thread t1 = new Thread(new Runnable() {
            int i;
            @Override
            public void run() {
                c.decrementAndGet();
                while (c.get() != 0) { }

                while (i++ < 10000) {
                    q.offer(i);
                }
            }
        });
        t1.start();

        Thread t2 = new Thread(new Runnable() {
            int i = 10000;
            @Override
            public void run() {
                c.decrementAndGet();
                while (c.get() != 0) { }

                while (i++ < 10000) {
                    q.offer(i);
                }
            }
        });
        t2.start();

        Runnable r3 = new Runnable() {
            int i = 20000;
            @Override
            public void run() {
                c.decrementAndGet();
                while (c.get() != 0) { }

                while (--i > 0) {
                    q.poll();
                }
            }
        };

        r3.run();

        t1.join();
        t2.join();
    }",loop_control
i,"{
        SpscLinkedArrayQueue<Integer> q = new SpscLinkedArrayQueue<>(16);

        AtomicReferenceArray<Object> ara = q.producerBuffer;

        for (int i = 0; i < 20; i++) {
            q.offer(i);
        }

        assertNotNull(ara.get(16));

        for (int i = 0; i < 20; i++) {
            assertEquals(i, q.poll().intValue());
        }

        assertNull(ara.get(16));
    }",loop_control
i,"{
        final Disposable firstSet = mock(Disposable.class);
        serialDisposable.update(firstSet);

        final CountDownLatch start = new CountDownLatch(1);

        final int count = 10;
        final CountDownLatch end = new CountDownLatch(count);

        final List<Thread> threads = new ArrayList<>();
        for (int i = 0; i < count; i++) {
            final Thread t = new Thread() {
                @Override
                public void run() {
                    try {
                        start.await();
                        serialDisposable.dispose();
                    } catch (InterruptedException e) {
                        fail(e.getMessage());
                    } finally {
                        end.countDown();
                    }
                }
            };
            t.start();
            threads.add(t);
        }

        final Disposable underlying = mock(Disposable.class);
        start.countDown();
        serialDisposable.update(underlying);
        end.await();
        verify(firstSet).dispose();
        verify(underlying).dispose();

        for (final Thread t : threads) {
            t.join();
        }
    }",loop_control
t,"{
        final Disposable firstSet = mock(Disposable.class);
        serialDisposable.update(firstSet);

        final CountDownLatch start = new CountDownLatch(1);

        final int count = 10;
        final CountDownLatch end = new CountDownLatch(count);

        final List<Thread> threads = new ArrayList<>();
        for (int i = 0; i < count; i++) {
            final Thread t = new Thread() {
                @Override
                public void run() {
                    try {
                        start.await();
                        serialDisposable.dispose();
                    } catch (InterruptedException e) {
                        fail(e.getMessage());
                    } finally {
                        end.countDown();
                    }
                }
            };
            t.start();
            threads.add(t);
        }

        final Disposable underlying = mock(Disposable.class);
        start.countDown();
        serialDisposable.update(underlying);
        end.await();
        verify(firstSet).dispose();
        verify(underlying).dispose();

        for (final Thread t : threads) {
            t.join();
        }
    }",iterator
i,"{
        final int count = 10;
        final List<Disposable> subscriptions = new ArrayList<>();

        final CountDownLatch start = new CountDownLatch(1);
        final CountDownLatch end = new CountDownLatch(count);

        final List<Thread> threads = new ArrayList<>();
        for (int i = 0; i < count; i++) {
            final Disposable subscription = mock(Disposable.class);
            subscriptions.add(subscription);

            final Thread t = new Thread() {
                @Override
                public void run() {
                    try {
                        start.await();
                        serialDisposable.update(subscription);
                    } catch (InterruptedException e) {
                        fail(e.getMessage());
                    } finally {
                        end.countDown();
                    }
                }
            };
            t.start();
            threads.add(t);
        }

        start.countDown();
        end.await();
        serialDisposable.dispose();

        for (final Disposable subscription : subscriptions) {
            verify(subscription).dispose();
        }

        for (final Thread t : threads) {
            t.join();
        }
    }",loop_control
t,"{
        final int count = 10;
        final List<Disposable> subscriptions = new ArrayList<>();

        final CountDownLatch start = new CountDownLatch(1);
        final CountDownLatch end = new CountDownLatch(count);

        final List<Thread> threads = new ArrayList<>();
        for (int i = 0; i < count; i++) {
            final Disposable subscription = mock(Disposable.class);
            subscriptions.add(subscription);

            final Thread t = new Thread() {
                @Override
                public void run() {
                    try {
                        start.await();
                        serialDisposable.update(subscription);
                    } catch (InterruptedException e) {
                        fail(e.getMessage());
                    } finally {
                        end.countDown();
                    }
                }
            };
            t.start();
            threads.add(t);
        }

        start.countDown();
        end.await();
        serialDisposable.dispose();

        for (final Disposable subscription : subscriptions) {
            verify(subscription).dispose();
        }

        for (final Thread t : threads) {
            t.join();
        }
    }",iterator
i,"{
        final AtomicInteger counter = new AtomicInteger();
        final CompositeDisposable cd = new CompositeDisposable();

        final int count = 10;
        final CountDownLatch start = new CountDownLatch(1);
        for (int i = 0; i < count; i++) {
            cd.add(Disposable.fromRunnable(new Runnable() {

                @Override
                public void run() {
                    counter.incrementAndGet();
                }
            }));
        }

        final List<Thread> threads = new ArrayList<>();
        for (int i = 0; i < count; i++) {
            final Thread t = new Thread() {
                @Override
                public void run() {
                    try {
                        start.await();
                        cd.dispose();
                    } catch (final InterruptedException e) {
                        fail(e.getMessage());
                    }
                }
            };
            t.start();
            threads.add(t);
        }

        start.countDown();
        for (final Thread t : threads) {
            t.join();
        }

        assertEquals(count, counter.get());
    }",loop_control
t,"{
        final AtomicInteger counter = new AtomicInteger();
        final CompositeDisposable cd = new CompositeDisposable();

        final int count = 10;
        final CountDownLatch start = new CountDownLatch(1);
        for (int i = 0; i < count; i++) {
            cd.add(Disposable.fromRunnable(new Runnable() {

                @Override
                public void run() {
                    counter.incrementAndGet();
                }
            }));
        }

        final List<Thread> threads = new ArrayList<>();
        for (int i = 0; i < count; i++) {
            final Thread t = new Thread() {
                @Override
                public void run() {
                    try {
                        start.await();
                        cd.dispose();
                    } catch (final InterruptedException e) {
                        fail(e.getMessage());
                    }
                }
            };
            t.start();
            threads.add(t);
        }

        start.countDown();
        for (final Thread t : threads) {
            t.join();
        }

        assertEquals(count, counter.get());
    }",iterator
i,"{
        final AtomicInteger counter = new AtomicInteger();
        final CompositeDisposable cd = new CompositeDisposable();

        final int count = 10;
        final CountDownLatch start = new CountDownLatch(1);
        cd.add(Disposable.fromRunnable(new Runnable() {

            @Override
            public void run() {
                counter.incrementAndGet();
            }

        }));

        final List<Thread> threads = new ArrayList<>();
        for (int i = 0; i < count; i++) {
            final Thread t = new Thread() {
                @Override
                public void run() {
                    try {
                        start.await();
                        cd.dispose();
                    } catch (final InterruptedException e) {
                        fail(e.getMessage());
                    }
                }
            };
            t.start();
            threads.add(t);
        }

        start.countDown();
        for (final Thread t : threads) {
            t.join();
        }

        // we should have only disposed once
        assertEquals(1, counter.get());
    }",loop_control
t,"{
        final AtomicInteger counter = new AtomicInteger();
        final CompositeDisposable cd = new CompositeDisposable();

        final int count = 10;
        final CountDownLatch start = new CountDownLatch(1);
        cd.add(Disposable.fromRunnable(new Runnable() {

            @Override
            public void run() {
                counter.incrementAndGet();
            }

        }));

        final List<Thread> threads = new ArrayList<>();
        for (int i = 0; i < count; i++) {
            final Thread t = new Thread() {
                @Override
                public void run() {
                    try {
                        start.await();
                        cd.dispose();
                    } catch (final InterruptedException e) {
                        fail(e.getMessage());
                    }
                }
            };
            t.start();
            threads.add(t);
        }

        start.countDown();
        for (final Thread t : threads) {
            t.join();
        }

        // we should have only disposed once
        assertEquals(1, counter.get());
    }",iterator
i,"{
        for (int i = 0; i < TestHelper.RACE_DEFAULT_LOOPS; i++) {
            final CompositeDisposable cd = new CompositeDisposable();

            Runnable run = new Runnable() {
                @Override
                public void run() {
                    cd.dispose();
                }
            };

            TestHelper.race(run, run);
        }
    }",loop_control
i,"{
        for (int i = 0; i < TestHelper.RACE_DEFAULT_LOOPS; i++) {
            final CompositeDisposable cd = new CompositeDisposable();

            Runnable run = new Runnable() {
                @Override
                public void run() {
                    cd.add(Disposable.empty());
                }
            };

            TestHelper.race(run, run);
        }
    }",loop_control
i,"{
        for (int i = 0; i < TestHelper.RACE_DEFAULT_LOOPS; i++) {
            final CompositeDisposable cd = new CompositeDisposable();

            Runnable run = new Runnable() {
                @Override
                public void run() {
                    cd.addAll(Disposable.empty());
                }
            };

            TestHelper.race(run, run);
        }
    }",loop_control
i,"{
        for (int i = 0; i < TestHelper.RACE_DEFAULT_LOOPS; i++) {
            final CompositeDisposable cd = new CompositeDisposable();

            final Disposable d1 = Disposable.empty();

            cd.add(d1);

            Runnable run = new Runnable() {
                @Override
                public void run() {
                    cd.remove(d1);
                }
            };

            TestHelper.race(run, run);
        }
    }",loop_control
i,"{
        for (int i = 0; i < TestHelper.RACE_DEFAULT_LOOPS; i++) {
            final CompositeDisposable cd = new CompositeDisposable();

            final Disposable d1 = Disposable.empty();

            cd.add(d1);

            Runnable run = new Runnable() {
                @Override
                public void run() {
                    cd.delete(d1);
                }
            };

            TestHelper.race(run, run);
        }
    }",loop_control
i,"{
        for (int i = 0; i < TestHelper.RACE_DEFAULT_LOOPS; i++) {
            final CompositeDisposable cd = new CompositeDisposable();

            final Disposable d1 = Disposable.empty();

            cd.add(d1);

            Runnable run = new Runnable() {
                @Override
                public void run() {
                    cd.clear();
                }
            };

            TestHelper.race(run, run);
        }
    }",loop_control
i,"{
        for (int i = 0; i < TestHelper.RACE_DEFAULT_LOOPS; i++) {
            final CompositeDisposable cd = new CompositeDisposable();

            Runnable run = new Runnable() {
                @Override
                public void run() {
                    cd.dispose();
                }
            };

            Runnable run2 = new Runnable() {
                @Override
                public void run() {
                    cd.add(Disposable.empty());
                }
            };

            TestHelper.race(run, run2);
        }
    }",loop_control
i,"{
        for (int i = 0; i < TestHelper.RACE_DEFAULT_LOOPS; i++) {
            final CompositeDisposable cd = new CompositeDisposable();

            Runnable run = new Runnable() {
                @Override
                public void run() {
                    cd.dispose();
                }
            };

            Runnable run2 = new Runnable() {
                @Override
                public void run() {
                    cd.addAll(Disposable.empty());
                }
            };

            TestHelper.race(run, run2);
        }
    }",loop_control
i,"{
        for (int i = 0; i < TestHelper.RACE_DEFAULT_LOOPS; i++) {
            final CompositeDisposable cd = new CompositeDisposable();

            final Disposable d1 = Disposable.empty();

            cd.add(d1);

            Runnable run = new Runnable() {
                @Override
                public void run() {
                    cd.dispose();
                }
            };

            Runnable run2 = new Runnable() {
                @Override
                public void run() {
                    cd.remove(d1);
                }
            };

            TestHelper.race(run, run2);
        }
    }",loop_control
i,"{
        for (int i = 0; i < TestHelper.RACE_DEFAULT_LOOPS; i++) {
            final CompositeDisposable cd = new CompositeDisposable();

            final Disposable d1 = Disposable.empty();

            cd.add(d1);

            Runnable run = new Runnable() {
                @Override
                public void run() {
                    cd.dispose();
                }
            };

            Runnable run2 = new Runnable() {
                @Override
                public void run() {
                    cd.delete(d1);
                }
            };

            TestHelper.race(run, run2);
        }
    }",loop_control
i,"{
        for (int i = 0; i < TestHelper.RACE_DEFAULT_LOOPS; i++) {
            final CompositeDisposable cd = new CompositeDisposable();

            final Disposable d1 = Disposable.empty();

            cd.add(d1);

            Runnable run = new Runnable() {
                @Override
                public void run() {
                    cd.dispose();
                }
            };

            Runnable run2 = new Runnable() {
                @Override
                public void run() {
                    cd.clear();
                }
            };

            TestHelper.race(run, run2);
        }
    }",loop_control
i,"{
        for (int i = 0; i < TestHelper.RACE_DEFAULT_LOOPS; i++) {
            final CompositeDisposable cd = new CompositeDisposable();

            final Disposable d1 = Disposable.empty();

            cd.add(d1);

            Runnable run = new Runnable() {
                @Override
                public void run() {
                    cd.dispose();
                }
            };

            Runnable run2 = new Runnable() {
                @Override
                public void run() {
                    cd.size();
                }
            };

            TestHelper.race(run, run2);
        }
    }",loop_control
i,"{
        for (int i = 0; i < TestHelper.RACE_DEFAULT_LOOPS; i++) {
            final Disposable d = Disposable.empty();

            Runnable r = new Runnable() {
                @Override
                public void run() {
                    d.dispose();
                }
            };

            TestHelper.race(r, r);
        }
    }",loop_control
i,"{
        final Disposable firstSet = mock(Disposable.class);
        serialDisposable.set(firstSet);

        final CountDownLatch start = new CountDownLatch(1);

        final int count = 10;
        final CountDownLatch end = new CountDownLatch(count);

        final List<Thread> threads = new ArrayList<>();
        for (int i = 0; i < count; i++) {
            final Thread t = new Thread() {
                @Override
                public void run() {
                    try {
                        start.await();
                        serialDisposable.dispose();
                    } catch (InterruptedException e) {
                        fail(e.getMessage());
                    } finally {
                        end.countDown();
                    }
                }
            };
            t.start();
            threads.add(t);
        }

        final Disposable underlying = mock(Disposable.class);
        start.countDown();
        serialDisposable.set(underlying);
        end.await();
        verify(firstSet).dispose();
        verify(underlying).dispose();

        for (final Thread t : threads) {
            t.join();
        }
    }",loop_control
t,"{
        final Disposable firstSet = mock(Disposable.class);
        serialDisposable.set(firstSet);

        final CountDownLatch start = new CountDownLatch(1);

        final int count = 10;
        final CountDownLatch end = new CountDownLatch(count);

        final List<Thread> threads = new ArrayList<>();
        for (int i = 0; i < count; i++) {
            final Thread t = new Thread() {
                @Override
                public void run() {
                    try {
                        start.await();
                        serialDisposable.dispose();
                    } catch (InterruptedException e) {
                        fail(e.getMessage());
                    } finally {
                        end.countDown();
                    }
                }
            };
            t.start();
            threads.add(t);
        }

        final Disposable underlying = mock(Disposable.class);
        start.countDown();
        serialDisposable.set(underlying);
        end.await();
        verify(firstSet).dispose();
        verify(underlying).dispose();

        for (final Thread t : threads) {
            t.join();
        }
    }",iterator
i,"{
        final int count = 10;
        final List<Disposable> subscriptions = new ArrayList<>();

        final CountDownLatch start = new CountDownLatch(1);
        final CountDownLatch end = new CountDownLatch(count);

        final List<Thread> threads = new ArrayList<>();
        for (int i = 0; i < count; i++) {
            final Disposable subscription = mock(Disposable.class);
            subscriptions.add(subscription);

            final Thread t = new Thread() {
                @Override
                public void run() {
                    try {
                        start.await();
                        serialDisposable.set(subscription);
                    } catch (InterruptedException e) {
                        fail(e.getMessage());
                    } finally {
                        end.countDown();
                    }
                }
            };
            t.start();
            threads.add(t);
        }

        start.countDown();
        end.await();
        serialDisposable.dispose();

        for (final Disposable subscription : subscriptions) {
            verify(subscription).dispose();
        }

        for (final Thread t : threads) {
            t.join();
        }
    }",loop_control
t,"{
        final int count = 10;
        final List<Disposable> subscriptions = new ArrayList<>();

        final CountDownLatch start = new CountDownLatch(1);
        final CountDownLatch end = new CountDownLatch(count);

        final List<Thread> threads = new ArrayList<>();
        for (int i = 0; i < count; i++) {
            final Disposable subscription = mock(Disposable.class);
            subscriptions.add(subscription);

            final Thread t = new Thread() {
                @Override
                public void run() {
                    try {
                        start.await();
                        serialDisposable.set(subscription);
                    } catch (InterruptedException e) {
                        fail(e.getMessage());
                    } finally {
                        end.countDown();
                    }
                }
            };
            t.start();
            threads.add(t);
        }

        start.countDown();
        end.await();
        serialDisposable.dispose();

        for (final Disposable subscription : subscriptions) {
            verify(subscription).dispose();
        }

        for (final Thread t : threads) {
            t.join();
        }
    }",iterator
n,"{
        for (int n = 1; n < 10000; n *= 10) {
            Completable c = Completable.fromPublisher(Flowable.range(1, n));

            c.blockingAwait();
        }
    }",loop_control
n,"{
        for (int n = 1; n < 10000; n *= 10) {
            Completable c = Completable.fromObservable(Observable.range(1, n));

            c.blockingAwait();
        }
    }",loop_control
timeout,"{
        Completable c = normal.completable.delay(250, TimeUnit.MILLISECONDS);

        final AtomicBoolean done = new AtomicBoolean();
        final AtomicReference<Throwable> error = new AtomicReference<>();

        c.subscribe(new CompletableObserver() {
            @Override
            public void onSubscribe(Disposable d) {

            }

            @Override
            public void onError(Throwable e) {
                error.set(e);
            }

            @Override
            public void onComplete() {
                done.set(true);
            }
        });

        Thread.sleep(100);

        Assert.assertFalse(""Already done"", done.get());

        int timeout = 10;

        while (timeout-- > 0 && !done.get()) {
            Thread.sleep(100);
        }

        Assert.assertTrue(""Not done"", done.get());

        Assert.assertNull(error.get());
    }",loop_control
done,"{
        Completable c = normal.completable.delay(250, TimeUnit.MILLISECONDS);

        final AtomicBoolean done = new AtomicBoolean();
        final AtomicReference<Throwable> error = new AtomicReference<>();

        c.subscribe(new CompletableObserver() {
            @Override
            public void onSubscribe(Disposable d) {

            }

            @Override
            public void onError(Throwable e) {
                error.set(e);
            }

            @Override
            public void onComplete() {
                done.set(true);
            }
        });

        Thread.sleep(100);

        Assert.assertFalse(""Already done"", done.get());

        int timeout = 10;

        while (timeout-- > 0 && !done.get()) {
            Thread.sleep(100);
        }

        Assert.assertTrue(""Not done"", done.get());

        Assert.assertNull(error.get());
    }",maybe_loop_control
i,"{
        final AtomicInteger calls = new AtomicInteger();

        Completable c = normal.completable.doOnSubscribe(new Consumer<Disposable>() {
            @Override
            public void accept(Disposable d) {
                calls.getAndIncrement();
            }
        });

        for (int i = 0; i < 10; i++) {
            c.blockingAwait();
        }

        Assert.assertEquals(10, calls.get());
    }",loop_control
caught,"{
        Thread.UncaughtExceptionHandler originalHandler = Thread.getDefaultUncaughtExceptionHandler();
        CapturingUncaughtExceptionHandler handler = new CapturingUncaughtExceptionHandler();
        Thread.setDefaultUncaughtExceptionHandler(handler);
        RxJavaPlugins.setErrorHandler(new Consumer<Throwable>() {
            @Override
            public void accept(Throwable error) throws Exception {
                Thread.currentThread().getUncaughtExceptionHandler().uncaughtException(Thread.currentThread(), error);
            }
        });
        try {
            action.run();
            assertEquals(""Should have received exactly 1 exception"", 1, handler.count);
            Throwable caught = handler.caught;
            while (caught != null) {
                if (caught instanceof TestException) { break; }
                if (caught == caught.getCause()) { break; }
                caught = caught.getCause();
            }
            assertTrue(""A TestException should have been delivered to the handler"",
                    caught instanceof TestException);
        } catch (Throwable ex) {
            throw ExceptionHelper.wrapOrThrow(ex);
        } finally {
            Thread.setDefaultUncaughtExceptionHandler(originalHandler);
            RxJavaPlugins.setErrorHandler(null);
        }
    }",maybe_loop_control
caught,"{
        Thread.UncaughtExceptionHandler originalHandler = Thread.getDefaultUncaughtExceptionHandler();
        CapturingUncaughtExceptionHandler handler = new CapturingUncaughtExceptionHandler();
        Thread.setDefaultUncaughtExceptionHandler(handler);
        RxJavaPlugins.setErrorHandler(new Consumer<Throwable>() {
            @Override
            public void accept(Throwable error) throws Exception {
                Thread.currentThread().getUncaughtExceptionHandler().uncaughtException(Thread.currentThread(), error);
            }
        });
        try {
            action.run();
            assertEquals(""Should have received exactly 1 exception"", 1, handler.count);
            Throwable caught = handler.caught;
            while (caught != null) {
                if (caught instanceof TestException) { break; }
                if (caught == caught.getCause()) { break; }
                caught = caught.getCause();
            }
            assertTrue(""A TestException should have been delivered to the handler"",
                    caught instanceof TestException);
        } catch (Throwable ex) {
            throw ExceptionHelper.wrapOrThrow(ex);
        } finally {
            Thread.setDefaultUncaughtExceptionHandler(originalHandler);
            RxJavaPlugins.setErrorHandler(null);
        }
    }",break_loop_control
i,"{
        ReplaySubject<String> src = ReplaySubject.create();

        for (int i = 0; i < 10; i++) {
            final Observer<Object> o = TestHelper.mockObserver();
            InOrder inOrder = inOrder(o);
            String v = """" + i;
            src.onNext(v);
            System.out.printf(""Turn: %d%n"", i);
            src.firstElement()
                .toObservable()
                .flatMap(new Function<String, Observable<String>>() {

                    @Override
                    public Observable<String> apply(String t1) {
                        return Observable.just(t1 + "", "" + t1);
                    }
                })
                .subscribe(new DefaultObserver<String>() {
                    @Override
                    public void onNext(String t) {
                        System.out.println(t);
                        o.onNext(t);
                    }

                    @Override
                    public void onError(Throwable e) {
                        o.onError(e);
                    }

                    @Override
                    public void onComplete() {
                        o.onComplete();
                    }
                });
            inOrder.verify(o).onNext(""0, 0"");
            inOrder.verify(o).onComplete();
            verify(o, never()).onError(any(Throwable.class));
        }
    }",loop_control
i,"{
        ReplaySubject<Integer> source = ReplaySubject.createWithSize(1);

        source.onNext(1);
        source.onNext(2);
        source.onComplete();

        for (int i = 0; i < 1; i++) {
            Observer<Integer> o = TestHelper.mockObserver();

            source.subscribe(o);

            verify(o, never()).onNext(1);
            verify(o).onNext(2);
            verify(o).onComplete();
            verify(o, never()).onError(any(Throwable.class));
        }
    }",loop_control
i,"{
        ReplaySubject<Object> rs = ReplaySubject.createWithSize(1);

        assertEquals(0, rs.size());
        assertFalse(rs.hasValue());

        for (int i = 0; i < 1000; i++) {
            rs.onNext(i);

            assertEquals(1, rs.size());
            assertTrue(rs.hasValue());
        }

        rs.onComplete();

        assertEquals(1, rs.size());
        assertTrue(rs.hasValue());
    }",loop_control
i,"{
        TestScheduler to = new TestScheduler();
        ReplaySubject<Object> rs = ReplaySubject.createWithTime(1, TimeUnit.SECONDS, to);

        assertEquals(0, rs.size());
        assertFalse(rs.hasValue());

        for (int i = 0; i < 1000; i++) {
            rs.onNext(i);
            assertEquals(1, rs.size());
            assertTrue(rs.hasValue());
            to.advanceTimeBy(2, TimeUnit.SECONDS);
            assertEquals(0, rs.size());
            assertFalse(rs.hasValue());
        }

        rs.onComplete();

        assertEquals(0, rs.size());
        assertFalse(rs.hasValue());
    }",loop_control
i,"{
        ReplaySubject<Object> rs = ReplaySubject.create();
        Object[] expected = new Object[10];
        for (int i = 0; i < expected.length; i++) {
            expected[i] = i;
            rs.onNext(i);
            assertArrayEquals(Arrays.copyOf(expected, i + 1), rs.getValues());
        }
        rs.onComplete();

        assertArrayEquals(expected, rs.getValues());

    }",loop_control
i,"{
        ReplaySubject<Object> rs = ReplaySubject.createUnbounded();
        Object[] expected = new Object[10];
        for (int i = 0; i < expected.length; i++) {
            expected[i] = i;
            rs.onNext(i);
            assertArrayEquals(Arrays.copyOf(expected, i + 1), rs.getValues());
        }
        rs.onComplete();

        assertArrayEquals(expected, rs.getValues());

    }",loop_control
i,"{
        ReplaySubject<Integer> rp = ReplaySubject.create(8);

        for (int i = 0; i < 15; i++) {
            rp.onNext(i);
        }
        rp.onComplete();

        rp.test().assertResult(0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14);
    }",loop_control
i,"{
        for (int i = 0; i < TestHelper.RACE_DEFAULT_LOOPS; i++) {
            final TestObserver<Integer> to = new TestObserver<>();

            final ReplaySubject<Integer> rp = ReplaySubject.create();

            Runnable r1 = new Runnable() {
                @Override
                public void run() {
                    rp.subscribe(to);
                }
            };

            Runnable r2 = new Runnable() {
                @Override
                public void run() {
                    to.dispose();
                }
            };

            TestHelper.race(r1, r2);
        }
    }",loop_control
i,"{
        for (int i = 0; i < TestHelper.RACE_DEFAULT_LOOPS; i++) {
            final ReplaySubject<Integer> rp = ReplaySubject.create();

            Runnable r1 = new Runnable() {
                @Override
                public void run() {
                    rp.test();
                }
            };

            TestHelper.race(r1, r1);
        }
    }",loop_control
i,"{
        for (int i = 0; i < TestHelper.RACE_DEFAULT_LOOPS; i++) {

            final ReplaySubject<Integer> rp = ReplaySubject.create();
            final TestObserver<Integer> to1 = rp.test();
            final TestObserver<Integer> to2 = rp.test();

            Runnable r1 = new Runnable() {
                @Override
                public void run() {
                    to1.dispose();
                }
            };

            Runnable r2 = new Runnable() {
                @Override
                public void run() {
                    to2.dispose();
                }
            };

            TestHelper.race(r1, r2);

            assertFalse(rp.hasObservers());
        }
    }",loop_control
i,"{
        final PublishSubject<Integer> s = PublishSubject.create();

        final AtomicInteger countParent = new AtomicInteger();
        final AtomicInteger countChildren = new AtomicInteger();
        final AtomicInteger countTotal = new AtomicInteger();

        final ArrayList<String> list = new ArrayList<>();

        s.flatMap(new Function<Integer, Observable<String>>() {

            @Override
            public Observable<String> apply(final Integer v) {
                countParent.incrementAndGet();

                // then subscribe to subject again (it will not receive the previous value)
                return s.map(new Function<Integer, String>() {

                    @Override
                    public String apply(Integer v2) {
                        countChildren.incrementAndGet();
                        return ""Parent: "" + v + "" Child: "" + v2;
                    }

                });
            }

        }).subscribe(new Consumer<String>() {

            @Override
            public void accept(String v) {
                countTotal.incrementAndGet();
                list.add(v);
            }

        });

        for (int i = 0; i < 10; i++) {
            s.onNext(i);
        }
        s.onComplete();

        //            System.out.println(""countParent: "" + countParent.get());
        //            System.out.println(""countChildren: "" + countChildren.get());
        //            System.out.println(""countTotal: "" + countTotal.get());

        // 9+8+7+6+5+4+3+2+1+0 == 45
        assertEquals(45, list.size());
    }",loop_control
i,"{
        PublishSubject<String> src = PublishSubject.create();

        for (int i = 0; i < 10; i++) {
            final Observer<Object> o = TestHelper.mockObserver();
            InOrder inOrder = inOrder(o);
            String v = """" + i;
            System.out.printf(""Turn: %d%n"", i);
            src.firstElement()
                .toObservable()
                .flatMap(new Function<String, Observable<String>>() {

                    @Override
                    public Observable<String> apply(String t1) {
                        return Observable.just(t1 + "", "" + t1);
                    }
                })
                .subscribe(new DefaultObserver<String>() {
                    @Override
                    public void onNext(String t) {
                        o.onNext(t);
                    }

                    @Override
                    public void onError(Throwable e) {
                        o.onError(e);
                    }

                    @Override
                    public void onComplete() {
                        o.onComplete();
                    }
                });
            src.onNext(v);

            inOrder.verify(o).onNext(v + "", "" + v);
            inOrder.verify(o).onComplete();
            verify(o, never()).onError(any(Throwable.class));
        }
    }",loop_control
i,"{

        for (int i = 0; i < TestHelper.RACE_DEFAULT_LOOPS; i++) {
            final PublishSubject<Integer> ps = PublishSubject.create();

            TestObserver<Integer> to = ps.test();

            Runnable task = new Runnable() {
                @Override
                public void run() {
                    ps.onComplete();
                }
            };

            TestHelper.race(task, task);

            to
            .awaitDone(5, TimeUnit.SECONDS)
            .assertResult();
        }
    }",loop_control
i,"{

        for (int i = 0; i < TestHelper.RACE_DEFAULT_LOOPS; i++) {
            final PublishSubject<Integer> ps = PublishSubject.create();

            final TestObserver<Integer> to = ps.test();

            Runnable r1 = new Runnable() {
                @Override
                public void run() {
                    ps.subscribe();
                }
            };
            Runnable r2 = new Runnable() {
                @Override
                public void run() {
                    to.dispose();
                }
            };

            TestHelper.race(r1, r2);
        }
    }",loop_control
i,"{

        for (int i = 0; i < TestHelper.RACE_DEFAULT_LOOPS; i++) {
            final PublishSubject<Integer> ps = PublishSubject.create();

            Runnable r1 = new Runnable() {
                @Override
                public void run() {
                    ps.subscribe();
                }
            };
            Runnable r2 = new Runnable() {
                @Override
                public void run() {
                    ps.onComplete();
                }
            };

            TestHelper.race(r1, r2);
        }
    }",loop_control
i,"{

        for (int i = 0; i < TestHelper.RACE_DEFAULT_LOOPS; i++) {
            final PublishSubject<Integer> ps = PublishSubject.create();

            final TestObserver<Integer> to = new TestObserver<>();

            Runnable r1 = new Runnable() {
                @Override
                public void run() {
                    ps.subscribe(to);
                }
            };
            Runnable r2 = new Runnable() {
                @Override
                public void run() {
                    ps.onComplete();
                }
            };

            TestHelper.race(r1, r2);

            to.awaitDone(5, TimeUnit.SECONDS)
            .assertResult();
        }
    }",loop_control
i,"{
        /*
         * With non-threadsafe code this fails most of the time on my dev laptop and is non-deterministic enough
         * to act as a unit test to the race conditions.
         *
         * With the synchronization code in place I can not get this to fail on my laptop.
         */
        for (int i = 0; i < 50; i++) {
            final AsyncSubject<String> subject = AsyncSubject.create();
            final AtomicReference<String> value1 = new AtomicReference<>();

            subject.subscribe(new Consumer<String>() {

                @Override
                public void accept(String t1) {
                    try {
                        // simulate a slow observer
                        Thread.sleep(50);
                    } catch (InterruptedException e) {
                        e.printStackTrace();
                    }
                    value1.set(t1);
                }

            });

            Thread t1 = new Thread(new Runnable() {

                @Override
                public void run() {
                    subject.onNext(""value"");
                    subject.onComplete();
                }
            });

            SubjectSubscriberThread t2 = new SubjectSubscriberThread(subject);
            SubjectSubscriberThread t3 = new SubjectSubscriberThread(subject);
            SubjectSubscriberThread t4 = new SubjectSubscriberThread(subject);
            SubjectSubscriberThread t5 = new SubjectSubscriberThread(subject);

            t2.start();
            t3.start();
            t1.start();
            t4.start();
            t5.start();
            try {
                t1.join();
                t2.join();
                t3.join();
                t4.join();
                t5.join();
            } catch (InterruptedException e) {
                throw new RuntimeException(e);
            }

            assertEquals(""value"", value1.get());
            assertEquals(""value"", t2.value.get());
            assertEquals(""value"", t3.value.get());
            assertEquals(""value"", t4.value.get());
            assertEquals(""value"", t5.value.get());
        }

    }",loop_control
i,"{
        AsyncSubject<Object> p = AsyncSubject.create();

        for (int i = 0; i < TestHelper.RACE_DEFAULT_LOOPS; i++) {
            final TestObserver<Object> to1 = p.test();
            final TestObserver<Object> to2 = p.test();

            Runnable r1 = new Runnable() {
                @Override
                public void run() {
                    to1.dispose();
                }
            };

            Runnable r2 = new Runnable() {
                @Override
                public void run() {
                    to2.dispose();
                }
            };

            TestHelper.race(r1, r2);
        }
    }",loop_control
i,"{

        for (int i = 0; i < TestHelper.RACE_DEFAULT_LOOPS; i++) {
            final AsyncSubject<Object> p = AsyncSubject.create();

            final TestObserverEx<Object> to1 = p.to(TestHelper.testConsumer());

            Runnable r1 = new Runnable() {
                @Override
                public void run() {
                    to1.dispose();
                }
            };

            final TestException ex = new TestException();

            Runnable r2 = new Runnable() {
                @Override
                public void run() {
                    p.onError(ex);
                }
            };

            TestHelper.race(r1, r2);

            if (to1.errors().size() != 0) {
                to1.assertFailure(TestException.class);
            } else {
                to1.assertEmpty();
            }
        }
    }",loop_control
i,"{
        Set<Integer> expectedSet = new HashSet<>(Arrays.asList(1, 2));

        for (int i = 0; i < TestHelper.RACE_DEFAULT_LOOPS; i++) {
            final Subject<Integer> s = PublishSubject.<Integer>create().toSerialized();

            TestObserverEx<Integer> to = s.to(TestHelper.<Integer>testConsumer());

            Runnable r1 = new Runnable() {
                @Override
                public void run() {
                    s.onNext(1);
                }
            };

            Runnable r2 = new Runnable() {
                @Override
                public void run() {
                    s.onNext(2);
                }
            };

            TestHelper.race(r1, r2);

            to.assertSubscribed()
            .assertNoErrors()
            .assertNotComplete()
            .assertValueCount(2)
            ;

            Set<Integer> actualSet = new HashSet<>(to.values());
            assertEquals("""" + actualSet, expectedSet, actualSet);
        }
    }",loop_control
i,"{
        for (int i = 0; i < TestHelper.RACE_DEFAULT_LOOPS; i++) {
            final Subject<Integer> s = PublishSubject.<Integer>create().toSerialized();

            TestObserver<Integer> to = s.test();

            final TestException ex = new TestException();

            Runnable r1 = new Runnable() {
                @Override
                public void run() {
                    s.onNext(1);
                }
            };

            Runnable r2 = new Runnable() {
                @Override
                public void run() {
                    s.onError(ex);
                }
            };

            TestHelper.race(r1, r2);

            to.assertError(ex).assertNotComplete();

            if (to.values().size() != 0) {
                to.assertValue(1);
            }
        }
    }",loop_control
i,"{
        for (int i = 0; i < TestHelper.RACE_DEFAULT_LOOPS; i++) {
            final Subject<Integer> s = PublishSubject.<Integer>create().toSerialized();

            TestObserver<Integer> to = s.test();

            Runnable r1 = new Runnable() {
                @Override
                public void run() {
                    s.onNext(1);
                }
            };

            Runnable r2 = new Runnable() {
                @Override
                public void run() {
                    s.onComplete();
                }
            };

            TestHelper.race(r1, r2);

            to.assertComplete().assertNoErrors();

            if (to.values().size() != 0) {
                to.assertValue(1);
            }
        }
    }",loop_control
i,"{
        for (int i = 0; i < TestHelper.RACE_DEFAULT_LOOPS; i++) {
            final Subject<Integer> s = PublishSubject.<Integer>create().toSerialized();

            TestObserver<Integer> to = s.test();

            final Disposable bs = Disposable.empty();

            Runnable r1 = new Runnable() {
                @Override
                public void run() {
                    s.onNext(1);
                }
            };

            Runnable r2 = new Runnable() {
                @Override
                public void run() {
                    s.onSubscribe(bs);
                }
            };

            TestHelper.race(r1, r2);

            to.assertValue(1).assertNotComplete().assertNoErrors();
        }
    }",loop_control
i,"{
        for (int i = 0; i < TestHelper.RACE_DEFAULT_LOOPS; i++) {
            final Subject<Integer> s = PublishSubject.<Integer>create().toSerialized();

            TestObserver<Integer> to = s.test();

            final Disposable bs = Disposable.empty();

            Runnable r1 = new Runnable() {
                @Override
                public void run() {
                    s.onComplete();
                }
            };

            Runnable r2 = new Runnable() {
                @Override
                public void run() {
                    s.onSubscribe(bs);
                }
            };

            TestHelper.race(r1, r2);

            to.assertResult();
        }
    }",loop_control
i,"{
        for (int i = 0; i < TestHelper.RACE_DEFAULT_LOOPS; i++) {
            final Subject<Integer> s = PublishSubject.<Integer>create().toSerialized();

            TestObserver<Integer> to = s.test();

            Runnable r1 = new Runnable() {
                @Override
                public void run() {
                    s.onComplete();
                }
            };

            Runnable r2 = new Runnable() {
                @Override
                public void run() {
                    s.onComplete();
                }
            };

            TestHelper.race(r1, r2);

            to.assertResult();
        }
    }",loop_control
i,"{
        for (int i = 0; i < TestHelper.RACE_DEFAULT_LOOPS; i++) {
            final Subject<Integer> s = PublishSubject.<Integer>create().toSerialized();

            TestObserver<Integer> to = s.test();

            final TestException ex = new TestException();

            List<Throwable> errors = TestHelper.trackPluginErrors();
            try {
                Runnable r1 = new Runnable() {
                    @Override
                    public void run() {
                        s.onError(ex);
                    }
                };

                Runnable r2 = new Runnable() {
                    @Override
                    public void run() {
                        s.onError(ex);
                    }
                };

                TestHelper.race(r1, r2);

                to.assertFailure(TestException.class);

                TestHelper.assertUndeliverable(errors, 0, TestException.class);
            } finally {
                RxJavaPlugins.reset();
            }
        }
    }",loop_control
i,"{
        for (int i = 0; i < TestHelper.RACE_DEFAULT_LOOPS; i++) {
            final Subject<Integer> s = PublishSubject.<Integer>create().toSerialized();

            TestObserver<Integer> to = s.test();

            final Disposable bs1 = Disposable.empty();
            final Disposable bs2 = Disposable.empty();

            Runnable r1 = new Runnable() {
                @Override
                public void run() {
                    s.onSubscribe(bs1);
                }
            };

            Runnable r2 = new Runnable() {
                @Override
                public void run() {
                    s.onSubscribe(bs2);
                }
            };

            TestHelper.race(r1, r2);

            to.assertEmpty();
        }
    }",loop_control
i,"{
        for (int i = 0; i < TestHelper.RACE_DEFAULT_LOOPS; i++) {
            final MaybeSubject<Integer> ms = MaybeSubject.create();

            final TestObserver<Integer> to = ms.test();

            Runnable r1 = new Runnable() {
                @Override
                public void run() {
                    ms.test();
                }
            };

            Runnable r2 = new Runnable() {
                @Override
                public void run() {
                    to.dispose();
                }
            };
            TestHelper.race(r1, r2);
        }
    }",loop_control
l,"{
        final ReplaySubject<Long> replay = ReplaySubject.createUnbounded();
        Thread source = new Thread(new Runnable() {

            @Override
            public void run() {
                Observable.unsafeCreate(new ObservableSource<Long>() {

                    @Override
                    public void subscribe(Observer<? super Long> o) {
                        o.onSubscribe(Disposable.empty());
                        System.out.println(""********* Start Source Data ***********"");
                        for (long l = 1; l <= 10000; l++) {
                            o.onNext(l);
                        }
                        System.out.println(""********* Finished Source Data ***********"");
                        o.onComplete();
                    }
                }).subscribe(replay);
            }
        });
        source.start();

        long v = replay.blockingLast();
        assertEquals(10000, v);

        // it's been played through once so now it will all be replays
        final CountDownLatch slowLatch = new CountDownLatch(1);
        Thread slowThread = new Thread(new Runnable() {

            @Override
            public void run() {
                Observer<Long> slow = new DefaultObserver<Long>() {

                    @Override
                    public void onComplete() {
                        System.out.println(""*** Slow Observer completed"");
                        slowLatch.countDown();
                    }

                    @Override
                    public void onError(Throwable e) {
                    }

                    @Override
                    public void onNext(Long args) {
                        if (args == 1) {
                            System.out.println(""*** Slow Observer STARTED"");
                        }
                        try {
                            if (args % 10 == 0) {
                                Thread.sleep(1);
                            }
                        } catch (InterruptedException e) {
                            e.printStackTrace();
                        }
                    }
                };
                replay.subscribe(slow);
                try {
                    slowLatch.await();
                } catch (InterruptedException e1) {
                    e1.printStackTrace();
                }
            }
        });
        slowThread.start();

        Thread fastThread = new Thread(new Runnable() {

            @Override
            public void run() {
                final CountDownLatch fastLatch = new CountDownLatch(1);
                Observer<Long> fast = new DefaultObserver<Long>() {

                    @Override
                    public void onComplete() {
                        System.out.println(""*** Fast Observer completed"");
                        fastLatch.countDown();
                    }

                    @Override
                    public void onError(Throwable e) {
                    }

                    @Override
                    public void onNext(Long args) {
                        if (args == 1) {
                            System.out.println(""*** Fast Observer STARTED"");
                        }
                    }
                };
                replay.subscribe(fast);
                try {
                    fastLatch.await();
                } catch (InterruptedException e1) {
                    e1.printStackTrace();
                }
            }
        });
        fastThread.start();
        fastThread.join();

        // slow should not yet be completed when fast completes
        assertEquals(1, slowLatch.getCount());

        slowThread.join();
    }",loop_control
l,"{
        final ReplaySubject<Long> replay = ReplaySubject.createUnbounded();
        Thread source = new Thread(new Runnable() {

            @Override
            public void run() {
                Observable.unsafeCreate(new ObservableSource<Long>() {

                    @Override
                    public void subscribe(Observer<? super Long> o) {
                        o.onSubscribe(Disposable.empty());
                        System.out.println(""********* Start Source Data ***********"");
                        for (long l = 1; l <= 10000; l++) {
                            o.onNext(l);
                        }
                        System.out.println(""********* Finished Source Data ***********"");
                        o.onComplete();
                    }
                }).subscribe(replay);
            }
        });

        // used to collect results of each thread
        final List<List<Long>> listOfListsOfValues = Collections.synchronizedList(new ArrayList<>());
        final List<Thread> threads = Collections.synchronizedList(new ArrayList<>());

        for (int i = 1; i <= 200; i++) {
            final int count = i;
            if (count == 20) {
                // start source data after we have some already subscribed
                // and while others are in process of subscribing
                source.start();
            }
            if (count == 100) {
                // wait for source to finish then keep adding after it's done
                source.join();
            }
            Thread t = new Thread(new Runnable() {

                @Override
                public void run() {
                    List<Long> values = replay.toList().blockingGet();
                    listOfListsOfValues.add(values);
                    System.out.println(""Finished thread: "" + count);
                }
            });
            t.start();
            System.out.println(""Started thread: "" + i);
            threads.add(t);
        }

        // wait for all threads to complete
        for (Thread t : threads) {
            t.join();
        }

        // assert all threads got the same results
        List<Long> sums = new ArrayList<>();
        for (List<Long> values : listOfListsOfValues) {
            long v = 0;
            for (long l : values) {
                v += l;
            }
            sums.add(v);
        }

        long expected = sums.get(0);
        boolean success = true;
        for (long l : sums) {
            if (l != expected) {
                success = false;
                System.out.println(""FAILURE => Expected "" + expected + "" but got: "" + l);
            }
        }

        if (success) {
            System.out.println(""Success! "" + sums.size() + "" each had the same sum of "" + expected);
        } else {
            throw new RuntimeException(""Concurrency Bug"");
        }

    }",loop_control
i,"{
        final ReplaySubject<Long> replay = ReplaySubject.createUnbounded();
        Thread source = new Thread(new Runnable() {

            @Override
            public void run() {
                Observable.unsafeCreate(new ObservableSource<Long>() {

                    @Override
                    public void subscribe(Observer<? super Long> o) {
                        o.onSubscribe(Disposable.empty());
                        System.out.println(""********* Start Source Data ***********"");
                        for (long l = 1; l <= 10000; l++) {
                            o.onNext(l);
                        }
                        System.out.println(""********* Finished Source Data ***********"");
                        o.onComplete();
                    }
                }).subscribe(replay);
            }
        });

        // used to collect results of each thread
        final List<List<Long>> listOfListsOfValues = Collections.synchronizedList(new ArrayList<>());
        final List<Thread> threads = Collections.synchronizedList(new ArrayList<>());

        for (int i = 1; i <= 200; i++) {
            final int count = i;
            if (count == 20) {
                // start source data after we have some already subscribed
                // and while others are in process of subscribing
                source.start();
            }
            if (count == 100) {
                // wait for source to finish then keep adding after it's done
                source.join();
            }
            Thread t = new Thread(new Runnable() {

                @Override
                public void run() {
                    List<Long> values = replay.toList().blockingGet();
                    listOfListsOfValues.add(values);
                    System.out.println(""Finished thread: "" + count);
                }
            });
            t.start();
            System.out.println(""Started thread: "" + i);
            threads.add(t);
        }

        // wait for all threads to complete
        for (Thread t : threads) {
            t.join();
        }

        // assert all threads got the same results
        List<Long> sums = new ArrayList<>();
        for (List<Long> values : listOfListsOfValues) {
            long v = 0;
            for (long l : values) {
                v += l;
            }
            sums.add(v);
        }

        long expected = sums.get(0);
        boolean success = true;
        for (long l : sums) {
            if (l != expected) {
                success = false;
                System.out.println(""FAILURE => Expected "" + expected + "" but got: "" + l);
            }
        }

        if (success) {
            System.out.println(""Success! "" + sums.size() + "" each had the same sum of "" + expected);
        } else {
            throw new RuntimeException(""Concurrency Bug"");
        }

    }",loop_control
t,"{
        final ReplaySubject<Long> replay = ReplaySubject.createUnbounded();
        Thread source = new Thread(new Runnable() {

            @Override
            public void run() {
                Observable.unsafeCreate(new ObservableSource<Long>() {

                    @Override
                    public void subscribe(Observer<? super Long> o) {
                        o.onSubscribe(Disposable.empty());
                        System.out.println(""********* Start Source Data ***********"");
                        for (long l = 1; l <= 10000; l++) {
                            o.onNext(l);
                        }
                        System.out.println(""********* Finished Source Data ***********"");
                        o.onComplete();
                    }
                }).subscribe(replay);
            }
        });

        // used to collect results of each thread
        final List<List<Long>> listOfListsOfValues = Collections.synchronizedList(new ArrayList<>());
        final List<Thread> threads = Collections.synchronizedList(new ArrayList<>());

        for (int i = 1; i <= 200; i++) {
            final int count = i;
            if (count == 20) {
                // start source data after we have some already subscribed
                // and while others are in process of subscribing
                source.start();
            }
            if (count == 100) {
                // wait for source to finish then keep adding after it's done
                source.join();
            }
            Thread t = new Thread(new Runnable() {

                @Override
                public void run() {
                    List<Long> values = replay.toList().blockingGet();
                    listOfListsOfValues.add(values);
                    System.out.println(""Finished thread: "" + count);
                }
            });
            t.start();
            System.out.println(""Started thread: "" + i);
            threads.add(t);
        }

        // wait for all threads to complete
        for (Thread t : threads) {
            t.join();
        }

        // assert all threads got the same results
        List<Long> sums = new ArrayList<>();
        for (List<Long> values : listOfListsOfValues) {
            long v = 0;
            for (long l : values) {
                v += l;
            }
            sums.add(v);
        }

        long expected = sums.get(0);
        boolean success = true;
        for (long l : sums) {
            if (l != expected) {
                success = false;
                System.out.println(""FAILURE => Expected "" + expected + "" but got: "" + l);
            }
        }

        if (success) {
            System.out.println(""Success! "" + sums.size() + "" each had the same sum of "" + expected);
        } else {
            throw new RuntimeException(""Concurrency Bug"");
        }

    }",iterator
values,"{
        final ReplaySubject<Long> replay = ReplaySubject.createUnbounded();
        Thread source = new Thread(new Runnable() {

            @Override
            public void run() {
                Observable.unsafeCreate(new ObservableSource<Long>() {

                    @Override
                    public void subscribe(Observer<? super Long> o) {
                        o.onSubscribe(Disposable.empty());
                        System.out.println(""********* Start Source Data ***********"");
                        for (long l = 1; l <= 10000; l++) {
                            o.onNext(l);
                        }
                        System.out.println(""********* Finished Source Data ***********"");
                        o.onComplete();
                    }
                }).subscribe(replay);
            }
        });

        // used to collect results of each thread
        final List<List<Long>> listOfListsOfValues = Collections.synchronizedList(new ArrayList<>());
        final List<Thread> threads = Collections.synchronizedList(new ArrayList<>());

        for (int i = 1; i <= 200; i++) {
            final int count = i;
            if (count == 20) {
                // start source data after we have some already subscribed
                // and while others are in process of subscribing
                source.start();
            }
            if (count == 100) {
                // wait for source to finish then keep adding after it's done
                source.join();
            }
            Thread t = new Thread(new Runnable() {

                @Override
                public void run() {
                    List<Long> values = replay.toList().blockingGet();
                    listOfListsOfValues.add(values);
                    System.out.println(""Finished thread: "" + count);
                }
            });
            t.start();
            System.out.println(""Started thread: "" + i);
            threads.add(t);
        }

        // wait for all threads to complete
        for (Thread t : threads) {
            t.join();
        }

        // assert all threads got the same results
        List<Long> sums = new ArrayList<>();
        for (List<Long> values : listOfListsOfValues) {
            long v = 0;
            for (long l : values) {
                v += l;
            }
            sums.add(v);
        }

        long expected = sums.get(0);
        boolean success = true;
        for (long l : sums) {
            if (l != expected) {
                success = false;
                System.out.println(""FAILURE => Expected "" + expected + "" but got: "" + l);
            }
        }

        if (success) {
            System.out.println(""Success! "" + sums.size() + "" each had the same sum of "" + expected);
        } else {
            throw new RuntimeException(""Concurrency Bug"");
        }

    }",iterator
i,"{
        for (int i = 0; i < 50; i++) {
            final ReplaySubject<String> subject = ReplaySubject.createUnbounded();
            final AtomicReference<String> value1 = new AtomicReference<>();

            subject.subscribe(new Consumer<String>() {

                @Override
                public void accept(String t1) {
                    try {
                        // simulate a slow observer
                        Thread.sleep(50);
                    } catch (InterruptedException e) {
                        e.printStackTrace();
                    }
                    value1.set(t1);
                }

            });

            Thread t1 = new Thread(new Runnable() {

                @Override
                public void run() {
                    subject.onNext(""value"");
                    subject.onComplete();
                }
            });

            SubjectObserverThread t2 = new SubjectObserverThread(subject);
            SubjectObserverThread t3 = new SubjectObserverThread(subject);
            SubjectObserverThread t4 = new SubjectObserverThread(subject);
            SubjectObserverThread t5 = new SubjectObserverThread(subject);

            t2.start();
            t3.start();
            t1.start();
            t4.start();
            t5.start();
            try {
                t1.join();
                t2.join();
                t3.join();
                t4.join();
                t5.join();
            } catch (InterruptedException e) {
                throw new RuntimeException(e);
            }

            assertEquals(""value"", value1.get());
            assertEquals(""value"", t2.value.get());
            assertEquals(""value"", t3.value.get());
            assertEquals(""value"", t4.value.get());
            assertEquals(""value"", t5.value.get());
        }

    }",loop_control
i,"{
        final List<Integer> expected = Arrays.asList(1);
        for (int i = 0; i < 100000; i++) {
            TestObserverEx<Integer> to = new TestObserverEx<>();
            Observable.just(1).subscribeOn(Schedulers.computation()).cache().subscribe(to);
            to.awaitDone(5, TimeUnit.SECONDS);
            to.assertValueSequence(expected);
            to.assertTerminated();
        }
    }",loop_control
i,"{
        Scheduler s = Schedulers.io();
        Scheduler.Worker worker = Schedulers.io().createWorker();
        try {
            for (int i = 0; i < 50000; i++) {
                if (i % 1000 == 0) {
                    System.out.println(i);
                }
                final ReplaySubject<Object> rs = ReplaySubject.createWithSize(2);

                final CountDownLatch finish = new CountDownLatch(1);
                final CountDownLatch start = new CountDownLatch(1);

//                int j = i;

                worker.schedule(new Runnable() {
                    @Override
                    public void run() {
                        try {
                            start.await();
                        } catch (Exception e1) {
                            e1.printStackTrace();
                        }
//                        System.out.println(""> "" + j);
                        rs.onNext(1);
                    }
                });

                final AtomicReference<Object> o = new AtomicReference<>();

                rs
//                .doOnSubscribe(v -> System.out.println(""!! "" + j))
//                .doOnNext(e -> System.out.println("">> "" + j))
                .subscribeOn(s)
                .observeOn(Schedulers.io())
//                .doOnNext(e -> System.out.println("">>> "" + j))
                .subscribe(new DefaultObserver<Object>() {

                    @Override
                    protected void onStart() {
                        super.onStart();
                    }

                    @Override
                    public void onComplete() {
                        o.set(-1);
                        finish.countDown();
                    }

                    @Override
                    public void onError(Throwable e) {
                        o.set(e);
                        finish.countDown();
                    }

                    @Override
                    public void onNext(Object t) {
                        o.set(t);
                        finish.countDown();
                    }

                });
                start.countDown();

                if (!finish.await(5, TimeUnit.SECONDS)) {
                    System.out.println(o.get());
                    System.out.println(rs.hasObservers());
                    rs.onComplete();
                    Assert.fail(""Timeout @ "" + i);
                    break;
                } else {
                    Assert.assertEquals(1, o.get());
                    worker.schedule(new Runnable() {
                        @Override
                        public void run() {
                            rs.onComplete();
                        }
                    });
                }
            }
        } finally {
            worker.dispose();
        }
    }",loop_control
finish,"{
        Scheduler s = Schedulers.io();
        Scheduler.Worker worker = Schedulers.io().createWorker();
        try {
            for (int i = 0; i < 50000; i++) {
                if (i % 1000 == 0) {
                    System.out.println(i);
                }
                final ReplaySubject<Object> rs = ReplaySubject.createWithSize(2);

                final CountDownLatch finish = new CountDownLatch(1);
                final CountDownLatch start = new CountDownLatch(1);

//                int j = i;

                worker.schedule(new Runnable() {
                    @Override
                    public void run() {
                        try {
                            start.await();
                        } catch (Exception e1) {
                            e1.printStackTrace();
                        }
//                        System.out.println(""> "" + j);
                        rs.onNext(1);
                    }
                });

                final AtomicReference<Object> o = new AtomicReference<>();

                rs
//                .doOnSubscribe(v -> System.out.println(""!! "" + j))
//                .doOnNext(e -> System.out.println("">> "" + j))
                .subscribeOn(s)
                .observeOn(Schedulers.io())
//                .doOnNext(e -> System.out.println("">>> "" + j))
                .subscribe(new DefaultObserver<Object>() {

                    @Override
                    protected void onStart() {
                        super.onStart();
                    }

                    @Override
                    public void onComplete() {
                        o.set(-1);
                        finish.countDown();
                    }

                    @Override
                    public void onError(Throwable e) {
                        o.set(e);
                        finish.countDown();
                    }

                    @Override
                    public void onNext(Object t) {
                        o.set(t);
                        finish.countDown();
                    }

                });
                start.countDown();

                if (!finish.await(5, TimeUnit.SECONDS)) {
                    System.out.println(o.get());
                    System.out.println(rs.hasObservers());
                    rs.onComplete();
                    Assert.fail(""Timeout @ "" + i);
                    break;
                } else {
                    Assert.assertEquals(1, o.get());
                    worker.schedule(new Runnable() {
                        @Override
                        public void run() {
                            rs.onComplete();
                        }
                    });
                }
            }
        } finally {
            worker.dispose();
        }
    }",break_loop_control
i,"{
        final ReplaySubject<Object> rs = ReplaySubject.createUnbounded();
        final CyclicBarrier cb = new CyclicBarrier(2);

        Thread t = new Thread(new Runnable() {
            @Override
            public void run() {
                try {
                    cb.await();
                } catch (InterruptedException e) {
                    return;
                } catch (BrokenBarrierException e) {
                    return;
                }
                for (int i = 0; i < 1000000; i++) {
                    rs.onNext(i);
                }
                rs.onComplete();
                System.out.println(""Replay fill Thread finished!"");
            }
        });
        t.start();
        try {
            cb.await();
        } catch (InterruptedException e) {
            return;
        } catch (BrokenBarrierException e) {
            return;
        }
        int lastSize = 0;
        for (; !rs.hasThrowable() && !rs.hasComplete();) {
            int size = rs.size();
            boolean hasAny = rs.hasValue();
            Object[] values = rs.getValues();
            if (size < lastSize) {
                Assert.fail(""Size decreased! "" + lastSize + "" -> "" + size);
            }
            if ((size > 0) && !hasAny) {
                Assert.fail(""hasAnyValue reports emptyness but size doesn't"");
            }
            if (size > values.length) {
                Assert.fail(""Got fewer values than size! "" + size + "" -> "" + values.length);
            }
            for (int i = 0; i < values.length - 1; i++) {
                Integer v1 = (Integer)values[i];
                Integer v2 = (Integer)values[i + 1];
                assertEquals(1, v2 - v1);
            }
            lastSize = size;
        }

        t.join();
    }",loop_control
rs,"{
        final ReplaySubject<Object> rs = ReplaySubject.createUnbounded();
        final CyclicBarrier cb = new CyclicBarrier(2);

        Thread t = new Thread(new Runnable() {
            @Override
            public void run() {
                try {
                    cb.await();
                } catch (InterruptedException e) {
                    return;
                } catch (BrokenBarrierException e) {
                    return;
                }
                for (int i = 0; i < 1000000; i++) {
                    rs.onNext(i);
                }
                rs.onComplete();
                System.out.println(""Replay fill Thread finished!"");
            }
        });
        t.start();
        try {
            cb.await();
        } catch (InterruptedException e) {
            return;
        } catch (BrokenBarrierException e) {
            return;
        }
        int lastSize = 0;
        for (; !rs.hasThrowable() && !rs.hasComplete();) {
            int size = rs.size();
            boolean hasAny = rs.hasValue();
            Object[] values = rs.getValues();
            if (size < lastSize) {
                Assert.fail(""Size decreased! "" + lastSize + "" -> "" + size);
            }
            if ((size > 0) && !hasAny) {
                Assert.fail(""hasAnyValue reports emptyness but size doesn't"");
            }
            if (size > values.length) {
                Assert.fail(""Got fewer values than size! "" + size + "" -> "" + values.length);
            }
            for (int i = 0; i < values.length - 1; i++) {
                Integer v1 = (Integer)values[i];
                Integer v2 = (Integer)values[i + 1];
                assertEquals(1, v2 - v1);
            }
            lastSize = size;
        }

        t.join();
    }",maybe_loop_control
i,"{
        final ReplaySubject<Object> rs = ReplaySubject.createWithSize(3);
        final CyclicBarrier cb = new CyclicBarrier(2);

        Thread t = new Thread(new Runnable() {
            @Override
            public void run() {
                try {
                    cb.await();
                } catch (InterruptedException e) {
                    return;
                } catch (BrokenBarrierException e) {
                    return;
                }
                for (int i = 0; i < 1000000; i++) {
                    rs.onNext(i);
                }
                rs.onComplete();
                System.out.println(""Replay fill Thread finished!"");
            }
        });
        t.start();
        try {
            cb.await();
        } catch (InterruptedException e) {
            return;
        } catch (BrokenBarrierException e) {
            return;
        }
        for (; !rs.hasThrowable() && !rs.hasComplete();) {
            rs.size(); // can't use value so just call to detect hangs
            rs.hasValue(); // can't use value so just call to detect hangs
            Object[] values = rs.getValues();
            for (int i = 0; i < values.length - 1; i++) {
                Integer v1 = (Integer)values[i];
                Integer v2 = (Integer)values[i + 1];
                assertEquals(1, v2 - v1);
            }
        }

        t.join();
    }",loop_control
rs,"{
        final ReplaySubject<Object> rs = ReplaySubject.createWithSize(3);
        final CyclicBarrier cb = new CyclicBarrier(2);

        Thread t = new Thread(new Runnable() {
            @Override
            public void run() {
                try {
                    cb.await();
                } catch (InterruptedException e) {
                    return;
                } catch (BrokenBarrierException e) {
                    return;
                }
                for (int i = 0; i < 1000000; i++) {
                    rs.onNext(i);
                }
                rs.onComplete();
                System.out.println(""Replay fill Thread finished!"");
            }
        });
        t.start();
        try {
            cb.await();
        } catch (InterruptedException e) {
            return;
        } catch (BrokenBarrierException e) {
            return;
        }
        for (; !rs.hasThrowable() && !rs.hasComplete();) {
            rs.size(); // can't use value so just call to detect hangs
            rs.hasValue(); // can't use value so just call to detect hangs
            Object[] values = rs.getValues();
            for (int i = 0; i < values.length - 1; i++) {
                Integer v1 = (Integer)values[i];
                Integer v2 = (Integer)values[i + 1];
                assertEquals(1, v2 - v1);
            }
        }

        t.join();
    }",maybe_loop_control
i,"{
        final ReplaySubject<Object> rs = ReplaySubject.createWithTime(1, TimeUnit.MILLISECONDS, Schedulers.computation());
        final CyclicBarrier cb = new CyclicBarrier(2);

        Thread t = new Thread(new Runnable() {
            @Override
            public void run() {
                try {
                    cb.await();
                } catch (InterruptedException e) {
                    return;
                } catch (BrokenBarrierException e) {
                    return;
                }
                for (int i = 0; i < 1000000; i++) {
                    rs.onNext(i);
                    if (i % 10000 == 0) {
                        try {
                            Thread.sleep(1);
                        } catch (InterruptedException e) {
                            return;
                        }
                    }
                }
                rs.onComplete();
                System.out.println(""Replay fill Thread finished!"");
            }
        });
        t.start();
        try {
            cb.await();
        } catch (InterruptedException e) {
            return;
        } catch (BrokenBarrierException e) {
            return;
        }
        for (; !rs.hasThrowable() && !rs.hasComplete();) {
            rs.size(); // can't use value so just call to detect hangs
            rs.hasValue(); // can't use value so just call to detect hangs
            Object[] values = rs.getValues();
            for (int i = 0; i < values.length - 1; i++) {
                Integer v1 = (Integer)values[i];
                Integer v2 = (Integer)values[i + 1];
                assertEquals(1, v2 - v1);
            }
        }

        t.join();
    }",loop_control
rs,"{
        final ReplaySubject<Object> rs = ReplaySubject.createWithTime(1, TimeUnit.MILLISECONDS, Schedulers.computation());
        final CyclicBarrier cb = new CyclicBarrier(2);

        Thread t = new Thread(new Runnable() {
            @Override
            public void run() {
                try {
                    cb.await();
                } catch (InterruptedException e) {
                    return;
                } catch (BrokenBarrierException e) {
                    return;
                }
                for (int i = 0; i < 1000000; i++) {
                    rs.onNext(i);
                    if (i % 10000 == 0) {
                        try {
                            Thread.sleep(1);
                        } catch (InterruptedException e) {
                            return;
                        }
                    }
                }
                rs.onComplete();
                System.out.println(""Replay fill Thread finished!"");
            }
        });
        t.start();
        try {
            cb.await();
        } catch (InterruptedException e) {
            return;
        } catch (BrokenBarrierException e) {
            return;
        }
        for (; !rs.hasThrowable() && !rs.hasComplete();) {
            rs.size(); // can't use value so just call to detect hangs
            rs.hasValue(); // can't use value so just call to detect hangs
            Object[] values = rs.getValues();
            for (int i = 0; i < values.length - 1; i++) {
                Integer v1 = (Integer)values[i];
                Integer v2 = (Integer)values[i + 1];
                assertEquals(1, v2 - v1);
            }
        }

        t.join();
    }",maybe_loop_control
l,"{
        final ReplaySubject<Long> replay = ReplaySubject.create();
        Thread source = new Thread(new Runnable() {

            @Override
            public void run() {
                Observable.unsafeCreate(new ObservableSource<Long>() {

                    @Override
                    public void subscribe(Observer<? super Long> o) {
                        o.onSubscribe(Disposable.empty());
                        System.out.println(""********* Start Source Data ***********"");
                        for (long l = 1; l <= 10000; l++) {
                            o.onNext(l);
                        }
                        System.out.println(""********* Finished Source Data ***********"");
                        o.onComplete();
                    }
                }).subscribe(replay);
            }
        });
        source.start();

        long v = replay.blockingLast();
        assertEquals(10000, v);

        // it's been played through once so now it will all be replays
        final CountDownLatch slowLatch = new CountDownLatch(1);
        Thread slowThread = new Thread(new Runnable() {

            @Override
            public void run() {
                Observer<Long> slow = new DefaultObserver<Long>() {

                    @Override
                    public void onComplete() {
                        System.out.println(""*** Slow Observer completed"");
                        slowLatch.countDown();
                    }

                    @Override
                    public void onError(Throwable e) {
                    }

                    @Override
                    public void onNext(Long args) {
                        if (args == 1) {
                            System.out.println(""*** Slow Observer STARTED"");
                        }
                        try {
                            if (args % 10 == 0) {
                                Thread.sleep(1);
                            }
                        } catch (InterruptedException e) {
                            e.printStackTrace();
                        }
                    }
                };
                replay.subscribe(slow);
                try {
                    slowLatch.await();
                } catch (InterruptedException e1) {
                    e1.printStackTrace();
                }
            }
        });
        slowThread.start();

        Thread fastThread = new Thread(new Runnable() {

            @Override
            public void run() {
                final CountDownLatch fastLatch = new CountDownLatch(1);
                Observer<Long> fast = new DefaultObserver<Long>() {

                    @Override
                    public void onComplete() {
                        System.out.println(""*** Fast Observer completed"");
                        fastLatch.countDown();
                    }

                    @Override
                    public void onError(Throwable e) {
                    }

                    @Override
                    public void onNext(Long args) {
                        if (args == 1) {
                            System.out.println(""*** Fast Observer STARTED"");
                        }
                    }
                };
                replay.subscribe(fast);
                try {
                    fastLatch.await();
                } catch (InterruptedException e1) {
                    e1.printStackTrace();
                }
            }
        });
        fastThread.start();
        fastThread.join();

        // slow should not yet be completed when fast completes
        assertEquals(1, slowLatch.getCount());

        slowThread.join();
    }",loop_control
l,"{
        final ReplaySubject<Long> replay = ReplaySubject.create();
        Thread source = new Thread(new Runnable() {

            @Override
            public void run() {
                Observable.unsafeCreate(new ObservableSource<Long>() {

                    @Override
                    public void subscribe(Observer<? super Long> o) {
                        o.onSubscribe(Disposable.empty());
                        System.out.println(""********* Start Source Data ***********"");
                        for (long l = 1; l <= 10000; l++) {
                            o.onNext(l);
                        }
                        System.out.println(""********* Finished Source Data ***********"");
                        o.onComplete();
                    }
                }).subscribe(replay);
            }
        });

        // used to collect results of each thread
        final List<List<Long>> listOfListsOfValues = Collections.synchronizedList(new ArrayList<>());
        final List<Thread> threads = Collections.synchronizedList(new ArrayList<>());

        for (int i = 1; i <= 200; i++) {
            final int count = i;
            if (count == 20) {
                // start source data after we have some already subscribed
                // and while others are in process of subscribing
                source.start();
            }
            if (count == 100) {
                // wait for source to finish then keep adding after it's done
                source.join();
            }
            Thread t = new Thread(new Runnable() {

                @Override
                public void run() {
                    List<Long> values = replay.toList().blockingGet();
                    listOfListsOfValues.add(values);
                    System.out.println(""Finished thread: "" + count);
                }
            });
            t.start();
            System.out.println(""Started thread: "" + i);
            threads.add(t);
        }

        // wait for all threads to complete
        for (Thread t : threads) {
            t.join();
        }

        // assert all threads got the same results
        List<Long> sums = new ArrayList<>();
        for (List<Long> values : listOfListsOfValues) {
            long v = 0;
            for (long l : values) {
                v += l;
            }
            sums.add(v);
        }

        long expected = sums.get(0);
        boolean success = true;
        for (long l : sums) {
            if (l != expected) {
                success = false;
                System.out.println(""FAILURE => Expected "" + expected + "" but got: "" + l);
            }
        }

        if (success) {
            System.out.println(""Success! "" + sums.size() + "" each had the same sum of "" + expected);
        } else {
            throw new RuntimeException(""Concurrency Bug"");
        }

    }",loop_control
i,"{
        final ReplaySubject<Long> replay = ReplaySubject.create();
        Thread source = new Thread(new Runnable() {

            @Override
            public void run() {
                Observable.unsafeCreate(new ObservableSource<Long>() {

                    @Override
                    public void subscribe(Observer<? super Long> o) {
                        o.onSubscribe(Disposable.empty());
                        System.out.println(""********* Start Source Data ***********"");
                        for (long l = 1; l <= 10000; l++) {
                            o.onNext(l);
                        }
                        System.out.println(""********* Finished Source Data ***********"");
                        o.onComplete();
                    }
                }).subscribe(replay);
            }
        });

        // used to collect results of each thread
        final List<List<Long>> listOfListsOfValues = Collections.synchronizedList(new ArrayList<>());
        final List<Thread> threads = Collections.synchronizedList(new ArrayList<>());

        for (int i = 1; i <= 200; i++) {
            final int count = i;
            if (count == 20) {
                // start source data after we have some already subscribed
                // and while others are in process of subscribing
                source.start();
            }
            if (count == 100) {
                // wait for source to finish then keep adding after it's done
                source.join();
            }
            Thread t = new Thread(new Runnable() {

                @Override
                public void run() {
                    List<Long> values = replay.toList().blockingGet();
                    listOfListsOfValues.add(values);
                    System.out.println(""Finished thread: "" + count);
                }
            });
            t.start();
            System.out.println(""Started thread: "" + i);
            threads.add(t);
        }

        // wait for all threads to complete
        for (Thread t : threads) {
            t.join();
        }

        // assert all threads got the same results
        List<Long> sums = new ArrayList<>();
        for (List<Long> values : listOfListsOfValues) {
            long v = 0;
            for (long l : values) {
                v += l;
            }
            sums.add(v);
        }

        long expected = sums.get(0);
        boolean success = true;
        for (long l : sums) {
            if (l != expected) {
                success = false;
                System.out.println(""FAILURE => Expected "" + expected + "" but got: "" + l);
            }
        }

        if (success) {
            System.out.println(""Success! "" + sums.size() + "" each had the same sum of "" + expected);
        } else {
            throw new RuntimeException(""Concurrency Bug"");
        }

    }",loop_control
t,"{
        final ReplaySubject<Long> replay = ReplaySubject.create();
        Thread source = new Thread(new Runnable() {

            @Override
            public void run() {
                Observable.unsafeCreate(new ObservableSource<Long>() {

                    @Override
                    public void subscribe(Observer<? super Long> o) {
                        o.onSubscribe(Disposable.empty());
                        System.out.println(""********* Start Source Data ***********"");
                        for (long l = 1; l <= 10000; l++) {
                            o.onNext(l);
                        }
                        System.out.println(""********* Finished Source Data ***********"");
                        o.onComplete();
                    }
                }).subscribe(replay);
            }
        });

        // used to collect results of each thread
        final List<List<Long>> listOfListsOfValues = Collections.synchronizedList(new ArrayList<>());
        final List<Thread> threads = Collections.synchronizedList(new ArrayList<>());

        for (int i = 1; i <= 200; i++) {
            final int count = i;
            if (count == 20) {
                // start source data after we have some already subscribed
                // and while others are in process of subscribing
                source.start();
            }
            if (count == 100) {
                // wait for source to finish then keep adding after it's done
                source.join();
            }
            Thread t = new Thread(new Runnable() {

                @Override
                public void run() {
                    List<Long> values = replay.toList().blockingGet();
                    listOfListsOfValues.add(values);
                    System.out.println(""Finished thread: "" + count);
                }
            });
            t.start();
            System.out.println(""Started thread: "" + i);
            threads.add(t);
        }

        // wait for all threads to complete
        for (Thread t : threads) {
            t.join();
        }

        // assert all threads got the same results
        List<Long> sums = new ArrayList<>();
        for (List<Long> values : listOfListsOfValues) {
            long v = 0;
            for (long l : values) {
                v += l;
            }
            sums.add(v);
        }

        long expected = sums.get(0);
        boolean success = true;
        for (long l : sums) {
            if (l != expected) {
                success = false;
                System.out.println(""FAILURE => Expected "" + expected + "" but got: "" + l);
            }
        }

        if (success) {
            System.out.println(""Success! "" + sums.size() + "" each had the same sum of "" + expected);
        } else {
            throw new RuntimeException(""Concurrency Bug"");
        }

    }",iterator
value,"{
        final ReplaySubject<Long> replay = ReplaySubject.create();
        Thread source = new Thread(new Runnable() {

            @Override
            public void run() {
                Observable.unsafeCreate(new ObservableSource<Long>() {

                    @Override
                    public void subscribe(Observer<? super Long> o) {
                        o.onSubscribe(Disposable.empty());
                        System.out.println(""********* Start Source Data ***********"");
                        for (long l = 1; l <= 10000; l++) {
                            o.onNext(l);
                        }
                        System.out.println(""********* Finished Source Data ***********"");
                        o.onComplete();
                    }
                }).subscribe(replay);
            }
        });

        // used to collect results of each thread
        final List<List<Long>> listOfListsOfValues = Collections.synchronizedList(new ArrayList<>());
        final List<Thread> threads = Collections.synchronizedList(new ArrayList<>());

        for (int i = 1; i <= 200; i++) {
            final int count = i;
            if (count == 20) {
                // start source data after we have some already subscribed
                // and while others are in process of subscribing
                source.start();
            }
            if (count == 100) {
                // wait for source to finish then keep adding after it's done
                source.join();
            }
            Thread t = new Thread(new Runnable() {

                @Override
                public void run() {
                    List<Long> values = replay.toList().blockingGet();
                    listOfListsOfValues.add(values);
                    System.out.println(""Finished thread: "" + count);
                }
            });
            t.start();
            System.out.println(""Started thread: "" + i);
            threads.add(t);
        }

        // wait for all threads to complete
        for (Thread t : threads) {
            t.join();
        }

        // assert all threads got the same results
        List<Long> sums = new ArrayList<>();
        for (List<Long> values : listOfListsOfValues) {
            long v = 0;
            for (long l : values) {
                v += l;
            }
            sums.add(v);
        }

        long expected = sums.get(0);
        boolean success = true;
        for (long l : sums) {
            if (l != expected) {
                success = false;
                System.out.println(""FAILURE => Expected "" + expected + "" but got: "" + l);
            }
        }

        if (success) {
            System.out.println(""Success! "" + sums.size() + "" each had the same sum of "" + expected);
        } else {
            throw new RuntimeException(""Concurrency Bug"");
        }

    }",iterator
i,"{
        for (int i = 0; i < 50; i++) {
            final ReplaySubject<String> subject = ReplaySubject.create();
            final AtomicReference<String> value1 = new AtomicReference<>();

            subject.subscribe(new Consumer<String>() {

                @Override
                public void accept(String t1) {
                    try {
                        // simulate a slow observer
                        Thread.sleep(50);
                    } catch (InterruptedException e) {
                        e.printStackTrace();
                    }
                    value1.set(t1);
                }

            });

            Thread t1 = new Thread(new Runnable() {

                @Override
                public void run() {
                    subject.onNext(""value"");
                    subject.onComplete();
                }
            });

            SubjectObserverThread t2 = new SubjectObserverThread(subject);
            SubjectObserverThread t3 = new SubjectObserverThread(subject);
            SubjectObserverThread t4 = new SubjectObserverThread(subject);
            SubjectObserverThread t5 = new SubjectObserverThread(subject);

            t2.start();
            t3.start();
            t1.start();
            t4.start();
            t5.start();
            try {
                t1.join();
                t2.join();
                t3.join();
                t4.join();
                t5.join();
            } catch (InterruptedException e) {
                throw new RuntimeException(e);
            }

            assertEquals(""value"", value1.get());
            assertEquals(""value"", t2.value.get());
            assertEquals(""value"", t3.value.get());
            assertEquals(""value"", t4.value.get());
            assertEquals(""value"", t5.value.get());
        }

    }",loop_control
i,"{
        final List<Integer> expected = Arrays.asList(1);
        for (int i = 0; i < 100000; i++) {
            TestObserverEx<Integer> to = new TestObserverEx<>();
            Observable.just(1).subscribeOn(Schedulers.computation()).cache().subscribe(to);
            to.awaitDone(5, TimeUnit.SECONDS);
            to.assertValueSequence(expected);
            to.assertTerminated();
        }
    }",loop_control
i,"{
        Scheduler s = Schedulers.io();
        Scheduler.Worker worker = Schedulers.io().createWorker();
        try {
            for (int i = 0; i < 50000; i++) {
                if (i % 1000 == 0) {
                    System.out.println(i);
                }
                final ReplaySubject<Object> rs = ReplaySubject.create();

                final CountDownLatch finish = new CountDownLatch(1);
                final CountDownLatch start = new CountDownLatch(1);

                worker.schedule(new Runnable() {
                    @Override
                    public void run() {
                        try {
                            start.await();
                        } catch (Exception e1) {
                            e1.printStackTrace();
                        }
                        rs.onNext(1);
                    }
                });

                final AtomicReference<Object> o = new AtomicReference<>();

                rs.subscribeOn(s).observeOn(Schedulers.io())
                .subscribe(new DefaultObserver<Object>() {

                    @Override
                    public void onComplete() {
                        o.set(-1);
                        finish.countDown();
                    }

                    @Override
                    public void onError(Throwable e) {
                        o.set(e);
                        finish.countDown();
                    }

                    @Override
                    public void onNext(Object t) {
                        o.set(t);
                        finish.countDown();
                    }

                });
                start.countDown();

                if (!finish.await(5, TimeUnit.SECONDS)) {
                    System.out.println(o.get());
                    System.out.println(rs.hasObservers());
                    rs.onComplete();
                    Assert.fail(""Timeout @ "" + i);
                    break;
                } else {
                    Assert.assertEquals(1, o.get());
                    worker.schedule(new Runnable() {
                        @Override
                        public void run() {
                            rs.onComplete();
                        }
                    });

                }
            }
        } finally {
            worker.dispose();
        }
    }",loop_control
finish,"{
        Scheduler s = Schedulers.io();
        Scheduler.Worker worker = Schedulers.io().createWorker();
        try {
            for (int i = 0; i < 50000; i++) {
                if (i % 1000 == 0) {
                    System.out.println(i);
                }
                final ReplaySubject<Object> rs = ReplaySubject.create();

                final CountDownLatch finish = new CountDownLatch(1);
                final CountDownLatch start = new CountDownLatch(1);

                worker.schedule(new Runnable() {
                    @Override
                    public void run() {
                        try {
                            start.await();
                        } catch (Exception e1) {
                            e1.printStackTrace();
                        }
                        rs.onNext(1);
                    }
                });

                final AtomicReference<Object> o = new AtomicReference<>();

                rs.subscribeOn(s).observeOn(Schedulers.io())
                .subscribe(new DefaultObserver<Object>() {

                    @Override
                    public void onComplete() {
                        o.set(-1);
                        finish.countDown();
                    }

                    @Override
                    public void onError(Throwable e) {
                        o.set(e);
                        finish.countDown();
                    }

                    @Override
                    public void onNext(Object t) {
                        o.set(t);
                        finish.countDown();
                    }

                });
                start.countDown();

                if (!finish.await(5, TimeUnit.SECONDS)) {
                    System.out.println(o.get());
                    System.out.println(rs.hasObservers());
                    rs.onComplete();
                    Assert.fail(""Timeout @ "" + i);
                    break;
                } else {
                    Assert.assertEquals(1, o.get());
                    worker.schedule(new Runnable() {
                        @Override
                        public void run() {
                            rs.onComplete();
                        }
                    });

                }
            }
        } finally {
            worker.dispose();
        }
    }",break_loop_control
i,"{
        final ReplaySubject<Object> rs = ReplaySubject.create();
        final CyclicBarrier cb = new CyclicBarrier(2);

        Thread t = new Thread(new Runnable() {
            @Override
            public void run() {
                try {
                    cb.await();
                } catch (InterruptedException e) {
                    return;
                } catch (BrokenBarrierException e) {
                    return;
                }
                for (int i = 0; i < 1000000; i++) {
                    rs.onNext(i);
                }
                rs.onComplete();
                System.out.println(""Replay fill Thread finished!"");
            }
        });
        t.start();
        try {
            cb.await();
        } catch (InterruptedException e) {
            return;
        } catch (BrokenBarrierException e) {
            return;
        }
        int lastSize = 0;
        for (; !rs.hasThrowable() && !rs.hasComplete();) {
            int size = rs.size();
            boolean hasAny = rs.hasValue();
            Object[] values = rs.getValues();
            if (size < lastSize) {
                Assert.fail(""Size decreased! "" + lastSize + "" -> "" + size);
            }
            if ((size > 0) && !hasAny) {
                Assert.fail(""hasAnyValue reports emptyness but size doesn't"");
            }
            if (size > values.length) {
                Assert.fail(""Got fewer values than size! "" + size + "" -> "" + values.length);
            }
            lastSize = size;
        }

        t.join();
    }",loop_control
rs,"{
        final ReplaySubject<Object> rs = ReplaySubject.create();
        final CyclicBarrier cb = new CyclicBarrier(2);

        Thread t = new Thread(new Runnable() {
            @Override
            public void run() {
                try {
                    cb.await();
                } catch (InterruptedException e) {
                    return;
                } catch (BrokenBarrierException e) {
                    return;
                }
                for (int i = 0; i < 1000000; i++) {
                    rs.onNext(i);
                }
                rs.onComplete();
                System.out.println(""Replay fill Thread finished!"");
            }
        });
        t.start();
        try {
            cb.await();
        } catch (InterruptedException e) {
            return;
        } catch (BrokenBarrierException e) {
            return;
        }
        int lastSize = 0;
        for (; !rs.hasThrowable() && !rs.hasComplete();) {
            int size = rs.size();
            boolean hasAny = rs.hasValue();
            Object[] values = rs.getValues();
            if (size < lastSize) {
                Assert.fail(""Size decreased! "" + lastSize + "" -> "" + size);
            }
            if ((size > 0) && !hasAny) {
                Assert.fail(""hasAnyValue reports emptyness but size doesn't"");
            }
            if (size > values.length) {
                Assert.fail(""Got fewer values than size! "" + size + "" -> "" + values.length);
            }
            lastSize = size;
        }

        t.join();
    }",maybe_loop_control
i,"{
        BehaviorSubject<String> src = BehaviorSubject.createDefault(""null""); // FIXME was plain null which is not allowed

        for (int i = 0; i < 10; i++) {
            final Observer<Object> o = TestHelper.mockObserver();
            InOrder inOrder = inOrder(o);
            String v = """" + i;
            src.onNext(v);
            System.out.printf(""Turn: %d%n"", i);
            src.firstElement()
                .toObservable()
                .flatMap(new Function<String, Observable<String>>() {

                    @Override
                    public Observable<String> apply(String t1) {
                        return Observable.just(t1 + "", "" + t1);
                    }
                })
                .subscribe(new DefaultObserver<String>() {
                    @Override
                    public void onNext(String t) {
                        o.onNext(t);
                    }

                    @Override
                    public void onError(Throwable e) {
                        o.onError(e);
                    }

                    @Override
                    public void onComplete() {
                        o.onComplete();
                    }
                });
            inOrder.verify(o).onNext(v + "", "" + v);
            inOrder.verify(o).onComplete();
            verify(o, never()).onError(any(Throwable.class));
        }
    }",loop_control
i,"{
        Scheduler s = Schedulers.io();
        Scheduler.Worker worker = Schedulers.io().createWorker();
        try {
            for (int i = 0; i < 50000; i++) {
                if (i % 1000 == 0) {
                    System.out.println(i);
                }
                final BehaviorSubject<Object> rs = BehaviorSubject.create();

                final CountDownLatch finish = new CountDownLatch(1);
                final CountDownLatch start = new CountDownLatch(1);

                worker.schedule(new Runnable() {
                    @Override
                    public void run() {
                        try {
                            start.await();
                        } catch (Exception e1) {
                            e1.printStackTrace();
                        }
                        rs.onNext(1);
                    }
                });

                final AtomicReference<Object> o = new AtomicReference<>();

                rs.subscribeOn(s).observeOn(Schedulers.io())
                .subscribe(new DefaultObserver<Object>() {

                    @Override
                    public void onComplete() {
                        o.set(-1);
                        finish.countDown();
                    }

                    @Override
                    public void onError(Throwable e) {
                        o.set(e);
                        finish.countDown();
                    }

                    @Override
                    public void onNext(Object t) {
                        o.set(t);
                        finish.countDown();
                    }

                });
                start.countDown();

                if (!finish.await(5, TimeUnit.SECONDS)) {
                    System.out.println(o.get());
                    System.out.println(rs.hasObservers());
                    rs.onComplete();
                    Assert.fail(""Timeout @ "" + i);
                    break;
                } else {
                    Assert.assertEquals(1, o.get());
                    worker.schedule(new Runnable() {
                        @Override
                        public void run() {
                            rs.onComplete();
                        }
                    });
                }
            }
        } finally {
            worker.dispose();
        }
    }",loop_control
finish,"{
        Scheduler s = Schedulers.io();
        Scheduler.Worker worker = Schedulers.io().createWorker();
        try {
            for (int i = 0; i < 50000; i++) {
                if (i % 1000 == 0) {
                    System.out.println(i);
                }
                final BehaviorSubject<Object> rs = BehaviorSubject.create();

                final CountDownLatch finish = new CountDownLatch(1);
                final CountDownLatch start = new CountDownLatch(1);

                worker.schedule(new Runnable() {
                    @Override
                    public void run() {
                        try {
                            start.await();
                        } catch (Exception e1) {
                            e1.printStackTrace();
                        }
                        rs.onNext(1);
                    }
                });

                final AtomicReference<Object> o = new AtomicReference<>();

                rs.subscribeOn(s).observeOn(Schedulers.io())
                .subscribe(new DefaultObserver<Object>() {

                    @Override
                    public void onComplete() {
                        o.set(-1);
                        finish.countDown();
                    }

                    @Override
                    public void onError(Throwable e) {
                        o.set(e);
                        finish.countDown();
                    }

                    @Override
                    public void onNext(Object t) {
                        o.set(t);
                        finish.countDown();
                    }

                });
                start.countDown();

                if (!finish.await(5, TimeUnit.SECONDS)) {
                    System.out.println(o.get());
                    System.out.println(rs.hasObservers());
                    rs.onComplete();
                    Assert.fail(""Timeout @ "" + i);
                    break;
                } else {
                    Assert.assertEquals(1, o.get());
                    worker.schedule(new Runnable() {
                        @Override
                        public void run() {
                            rs.onComplete();
                        }
                    });
                }
            }
        } finally {
            worker.dispose();
        }
    }",break_loop_control
i,"{
        for (int i = 0; i < TestHelper.RACE_DEFAULT_LOOPS; i++) {
            final BehaviorSubject<Object> p = BehaviorSubject.create();

            final TestObserver<Object> to = p.test();

            Runnable r1 = new Runnable() {
                @Override
                public void run() {
                    p.test();
                }
            };

            Runnable r2 = new Runnable() {
                @Override
                public void run() {
                    to.dispose();
                }
            };

            TestHelper.race(r1, r2);
        }
    }",loop_control
i,"{
        for (int i = 0; i < TestHelper.RACE_DEFAULT_LOOPS; i++) {
            final BehaviorSubject<Object> p = BehaviorSubject.createDefault((Object)1);

            final TestObserver[] to = { null };

            Runnable r1 = new Runnable() {
                @Override
                public void run() {
                    to[0] = p.test();
                }
            };

            Runnable r2 = new Runnable() {
                @Override
                public void run() {
                    p.onNext(2);
                }
            };

            TestHelper.race(r1, r2);

            if (to[0].values().size() == 1) {
                to[0].assertValue(2).assertNoErrors().assertNotComplete();
            } else {
                to[0].assertValues(1, 2).assertNoErrors().assertNotComplete();
            }
        }
    }",loop_control
i,"{
        for (int i = 0; i < TestHelper.RACE_DEFAULT_LOOPS; i++) {
            final BehaviorSubject<Object> p = BehaviorSubject.create();

            final TestObserver<Object> to = new TestObserver<>();

            Runnable r1 = new Runnable() {
                @Override
                public void run() {
                    p.subscribe(to);
                }
            };

            Runnable r2 = new Runnable() {
                @Override
                public void run() {
                    p.onComplete();
                }
            };

            TestHelper.race(r1, r2);

            to.assertResult();
        }
    }",loop_control
i,"{
        for (int i = 0; i < TestHelper.RACE_DEFAULT_LOOPS; i++) {
            final BehaviorSubject<Object> p = BehaviorSubject.create();

            final TestObserver<Object> to = new TestObserver<>();

            final TestException ex = new TestException();

            Runnable r1 = new Runnable() {
                @Override
                public void run() {
                    p.subscribe(to);
                }
            };

            Runnable r2 = new Runnable() {
                @Override
                public void run() {
                    p.onError(ex);
                }
            };

            TestHelper.race(r1, r2);

            to.assertFailure(TestException.class);
        }
    }",loop_control
i,"{
        for (int i = 0; i < TestHelper.RACE_LONG_LOOPS; i++) {

            BehaviorSubject<Integer> bs = BehaviorSubject.create();
            bs.onNext(1);

            TestObserver<Integer> to = new TestObserver<>();

            final BehaviorDisposable<Integer> bd = new BehaviorDisposable<>(to, bs);
            to.onSubscribe(bd);

            Runnable r1 = new Runnable() {
                @Override
                public void run() {
                    bd.emitFirst();
                }
            };
            Runnable r2 = new Runnable() {
                @Override
                public void run() {
                    bd.dispose();
                }
            };

            TestHelper.race(r1, r2);
        }
    }",loop_control
i,"{
        for (int i = 0; i < TestHelper.RACE_LONG_LOOPS; i++) {

            BehaviorSubject<Integer> bs = BehaviorSubject.create();
            bs.onNext(1);

            TestObserver<Integer> to = new TestObserver<>();

            final BehaviorDisposable<Integer> bd = new BehaviorDisposable<>(to, bs);
            to.onSubscribe(bd);

            Runnable r1 = new Runnable() {
                @Override
                public void run() {
                    bd.emitNext(2, 0);
                }
            };
            Runnable r2 = new Runnable() {
                @Override
                public void run() {
                    bd.dispose();
                }
            };

            TestHelper.race(r1, r2);
        }
    }",loop_control
i,"{
        for (int i = 0; i < TestHelper.RACE_DEFAULT_LOOPS; i++) {
            final SingleSubject<Integer> ss = SingleSubject.create();

            final TestObserver<Integer> to = ss.test();

            Runnable r1 = new Runnable() {
                @Override
                public void run() {
                    ss.test();
                }
            };

            Runnable r2 = new Runnable() {
                @Override
                public void run() {
                    to.dispose();
                }
            };
            TestHelper.race(r1, r2);
        }
    }",loop_control
i,"{
        for (int i = 0; i < TestHelper.RACE_DEFAULT_LOOPS; i++) {
            final int[] calls = { 0 };
            final UnicastSubject<Object> us = UnicastSubject.create(100, new Runnable() {
                @Override
                public void run() {
                    calls[0]++;
                }
            });

            final TestObserver<Object> to = us.test();

            Runnable r1 = new Runnable() {
                @Override
                public void run() {
                    to.dispose();
                }
            };

            Runnable r2 = new Runnable() {
                @Override
                public void run() {
                    us.onComplete();
                }
            };

            TestHelper.race(r1, r2);

            assertEquals(1, calls[0]);
        }
    }",loop_control
i,"{
        for (int i = 0; i < TestHelper.RACE_DEFAULT_LOOPS; i++) {
            final UnicastSubject<Object> p = UnicastSubject.create();

            final TestObserverEx<Object> to = new TestObserverEx<>(QueueFuseable.ANY);

            p.subscribe(to);

            Runnable r1 = new Runnable() {
                @Override
                public void run() {
                    p.onNext(1);
                }
            };

            Runnable r2 = new Runnable() {
                @Override
                public void run() {
                    to.dispose();
                }
            };

            TestHelper.race(r1, r2);
        }
    }",loop_control
i,"{
        for (int i = 0; i < TestHelper.RACE_DEFAULT_LOOPS; i++) {
            final UnicastSubject<Integer> us = UnicastSubject.create();

            final TestObserverEx<Integer> to1 = new TestObserverEx<>();
            final TestObserverEx<Integer> to2 = new TestObserverEx<>();

            Runnable r1 = new Runnable() {
                @Override
                public void run() {
                    us.subscribe(to1);
                }
            };

            Runnable r2 = new Runnable() {
                @Override
                public void run() {
                    us.subscribe(to2);
                }
            };

            TestHelper.race(r1, r2);

            if (to1.errors().size() == 0) {
                to2.assertFailure(IllegalStateException.class);
            } else
            if (to2.errors().size() == 0) {
                to1.assertFailure(IllegalStateException.class);
            } else {
                fail(""Neither TestObserver failed"");
            }
        }
    }",loop_control
j,"{
        for (int j = 0; j < TestHelper.RACE_LONG_LOOPS; j++) {
            List<Throwable> errors = TestHelper.trackPluginErrors();
            try {
                final UnicastSubject<Integer> us = UnicastSubject.create();

                TestObserver<Integer> to = us
                .observeOn(Schedulers.io())
                .map(Functions.<Integer>identity())
                .observeOn(Schedulers.single())
                .firstOrError()
                .test();

                for (int i = 0; us.hasObservers(); i++) {
                    us.onNext(i);
                }

                to.awaitDone(10, TimeUnit.SECONDS);

                if (!errors.isEmpty()) {
                    throw new CompositeException(errors);
                }

                to.assertResult(0);
            } finally {
                RxJavaPlugins.reset();
            }
        }
    }",loop_control
i,"{
        for (int j = 0; j < TestHelper.RACE_LONG_LOOPS; j++) {
            List<Throwable> errors = TestHelper.trackPluginErrors();
            try {
                final UnicastSubject<Integer> us = UnicastSubject.create();

                TestObserver<Integer> to = us
                .observeOn(Schedulers.io())
                .map(Functions.<Integer>identity())
                .observeOn(Schedulers.single())
                .firstOrError()
                .test();

                for (int i = 0; us.hasObservers(); i++) {
                    us.onNext(i);
                }

                to.awaitDone(10, TimeUnit.SECONDS);

                if (!errors.isEmpty()) {
                    throw new CompositeException(errors);
                }

                to.assertResult(0);
            } finally {
                RxJavaPlugins.reset();
            }
        }
    }",loop_control
i,"{
        UnicastSubject<Integer> us = UnicastSubject.create(16);

        TestObserver<Integer> to = us.test();

        for (int i = 0; i < 256; i++) {
            us.onNext(i);
        }
        us.onComplete();

        to.assertValueCount(256)
        .assertComplete()
        .assertNoErrors();
    }",loop_control
i,"{
        for (int i = 0; i < TestHelper.RACE_DEFAULT_LOOPS; i++) {
            final CompletableSubject cs = CompletableSubject.create();

            final TestObserver<Void> to = cs.test();

            Runnable r1 = new Runnable() {
                @Override
                public void run() {
                    cs.test();
                }
            };

            Runnable r2 = new Runnable() {
                @Override
                public void run() {
                    to.dispose();
                }
            };
            TestHelper.race(r1, r2);
        }
    }",loop_control
pp,"{
        final ReplayProcessor<Integer> pp = ReplayProcessor.createWithTime(1, TimeUnit.MINUTES, Schedulers.computation());

        Schedulers.io().scheduleDirect(new Runnable() {
            @Override
            public void run() {
                long start = System.currentTimeMillis();
                while (!pp.hasSubscribers()) {
                    try {
                        Thread.sleep(1);
                    } catch (InterruptedException ex) {
                        return;
                    }

                    if (System.currentTimeMillis() - start > 200) {
                        return;
                    }
                }

                for (int i = 0; i < elements; i++) {
                    pp.onNext(i);
                }
                pp.onComplete();
            }
        });
        return pp;
    }",maybe_loop_control
i,"{
        final ReplayProcessor<Integer> pp = ReplayProcessor.createWithTime(1, TimeUnit.MINUTES, Schedulers.computation());

        Schedulers.io().scheduleDirect(new Runnable() {
            @Override
            public void run() {
                long start = System.currentTimeMillis();
                while (!pp.hasSubscribers()) {
                    try {
                        Thread.sleep(1);
                    } catch (InterruptedException ex) {
                        return;
                    }

                    if (System.currentTimeMillis() - start > 200) {
                        return;
                    }
                }

                for (int i = 0; i < elements; i++) {
                    pp.onNext(i);
                }
                pp.onComplete();
            }
        });
        return pp;
    }",loop_control
i,"{
        final AsyncProcessor<Integer> pp = AsyncProcessor.create();

        Schedulers.io().scheduleDirect(new Runnable() {
            @Override
            public void run() {
                long start = System.currentTimeMillis();
                while (!pp.hasSubscribers()) {
                    try {
                        Thread.sleep(1);
                    } catch (InterruptedException ex) {
                        return;
                    }

                    if (System.currentTimeMillis() - start > 200) {
                        return;
                    }
                }

                for (int i = 0; i < elements; i++) {
                    pp.onNext(i);
                }
                pp.onComplete();
            }
        });
        return pp;
    }",loop_control
pp,"{
        final AsyncProcessor<Integer> pp = AsyncProcessor.create();

        Schedulers.io().scheduleDirect(new Runnable() {
            @Override
            public void run() {
                long start = System.currentTimeMillis();
                while (!pp.hasSubscribers()) {
                    try {
                        Thread.sleep(1);
                    } catch (InterruptedException ex) {
                        return;
                    }

                    if (System.currentTimeMillis() - start > 200) {
                        return;
                    }
                }

                for (int i = 0; i < elements; i++) {
                    pp.onNext(i);
                }
                pp.onComplete();
            }
        });
        return pp;
    }",maybe_loop_control
i,"{
        final MulticastProcessor<Integer> mp = MulticastProcessor.create();
        mp.start();

        Schedulers.io().scheduleDirect(new Runnable() {
            @Override
            public void run() {
                long start = System.currentTimeMillis();
                while (!mp.hasSubscribers()) {
                    try {
                        Thread.sleep(1);
                    } catch (InterruptedException ex) {
                        return;
                    }

                    if (System.currentTimeMillis() - start > 200) {
                        return;
                    }
                }

                for (int i = 0; i < elements; i++) {
                    while (!mp.offer(i)) {
                        Thread.yield();
                        if (System.currentTimeMillis() - start > 1000) {
                            return;
                        }
                    }
                }
                mp.onComplete();
            }
        });
        return mp;
    }",loop_control
mp,"{
        final MulticastProcessor<Integer> mp = MulticastProcessor.create();
        mp.start();

        Schedulers.io().scheduleDirect(new Runnable() {
            @Override
            public void run() {
                long start = System.currentTimeMillis();
                while (!mp.hasSubscribers()) {
                    try {
                        Thread.sleep(1);
                    } catch (InterruptedException ex) {
                        return;
                    }

                    if (System.currentTimeMillis() - start > 200) {
                        return;
                    }
                }

                for (int i = 0; i < elements; i++) {
                    while (!mp.offer(i)) {
                        Thread.yield();
                        if (System.currentTimeMillis() - start > 1000) {
                            return;
                        }
                    }
                }
                mp.onComplete();
            }
        });
        return mp;
    }",maybe_loop_control
i,"{
        final BehaviorProcessor<Integer> pp = BehaviorProcessor.create();

        Schedulers.io().scheduleDirect(new Runnable() {
            @Override
            public void run() {
                long start = System.currentTimeMillis();
                while (!pp.hasSubscribers()) {
                    try {
                        Thread.sleep(1);
                    } catch (InterruptedException ex) {
                        return;
                    }

                    if (System.currentTimeMillis() - start > 200) {
                        return;
                    }
                }

                for (int i = 0; i < elements; i++) {
                    while (!pp.offer(i)) {
                        Thread.yield();
                        if (System.currentTimeMillis() - start > 1000) {
                            return;
                        }
                    }
                }
                pp.onComplete();
            }
        });
        return pp;
    }",loop_control
pp,"{
        final BehaviorProcessor<Integer> pp = BehaviorProcessor.create();

        Schedulers.io().scheduleDirect(new Runnable() {
            @Override
            public void run() {
                long start = System.currentTimeMillis();
                while (!pp.hasSubscribers()) {
                    try {
                        Thread.sleep(1);
                    } catch (InterruptedException ex) {
                        return;
                    }

                    if (System.currentTimeMillis() - start > 200) {
                        return;
                    }
                }

                for (int i = 0; i < elements; i++) {
                    while (!pp.offer(i)) {
                        Thread.yield();
                        if (System.currentTimeMillis() - start > 1000) {
                            return;
                        }
                    }
                }
                pp.onComplete();
            }
        });
        return pp;
    }",maybe_loop_control
i,"{
        final ReplayProcessor<Integer> pp = ReplayProcessor.createWithSize((int)elements + 10);

        Schedulers.io().scheduleDirect(new Runnable() {
            @Override
            public void run() {
                long start = System.currentTimeMillis();
                while (!pp.hasSubscribers()) {
                    try {
                        Thread.sleep(1);
                    } catch (InterruptedException ex) {
                        return;
                    }

                    if (System.currentTimeMillis() - start > 200) {
                        return;
                    }
                }

                for (int i = 0; i < elements; i++) {
                    pp.onNext(i);
                }
                pp.onComplete();
            }
        });
        return pp;
    }",loop_control
pp,"{
        final ReplayProcessor<Integer> pp = ReplayProcessor.createWithSize((int)elements + 10);

        Schedulers.io().scheduleDirect(new Runnable() {
            @Override
            public void run() {
                long start = System.currentTimeMillis();
                while (!pp.hasSubscribers()) {
                    try {
                        Thread.sleep(1);
                    } catch (InterruptedException ex) {
                        return;
                    }

                    if (System.currentTimeMillis() - start > 200) {
                        return;
                    }
                }

                for (int i = 0; i < elements; i++) {
                    pp.onNext(i);
                }
                pp.onComplete();
            }
        });
        return pp;
    }",maybe_loop_control
a,"{
        for (;;) {
            RefCountSubscriber<T>[] a = subscribers.get();
            if (a == TERMINATED) {
                return false;
            }
            int n = a.length;
            @SuppressWarnings(""unchecked"")
            RefCountSubscriber<T>[] b = new RefCountSubscriber[n + 1];
            System.arraycopy(a, 0, b, 0, n);
            b[n] = rcs;
            if (subscribers.compareAndSet(a, b)) {
                return true;
            }
        }
    }",break_loop_control
subscribers,"{
        for (;;) {
            RefCountSubscriber<T>[] a = subscribers.get();
            if (a == TERMINATED) {
                return false;
            }
            int n = a.length;
            @SuppressWarnings(""unchecked"")
            RefCountSubscriber<T>[] b = new RefCountSubscriber[n + 1];
            System.arraycopy(a, 0, b, 0, n);
            b[n] = rcs;
            if (subscribers.compareAndSet(a, b)) {
                return true;
            }
        }
    }",break_loop_control
n,"{
        for (;;) {
            RefCountSubscriber<T>[] a = subscribers.get();
            int n = a.length;
            if (n == 0) {
                break;
            }
            int j = -1;

            for (int i = 0; i < n; i++) {
                if (rcs == a[i]) {
                    j = i;
                    break;
                }
            }

            if (j < 0) {
                break;
            }

            RefCountSubscriber<T>[] b;
            if (n == 1) {
                b = TERMINATED;
            } else {
                b = new RefCountSubscriber[n - 1];
                System.arraycopy(a, 0, b, 0, j);
                System.arraycopy(a, j + 1, b, j, n - j - 1);
            }
            if (subscribers.compareAndSet(a, b)) {
                if (b == TERMINATED) {
                    cancel();
                }
                break;
            }
        }
    }",break_loop_control
i,"{
        for (;;) {
            RefCountSubscriber<T>[] a = subscribers.get();
            int n = a.length;
            if (n == 0) {
                break;
            }
            int j = -1;

            for (int i = 0; i < n; i++) {
                if (rcs == a[i]) {
                    j = i;
                    break;
                }
            }

            if (j < 0) {
                break;
            }

            RefCountSubscriber<T>[] b;
            if (n == 1) {
                b = TERMINATED;
            } else {
                b = new RefCountSubscriber[n - 1];
                System.arraycopy(a, 0, b, 0, j);
                System.arraycopy(a, j + 1, b, j, n - j - 1);
            }
            if (subscribers.compareAndSet(a, b)) {
                if (b == TERMINATED) {
                    cancel();
                }
                break;
            }
        }
    }",loop_control
rcs,"{
        for (;;) {
            RefCountSubscriber<T>[] a = subscribers.get();
            int n = a.length;
            if (n == 0) {
                break;
            }
            int j = -1;

            for (int i = 0; i < n; i++) {
                if (rcs == a[i]) {
                    j = i;
                    break;
                }
            }

            if (j < 0) {
                break;
            }

            RefCountSubscriber<T>[] b;
            if (n == 1) {
                b = TERMINATED;
            } else {
                b = new RefCountSubscriber[n - 1];
                System.arraycopy(a, 0, b, 0, j);
                System.arraycopy(a, j + 1, b, j, n - j - 1);
            }
            if (subscribers.compareAndSet(a, b)) {
                if (b == TERMINATED) {
                    cancel();
                }
                break;
            }
        }
    }",break_loop_control
j,"{
        for (;;) {
            RefCountSubscriber<T>[] a = subscribers.get();
            int n = a.length;
            if (n == 0) {
                break;
            }
            int j = -1;

            for (int i = 0; i < n; i++) {
                if (rcs == a[i]) {
                    j = i;
                    break;
                }
            }

            if (j < 0) {
                break;
            }

            RefCountSubscriber<T>[] b;
            if (n == 1) {
                b = TERMINATED;
            } else {
                b = new RefCountSubscriber[n - 1];
                System.arraycopy(a, 0, b, 0, j);
                System.arraycopy(a, j + 1, b, j, n - j - 1);
            }
            if (subscribers.compareAndSet(a, b)) {
                if (b == TERMINATED) {
                    cancel();
                }
                break;
            }
        }
    }",break_loop_control
subscribers,"{
        for (;;) {
            RefCountSubscriber<T>[] a = subscribers.get();
            int n = a.length;
            if (n == 0) {
                break;
            }
            int j = -1;

            for (int i = 0; i < n; i++) {
                if (rcs == a[i]) {
                    j = i;
                    break;
                }
            }

            if (j < 0) {
                break;
            }

            RefCountSubscriber<T>[] b;
            if (n == 1) {
                b = TERMINATED;
            } else {
                b = new RefCountSubscriber[n - 1];
                System.arraycopy(a, 0, b, 0, j);
                System.arraycopy(a, j + 1, b, j, n - j - 1);
            }
            if (subscribers.compareAndSet(a, b)) {
                if (b == TERMINATED) {
                    cancel();
                }
                break;
            }
        }
    }",break_loop_control
i,"{
        Long[] a = new Long[(int)elements];
        for (int i = 0; i < elements; i++) {
            a[i] = (long)i;
        }
        return a;
    }",loop_control
i,"{
        return
            Flowable.create(new FlowableOnSubscribe<Long>() {
                @Override
                public void subscribe(FlowableEmitter<Long> e) throws Exception {
                    for (long i = 0; i < elements && !e.isCancelled(); i++) {
                        e.onNext(i);
                    }
                    e.onComplete();
                }
            }, BackpressureStrategy.BUFFER)
        ;
    }",loop_control
e,"{
        return
            Flowable.create(new FlowableOnSubscribe<Long>() {
                @Override
                public void subscribe(FlowableEmitter<Long> e) throws Exception {
                    for (long i = 0; i < elements && !e.isCancelled(); i++) {
                        e.onNext(i);
                    }
                    e.onComplete();
                }
            }, BackpressureStrategy.BUFFER)
        ;
    }",maybe_loop_control
pp,"{
        final PublishProcessor<Integer> pp = PublishProcessor.create();

        Schedulers.io().scheduleDirect(new Runnable() {
            @Override
            public void run() {
                long start = System.currentTimeMillis();
                while (!pp.hasSubscribers()) {
                    try {
                        Thread.sleep(1);
                    } catch (InterruptedException ex) {
                        return;
                    }

                    if (System.currentTimeMillis() - start > 200) {
                        return;
                    }
                }

                for (int i = 0; i < elements; i++) {
                    while (!pp.offer(i)) {
                        Thread.yield();
                        if (System.currentTimeMillis() - start > 1000) {
                            return;
                        }
                    }
                }
                pp.onComplete();
            }
        });
        return pp;
    }",maybe_loop_control
i,"{
        final PublishProcessor<Integer> pp = PublishProcessor.create();

        Schedulers.io().scheduleDirect(new Runnable() {
            @Override
            public void run() {
                long start = System.currentTimeMillis();
                while (!pp.hasSubscribers()) {
                    try {
                        Thread.sleep(1);
                    } catch (InterruptedException ex) {
                        return;
                    }

                    if (System.currentTimeMillis() - start > 200) {
                        return;
                    }
                }

                for (int i = 0; i < elements; i++) {
                    while (!pp.offer(i)) {
                        Thread.yield();
                        if (System.currentTimeMillis() - start > 1000) {
                            return;
                        }
                    }
                }
                pp.onComplete();
            }
        });
        return pp;
    }",loop_control
i,"{
        final UnicastProcessor<Integer> pp = UnicastProcessor.create();

        Schedulers.io().scheduleDirect(new Runnable() {
            @Override
            public void run() {
                long start = System.currentTimeMillis();
                while (!pp.hasSubscribers()) {
                    try {
                        Thread.sleep(1);
                    } catch (InterruptedException ex) {
                        return;
                    }

                    if (System.currentTimeMillis() - start > 200) {
                        return;
                    }
                }

                for (int i = 0; i < elements; i++) {
                    pp.onNext(i);
                }
                pp.onComplete();
            }
        });
        return pp;
    }",loop_control
pp,"{
        final UnicastProcessor<Integer> pp = UnicastProcessor.create();

        Schedulers.io().scheduleDirect(new Runnable() {
            @Override
            public void run() {
                long start = System.currentTimeMillis();
                while (!pp.hasSubscribers()) {
                    try {
                        Thread.sleep(1);
                    } catch (InterruptedException ex) {
                        return;
                    }

                    if (System.currentTimeMillis() - start > 200) {
                        return;
                    }
                }

                for (int i = 0; i < elements; i++) {
                    pp.onNext(i);
                }
                pp.onComplete();
            }
        });
        return pp;
    }",maybe_loop_control
pp,"{
        final ReplayProcessor<Integer> pp = ReplayProcessor.create();

        Schedulers.io().scheduleDirect(new Runnable() {
            @Override
            public void run() {
                long start = System.currentTimeMillis();
                while (!pp.hasSubscribers()) {
                    try {
                        Thread.sleep(1);
                    } catch (InterruptedException ex) {
                        return;
                    }

                    if (System.currentTimeMillis() - start > 200) {
                        return;
                    }
                }

                for (int i = 0; i < elements; i++) {
                    pp.onNext(i);
                }
                pp.onComplete();
            }
        });
        return pp;
    }",maybe_loop_control
i,"{
        final ReplayProcessor<Integer> pp = ReplayProcessor.create();

        Schedulers.io().scheduleDirect(new Runnable() {
            @Override
            public void run() {
                long start = System.currentTimeMillis();
                while (!pp.hasSubscribers()) {
                    try {
                        Thread.sleep(1);
                    } catch (InterruptedException ex) {
                        return;
                    }

                    if (System.currentTimeMillis() - start > 200) {
                        return;
                    }
                }

                for (int i = 0; i < elements; i++) {
                    pp.onNext(i);
                }
                pp.onComplete();
            }
        });
        return pp;
    }",loop_control
old,"{
        @Override
        public Flowable<Movie> apply(List<List<Movie>> listOfLists) {
            if (listOfLists.size() == 1) {
                return Flowable.fromIterable(listOfLists.get(0));
            } else {
                // diff the two
                List<Movie> newList = listOfLists.get(1);
                List<Movie> oldList = new ArrayList<>(listOfLists.get(0));

                Set<Movie> delta = new LinkedHashSet<>();
                delta.addAll(newList);
                // remove all that match in old
                delta.removeAll(oldList);

                // filter oldList to those that aren't in the newList
                oldList.removeAll(newList);

                // for all left in the oldList we'll create DROP events
                for (@SuppressWarnings(""unused"") Movie old : oldList) {
                    delta.add(new Movie());
                }

                return Flowable.fromIterable(delta);
            }
        }
    }",iterator
i,"{
        for (int i = 0; i < 500; i++) {
            if (i % 10 == 0) {
                System.out.println(""testMergeAsyncThenObserveOnLoop >> "" + i);
            }
            // Verify there is no MissingBackpressureException
            int num = (int) (Flowable.bufferSize() * 4.1);
            AtomicInteger c1 = new AtomicInteger();
            AtomicInteger c2 = new AtomicInteger();

            TestSubscriber<Integer> ts = new TestSubscriber<>();
            Flowable<Integer> merged = Flowable.merge(
                    incrementingIntegers(c1).subscribeOn(Schedulers.computation()),
                    incrementingIntegers(c2).subscribeOn(Schedulers.computation()));

            merged
            .observeOn(Schedulers.io())
            .take(num)
            .subscribe(ts);

            ts.awaitDone(5, TimeUnit.SECONDS);
            ts.assertComplete();
            ts.assertNoErrors();
            System.out.println(""testMergeAsyncThenObserveOn => Received: "" + ts.values().size() + ""  Emitted: "" + c1.get() + "" / "" + c2.get());
            assertEquals(num, ts.values().size());
        }
    }",loop_control
i,"{
        // in a loop for repeating the concurrency in this to increase chance of failure
        for (int i = 0; i < 100; i++) {
            int num = (int) (Flowable.bufferSize() * 2.1);
            AtomicInteger c = new AtomicInteger();
            ConcurrentLinkedQueue<Thread> threads = new ConcurrentLinkedQueue<>();
            TestSubscriber<Integer> ts = new TestSubscriber<>();
            // observeOn is there to make it async and need backpressure
            incrementingIntegers(c, threads).subscribeOn(Schedulers.computation()).observeOn(Schedulers.computation()).take(num).subscribe(ts);
            ts.awaitDone(5, TimeUnit.SECONDS);
            ts.assertNoErrors();
            System.out.println(""testSubscribeOnScheduling => Received: "" + ts.values().size() + ""  Emitted: "" + c.get());
            assertEquals(num, ts.values().size());
            assertTrue(c.get() < Flowable.bufferSize() * 4);
            Thread first = null;
            for (Thread t : threads) {
                System.out.println(""testSubscribeOnScheduling => thread: "" + t);
                if (first == null) {
                    first = t;
                } else {
                    if (!first.equals(t)) {
                        fail(""Expected to see the same thread"");
                    }
                }
            }
            System.out.println(""testSubscribeOnScheduling => Number of batch requests seen: "" + threads.size());
            assertTrue(threads.size() > 1);
            System.out.println(""-------------------------------------------------------------------------------------------"");
        }
    }",loop_control
t,"{
        // in a loop for repeating the concurrency in this to increase chance of failure
        for (int i = 0; i < 100; i++) {
            int num = (int) (Flowable.bufferSize() * 2.1);
            AtomicInteger c = new AtomicInteger();
            ConcurrentLinkedQueue<Thread> threads = new ConcurrentLinkedQueue<>();
            TestSubscriber<Integer> ts = new TestSubscriber<>();
            // observeOn is there to make it async and need backpressure
            incrementingIntegers(c, threads).subscribeOn(Schedulers.computation()).observeOn(Schedulers.computation()).take(num).subscribe(ts);
            ts.awaitDone(5, TimeUnit.SECONDS);
            ts.assertNoErrors();
            System.out.println(""testSubscribeOnScheduling => Received: "" + ts.values().size() + ""  Emitted: "" + c.get());
            assertEquals(num, ts.values().size());
            assertTrue(c.get() < Flowable.bufferSize() * 4);
            Thread first = null;
            for (Thread t : threads) {
                System.out.println(""testSubscribeOnScheduling => thread: "" + t);
                if (first == null) {
                    first = t;
                } else {
                    if (!first.equals(t)) {
                        fail(""Expected to see the same thread"");
                    }
                }
            }
            System.out.println(""testSubscribeOnScheduling => Number of batch requests seen: "" + threads.size());
            assertTrue(threads.size() > 1);
            System.out.println(""-------------------------------------------------------------------------------------------"");
        }
    }",iterator
i,"{
        for (int i = 0; i < 100; i++) {
            firehoseFailsAsExpected();
        }
    }",loop_control
i,"{
        long t = System.currentTimeMillis();
        for (int i = 0; i < 100; i++) {
            // stop the test if we are getting close to the timeout because slow machines
            // may not get through 100 iterations
            if (System.currentTimeMillis() - t > TimeUnit.SECONDS.toMillis(9)) {
                break;
            }
            int num = (int) (Flowable.bufferSize() * 1.1); // > 1 so that take doesn't prevent buffer overflow
            AtomicInteger c = new AtomicInteger();
            TestSubscriber<Integer> ts = new TestSubscriber<>();
            firehose(c).onBackpressureDrop()
            .observeOn(Schedulers.computation())
            .map(SLOW_PASS_THRU).take(num).subscribe(ts);
            ts.awaitDone(5, TimeUnit.SECONDS);
            ts.assertNoErrors();

            List<Integer> onNextEvents = ts.values();
            assertEquals(num, onNextEvents.size());

            Integer lastEvent = onNextEvents.get(num - 1);

            System.out.println(""testOnBackpressureDrop => Received: "" + onNextEvents.size() + ""  Emitted: "" + c.get() + "" Last value: "" + lastEvent);
            // it drop, so we should get some number far higher than what would have sequentially incremented
            assertTrue(num - 1 <= lastEvent.intValue());
        }
    }",loop_control
i,"{
        for (int i = 0; i < 100; i++) {
            final AtomicInteger emitCount = new AtomicInteger();
            final AtomicInteger dropCount = new AtomicInteger();
            final AtomicInteger passCount = new AtomicInteger();
            final int num = Flowable.bufferSize() * 3; // > 1 so that take doesn't prevent buffer overflow
            TestSubscriber<Integer> ts = new TestSubscriber<>();

            firehose(emitCount)
            .onBackpressureDrop(new Consumer<Integer>() {
                @Override
                public void accept(Integer v) {
                    dropCount.incrementAndGet();
                }
            })
            .doOnNext(new Consumer<Integer>() {
                @Override
                public void accept(Integer v) {
                    passCount.incrementAndGet();
                }
            })
            .observeOn(Schedulers.computation())
            .map(SLOW_PASS_THRU)
            .take(num).subscribe(ts);

            ts.awaitDone(5, TimeUnit.SECONDS);
            ts.assertNoErrors();

            List<Integer> onNextEvents = ts.values();
            Integer lastEvent = onNextEvents.get(num - 1);
            System.out.println(testName.getMethodName() + "" => Received: "" + onNextEvents.size() + "" Passed: "" + passCount.get() + "" Dropped: "" + dropCount.get() + ""  Emitted: "" + emitCount.get() + "" Last value: "" + lastEvent);
            assertEquals(num, onNextEvents.size());
            // in reality, num < passCount
            assertTrue(num <= passCount.get());
            // it drop, so we should get some number far higher than what would have sequentially incremented
            assertTrue(num - 1 <= lastEvent.intValue());
            assertTrue(0 < dropCount.get());
            assertEquals(emitCount.get(), passCount.get() + dropCount.get());
        }
    }",loop_control
i,"{
        for (int i = 0; i < 100; i++) {
            int num = (int) (Flowable.bufferSize() * 1.1); // > 1 so that take doesn't prevent buffer overflow
            AtomicInteger c = new AtomicInteger();
            TestSubscriber<Integer> ts = new TestSubscriber<>();
            firehose(c).onBackpressureDrop()
            .map(SLOW_PASS_THRU).take(num).subscribe(ts);
            ts.awaitDone(5, TimeUnit.SECONDS);
            ts.assertNoErrors();

            List<Integer> onNextEvents = ts.values();
            assertEquals(num, onNextEvents.size());

            Integer lastEvent = onNextEvents.get(num - 1);

            System.out.println(""testOnBackpressureDrop => Received: "" + onNextEvents.size() + ""  Emitted: "" + c.get() + "" Last value: "" + lastEvent);
            // it drop, so we should get some number far higher than what would have sequentially incremented
            assertTrue(num - 1 <= lastEvent.intValue());
        }
    }",loop_control
i,"{
        for (int i = 0; i < 100; i++) {
            final AtomicInteger dropCount = new AtomicInteger();
            int num = (int) (Flowable.bufferSize() * 1.1); // > 1 so that take doesn't prevent buffer overflow
            AtomicInteger c = new AtomicInteger();
            TestSubscriber<Integer> ts = new TestSubscriber<>();
            firehose(c).onBackpressureDrop(new Consumer<Integer>() {
                @Override
                public void accept(Integer j) {
                    dropCount.incrementAndGet();
                }
            })
            .map(SLOW_PASS_THRU).take(num).subscribe(ts);
            ts.awaitDone(5, TimeUnit.SECONDS);
            ts.assertNoErrors();

            List<Integer> onNextEvents = ts.values();
            assertEquals(num, onNextEvents.size());

            Integer lastEvent = onNextEvents.get(num - 1);

            System.out.println(""testOnBackpressureDrop => Received: "" + onNextEvents.size() + "" Dropped: "" + dropCount.get() + ""  Emitted: "" + c.get() + "" Last value: "" + lastEvent);
            // it drop, so we should get some number far higher than what would have sequentially incremented
            assertTrue(num - 1 <= lastEvent.intValue());
            // no drop in synchronous mode
            assertEquals(0, dropCount.get());
            assertEquals(c.get(), onNextEvents.size());
        }
    }",loop_control
cancelled,"{
        return Flowable.unsafeCreate(new Publisher<Integer>() {

            @Override
            public void subscribe(final Subscriber<? super Integer> s) {
                s.onSubscribe(new Subscription() {
                    int i;

                    volatile boolean cancelled;

                    final AtomicLong requested = new AtomicLong();

                    @Override
                    public void request(long n) {
                        if (!SubscriptionHelper.validate(n)) {
                            return;
                        }
                        if (threadsSeen != null) {
                            threadsSeen.offer(Thread.currentThread());
                        }
                        long c = BackpressureHelper.add(requested, n);
                        if (c == 0) {
                            while (!cancelled) {
                                counter.incrementAndGet();
                                s.onNext(i++);
                                if (requested.decrementAndGet() == 0) {
                                    // we're done emitting the number requested so return
                                    return;
                                }
                            }
                        }
                    }

                    @Override
                    public void cancel() {
                        cancelled = true;
                    }
                });
            }

        });
    }",maybe_loop_control
requested,"{
        return Flowable.unsafeCreate(new Publisher<Integer>() {

            @Override
            public void subscribe(final Subscriber<? super Integer> s) {
                s.onSubscribe(new Subscription() {
                    int i;

                    volatile boolean cancelled;

                    final AtomicLong requested = new AtomicLong();

                    @Override
                    public void request(long n) {
                        if (!SubscriptionHelper.validate(n)) {
                            return;
                        }
                        if (threadsSeen != null) {
                            threadsSeen.offer(Thread.currentThread());
                        }
                        long c = BackpressureHelper.add(requested, n);
                        if (c == 0) {
                            while (!cancelled) {
                                counter.incrementAndGet();
                                s.onNext(i++);
                                if (requested.decrementAndGet() == 0) {
                                    // we're done emitting the number requested so return
                                    return;
                                }
                            }
                        }
                    }

                    @Override
                    public void cancel() {
                        cancelled = true;
                    }
                });
            }

        });
    }",break_loop_control
i,"{
        volatile int sink;
        @Override
        public Integer apply(Integer t1) {
            // be slow ... but faster than Thread.sleep(1)
            String t = """";
            int s = sink;
            for (int i = 2000; i >= 0; i--) {
                t = String.valueOf(i + t.hashCode() + s);
            }
            sink = t.hashCode();
            return t1;
        }

    }",loop_control
isFinished,"{
        final AtomicReference<Throwable> thrown = new AtomicReference<>(null);
        final AtomicBoolean isFinished = new AtomicBoolean(false);
        ConcurrentLinkedQueue<? extends Integer> queue = Flowable.range(0, 5)
                .flatMap(new Function<Integer, Publisher<Integer>>() {
                    @Override
                    public Publisher<Integer> apply(final Integer i) {
                        return Flowable.range(0, 5)
                                .observeOn(Schedulers.io())
                                .map(new Function<Integer, Integer>() {
                                    @Override
                                    public Integer apply(Integer k) {
                                        try {
                                            Thread.sleep(System.currentTimeMillis() % 100);
                                        } catch (InterruptedException e) {
                                            e.printStackTrace();
                                        }
                                        return i + k;
                                    }
                                });
                    }
                })
                    .to(new FlowableConverter<Integer, ConcurrentLinkedQueue<Integer>>() {
                        @Override
                        public ConcurrentLinkedQueue<Integer> apply(Flowable<Integer> onSubscribe) {
                            final ConcurrentLinkedQueue<Integer> q = new ConcurrentLinkedQueue<>();
                            onSubscribe.subscribe(new DefaultSubscriber<Integer>() {
                                @Override
                                public void onComplete() {
                                    isFinished.set(true);
                                }

                                @Override
                                public void onError(Throwable e) {
                                    thrown.set(e);
                                }

                                @Override
                                public void onNext(Integer t) {
                                    q.add(t);
                                }});
                            return q;
                        }
                    });

        int x = 0;
        while (!isFinished.get()) {
            Integer i = queue.poll();
            if (i != null) {
                x++;
                System.out.println(x + "" item: "" + i);
            }
        }
        Assert.assertNull(thrown.get());
    }",maybe_loop_control
item,"{

    final List<T> items;
    final Throwable error;

    Burst(Throwable error, List<T> items) {
        if (items.isEmpty()) {
            throw new IllegalArgumentException(""items cannot be empty"");
        }
        for (T item : items) {
            if (item == null) {
                throw new IllegalArgumentException(""items cannot include null"");
            }
        }
        this.error = error;
        this.items = items;
    }

    @Override
    protected void subscribeActual(final Subscriber<? super T> subscriber) {
        subscriber.onSubscribe(new BurstSubscription(subscriber));

    }

    public static <T> Builder<T> item(T item) {
        return items(item);
    }

    @SafeVarargs
    public static <T> Builder<T> items(T... items) {
        return new Builder<>(Arrays.asList(items));
    }

    final class BurstSubscription implements Subscription {
        private final Subscriber<? super T> subscriber;
        final Queue<T> q = new ConcurrentLinkedQueue<>(items);
        final AtomicLong requested = new AtomicLong();
        volatile boolean cancelled;

        BurstSubscription(Subscriber<? super T> subscriber) {
            this.subscriber = subscriber;
        }

        @Override
        public void request(long n) {
            if (cancelled) {
                // required by reactive-streams-jvm 3.6
                return;
            }
            if (SubscriptionHelper.validate(n)) {
                // just for testing, don't care about perf
                // so no attempt made to reduce volatile reads
                if (BackpressureHelper.add(requested, n) == 0) {
                    if (q.isEmpty()) {
                        return;
                    }
                    while (!q.isEmpty() && requested.get() > 0) {
                        T item = q.poll();
                        requested.decrementAndGet();
                        subscriber.onNext(item);
                    }
                    if (q.isEmpty()) {
                        if (error != null) {
                            subscriber.onError(error);
                        } else {
                            subscriber.onComplete();
                        }
                    }
                }
            }
        }

        @Override
        public void cancel() {
            cancelled = true;
        }
    }

    public static final class Builder<T> {

        private final List<T> items;
        private Throwable error;

        Builder(List<T> items) {
            this.items = items;
        }

        public Flowable<T> error(Throwable e) {
            this.error = e;
            return create();
        }

        public Flowable<T> create() {
            return new Burst<>(error, items);
        }

    }

}",iterator
q,"{

    final List<T> items;
    final Throwable error;

    Burst(Throwable error, List<T> items) {
        if (items.isEmpty()) {
            throw new IllegalArgumentException(""items cannot be empty"");
        }
        for (T item : items) {
            if (item == null) {
                throw new IllegalArgumentException(""items cannot include null"");
            }
        }
        this.error = error;
        this.items = items;
    }

    @Override
    protected void subscribeActual(final Subscriber<? super T> subscriber) {
        subscriber.onSubscribe(new BurstSubscription(subscriber));

    }

    public static <T> Builder<T> item(T item) {
        return items(item);
    }

    @SafeVarargs
    public static <T> Builder<T> items(T... items) {
        return new Builder<>(Arrays.asList(items));
    }

    final class BurstSubscription implements Subscription {
        private final Subscriber<? super T> subscriber;
        final Queue<T> q = new ConcurrentLinkedQueue<>(items);
        final AtomicLong requested = new AtomicLong();
        volatile boolean cancelled;

        BurstSubscription(Subscriber<? super T> subscriber) {
            this.subscriber = subscriber;
        }

        @Override
        public void request(long n) {
            if (cancelled) {
                // required by reactive-streams-jvm 3.6
                return;
            }
            if (SubscriptionHelper.validate(n)) {
                // just for testing, don't care about perf
                // so no attempt made to reduce volatile reads
                if (BackpressureHelper.add(requested, n) == 0) {
                    if (q.isEmpty()) {
                        return;
                    }
                    while (!q.isEmpty() && requested.get() > 0) {
                        T item = q.poll();
                        requested.decrementAndGet();
                        subscriber.onNext(item);
                    }
                    if (q.isEmpty()) {
                        if (error != null) {
                            subscriber.onError(error);
                        } else {
                            subscriber.onComplete();
                        }
                    }
                }
            }
        }

        @Override
        public void cancel() {
            cancelled = true;
        }
    }

    public static final class Builder<T> {

        private final List<T> items;
        private Throwable error;

        Builder(List<T> items) {
            this.items = items;
        }

        public Flowable<T> error(Throwable e) {
            this.error = e;
            return create();
        }

        public Flowable<T> create() {
            return new Burst<>(error, items);
        }

    }

}",maybe_loop_control
requested,"{

    final List<T> items;
    final Throwable error;

    Burst(Throwable error, List<T> items) {
        if (items.isEmpty()) {
            throw new IllegalArgumentException(""items cannot be empty"");
        }
        for (T item : items) {
            if (item == null) {
                throw new IllegalArgumentException(""items cannot include null"");
            }
        }
        this.error = error;
        this.items = items;
    }

    @Override
    protected void subscribeActual(final Subscriber<? super T> subscriber) {
        subscriber.onSubscribe(new BurstSubscription(subscriber));

    }

    public static <T> Builder<T> item(T item) {
        return items(item);
    }

    @SafeVarargs
    public static <T> Builder<T> items(T... items) {
        return new Builder<>(Arrays.asList(items));
    }

    final class BurstSubscription implements Subscription {
        private final Subscriber<? super T> subscriber;
        final Queue<T> q = new ConcurrentLinkedQueue<>(items);
        final AtomicLong requested = new AtomicLong();
        volatile boolean cancelled;

        BurstSubscription(Subscriber<? super T> subscriber) {
            this.subscriber = subscriber;
        }

        @Override
        public void request(long n) {
            if (cancelled) {
                // required by reactive-streams-jvm 3.6
                return;
            }
            if (SubscriptionHelper.validate(n)) {
                // just for testing, don't care about perf
                // so no attempt made to reduce volatile reads
                if (BackpressureHelper.add(requested, n) == 0) {
                    if (q.isEmpty()) {
                        return;
                    }
                    while (!q.isEmpty() && requested.get() > 0) {
                        T item = q.poll();
                        requested.decrementAndGet();
                        subscriber.onNext(item);
                    }
                    if (q.isEmpty()) {
                        if (error != null) {
                            subscriber.onError(error);
                        } else {
                            subscriber.onComplete();
                        }
                    }
                }
            }
        }

        @Override
        public void cancel() {
            cancelled = true;
        }
    }

    public static final class Builder<T> {

        private final List<T> items;
        private Throwable error;

        Builder(List<T> items) {
            this.items = items;
        }

        public Flowable<T> error(Throwable e) {
            this.error = e;
            return create();
        }

        public Flowable<T> create() {
            return new Burst<>(error, items);
        }

    }

}",maybe_loop_control
argCount,"{
        @SuppressWarnings(""rawtypes"")
        Class<Flowable> clazz = Flowable.class;
        for (int argCount = 1; argCount < 10; argCount++) {
            for (int argNull = 1; argNull <= argCount; argNull++) {
                Class<?>[] params = new Class[argCount];
                Arrays.fill(params, Object.class);

                Object[] values = new Object[argCount];
                Arrays.fill(values, 1);
                values[argNull - 1] = null;

                Method m = clazz.getMethod(""just"", params);

                try {
                    m.invoke(null, values);
                    Assert.fail(""No exception for argCount "" + argCount + "" / argNull "" + argNull);
                } catch (InvocationTargetException ex) {
                    if (!(ex.getCause() instanceof NullPointerException)) {
                        Assert.fail(""Unexpected exception for argCount "" + argCount + "" / argNull "" + argNull + "": "" + ex);
                    }
                }
            }
        }
    }",loop_control
argNull,"{
        @SuppressWarnings(""rawtypes"")
        Class<Flowable> clazz = Flowable.class;
        for (int argCount = 1; argCount < 10; argCount++) {
            for (int argNull = 1; argNull <= argCount; argNull++) {
                Class<?>[] params = new Class[argCount];
                Arrays.fill(params, Object.class);

                Object[] values = new Object[argCount];
                Arrays.fill(values, 1);
                values[argNull - 1] = null;

                Method m = clazz.getMethod(""just"", params);

                try {
                    m.invoke(null, values);
                    Assert.fail(""No exception for argCount "" + argCount + "" / argNull "" + argNull);
                } catch (InvocationTargetException ex) {
                    if (!(ex.getCause() instanceof NullPointerException)) {
                        Assert.fail(""Unexpected exception for argCount "" + argCount + "" / argNull "" + argNull + "": "" + ex);
                    }
                }
            }
        }
    }",loop_control
i,"{
        final int expectedCount = 3;
        final AtomicInteger count = new AtomicInteger();
        for (int i = 0; i < expectedCount; i++) {
            Flowable
                    .just(Boolean.TRUE, Boolean.FALSE)
                    .takeWhile(new Predicate<Boolean>() {
                        @Override
                        public boolean test(Boolean v) {
                            return v;
                        }
                    })
                    .toList()
                    .doOnSuccess(new Consumer<List<Boolean>>() {
                        @Override
                        public void accept(List<Boolean> booleans) {
                            count.incrementAndGet();
                        }
                    })
                    .subscribe();
        }
        assertEquals(expectedCount, count.get());
    }",loop_control
i,"{
        final List<Flowable<Integer>> flowables = Arrays.asList(Flowable.just(1, 2, 3), Flowable.just(1, 2, 3));
        Flowable.zip(flowables, new Function<Object[], Object>() {
            @Override
            public Object apply(Object[] o) throws Exception {
                int sum = 0;
                for (Object i : o) {
                    sum += (Integer) i;
                }
                return sum;
            }
        }).test().assertResult(2, 4, 6);
    }",iterator
i,"{
        final List<Flowable<Integer>> flowables = Arrays.asList(Flowable.just(1, 2, 3), Flowable.just(1, 2, 3));
        Flowable.combineLatest(flowables, new Function<Object[], Object>() {
            @Override
            public Object apply(final Object[] o) throws Exception {
                int sum = 1;
                for (Object i : o) {
                    sum *= (Integer) i;
                }
                return sum;
            }
        }).test().assertResult(3, 6, 9);
    }",iterator
i,"{
        ReplayProcessor<String> src = ReplayProcessor.create();

        for (int i = 0; i < 10; i++) {
            final Subscriber<Object> subscriber = TestHelper.mockSubscriber();
            InOrder inOrder = inOrder(subscriber);
            String v = """" + i;
            src.onNext(v);
            System.out.printf(""Turn: %d%n"", i);
            src.firstElement().toFlowable()
                .flatMap(new Function<String, Flowable<String>>() {

                    @Override
                    public Flowable<String> apply(String t1) {
                        return Flowable.just(t1 + "", "" + t1);
                    }
                })
                .subscribe(new DefaultSubscriber<String>() {
                    @Override
                    public void onNext(String t) {
                        System.out.println(t);
                        subscriber.onNext(t);
                    }

                    @Override
                    public void onError(Throwable e) {
                        subscriber.onError(e);
                    }

                    @Override
                    public void onComplete() {
                        subscriber.onComplete();
                    }
                });
            inOrder.verify(subscriber).onNext(""0, 0"");
            inOrder.verify(subscriber).onComplete();
            verify(subscriber, never()).onError(any(Throwable.class));
        }
    }",loop_control
i,"{
        ReplayProcessor<Integer> source = ReplayProcessor.createWithSize(1);

        source.onNext(1);
        source.onNext(2);
        source.onComplete();

        for (int i = 0; i < 1; i++) {
            Subscriber<Integer> subscriber = TestHelper.mockSubscriber();

            source.subscribe(subscriber);

            verify(subscriber, never()).onNext(1);
            verify(subscriber).onNext(2);
            verify(subscriber).onComplete();
            verify(subscriber, never()).onError(any(Throwable.class));
        }
    }",loop_control
i,"{
        ReplayProcessor<Object> rs = ReplayProcessor.createWithSize(1);

        assertEquals(0, rs.size());
        assertFalse(rs.hasValue());

        for (int i = 0; i < 1000; i++) {
            rs.onNext(i);

            assertEquals(1, rs.size());
            assertTrue(rs.hasValue());
        }

        rs.onComplete();

        assertEquals(1, rs.size());
        assertTrue(rs.hasValue());
    }",loop_control
i,"{
        TestScheduler ts = new TestScheduler();
        ReplayProcessor<Object> rs = ReplayProcessor.createWithTime(1, TimeUnit.SECONDS, ts);

        assertEquals(0, rs.size());
        assertFalse(rs.hasValue());

        for (int i = 0; i < 1000; i++) {
            rs.onNext(i);
            assertEquals(1, rs.size());
            assertTrue(rs.hasValue());
            ts.advanceTimeBy(2, TimeUnit.SECONDS);
            assertEquals(0, rs.size());
            assertFalse(rs.hasValue());
        }

        rs.onComplete();

        assertEquals(0, rs.size());
        assertFalse(rs.hasValue());
    }",loop_control
i,"{
        ReplayProcessor<Object> rs = ReplayProcessor.create();
        Object[] expected = new Object[10];
        for (int i = 0; i < expected.length; i++) {
            expected[i] = i;
            rs.onNext(i);
            assertArrayEquals(Arrays.copyOf(expected, i + 1), rs.getValues());
        }
        rs.onComplete();

        assertArrayEquals(expected, rs.getValues());

    }",loop_control
i,"{
        ReplayProcessor<Object> rs = ReplayProcessor.createUnbounded();
        Object[] expected = new Object[10];
        for (int i = 0; i < expected.length; i++) {
            expected[i] = i;
            rs.onNext(i);
            assertArrayEquals(Arrays.copyOf(expected, i + 1), rs.getValues());
        }
        rs.onComplete();

        assertArrayEquals(expected, rs.getValues());

    }",loop_control
i,"{
        ReplayProcessor<Integer> rp = ReplayProcessor.create(8);

        for (int i = 0; i < 15; i++) {
            rp.onNext(i);
        }
        rp.onComplete();

        rp.test().assertResult(0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14);
    }",loop_control
i,"{
        for (int i = 0; i < TestHelper.RACE_DEFAULT_LOOPS; i++) {
            final TestSubscriber<Integer> ts = new TestSubscriber<>();

            final ReplayProcessor<Integer> rp = ReplayProcessor.create();

            Runnable r1 = new Runnable() {
                @Override
                public void run() {
                    rp.subscribe(ts);
                }
            };

            Runnable r2 = new Runnable() {
                @Override
                public void run() {
                    ts.cancel();
                }
            };

            TestHelper.race(r1, r2);
        }
    }",loop_control
i,"{
        for (int i = 0; i < TestHelper.RACE_DEFAULT_LOOPS; i++) {
            final ReplayProcessor<Integer> rp = ReplayProcessor.create();

            Runnable r1 = new Runnable() {
                @Override
                public void run() {
                    rp.test();
                }
            };

            TestHelper.race(r1, r1);
        }
    }",loop_control
i,"{
        for (int i = 0; i < TestHelper.RACE_DEFAULT_LOOPS; i++) {

            final ReplayProcessor<Integer> rp = ReplayProcessor.create();
            final TestSubscriber<Integer> ts1 = rp.test();
            final TestSubscriber<Integer> ts2 = rp.test();

            Runnable r1 = new Runnable() {
                @Override
                public void run() {
                    ts1.cancel();
                }
            };

            Runnable r2 = new Runnable() {
                @Override
                public void run() {
                    ts2.cancel();
                }
            };

            TestHelper.race(r1, r2);

            assertFalse(rp.hasSubscribers());
        }
    }",loop_control
i,"{
        for (int i = 0; i < TestHelper.RACE_DEFAULT_LOOPS; i++) {

            final ReplayProcessor<Integer> rp = ReplayProcessor.createWithTimeAndSize(1, TimeUnit.DAYS, Schedulers.single(), 2);
            final TestSubscriber<Integer> ts = rp.test(0L);

            Runnable r1 = new Runnable() {
                @Override
                public void run() {
                    ts.request(1);
                }
            };

            Runnable r2 = new Runnable() {
                @Override
                public void run() {
                    rp.onNext(1);
                }
            };

            TestHelper.race(r1, r2);
        }
    }",loop_control
i,"{
        for (int i = 0; i < TestHelper.RACE_LONG_LOOPS; i++) {
            final ReplayProcessor<Integer> source = ReplayProcessor.create();

            final TestSubscriber<Integer> ts = source.test(0);

            Runnable r1 = new Runnable() {
                @Override
                public void run() {
                    source.onComplete();
                }
            };

            Runnable r2 = new Runnable() {
                @Override
                public void run() {
                    ts.request(1);
                }
            };

            TestHelper.race(r1, r2);

            ts.assertResult();
        }
    }",loop_control
i,"{
        for (int i = 0; i < TestHelper.RACE_LONG_LOOPS; i++) {
            final ReplayProcessor<Integer> source = ReplayProcessor.createWithSize(10);

            final TestSubscriber<Integer> ts = source.test(0);

            Runnable r1 = new Runnable() {
                @Override
                public void run() {
                    source.onComplete();
                }
            };

            Runnable r2 = new Runnable() {
                @Override
                public void run() {
                    ts.request(1);
                }
            };

            TestHelper.race(r1, r2);

            ts.assertResult();
        }
    }",loop_control
i,"{
        for (int i = 0; i < TestHelper.RACE_LONG_LOOPS; i++) {
            final ReplayProcessor<Integer> source = ReplayProcessor.createWithTime(2, TimeUnit.HOURS, Schedulers.single());

            final TestSubscriber<Integer> ts = source.test(0);

            Runnable r1 = new Runnable() {
                @Override
                public void run() {
                    source.onComplete();
                }
            };

            Runnable r2 = new Runnable() {
                @Override
                public void run() {
                    ts.request(1);
                }
            };

            TestHelper.race(r1, r2);

            ts.assertResult();
        }
    }",loop_control
i,"{
        for (int i = 0; i < TestHelper.RACE_LONG_LOOPS; i++) {
            final ReplayProcessor<Integer> source = ReplayProcessor.createWithTimeAndSize(2, TimeUnit.HOURS, Schedulers.single(), 100);

            final TestSubscriber<Integer> ts = source.test(0);

            Runnable r1 = new Runnable() {
                @Override
                public void run() {
                    source.onComplete();
                }
            };

            Runnable r2 = new Runnable() {
                @Override
                public void run() {
                    ts.request(1);
                }
            };

            TestHelper.race(r1, r2);

            ts.assertResult();
        }
    }",loop_control
i,"{
        Set<Integer> expectedSet = new HashSet<>(Arrays.asList(1, 2));

        for (int i = 0; i < TestHelper.RACE_DEFAULT_LOOPS; i++) {
            final FlowableProcessor<Integer> s = PublishProcessor.<Integer>create().toSerialized();

            TestSubscriberEx<Integer> ts = s.to(TestHelper.<Integer>testConsumer());

            Runnable r1 = new Runnable() {
                @Override
                public void run() {
                    s.onNext(1);
                }
            };

            Runnable r2 = new Runnable() {
                @Override
                public void run() {
                    s.onNext(2);
                }
            };

            TestHelper.race(r1, r2);

            ts.assertSubscribed()
            .assertNoErrors()
            .assertNotComplete()
            .assertValueCount(2)
            ;

            Set<Integer> actualSet = new HashSet<>(ts.values());
            assertEquals("""" + actualSet, expectedSet, actualSet);
        }
    }",loop_control
i,"{
        for (int i = 0; i < TestHelper.RACE_DEFAULT_LOOPS; i++) {
            final FlowableProcessor<Integer> s = PublishProcessor.<Integer>create().toSerialized();

            TestSubscriber<Integer> ts = s.test();

            final TestException ex = new TestException();

            Runnable r1 = new Runnable() {
                @Override
                public void run() {
                    s.onNext(1);
                }
            };

            Runnable r2 = new Runnable() {
                @Override
                public void run() {
                    s.onError(ex);
                }
            };

            TestHelper.race(r1, r2);

            ts.assertError(ex).assertNotComplete();

            if (ts.values().size() != 0) {
                ts.assertValue(1);
            }
        }
    }",loop_control
i,"{
        for (int i = 0; i < TestHelper.RACE_DEFAULT_LOOPS; i++) {
            final FlowableProcessor<Integer> s = PublishProcessor.<Integer>create().toSerialized();

            TestSubscriber<Integer> ts = s.test();

            Runnable r1 = new Runnable() {
                @Override
                public void run() {
                    s.onNext(1);
                }
            };

            Runnable r2 = new Runnable() {
                @Override
                public void run() {
                    s.onComplete();
                }
            };

            TestHelper.race(r1, r2);

            ts.assertComplete().assertNoErrors();

            if (ts.values().size() != 0) {
                ts.assertValue(1);
            }
        }
    }",loop_control
i,"{
        for (int i = 0; i < TestHelper.RACE_DEFAULT_LOOPS; i++) {
            final FlowableProcessor<Integer> s = PublishProcessor.<Integer>create().toSerialized();

            TestSubscriber<Integer> ts = s.test();

            final BooleanSubscription bs = new BooleanSubscription();

            Runnable r1 = new Runnable() {
                @Override
                public void run() {
                    s.onNext(1);
                }
            };

            Runnable r2 = new Runnable() {
                @Override
                public void run() {
                    s.onSubscribe(bs);
                }
            };

            TestHelper.race(r1, r2);

            ts.assertValue(1).assertNotComplete().assertNoErrors();
        }
    }",loop_control
i,"{
        for (int i = 0; i < TestHelper.RACE_DEFAULT_LOOPS; i++) {
            final FlowableProcessor<Integer> s = PublishProcessor.<Integer>create().toSerialized();

            TestSubscriber<Integer> ts = s.test();

            final BooleanSubscription bs = new BooleanSubscription();

            Runnable r1 = new Runnable() {
                @Override
                public void run() {
                    s.onComplete();
                }
            };

            Runnable r2 = new Runnable() {
                @Override
                public void run() {
                    s.onSubscribe(bs);
                }
            };

            TestHelper.race(r1, r2);

            ts.assertResult();
        }
    }",loop_control
i,"{
        for (int i = 0; i < TestHelper.RACE_DEFAULT_LOOPS; i++) {
            final FlowableProcessor<Integer> s = PublishProcessor.<Integer>create().toSerialized();

            TestSubscriber<Integer> ts = s.test();

            Runnable r1 = new Runnable() {
                @Override
                public void run() {
                    s.onComplete();
                }
            };

            Runnable r2 = new Runnable() {
                @Override
                public void run() {
                    s.onComplete();
                }
            };

            TestHelper.race(r1, r2);

            ts.assertResult();
        }
    }",loop_control
i,"{
        for (int i = 0; i < TestHelper.RACE_DEFAULT_LOOPS; i++) {
            final FlowableProcessor<Integer> s = PublishProcessor.<Integer>create().toSerialized();

            TestSubscriber<Integer> ts = s.test();

            final TestException ex = new TestException();

            List<Throwable> errors = TestHelper.trackPluginErrors();
            try {
                Runnable r1 = new Runnable() {
                    @Override
                    public void run() {
                        s.onError(ex);
                    }
                };

                Runnable r2 = new Runnable() {
                    @Override
                    public void run() {
                        s.onError(ex);
                    }
                };

                TestHelper.race(r1, r2);

                ts.assertFailure(TestException.class);

                TestHelper.assertUndeliverable(errors, 0, TestException.class);
            } finally {
                RxJavaPlugins.reset();
            }
        }
    }",loop_control
i,"{
        for (int i = 0; i < TestHelper.RACE_DEFAULT_LOOPS; i++) {
            final FlowableProcessor<Integer> s = PublishProcessor.<Integer>create().toSerialized();

            TestSubscriber<Integer> ts = s.test();

            final BooleanSubscription bs1 = new BooleanSubscription();
            final BooleanSubscription bs2 = new BooleanSubscription();

            Runnable r1 = new Runnable() {
                @Override
                public void run() {
                    s.onSubscribe(bs1);
                }
            };

            Runnable r2 = new Runnable() {
                @Override
                public void run() {
                    s.onSubscribe(bs2);
                }
            };

            TestHelper.race(r1, r2);

            ts.assertEmpty();
        }
    }",loop_control
i,"{
        MulticastProcessor<Integer> mp = MulticastProcessor.create(16, false);
        mp.start();

        for (int i = 0; i < 10; i++) {
            mp.onNext(i);
        }
        mp.onComplete();

        mp.test(0)
        .assertEmpty()
        .requestMore(1)
        .assertValuesOnly(0)
        .requestMore(2)
        .assertValuesOnly(0, 1, 2)
        .requestMore(3)
        .assertValuesOnly(0, 1, 2, 3, 4, 5)
        .requestMore(4)
        .assertResult(0, 1, 2, 3, 4, 5, 6, 7, 8, 9);
    }",loop_control
i,"{
        MulticastProcessor<Integer> mp = MulticastProcessor.create(4, false);
        mp.startUnbounded();

        for (int i = 0; i < 10; i++) {
            assertTrue(mp.offer(i));
        }
        mp.onComplete();

        mp.test().assertResult(0, 1, 2, 3, 4, 5, 6, 7, 8, 9);
    }",loop_control
i,"{
        UnicastProcessor<Integer> up = UnicastProcessor.create();
        MulticastProcessor<Integer> mp = MulticastProcessor.create(4);

        up.subscribe(mp);

        TestSubscriber<Integer> ts = mp.test();

        for (int i = 0; i < 10; i++) {
            up.onNext(i);
        }

        try {
            mp.offer(10);
            fail(""Should have thrown IllegalStateException"");
        } catch (IllegalStateException expected) {
            // expected
        }

        up.onComplete();

        ts.assertResult(0, 1, 2, 3, 4, 5, 6, 7, 8, 9);
    }",loop_control
i,"{
        for (int i = 0; i < TestHelper.RACE_LONG_LOOPS; i++) {
            final MulticastProcessor<Integer> mp = MulticastProcessor.create();

            final TestSubscriber<Integer> ts = mp.test();
            final TestSubscriber<Integer> ts2 = new TestSubscriber<>();

            Runnable r1 = new Runnable() {
                @Override
                public void run() {
                    ts.cancel();
                }
            };

            Runnable r2 = new Runnable() {
                @Override
                public void run() {
                    mp.subscribe(ts2);
                }
            };

            TestHelper.race(r1, r2);

            assertTrue(mp.hasSubscribers());
        }
    }",loop_control
i,"{
        for (int i = 0; i < TestHelper.RACE_LONG_LOOPS; i++) {
            final MulticastProcessor<Integer> mp = MulticastProcessor.create();

            mp.test();
            final TestSubscriber<Integer> ts = mp.test();
            final TestSubscriber<Integer> ts2 = new TestSubscriber<>();

            Runnable r1 = new Runnable() {
                @Override
                public void run() {
                    ts.cancel();
                }
            };

            Runnable r2 = new Runnable() {
                @Override
                public void run() {
                    mp.subscribe(ts2);
                }
            };

            TestHelper.race(r1, r2);

            assertTrue(mp.hasSubscribers());
        }
    }",loop_control
i,"{
        for (int i = 0; i < TestHelper.RACE_LONG_LOOPS; i++) {
            final MulticastProcessor<Integer> mp = MulticastProcessor.create(true);

            final TestSubscriber<Integer> ts = mp.test();
            final TestSubscriber<Integer> ts2 = new TestSubscriber<>();

            Runnable r1 = new Runnable() {
                @Override
                public void run() {
                    ts.cancel();
                }
            };

            Runnable r2 = new Runnable() {
                @Override
                public void run() {
                    mp.subscribe(ts2);
                }
            };

            TestHelper.race(r1, r2);
        }
    }",loop_control
i,"{
        for (int i = 0; i < TestHelper.RACE_LONG_LOOPS; i++) {
            final MulticastProcessor<Integer> mp = MulticastProcessor.create(true);
            mp.startUnbounded();
            mp.onNext(1);
            mp.onNext(2);

            final TestSubscriber<Integer> ts = mp.test();

            Runnable r1 = new Runnable() {
                @Override
                public void run() {
                    ts.request(1);
                }
            };

            Runnable r2 = new Runnable() {
                @Override
                public void run() {
                    ts.request(1);
                }
            };

            TestHelper.race(r1, r2);

            ts.assertValuesOnly(1, 2);
        }
    }",loop_control
i,"{
        for (int i = 0; i < TestHelper.RACE_LONG_LOOPS; i++) {
            final MulticastProcessor<Integer> mp = MulticastProcessor.create(true);

            final Flowable<Integer> source = Flowable.range(1, 5);

            final TestSubscriber<Integer> ts = mp.test();

            Runnable r1 = new Runnable() {
                @Override
                public void run() {
                    ts.request(5);
                }
            };

            Runnable r2 = new Runnable() {
                @Override
                public void run() {
                    source.subscribe(mp);
                }
            };

            TestHelper.race(r1, r2);

            ts
            .awaitDone(5, TimeUnit.SECONDS)
            .assertResult(1, 2, 3, 4, 5);
        }
    }",loop_control
i,"{
        for (int i = 0; i < TestHelper.RACE_LONG_LOOPS; i++) {
            final MulticastProcessor<Integer> mp = MulticastProcessor.create(true);
            mp.startUnbounded();

            final TestSubscriber<Integer> ts = mp.test();

            Runnable r1 = new Runnable() {
                @Override
                public void run() {
                    ts.cancel();
                }
            };

            Runnable r2 = new Runnable() {
                @Override
                public void run() {
                    mp.onNext(1);
                }
            };

            TestHelper.race(r1, r2);
        }
    }",loop_control
i,"{
        for (int i = 0; i < TestHelper.RACE_LONG_LOOPS; i++) {
            final MulticastProcessor<Integer> mp = MulticastProcessor.create(true);

            final TestSubscriber<Integer> ts1 = mp.test();
            final TestSubscriber<Integer> ts2 = mp.test();

            mp.test();

            Runnable r1 = new Runnable() {
                @Override
                public void run() {
                    ts1.cancel();
                }
            };

            Runnable r2 = new Runnable() {
                @Override
                public void run() {
                    ts2.cancel();
                }
            };

            TestHelper.race(r1, r2);
        }
    }",loop_control
i,"{
        for (int i = 0; i < TestHelper.RACE_LONG_LOOPS; i++) {
            final MulticastProcessor<Integer> mp = MulticastProcessor.create(true);

            final TestSubscriber<Integer> ts1 = mp.test();

            Runnable r1 = new Runnable() {
                @Override
                public void run() {
                    ts1.cancel();
                }
            };

            Runnable r2 = new Runnable() {
                @Override
                public void run() {
                    ts1.request(1);
                }
            };

            TestHelper.race(r1, r2);
        }
    }",loop_control
j,"{
        for (int j = 1; j < 12; j++) {
            MulticastProcessor<Integer> mp = MulticastProcessor.create(j, true);

            TestSubscriber<Integer> ts = mp.test(0).withTag(""Prefetch: "" + j);

            Flowable.range(1, 10).hide().subscribe(mp);

            ts.assertEmpty()
            .requestMore(3)
            .assertValuesOnly(1, 2, 3)
            .requestMore(3)
            .assertValuesOnly(1, 2, 3, 4, 5, 6)
            .requestMore(4)
            .assertResult(1, 2, 3, 4, 5, 6, 7, 8, 9, 10);
        }
    }",loop_control
j,"{
        for (int j = 1; j < 12; j++) {
            MulticastProcessor<Integer> mp = MulticastProcessor.create(j, true);

            TestSubscriber<Integer> ts = mp.test(0).withTag(""Prefetch: "" + j);

            Flowable.range(1, 10).hide().subscribe(mp);

            ts.assertEmpty()
            .requestMore(2)
            .assertValuesOnly(1, 2)
            .requestMore(2)
            .assertValuesOnly(1, 2, 3, 4)
            .requestMore(6)
            .assertResult(1, 2, 3, 4, 5, 6, 7, 8, 9, 10);
        }
    }",loop_control
l,"{
        final ReplayProcessor<Long> replay = ReplayProcessor.createUnbounded();
        Thread source = new Thread(new Runnable() {

            @Override
            public void run() {
                Flowable.unsafeCreate(new Publisher<Long>() {

                    @Override
                    public void subscribe(Subscriber<? super Long> subscriber) {
                        System.out.println(""********* Start Source Data ***********"");
                        for (long l = 1; l <= 10000; l++) {
                            subscriber.onNext(l);
                        }
                        System.out.println(""********* Finished Source Data ***********"");
                        subscriber.onComplete();
                    }
                }).subscribe(replay);
            }
        });
        source.start();

        long v = replay.blockingLast();
        assertEquals(10000, v);

        // it's been played through once so now it will all be replays
        final CountDownLatch slowLatch = new CountDownLatch(1);
        Thread slowThread = new Thread(new Runnable() {

            @Override
            public void run() {
                Subscriber<Long> slow = new DefaultSubscriber<Long>() {

                    @Override
                    public void onComplete() {
                        System.out.println(""*** Slow Observer completed"");
                        slowLatch.countDown();
                    }

                    @Override
                    public void onError(Throwable e) {
                    }

                    @Override
                    public void onNext(Long args) {
                        if (args == 1) {
                            System.out.println(""*** Slow Observer STARTED"");
                        }
                        try {
                            if (args % 10 == 0) {
                                Thread.sleep(1);
                            }
                        } catch (InterruptedException e) {
                            e.printStackTrace();
                        }
                    }
                };
                replay.subscribe(slow);
                try {
                    slowLatch.await();
                } catch (InterruptedException e1) {
                    e1.printStackTrace();
                }
            }
        });
        slowThread.start();

        Thread fastThread = new Thread(new Runnable() {

            @Override
            public void run() {
                final CountDownLatch fastLatch = new CountDownLatch(1);
                Subscriber<Long> fast = new DefaultSubscriber<Long>() {

                    @Override
                    public void onComplete() {
                        System.out.println(""*** Fast Observer completed"");
                        fastLatch.countDown();
                    }

                    @Override
                    public void onError(Throwable e) {
                    }

                    @Override
                    public void onNext(Long args) {
                        if (args == 1) {
                            System.out.println(""*** Fast Observer STARTED"");
                        }
                    }
                };
                replay.subscribe(fast);
                try {
                    fastLatch.await();
                } catch (InterruptedException e1) {
                    e1.printStackTrace();
                }
            }
        });
        fastThread.start();
        fastThread.join();

        // slow should not yet be completed when fast completes
        assertEquals(1, slowLatch.getCount());

        slowThread.join();
    }",loop_control
l,"{
        final ReplayProcessor<Long> replay = ReplayProcessor.createUnbounded();
        Thread source = new Thread(new Runnable() {

            @Override
            public void run() {
                Flowable.unsafeCreate(new Publisher<Long>() {

                    @Override
                    public void subscribe(Subscriber<? super Long> subscriber) {
                        System.out.println(""********* Start Source Data ***********"");
                        for (long l = 1; l <= 10000; l++) {
                            subscriber.onNext(l);
                        }
                        System.out.println(""********* Finished Source Data ***********"");
                        subscriber.onComplete();
                    }
                }).subscribe(replay);
            }
        });

        // used to collect results of each thread
        final List<List<Long>> listOfListsOfValues = Collections.synchronizedList(new ArrayList<>());
        final List<Thread> threads = Collections.synchronizedList(new ArrayList<>());

        for (int i = 1; i <= 200; i++) {
            final int count = i;
            if (count == 20) {
                // start source data after we have some already subscribed
                // and while others are in process of subscribing
                source.start();
            }
            if (count == 100) {
                // wait for source to finish then keep adding after it's done
                source.join();
            }
            Thread t = new Thread(new Runnable() {

                @Override
                public void run() {
                    List<Long> values = replay.toList().blockingGet();
                    listOfListsOfValues.add(values);
                    System.out.println(""Finished thread: "" + count);
                }
            });
            t.start();
            System.out.println(""Started thread: "" + i);
            threads.add(t);
        }

        // wait for all threads to complete
        for (Thread t : threads) {
            t.join();
        }

        // assert all threads got the same results
        List<Long> sums = new ArrayList<>();
        for (List<Long> values : listOfListsOfValues) {
            long v = 0;
            for (long l : values) {
                v += l;
            }
            sums.add(v);
        }

        long expected = sums.get(0);
        boolean success = true;
        for (long l : sums) {
            if (l != expected) {
                success = false;
                System.out.println(""FAILURE => Expected "" + expected + "" but got: "" + l);
            }
        }

        if (success) {
            System.out.println(""Success! "" + sums.size() + "" each had the same sum of "" + expected);
        } else {
            throw new RuntimeException(""Concurrency Bug"");
        }

    }",loop_control
t,"{
        final ReplayProcessor<Long> replay = ReplayProcessor.createUnbounded();
        Thread source = new Thread(new Runnable() {

            @Override
            public void run() {
                Flowable.unsafeCreate(new Publisher<Long>() {

                    @Override
                    public void subscribe(Subscriber<? super Long> subscriber) {
                        System.out.println(""********* Start Source Data ***********"");
                        for (long l = 1; l <= 10000; l++) {
                            subscriber.onNext(l);
                        }
                        System.out.println(""********* Finished Source Data ***********"");
                        subscriber.onComplete();
                    }
                }).subscribe(replay);
            }
        });

        // used to collect results of each thread
        final List<List<Long>> listOfListsOfValues = Collections.synchronizedList(new ArrayList<>());
        final List<Thread> threads = Collections.synchronizedList(new ArrayList<>());

        for (int i = 1; i <= 200; i++) {
            final int count = i;
            if (count == 20) {
                // start source data after we have some already subscribed
                // and while others are in process of subscribing
                source.start();
            }
            if (count == 100) {
                // wait for source to finish then keep adding after it's done
                source.join();
            }
            Thread t = new Thread(new Runnable() {

                @Override
                public void run() {
                    List<Long> values = replay.toList().blockingGet();
                    listOfListsOfValues.add(values);
                    System.out.println(""Finished thread: "" + count);
                }
            });
            t.start();
            System.out.println(""Started thread: "" + i);
            threads.add(t);
        }

        // wait for all threads to complete
        for (Thread t : threads) {
            t.join();
        }

        // assert all threads got the same results
        List<Long> sums = new ArrayList<>();
        for (List<Long> values : listOfListsOfValues) {
            long v = 0;
            for (long l : values) {
                v += l;
            }
            sums.add(v);
        }

        long expected = sums.get(0);
        boolean success = true;
        for (long l : sums) {
            if (l != expected) {
                success = false;
                System.out.println(""FAILURE => Expected "" + expected + "" but got: "" + l);
            }
        }

        if (success) {
            System.out.println(""Success! "" + sums.size() + "" each had the same sum of "" + expected);
        } else {
            throw new RuntimeException(""Concurrency Bug"");
        }

    }",iterator
i,"{
        final ReplayProcessor<Long> replay = ReplayProcessor.createUnbounded();
        Thread source = new Thread(new Runnable() {

            @Override
            public void run() {
                Flowable.unsafeCreate(new Publisher<Long>() {

                    @Override
                    public void subscribe(Subscriber<? super Long> subscriber) {
                        System.out.println(""********* Start Source Data ***********"");
                        for (long l = 1; l <= 10000; l++) {
                            subscriber.onNext(l);
                        }
                        System.out.println(""********* Finished Source Data ***********"");
                        subscriber.onComplete();
                    }
                }).subscribe(replay);
            }
        });

        // used to collect results of each thread
        final List<List<Long>> listOfListsOfValues = Collections.synchronizedList(new ArrayList<>());
        final List<Thread> threads = Collections.synchronizedList(new ArrayList<>());

        for (int i = 1; i <= 200; i++) {
            final int count = i;
            if (count == 20) {
                // start source data after we have some already subscribed
                // and while others are in process of subscribing
                source.start();
            }
            if (count == 100) {
                // wait for source to finish then keep adding after it's done
                source.join();
            }
            Thread t = new Thread(new Runnable() {

                @Override
                public void run() {
                    List<Long> values = replay.toList().blockingGet();
                    listOfListsOfValues.add(values);
                    System.out.println(""Finished thread: "" + count);
                }
            });
            t.start();
            System.out.println(""Started thread: "" + i);
            threads.add(t);
        }

        // wait for all threads to complete
        for (Thread t : threads) {
            t.join();
        }

        // assert all threads got the same results
        List<Long> sums = new ArrayList<>();
        for (List<Long> values : listOfListsOfValues) {
            long v = 0;
            for (long l : values) {
                v += l;
            }
            sums.add(v);
        }

        long expected = sums.get(0);
        boolean success = true;
        for (long l : sums) {
            if (l != expected) {
                success = false;
                System.out.println(""FAILURE => Expected "" + expected + "" but got: "" + l);
            }
        }

        if (success) {
            System.out.println(""Success! "" + sums.size() + "" each had the same sum of "" + expected);
        } else {
            throw new RuntimeException(""Concurrency Bug"");
        }

    }",loop_control
value,"{
        final ReplayProcessor<Long> replay = ReplayProcessor.createUnbounded();
        Thread source = new Thread(new Runnable() {

            @Override
            public void run() {
                Flowable.unsafeCreate(new Publisher<Long>() {

                    @Override
                    public void subscribe(Subscriber<? super Long> subscriber) {
                        System.out.println(""********* Start Source Data ***********"");
                        for (long l = 1; l <= 10000; l++) {
                            subscriber.onNext(l);
                        }
                        System.out.println(""********* Finished Source Data ***********"");
                        subscriber.onComplete();
                    }
                }).subscribe(replay);
            }
        });

        // used to collect results of each thread
        final List<List<Long>> listOfListsOfValues = Collections.synchronizedList(new ArrayList<>());
        final List<Thread> threads = Collections.synchronizedList(new ArrayList<>());

        for (int i = 1; i <= 200; i++) {
            final int count = i;
            if (count == 20) {
                // start source data after we have some already subscribed
                // and while others are in process of subscribing
                source.start();
            }
            if (count == 100) {
                // wait for source to finish then keep adding after it's done
                source.join();
            }
            Thread t = new Thread(new Runnable() {

                @Override
                public void run() {
                    List<Long> values = replay.toList().blockingGet();
                    listOfListsOfValues.add(values);
                    System.out.println(""Finished thread: "" + count);
                }
            });
            t.start();
            System.out.println(""Started thread: "" + i);
            threads.add(t);
        }

        // wait for all threads to complete
        for (Thread t : threads) {
            t.join();
        }

        // assert all threads got the same results
        List<Long> sums = new ArrayList<>();
        for (List<Long> values : listOfListsOfValues) {
            long v = 0;
            for (long l : values) {
                v += l;
            }
            sums.add(v);
        }

        long expected = sums.get(0);
        boolean success = true;
        for (long l : sums) {
            if (l != expected) {
                success = false;
                System.out.println(""FAILURE => Expected "" + expected + "" but got: "" + l);
            }
        }

        if (success) {
            System.out.println(""Success! "" + sums.size() + "" each had the same sum of "" + expected);
        } else {
            throw new RuntimeException(""Concurrency Bug"");
        }

    }",iterator
i,"{
        final List<Integer> expected = Arrays.asList(1);
        for (int i = 0; i < 100000; i++) {
            TestSubscriberEx<Integer> ts = new TestSubscriberEx<>();
            Flowable.just(1).subscribeOn(Schedulers.computation()).cache().subscribe(ts);
            ts.awaitDone(5, TimeUnit.SECONDS);
            ts.assertValueSequence(expected);
            ts.assertTerminated();
        }
    }",loop_control
i,"{
        Scheduler s = Schedulers.io();
        Scheduler.Worker worker = Schedulers.io().createWorker();
        try {
            for (int i = 0; i < 50000; i++) {
                if (i % 1000 == 0) {
                    System.out.println(i);
                }
                final ReplayProcessor<Object> rs = ReplayProcessor.createWithSize(2);

                final CountDownLatch finish = new CountDownLatch(1);
                final CountDownLatch start = new CountDownLatch(1);

//                int j = i;

                worker.schedule(new Runnable() {
                    @Override
                    public void run() {
                        try {
                            start.await();
                        } catch (Exception e1) {
                            e1.printStackTrace();
                        }
//                        System.out.println(""> "" + j);
                        rs.onNext(1);
                    }
                });

                final AtomicReference<Object> o = new AtomicReference<>();

                rs
//                .doOnSubscribe(v -> System.out.println(""!! "" + j))
//                .doOnNext(e -> System.out.println("">> "" + j))
                .subscribeOn(s)
                .observeOn(Schedulers.io())
//                .doOnNext(e -> System.out.println("">>> "" + j))
                .subscribe(new DefaultSubscriber<Object>() {

                    @Override
                    protected void onStart() {
                        super.onStart();
                    }

                    @Override
                    public void onComplete() {
                        o.set(-1);
                        finish.countDown();
                    }

                    @Override
                    public void onError(Throwable e) {
                        o.set(e);
                        finish.countDown();
                    }

                    @Override
                    public void onNext(Object t) {
                        o.set(t);
                        finish.countDown();
                    }

                });
                start.countDown();

                if (!finish.await(5, TimeUnit.SECONDS)) {
                    System.out.println(o.get());
                    System.out.println(rs.hasSubscribers());
                    rs.onComplete();
                    Assert.fail(""Timeout @ "" + i);
                    break;
                } else {
                    Assert.assertEquals(1, o.get());
                    worker.schedule(new Runnable() {
                        @Override
                        public void run() {
                            rs.onComplete();
                        }
                    });
                }
            }
        } finally {
            worker.dispose();
        }
    }",loop_control
finish,"{
        Scheduler s = Schedulers.io();
        Scheduler.Worker worker = Schedulers.io().createWorker();
        try {
            for (int i = 0; i < 50000; i++) {
                if (i % 1000 == 0) {
                    System.out.println(i);
                }
                final ReplayProcessor<Object> rs = ReplayProcessor.createWithSize(2);

                final CountDownLatch finish = new CountDownLatch(1);
                final CountDownLatch start = new CountDownLatch(1);

//                int j = i;

                worker.schedule(new Runnable() {
                    @Override
                    public void run() {
                        try {
                            start.await();
                        } catch (Exception e1) {
                            e1.printStackTrace();
                        }
//                        System.out.println(""> "" + j);
                        rs.onNext(1);
                    }
                });

                final AtomicReference<Object> o = new AtomicReference<>();

                rs
//                .doOnSubscribe(v -> System.out.println(""!! "" + j))
//                .doOnNext(e -> System.out.println("">> "" + j))
                .subscribeOn(s)
                .observeOn(Schedulers.io())
//                .doOnNext(e -> System.out.println("">>> "" + j))
                .subscribe(new DefaultSubscriber<Object>() {

                    @Override
                    protected void onStart() {
                        super.onStart();
                    }

                    @Override
                    public void onComplete() {
                        o.set(-1);
                        finish.countDown();
                    }

                    @Override
                    public void onError(Throwable e) {
                        o.set(e);
                        finish.countDown();
                    }

                    @Override
                    public void onNext(Object t) {
                        o.set(t);
                        finish.countDown();
                    }

                });
                start.countDown();

                if (!finish.await(5, TimeUnit.SECONDS)) {
                    System.out.println(o.get());
                    System.out.println(rs.hasSubscribers());
                    rs.onComplete();
                    Assert.fail(""Timeout @ "" + i);
                    break;
                } else {
                    Assert.assertEquals(1, o.get());
                    worker.schedule(new Runnable() {
                        @Override
                        public void run() {
                            rs.onComplete();
                        }
                    });
                }
            }
        } finally {
            worker.dispose();
        }
    }",break_loop_control
i,"{
        final ReplayProcessor<Object> rs = ReplayProcessor.createUnbounded();
        final CyclicBarrier cb = new CyclicBarrier(2);

        Thread t = new Thread(new Runnable() {
            @Override
            public void run() {
                try {
                    cb.await();
                } catch (InterruptedException e) {
                    return;
                } catch (BrokenBarrierException e) {
                    return;
                }
                for (int i = 0; i < 1000000; i++) {
                    rs.onNext(i);
                }
                rs.onComplete();
                System.out.println(""Replay fill Thread finished!"");
            }
        });
        t.start();
        try {
            cb.await();
        } catch (InterruptedException e) {
            return;
        } catch (BrokenBarrierException e) {
            return;
        }
        int lastSize = 0;
        for (; !rs.hasThrowable() && !rs.hasComplete();) {
            int size = rs.size();
            boolean hasAny = rs.hasValue();
            Object[] values = rs.getValues();
            if (size < lastSize) {
                Assert.fail(""Size decreased! "" + lastSize + "" -> "" + size);
            }
            if ((size > 0) && !hasAny) {
                Assert.fail(""hasAnyValue reports emptyness but size doesn't"");
            }
            if (size > values.length) {
                Assert.fail(""Got fewer values than size! "" + size + "" -> "" + values.length);
            }
            for (int i = 0; i < values.length - 1; i++) {
                Integer v1 = (Integer)values[i];
                Integer v2 = (Integer)values[i + 1];
                assertEquals(1, v2 - v1);
            }
            lastSize = size;
        }

        t.join();
    }",loop_control
rs,"{
        final ReplayProcessor<Object> rs = ReplayProcessor.createUnbounded();
        final CyclicBarrier cb = new CyclicBarrier(2);

        Thread t = new Thread(new Runnable() {
            @Override
            public void run() {
                try {
                    cb.await();
                } catch (InterruptedException e) {
                    return;
                } catch (BrokenBarrierException e) {
                    return;
                }
                for (int i = 0; i < 1000000; i++) {
                    rs.onNext(i);
                }
                rs.onComplete();
                System.out.println(""Replay fill Thread finished!"");
            }
        });
        t.start();
        try {
            cb.await();
        } catch (InterruptedException e) {
            return;
        } catch (BrokenBarrierException e) {
            return;
        }
        int lastSize = 0;
        for (; !rs.hasThrowable() && !rs.hasComplete();) {
            int size = rs.size();
            boolean hasAny = rs.hasValue();
            Object[] values = rs.getValues();
            if (size < lastSize) {
                Assert.fail(""Size decreased! "" + lastSize + "" -> "" + size);
            }
            if ((size > 0) && !hasAny) {
                Assert.fail(""hasAnyValue reports emptyness but size doesn't"");
            }
            if (size > values.length) {
                Assert.fail(""Got fewer values than size! "" + size + "" -> "" + values.length);
            }
            for (int i = 0; i < values.length - 1; i++) {
                Integer v1 = (Integer)values[i];
                Integer v2 = (Integer)values[i + 1];
                assertEquals(1, v2 - v1);
            }
            lastSize = size;
        }

        t.join();
    }",maybe_loop_control
rs,"{
        final ReplayProcessor<Object> rs = ReplayProcessor.createWithSize(3);
        final CyclicBarrier cb = new CyclicBarrier(2);

        Thread t = new Thread(new Runnable() {
            @Override
            public void run() {
                try {
                    cb.await();
                } catch (InterruptedException e) {
                    return;
                } catch (BrokenBarrierException e) {
                    return;
                }
                for (int i = 0; i < 1000000; i++) {
                    rs.onNext(i);
                }
                rs.onComplete();
                System.out.println(""Replay fill Thread finished!"");
            }
        });
        t.start();
        try {
            cb.await();
        } catch (InterruptedException e) {
            return;
        } catch (BrokenBarrierException e) {
            return;
        }
        for (; !rs.hasThrowable() && !rs.hasComplete();) {
            rs.size(); // can't use value so just call to detect hangs
            rs.hasValue(); // can't use value so just call to detect hangs
            Object[] values = rs.getValues();
            for (int i = 0; i < values.length - 1; i++) {
                Integer v1 = (Integer)values[i];
                Integer v2 = (Integer)values[i + 1];
                assertEquals(1, v2 - v1);
            }
        }

        t.join();
    }",maybe_loop_control
i,"{
        final ReplayProcessor<Object> rs = ReplayProcessor.createWithSize(3);
        final CyclicBarrier cb = new CyclicBarrier(2);

        Thread t = new Thread(new Runnable() {
            @Override
            public void run() {
                try {
                    cb.await();
                } catch (InterruptedException e) {
                    return;
                } catch (BrokenBarrierException e) {
                    return;
                }
                for (int i = 0; i < 1000000; i++) {
                    rs.onNext(i);
                }
                rs.onComplete();
                System.out.println(""Replay fill Thread finished!"");
            }
        });
        t.start();
        try {
            cb.await();
        } catch (InterruptedException e) {
            return;
        } catch (BrokenBarrierException e) {
            return;
        }
        for (; !rs.hasThrowable() && !rs.hasComplete();) {
            rs.size(); // can't use value so just call to detect hangs
            rs.hasValue(); // can't use value so just call to detect hangs
            Object[] values = rs.getValues();
            for (int i = 0; i < values.length - 1; i++) {
                Integer v1 = (Integer)values[i];
                Integer v2 = (Integer)values[i + 1];
                assertEquals(1, v2 - v1);
            }
        }

        t.join();
    }",loop_control
i,"{
        final ReplayProcessor<Object> rs = ReplayProcessor.createWithTime(1, TimeUnit.MILLISECONDS, Schedulers.computation());
        final CyclicBarrier cb = new CyclicBarrier(2);

        Thread t = new Thread(new Runnable() {
            @Override
            public void run() {
                try {
                    cb.await();
                } catch (InterruptedException e) {
                    return;
                } catch (BrokenBarrierException e) {
                    return;
                }
                for (int i = 0; i < 1000000; i++) {
                    rs.onNext(i);
                    if (i % 10000 == 0) {
                        try {
                            Thread.sleep(1);
                        } catch (InterruptedException e) {
                            return;
                        }
                    }
                }
                rs.onComplete();
                System.out.println(""Replay fill Thread finished!"");
            }
        });
        t.start();
        try {
            cb.await();
        } catch (InterruptedException e) {
            return;
        } catch (BrokenBarrierException e) {
            return;
        }
        for (; !rs.hasThrowable() && !rs.hasComplete();) {
            rs.size(); // can't use value so just call to detect hangs
            rs.hasValue(); // can't use value so just call to detect hangs
            Object[] values = rs.getValues();
            for (int i = 0; i < values.length - 1; i++) {
                Integer v1 = (Integer)values[i];
                Integer v2 = (Integer)values[i + 1];
                assertEquals(1, v2 - v1);
            }
        }

        t.join();
    }",loop_control
rs,"{
        final ReplayProcessor<Object> rs = ReplayProcessor.createWithTime(1, TimeUnit.MILLISECONDS, Schedulers.computation());
        final CyclicBarrier cb = new CyclicBarrier(2);

        Thread t = new Thread(new Runnable() {
            @Override
            public void run() {
                try {
                    cb.await();
                } catch (InterruptedException e) {
                    return;
                } catch (BrokenBarrierException e) {
                    return;
                }
                for (int i = 0; i < 1000000; i++) {
                    rs.onNext(i);
                    if (i % 10000 == 0) {
                        try {
                            Thread.sleep(1);
                        } catch (InterruptedException e) {
                            return;
                        }
                    }
                }
                rs.onComplete();
                System.out.println(""Replay fill Thread finished!"");
            }
        });
        t.start();
        try {
            cb.await();
        } catch (InterruptedException e) {
            return;
        } catch (BrokenBarrierException e) {
            return;
        }
        for (; !rs.hasThrowable() && !rs.hasComplete();) {
            rs.size(); // can't use value so just call to detect hangs
            rs.hasValue(); // can't use value so just call to detect hangs
            Object[] values = rs.getValues();
            for (int i = 0; i < values.length - 1; i++) {
                Integer v1 = (Integer)values[i];
                Integer v2 = (Integer)values[i + 1];
                assertEquals(1, v2 - v1);
            }
        }

        t.join();
    }",maybe_loop_control
i,"{
        /*
         * With non-threadsafe code this fails most of the time on my dev laptop and is non-deterministic enough
         * to act as a unit test to the race conditions.
         *
         * With the synchronization code in place I can not get this to fail on my laptop.
         */
        for (int i = 0; i < 50; i++) {
            final AsyncProcessor<String> processor = AsyncProcessor.create();
            final AtomicReference<String> value1 = new AtomicReference<>();

            processor.subscribe(new Consumer<String>() {

                @Override
                public void accept(String t1) {
                    try {
                        // simulate a slow observer
                        Thread.sleep(50);
                    } catch (InterruptedException e) {
                        e.printStackTrace();
                    }
                    value1.set(t1);
                }

            });

            Thread t1 = new Thread(new Runnable() {

                @Override
                public void run() {
                    processor.onNext(""value"");
                    processor.onComplete();
                }
            });

            SubjectSubscriberThread t2 = new SubjectSubscriberThread(processor);
            SubjectSubscriberThread t3 = new SubjectSubscriberThread(processor);
            SubjectSubscriberThread t4 = new SubjectSubscriberThread(processor);
            SubjectSubscriberThread t5 = new SubjectSubscriberThread(processor);

            t2.start();
            t3.start();
            t1.start();
            t4.start();
            t5.start();
            try {
                t1.join();
                t2.join();
                t3.join();
                t4.join();
                t5.join();
            } catch (InterruptedException e) {
                throw new RuntimeException(e);
            }

            assertEquals(""value"", value1.get());
            assertEquals(""value"", t2.value.get());
            assertEquals(""value"", t3.value.get());
            assertEquals(""value"", t4.value.get());
            assertEquals(""value"", t5.value.get());
        }

    }",loop_control
i,"{
        AsyncProcessor<Object> p = AsyncProcessor.create();

        for (int i = 0; i < TestHelper.RACE_DEFAULT_LOOPS; i++) {
            final TestSubscriber<Object> ts1 = p.test();
            final TestSubscriber<Object> ts2 = p.test();

            Runnable r1 = new Runnable() {
                @Override
                public void run() {
                    ts1.cancel();
                }
            };

            Runnable r2 = new Runnable() {
                @Override
                public void run() {
                    ts2.cancel();
                }
            };

            TestHelper.race(r1, r2);
        }
    }",loop_control
i,"{

        for (int i = 0; i < TestHelper.RACE_DEFAULT_LOOPS; i++) {
            final AsyncProcessor<Object> p = AsyncProcessor.create();

            final TestSubscriberEx<Object> ts1 = p.to(TestHelper.<Object>testConsumer());

            Runnable r1 = new Runnable() {
                @Override
                public void run() {
                    ts1.cancel();
                }
            };

            final TestException ex = new TestException();

            Runnable r2 = new Runnable() {
                @Override
                public void run() {
                    p.onError(ex);
                }
            };

            TestHelper.race(r1, r2);

            if (ts1.errors().size() != 0) {
                ts1.assertFailure(TestException.class);
            } else {
                ts1.assertEmpty();
            }
        }
    }",loop_control
l,"{
        final ReplayProcessor<Long> replay = ReplayProcessor.create();
        Thread source = new Thread(new Runnable() {

            @Override
            public void run() {
                Flowable.unsafeCreate(new Publisher<Long>() {

                    @Override
                    public void subscribe(Subscriber<? super Long> subscriber) {
                        System.out.println(""********* Start Source Data ***********"");
                        for (long l = 1; l <= 10000; l++) {
                            subscriber.onNext(l);
                        }
                        System.out.println(""********* Finished Source Data ***********"");
                        subscriber.onComplete();
                    }
                }).subscribe(replay);
            }
        });
        source.start();

        long v = replay.blockingLast();
        assertEquals(10000, v);

        // it's been played through once so now it will all be replays
        final CountDownLatch slowLatch = new CountDownLatch(1);
        Thread slowThread = new Thread(new Runnable() {

            @Override
            public void run() {
                Subscriber<Long> slow = new DefaultSubscriber<Long>() {

                    @Override
                    public void onComplete() {
                        System.out.println(""*** Slow Observer completed"");
                        slowLatch.countDown();
                    }

                    @Override
                    public void onError(Throwable e) {
                    }

                    @Override
                    public void onNext(Long args) {
                        if (args == 1) {
                            System.out.println(""*** Slow Observer STARTED"");
                        }
                        try {
                            if (args % 10 == 0) {
                                Thread.sleep(1);
                            }
                        } catch (InterruptedException e) {
                            e.printStackTrace();
                        }
                    }
                };
                replay.subscribe(slow);
                try {
                    slowLatch.await();
                } catch (InterruptedException e1) {
                    e1.printStackTrace();
                }
            }
        });
        slowThread.start();

        Thread fastThread = new Thread(new Runnable() {

            @Override
            public void run() {
                final CountDownLatch fastLatch = new CountDownLatch(1);
                Subscriber<Long> fast = new DefaultSubscriber<Long>() {

                    @Override
                    public void onComplete() {
                        System.out.println(""*** Fast Observer completed"");
                        fastLatch.countDown();
                    }

                    @Override
                    public void onError(Throwable e) {
                    }

                    @Override
                    public void onNext(Long args) {
                        if (args == 1) {
                            System.out.println(""*** Fast Observer STARTED"");
                        }
                    }
                };
                replay.subscribe(fast);
                try {
                    fastLatch.await();
                } catch (InterruptedException e1) {
                    e1.printStackTrace();
                }
            }
        });
        fastThread.start();
        fastThread.join();

        // slow should not yet be completed when fast completes
        assertEquals(1, slowLatch.getCount());

        slowThread.join();
    }",loop_control
l,"{
        final ReplayProcessor<Long> replay = ReplayProcessor.create();
        Thread source = new Thread(new Runnable() {

            @Override
            public void run() {
                Flowable.unsafeCreate(new Publisher<Long>() {

                    @Override
                    public void subscribe(Subscriber<? super Long> subscriber) {
                        System.out.println(""********* Start Source Data ***********"");
                        for (long l = 1; l <= 10000; l++) {
                            subscriber.onNext(l);
                        }
                        System.out.println(""********* Finished Source Data ***********"");
                        subscriber.onComplete();
                    }
                }).subscribe(replay);
            }
        });

        // used to collect results of each thread
        final List<List<Long>> listOfListsOfValues = Collections.synchronizedList(new ArrayList<>());
        final List<Thread> threads = Collections.synchronizedList(new ArrayList<>());

        for (int i = 1; i <= 200; i++) {
            final int count = i;
            if (count == 20) {
                // start source data after we have some already subscribed
                // and while others are in process of subscribing
                source.start();
            }
            if (count == 100) {
                // wait for source to finish then keep adding after it's done
                source.join();
            }
            Thread t = new Thread(new Runnable() {

                @Override
                public void run() {
                    List<Long> values = replay.toList().blockingGet();
                    listOfListsOfValues.add(values);
                    System.out.println(""Finished thread: "" + count);
                }
            });
            t.start();
            System.out.println(""Started thread: "" + i);
            threads.add(t);
        }

        // wait for all threads to complete
        for (Thread t : threads) {
            t.join();
        }

        // assert all threads got the same results
        List<Long> sums = new ArrayList<>();
        for (List<Long> values : listOfListsOfValues) {
            long v = 0;
            for (long l : values) {
                v += l;
            }
            sums.add(v);
        }

        long expected = sums.get(0);
        boolean success = true;
        for (long l : sums) {
            if (l != expected) {
                success = false;
                System.out.println(""FAILURE => Expected "" + expected + "" but got: "" + l);
            }
        }

        if (success) {
            System.out.println(""Success! "" + sums.size() + "" each had the same sum of "" + expected);
        } else {
            throw new RuntimeException(""Concurrency Bug"");
        }

    }",loop_control
i,"{
        final ReplayProcessor<Long> replay = ReplayProcessor.create();
        Thread source = new Thread(new Runnable() {

            @Override
            public void run() {
                Flowable.unsafeCreate(new Publisher<Long>() {

                    @Override
                    public void subscribe(Subscriber<? super Long> subscriber) {
                        System.out.println(""********* Start Source Data ***********"");
                        for (long l = 1; l <= 10000; l++) {
                            subscriber.onNext(l);
                        }
                        System.out.println(""********* Finished Source Data ***********"");
                        subscriber.onComplete();
                    }
                }).subscribe(replay);
            }
        });

        // used to collect results of each thread
        final List<List<Long>> listOfListsOfValues = Collections.synchronizedList(new ArrayList<>());
        final List<Thread> threads = Collections.synchronizedList(new ArrayList<>());

        for (int i = 1; i <= 200; i++) {
            final int count = i;
            if (count == 20) {
                // start source data after we have some already subscribed
                // and while others are in process of subscribing
                source.start();
            }
            if (count == 100) {
                // wait for source to finish then keep adding after it's done
                source.join();
            }
            Thread t = new Thread(new Runnable() {

                @Override
                public void run() {
                    List<Long> values = replay.toList().blockingGet();
                    listOfListsOfValues.add(values);
                    System.out.println(""Finished thread: "" + count);
                }
            });
            t.start();
            System.out.println(""Started thread: "" + i);
            threads.add(t);
        }

        // wait for all threads to complete
        for (Thread t : threads) {
            t.join();
        }

        // assert all threads got the same results
        List<Long> sums = new ArrayList<>();
        for (List<Long> values : listOfListsOfValues) {
            long v = 0;
            for (long l : values) {
                v += l;
            }
            sums.add(v);
        }

        long expected = sums.get(0);
        boolean success = true;
        for (long l : sums) {
            if (l != expected) {
                success = false;
                System.out.println(""FAILURE => Expected "" + expected + "" but got: "" + l);
            }
        }

        if (success) {
            System.out.println(""Success! "" + sums.size() + "" each had the same sum of "" + expected);
        } else {
            throw new RuntimeException(""Concurrency Bug"");
        }

    }",loop_control
values,"{
        final ReplayProcessor<Long> replay = ReplayProcessor.create();
        Thread source = new Thread(new Runnable() {

            @Override
            public void run() {
                Flowable.unsafeCreate(new Publisher<Long>() {

                    @Override
                    public void subscribe(Subscriber<? super Long> subscriber) {
                        System.out.println(""********* Start Source Data ***********"");
                        for (long l = 1; l <= 10000; l++) {
                            subscriber.onNext(l);
                        }
                        System.out.println(""********* Finished Source Data ***********"");
                        subscriber.onComplete();
                    }
                }).subscribe(replay);
            }
        });

        // used to collect results of each thread
        final List<List<Long>> listOfListsOfValues = Collections.synchronizedList(new ArrayList<>());
        final List<Thread> threads = Collections.synchronizedList(new ArrayList<>());

        for (int i = 1; i <= 200; i++) {
            final int count = i;
            if (count == 20) {
                // start source data after we have some already subscribed
                // and while others are in process of subscribing
                source.start();
            }
            if (count == 100) {
                // wait for source to finish then keep adding after it's done
                source.join();
            }
            Thread t = new Thread(new Runnable() {

                @Override
                public void run() {
                    List<Long> values = replay.toList().blockingGet();
                    listOfListsOfValues.add(values);
                    System.out.println(""Finished thread: "" + count);
                }
            });
            t.start();
            System.out.println(""Started thread: "" + i);
            threads.add(t);
        }

        // wait for all threads to complete
        for (Thread t : threads) {
            t.join();
        }

        // assert all threads got the same results
        List<Long> sums = new ArrayList<>();
        for (List<Long> values : listOfListsOfValues) {
            long v = 0;
            for (long l : values) {
                v += l;
            }
            sums.add(v);
        }

        long expected = sums.get(0);
        boolean success = true;
        for (long l : sums) {
            if (l != expected) {
                success = false;
                System.out.println(""FAILURE => Expected "" + expected + "" but got: "" + l);
            }
        }

        if (success) {
            System.out.println(""Success! "" + sums.size() + "" each had the same sum of "" + expected);
        } else {
            throw new RuntimeException(""Concurrency Bug"");
        }

    }",iterator
t,"{
        final ReplayProcessor<Long> replay = ReplayProcessor.create();
        Thread source = new Thread(new Runnable() {

            @Override
            public void run() {
                Flowable.unsafeCreate(new Publisher<Long>() {

                    @Override
                    public void subscribe(Subscriber<? super Long> subscriber) {
                        System.out.println(""********* Start Source Data ***********"");
                        for (long l = 1; l <= 10000; l++) {
                            subscriber.onNext(l);
                        }
                        System.out.println(""********* Finished Source Data ***********"");
                        subscriber.onComplete();
                    }
                }).subscribe(replay);
            }
        });

        // used to collect results of each thread
        final List<List<Long>> listOfListsOfValues = Collections.synchronizedList(new ArrayList<>());
        final List<Thread> threads = Collections.synchronizedList(new ArrayList<>());

        for (int i = 1; i <= 200; i++) {
            final int count = i;
            if (count == 20) {
                // start source data after we have some already subscribed
                // and while others are in process of subscribing
                source.start();
            }
            if (count == 100) {
                // wait for source to finish then keep adding after it's done
                source.join();
            }
            Thread t = new Thread(new Runnable() {

                @Override
                public void run() {
                    List<Long> values = replay.toList().blockingGet();
                    listOfListsOfValues.add(values);
                    System.out.println(""Finished thread: "" + count);
                }
            });
            t.start();
            System.out.println(""Started thread: "" + i);
            threads.add(t);
        }

        // wait for all threads to complete
        for (Thread t : threads) {
            t.join();
        }

        // assert all threads got the same results
        List<Long> sums = new ArrayList<>();
        for (List<Long> values : listOfListsOfValues) {
            long v = 0;
            for (long l : values) {
                v += l;
            }
            sums.add(v);
        }

        long expected = sums.get(0);
        boolean success = true;
        for (long l : sums) {
            if (l != expected) {
                success = false;
                System.out.println(""FAILURE => Expected "" + expected + "" but got: "" + l);
            }
        }

        if (success) {
            System.out.println(""Success! "" + sums.size() + "" each had the same sum of "" + expected);
        } else {
            throw new RuntimeException(""Concurrency Bug"");
        }

    }",iterator
i,"{
        for (int i = 0; i < 50; i++) {
            final ReplayProcessor<String> processor = ReplayProcessor.create();
            final AtomicReference<String> value1 = new AtomicReference<>();

            processor.subscribe(new Consumer<String>() {

                @Override
                public void accept(String t1) {
                    try {
                        // simulate a slow observer
                        Thread.sleep(50);
                    } catch (InterruptedException e) {
                        e.printStackTrace();
                    }
                    value1.set(t1);
                }

            });

            Thread t1 = new Thread(new Runnable() {

                @Override
                public void run() {
                    processor.onNext(""value"");
                    processor.onComplete();
                }
            });

            SubjectObserverThread t2 = new SubjectObserverThread(processor);
            SubjectObserverThread t3 = new SubjectObserverThread(processor);
            SubjectObserverThread t4 = new SubjectObserverThread(processor);
            SubjectObserverThread t5 = new SubjectObserverThread(processor);

            t2.start();
            t3.start();
            t1.start();
            t4.start();
            t5.start();
            try {
                t1.join();
                t2.join();
                t3.join();
                t4.join();
                t5.join();
            } catch (InterruptedException e) {
                throw new RuntimeException(e);
            }

            assertEquals(""value"", value1.get());
            assertEquals(""value"", t2.value.get());
            assertEquals(""value"", t3.value.get());
            assertEquals(""value"", t4.value.get());
            assertEquals(""value"", t5.value.get());
        }

    }",loop_control
i,"{
        final List<Integer> expected = Arrays.asList(1);
        for (int i = 0; i < 100000; i++) {
            TestSubscriberEx<Integer> ts = new TestSubscriberEx<>();
            Flowable.just(1).subscribeOn(Schedulers.computation()).cache().subscribe(ts);
            ts.awaitDone(5, TimeUnit.SECONDS);
            ts.assertValueSequence(expected);
            ts.assertTerminated();
        }
    }",loop_control
i,"{
        Scheduler s = Schedulers.io();
        Scheduler.Worker worker = Schedulers.io().createWorker();
        try {
            for (int i = 0; i < 50000; i++) {
                if (i % 1000 == 0) {
                    System.out.println(i);
                }
                final ReplayProcessor<Object> rs = ReplayProcessor.create();

                final CountDownLatch finish = new CountDownLatch(1);
                final CountDownLatch start = new CountDownLatch(1);

                worker.schedule(new Runnable() {
                    @Override
                    public void run() {
                        try {
                            start.await();
                        } catch (Exception e1) {
                            e1.printStackTrace();
                        }
                        rs.onNext(1);
                    }
                });

                final AtomicReference<Object> o = new AtomicReference<>();

                rs.subscribeOn(s).observeOn(Schedulers.io())
                .subscribe(new DefaultSubscriber<Object>() {

                    @Override
                    public void onComplete() {
                        o.set(-1);
                        finish.countDown();
                    }

                    @Override
                    public void onError(Throwable e) {
                        o.set(e);
                        finish.countDown();
                    }

                    @Override
                    public void onNext(Object t) {
                        o.set(t);
                        finish.countDown();
                    }

                });
                start.countDown();

                if (!finish.await(5, TimeUnit.SECONDS)) {
                    System.out.println(o.get());
                    System.out.println(rs.hasSubscribers());
                    rs.onComplete();
                    Assert.fail(""Timeout @ "" + i);
                    break;
                } else {
                    Assert.assertEquals(1, o.get());
                    worker.schedule(new Runnable() {
                        @Override
                        public void run() {
                            rs.onComplete();
                        }
                    });

                }
            }
        } finally {
            worker.dispose();
        }
    }",loop_control
finish,"{
        Scheduler s = Schedulers.io();
        Scheduler.Worker worker = Schedulers.io().createWorker();
        try {
            for (int i = 0; i < 50000; i++) {
                if (i % 1000 == 0) {
                    System.out.println(i);
                }
                final ReplayProcessor<Object> rs = ReplayProcessor.create();

                final CountDownLatch finish = new CountDownLatch(1);
                final CountDownLatch start = new CountDownLatch(1);

                worker.schedule(new Runnable() {
                    @Override
                    public void run() {
                        try {
                            start.await();
                        } catch (Exception e1) {
                            e1.printStackTrace();
                        }
                        rs.onNext(1);
                    }
                });

                final AtomicReference<Object> o = new AtomicReference<>();

                rs.subscribeOn(s).observeOn(Schedulers.io())
                .subscribe(new DefaultSubscriber<Object>() {

                    @Override
                    public void onComplete() {
                        o.set(-1);
                        finish.countDown();
                    }

                    @Override
                    public void onError(Throwable e) {
                        o.set(e);
                        finish.countDown();
                    }

                    @Override
                    public void onNext(Object t) {
                        o.set(t);
                        finish.countDown();
                    }

                });
                start.countDown();

                if (!finish.await(5, TimeUnit.SECONDS)) {
                    System.out.println(o.get());
                    System.out.println(rs.hasSubscribers());
                    rs.onComplete();
                    Assert.fail(""Timeout @ "" + i);
                    break;
                } else {
                    Assert.assertEquals(1, o.get());
                    worker.schedule(new Runnable() {
                        @Override
                        public void run() {
                            rs.onComplete();
                        }
                    });

                }
            }
        } finally {
            worker.dispose();
        }
    }",break_loop_control
i,"{
        final ReplayProcessor<Object> rs = ReplayProcessor.create();
        final CyclicBarrier cb = new CyclicBarrier(2);

        Thread t = new Thread(new Runnable() {
            @Override
            public void run() {
                try {
                    cb.await();
                } catch (InterruptedException e) {
                    return;
                } catch (BrokenBarrierException e) {
                    return;
                }
                for (int i = 0; i < 1000000; i++) {
                    rs.onNext(i);
                }
                rs.onComplete();
                System.out.println(""Replay fill Thread finished!"");
            }
        });
        t.start();
        try {
            cb.await();
        } catch (InterruptedException e) {
            return;
        } catch (BrokenBarrierException e) {
            return;
        }
        int lastSize = 0;
        for (; !rs.hasThrowable() && !rs.hasComplete();) {
            int size = rs.size();
            boolean hasAny = rs.hasValue();
            Object[] values = rs.getValues();
            if (size < lastSize) {
                Assert.fail(""Size decreased! "" + lastSize + "" -> "" + size);
            }
            if ((size > 0) && !hasAny) {
                Assert.fail(""hasAnyValue reports emptyness but size doesn't"");
            }
            if (size > values.length) {
                Assert.fail(""Got fewer values than size! "" + size + "" -> "" + values.length);
            }
            lastSize = size;
        }

        t.join();
    }",loop_control
rs,"{
        final ReplayProcessor<Object> rs = ReplayProcessor.create();
        final CyclicBarrier cb = new CyclicBarrier(2);

        Thread t = new Thread(new Runnable() {
            @Override
            public void run() {
                try {
                    cb.await();
                } catch (InterruptedException e) {
                    return;
                } catch (BrokenBarrierException e) {
                    return;
                }
                for (int i = 0; i < 1000000; i++) {
                    rs.onNext(i);
                }
                rs.onComplete();
                System.out.println(""Replay fill Thread finished!"");
            }
        });
        t.start();
        try {
            cb.await();
        } catch (InterruptedException e) {
            return;
        } catch (BrokenBarrierException e) {
            return;
        }
        int lastSize = 0;
        for (; !rs.hasThrowable() && !rs.hasComplete();) {
            int size = rs.size();
            boolean hasAny = rs.hasValue();
            Object[] values = rs.getValues();
            if (size < lastSize) {
                Assert.fail(""Size decreased! "" + lastSize + "" -> "" + size);
            }
            if ((size > 0) && !hasAny) {
                Assert.fail(""hasAnyValue reports emptyness but size doesn't"");
            }
            if (size > values.length) {
                Assert.fail(""Got fewer values than size! "" + size + "" -> "" + values.length);
            }
            lastSize = size;
        }

        t.join();
    }",maybe_loop_control
i,"{
        final PublishProcessor<Integer> s = PublishProcessor.create();

        final AtomicInteger countParent = new AtomicInteger();
        final AtomicInteger countChildren = new AtomicInteger();
        final AtomicInteger countTotal = new AtomicInteger();

        final ArrayList<String> list = new ArrayList<>();

        s.flatMap(new Function<Integer, Flowable<String>>() {

            @Override
            public Flowable<String> apply(final Integer v) {
                countParent.incrementAndGet();

                // then subscribe to processor again (it will not receive the previous value)
                return s.map(new Function<Integer, String>() {

                    @Override
                    public String apply(Integer v2) {
                        countChildren.incrementAndGet();
                        return ""Parent: "" + v + "" Child: "" + v2;
                    }

                });
            }

        }).subscribe(new Consumer<String>() {

            @Override
            public void accept(String v) {
                countTotal.incrementAndGet();
                list.add(v);
            }

        });

        for (int i = 0; i < 10; i++) {
            s.onNext(i);
        }
        s.onComplete();

        //            System.out.println(""countParent: "" + countParent.get());
        //            System.out.println(""countChildren: "" + countChildren.get());
        //            System.out.println(""countTotal: "" + countTotal.get());

        // 9+8+7+6+5+4+3+2+1+0 == 45
        assertEquals(45, list.size());
    }",loop_control
i,"{
        PublishProcessor<String> src = PublishProcessor.create();

        for (int i = 0; i < 10; i++) {
            final Subscriber<Object> subscriber = TestHelper.mockSubscriber();
            InOrder inOrder = inOrder(subscriber);
            String v = """" + i;
            System.out.printf(""Turn: %d%n"", i);
            src.firstElement().toFlowable()
                .flatMap(new Function<String, Flowable<String>>() {

                    @Override
                    public Flowable<String> apply(String t1) {
                        return Flowable.just(t1 + "", "" + t1);
                    }
                })
                .subscribe(new DefaultSubscriber<String>() {
                    @Override
                    public void onNext(String t) {
                        subscriber.onNext(t);
                    }

                    @Override
                    public void onError(Throwable e) {
                        subscriber.onError(e);
                    }

                    @Override
                    public void onComplete() {
                        subscriber.onComplete();
                    }
                });
            src.onNext(v);

            inOrder.verify(subscriber).onNext(v + "", "" + v);
            inOrder.verify(subscriber).onComplete();
            verify(subscriber, never()).onError(any(Throwable.class));
        }
    }",loop_control
i,"{

        for (int i = 0; i < TestHelper.RACE_DEFAULT_LOOPS; i++) {
            final PublishProcessor<Integer> pp = PublishProcessor.create();

            TestSubscriber<Integer> ts = pp.test();

            Runnable task = new Runnable() {
                @Override
                public void run() {
                    pp.onComplete();
                }
            };

            TestHelper.race(task, task);

            ts
            .awaitDone(5, TimeUnit.SECONDS)
            .assertResult();
        }
    }",loop_control
i,"{

        for (int i = 0; i < TestHelper.RACE_DEFAULT_LOOPS; i++) {
            final PublishProcessor<Integer> pp = PublishProcessor.create();

            final TestSubscriber<Integer> ts = pp.test();

            Runnable r1 = new Runnable() {
                @Override
                public void run() {
                    pp.subscribe();
                }
            };
            Runnable r2 = new Runnable() {
                @Override
                public void run() {
                    ts.cancel();
                }
            };

            TestHelper.race(r1, r2);
        }
    }",loop_control
pp,"{
        final PublishProcessor<Integer> pp = PublishProcessor.create();

        Schedulers.single().scheduleDirect(new Runnable() {
            @Override
            public void run() {
                while (!pp.hasSubscribers()) {
                    try {
                        Thread.sleep(1);
                    } catch (InterruptedException ex) {
                        return;
                    }
                }

                for (int i = 1; i <= 10; i++) {
                    while (!pp.offer(i)) { }
                }
                pp.onComplete();
            }
        });

        Thread.sleep(1);

        pp.test()
        .awaitDone(5, TimeUnit.SECONDS)
        .assertResult(1, 2, 3, 4, 5, 6, 7, 8, 9, 10);
    }",maybe_loop_control
i,"{
        final PublishProcessor<Integer> pp = PublishProcessor.create();

        Schedulers.single().scheduleDirect(new Runnable() {
            @Override
            public void run() {
                while (!pp.hasSubscribers()) {
                    try {
                        Thread.sleep(1);
                    } catch (InterruptedException ex) {
                        return;
                    }
                }

                for (int i = 1; i <= 10; i++) {
                    while (!pp.offer(i)) { }
                }
                pp.onComplete();
            }
        });

        Thread.sleep(1);

        pp.test()
        .awaitDone(5, TimeUnit.SECONDS)
        .assertResult(1, 2, 3, 4, 5, 6, 7, 8, 9, 10);
    }",loop_control
i,"{
        for (int i = 0; i < TestHelper.RACE_DEFAULT_LOOPS; i++) {
            final PublishProcessor<Integer> pp = PublishProcessor.create();

            final TestSubscriber<Integer> ts = pp.test(1);

            Runnable r1 = new Runnable() {
                @Override
                public void run() {
                    for (int i = 0; i < 2; i++) {
                        while (!pp.offer(i)) { }
                    }
                }
            };

            Runnable r2 = new Runnable() {
                @Override
                public void run() {
                    ts.cancel();
                }
            };

            TestHelper.race(r1, r2);

            if (ts.values().size() > 0) {
                ts.assertValuesOnly(0);
            } else {
                ts.assertEmpty();
            }
        }
    }",loop_control
pp,"{
        for (int i = 0; i < TestHelper.RACE_DEFAULT_LOOPS; i++) {
            final PublishProcessor<Integer> pp = PublishProcessor.create();

            final TestSubscriber<Integer> ts = pp.test(1);

            Runnable r1 = new Runnable() {
                @Override
                public void run() {
                    for (int i = 0; i < 2; i++) {
                        while (!pp.offer(i)) { }
                    }
                }
            };

            Runnable r2 = new Runnable() {
                @Override
                public void run() {
                    ts.cancel();
                }
            };

            TestHelper.race(r1, r2);

            if (ts.values().size() > 0) {
                ts.assertValuesOnly(0);
            } else {
                ts.assertEmpty();
            }
        }
    }",maybe_loop_control
i,"{
        BehaviorProcessor<String> src = BehaviorProcessor.createDefault(""null""); // FIXME was plain null which is not allowed

        for (int i = 0; i < 10; i++) {
            final Subscriber<Object> subscriber = TestHelper.mockSubscriber();
            InOrder inOrder = inOrder(subscriber);
            String v = """" + i;
            src.onNext(v);
            System.out.printf(""Turn: %d%n"", i);
            src.firstElement().toFlowable()
                .flatMap(new Function<String, Flowable<String>>() {

                    @Override
                    public Flowable<String> apply(String t1) {
                        return Flowable.just(t1 + "", "" + t1);
                    }
                })
                .subscribe(new DefaultSubscriber<String>() {
                    @Override
                    public void onNext(String t) {
                        subscriber.onNext(t);
                    }

                    @Override
                    public void onError(Throwable e) {
                        subscriber.onError(e);
                    }

                    @Override
                    public void onComplete() {
                        subscriber.onComplete();
                    }
                });
            inOrder.verify(subscriber).onNext(v + "", "" + v);
            inOrder.verify(subscriber).onComplete();
            verify(subscriber, never()).onError(any(Throwable.class));
        }
    }",loop_control
i,"{
        Scheduler s = Schedulers.io();
        Scheduler.Worker worker = Schedulers.io().createWorker();
        try {
            for (int i = 0; i < 50000; i++) {
                if (i % 1000 == 0) {
                    System.out.println(i);
                }
                final BehaviorProcessor<Object> rs = BehaviorProcessor.create();

                final CountDownLatch finish = new CountDownLatch(1);
                final CountDownLatch start = new CountDownLatch(1);

                worker.schedule(new Runnable() {
                    @Override
                    public void run() {
                        try {
                            start.await();
                        } catch (Exception e1) {
                            e1.printStackTrace();
                        }
                        rs.onNext(1);
                    }
                });

                final AtomicReference<Object> o = new AtomicReference<>();

                rs.subscribeOn(s).observeOn(Schedulers.io())
                .subscribe(new DefaultSubscriber<Object>() {

                    @Override
                    public void onComplete() {
                        o.set(-1);
                        finish.countDown();
                    }

                    @Override
                    public void onError(Throwable e) {
                        o.set(e);
                        finish.countDown();
                    }

                    @Override
                    public void onNext(Object t) {
                        o.set(t);
                        finish.countDown();
                    }

                });
                start.countDown();

                if (!finish.await(5, TimeUnit.SECONDS)) {
                    System.out.println(o.get());
                    System.out.println(rs.hasSubscribers());
                    rs.onComplete();
                    Assert.fail(""Timeout @ "" + i);
                    break;
                } else {
                    Assert.assertEquals(1, o.get());
                    worker.schedule(new Runnable() {
                        @Override
                        public void run() {
                            rs.onComplete();
                        }
                    });
                }
            }
        } finally {
            worker.dispose();
        }
    }",loop_control
finish,"{
        Scheduler s = Schedulers.io();
        Scheduler.Worker worker = Schedulers.io().createWorker();
        try {
            for (int i = 0; i < 50000; i++) {
                if (i % 1000 == 0) {
                    System.out.println(i);
                }
                final BehaviorProcessor<Object> rs = BehaviorProcessor.create();

                final CountDownLatch finish = new CountDownLatch(1);
                final CountDownLatch start = new CountDownLatch(1);

                worker.schedule(new Runnable() {
                    @Override
                    public void run() {
                        try {
                            start.await();
                        } catch (Exception e1) {
                            e1.printStackTrace();
                        }
                        rs.onNext(1);
                    }
                });

                final AtomicReference<Object> o = new AtomicReference<>();

                rs.subscribeOn(s).observeOn(Schedulers.io())
                .subscribe(new DefaultSubscriber<Object>() {

                    @Override
                    public void onComplete() {
                        o.set(-1);
                        finish.countDown();
                    }

                    @Override
                    public void onError(Throwable e) {
                        o.set(e);
                        finish.countDown();
                    }

                    @Override
                    public void onNext(Object t) {
                        o.set(t);
                        finish.countDown();
                    }

                });
                start.countDown();

                if (!finish.await(5, TimeUnit.SECONDS)) {
                    System.out.println(o.get());
                    System.out.println(rs.hasSubscribers());
                    rs.onComplete();
                    Assert.fail(""Timeout @ "" + i);
                    break;
                } else {
                    Assert.assertEquals(1, o.get());
                    worker.schedule(new Runnable() {
                        @Override
                        public void run() {
                            rs.onComplete();
                        }
                    });
                }
            }
        } finally {
            worker.dispose();
        }
    }",break_loop_control
i,"{
        for (int i = 0; i < TestHelper.RACE_DEFAULT_LOOPS; i++) {
            final BehaviorProcessor<Object> p = BehaviorProcessor.create();

            final TestSubscriber<Object> ts = p.test();

            Runnable r1 = new Runnable() {
                @Override
                public void run() {
                    p.test();
                }
            };

            Runnable r2 = new Runnable() {
                @Override
                public void run() {
                    ts.cancel();
                }
            };

            TestHelper.race(r1, r2);
        }
    }",loop_control
i,"{
        for (int i = 0; i < TestHelper.RACE_DEFAULT_LOOPS; i++) {
            final BehaviorProcessor<Object> p = BehaviorProcessor.create();

            final TestSubscriber<Object> ts1 = p.test();
            final TestSubscriber<Object> ts2 = p.test();
            final TestSubscriber<Object> ts3 = p.test();

            Runnable r1 = new Runnable() {
                @Override
                public void run() {
                    ts1.cancel();
                }
            };

            Runnable r2 = new Runnable() {
                @Override
                public void run() {
                    ts2.cancel();
                }
            };

            TestHelper.race(r1, r2);

            p.onNext(1);
            ts3.assertValuesOnly(1);
        }
    }",loop_control
i,"{
        for (int i = 0; i < TestHelper.RACE_DEFAULT_LOOPS; i++) {
            final BehaviorProcessor<Object> p = BehaviorProcessor.createDefault((Object)1);

            final TestSubscriber[] ts = { null };

            Runnable r1 = new Runnable() {
                @Override
                public void run() {
                    ts[0] = p.test();
                }
            };

            Runnable r2 = new Runnable() {
                @Override
                public void run() {
                    p.onNext(2);
                }
            };

            TestHelper.race(r1, r2);

            if (ts[0].values().size() == 1) {
                ts[0].assertValue(2).assertNoErrors().assertNotComplete();
            } else {
                ts[0].assertValues(1, 2).assertNoErrors().assertNotComplete();
            }
        }
    }",loop_control
pp,"{
        final BehaviorProcessor<Integer> pp = BehaviorProcessor.create();

        Schedulers.single().scheduleDirect(new Runnable() {
            @Override
            public void run() {
                while (!pp.hasSubscribers()) {
                    try {
                        Thread.sleep(1);
                    } catch (InterruptedException ex) {
                        return;
                    }
                }

                for (int i = 1; i <= 10; i++) {
                    while (!pp.offer(i)) { }
                }
                pp.onComplete();
            }
        });

        Thread.sleep(1);

        pp.test()
        .awaitDone(5, TimeUnit.SECONDS)
        .assertResult(1, 2, 3, 4, 5, 6, 7, 8, 9, 10);
    }",maybe_loop_control
i,"{
        final BehaviorProcessor<Integer> pp = BehaviorProcessor.create();

        Schedulers.single().scheduleDirect(new Runnable() {
            @Override
            public void run() {
                while (!pp.hasSubscribers()) {
                    try {
                        Thread.sleep(1);
                    } catch (InterruptedException ex) {
                        return;
                    }
                }

                for (int i = 1; i <= 10; i++) {
                    while (!pp.offer(i)) { }
                }
                pp.onComplete();
            }
        });

        Thread.sleep(1);

        pp.test()
        .awaitDone(5, TimeUnit.SECONDS)
        .assertResult(1, 2, 3, 4, 5, 6, 7, 8, 9, 10);
    }",loop_control
i,"{
        for (int i = 0; i < TestHelper.RACE_DEFAULT_LOOPS; i++) {
            final BehaviorProcessor<Object> p = BehaviorProcessor.create();

            final TestSubscriber<Object> ts = new TestSubscriber<>();

            Runnable r1 = new Runnable() {
                @Override
                public void run() {
                    p.subscribe(ts);
                }
            };

            Runnable r2 = new Runnable() {
                @Override
                public void run() {
                    p.onComplete();
                }
            };

            TestHelper.race(r1, r2);

            ts.assertResult();
        }
    }",loop_control
i,"{
        for (int i = 0; i < TestHelper.RACE_DEFAULT_LOOPS; i++) {
            final BehaviorProcessor<Object> p = BehaviorProcessor.create();

            final TestSubscriber<Object> ts = new TestSubscriber<>();

            final TestException ex = new TestException();

            Runnable r1 = new Runnable() {
                @Override
                public void run() {
                    p.subscribe(ts);
                }
            };

            Runnable r2 = new Runnable() {
                @Override
                public void run() {
                    p.onError(ex);
                }
            };

            TestHelper.race(r1, r2);

            ts.assertFailure(TestException.class);
        }
    }",loop_control
i,"{
        for (int i = 0; i < TestHelper.RACE_DEFAULT_LOOPS; i++) {
            final BehaviorProcessor<Integer> pp = BehaviorProcessor.create();

            final TestSubscriber<Integer> ts = pp.test(1);

            Runnable r1 = new Runnable() {
                @Override
                public void run() {
                    for (int i = 0; i < 2; i++) {
                        while (!pp.offer(i)) { }
                    }
                }
            };

            Runnable r2 = new Runnable() {
                @Override
                public void run() {
                    ts.cancel();
                }
            };

            TestHelper.race(r1, r2);

            if (ts.values().size() > 0) {
                ts.assertValuesOnly(0);
            } else {
                ts.assertEmpty();
            }
        }
    }",loop_control
pp,"{
        for (int i = 0; i < TestHelper.RACE_DEFAULT_LOOPS; i++) {
            final BehaviorProcessor<Integer> pp = BehaviorProcessor.create();

            final TestSubscriber<Integer> ts = pp.test(1);

            Runnable r1 = new Runnable() {
                @Override
                public void run() {
                    for (int i = 0; i < 2; i++) {
                        while (!pp.offer(i)) { }
                    }
                }
            };

            Runnable r2 = new Runnable() {
                @Override
                public void run() {
                    ts.cancel();
                }
            };

            TestHelper.race(r1, r2);

            if (ts.values().size() > 0) {
                ts.assertValuesOnly(0);
            } else {
                ts.assertEmpty();
            }
        }
    }",maybe_loop_control
i,"{
        for (int i = 0; i < TestHelper.RACE_LONG_LOOPS; i++) {

            BehaviorProcessor<Integer> bp = BehaviorProcessor.create();
            bp.onNext(1);

            TestSubscriber<Integer> ts = new TestSubscriber<>();

            final BehaviorSubscription<Integer> bs = new BehaviorSubscription<>(ts, bp);
            ts.onSubscribe(bs);

            Runnable r1 = new Runnable() {
                @Override
                public void run() {
                    bs.emitFirst();
                }
            };
            Runnable r2 = new Runnable() {
                @Override
                public void run() {
                    bs.cancel();
                }
            };

            TestHelper.race(r1, r2);
        }
    }",loop_control
i,"{
        for (int i = 0; i < TestHelper.RACE_LONG_LOOPS; i++) {

            BehaviorProcessor<Integer> bp = BehaviorProcessor.create();
            bp.onNext(1);

            TestSubscriber<Integer> ts = new TestSubscriber<>();

            final BehaviorSubscription<Integer> bs = new BehaviorSubscription<>(ts, bp);
            ts.onSubscribe(bs);

            Runnable r1 = new Runnable() {
                @Override
                public void run() {
                    bs.emitNext(2, 0);
                }
            };
            Runnable r2 = new Runnable() {
                @Override
                public void run() {
                    bs.cancel();
                }
            };

            TestHelper.race(r1, r2);
        }
    }",loop_control
i,"{
        for (int i = 0; i < TestHelper.RACE_DEFAULT_LOOPS; i++) {
            final int[] calls = { 0 };
            final UnicastProcessor<Object> up = UnicastProcessor.create(100, new Runnable() {
                @Override
                public void run() {
                    calls[0]++;
                }
            });

            final TestSubscriber<Object> ts = up.test();

            Runnable r1 = new Runnable() {
                @Override
                public void run() {
                    ts.cancel();
                }
            };

            Runnable r2 = new Runnable() {
                @Override
                public void run() {
                    up.onComplete();
                }
            };

            TestHelper.race(r1, r2);

            assertEquals(1, calls[0]);
        }
    }",loop_control
i,"{
        for (int i = 0; i < TestHelper.RACE_DEFAULT_LOOPS; i++) {
            final UnicastProcessor<Object> p = UnicastProcessor.create();

            final TestSubscriberEx<Object> ts = new TestSubscriberEx<>().setInitialFusionMode(QueueFuseable.ANY);

            p.subscribe(ts);

            Runnable r1 = new Runnable() {
                @Override
                public void run() {
                    p.onNext(1);
                }
            };

            Runnable r2 = new Runnable() {
                @Override
                public void run() {
                    ts.cancel();
                }
            };

            TestHelper.race(r1, r2);
        }
    }",loop_control
i,"{
        for (int i = 0; i < TestHelper.RACE_DEFAULT_LOOPS; i++) {
            final UnicastProcessor<Integer> up = UnicastProcessor.create();

            final TestSubscriberEx<Integer> ts1 = new TestSubscriberEx<>();
            final TestSubscriberEx<Integer> ts2 = new TestSubscriberEx<>();

            Runnable r1 = new Runnable() {
                @Override
                public void run() {
                    up.subscribe(ts1);
                }
            };

            Runnable r2 = new Runnable() {
                @Override
                public void run() {
                    up.subscribe(ts2);
                }
            };

            TestHelper.race(r1, r2);

            if (ts1.errors().size() == 0) {
                ts2.assertFailure(IllegalStateException.class);
            } else
            if (ts2.errors().size() == 0) {
                ts1.assertFailure(IllegalStateException.class);
            } else {
                fail(""Neither TestObserver failed"");
            }
        }
    }",loop_control
j,"{
        for (int j = 0; j < TestHelper.RACE_LONG_LOOPS; j++) {
            List<Throwable> errors = TestHelper.trackPluginErrors();
            try {
                final UnicastProcessor<Integer> up = UnicastProcessor.create();

                TestObserver<Integer> to = up
                .observeOn(Schedulers.io())
                .map(Functions.<Integer>identity())
                .observeOn(Schedulers.single())
                .firstOrError()
                .test();

                for (int i = 0; up.hasSubscribers(); i++) {
                    up.onNext(i);
                }

                to
                .awaitDone(5, TimeUnit.SECONDS)
                ;

                if (!errors.isEmpty()) {
                    throw new CompositeException(errors);
                }

                to.assertResult(0);
            } finally {
                RxJavaPlugins.reset();
            }
        }
    }",loop_control
up,"{
        for (int j = 0; j < TestHelper.RACE_LONG_LOOPS; j++) {
            List<Throwable> errors = TestHelper.trackPluginErrors();
            try {
                final UnicastProcessor<Integer> up = UnicastProcessor.create();

                TestObserver<Integer> to = up
                .observeOn(Schedulers.io())
                .map(Functions.<Integer>identity())
                .observeOn(Schedulers.single())
                .firstOrError()
                .test();

                for (int i = 0; up.hasSubscribers(); i++) {
                    up.onNext(i);
                }

                to
                .awaitDone(5, TimeUnit.SECONDS)
                ;

                if (!errors.isEmpty()) {
                    throw new CompositeException(errors);
                }

                to.assertResult(0);
            } finally {
                RxJavaPlugins.reset();
            }
        }
    }",maybe_loop_control
i,"{
        try {
            for (int i = 1; i < 3; i++) {
                Observable.just(i)
                .test()
                .withTag(""testing with item="" + i)
                .assertResult(1)
                ;
            }
            throw new RuntimeException(""Should have thrown!"");
        } catch (AssertionError ex) {
            assertTrue(ex.toString(), ex.toString().contains(""testing with item=2""));
        }
    }",loop_control
i,"{
        int n = 10;
        for (int i = 0; i < n; i++) {
            TestMultiThreadedObservable onSubscribe = new TestMultiThreadedObservable(""one"", ""two"", ""three"", null,
                    ""four"", ""five"", ""six"", ""seven"", ""eight"", ""nine"");
            Observable<String> w = Observable.unsafeCreate(onSubscribe);

            BusyObserver busySubscriber = new BusyObserver();
            Observer<String> aw = serializedObserver(busySubscriber);

            w.subscribe(aw);
            onSubscribe.waitToFinish();

            System.out.println(""OnSubscribe maxConcurrentThreads: "" + onSubscribe.maxConcurrentThreads.get() + ""  Observer maxConcurrentThreads: "" + busySubscriber.maxConcurrentThreads.get());

            // we can have concurrency ...
            assertTrue(onSubscribe.maxConcurrentThreads.get() > 1);
            // ... but the onNext execution should be single threaded
            assertEquals(1, busySubscriber.maxConcurrentThreads.get());

            // this should not be the full number of items since the error should stop it before it completes all 9
            System.out.println(""onNext count: "" + busySubscriber.onNextCount.get());
            assertFalse(busySubscriber.onComplete);
            assertTrue(busySubscriber.onError);
            assertTrue(busySubscriber.onNextCount.get() < 9);
            // no onComplete because onError was invoked
            // non-deterministic because unsubscribe happens after 'waitToFinish' releases
            // so commenting out for now as this is not a critical thing to test here
            // verify(s, times(1)).unsubscribe();
        }
    }",loop_control
i,"{
        ExecutorService tp = Executors.newFixedThreadPool(20);
        List<Throwable> errors = TestHelper.trackPluginErrors();
        try {
            TestConcurrencySubscriber tw = new TestConcurrencySubscriber();
            // we need Synchronized + SafeObserver to handle synchronization plus life-cycle
            Observer<String> w = serializedObserver(new SafeObserver<>(tw));

            Future<?> f1 = tp.submit(new OnNextThread(w, 12000));
            Future<?> f2 = tp.submit(new OnNextThread(w, 5000));
            Future<?> f3 = tp.submit(new OnNextThread(w, 75000));
            Future<?> f4 = tp.submit(new OnNextThread(w, 13500));
            Future<?> f5 = tp.submit(new OnNextThread(w, 22000));
            Future<?> f6 = tp.submit(new OnNextThread(w, 15000));
            Future<?> f7 = tp.submit(new OnNextThread(w, 7500));
            Future<?> f8 = tp.submit(new OnNextThread(w, 23500));

            Future<?> f10 = tp.submit(new CompletionThread(w, TestConcurrencySubscriberEvent.onComplete, f1, f2, f3, f4));
            try {
                Thread.sleep(1);
            } catch (InterruptedException e) {
                // ignore
            }
            Future<?> f11 = tp.submit(new CompletionThread(w, TestConcurrencySubscriberEvent.onComplete, f4, f6, f7));
            Future<?> f12 = tp.submit(new CompletionThread(w, TestConcurrencySubscriberEvent.onComplete, f4, f6, f7));
            Future<?> f13 = tp.submit(new CompletionThread(w, TestConcurrencySubscriberEvent.onComplete, f4, f6, f7));
            Future<?> f14 = tp.submit(new CompletionThread(w, TestConcurrencySubscriberEvent.onComplete, f4, f6, f7));
            // // the next 4 onError events should wait on same as f10
            Future<?> f15 = tp.submit(new CompletionThread(w, TestConcurrencySubscriberEvent.onError, f1, f2, f3, f4));
            Future<?> f16 = tp.submit(new CompletionThread(w, TestConcurrencySubscriberEvent.onError, f1, f2, f3, f4));
            Future<?> f17 = tp.submit(new CompletionThread(w, TestConcurrencySubscriberEvent.onError, f1, f2, f3, f4));
            Future<?> f18 = tp.submit(new CompletionThread(w, TestConcurrencySubscriberEvent.onError, f1, f2, f3, f4));

            waitOnThreads(f1, f2, f3, f4, f5, f6, f7, f8, f10, f11, f12, f13, f14, f15, f16, f17, f18);
            @SuppressWarnings(""unused"")
            int numNextEvents = tw.assertEvents(null); // no check of type since we don't want to test barging results here, just interleaving behavior
            //            System.out.println(""Number of events executed: "" + numNextEvents);

            for (int i = 0; i < errors.size(); i++) {
                TestHelper.assertUndeliverable(errors, i, RuntimeException.class);
            }
        } catch (Throwable e) {
            fail(""Concurrency test failed: "" + e.getMessage());
            e.printStackTrace();
        } finally {
            tp.shutdown();
            try {
                tp.awaitTermination(5000, TimeUnit.MILLISECONDS);
            } catch (InterruptedException e) {
                e.printStackTrace();
            }

            RxJavaPlugins.reset();
        }
    }",loop_control
i,"{
        ExecutorService tp1 = Executors.newFixedThreadPool(1);
        ExecutorService tp2 = Executors.newFixedThreadPool(1);
        try {
            int n = 10;
            for (int i = 0; i < n; i++) {
                final CountDownLatch firstOnNext = new CountDownLatch(1);
                final CountDownLatch onNextCount = new CountDownLatch(2);
                final CountDownLatch latch = new CountDownLatch(1);
                final CountDownLatch running = new CountDownLatch(2);

                TestObserverEx<String> to = new TestObserverEx<>(new DefaultObserver<String>() {

                    @Override
                    public void onComplete() {

                    }

                    @Override
                    public void onError(Throwable e) {

                    }

                    @Override
                    public void onNext(String t) {
                        firstOnNext.countDown();
                        // force it to take time when delivering so the second one is enqueued
                        try {
                            latch.await();
                        } catch (InterruptedException e) {
                        }
                    }

                });
                Observer<String> o = serializedObserver(to);

                Future<?> f1 = tp1.submit(new OnNextThread(o, 1, onNextCount, running));
                Future<?> f2 = tp2.submit(new OnNextThread(o, 1, onNextCount, running));

                running.await(); // let one of the OnNextThread actually run before proceeding

                firstOnNext.await();

                Thread t1 = to.lastThread();
                System.out.println(""first onNext on thread: "" + t1);

                latch.countDown();

                waitOnThreads(f1, f2);
                // not completed yet

                assertEquals(2, to.values().size());

                Thread t2 = to.lastThread();
                System.out.println(""second onNext on thread: "" + t2);

                assertSame(t1, t2);

                System.out.println(to.values());
                o.onComplete();
                System.out.println(to.values());
            }
        } finally {
            tp1.shutdown();
            tp2.shutdown();
        }
    }",loop_control
f,"{
        for (Future<?> f : futures) {
            try {
                f.get(20, TimeUnit.SECONDS);
            } catch (Throwable e) {
                System.err.println(""Failed while waiting on future."");
                e.printStackTrace();
            }
        }
    }",iterator
bs,"{
        return Observable.unsafeCreate(new ObservableSource<String>() {

            @Override
            public void subscribe(Observer<? super String> observer) {
                Disposable bs = Disposable.empty();
                observer.onSubscribe(bs);
                while (!bs.isDisposed()) {
                    observer.onNext(""onNext"");
                    produced.incrementAndGet();
                }
            }

        }).subscribeOn(Schedulers.newThread());
    }",maybe_loop_control
i,"{

        private final CountDownLatch latch;
        private final Observer<String> observer;
        private final int numStringsToSend;
        final AtomicInteger produced;
        private final CountDownLatch running;

        OnNextThread(Observer<String> observer, int numStringsToSend, CountDownLatch latch, CountDownLatch running) {
            this(observer, numStringsToSend, new AtomicInteger(), latch, running);
        }

        OnNextThread(Observer<String> observer, int numStringsToSend, AtomicInteger produced) {
            this(observer, numStringsToSend, produced, null, null);
        }

        OnNextThread(Observer<String> observer, int numStringsToSend, AtomicInteger produced, CountDownLatch latch, CountDownLatch running) {
            this.observer = observer;
            this.numStringsToSend = numStringsToSend;
            this.produced = produced;
            this.latch = latch;
            this.running = running;
        }

        OnNextThread(Observer<String> observer, int numStringsToSend) {
            this(observer, numStringsToSend, new AtomicInteger());
        }

        @Override
        public void run() {
            if (running != null) {
                running.countDown();
            }
            for (int i = 0; i < numStringsToSend; i++) {
                observer.onNext(Thread.currentThread().getId() + ""-"" + i);
                if (latch != null) {
                    latch.countDown();
                }
                produced.incrementAndGet();
            }
        }
    }",loop_control
f,"{

        private final Observer<String> observer;
        private final TestConcurrencySubscriberEvent event;
        private final Future<?>[] waitOnThese;

        CompletionThread(Observer<String> Observer, TestConcurrencySubscriberEvent event, Future<?>... waitOnThese) {
            this.observer = Observer;
            this.event = event;
            this.waitOnThese = waitOnThese;
        }

        @Override
        public void run() {
            /* if we have 'waitOnThese' futures, we'll wait on them before proceeding */
            if (waitOnThese != null) {
                for (Future<?> f : waitOnThese) {
                    try {
                        f.get();
                    } catch (Throwable e) {
                        System.err.println(""Error while waiting on future in CompletionThread"");
                    }
                }
            }

            /* send the event */
            if (event == TestConcurrencySubscriberEvent.onError) {
                observer.onError(new RuntimeException(""mocked exception""));
            } else if (event == TestConcurrencySubscriberEvent.onComplete) {
                observer.onComplete();

            } else {
                throw new IllegalArgumentException(""Expecting either onError or onComplete"");
            }
        }
    }",iterator
i,"{

        /**
         * used to store the order and number of events received.
         */
        private final LinkedBlockingQueue<TestConcurrencySubscriberEvent> events = new LinkedBlockingQueue<>();
        private final int waitTime;

        @SuppressWarnings(""unused"")
        TestConcurrencySubscriber(int waitTimeInNext) {
            this.waitTime = waitTimeInNext;
        }

        TestConcurrencySubscriber() {
            this.waitTime = 0;
        }

        @Override
        public void onComplete() {
            events.add(TestConcurrencySubscriberEvent.onComplete);
        }

        @Override
        public void onError(Throwable e) {
            events.add(TestConcurrencySubscriberEvent.onError);
        }

        @Override
        public void onNext(String args) {
            events.add(TestConcurrencySubscriberEvent.onNext);
            // do some artificial work to make the thread scheduling/timing vary
            int s = 0;
            for (int i = 0; i < 20; i++) {
                s += s * i;
            }

            if (waitTime > 0) {
                try {
                    Thread.sleep(waitTime);
                } catch (InterruptedException e) {
                    // ignore
                }
            }
        }

        /**
         * Assert the order of events is correct and return the number of onNext executions.
         *
         * @param expectedEndingEvent the expected last event
         * @return int count of onNext calls
         * @throws IllegalStateException
         *             If order of events was invalid.
         */
        public int assertEvents(TestConcurrencySubscriberEvent expectedEndingEvent) throws IllegalStateException {
            int nextCount = 0;
            boolean finished = false;
            for (TestConcurrencySubscriberEvent e : events) {
                if (e == TestConcurrencySubscriberEvent.onNext) {
                    if (finished) {
                        // already finished, we shouldn't get this again
                        throw new IllegalStateException(""Received onNext but we're already finished."");
                    }
                    nextCount++;
                } else if (e == TestConcurrencySubscriberEvent.onError) {
                    if (finished) {
                        // already finished, we shouldn't get this again
                        throw new IllegalStateException(""Received onError but we're already finished."");
                    }
                    if (expectedEndingEvent != null && TestConcurrencySubscriberEvent.onError != expectedEndingEvent) {
                        throw new IllegalStateException(""Received onError ending event but expected "" + expectedEndingEvent);
                    }
                    finished = true;
                } else if (e == TestConcurrencySubscriberEvent.onComplete) {
                    if (finished) {
                        // already finished, we shouldn't get this again
                        throw new IllegalStateException(""Received onComplete but we're already finished."");
                    }
                    if (expectedEndingEvent != null && TestConcurrencySubscriberEvent.onComplete != expectedEndingEvent) {
                        throw new IllegalStateException(""Received onComplete ending event but expected "" + expectedEndingEvent);
                    }
                    finished = true;
                }
            }

            return nextCount;
        }

    }",loop_control
e,"{

        /**
         * used to store the order and number of events received.
         */
        private final LinkedBlockingQueue<TestConcurrencySubscriberEvent> events = new LinkedBlockingQueue<>();
        private final int waitTime;

        @SuppressWarnings(""unused"")
        TestConcurrencySubscriber(int waitTimeInNext) {
            this.waitTime = waitTimeInNext;
        }

        TestConcurrencySubscriber() {
            this.waitTime = 0;
        }

        @Override
        public void onComplete() {
            events.add(TestConcurrencySubscriberEvent.onComplete);
        }

        @Override
        public void onError(Throwable e) {
            events.add(TestConcurrencySubscriberEvent.onError);
        }

        @Override
        public void onNext(String args) {
            events.add(TestConcurrencySubscriberEvent.onNext);
            // do some artificial work to make the thread scheduling/timing vary
            int s = 0;
            for (int i = 0; i < 20; i++) {
                s += s * i;
            }

            if (waitTime > 0) {
                try {
                    Thread.sleep(waitTime);
                } catch (InterruptedException e) {
                    // ignore
                }
            }
        }

        /**
         * Assert the order of events is correct and return the number of onNext executions.
         *
         * @param expectedEndingEvent the expected last event
         * @return int count of onNext calls
         * @throws IllegalStateException
         *             If order of events was invalid.
         */
        public int assertEvents(TestConcurrencySubscriberEvent expectedEndingEvent) throws IllegalStateException {
            int nextCount = 0;
            boolean finished = false;
            for (TestConcurrencySubscriberEvent e : events) {
                if (e == TestConcurrencySubscriberEvent.onNext) {
                    if (finished) {
                        // already finished, we shouldn't get this again
                        throw new IllegalStateException(""Received onNext but we're already finished."");
                    }
                    nextCount++;
                } else if (e == TestConcurrencySubscriberEvent.onError) {
                    if (finished) {
                        // already finished, we shouldn't get this again
                        throw new IllegalStateException(""Received onError but we're already finished."");
                    }
                    if (expectedEndingEvent != null && TestConcurrencySubscriberEvent.onError != expectedEndingEvent) {
                        throw new IllegalStateException(""Received onError ending event but expected "" + expectedEndingEvent);
                    }
                    finished = true;
                } else if (e == TestConcurrencySubscriberEvent.onComplete) {
                    if (finished) {
                        // already finished, we shouldn't get this again
                        throw new IllegalStateException(""Received onComplete but we're already finished."");
                    }
                    if (expectedEndingEvent != null && TestConcurrencySubscriberEvent.onComplete != expectedEndingEvent) {
                        throw new IllegalStateException(""Received onComplete ending event but expected "" + expectedEndingEvent);
                    }
                    finished = true;
                }
            }

            return nextCount;
        }

    }",iterator
s,"{

        final String[] values;
        private Thread t;

        TestSingleThreadedObservable(final String... values) {
            this.values = values;

        }

        @Override
        public void subscribe(final Observer<? super String> observer) {
            observer.onSubscribe(Disposable.empty());
            System.out.println(""TestSingleThreadedObservable subscribed to ..."");
            t = new Thread(new Runnable() {

                @Override
                public void run() {
                    try {
                        System.out.println(""running TestSingleThreadedObservable thread"");
                        for (String s : values) {
                            System.out.println(""TestSingleThreadedObservable onNext: "" + s);
                            observer.onNext(s);
                        }
                        observer.onComplete();
                    } catch (Throwable e) {
                        throw new RuntimeException(e);
                    }
                }

            });
            System.out.println(""starting TestSingleThreadedObservable thread"");
            t.start();
            System.out.println(""done starting TestSingleThreadedObservable thread"");
        }

        public void waitToFinish() {
            try {
                t.join();
            } catch (InterruptedException e) {
                throw new RuntimeException(e);
            }
        }

    }",iterator
s,"{

        final String[] values;
        Thread t;
        AtomicInteger threadsRunning = new AtomicInteger();
        AtomicInteger maxConcurrentThreads = new AtomicInteger();
        ExecutorService threadPool;

        TestMultiThreadedObservable(String... values) {
            this.values = values;
            this.threadPool = Executors.newCachedThreadPool();
        }

        @Override
        public void subscribe(final Observer<? super String> observer) {
            observer.onSubscribe(Disposable.empty());
            final NullPointerException npe = new NullPointerException();
            System.out.println(""TestMultiThreadedObservable subscribed to ..."");
            t = new Thread(new Runnable() {

                @Override
                public void run() {
                    try {
                        System.out.println(""running TestMultiThreadedObservable thread"");
                        int j = 0;
                        for (final String s : values) {
                            final int fj = ++j;
                            threadPool.execute(new Runnable() {

                                @Override
                                public void run() {
                                    threadsRunning.incrementAndGet();
                                    try {
                                        // perform onNext call
                                        System.out.println(""TestMultiThreadedObservable onNext: "" + s + "" on thread "" + Thread.currentThread().getName());
                                        if (s == null) {
                                            // force an error
                                            throw npe;
                                        } else {
                                             // allow the exception to queue up
                                            int sleep = (fj % 3) * 10;
                                            if (sleep != 0) {
                                                Thread.sleep(sleep);
                                            }
                                        }
                                        observer.onNext(s);
                                        // capture 'maxThreads'
                                        int concurrentThreads = threadsRunning.get();
                                        int maxThreads = maxConcurrentThreads.get();
                                        if (concurrentThreads > maxThreads) {
                                            maxConcurrentThreads.compareAndSet(maxThreads, concurrentThreads);
                                        }
                                    } catch (Throwable e) {
                                        observer.onError(e);
                                    } finally {
                                        threadsRunning.decrementAndGet();
                                    }
                                }
                            });
                        }
                        // we are done spawning threads
                        threadPool.shutdown();
                    } catch (Throwable e) {
                        throw new RuntimeException(e);
                    }

                    // wait until all threads are done, then mark it as COMPLETED
                    try {
                        // wait for all the threads to finish
                        if (!threadPool.awaitTermination(5, TimeUnit.SECONDS)) {
                            System.out.println(""Threadpool did not terminate in time."");
                        }
                    } catch (InterruptedException e) {
                        throw new RuntimeException(e);
                    }
                    observer.onComplete();
                }
            });
            System.out.println(""starting TestMultiThreadedObservable thread"");
            t.start();
            System.out.println(""done starting TestMultiThreadedObservable thread"");
        }

        public void waitToFinish() {
            try {
                t.join();
            } catch (InterruptedException e) {
                throw new RuntimeException(e);
            }
        }
    }",iterator
i,"{
        for (int i = 0; i < TestHelper.RACE_DEFAULT_LOOPS; i++) {
            TestObserver<Integer> to = new TestObserver<>();

            final SerializedObserver<Integer> so = new SerializedObserver<>(to);

            Disposable d = Disposable.empty();

            so.onSubscribe(d);

            Runnable r = new Runnable() {
                @Override
                public void run() {
                    so.onComplete();
                }
            };

            TestHelper.race(r, r);

            to.awaitDone(5, TimeUnit.SECONDS)
            .assertResult();
        }

    }",loop_control
i,"{
        for (int i = 0; i < TestHelper.RACE_DEFAULT_LOOPS; i++) {
            TestObserver<Integer> to = new TestObserver<>();

            final SerializedObserver<Integer> so = new SerializedObserver<>(to);

            Disposable d = Disposable.empty();

            so.onSubscribe(d);

            Runnable r1 = new Runnable() {
                @Override
                public void run() {
                    so.onComplete();
                }
            };

            Runnable r2 = new Runnable() {
                @Override
                public void run() {
                    so.onNext(1);
                }
            };

            TestHelper.race(r1, r2);

            to.awaitDone(5, TimeUnit.SECONDS)
            .assertNoErrors()
            .assertComplete();

            assertTrue(to.values().size() <= 1);
        }

    }",loop_control
i,"{
        for (int i = 0; i < TestHelper.RACE_DEFAULT_LOOPS; i++) {
            TestObserver<Integer> to = new TestObserver<>();

            final SerializedObserver<Integer> so = new SerializedObserver<>(to);

            Disposable d = Disposable.empty();

            so.onSubscribe(d);

            final Throwable ex = new TestException();

            Runnable r1 = new Runnable() {
                @Override
                public void run() {
                    so.onError(ex);
                }
            };

            Runnable r2 = new Runnable() {
                @Override
                public void run() {
                    so.onNext(1);
                }
            };

            TestHelper.race(r1, r2);

            to.awaitDone(5, TimeUnit.SECONDS)
            .assertError(ex)
            .assertNotComplete();

            assertTrue(to.values().size() <= 1);
        }

    }",loop_control
i,"{
        for (int i = 0; i < TestHelper.RACE_DEFAULT_LOOPS; i++) {
            TestObserver<Integer> to = new TestObserver<>();

            final SerializedObserver<Integer> so = new SerializedObserver<>(to, true);

            Disposable d = Disposable.empty();

            so.onSubscribe(d);

            final Throwable ex = new TestException();

            Runnable r1 = new Runnable() {
                @Override
                public void run() {
                    so.onError(ex);
                }
            };

            Runnable r2 = new Runnable() {
                @Override
                public void run() {
                    so.onNext(1);
                }
            };

            TestHelper.race(r1, r2);

            to.awaitDone(5, TimeUnit.SECONDS)
            .assertError(ex)
            .assertNotComplete();

            assertTrue(to.values().size() <= 1);
        }

    }",loop_control
i,"{
        for (int i = 0; i < TestHelper.RACE_DEFAULT_LOOPS; i++) {

            List<Throwable> errors = TestHelper.trackPluginErrors();
            try {
                TestObserverEx<Integer> to = new TestObserverEx<>();

                final SerializedObserver<Integer> so = new SerializedObserver<>(to);

                Disposable d = Disposable.empty();

                so.onSubscribe(d);

                final Throwable ex = new TestException();

                Runnable r1 = new Runnable() {
                    @Override
                    public void run() {
                        so.onError(ex);
                    }
                };

                Runnable r2 = new Runnable() {
                    @Override
                    public void run() {
                        so.onComplete();
                    }
                };

                TestHelper.race(r1, r2);

                to.awaitDone(5, TimeUnit.SECONDS);

                if (to.completions() != 0) {
                    to.assertResult();
                } else {
                    to.assertFailure(TestException.class).assertError(ex);
                }

                for (Throwable e : errors) {
                    assertTrue(e.toString(), e.getCause() instanceof TestException);
                }
            } finally {
                RxJavaPlugins.reset();
            }
        }

    }",loop_control
e,"{
        for (int i = 0; i < TestHelper.RACE_DEFAULT_LOOPS; i++) {

            List<Throwable> errors = TestHelper.trackPluginErrors();
            try {
                TestObserverEx<Integer> to = new TestObserverEx<>();

                final SerializedObserver<Integer> so = new SerializedObserver<>(to);

                Disposable d = Disposable.empty();

                so.onSubscribe(d);

                final Throwable ex = new TestException();

                Runnable r1 = new Runnable() {
                    @Override
                    public void run() {
                        so.onError(ex);
                    }
                };

                Runnable r2 = new Runnable() {
                    @Override
                    public void run() {
                        so.onComplete();
                    }
                };

                TestHelper.race(r1, r2);

                to.awaitDone(5, TimeUnit.SECONDS);

                if (to.completions() != 0) {
                    to.assertResult();
                } else {
                    to.assertFailure(TestException.class).assertError(ex);
                }

                for (Throwable e : errors) {
                    assertTrue(e.toString(), e.getCause() instanceof TestException);
                }
            } finally {
                RxJavaPlugins.reset();
            }
        }

    }",iterator
i,"{
        private final Statement base;
        private final Description description;

        RetryStatement(Statement base, Description description) {
            this.base = base;
            this.description = description;
        }

        @Override
        public void evaluate() throws Throwable {
            Throwable caughtThrowable = null;

            for (int i = 0; i < retryCount; i++) {
                try {
                    base.evaluate();
                    return;
                } catch (Throwable t) {
                    caughtThrowable = t;
                    System.err.println(description.getDisplayName() + "": run "" + (i + 1) + "" failed"");
                    int n = sleep;
                    if (backoff && i != 0) {
                        n = n * (2 << i);
                    }
                    Thread.sleep(n);
                }
            }
            System.err.println(description.getDisplayName() + "": giving up after "" + retryCount + "" failures"");
            throw caughtThrowable;
        }
    }",loop_control
i,"{
        List<Throwable> list = trackPluginErrors();
        try {
            final CountDownLatch cdl = new CountDownLatch(1);

            FlowableSubscriber<Object> bad = new FlowableSubscriber<Object>() {

                @Override
                public void onSubscribe(Subscription s) {
                    try {
                        s.request(-99);
                        s.cancel();
                        s.cancel();
                    } finally {
                        cdl.countDown();
                    }
                }

                @Override
                public void onNext(Object t) {

                }

                @Override
                public void onError(Throwable t) {

                }

                @Override
                public void onComplete() {

                }

            };

            @SuppressWarnings(""unchecked"")
            FlowableSubscriber<Object>[] subs = new FlowableSubscriber[source.parallelism()];
            subs[0] = bad;
            for (int i = 1; i < subs.length; i++) {
                subs[i] = NoOpConsumer.INSTANCE;
            }
            source.subscribe(subs);

            try {
                assertTrue(cdl.await(5, TimeUnit.SECONDS));
            } catch (InterruptedException ex) {
                throw new AssertionError(ex.getMessage());
            }

            assertTrue(list.toString(), list.get(0) instanceof IllegalArgumentException);
            assertEquals(""n > 0 required but it was -99"", list.get(0).getMessage());
        } finally {
            RxJavaPlugins.setErrorHandler(null);
        }
    }",loop_control
count,"{
        final AtomicInteger count = new AtomicInteger(2);
        final CountDownLatch cdl = new CountDownLatch(2);

        final Throwable[] errors = { null, null };

        s.scheduleDirect(new Runnable() {
            @Override
            public void run() {
                if (count.decrementAndGet() != 0) {
                    while (count.get() != 0) { }
                }

                try {
                    try {
                        r1.run();
                    } catch (Throwable ex) {
                        errors[0] = ex;
                    }
                } finally {
                    cdl.countDown();
                }
            }
        });

        if (count.decrementAndGet() != 0) {
            while (count.get() != 0) { }
        }

        try {
            try {
                r2.run();
            } catch (Throwable ex) {
                errors[1] = ex;
            }
        } finally {
            cdl.countDown();
        }

        try {
            if (!cdl.await(5, TimeUnit.SECONDS)) {
                throw new AssertionError(""The wait timed out!"");
            }
        } catch (InterruptedException ex) {
            throw new RuntimeException(ex);
        }
        if (errors[0] != null && errors[1] == null) {
            throw ExceptionHelper.wrapOrThrow(errors[0]);
        }

        if (errors[0] == null && errors[1] != null) {
            throw ExceptionHelper.wrapOrThrow(errors[1]);
        }

        if (errors[0] != null && errors[1] != null) {
            throw new CompositeException(errors);
        }
    }",maybe_loop_control
o,"{
        try {
            Method m = enumClass.getMethod(""values"");
            m.setAccessible(true);
            Method e = enumClass.getMethod(""valueOf"", String.class);
            m.setAccessible(true);

            for (Enum<E> o : (Enum<E>[])m.invoke(null)) {
                assertSame(o, e.invoke(null, o.name()));
            }

        } catch (Throwable ex) {
            throw ExceptionHelper.wrapOrThrow(ex);
        }
    }",iterator
i,"{
        List<Throwable> errors = trackPluginErrors();
        try {
            final Boolean[] b = { null, null, null, null };
            final CountDownLatch cdl = new CountDownLatch(2);

            ParallelFlowable<T> source = new ParallelFlowable<T>() {
                @Override
                public void subscribe(Subscriber<? super T>[] subscribers) {
                    for (int i = 0; i < subscribers.length; i++) {
                        try {
                            BooleanSubscription bs1 = new BooleanSubscription();

                            subscribers[i].onSubscribe(bs1);

                            BooleanSubscription bs2 = new BooleanSubscription();

                            subscribers[i].onSubscribe(bs2);

                            b[i * 2 + 0] = bs1.isCancelled();
                            b[i * 2 + 1] = bs2.isCancelled();
                        } finally {
                            cdl.countDown();
                        }
                    }
                }

                @Override
                public int parallelism() {
                    return 2;
                }
            };

            ParallelFlowable<?> out = transform.apply(source);

            out.subscribe(new Subscriber[] { NoOpConsumer.INSTANCE, NoOpConsumer.INSTANCE });

            try {
                assertTrue(""Timed out"", cdl.await(5, TimeUnit.SECONDS));
            } catch (InterruptedException ex) {
                throw ExceptionHelper.wrapOrThrow(ex);
            }

            assertEquals(""Rail 1 First disposed?"", false, b[0]);
            assertEquals(""Rail 1 Second not disposed?"", true, b[1]);

            assertEquals(""Rail 2 First disposed?"", false, b[2]);
            assertEquals(""Rail 2 Second not disposed?"", true, b[3]);

            assertError(errors, 0, IllegalStateException.class, ""Subscription already set!"");
            assertError(errors, 1, IllegalStateException.class, ""Subscription already set!"");
        } catch (Throwable ex) {
            throw ExceptionHelper.wrapOrThrow(ex);
        } finally {
            RxJavaPlugins.reset();
        }
    }",loop_control
i,"{
        List<Throwable> errors = trackPluginErrors();
        try {
            final Boolean[] b = { null, null, null, null };
            final CountDownLatch cdl = new CountDownLatch(2);

            ParallelFlowable<T> source = new ParallelFlowable<T>() {
                @Override
                public void subscribe(Subscriber<? super T>[] subscribers) {
                    for (int i = 0; i < subscribers.length; i++) {
                        try {
                            BooleanSubscription bs1 = new BooleanSubscription();

                            subscribers[i].onSubscribe(bs1);

                            BooleanSubscription bs2 = new BooleanSubscription();

                            subscribers[i].onSubscribe(bs2);

                            b[i * 2 + 0] = bs1.isCancelled();
                            b[i * 2 + 1] = bs2.isCancelled();
                        } finally {
                            cdl.countDown();
                        }
                    }
                }

                @Override
                public int parallelism() {
                    return 2;
                }
            };

            Flowable<?> out = transform.apply(source);

            out.subscribe(NoOpConsumer.INSTANCE);

            try {
                assertTrue(""Timed out"", cdl.await(5, TimeUnit.SECONDS));
            } catch (InterruptedException ex) {
                throw ExceptionHelper.wrapOrThrow(ex);
            }

            assertEquals(""Rail 1 First disposed?"", false, b[0]);
            assertEquals(""Rail 1 Second not disposed?"", true, b[1]);

            assertEquals(""Rail 2 First disposed?"", false, b[2]);
            assertEquals(""Rail 2 Second not disposed?"", true, b[3]);

            assertError(errors, 0, IllegalStateException.class, ""Subscription already set!"");
            assertError(errors, 1, IllegalStateException.class, ""Subscription already set!"");
        } catch (Throwable ex) {
            throw ExceptionHelper.wrapOrThrow(ex);
        } finally {
            RxJavaPlugins.reset();
        }
    }",loop_control
i,"{
        ts
        .assertSubscribed()
        .assertError(CompositeException.class)
        .assertNotComplete();

        List<Throwable> list = compositeList(ts.errors().get(0));

        assertEquals(classes.length, list.size());

        for (int i = 0; i < classes.length; i++) {
            assertError(list, i, classes[i]);
        }
    }",loop_control
i,"{
        ts
        .assertSubscribed()
        .assertError(CompositeException.class)
        .assertNotComplete();

        List<Throwable> list = compositeList(ts.errors().get(0));

        assertEquals(classes.length, list.size());

        for (int i = 0; i < classes.length; i += 2) {
            assertError(list, i, (Class<Throwable>)classes[i], (String)classes[i + 1]);
        }
    }",loop_control
i,"{
        to
        .assertSubscribed()
        .assertError(CompositeException.class)
        .assertNotComplete();

        List<Throwable> list = compositeList(to.errors().get(0));

        assertEquals(classes.length, list.size());

        for (int i = 0; i < classes.length; i++) {
            assertError(list, i, classes[i]);
        }
    }",loop_control
i,"{
        to
        .assertSubscribed()
        .assertError(CompositeException.class)
        .assertNotComplete();

        List<Throwable> list = compositeList(to.errors().get(0));

        assertEquals(classes.length, list.size());

        for (int i = 0; i < classes.length; i += 2) {
            assertError(list, i, (Class<Throwable>)classes[i], (String)classes[i + 1]);
        }
    }",loop_control
v,"{
        for (T v : values) {
            p.onNext(v);
        }
        p.onComplete();
    }",iterator
v,"{
        for (T v : values) {
            p.onNext(v);
        }
        p.onComplete();
    }",iterator
i,"{
        int n = source.parallelism();

        @SuppressWarnings(""unchecked"")
        TestSubscriber<Object>[] tss = new TestSubscriber[n + 1];
        for (int i = 0; i <= n; i++) {
            tss[i] = new TestSubscriber<>().withTag("""" + i);
        }

        source.subscribe(tss);

        for (int i = 0; i <= n; i++) {
            tss[i].assertFailure(IllegalArgumentException.class);
        }
    }",loop_control
t,"{
        Set<T> expectedSet = new HashSet<>(Arrays.asList(values));
        for (T t : ts.values()) {
            if (!expectedSet.contains(t)) {
                throw ts.failWith(""Item not in the set: "" + BaseTestConsumer.valueAndClass(t));
            }
        }
        return ts;
    }",iterator
t,"{
        Set<T> expectedSet = new HashSet<>(Arrays.asList(values));
        for (T t : to.values()) {
            if (!expectedSet.contains(t)) {
                throw to.failWith(""Item not in the set: "" + BaseTestConsumer.valueAndClass(t));
            }
        }
        return to;
    }",iterator
idx,"{
        URL u = TestHelper.class.getResource(TestHelper.class.getSimpleName() + "".class"");

        String path = new File(u.toURI()).toString().replace('\\', '/');

        parentPackage = parentPackage.replace(""."", ""/"");
//        System.out.println(path);

        // Locate the src/main/java directory
        String p = null;
        while (true) {
            int idx = path.lastIndexOf(""/"");
            if (idx < 0) {
                break;
            }
            path = path.substring(0, idx);
            String check = path + ""/src/main/java"";

            if (new File(check).exists()) {
                p = check + ""/"" + parentPackage + ""/"" + baseClassName + "".java"";
                break;
            }
        }

        if (p == null) {
            System.err.println(""Unable to locate the RxJava sources"");
            return null;
        }

        File f = new File(p);

        if (f.canRead()) {
            return f;
        }

        System.out.println(""Can't read "" + p);
        return null;
    }",break_loop_control
i,"{
        MemoryMXBean bean = ManagementFactory.getMemoryMXBean();

        System.gc();

        int i = maxLoop;
        while (i-- != 0) {
            long usage = bean.getHeapMemoryUsage().getUsed();
            if (usage <= expectedMemoryUsage) {
                return usage;
            }
            System.gc();
            Thread.sleep(oneSleep);
        }
        return bean.getHeapMemoryUsage().getUsed();
    }",loop_control
sync,"{
        AtomicInteger sync = new AtomicInteger(2);

        Schedulers.single().scheduleDirect(() -> {
            if (sync.decrementAndGet() != 0) {
                while (sync.get() != 0) { }
            }

            run.run();

            resume.countDown();
        });

        if (sync.decrementAndGet() != 0) {
            while (sync.get() != 0) { }
        }
    }",maybe_loop_control
i,"{
        int s = values.size();

        for (int i = 0; i < s; i++) {
            T v = this.values.get(i);
            if (Objects.equals(v, value)) {
                throw fail(""Value at position "" + i + "" is equal to "" + valueAndClass(value) + ""; Expected them to be different"");
            }
        }
        return (U) this;
    }",loop_control
i,"{
        int s = values.size();

        for (int i = 0; i < s; i++) {
            T v = this.values.get(i);
            try {
                if (valuePredicate.test(v)) {
                    throw fail(""Value at position "" + i + "" matches predicate "" + valuePredicate.toString() + "", which was not expected."");
                }
            } catch (Throwable ex) {
                throw ExceptionHelper.wrapOrThrow(ex);
            }
        }
        return (U)this;
    }",loop_control
t,"{
        lastThread = Thread.currentThread();

        if (d == null) {
            errors.add(new NullPointerException(""onSubscribe received a null Subscription""));
            return;
        }
        if (!upstream.compareAndSet(null, d)) {
            d.dispose();
            if (upstream.get() != DisposableHelper.DISPOSED) {
                errors.add(new IllegalStateException(""onSubscribe received multiple subscriptions: "" + d));
            }
            return;
        }

        if (initialFusionMode != 0) {
            if (d instanceof QueueDisposable) {
                qd = (QueueDisposable<T>)d;

                int m = qd.requestFusion(initialFusionMode);
                establishedFusionMode = m;

                if (m == QueueFuseable.SYNC) {
                    checkSubscriptionOnce = true;
                    lastThread = Thread.currentThread();
                    try {
                        T t;
                        while ((t = qd.poll()) != null) {
                            values.add(t);
                        }
                        completions++;

                        upstream.lazySet(DisposableHelper.DISPOSED);
                    } catch (Throwable ex) {
                        errors.add(ex);
                    }
                    return;
                }
            }
        }

        downstream.onSubscribe(d);
    }",maybe_loop_control
t,"{
        if (!checkSubscriptionOnce) {
            checkSubscriptionOnce = true;
            if (upstream.get() == null) {
                errors.add(new IllegalStateException(""onSubscribe not called in proper order""));
            }
        }

        lastThread = Thread.currentThread();

        if (establishedFusionMode == QueueFuseable.ASYNC) {
            try {
                while ((t = qd.poll()) != null) {
                    values.add(t);
                }
            } catch (Throwable ex) {
                errors.add(ex);
                qd.dispose();
            }
            return;
        }

        values.add(t);

        if (t == null) {
            errors.add(new NullPointerException(""onNext received a null value""));
        }

        downstream.onNext(t);
    }",maybe_loop_control
i,"{
        try {
            for (int i = 1; i < 3; i++) {
                Observable.just(i)
                .test()
                .withTag(""testing with item="" + i)
                .assertResult(1)
                ;
            }
            throw new RuntimeException(""Should have thrown!"");
        } catch (AssertionError ex) {
            assertTrue(ex.toString(), ex.toString().contains(""testing with item=2""));
        }
    }",loop_control
i,"{
        try {
            for (int i = 1; i < 3; i++) {
                Flowable.just(i)
                .test()
                .withTag(""testing with item="" + i)
                .assertResult(1)
                ;
            }
            throw new RuntimeException(""Should have thrown!"");
        } catch (AssertionError ex) {
            assertTrue(ex.toString(), ex.toString().contains(""testing with item=2""));
        }
    }",loop_control
t,"{
        lastThread = Thread.currentThread();

        if (s == null) {
            errors.add(new NullPointerException(""onSubscribe received a null Subscription""));
            return;
        }
        if (!upstream.compareAndSet(null, s)) {
            s.cancel();
            if (upstream.get() != SubscriptionHelper.CANCELLED) {
                errors.add(new IllegalStateException(""onSubscribe received multiple subscriptions: "" + s));
            }
            return;
        }

        if (initialFusionMode != 0) {
            if (s instanceof QueueSubscription) {
                qs = (QueueSubscription<T>)s;

                int m = qs.requestFusion(initialFusionMode);
                establishedFusionMode = m;

                if (m == QueueFuseable.SYNC) {
                    checkSubscriptionOnce = true;
                    lastThread = Thread.currentThread();
                    try {
                        T t;
                        while ((t = qs.poll()) != null) {
                            values.add(t);
                        }
                        completions++;
                    } catch (Throwable ex) {
                        // Exceptions.throwIfFatal(e); TODO add fatal exceptions?
                        errors.add(ex);
                    }
                    return;
                }
            }
        }

        downstream.onSubscribe(s);

        long mr = missedRequested.getAndSet(0L);
        if (mr != 0L) {
            s.request(mr);
        }

        onStart();
    }",maybe_loop_control
t,"{
        if (!checkSubscriptionOnce) {
            checkSubscriptionOnce = true;
            if (upstream.get() == null) {
                errors.add(new IllegalStateException(""onSubscribe not called in proper order""));
            }
        }
        lastThread = Thread.currentThread();

        if (establishedFusionMode == QueueFuseable.ASYNC) {
            try {
                while ((t = qs.poll()) != null) {
                    values.add(t);
                }
            } catch (Throwable ex) {
                // Exceptions.throwIfFatal(e); TODO add fatal exceptions?
                errors.add(ex);
                qs.cancel();
            }
            return;
        }

        values.add(t);

        if (t == null) {
            errors.add(new NullPointerException(""onNext received a null value""));
        }

        downstream.onNext(t);
    }",maybe_loop_control
dirs,"{
        File f = TestHelper.findSource(""Flowable"");
        if (f == null) {
            System.out.println(""Unable to find sources of RxJava"");
            return;
        }

        Queue<File> dirs = new ArrayDeque<>();

        StringBuilder fail = new StringBuilder();
        fail.append(""The following code pattern was found: "").append(pattern).append(""\n"");
        fail.append(""Refresh and re-run tests!\n\n"");

        File parent = f.getParentFile().getParentFile();

        dirs.offer(new File(parent.getAbsolutePath().replace('\\', '/')));
        dirs.offer(new File(parent.getAbsolutePath().replace('\\', '/').replace(""src/main/java"", ""src/test/java"")));

        Pattern p = Pattern.compile(pattern);

        int total = 0;

        while (!dirs.isEmpty()) {
            f = dirs.poll();

            File[] list = f.listFiles();
            if (list != null && list.length != 0) {

                for (File u : list) {
                    if (u.isDirectory()) {
                        dirs.offer(u);
                    } else {
                        String fname = u.getName();
                        if (fname.endsWith("".java"")) {

                            int lineNum = 0;
                            List<String> lines = new ArrayList<>();
                            BufferedReader in = new BufferedReader(new FileReader(u));
                            //boolean found = false;
                            try {
                                for (; ; ) {
                                    String line = in.readLine();
                                    if (line == null) {
                                        break;
                                    }
                                    lineNum++;

                                    Matcher matcher = p.matcher(line);
                                    if (!line.startsWith(""//"") && !line.startsWith(""*"") && matcher.find()) {
                                        // found = true;
                                        fail
                                                .append(fname)
                                                .append(""#L"").append(lineNum)
                                                .append(""    "").append(line)
                                                .append(""\n"");
                                        total++;

                                        int methodNameStartIndex = matcher.end() - 1;
                                        char firstChar = Character.toLowerCase(line.charAt(methodNameStartIndex));

                                        String newLine = matcher.replaceAll(replacement + firstChar);

                                        lines.add(newLine);
                                    } else {
                                        lines.add(line);
                                    }

                                }
                            } finally {
                                in.close();
                            }

                            /*if (found && System.getenv(""CI"") == null) {
                                PrintWriter w = new PrintWriter(new FileWriter(u));

                                try {
                                    for (String s : lines) {
                                        w.println(s);
                                    }
                                } finally {
                                    w.close();
                                }
                            }*/
                        }
                    }
                }
            }
        }
        if (total != 0) {
            fail.append(""Found "")
                    .append(total)
                    .append("" instances"");
            System.out.println(fail);
            throw new AssertionError(fail.toString());
        }
    }",maybe_loop_control
u,"{
        File f = TestHelper.findSource(""Flowable"");
        if (f == null) {
            System.out.println(""Unable to find sources of RxJava"");
            return;
        }

        Queue<File> dirs = new ArrayDeque<>();

        StringBuilder fail = new StringBuilder();
        fail.append(""The following code pattern was found: "").append(pattern).append(""\n"");
        fail.append(""Refresh and re-run tests!\n\n"");

        File parent = f.getParentFile().getParentFile();

        dirs.offer(new File(parent.getAbsolutePath().replace('\\', '/')));
        dirs.offer(new File(parent.getAbsolutePath().replace('\\', '/').replace(""src/main/java"", ""src/test/java"")));

        Pattern p = Pattern.compile(pattern);

        int total = 0;

        while (!dirs.isEmpty()) {
            f = dirs.poll();

            File[] list = f.listFiles();
            if (list != null && list.length != 0) {

                for (File u : list) {
                    if (u.isDirectory()) {
                        dirs.offer(u);
                    } else {
                        String fname = u.getName();
                        if (fname.endsWith("".java"")) {

                            int lineNum = 0;
                            List<String> lines = new ArrayList<>();
                            BufferedReader in = new BufferedReader(new FileReader(u));
                            //boolean found = false;
                            try {
                                for (; ; ) {
                                    String line = in.readLine();
                                    if (line == null) {
                                        break;
                                    }
                                    lineNum++;

                                    Matcher matcher = p.matcher(line);
                                    if (!line.startsWith(""//"") && !line.startsWith(""*"") && matcher.find()) {
                                        // found = true;
                                        fail
                                                .append(fname)
                                                .append(""#L"").append(lineNum)
                                                .append(""    "").append(line)
                                                .append(""\n"");
                                        total++;

                                        int methodNameStartIndex = matcher.end() - 1;
                                        char firstChar = Character.toLowerCase(line.charAt(methodNameStartIndex));

                                        String newLine = matcher.replaceAll(replacement + firstChar);

                                        lines.add(newLine);
                                    } else {
                                        lines.add(line);
                                    }

                                }
                            } finally {
                                in.close();
                            }

                            /*if (found && System.getenv(""CI"") == null) {
                                PrintWriter w = new PrintWriter(new FileWriter(u));

                                try {
                                    for (String s : lines) {
                                        w.println(s);
                                    }
                                } finally {
                                    w.close();
                                }
                            }*/
                        }
                    }
                }
            }
        }
        if (total != 0) {
            fail.append(""Found "")
                    .append(total)
                    .append("" instances"");
            System.out.println(fail);
            throw new AssertionError(fail.toString());
        }
    }",iterator
s,"{
        File f = TestHelper.findSource(""Flowable"");
        if (f == null) {
            System.out.println(""Unable to find sources of RxJava"");
            return;
        }

        Queue<File> dirs = new ArrayDeque<>();

        StringBuilder fail = new StringBuilder();
        fail.append(""The following code pattern was found: "").append(pattern).append(""\n"");
        fail.append(""Refresh and re-run tests!\n\n"");

        File parent = f.getParentFile().getParentFile();

        dirs.offer(new File(parent.getAbsolutePath().replace('\\', '/')));
        dirs.offer(new File(parent.getAbsolutePath().replace('\\', '/').replace(""src/main/java"", ""src/test/java"")));

        Pattern p = Pattern.compile(pattern);

        int total = 0;

        while (!dirs.isEmpty()) {
            f = dirs.poll();

            File[] list = f.listFiles();
            if (list != null && list.length != 0) {

                for (File u : list) {
                    if (u.isDirectory()) {
                        dirs.offer(u);
                    } else {
                        String fname = u.getName();
                        if (fname.endsWith("".java"")) {

                            int lineNum = 0;
                            List<String> lines = new ArrayList<>();
                            BufferedReader in = new BufferedReader(new FileReader(u));
                            //boolean found = false;
                            try {
                                for (; ; ) {
                                    String line = in.readLine();
                                    if (line == null) {
                                        break;
                                    }
                                    lineNum++;

                                    Matcher matcher = p.matcher(line);
                                    if (!line.startsWith(""//"") && !line.startsWith(""*"") && matcher.find()) {
                                        // found = true;
                                        fail
                                                .append(fname)
                                                .append(""#L"").append(lineNum)
                                                .append(""    "").append(line)
                                                .append(""\n"");
                                        total++;

                                        int methodNameStartIndex = matcher.end() - 1;
                                        char firstChar = Character.toLowerCase(line.charAt(methodNameStartIndex));

                                        String newLine = matcher.replaceAll(replacement + firstChar);

                                        lines.add(newLine);
                                    } else {
                                        lines.add(line);
                                    }

                                }
                            } finally {
                                in.close();
                            }

                            /*if (found && System.getenv(""CI"") == null) {
                                PrintWriter w = new PrintWriter(new FileWriter(u));

                                try {
                                    for (String s : lines) {
                                        w.println(s);
                                    }
                                } finally {
                                    w.close();
                                }
                            }*/
                        }
                    }
                }
            }
        }
        if (total != 0) {
            fail.append(""Found "")
                    .append(total)
                    .append("" instances"");
            System.out.println(fail);
            throw new AssertionError(fail.toString());
        }
    }",iterator
j,"{
        String baseClassName = clazz.getSimpleName();
        File f = TestHelper.findSource(baseClassName, clazz.getPackage().getName());
        if (f == null) {
            return;
        }
        String fullClassName = clazz.getName();

        int errorCount = 0;
        StringBuilder errors = new StringBuilder();

        List<String> lines = Files.readAllLines(f.toPath());

        for (int j = 0; j < lines.size(); j++) {
            String line = lines.get(j).trim();

            for (ValidatorStrings validatorStr : VALIDATOR_STRINGS) {
                int strIdx = line.indexOf(validatorStr.code);
                if (strIdx >= 0) {

                    int comma = line.indexOf(',', strIdx + validatorStr.code.length());

                    String paramName = line.substring(strIdx + validatorStr.code.length(), comma);

                    int quote = line.indexOf('""', comma);

                    String message = line.substring(quote + 1, Math.min(line.length(), quote + 2 + paramName.length()));

                    if (line.contains(""\""A Disposable"")) {
                        continue;
                    }

                    if (!line.contains(""\""The RxJavaPlugins"")
                            && !(message.startsWith(paramName)
                            && (message.endsWith("" "") || message.endsWith(""\"""")))) {
                        errorCount++;
                        errors.append(""L"")
                        .append(j)
                        .append("" : Wrong validator message parameter name\r\n    "")
                        .append(line)
                        .append(""\r\n"")
                        .append(""    "").append(paramName).append("" != "").append(message)
                        .append(""\r\n at "")
                        .append(fullClassName)
                        .append("".method("")
                        .append(f.getName())
                        .append("":"")
                        .append(j + 1)
                        .append("")\r\n"")
                        ;
                    }

                    int midx = j - 1;
                    // find the method declaration
                    for (; midx >= 0; midx--) {
                        String linek = lines.get(midx).trim();
                        if (linek.startsWith(""public"") || linek.startsWith(""private"")
                                || linek.startsWith(""protected"")
                                || linek.startsWith(""static"")
                                || linek.startsWith(baseClassName)) {
                            break;
                        }
                    }

                    if (line.contains(""\""The RxJavaPlugins"")) {
                        continue;
                    }

                    // find JavaDoc of throws
                    boolean found = false;
                    for (int k = midx - 1; k >= 0; k--) {
                        String linek = lines.get(k).trim();
                        if (linek.startsWith(""/**"")) {
                            break;
                        }
                        if (linek.startsWith(""}"")) {
                            found = true; // no method JavaDoc present
                            break;
                        }
                        if (linek.startsWith(validatorStr.javadoc)) {
                            // see if a @code paramName is present
                            String paramStr = ""{@code "" + paramName + ""}"";
                            for (int m = k; m < lines.size(); m++) {
                                String linem = lines.get(m).trim();
                                if (linem.startsWith(""* @see"")
                                        || linem.startsWith(""* @since"")
                                        || linem.startsWith(""*/"")) {
                                    break;
                                }
                                if (linem.contains(paramStr)) {
                                    found = true;
                                    break;
                                }
                            }
                            break;
                        }
                    }

                    if (!found) {
                        errorCount++;
                        errors.append(""L"")
                        .append(j)
                        .append("" : missing '"")
                        .append(validatorStr.javadoc)
                        .append(""' for argument validation: "")
                        .append(paramName)
                        .append(""\r\n    "")
                        .append(line)
                        .append(""\r\n at "")
                        .append(fullClassName)
                        .append("".method("")
                        .append(f.getName())
                        .append("":"")
                        .append(j + 1)
                        .append("")\r\n"")
                        ;
                    }
                }
            }

            for (ValidatorStrings validatorStr : EXCEPTION_STRINGS) {
                int strIdx = line.indexOf(validatorStr.code);
                if (strIdx >= 0) {

                    int midx = j - 1;
                    // find the method declaration
                    for (; midx >= 0; midx--) {
                        String linek = lines.get(midx).trim();
                        if (linek.startsWith(""public"") || linek.startsWith(""private"")
                                || linek.startsWith(""protected"")
                                || linek.startsWith(""static"")
                                || linek.startsWith(baseClassName)) {
                            break;
                        }
                    }

                    // find JavaDoc of throws
                    boolean found = false;
                    for (int k = midx - 1; k >= 0; k--) {
                        String linek = lines.get(k).trim();
                        if (linek.startsWith(""/**"")) {
                            break;
                        }
                        if (linek.startsWith(""}"")) {
                            found = true; // no JavaDoc
                            break;
                        }
                        if (linek.startsWith(validatorStr.javadoc)) {
                            found = true;
                        }
                    }

                    if (!found) {
                        errorCount++;
                        errors.append(""L"")
                        .append(j)
                        .append("" : missing '"")
                        .append(validatorStr.javadoc)
                        .append(""' for exception\r\n    "")
                        .append(line)
                        .append(""\r\n at "")
                        .append(fullClassName)
                        .append("".method("")
                        .append(f.getName())
                        .append("":"")
                        .append(j + 1)
                        .append("")\r\n"")
                        ;
                    }
                }
            }",loop_control
validatorStr,"{
        String baseClassName = clazz.getSimpleName();
        File f = TestHelper.findSource(baseClassName, clazz.getPackage().getName());
        if (f == null) {
            return;
        }
        String fullClassName = clazz.getName();

        int errorCount = 0;
        StringBuilder errors = new StringBuilder();

        List<String> lines = Files.readAllLines(f.toPath());

        for (int j = 0; j < lines.size(); j++) {
            String line = lines.get(j).trim();

            for (ValidatorStrings validatorStr : VALIDATOR_STRINGS) {
                int strIdx = line.indexOf(validatorStr.code);
                if (strIdx >= 0) {

                    int comma = line.indexOf(',', strIdx + validatorStr.code.length());

                    String paramName = line.substring(strIdx + validatorStr.code.length(), comma);

                    int quote = line.indexOf('""', comma);

                    String message = line.substring(quote + 1, Math.min(line.length(), quote + 2 + paramName.length()));

                    if (line.contains(""\""A Disposable"")) {
                        continue;
                    }

                    if (!line.contains(""\""The RxJavaPlugins"")
                            && !(message.startsWith(paramName)
                            && (message.endsWith("" "") || message.endsWith(""\"""")))) {
                        errorCount++;
                        errors.append(""L"")
                        .append(j)
                        .append("" : Wrong validator message parameter name\r\n    "")
                        .append(line)
                        .append(""\r\n"")
                        .append(""    "").append(paramName).append("" != "").append(message)
                        .append(""\r\n at "")
                        .append(fullClassName)
                        .append("".method("")
                        .append(f.getName())
                        .append("":"")
                        .append(j + 1)
                        .append("")\r\n"")
                        ;
                    }

                    int midx = j - 1;
                    // find the method declaration
                    for (; midx >= 0; midx--) {
                        String linek = lines.get(midx).trim();
                        if (linek.startsWith(""public"") || linek.startsWith(""private"")
                                || linek.startsWith(""protected"")
                                || linek.startsWith(""static"")
                                || linek.startsWith(baseClassName)) {
                            break;
                        }
                    }

                    if (line.contains(""\""The RxJavaPlugins"")) {
                        continue;
                    }

                    // find JavaDoc of throws
                    boolean found = false;
                    for (int k = midx - 1; k >= 0; k--) {
                        String linek = lines.get(k).trim();
                        if (linek.startsWith(""/**"")) {
                            break;
                        }
                        if (linek.startsWith(""}"")) {
                            found = true; // no method JavaDoc present
                            break;
                        }
                        if (linek.startsWith(validatorStr.javadoc)) {
                            // see if a @code paramName is present
                            String paramStr = ""{@code "" + paramName + ""}"";
                            for (int m = k; m < lines.size(); m++) {
                                String linem = lines.get(m).trim();
                                if (linem.startsWith(""* @see"")
                                        || linem.startsWith(""* @since"")
                                        || linem.startsWith(""*/"")) {
                                    break;
                                }
                                if (linem.contains(paramStr)) {
                                    found = true;
                                    break;
                                }
                            }
                            break;
                        }
                    }

                    if (!found) {
                        errorCount++;
                        errors.append(""L"")
                        .append(j)
                        .append("" : missing '"")
                        .append(validatorStr.javadoc)
                        .append(""' for argument validation: "")
                        .append(paramName)
                        .append(""\r\n    "")
                        .append(line)
                        .append(""\r\n at "")
                        .append(fullClassName)
                        .append("".method("")
                        .append(f.getName())
                        .append("":"")
                        .append(j + 1)
                        .append("")\r\n"")
                        ;
                    }
                }
            }

            for (ValidatorStrings validatorStr : EXCEPTION_STRINGS) {
                int strIdx = line.indexOf(validatorStr.code);
                if (strIdx >= 0) {

                    int midx = j - 1;
                    // find the method declaration
                    for (; midx >= 0; midx--) {
                        String linek = lines.get(midx).trim();
                        if (linek.startsWith(""public"") || linek.startsWith(""private"")
                                || linek.startsWith(""protected"")
                                || linek.startsWith(""static"")
                                || linek.startsWith(baseClassName)) {
                            break;
                        }
                    }

                    // find JavaDoc of throws
                    boolean found = false;
                    for (int k = midx - 1; k >= 0; k--) {
                        String linek = lines.get(k).trim();
                        if (linek.startsWith(""/**"")) {
                            break;
                        }
                        if (linek.startsWith(""}"")) {
                            found = true; // no JavaDoc
                            break;
                        }
                        if (linek.startsWith(validatorStr.javadoc)) {
                            found = true;
                        }
                    }

                    if (!found) {
                        errorCount++;
                        errors.append(""L"")
                        .append(j)
                        .append("" : missing '"")
                        .append(validatorStr.javadoc)
                        .append(""' for exception\r\n    "")
                        .append(line)
                        .append(""\r\n at "")
                        .append(fullClassName)
                        .append("".method("")
                        .append(f.getName())
                        .append("":"")
                        .append(j + 1)
                        .append("")\r\n"")
                        ;
                    }
                }
            }",iterator
midx,"{
        String baseClassName = clazz.getSimpleName();
        File f = TestHelper.findSource(baseClassName, clazz.getPackage().getName());
        if (f == null) {
            return;
        }
        String fullClassName = clazz.getName();

        int errorCount = 0;
        StringBuilder errors = new StringBuilder();

        List<String> lines = Files.readAllLines(f.toPath());

        for (int j = 0; j < lines.size(); j++) {
            String line = lines.get(j).trim();

            for (ValidatorStrings validatorStr : VALIDATOR_STRINGS) {
                int strIdx = line.indexOf(validatorStr.code);
                if (strIdx >= 0) {

                    int comma = line.indexOf(',', strIdx + validatorStr.code.length());

                    String paramName = line.substring(strIdx + validatorStr.code.length(), comma);

                    int quote = line.indexOf('""', comma);

                    String message = line.substring(quote + 1, Math.min(line.length(), quote + 2 + paramName.length()));

                    if (line.contains(""\""A Disposable"")) {
                        continue;
                    }

                    if (!line.contains(""\""The RxJavaPlugins"")
                            && !(message.startsWith(paramName)
                            && (message.endsWith("" "") || message.endsWith(""\"""")))) {
                        errorCount++;
                        errors.append(""L"")
                        .append(j)
                        .append("" : Wrong validator message parameter name\r\n    "")
                        .append(line)
                        .append(""\r\n"")
                        .append(""    "").append(paramName).append("" != "").append(message)
                        .append(""\r\n at "")
                        .append(fullClassName)
                        .append("".method("")
                        .append(f.getName())
                        .append("":"")
                        .append(j + 1)
                        .append("")\r\n"")
                        ;
                    }

                    int midx = j - 1;
                    // find the method declaration
                    for (; midx >= 0; midx--) {
                        String linek = lines.get(midx).trim();
                        if (linek.startsWith(""public"") || linek.startsWith(""private"")
                                || linek.startsWith(""protected"")
                                || linek.startsWith(""static"")
                                || linek.startsWith(baseClassName)) {
                            break;
                        }
                    }

                    if (line.contains(""\""The RxJavaPlugins"")) {
                        continue;
                    }

                    // find JavaDoc of throws
                    boolean found = false;
                    for (int k = midx - 1; k >= 0; k--) {
                        String linek = lines.get(k).trim();
                        if (linek.startsWith(""/**"")) {
                            break;
                        }
                        if (linek.startsWith(""}"")) {
                            found = true; // no method JavaDoc present
                            break;
                        }
                        if (linek.startsWith(validatorStr.javadoc)) {
                            // see if a @code paramName is present
                            String paramStr = ""{@code "" + paramName + ""}"";
                            for (int m = k; m < lines.size(); m++) {
                                String linem = lines.get(m).trim();
                                if (linem.startsWith(""* @see"")
                                        || linem.startsWith(""* @since"")
                                        || linem.startsWith(""*/"")) {
                                    break;
                                }
                                if (linem.contains(paramStr)) {
                                    found = true;
                                    break;
                                }
                            }
                            break;
                        }
                    }

                    if (!found) {
                        errorCount++;
                        errors.append(""L"")
                        .append(j)
                        .append("" : missing '"")
                        .append(validatorStr.javadoc)
                        .append(""' for argument validation: "")
                        .append(paramName)
                        .append(""\r\n    "")
                        .append(line)
                        .append(""\r\n at "")
                        .append(fullClassName)
                        .append("".method("")
                        .append(f.getName())
                        .append("":"")
                        .append(j + 1)
                        .append("")\r\n"")
                        ;
                    }
                }
            }

            for (ValidatorStrings validatorStr : EXCEPTION_STRINGS) {
                int strIdx = line.indexOf(validatorStr.code);
                if (strIdx >= 0) {

                    int midx = j - 1;
                    // find the method declaration
                    for (; midx >= 0; midx--) {
                        String linek = lines.get(midx).trim();
                        if (linek.startsWith(""public"") || linek.startsWith(""private"")
                                || linek.startsWith(""protected"")
                                || linek.startsWith(""static"")
                                || linek.startsWith(baseClassName)) {
                            break;
                        }
                    }

                    // find JavaDoc of throws
                    boolean found = false;
                    for (int k = midx - 1; k >= 0; k--) {
                        String linek = lines.get(k).trim();
                        if (linek.startsWith(""/**"")) {
                            break;
                        }
                        if (linek.startsWith(""}"")) {
                            found = true; // no JavaDoc
                            break;
                        }
                        if (linek.startsWith(validatorStr.javadoc)) {
                            found = true;
                        }
                    }

                    if (!found) {
                        errorCount++;
                        errors.append(""L"")
                        .append(j)
                        .append("" : missing '"")
                        .append(validatorStr.javadoc)
                        .append(""' for exception\r\n    "")
                        .append(line)
                        .append(""\r\n at "")
                        .append(fullClassName)
                        .append("".method("")
                        .append(f.getName())
                        .append("":"")
                        .append(j + 1)
                        .append("")\r\n"")
                        ;
                    }
                }
            }",loop_control
linek,"{
        String baseClassName = clazz.getSimpleName();
        File f = TestHelper.findSource(baseClassName, clazz.getPackage().getName());
        if (f == null) {
            return;
        }
        String fullClassName = clazz.getName();

        int errorCount = 0;
        StringBuilder errors = new StringBuilder();

        List<String> lines = Files.readAllLines(f.toPath());

        for (int j = 0; j < lines.size(); j++) {
            String line = lines.get(j).trim();

            for (ValidatorStrings validatorStr : VALIDATOR_STRINGS) {
                int strIdx = line.indexOf(validatorStr.code);
                if (strIdx >= 0) {

                    int comma = line.indexOf(',', strIdx + validatorStr.code.length());

                    String paramName = line.substring(strIdx + validatorStr.code.length(), comma);

                    int quote = line.indexOf('""', comma);

                    String message = line.substring(quote + 1, Math.min(line.length(), quote + 2 + paramName.length()));

                    if (line.contains(""\""A Disposable"")) {
                        continue;
                    }

                    if (!line.contains(""\""The RxJavaPlugins"")
                            && !(message.startsWith(paramName)
                            && (message.endsWith("" "") || message.endsWith(""\"""")))) {
                        errorCount++;
                        errors.append(""L"")
                        .append(j)
                        .append("" : Wrong validator message parameter name\r\n    "")
                        .append(line)
                        .append(""\r\n"")
                        .append(""    "").append(paramName).append("" != "").append(message)
                        .append(""\r\n at "")
                        .append(fullClassName)
                        .append("".method("")
                        .append(f.getName())
                        .append("":"")
                        .append(j + 1)
                        .append("")\r\n"")
                        ;
                    }

                    int midx = j - 1;
                    // find the method declaration
                    for (; midx >= 0; midx--) {
                        String linek = lines.get(midx).trim();
                        if (linek.startsWith(""public"") || linek.startsWith(""private"")
                                || linek.startsWith(""protected"")
                                || linek.startsWith(""static"")
                                || linek.startsWith(baseClassName)) {
                            break;
                        }
                    }

                    if (line.contains(""\""The RxJavaPlugins"")) {
                        continue;
                    }

                    // find JavaDoc of throws
                    boolean found = false;
                    for (int k = midx - 1; k >= 0; k--) {
                        String linek = lines.get(k).trim();
                        if (linek.startsWith(""/**"")) {
                            break;
                        }
                        if (linek.startsWith(""}"")) {
                            found = true; // no method JavaDoc present
                            break;
                        }
                        if (linek.startsWith(validatorStr.javadoc)) {
                            // see if a @code paramName is present
                            String paramStr = ""{@code "" + paramName + ""}"";
                            for (int m = k; m < lines.size(); m++) {
                                String linem = lines.get(m).trim();
                                if (linem.startsWith(""* @see"")
                                        || linem.startsWith(""* @since"")
                                        || linem.startsWith(""*/"")) {
                                    break;
                                }
                                if (linem.contains(paramStr)) {
                                    found = true;
                                    break;
                                }
                            }
                            break;
                        }
                    }

                    if (!found) {
                        errorCount++;
                        errors.append(""L"")
                        .append(j)
                        .append("" : missing '"")
                        .append(validatorStr.javadoc)
                        .append(""' for argument validation: "")
                        .append(paramName)
                        .append(""\r\n    "")
                        .append(line)
                        .append(""\r\n at "")
                        .append(fullClassName)
                        .append("".method("")
                        .append(f.getName())
                        .append("":"")
                        .append(j + 1)
                        .append("")\r\n"")
                        ;
                    }
                }
            }

            for (ValidatorStrings validatorStr : EXCEPTION_STRINGS) {
                int strIdx = line.indexOf(validatorStr.code);
                if (strIdx >= 0) {

                    int midx = j - 1;
                    // find the method declaration
                    for (; midx >= 0; midx--) {
                        String linek = lines.get(midx).trim();
                        if (linek.startsWith(""public"") || linek.startsWith(""private"")
                                || linek.startsWith(""protected"")
                                || linek.startsWith(""static"")
                                || linek.startsWith(baseClassName)) {
                            break;
                        }
                    }

                    // find JavaDoc of throws
                    boolean found = false;
                    for (int k = midx - 1; k >= 0; k--) {
                        String linek = lines.get(k).trim();
                        if (linek.startsWith(""/**"")) {
                            break;
                        }
                        if (linek.startsWith(""}"")) {
                            found = true; // no JavaDoc
                            break;
                        }
                        if (linek.startsWith(validatorStr.javadoc)) {
                            found = true;
                        }
                    }

                    if (!found) {
                        errorCount++;
                        errors.append(""L"")
                        .append(j)
                        .append("" : missing '"")
                        .append(validatorStr.javadoc)
                        .append(""' for exception\r\n    "")
                        .append(line)
                        .append(""\r\n at "")
                        .append(fullClassName)
                        .append("".method("")
                        .append(f.getName())
                        .append("":"")
                        .append(j + 1)
                        .append("")\r\n"")
                        ;
                    }
                }
            }",break_loop_control
m,"{
        String baseClassName = clazz.getSimpleName();
        File f = TestHelper.findSource(baseClassName, clazz.getPackage().getName());
        if (f == null) {
            return;
        }
        String fullClassName = clazz.getName();

        int errorCount = 0;
        StringBuilder errors = new StringBuilder();

        List<String> lines = Files.readAllLines(f.toPath());

        for (int j = 0; j < lines.size(); j++) {
            String line = lines.get(j).trim();

            for (ValidatorStrings validatorStr : VALIDATOR_STRINGS) {
                int strIdx = line.indexOf(validatorStr.code);
                if (strIdx >= 0) {

                    int comma = line.indexOf(',', strIdx + validatorStr.code.length());

                    String paramName = line.substring(strIdx + validatorStr.code.length(), comma);

                    int quote = line.indexOf('""', comma);

                    String message = line.substring(quote + 1, Math.min(line.length(), quote + 2 + paramName.length()));

                    if (line.contains(""\""A Disposable"")) {
                        continue;
                    }

                    if (!line.contains(""\""The RxJavaPlugins"")
                            && !(message.startsWith(paramName)
                            && (message.endsWith("" "") || message.endsWith(""\"""")))) {
                        errorCount++;
                        errors.append(""L"")
                        .append(j)
                        .append("" : Wrong validator message parameter name\r\n    "")
                        .append(line)
                        .append(""\r\n"")
                        .append(""    "").append(paramName).append("" != "").append(message)
                        .append(""\r\n at "")
                        .append(fullClassName)
                        .append("".method("")
                        .append(f.getName())
                        .append("":"")
                        .append(j + 1)
                        .append("")\r\n"")
                        ;
                    }

                    int midx = j - 1;
                    // find the method declaration
                    for (; midx >= 0; midx--) {
                        String linek = lines.get(midx).trim();
                        if (linek.startsWith(""public"") || linek.startsWith(""private"")
                                || linek.startsWith(""protected"")
                                || linek.startsWith(""static"")
                                || linek.startsWith(baseClassName)) {
                            break;
                        }
                    }

                    if (line.contains(""\""The RxJavaPlugins"")) {
                        continue;
                    }

                    // find JavaDoc of throws
                    boolean found = false;
                    for (int k = midx - 1; k >= 0; k--) {
                        String linek = lines.get(k).trim();
                        if (linek.startsWith(""/**"")) {
                            break;
                        }
                        if (linek.startsWith(""}"")) {
                            found = true; // no method JavaDoc present
                            break;
                        }
                        if (linek.startsWith(validatorStr.javadoc)) {
                            // see if a @code paramName is present
                            String paramStr = ""{@code "" + paramName + ""}"";
                            for (int m = k; m < lines.size(); m++) {
                                String linem = lines.get(m).trim();
                                if (linem.startsWith(""* @see"")
                                        || linem.startsWith(""* @since"")
                                        || linem.startsWith(""*/"")) {
                                    break;
                                }
                                if (linem.contains(paramStr)) {
                                    found = true;
                                    break;
                                }
                            }
                            break;
                        }
                    }

                    if (!found) {
                        errorCount++;
                        errors.append(""L"")
                        .append(j)
                        .append("" : missing '"")
                        .append(validatorStr.javadoc)
                        .append(""' for argument validation: "")
                        .append(paramName)
                        .append(""\r\n    "")
                        .append(line)
                        .append(""\r\n at "")
                        .append(fullClassName)
                        .append("".method("")
                        .append(f.getName())
                        .append("":"")
                        .append(j + 1)
                        .append("")\r\n"")
                        ;
                    }
                }
            }

            for (ValidatorStrings validatorStr : EXCEPTION_STRINGS) {
                int strIdx = line.indexOf(validatorStr.code);
                if (strIdx >= 0) {

                    int midx = j - 1;
                    // find the method declaration
                    for (; midx >= 0; midx--) {
                        String linek = lines.get(midx).trim();
                        if (linek.startsWith(""public"") || linek.startsWith(""private"")
                                || linek.startsWith(""protected"")
                                || linek.startsWith(""static"")
                                || linek.startsWith(baseClassName)) {
                            break;
                        }
                    }

                    // find JavaDoc of throws
                    boolean found = false;
                    for (int k = midx - 1; k >= 0; k--) {
                        String linek = lines.get(k).trim();
                        if (linek.startsWith(""/**"")) {
                            break;
                        }
                        if (linek.startsWith(""}"")) {
                            found = true; // no JavaDoc
                            break;
                        }
                        if (linek.startsWith(validatorStr.javadoc)) {
                            found = true;
                        }
                    }

                    if (!found) {
                        errorCount++;
                        errors.append(""L"")
                        .append(j)
                        .append("" : missing '"")
                        .append(validatorStr.javadoc)
                        .append(""' for exception\r\n    "")
                        .append(line)
                        .append(""\r\n at "")
                        .append(fullClassName)
                        .append("".method("")
                        .append(f.getName())
                        .append("":"")
                        .append(j + 1)
                        .append("")\r\n"")
                        ;
                    }
                }
            }",loop_control
linem,"{
        String baseClassName = clazz.getSimpleName();
        File f = TestHelper.findSource(baseClassName, clazz.getPackage().getName());
        if (f == null) {
            return;
        }
        String fullClassName = clazz.getName();

        int errorCount = 0;
        StringBuilder errors = new StringBuilder();

        List<String> lines = Files.readAllLines(f.toPath());

        for (int j = 0; j < lines.size(); j++) {
            String line = lines.get(j).trim();

            for (ValidatorStrings validatorStr : VALIDATOR_STRINGS) {
                int strIdx = line.indexOf(validatorStr.code);
                if (strIdx >= 0) {

                    int comma = line.indexOf(',', strIdx + validatorStr.code.length());

                    String paramName = line.substring(strIdx + validatorStr.code.length(), comma);

                    int quote = line.indexOf('""', comma);

                    String message = line.substring(quote + 1, Math.min(line.length(), quote + 2 + paramName.length()));

                    if (line.contains(""\""A Disposable"")) {
                        continue;
                    }

                    if (!line.contains(""\""The RxJavaPlugins"")
                            && !(message.startsWith(paramName)
                            && (message.endsWith("" "") || message.endsWith(""\"""")))) {
                        errorCount++;
                        errors.append(""L"")
                        .append(j)
                        .append("" : Wrong validator message parameter name\r\n    "")
                        .append(line)
                        .append(""\r\n"")
                        .append(""    "").append(paramName).append("" != "").append(message)
                        .append(""\r\n at "")
                        .append(fullClassName)
                        .append("".method("")
                        .append(f.getName())
                        .append("":"")
                        .append(j + 1)
                        .append("")\r\n"")
                        ;
                    }

                    int midx = j - 1;
                    // find the method declaration
                    for (; midx >= 0; midx--) {
                        String linek = lines.get(midx).trim();
                        if (linek.startsWith(""public"") || linek.startsWith(""private"")
                                || linek.startsWith(""protected"")
                                || linek.startsWith(""static"")
                                || linek.startsWith(baseClassName)) {
                            break;
                        }
                    }

                    if (line.contains(""\""The RxJavaPlugins"")) {
                        continue;
                    }

                    // find JavaDoc of throws
                    boolean found = false;
                    for (int k = midx - 1; k >= 0; k--) {
                        String linek = lines.get(k).trim();
                        if (linek.startsWith(""/**"")) {
                            break;
                        }
                        if (linek.startsWith(""}"")) {
                            found = true; // no method JavaDoc present
                            break;
                        }
                        if (linek.startsWith(validatorStr.javadoc)) {
                            // see if a @code paramName is present
                            String paramStr = ""{@code "" + paramName + ""}"";
                            for (int m = k; m < lines.size(); m++) {
                                String linem = lines.get(m).trim();
                                if (linem.startsWith(""* @see"")
                                        || linem.startsWith(""* @since"")
                                        || linem.startsWith(""*/"")) {
                                    break;
                                }
                                if (linem.contains(paramStr)) {
                                    found = true;
                                    break;
                                }
                            }
                            break;
                        }
                    }

                    if (!found) {
                        errorCount++;
                        errors.append(""L"")
                        .append(j)
                        .append("" : missing '"")
                        .append(validatorStr.javadoc)
                        .append(""' for argument validation: "")
                        .append(paramName)
                        .append(""\r\n    "")
                        .append(line)
                        .append(""\r\n at "")
                        .append(fullClassName)
                        .append("".method("")
                        .append(f.getName())
                        .append("":"")
                        .append(j + 1)
                        .append("")\r\n"")
                        ;
                    }
                }
            }

            for (ValidatorStrings validatorStr : EXCEPTION_STRINGS) {
                int strIdx = line.indexOf(validatorStr.code);
                if (strIdx >= 0) {

                    int midx = j - 1;
                    // find the method declaration
                    for (; midx >= 0; midx--) {
                        String linek = lines.get(midx).trim();
                        if (linek.startsWith(""public"") || linek.startsWith(""private"")
                                || linek.startsWith(""protected"")
                                || linek.startsWith(""static"")
                                || linek.startsWith(baseClassName)) {
                            break;
                        }
                    }

                    // find JavaDoc of throws
                    boolean found = false;
                    for (int k = midx - 1; k >= 0; k--) {
                        String linek = lines.get(k).trim();
                        if (linek.startsWith(""/**"")) {
                            break;
                        }
                        if (linek.startsWith(""}"")) {
                            found = true; // no JavaDoc
                            break;
                        }
                        if (linek.startsWith(validatorStr.javadoc)) {
                            found = true;
                        }
                    }

                    if (!found) {
                        errorCount++;
                        errors.append(""L"")
                        .append(j)
                        .append("" : missing '"")
                        .append(validatorStr.javadoc)
                        .append(""' for exception\r\n    "")
                        .append(line)
                        .append(""\r\n at "")
                        .append(fullClassName)
                        .append("".method("")
                        .append(f.getName())
                        .append("":"")
                        .append(j + 1)
                        .append("")\r\n"")
                        ;
                    }
                }
            }",break_loop_control
k,"{
        String baseClassName = clazz.getSimpleName();
        File f = TestHelper.findSource(baseClassName, clazz.getPackage().getName());
        if (f == null) {
            return;
        }
        String fullClassName = clazz.getName();

        int errorCount = 0;
        StringBuilder errors = new StringBuilder();

        List<String> lines = Files.readAllLines(f.toPath());

        for (int j = 0; j < lines.size(); j++) {
            String line = lines.get(j).trim();

            for (ValidatorStrings validatorStr : VALIDATOR_STRINGS) {
                int strIdx = line.indexOf(validatorStr.code);
                if (strIdx >= 0) {

                    int comma = line.indexOf(',', strIdx + validatorStr.code.length());

                    String paramName = line.substring(strIdx + validatorStr.code.length(), comma);

                    int quote = line.indexOf('""', comma);

                    String message = line.substring(quote + 1, Math.min(line.length(), quote + 2 + paramName.length()));

                    if (line.contains(""\""A Disposable"")) {
                        continue;
                    }

                    if (!line.contains(""\""The RxJavaPlugins"")
                            && !(message.startsWith(paramName)
                            && (message.endsWith("" "") || message.endsWith(""\"""")))) {
                        errorCount++;
                        errors.append(""L"")
                        .append(j)
                        .append("" : Wrong validator message parameter name\r\n    "")
                        .append(line)
                        .append(""\r\n"")
                        .append(""    "").append(paramName).append("" != "").append(message)
                        .append(""\r\n at "")
                        .append(fullClassName)
                        .append("".method("")
                        .append(f.getName())
                        .append("":"")
                        .append(j + 1)
                        .append("")\r\n"")
                        ;
                    }

                    int midx = j - 1;
                    // find the method declaration
                    for (; midx >= 0; midx--) {
                        String linek = lines.get(midx).trim();
                        if (linek.startsWith(""public"") || linek.startsWith(""private"")
                                || linek.startsWith(""protected"")
                                || linek.startsWith(""static"")
                                || linek.startsWith(baseClassName)) {
                            break;
                        }
                    }

                    if (line.contains(""\""The RxJavaPlugins"")) {
                        continue;
                    }

                    // find JavaDoc of throws
                    boolean found = false;
                    for (int k = midx - 1; k >= 0; k--) {
                        String linek = lines.get(k).trim();
                        if (linek.startsWith(""/**"")) {
                            break;
                        }
                        if (linek.startsWith(""}"")) {
                            found = true; // no method JavaDoc present
                            break;
                        }
                        if (linek.startsWith(validatorStr.javadoc)) {
                            // see if a @code paramName is present
                            String paramStr = ""{@code "" + paramName + ""}"";
                            for (int m = k; m < lines.size(); m++) {
                                String linem = lines.get(m).trim();
                                if (linem.startsWith(""* @see"")
                                        || linem.startsWith(""* @since"")
                                        || linem.startsWith(""*/"")) {
                                    break;
                                }
                                if (linem.contains(paramStr)) {
                                    found = true;
                                    break;
                                }
                            }
                            break;
                        }
                    }

                    if (!found) {
                        errorCount++;
                        errors.append(""L"")
                        .append(j)
                        .append("" : missing '"")
                        .append(validatorStr.javadoc)
                        .append(""' for argument validation: "")
                        .append(paramName)
                        .append(""\r\n    "")
                        .append(line)
                        .append(""\r\n at "")
                        .append(fullClassName)
                        .append("".method("")
                        .append(f.getName())
                        .append("":"")
                        .append(j + 1)
                        .append("")\r\n"")
                        ;
                    }
                }
            }

            for (ValidatorStrings validatorStr : EXCEPTION_STRINGS) {
                int strIdx = line.indexOf(validatorStr.code);
                if (strIdx >= 0) {

                    int midx = j - 1;
                    // find the method declaration
                    for (; midx >= 0; midx--) {
                        String linek = lines.get(midx).trim();
                        if (linek.startsWith(""public"") || linek.startsWith(""private"")
                                || linek.startsWith(""protected"")
                                || linek.startsWith(""static"")
                                || linek.startsWith(baseClassName)) {
                            break;
                        }
                    }

                    // find JavaDoc of throws
                    boolean found = false;
                    for (int k = midx - 1; k >= 0; k--) {
                        String linek = lines.get(k).trim();
                        if (linek.startsWith(""/**"")) {
                            break;
                        }
                        if (linek.startsWith(""}"")) {
                            found = true; // no JavaDoc
                            break;
                        }
                        if (linek.startsWith(validatorStr.javadoc)) {
                            found = true;
                        }
                    }

                    if (!found) {
                        errorCount++;
                        errors.append(""L"")
                        .append(j)
                        .append("" : missing '"")
                        .append(validatorStr.javadoc)
                        .append(""' for exception\r\n    "")
                        .append(line)
                        .append(""\r\n at "")
                        .append(fullClassName)
                        .append("".method("")
                        .append(f.getName())
                        .append("":"")
                        .append(j + 1)
                        .append("")\r\n"")
                        ;
                    }
                }
            }",loop_control
validatorStr,"{
                for (ValidatorStrings validatorStr : TYPICAL_ARGUMENT_STRINGS) {
                    // find the method declaration ending {
                    for (int i = j; i < lines.size(); i++) {
                        String linei = lines.get(i).trim();

                        // space + code for capturing type declarations
                        String varPattern = "" "" + validatorStr.code;
                        if (linei.contains(varPattern + "")"")
                                || linei.contains(varPattern + "","")
                                || linei.endsWith(varPattern)) {
                            // ignore nullable-annotated arguments
                            if (!linei.matches("".*\\@Nullable\\s.*"" + validatorStr.code + "".*"")) {
                                boolean found = false;
                                for (int k = i - 1; k >= 0; k--) {
                                    String linek = lines.get(k).trim();
                                    if (linek.startsWith(""/**"")) {
                                        break;
                                    }
                                    if (linek.startsWith(""}"")) {
                                        found = true; // no method JavaDoc present
                                        break;
                                    }
                                    if (linek.startsWith(validatorStr.javadoc)) {
                                        // see if a @code paramName is present
                                        String paramStr = ""{@code "" + validatorStr.code + ""}"";
                                        for (int m = k; m < lines.size(); m++) {
                                            String linem = lines.get(m).trim();
                                            if (linem.startsWith(""* @see"")
                                                    || linem.startsWith(""* @since"")
                                                    || linem.startsWith(""*/"")) {
                                                break;
                                            }
                                            if (linem.contains(paramStr)) {
                                                found = true;
                                                break;
                                            }
                                        }
                                        break;
                                    }
                                }

                                if (!found) {
                                    errorCount++;
                                    errors.append(""L"")
                                    .append(j)
                                    .append("" : missing '"")
                                    .append(validatorStr.javadoc)
                                    .append(""' for typical argument: "")
                                    .append(validatorStr.code)
                                    .append(""\r\n    "")
                                    .append(line)
                                    .append(""\r\n at "")
                                    .append(fullClassName)
                                    .append("".method("")
                                    .append(f.getName())
                                    .append("":"")
                                    .append(j + 1)
                                    .append("")\r\n"")
                                    ;
                                }
                            }
                        }

                        if (linei.endsWith(""{"") || linei.endsWith("";"")) {
                            break;
                        }
                    }
                }
            }
        }",iterator
i,"{
                for (ValidatorStrings validatorStr : TYPICAL_ARGUMENT_STRINGS) {
                    // find the method declaration ending {
                    for (int i = j; i < lines.size(); i++) {
                        String linei = lines.get(i).trim();

                        // space + code for capturing type declarations
                        String varPattern = "" "" + validatorStr.code;
                        if (linei.contains(varPattern + "")"")
                                || linei.contains(varPattern + "","")
                                || linei.endsWith(varPattern)) {
                            // ignore nullable-annotated arguments
                            if (!linei.matches("".*\\@Nullable\\s.*"" + validatorStr.code + "".*"")) {
                                boolean found = false;
                                for (int k = i - 1; k >= 0; k--) {
                                    String linek = lines.get(k).trim();
                                    if (linek.startsWith(""/**"")) {
                                        break;
                                    }
                                    if (linek.startsWith(""}"")) {
                                        found = true; // no method JavaDoc present
                                        break;
                                    }
                                    if (linek.startsWith(validatorStr.javadoc)) {
                                        // see if a @code paramName is present
                                        String paramStr = ""{@code "" + validatorStr.code + ""}"";
                                        for (int m = k; m < lines.size(); m++) {
                                            String linem = lines.get(m).trim();
                                            if (linem.startsWith(""* @see"")
                                                    || linem.startsWith(""* @since"")
                                                    || linem.startsWith(""*/"")) {
                                                break;
                                            }
                                            if (linem.contains(paramStr)) {
                                                found = true;
                                                break;
                                            }
                                        }
                                        break;
                                    }
                                }

                                if (!found) {
                                    errorCount++;
                                    errors.append(""L"")
                                    .append(j)
                                    .append("" : missing '"")
                                    .append(validatorStr.javadoc)
                                    .append(""' for typical argument: "")
                                    .append(validatorStr.code)
                                    .append(""\r\n    "")
                                    .append(line)
                                    .append(""\r\n at "")
                                    .append(fullClassName)
                                    .append("".method("")
                                    .append(f.getName())
                                    .append("":"")
                                    .append(j + 1)
                                    .append("")\r\n"")
                                    ;
                                }
                            }
                        }

                        if (linei.endsWith(""{"") || linei.endsWith("";"")) {
                            break;
                        }
                    }
                }
            }
        }",loop_control
k,"{
                for (ValidatorStrings validatorStr : TYPICAL_ARGUMENT_STRINGS) {
                    // find the method declaration ending {
                    for (int i = j; i < lines.size(); i++) {
                        String linei = lines.get(i).trim();

                        // space + code for capturing type declarations
                        String varPattern = "" "" + validatorStr.code;
                        if (linei.contains(varPattern + "")"")
                                || linei.contains(varPattern + "","")
                                || linei.endsWith(varPattern)) {
                            // ignore nullable-annotated arguments
                            if (!linei.matches("".*\\@Nullable\\s.*"" + validatorStr.code + "".*"")) {
                                boolean found = false;
                                for (int k = i - 1; k >= 0; k--) {
                                    String linek = lines.get(k).trim();
                                    if (linek.startsWith(""/**"")) {
                                        break;
                                    }
                                    if (linek.startsWith(""}"")) {
                                        found = true; // no method JavaDoc present
                                        break;
                                    }
                                    if (linek.startsWith(validatorStr.javadoc)) {
                                        // see if a @code paramName is present
                                        String paramStr = ""{@code "" + validatorStr.code + ""}"";
                                        for (int m = k; m < lines.size(); m++) {
                                            String linem = lines.get(m).trim();
                                            if (linem.startsWith(""* @see"")
                                                    || linem.startsWith(""* @since"")
                                                    || linem.startsWith(""*/"")) {
                                                break;
                                            }
                                            if (linem.contains(paramStr)) {
                                                found = true;
                                                break;
                                            }
                                        }
                                        break;
                                    }
                                }

                                if (!found) {
                                    errorCount++;
                                    errors.append(""L"")
                                    .append(j)
                                    .append("" : missing '"")
                                    .append(validatorStr.javadoc)
                                    .append(""' for typical argument: "")
                                    .append(validatorStr.code)
                                    .append(""\r\n    "")
                                    .append(line)
                                    .append(""\r\n at "")
                                    .append(fullClassName)
                                    .append("".method("")
                                    .append(f.getName())
                                    .append("":"")
                                    .append(j + 1)
                                    .append("")\r\n"")
                                    ;
                                }
                            }
                        }

                        if (linei.endsWith(""{"") || linei.endsWith("";"")) {
                            break;
                        }
                    }
                }
            }
        }",loop_control
m,"{
                for (ValidatorStrings validatorStr : TYPICAL_ARGUMENT_STRINGS) {
                    // find the method declaration ending {
                    for (int i = j; i < lines.size(); i++) {
                        String linei = lines.get(i).trim();

                        // space + code for capturing type declarations
                        String varPattern = "" "" + validatorStr.code;
                        if (linei.contains(varPattern + "")"")
                                || linei.contains(varPattern + "","")
                                || linei.endsWith(varPattern)) {
                            // ignore nullable-annotated arguments
                            if (!linei.matches("".*\\@Nullable\\s.*"" + validatorStr.code + "".*"")) {
                                boolean found = false;
                                for (int k = i - 1; k >= 0; k--) {
                                    String linek = lines.get(k).trim();
                                    if (linek.startsWith(""/**"")) {
                                        break;
                                    }
                                    if (linek.startsWith(""}"")) {
                                        found = true; // no method JavaDoc present
                                        break;
                                    }
                                    if (linek.startsWith(validatorStr.javadoc)) {
                                        // see if a @code paramName is present
                                        String paramStr = ""{@code "" + validatorStr.code + ""}"";
                                        for (int m = k; m < lines.size(); m++) {
                                            String linem = lines.get(m).trim();
                                            if (linem.startsWith(""* @see"")
                                                    || linem.startsWith(""* @since"")
                                                    || linem.startsWith(""*/"")) {
                                                break;
                                            }
                                            if (linem.contains(paramStr)) {
                                                found = true;
                                                break;
                                            }
                                        }
                                        break;
                                    }
                                }

                                if (!found) {
                                    errorCount++;
                                    errors.append(""L"")
                                    .append(j)
                                    .append("" : missing '"")
                                    .append(validatorStr.javadoc)
                                    .append(""' for typical argument: "")
                                    .append(validatorStr.code)
                                    .append(""\r\n    "")
                                    .append(line)
                                    .append(""\r\n at "")
                                    .append(fullClassName)
                                    .append("".method("")
                                    .append(f.getName())
                                    .append("":"")
                                    .append(j + 1)
                                    .append("")\r\n"")
                                    ;
                                }
                            }
                        }

                        if (linei.endsWith(""{"") || linei.endsWith("";"")) {
                            break;
                        }
                    }
                }
            }
        }",loop_control
linek,"{
                for (ValidatorStrings validatorStr : TYPICAL_ARGUMENT_STRINGS) {
                    // find the method declaration ending {
                    for (int i = j; i < lines.size(); i++) {
                        String linei = lines.get(i).trim();

                        // space + code for capturing type declarations
                        String varPattern = "" "" + validatorStr.code;
                        if (linei.contains(varPattern + "")"")
                                || linei.contains(varPattern + "","")
                                || linei.endsWith(varPattern)) {
                            // ignore nullable-annotated arguments
                            if (!linei.matches("".*\\@Nullable\\s.*"" + validatorStr.code + "".*"")) {
                                boolean found = false;
                                for (int k = i - 1; k >= 0; k--) {
                                    String linek = lines.get(k).trim();
                                    if (linek.startsWith(""/**"")) {
                                        break;
                                    }
                                    if (linek.startsWith(""}"")) {
                                        found = true; // no method JavaDoc present
                                        break;
                                    }
                                    if (linek.startsWith(validatorStr.javadoc)) {
                                        // see if a @code paramName is present
                                        String paramStr = ""{@code "" + validatorStr.code + ""}"";
                                        for (int m = k; m < lines.size(); m++) {
                                            String linem = lines.get(m).trim();
                                            if (linem.startsWith(""* @see"")
                                                    || linem.startsWith(""* @since"")
                                                    || linem.startsWith(""*/"")) {
                                                break;
                                            }
                                            if (linem.contains(paramStr)) {
                                                found = true;
                                                break;
                                            }
                                        }
                                        break;
                                    }
                                }

                                if (!found) {
                                    errorCount++;
                                    errors.append(""L"")
                                    .append(j)
                                    .append("" : missing '"")
                                    .append(validatorStr.javadoc)
                                    .append(""' for typical argument: "")
                                    .append(validatorStr.code)
                                    .append(""\r\n    "")
                                    .append(line)
                                    .append(""\r\n at "")
                                    .append(fullClassName)
                                    .append("".method("")
                                    .append(f.getName())
                                    .append("":"")
                                    .append(j + 1)
                                    .append("")\r\n"")
                                    ;
                                }
                            }
                        }

                        if (linei.endsWith(""{"") || linei.endsWith("";"")) {
                            break;
                        }
                    }
                }
            }
        }",break_loop_control
linei,"{
                for (ValidatorStrings validatorStr : TYPICAL_ARGUMENT_STRINGS) {
                    // find the method declaration ending {
                    for (int i = j; i < lines.size(); i++) {
                        String linei = lines.get(i).trim();

                        // space + code for capturing type declarations
                        String varPattern = "" "" + validatorStr.code;
                        if (linei.contains(varPattern + "")"")
                                || linei.contains(varPattern + "","")
                                || linei.endsWith(varPattern)) {
                            // ignore nullable-annotated arguments
                            if (!linei.matches("".*\\@Nullable\\s.*"" + validatorStr.code + "".*"")) {
                                boolean found = false;
                                for (int k = i - 1; k >= 0; k--) {
                                    String linek = lines.get(k).trim();
                                    if (linek.startsWith(""/**"")) {
                                        break;
                                    }
                                    if (linek.startsWith(""}"")) {
                                        found = true; // no method JavaDoc present
                                        break;
                                    }
                                    if (linek.startsWith(validatorStr.javadoc)) {
                                        // see if a @code paramName is present
                                        String paramStr = ""{@code "" + validatorStr.code + ""}"";
                                        for (int m = k; m < lines.size(); m++) {
                                            String linem = lines.get(m).trim();
                                            if (linem.startsWith(""* @see"")
                                                    || linem.startsWith(""* @since"")
                                                    || linem.startsWith(""*/"")) {
                                                break;
                                            }
                                            if (linem.contains(paramStr)) {
                                                found = true;
                                                break;
                                            }
                                        }
                                        break;
                                    }
                                }

                                if (!found) {
                                    errorCount++;
                                    errors.append(""L"")
                                    .append(j)
                                    .append("" : missing '"")
                                    .append(validatorStr.javadoc)
                                    .append(""' for typical argument: "")
                                    .append(validatorStr.code)
                                    .append(""\r\n    "")
                                    .append(line)
                                    .append(""\r\n at "")
                                    .append(fullClassName)
                                    .append("".method("")
                                    .append(f.getName())
                                    .append("":"")
                                    .append(j + 1)
                                    .append("")\r\n"")
                                    ;
                                }
                            }
                        }

                        if (linei.endsWith(""{"") || linei.endsWith("";"")) {
                            break;
                        }
                    }
                }
            }
        }",break_loop_control
line,"{

    static void process(Class<?> clazz) {

        String className = clazz.getSimpleName();
        String parentPackage = clazz.getPackage().getName();

        StringBuilder result = new StringBuilder();
        int count = 0;

        try {
            File f = TestHelper.findSource(className, parentPackage);

            try (BufferedReader in = Files.newBufferedReader(f.toPath())) {
                int lineCount = 1;
                String line = null;

                while ((line = in.readLine()) != null) {
                    line = line.trim();

                    if (!line.contains("" to("")) {
                        if (line.startsWith(""public static <"") || line.startsWith(""public final <"")) {

                            for (String ta : parseTypeArguments(line)) {
                                if (!ta.startsWith(""@NonNull"") && !ta.startsWith(""@Nullable"")) {
                                    if (!(""Maybe"".equals(clazz.getSimpleName()) && (line.contains(""fromCallable("") || line.contains(""fromSupplier("")))) {
                                        result.append(""Missing annotation on argument "").append(ta).append(""\r\nat "")
                                        .append(parentPackage).append(""."").append(className).append("".method("")
                                        .append(className).append("".java:"").append(lineCount).append("")\r\n"");
                                        count++;
                                    }
                                }
                            }
                        }
                    }
                    lineCount++;
                }
            }
        } catch (Exception ex) {
            throw new RuntimeException(ex);
        }

        if (count != 0) {
            throw new IllegalArgumentException(""Found "" + count + "" cases\r\n"" + result.toString());
        }
    }

    static List<String> parseTypeArguments(String line) {
        List<String> result = new ArrayList<>();
        int offset = line.indexOf(""<"");
        int c = 1;
        int i = offset + 1;
        int j = i;
        for (; i < line.length(); i++) {
            if (line.charAt(i) == '<') {
                c++;
            } else
            if (line.charAt(i) == '>') {
                c--;
                if (c == 0) {
                    break;
                }
            } else
            if (line.charAt(i) == ',' && c == 1) {
                result.add(line.substring(j, i).trim());
                j = i + 1;
            }
        }
        result.add(line.substring(j, i).trim());
        return result;
    }

    @Test
    public void parseTypeArguments() {
        assertEquals(new ArrayList<>(Arrays.asList(""T"")), parseTypeArguments(""<T>""));
        assertEquals(new ArrayList<>(Arrays.asList(""T"", ""U"")), parseTypeArguments(""<T, U>""));
        assertEquals(new ArrayList<>(Arrays.asList(""T"", ""Flowable<U>"")), parseTypeArguments(""<T, Flowable<U>>""));
        assertEquals(new ArrayList<>(Arrays.asList(""T"", ""Flowable<U, V>"")), parseTypeArguments(""<T, Flowable<U, V>>""));
    }

    @Test
    public void flowable() {
        process(Flowable.class);
    }

    @Test
    public void observable() {
        process(Observable.class);
    }

    @Test
    public void maybe() {
        process(Maybe.class);
    }

    @Test
    public void single() {
        process(Single.class);
    }

    @Test
    public void completable() {
        process(Completable.class);
    }

    @Test
    public void parallel() {
        process(ParallelFlowable.class);
    }

    @Test
    public void plugins() {
        process(RxJavaPlugins.class);
    }
}",maybe_loop_control
ta,"{

    static void process(Class<?> clazz) {

        String className = clazz.getSimpleName();
        String parentPackage = clazz.getPackage().getName();

        StringBuilder result = new StringBuilder();
        int count = 0;

        try {
            File f = TestHelper.findSource(className, parentPackage);

            try (BufferedReader in = Files.newBufferedReader(f.toPath())) {
                int lineCount = 1;
                String line = null;

                while ((line = in.readLine()) != null) {
                    line = line.trim();

                    if (!line.contains("" to("")) {
                        if (line.startsWith(""public static <"") || line.startsWith(""public final <"")) {

                            for (String ta : parseTypeArguments(line)) {
                                if (!ta.startsWith(""@NonNull"") && !ta.startsWith(""@Nullable"")) {
                                    if (!(""Maybe"".equals(clazz.getSimpleName()) && (line.contains(""fromCallable("") || line.contains(""fromSupplier("")))) {
                                        result.append(""Missing annotation on argument "").append(ta).append(""\r\nat "")
                                        .append(parentPackage).append(""."").append(className).append("".method("")
                                        .append(className).append("".java:"").append(lineCount).append("")\r\n"");
                                        count++;
                                    }
                                }
                            }
                        }
                    }
                    lineCount++;
                }
            }
        } catch (Exception ex) {
            throw new RuntimeException(ex);
        }

        if (count != 0) {
            throw new IllegalArgumentException(""Found "" + count + "" cases\r\n"" + result.toString());
        }
    }

    static List<String> parseTypeArguments(String line) {
        List<String> result = new ArrayList<>();
        int offset = line.indexOf(""<"");
        int c = 1;
        int i = offset + 1;
        int j = i;
        for (; i < line.length(); i++) {
            if (line.charAt(i) == '<') {
                c++;
            } else
            if (line.charAt(i) == '>') {
                c--;
                if (c == 0) {
                    break;
                }
            } else
            if (line.charAt(i) == ',' && c == 1) {
                result.add(line.substring(j, i).trim());
                j = i + 1;
            }
        }
        result.add(line.substring(j, i).trim());
        return result;
    }

    @Test
    public void parseTypeArguments() {
        assertEquals(new ArrayList<>(Arrays.asList(""T"")), parseTypeArguments(""<T>""));
        assertEquals(new ArrayList<>(Arrays.asList(""T"", ""U"")), parseTypeArguments(""<T, U>""));
        assertEquals(new ArrayList<>(Arrays.asList(""T"", ""Flowable<U>"")), parseTypeArguments(""<T, Flowable<U>>""));
        assertEquals(new ArrayList<>(Arrays.asList(""T"", ""Flowable<U, V>"")), parseTypeArguments(""<T, Flowable<U, V>>""));
    }

    @Test
    public void flowable() {
        process(Flowable.class);
    }

    @Test
    public void observable() {
        process(Observable.class);
    }

    @Test
    public void maybe() {
        process(Maybe.class);
    }

    @Test
    public void single() {
        process(Single.class);
    }

    @Test
    public void completable() {
        process(Completable.class);
    }

    @Test
    public void parallel() {
        process(ParallelFlowable.class);
    }

    @Test
    public void plugins() {
        process(RxJavaPlugins.class);
    }
}",iterator
i,"{

    static void process(Class<?> clazz) {

        String className = clazz.getSimpleName();
        String parentPackage = clazz.getPackage().getName();

        StringBuilder result = new StringBuilder();
        int count = 0;

        try {
            File f = TestHelper.findSource(className, parentPackage);

            try (BufferedReader in = Files.newBufferedReader(f.toPath())) {
                int lineCount = 1;
                String line = null;

                while ((line = in.readLine()) != null) {
                    line = line.trim();

                    if (!line.contains("" to("")) {
                        if (line.startsWith(""public static <"") || line.startsWith(""public final <"")) {

                            for (String ta : parseTypeArguments(line)) {
                                if (!ta.startsWith(""@NonNull"") && !ta.startsWith(""@Nullable"")) {
                                    if (!(""Maybe"".equals(clazz.getSimpleName()) && (line.contains(""fromCallable("") || line.contains(""fromSupplier("")))) {
                                        result.append(""Missing annotation on argument "").append(ta).append(""\r\nat "")
                                        .append(parentPackage).append(""."").append(className).append("".method("")
                                        .append(className).append("".java:"").append(lineCount).append("")\r\n"");
                                        count++;
                                    }
                                }
                            }
                        }
                    }
                    lineCount++;
                }
            }
        } catch (Exception ex) {
            throw new RuntimeException(ex);
        }

        if (count != 0) {
            throw new IllegalArgumentException(""Found "" + count + "" cases\r\n"" + result.toString());
        }
    }

    static List<String> parseTypeArguments(String line) {
        List<String> result = new ArrayList<>();
        int offset = line.indexOf(""<"");
        int c = 1;
        int i = offset + 1;
        int j = i;
        for (; i < line.length(); i++) {
            if (line.charAt(i) == '<') {
                c++;
            } else
            if (line.charAt(i) == '>') {
                c--;
                if (c == 0) {
                    break;
                }
            } else
            if (line.charAt(i) == ',' && c == 1) {
                result.add(line.substring(j, i).trim());
                j = i + 1;
            }
        }
        result.add(line.substring(j, i).trim());
        return result;
    }

    @Test
    public void parseTypeArguments() {
        assertEquals(new ArrayList<>(Arrays.asList(""T"")), parseTypeArguments(""<T>""));
        assertEquals(new ArrayList<>(Arrays.asList(""T"", ""U"")), parseTypeArguments(""<T, U>""));
        assertEquals(new ArrayList<>(Arrays.asList(""T"", ""Flowable<U>"")), parseTypeArguments(""<T, Flowable<U>>""));
        assertEquals(new ArrayList<>(Arrays.asList(""T"", ""Flowable<U, V>"")), parseTypeArguments(""<T, Flowable<U, V>>""));
    }

    @Test
    public void flowable() {
        process(Flowable.class);
    }

    @Test
    public void observable() {
        process(Observable.class);
    }

    @Test
    public void maybe() {
        process(Maybe.class);
    }

    @Test
    public void single() {
        process(Single.class);
    }

    @Test
    public void completable() {
        process(Completable.class);
    }

    @Test
    public void parallel() {
        process(ParallelFlowable.class);
    }

    @Test
    public void plugins() {
        process(RxJavaPlugins.class);
    }
}",loop_control
c,"{

    static void process(Class<?> clazz) {

        String className = clazz.getSimpleName();
        String parentPackage = clazz.getPackage().getName();

        StringBuilder result = new StringBuilder();
        int count = 0;

        try {
            File f = TestHelper.findSource(className, parentPackage);

            try (BufferedReader in = Files.newBufferedReader(f.toPath())) {
                int lineCount = 1;
                String line = null;

                while ((line = in.readLine()) != null) {
                    line = line.trim();

                    if (!line.contains("" to("")) {
                        if (line.startsWith(""public static <"") || line.startsWith(""public final <"")) {

                            for (String ta : parseTypeArguments(line)) {
                                if (!ta.startsWith(""@NonNull"") && !ta.startsWith(""@Nullable"")) {
                                    if (!(""Maybe"".equals(clazz.getSimpleName()) && (line.contains(""fromCallable("") || line.contains(""fromSupplier("")))) {
                                        result.append(""Missing annotation on argument "").append(ta).append(""\r\nat "")
                                        .append(parentPackage).append(""."").append(className).append("".method("")
                                        .append(className).append("".java:"").append(lineCount).append("")\r\n"");
                                        count++;
                                    }
                                }
                            }
                        }
                    }
                    lineCount++;
                }
            }
        } catch (Exception ex) {
            throw new RuntimeException(ex);
        }

        if (count != 0) {
            throw new IllegalArgumentException(""Found "" + count + "" cases\r\n"" + result.toString());
        }
    }

    static List<String> parseTypeArguments(String line) {
        List<String> result = new ArrayList<>();
        int offset = line.indexOf(""<"");
        int c = 1;
        int i = offset + 1;
        int j = i;
        for (; i < line.length(); i++) {
            if (line.charAt(i) == '<') {
                c++;
            } else
            if (line.charAt(i) == '>') {
                c--;
                if (c == 0) {
                    break;
                }
            } else
            if (line.charAt(i) == ',' && c == 1) {
                result.add(line.substring(j, i).trim());
                j = i + 1;
            }
        }
        result.add(line.substring(j, i).trim());
        return result;
    }

    @Test
    public void parseTypeArguments() {
        assertEquals(new ArrayList<>(Arrays.asList(""T"")), parseTypeArguments(""<T>""));
        assertEquals(new ArrayList<>(Arrays.asList(""T"", ""U"")), parseTypeArguments(""<T, U>""));
        assertEquals(new ArrayList<>(Arrays.asList(""T"", ""Flowable<U>"")), parseTypeArguments(""<T, Flowable<U>>""));
        assertEquals(new ArrayList<>(Arrays.asList(""T"", ""Flowable<U, V>"")), parseTypeArguments(""<T, Flowable<U, V>>""));
    }

    @Test
    public void flowable() {
        process(Flowable.class);
    }

    @Test
    public void observable() {
        process(Observable.class);
    }

    @Test
    public void maybe() {
        process(Maybe.class);
    }

    @Test
    public void single() {
        process(Single.class);
    }

    @Test
    public void completable() {
        process(Completable.class);
    }

    @Test
    public void parallel() {
        process(ParallelFlowable.class);
    }

    @Test
    public void plugins() {
        process(RxJavaPlugins.class);
    }
}",break_loop_control
i,"{
        int cnt = 1;
        for (int i = 0; i < index; i++) {
            if (s.charAt(i) == '\n') {
                cnt++;
            }
        }
        return cnt;
    }",loop_control
i,"{
        int cnt = 1;
        for (int i = 0; i < index; i++) {
            if (s.charAt(i) == '\n') {
                cnt++;
            }
        }
        return cnt;
    }",loop_control
m,"{
        List<RxMethod> list = BaseTypeParser.parse(TestHelper.findSource(""Maybe""), ""Maybe"");

        assertFalse(list.isEmpty());

        StringBuilder e = new StringBuilder();

        for (RxMethod m : list) {
            int jdx;
            if (m.javadoc != null) {
                jdx = 0;
                for (;;) {
                    int idx = m.javadoc.indexOf(""onNext"", jdx);
                    if (idx >= 0) {
                        if (!m.signature.contains(""Publisher"")
                                && !m.signature.contains(""Flowable"")
                                && !m.signature.contains(""Observable"")
                                && !m.signature.contains(""ObservableSource"")) {
                            e.append(""java.lang.RuntimeException: Maybe doc mentions onNext but no Flowable/Observable in signature\r\n at io.reactivex.rxjava3.core."")
                            .append(""Maybe.method(Maybe.java:"").append(m.javadocLine + lineNumber(m.javadoc, idx) - 1).append("")\r\n\r\n"");
                        }

                        jdx = idx + 6;
                    } else {
                        break;
                    }
                }
                jdx = 0;
                for (;;) {
                    int idx = m.javadoc.indexOf(""Subscriber"", jdx);
                    if (idx >= 0) {
                        if (!m.signature.contains(""Publisher"")
                                && !m.signature.contains(""Flowable"")
                                && !m.signature.contains(""TestSubscriber"")
                        ) {
                            e.append(""java.lang.RuntimeException: Maybe doc mentions Subscriber but not using Flowable\r\n at io.reactivex.rxjava3.core."")
                            .append(""Maybe.method(Maybe.java:"").append(m.javadocLine + lineNumber(m.javadoc, idx) - 1).append("")\r\n\r\n"");
                        }

                        jdx = idx + 6;
                    } else {
                        break;
                    }
                }
                jdx = 0;
                for (;;) {
                    int idx = m.javadoc.indexOf("" Subscription"", jdx);
                    if (idx >= 0) {
                        if (!m.signature.contains(""Publisher"")
                                && !m.signature.contains(""Flowable"")
                        ) {
                            e.append(""java.lang.RuntimeException: Maybe doc mentions Subscription but not using Flowable\r\n at io.reactivex.rxjava3.core."")
                            .append(""Maybe.method(Maybe.java:"").append(m.javadocLine + lineNumber(m.javadoc, idx) - 1).append("")\r\n\r\n"");
                        }

                        jdx = idx + 6;
                    } else {
                        break;
                    }
                }
                jdx = 0;
                for (;;) {
                    int idx = m.javadoc.indexOf(""Observer"", jdx);
                    if (idx >= 0) {
                        if (!m.signature.contains(""ObservableSource"")
                                && !m.signature.contains(""Observable"")
                                && !m.signature.contains(""TestObserver"")) {

                            if (idx < 5 || !m.javadoc.substring(idx - 5, idx + 8).equals(""MaybeObserver"")) {
                                e.append(""java.lang.RuntimeException: Maybe doc mentions Observer but not using Observable\r\n at io.reactivex.rxjava3.core."")
                                .append(""Maybe.method(Maybe.java:"").append(m.javadocLine + lineNumber(m.javadoc, idx) - 1).append("")\r\n\r\n"");
                            }
                        }

                        jdx = idx + 6;
                    } else {
                        break;
                    }
                }
                jdx = 0;
                for (;;) {
                    int idx = m.javadoc.indexOf(""Publisher"", jdx);
                    if (idx >= 0) {
                        if (!m.signature.contains(""Publisher"")) {
                            if (idx == 0 || !m.javadoc.substring(idx - 1, idx + 9).equals(""(Publisher"")) {
                                e.append(""java.lang.RuntimeException: Maybe doc mentions Publisher but not in the signature\r\n at io.reactivex.rxjava3.core."")
                                .append(""Maybe.method(Maybe.java:"").append(m.javadocLine + lineNumber(m.javadoc, idx) - 1).append("")\r\n\r\n"");
                            }
                        }

                        jdx = idx + 6;
                    } else {
                        break;
                    }
                }
                jdx = 0;
                for (;;) {
                    int idx = m.javadoc.indexOf(""Flowable"", jdx);
                    if (idx >= 0) {
                        if (!m.signature.contains(""Flowable"")) {
                            Pattern p = Pattern.compile(""@see\\s+#[A-Za-z0-9 _.,()]*Flowable"");
                            if (!p.matcher(m.javadoc).find()) {
                                e.append(""java.lang.RuntimeException: Maybe doc mentions Flowable but not in the signature\r\n at io.reactivex.rxjava3.core."")
                                .append(""Maybe.method(Maybe.java:"").append(m.javadocLine + lineNumber(m.javadoc, idx) - 1).append("")\r\n\r\n"");
                            }
                        }
                        jdx = idx + 6;
                    } else {
                        break;
                    }
                }
                jdx = 0;
                for (;;) {
                    int idx = m.javadoc.indexOf(""Single"", jdx);
                    if (idx >= 0 && m.javadoc.indexOf(""Single#"", jdx) != idx) {
                        int j = m.javadoc.indexOf(""#toSingle"", jdx);
                        int k = m.javadoc.indexOf(""{@code Single"", jdx);
                        if (!m.signature.contains(""Single"") && (j + 3 != idx && k + 7 != idx)) {
                            e.append(""java.lang.RuntimeException: Maybe doc mentions Single but not in the signature\r\n at io.reactivex.rxjava3.core."")
                            .append(""Maybe.method(Maybe.java:"").append(m.javadocLine + lineNumber(m.javadoc, idx) - 1).append("")\r\n\r\n"");
                        }
                        jdx = idx + 6;
                    } else {
                        break;
                    }
                }
                jdx = 0;
                for (;;) {
                    int idx = m.javadoc.indexOf(""SingleSource"", jdx);
                    if (idx >= 0) {
                        if (!m.signature.contains(""SingleSource"")) {
                            e.append(""java.lang.RuntimeException: Maybe doc mentions SingleSource but not in the signature\r\n at io.reactivex.rxjava3.core."")
                            .append(""Maybe.method(Maybe.java:"").append(m.javadocLine + lineNumber(m.javadoc, idx) - 1).append("")\r\n\r\n"");
                        }
                        jdx = idx + 6;
                    } else {
                        break;
                    }
                }
                jdx = 0;
                for (;;) {
                    int idx = m.javadoc.indexOf(""Observable"", jdx);
                    if (idx >= 0) {
                        if (!m.signature.contains(""Observable"")) {
                            Pattern p = Pattern.compile(""@see\\s+#[A-Za-z0-9 _.,()]*Observable"");
                            if (!p.matcher(m.javadoc).find()) {
                                e.append(""java.lang.RuntimeException: Maybe doc mentions Observable but not in the signature\r\n at io.reactivex.rxjava3.core."")
                                .append(""Maybe.method(Maybe.java:"").append(m.javadocLine + lineNumber(m.javadoc, idx) - 1).append("")\r\n\r\n"");
                            }
                        }
                        jdx = idx + 6;
                    } else {
                        break;
                    }
                }
                jdx = 0;
                for (;;) {
                    int idx = m.javadoc.indexOf(""ObservableSource"", jdx);
                    if (idx >= 0) {
                        if (!m.signature.contains(""ObservableSource"")) {
                            e.append(""java.lang.RuntimeException: Maybe doc mentions ObservableSource but not in the signature\r\n at io.reactivex.rxjava3.core."")
                            .append(""Maybe.method(Maybe.java:"").append(m.javadocLine + lineNumber(m.javadoc, idx) - 1).append("")\r\n\r\n"");
                        }
                        jdx = idx + 6;
                    } else {
                        break;
                    }
                }

                checkAtReturnAndSignatureMatch(""Maybe"", m, e, ""Flowable"", ""Observable"", ""Maybe"", ""Single"", ""Completable"", ""Disposable"", ""Iterable"", ""Stream"", ""Future"", ""CompletionStage"");

                aOrAn(e, m, ""Maybe"");
                missingClosingDD(e, m, ""Maybe"", ""io.reactivex.rxjava3.core"");
                backpressureMentionedWithoutAnnotation(e, m, ""Maybe"");
            }
        }

        if (e.length() != 0) {
            System.out.println(e);

            fail(e.toString());
        }
    }",iterator
idx,"{
        List<RxMethod> list = BaseTypeParser.parse(TestHelper.findSource(""Maybe""), ""Maybe"");

        assertFalse(list.isEmpty());

        StringBuilder e = new StringBuilder();

        for (RxMethod m : list) {
            int jdx;
            if (m.javadoc != null) {
                jdx = 0;
                for (;;) {
                    int idx = m.javadoc.indexOf(""onNext"", jdx);
                    if (idx >= 0) {
                        if (!m.signature.contains(""Publisher"")
                                && !m.signature.contains(""Flowable"")
                                && !m.signature.contains(""Observable"")
                                && !m.signature.contains(""ObservableSource"")) {
                            e.append(""java.lang.RuntimeException: Maybe doc mentions onNext but no Flowable/Observable in signature\r\n at io.reactivex.rxjava3.core."")
                            .append(""Maybe.method(Maybe.java:"").append(m.javadocLine + lineNumber(m.javadoc, idx) - 1).append("")\r\n\r\n"");
                        }

                        jdx = idx + 6;
                    } else {
                        break;
                    }
                }
                jdx = 0;
                for (;;) {
                    int idx = m.javadoc.indexOf(""Subscriber"", jdx);
                    if (idx >= 0) {
                        if (!m.signature.contains(""Publisher"")
                                && !m.signature.contains(""Flowable"")
                                && !m.signature.contains(""TestSubscriber"")
                        ) {
                            e.append(""java.lang.RuntimeException: Maybe doc mentions Subscriber but not using Flowable\r\n at io.reactivex.rxjava3.core."")
                            .append(""Maybe.method(Maybe.java:"").append(m.javadocLine + lineNumber(m.javadoc, idx) - 1).append("")\r\n\r\n"");
                        }

                        jdx = idx + 6;
                    } else {
                        break;
                    }
                }
                jdx = 0;
                for (;;) {
                    int idx = m.javadoc.indexOf("" Subscription"", jdx);
                    if (idx >= 0) {
                        if (!m.signature.contains(""Publisher"")
                                && !m.signature.contains(""Flowable"")
                        ) {
                            e.append(""java.lang.RuntimeException: Maybe doc mentions Subscription but not using Flowable\r\n at io.reactivex.rxjava3.core."")
                            .append(""Maybe.method(Maybe.java:"").append(m.javadocLine + lineNumber(m.javadoc, idx) - 1).append("")\r\n\r\n"");
                        }

                        jdx = idx + 6;
                    } else {
                        break;
                    }
                }
                jdx = 0;
                for (;;) {
                    int idx = m.javadoc.indexOf(""Observer"", jdx);
                    if (idx >= 0) {
                        if (!m.signature.contains(""ObservableSource"")
                                && !m.signature.contains(""Observable"")
                                && !m.signature.contains(""TestObserver"")) {

                            if (idx < 5 || !m.javadoc.substring(idx - 5, idx + 8).equals(""MaybeObserver"")) {
                                e.append(""java.lang.RuntimeException: Maybe doc mentions Observer but not using Observable\r\n at io.reactivex.rxjava3.core."")
                                .append(""Maybe.method(Maybe.java:"").append(m.javadocLine + lineNumber(m.javadoc, idx) - 1).append("")\r\n\r\n"");
                            }
                        }

                        jdx = idx + 6;
                    } else {
                        break;
                    }
                }
                jdx = 0;
                for (;;) {
                    int idx = m.javadoc.indexOf(""Publisher"", jdx);
                    if (idx >= 0) {
                        if (!m.signature.contains(""Publisher"")) {
                            if (idx == 0 || !m.javadoc.substring(idx - 1, idx + 9).equals(""(Publisher"")) {
                                e.append(""java.lang.RuntimeException: Maybe doc mentions Publisher but not in the signature\r\n at io.reactivex.rxjava3.core."")
                                .append(""Maybe.method(Maybe.java:"").append(m.javadocLine + lineNumber(m.javadoc, idx) - 1).append("")\r\n\r\n"");
                            }
                        }

                        jdx = idx + 6;
                    } else {
                        break;
                    }
                }
                jdx = 0;
                for (;;) {
                    int idx = m.javadoc.indexOf(""Flowable"", jdx);
                    if (idx >= 0) {
                        if (!m.signature.contains(""Flowable"")) {
                            Pattern p = Pattern.compile(""@see\\s+#[A-Za-z0-9 _.,()]*Flowable"");
                            if (!p.matcher(m.javadoc).find()) {
                                e.append(""java.lang.RuntimeException: Maybe doc mentions Flowable but not in the signature\r\n at io.reactivex.rxjava3.core."")
                                .append(""Maybe.method(Maybe.java:"").append(m.javadocLine + lineNumber(m.javadoc, idx) - 1).append("")\r\n\r\n"");
                            }
                        }
                        jdx = idx + 6;
                    } else {
                        break;
                    }
                }
                jdx = 0;
                for (;;) {
                    int idx = m.javadoc.indexOf(""Single"", jdx);
                    if (idx >= 0 && m.javadoc.indexOf(""Single#"", jdx) != idx) {
                        int j = m.javadoc.indexOf(""#toSingle"", jdx);
                        int k = m.javadoc.indexOf(""{@code Single"", jdx);
                        if (!m.signature.contains(""Single"") && (j + 3 != idx && k + 7 != idx)) {
                            e.append(""java.lang.RuntimeException: Maybe doc mentions Single but not in the signature\r\n at io.reactivex.rxjava3.core."")
                            .append(""Maybe.method(Maybe.java:"").append(m.javadocLine + lineNumber(m.javadoc, idx) - 1).append("")\r\n\r\n"");
                        }
                        jdx = idx + 6;
                    } else {
                        break;
                    }
                }
                jdx = 0;
                for (;;) {
                    int idx = m.javadoc.indexOf(""SingleSource"", jdx);
                    if (idx >= 0) {
                        if (!m.signature.contains(""SingleSource"")) {
                            e.append(""java.lang.RuntimeException: Maybe doc mentions SingleSource but not in the signature\r\n at io.reactivex.rxjava3.core."")
                            .append(""Maybe.method(Maybe.java:"").append(m.javadocLine + lineNumber(m.javadoc, idx) - 1).append("")\r\n\r\n"");
                        }
                        jdx = idx + 6;
                    } else {
                        break;
                    }
                }
                jdx = 0;
                for (;;) {
                    int idx = m.javadoc.indexOf(""Observable"", jdx);
                    if (idx >= 0) {
                        if (!m.signature.contains(""Observable"")) {
                            Pattern p = Pattern.compile(""@see\\s+#[A-Za-z0-9 _.,()]*Observable"");
                            if (!p.matcher(m.javadoc).find()) {
                                e.append(""java.lang.RuntimeException: Maybe doc mentions Observable but not in the signature\r\n at io.reactivex.rxjava3.core."")
                                .append(""Maybe.method(Maybe.java:"").append(m.javadocLine + lineNumber(m.javadoc, idx) - 1).append("")\r\n\r\n"");
                            }
                        }
                        jdx = idx + 6;
                    } else {
                        break;
                    }
                }
                jdx = 0;
                for (;;) {
                    int idx = m.javadoc.indexOf(""ObservableSource"", jdx);
                    if (idx >= 0) {
                        if (!m.signature.contains(""ObservableSource"")) {
                            e.append(""java.lang.RuntimeException: Maybe doc mentions ObservableSource but not in the signature\r\n at io.reactivex.rxjava3.core."")
                            .append(""Maybe.method(Maybe.java:"").append(m.javadocLine + lineNumber(m.javadoc, idx) - 1).append("")\r\n\r\n"");
                        }
                        jdx = idx + 6;
                    } else {
                        break;
                    }
                }

                checkAtReturnAndSignatureMatch(""Maybe"", m, e, ""Flowable"", ""Observable"", ""Maybe"", ""Single"", ""Completable"", ""Disposable"", ""Iterable"", ""Stream"", ""Future"", ""CompletionStage"");

                aOrAn(e, m, ""Maybe"");
                missingClosingDD(e, m, ""Maybe"", ""io.reactivex.rxjava3.core"");
                backpressureMentionedWithoutAnnotation(e, m, ""Maybe"");
            }
        }

        if (e.length() != 0) {
            System.out.println(e);

            fail(e.toString());
        }
    }",break_loop_control
m,"{
        List<RxMethod> list = BaseTypeParser.parse(TestHelper.findSource(""Flowable""), ""Flowable"");

        assertFalse(list.isEmpty());

        StringBuilder e = new StringBuilder();

        for (RxMethod m : list) {
            int jdx;
            if (m.javadoc != null) {
                jdx = 0;
                for (;;) {
                    int idx = m.javadoc.indexOf(""onSuccess"", jdx);
                    if (idx >= 0) {
                        if (!m.signature.contains(""Maybe"")
                                && !m.signature.contains(""MaybeSource"")
                                && !m.signature.contains(""Single"")
                                && !m.signature.contains(""SingleSource"")) {
                            e.append(""java.lang.RuntimeException: Flowable doc mentions onSuccess\r\n at io.reactivex.rxjava3.core."")
                            .append(""Flowable.method(Flowable.java:"").append(m.javadocLine + lineNumber(m.javadoc, idx) - 1).append("")\r\n\r\n"");
                        }

                        jdx = idx + 6;
                    } else {
                        break;
                    }
                }
                jdx = 0;
                for (;;) {
                    int idx = m.javadoc.indexOf("" Observer"", jdx);
                    if (idx >= 0) {
                        if (!m.signature.contains(""ObservableSource"")
                                && !m.signature.contains(""Observable"")) {
                            e.append(""java.lang.RuntimeException: Flowable doc mentions Observer but not using Observable\r\n at io.reactivex.rxjava3.core."")
                            .append(""Flowable.method(Flowable.java:"").append(m.javadocLine + lineNumber(m.javadoc, idx) - 1).append("")\r\n\r\n"");
                        }

                        jdx = idx + 6;
                    } else {
                        break;
                    }
                }
                jdx = 0;
                for (;;) {
                    int idx = m.javadoc.indexOf("" SingleObserver"", jdx);
                    if (idx >= 0) {
                        if (!m.signature.contains(""SingleSource"")
                                && !m.signature.contains(""Single"")) {
                            e.append(""java.lang.RuntimeException: Flowable doc mentions SingleObserver but not using Single\r\n at io.reactivex.rxjava3.core."")
                            .append(""Flowable.method(Flowable.java:"").append(m.javadocLine + lineNumber(m.javadoc, idx) - 1).append("")\r\n\r\n"");
                        }

                        jdx = idx + 6;
                    } else {
                        break;
                    }
                }
                jdx = 0;
                for (;;) {
                    int idx = m.javadoc.indexOf("" MaybeObserver"", jdx);
                    if (idx >= 0) {
                        if (!m.signature.contains(""MaybeSource"")
                                && !m.signature.contains(""Maybe"")) {
                            e.append(""java.lang.RuntimeException: Flowable doc mentions MaybeObserver but not using Maybe\r\n at io.reactivex.rxjava3.core."")
                            .append(""Flowable.method(Flowable.java:"").append(m.javadocLine + lineNumber(m.javadoc, idx) - 1).append("")\r\n\r\n"");
                        }

                        jdx = idx + 6;
                    } else {
                        break;
                    }
                }
                jdx = 0;
                for (;;) {
                    int idx = m.javadoc.indexOf("" Disposable"", jdx);
                    if (idx >= 0) {
                        if (!m.signature.contains(""Observable"")
                                && !m.signature.contains(""ObservableSource"")
                                && !m.signature.contains(""Single"")
                                && !m.signature.contains(""SingleSource"")
                                && !m.signature.contains(""Completable"")
                                && !m.signature.contains(""CompletableSource"")
                                && !m.signature.contains(""Maybe"")
                                && !m.signature.contains(""MaybeSource"")
                                && !m.signature.contains(""Disposable"")
                                && !m.signature.contains(""void subscribe"")
                        ) {
                            CharSequence subSequence = m.javadoc.subSequence(idx - 6, idx + 11);
                            if (idx < 6 || !subSequence.equals(""{@link Disposable"")) {
                                e.append(""java.lang.RuntimeException: Flowable doc mentions Disposable but not using Flowable\r\n at io.reactivex.rxjava3.core."")
                                .append(""Flowable.method(Flowable.java:"").append(m.javadocLine + lineNumber(m.javadoc, idx) - 1).append("")\r\n\r\n"");
                            }
                        }

                        jdx = idx + 6;
                    } else {
                        break;
                    }
                }
                jdx = 0;
                for (;;) {
                    int idx = m.javadoc.indexOf(""Observable"", jdx);
                    if (idx >= 0) {
                        if (!m.signature.contains(""Observable"")) {
                            e.append(""java.lang.RuntimeException: Flowable doc mentions Observable but not in the signature\r\n at io.reactivex.rxjava3.core."")
                            .append(""Flowable.method(Flowable.java:"").append(m.javadocLine + lineNumber(m.javadoc, idx) - 1).append("")\r\n\r\n"");
                        }

                        jdx = idx + 6;
                    } else {
                        break;
                    }
                }
                jdx = 0;
                for (;;) {
                    int idx = m.javadoc.indexOf(""ObservableSource"", jdx);
                    if (idx >= 0) {
                        if (!m.signature.contains(""ObservableSource"")) {
                            e.append(""java.lang.RuntimeException: Flowable doc mentions ObservableSource but not in the signature\r\n at io.reactivex.rxjava3.core."")
                            .append(""Flowable.method(Flowable.java:"").append(m.javadocLine + lineNumber(m.javadoc, idx) - 1).append("")\r\n\r\n"");
                        }
                        jdx = idx + 6;
                    } else {
                        break;
                    }
                }

                checkAtReturnAndSignatureMatch(""Flowable"", m, e, ""Flowable"", ""Observable"", ""Maybe"", ""Single"", ""Completable"", ""ConnectableFlowable"", ""ParallelFlowable"", ""Disposable"", ""Iterable"", ""Stream"", ""Future"", ""CompletionStage"");

                aOrAn(e, m, ""Flowable"");
                missingClosingDD(e, m, ""Flowable"", ""io.reactivex.rxjava3.core"");
                backpressureMentionedWithoutAnnotation(e, m, ""Flowable"");
            }
        }

        if (e.length() != 0) {
            System.out.println(e);

            fail(e.toString());
        }
    }",iterator
idx,"{
        List<RxMethod> list = BaseTypeParser.parse(TestHelper.findSource(""Flowable""), ""Flowable"");

        assertFalse(list.isEmpty());

        StringBuilder e = new StringBuilder();

        for (RxMethod m : list) {
            int jdx;
            if (m.javadoc != null) {
                jdx = 0;
                for (;;) {
                    int idx = m.javadoc.indexOf(""onSuccess"", jdx);
                    if (idx >= 0) {
                        if (!m.signature.contains(""Maybe"")
                                && !m.signature.contains(""MaybeSource"")
                                && !m.signature.contains(""Single"")
                                && !m.signature.contains(""SingleSource"")) {
                            e.append(""java.lang.RuntimeException: Flowable doc mentions onSuccess\r\n at io.reactivex.rxjava3.core."")
                            .append(""Flowable.method(Flowable.java:"").append(m.javadocLine + lineNumber(m.javadoc, idx) - 1).append("")\r\n\r\n"");
                        }

                        jdx = idx + 6;
                    } else {
                        break;
                    }
                }
                jdx = 0;
                for (;;) {
                    int idx = m.javadoc.indexOf("" Observer"", jdx);
                    if (idx >= 0) {
                        if (!m.signature.contains(""ObservableSource"")
                                && !m.signature.contains(""Observable"")) {
                            e.append(""java.lang.RuntimeException: Flowable doc mentions Observer but not using Observable\r\n at io.reactivex.rxjava3.core."")
                            .append(""Flowable.method(Flowable.java:"").append(m.javadocLine + lineNumber(m.javadoc, idx) - 1).append("")\r\n\r\n"");
                        }

                        jdx = idx + 6;
                    } else {
                        break;
                    }
                }
                jdx = 0;
                for (;;) {
                    int idx = m.javadoc.indexOf("" SingleObserver"", jdx);
                    if (idx >= 0) {
                        if (!m.signature.contains(""SingleSource"")
                                && !m.signature.contains(""Single"")) {
                            e.append(""java.lang.RuntimeException: Flowable doc mentions SingleObserver but not using Single\r\n at io.reactivex.rxjava3.core."")
                            .append(""Flowable.method(Flowable.java:"").append(m.javadocLine + lineNumber(m.javadoc, idx) - 1).append("")\r\n\r\n"");
                        }

                        jdx = idx + 6;
                    } else {
                        break;
                    }
                }
                jdx = 0;
                for (;;) {
                    int idx = m.javadoc.indexOf("" MaybeObserver"", jdx);
                    if (idx >= 0) {
                        if (!m.signature.contains(""MaybeSource"")
                                && !m.signature.contains(""Maybe"")) {
                            e.append(""java.lang.RuntimeException: Flowable doc mentions MaybeObserver but not using Maybe\r\n at io.reactivex.rxjava3.core."")
                            .append(""Flowable.method(Flowable.java:"").append(m.javadocLine + lineNumber(m.javadoc, idx) - 1).append("")\r\n\r\n"");
                        }

                        jdx = idx + 6;
                    } else {
                        break;
                    }
                }
                jdx = 0;
                for (;;) {
                    int idx = m.javadoc.indexOf("" Disposable"", jdx);
                    if (idx >= 0) {
                        if (!m.signature.contains(""Observable"")
                                && !m.signature.contains(""ObservableSource"")
                                && !m.signature.contains(""Single"")
                                && !m.signature.contains(""SingleSource"")
                                && !m.signature.contains(""Completable"")
                                && !m.signature.contains(""CompletableSource"")
                                && !m.signature.contains(""Maybe"")
                                && !m.signature.contains(""MaybeSource"")
                                && !m.signature.contains(""Disposable"")
                                && !m.signature.contains(""void subscribe"")
                        ) {
                            CharSequence subSequence = m.javadoc.subSequence(idx - 6, idx + 11);
                            if (idx < 6 || !subSequence.equals(""{@link Disposable"")) {
                                e.append(""java.lang.RuntimeException: Flowable doc mentions Disposable but not using Flowable\r\n at io.reactivex.rxjava3.core."")
                                .append(""Flowable.method(Flowable.java:"").append(m.javadocLine + lineNumber(m.javadoc, idx) - 1).append("")\r\n\r\n"");
                            }
                        }

                        jdx = idx + 6;
                    } else {
                        break;
                    }
                }
                jdx = 0;
                for (;;) {
                    int idx = m.javadoc.indexOf(""Observable"", jdx);
                    if (idx >= 0) {
                        if (!m.signature.contains(""Observable"")) {
                            e.append(""java.lang.RuntimeException: Flowable doc mentions Observable but not in the signature\r\n at io.reactivex.rxjava3.core."")
                            .append(""Flowable.method(Flowable.java:"").append(m.javadocLine + lineNumber(m.javadoc, idx) - 1).append("")\r\n\r\n"");
                        }

                        jdx = idx + 6;
                    } else {
                        break;
                    }
                }
                jdx = 0;
                for (;;) {
                    int idx = m.javadoc.indexOf(""ObservableSource"", jdx);
                    if (idx >= 0) {
                        if (!m.signature.contains(""ObservableSource"")) {
                            e.append(""java.lang.RuntimeException: Flowable doc mentions ObservableSource but not in the signature\r\n at io.reactivex.rxjava3.core."")
                            .append(""Flowable.method(Flowable.java:"").append(m.javadocLine + lineNumber(m.javadoc, idx) - 1).append("")\r\n\r\n"");
                        }
                        jdx = idx + 6;
                    } else {
                        break;
                    }
                }

                checkAtReturnAndSignatureMatch(""Flowable"", m, e, ""Flowable"", ""Observable"", ""Maybe"", ""Single"", ""Completable"", ""ConnectableFlowable"", ""ParallelFlowable"", ""Disposable"", ""Iterable"", ""Stream"", ""Future"", ""CompletionStage"");

                aOrAn(e, m, ""Flowable"");
                missingClosingDD(e, m, ""Flowable"", ""io.reactivex.rxjava3.core"");
                backpressureMentionedWithoutAnnotation(e, m, ""Flowable"");
            }
        }

        if (e.length() != 0) {
            System.out.println(e);

            fail(e.toString());
        }
    }",break_loop_control
m,"{
        List<RxMethod> list = BaseTypeParser.parse(TestHelper.findSource(""ParallelFlowable"", ""io.reactivex.rxjava3.parallel""), ""ParallelFlowable"");

        assertFalse(list.isEmpty());

        StringBuilder e = new StringBuilder();

        for (RxMethod m : list) {
            int jdx;
            if (m.javadoc != null) {
                jdx = 0;
                for (;;) {
                    int idx = m.javadoc.indexOf(""onSuccess"", jdx);
                    if (idx >= 0) {
                        if (!m.signature.contains(""Maybe"")
                                && !m.signature.contains(""MaybeSource"")
                                && !m.signature.contains(""Single"")
                                && !m.signature.contains(""SingleSource"")) {
                            e.append(""java.lang.RuntimeException: Flowable doc mentions onSuccess\r\n at io.reactivex.rxjava3.core."")
                            .append(""Flowable.method(Flowable.java:"").append(m.javadocLine + lineNumber(m.javadoc, idx) - 1).append("")\r\n\r\n"");
                        }

                        jdx = idx + 6;
                    } else {
                        break;
                    }
                }
                jdx = 0;
                for (;;) {
                    int idx = m.javadoc.indexOf("" Observer"", jdx);
                    if (idx >= 0) {
                        if (!m.signature.contains(""ObservableSource"")
                                && !m.signature.contains(""Observable"")) {
                            e.append(""java.lang.RuntimeException: Flowable doc mentions Observer but not using Observable\r\n at io.reactivex.rxjava3.core."")
                            .append(""Flowable.method(Flowable.java:"").append(m.javadocLine + lineNumber(m.javadoc, idx) - 1).append("")\r\n\r\n"");
                        }

                        jdx = idx + 6;
                    } else {
                        break;
                    }
                }
                jdx = 0;
                for (;;) {
                    int idx = m.javadoc.indexOf("" SingleObserver"", jdx);
                    if (idx >= 0) {
                        if (!m.signature.contains(""SingleSource"")
                                && !m.signature.contains(""Single"")) {
                            e.append(""java.lang.RuntimeException: Flowable doc mentions SingleObserver but not using Single\r\n at io.reactivex.rxjava3.core."")
                            .append(""Flowable.method(Flowable.java:"").append(m.javadocLine + lineNumber(m.javadoc, idx) - 1).append("")\r\n\r\n"");
                        }

                        jdx = idx + 6;
                    } else {
                        break;
                    }
                }
                jdx = 0;
                for (;;) {
                    int idx = m.javadoc.indexOf("" MaybeObserver"", jdx);
                    if (idx >= 0) {
                        if (!m.signature.contains(""MaybeSource"")
                                && !m.signature.contains(""Maybe"")) {
                            e.append(""java.lang.RuntimeException: Flowable doc mentions MaybeObserver but not using Maybe\r\n at io.reactivex.rxjava3.core."")
                            .append(""Flowable.method(Flowable.java:"").append(m.javadocLine + lineNumber(m.javadoc, idx) - 1).append("")\r\n\r\n"");
                        }

                        jdx = idx + 6;
                    } else {
                        break;
                    }
                }
                jdx = 0;
                for (;;) {
                    int idx = m.javadoc.indexOf("" Disposable"", jdx);
                    if (idx >= 0) {
                        if (!m.signature.contains(""Observable"")
                                && !m.signature.contains(""ObservableSource"")
                                && !m.signature.contains(""Single"")
                                && !m.signature.contains(""SingleSource"")
                                && !m.signature.contains(""Completable"")
                                && !m.signature.contains(""CompletableSource"")
                                && !m.signature.contains(""Maybe"")
                                && !m.signature.contains(""MaybeSource"")
                                && !m.signature.contains(""Disposable"")
                        ) {
                            CharSequence subSequence = m.javadoc.subSequence(idx - 6, idx + 11);
                            if (idx < 6 || !subSequence.equals(""{@link Disposable"")) {
                                e.append(""java.lang.RuntimeException: Flowable doc mentions Disposable but not using Flowable\r\n at io.reactivex.rxjava3.core."")
                                .append(""Flowable.method(Flowable.java:"").append(m.javadocLine + lineNumber(m.javadoc, idx) - 1).append("")\r\n\r\n"");
                            }
                        }

                        jdx = idx + 6;
                    } else {
                        break;
                    }
                }
                jdx = 0;
                for (;;) {
                    int idx = m.javadoc.indexOf(""Observable"", jdx);
                    if (idx >= 0) {
                        if (!m.signature.contains(""Observable"")) {
                            e.append(""java.lang.RuntimeException: Flowable doc mentions Observable but not in the signature\r\n at io.reactivex.rxjava3.core."")
                            .append(""Flowable.method(Flowable.java:"").append(m.javadocLine + lineNumber(m.javadoc, idx) - 1).append("")\r\n\r\n"");
                        }

                        jdx = idx + 6;
                    } else {
                        break;
                    }
                }
                jdx = 0;
                for (;;) {
                    int idx = m.javadoc.indexOf(""ObservableSource"", jdx);
                    if (idx >= 0) {
                        if (!m.signature.contains(""ObservableSource"")) {
                            e.append(""java.lang.RuntimeException: Flowable doc mentions ObservableSource but not in the signature\r\n at io.reactivex.rxjava3.core."")
                            .append(""Flowable.method(Flowable.java:"").append(m.javadocLine + lineNumber(m.javadoc, idx) - 1).append("")\r\n\r\n"");
                        }
                        jdx = idx + 6;
                    } else {
                        break;
                    }
                }

                checkAtReturnAndSignatureMatch(""ParallelFlowable"", m, e, ""Flowable"", ""Observable"", ""Maybe"", ""Single"", ""Completable"", ""ConnectableFlowable"", ""ParallelFlowable"", ""Disposable"", ""Iterable"", ""Stream"", ""Future"", ""CompletionStage"");

                aOrAn(e, m, ""ParallelFlowable"");
                missingClosingDD(e, m, ""ParallelFlowable"", ""io.reactivex.rxjava3.parallel"");
                backpressureMentionedWithoutAnnotation(e, m, ""ParallelFlowable"");
            }
        }

        if (e.length() != 0) {
            System.out.println(e);

            fail(e.toString());
        }
    }",iterator
idx,"{
        List<RxMethod> list = BaseTypeParser.parse(TestHelper.findSource(""ParallelFlowable"", ""io.reactivex.rxjava3.parallel""), ""ParallelFlowable"");

        assertFalse(list.isEmpty());

        StringBuilder e = new StringBuilder();

        for (RxMethod m : list) {
            int jdx;
            if (m.javadoc != null) {
                jdx = 0;
                for (;;) {
                    int idx = m.javadoc.indexOf(""onSuccess"", jdx);
                    if (idx >= 0) {
                        if (!m.signature.contains(""Maybe"")
                                && !m.signature.contains(""MaybeSource"")
                                && !m.signature.contains(""Single"")
                                && !m.signature.contains(""SingleSource"")) {
                            e.append(""java.lang.RuntimeException: Flowable doc mentions onSuccess\r\n at io.reactivex.rxjava3.core."")
                            .append(""Flowable.method(Flowable.java:"").append(m.javadocLine + lineNumber(m.javadoc, idx) - 1).append("")\r\n\r\n"");
                        }

                        jdx = idx + 6;
                    } else {
                        break;
                    }
                }
                jdx = 0;
                for (;;) {
                    int idx = m.javadoc.indexOf("" Observer"", jdx);
                    if (idx >= 0) {
                        if (!m.signature.contains(""ObservableSource"")
                                && !m.signature.contains(""Observable"")) {
                            e.append(""java.lang.RuntimeException: Flowable doc mentions Observer but not using Observable\r\n at io.reactivex.rxjava3.core."")
                            .append(""Flowable.method(Flowable.java:"").append(m.javadocLine + lineNumber(m.javadoc, idx) - 1).append("")\r\n\r\n"");
                        }

                        jdx = idx + 6;
                    } else {
                        break;
                    }
                }
                jdx = 0;
                for (;;) {
                    int idx = m.javadoc.indexOf("" SingleObserver"", jdx);
                    if (idx >= 0) {
                        if (!m.signature.contains(""SingleSource"")
                                && !m.signature.contains(""Single"")) {
                            e.append(""java.lang.RuntimeException: Flowable doc mentions SingleObserver but not using Single\r\n at io.reactivex.rxjava3.core."")
                            .append(""Flowable.method(Flowable.java:"").append(m.javadocLine + lineNumber(m.javadoc, idx) - 1).append("")\r\n\r\n"");
                        }

                        jdx = idx + 6;
                    } else {
                        break;
                    }
                }
                jdx = 0;
                for (;;) {
                    int idx = m.javadoc.indexOf("" MaybeObserver"", jdx);
                    if (idx >= 0) {
                        if (!m.signature.contains(""MaybeSource"")
                                && !m.signature.contains(""Maybe"")) {
                            e.append(""java.lang.RuntimeException: Flowable doc mentions MaybeObserver but not using Maybe\r\n at io.reactivex.rxjava3.core."")
                            .append(""Flowable.method(Flowable.java:"").append(m.javadocLine + lineNumber(m.javadoc, idx) - 1).append("")\r\n\r\n"");
                        }

                        jdx = idx + 6;
                    } else {
                        break;
                    }
                }
                jdx = 0;
                for (;;) {
                    int idx = m.javadoc.indexOf("" Disposable"", jdx);
                    if (idx >= 0) {
                        if (!m.signature.contains(""Observable"")
                                && !m.signature.contains(""ObservableSource"")
                                && !m.signature.contains(""Single"")
                                && !m.signature.contains(""SingleSource"")
                                && !m.signature.contains(""Completable"")
                                && !m.signature.contains(""CompletableSource"")
                                && !m.signature.contains(""Maybe"")
                                && !m.signature.contains(""MaybeSource"")
                                && !m.signature.contains(""Disposable"")
                        ) {
                            CharSequence subSequence = m.javadoc.subSequence(idx - 6, idx + 11);
                            if (idx < 6 || !subSequence.equals(""{@link Disposable"")) {
                                e.append(""java.lang.RuntimeException: Flowable doc mentions Disposable but not using Flowable\r\n at io.reactivex.rxjava3.core."")
                                .append(""Flowable.method(Flowable.java:"").append(m.javadocLine + lineNumber(m.javadoc, idx) - 1).append("")\r\n\r\n"");
                            }
                        }

                        jdx = idx + 6;
                    } else {
                        break;
                    }
                }
                jdx = 0;
                for (;;) {
                    int idx = m.javadoc.indexOf(""Observable"", jdx);
                    if (idx >= 0) {
                        if (!m.signature.contains(""Observable"")) {
                            e.append(""java.lang.RuntimeException: Flowable doc mentions Observable but not in the signature\r\n at io.reactivex.rxjava3.core."")
                            .append(""Flowable.method(Flowable.java:"").append(m.javadocLine + lineNumber(m.javadoc, idx) - 1).append("")\r\n\r\n"");
                        }

                        jdx = idx + 6;
                    } else {
                        break;
                    }
                }
                jdx = 0;
                for (;;) {
                    int idx = m.javadoc.indexOf(""ObservableSource"", jdx);
                    if (idx >= 0) {
                        if (!m.signature.contains(""ObservableSource"")) {
                            e.append(""java.lang.RuntimeException: Flowable doc mentions ObservableSource but not in the signature\r\n at io.reactivex.rxjava3.core."")
                            .append(""Flowable.method(Flowable.java:"").append(m.javadocLine + lineNumber(m.javadoc, idx) - 1).append("")\r\n\r\n"");
                        }
                        jdx = idx + 6;
                    } else {
                        break;
                    }
                }

                checkAtReturnAndSignatureMatch(""ParallelFlowable"", m, e, ""Flowable"", ""Observable"", ""Maybe"", ""Single"", ""Completable"", ""ConnectableFlowable"", ""ParallelFlowable"", ""Disposable"", ""Iterable"", ""Stream"", ""Future"", ""CompletionStage"");

                aOrAn(e, m, ""ParallelFlowable"");
                missingClosingDD(e, m, ""ParallelFlowable"", ""io.reactivex.rxjava3.parallel"");
                backpressureMentionedWithoutAnnotation(e, m, ""ParallelFlowable"");
            }
        }

        if (e.length() != 0) {
            System.out.println(e);

            fail(e.toString());
        }
    }",break_loop_control
m,"{
        List<RxMethod> list = BaseTypeParser.parse(TestHelper.findSource(""Observable""), ""Observable"");

        assertFalse(list.isEmpty());

        StringBuilder e = new StringBuilder();

        for (RxMethod m : list) {
            int jdx;
            if (m.javadoc != null) {
                jdx = 0;
                for (;;) {
                    int idx = m.javadoc.indexOf(""onSuccess"", jdx);
                    if (idx >= 0) {
                        if (!m.signature.contains(""Maybe"")
                                && !m.signature.contains(""MaybeSource"")
                                && !m.signature.contains(""Single"")
                                && !m.signature.contains(""SingleSource"")) {
                            e.append(""java.lang.RuntimeException: Observable doc mentions onSuccess\r\n at io.reactivex.rxjava3.core."")
                            .append(""Observable.method(Observable.java:"").append(m.javadocLine + lineNumber(m.javadoc, idx) - 1).append("")\r\n\r\n"");
                        }

                        jdx = idx + 6;
                    } else {
                        break;
                    }
                }
                jdx = 0;
                for (;;) {
                    int idx = m.javadoc.indexOf("" Subscription"", jdx);
                    if (idx >= 0) {
                        if (!m.signature.contains(""Flowable"")
                                && !m.signature.contains(""Publisher"")
                        ) {
                            e.append(""java.lang.RuntimeException: Observable doc mentions Subscription but not using Flowable\r\n at io.reactivex.rxjava3.core."")
                            .append(""Observable.method(Observable.java:"").append(m.javadocLine + lineNumber(m.javadoc, idx) - 1).append("")\r\n\r\n"");
                        }

                        jdx = idx + 6;
                    } else {
                        break;
                    }
                }
                jdx = 0;
                for (;;) {
                    int idx = m.javadoc.indexOf(""Flowable"", jdx);
                    if (idx >= 0) {
                        if (!m.signature.contains(""Flowable"")) {
                            if (idx < 6 || !m.javadoc.substring(idx - 6, idx + 8).equals(""@link Flowable"")) {
                                e.append(""java.lang.RuntimeException: Observable doc mentions Flowable but not in the signature\r\n at io.reactivex.rxjava3.core."")
                                .append(""Observable.method(Observable.java:"").append(m.javadocLine + lineNumber(m.javadoc, idx) - 1).append("")\r\n\r\n"");
                            }
                        }

                        jdx = idx + 6;
                    } else {
                        break;
                    }
                }
                jdx = 0;
                for (;;) {
                    int idx = m.javadoc.indexOf(""Publisher"", jdx);
                    if (idx >= 0) {
                        if (!m.signature.contains(""Publisher"")) {
                            e.append(""java.lang.RuntimeException: Observable doc mentions Publisher but not in the signature\r\n at io.reactivex.rxjava3.core."")
                            .append(""Observable.method(Observable.java:"").append(m.javadocLine + lineNumber(m.javadoc, idx) - 1).append("")\r\n\r\n"");
                        }
                        jdx = idx + 6;
                    } else {
                        break;
                    }
                }
                jdx = 0;
                for (;;) {
                    int idx = m.javadoc.indexOf(""Subscriber"", jdx);
                    if (idx >= 0) {
                        if (!m.signature.contains(""Publisher"")
                                && !m.signature.contains(""Flowable"")) {
                            e.append(""java.lang.RuntimeException: Observable doc mentions Subscriber but not using Flowable\r\n at io.reactivex.rxjava3.core."")
                            .append(""Observable.method(Observable.java:"").append(m.javadocLine + lineNumber(m.javadoc, idx) - 1).append("")\r\n\r\n"");
                        }

                        jdx = idx + 6;
                    } else {
                        break;
                    }
                }
                checkAtReturnAndSignatureMatch(""Observable"", m, e, ""Flowable"", ""Observable"", ""Maybe"", ""Single"", ""Completable"", ""ConnectableObservable"", ""Disposable"", ""Iterable"", ""Stream"", ""Future"", ""CompletionStage"");

                aOrAn(e, m, ""Observable"");
                missingClosingDD(e, m, ""Observable"", ""io.reactivex.rxjava3.core"");
                backpressureMentionedWithoutAnnotation(e, m, ""Observable"");
            }
        }

        if (e.length() != 0) {
            System.out.println(e);

            fail(e.toString());
        }
    }",iterator
idx,"{
        List<RxMethod> list = BaseTypeParser.parse(TestHelper.findSource(""Observable""), ""Observable"");

        assertFalse(list.isEmpty());

        StringBuilder e = new StringBuilder();

        for (RxMethod m : list) {
            int jdx;
            if (m.javadoc != null) {
                jdx = 0;
                for (;;) {
                    int idx = m.javadoc.indexOf(""onSuccess"", jdx);
                    if (idx >= 0) {
                        if (!m.signature.contains(""Maybe"")
                                && !m.signature.contains(""MaybeSource"")
                                && !m.signature.contains(""Single"")
                                && !m.signature.contains(""SingleSource"")) {
                            e.append(""java.lang.RuntimeException: Observable doc mentions onSuccess\r\n at io.reactivex.rxjava3.core."")
                            .append(""Observable.method(Observable.java:"").append(m.javadocLine + lineNumber(m.javadoc, idx) - 1).append("")\r\n\r\n"");
                        }

                        jdx = idx + 6;
                    } else {
                        break;
                    }
                }
                jdx = 0;
                for (;;) {
                    int idx = m.javadoc.indexOf("" Subscription"", jdx);
                    if (idx >= 0) {
                        if (!m.signature.contains(""Flowable"")
                                && !m.signature.contains(""Publisher"")
                        ) {
                            e.append(""java.lang.RuntimeException: Observable doc mentions Subscription but not using Flowable\r\n at io.reactivex.rxjava3.core."")
                            .append(""Observable.method(Observable.java:"").append(m.javadocLine + lineNumber(m.javadoc, idx) - 1).append("")\r\n\r\n"");
                        }

                        jdx = idx + 6;
                    } else {
                        break;
                    }
                }
                jdx = 0;
                for (;;) {
                    int idx = m.javadoc.indexOf(""Flowable"", jdx);
                    if (idx >= 0) {
                        if (!m.signature.contains(""Flowable"")) {
                            if (idx < 6 || !m.javadoc.substring(idx - 6, idx + 8).equals(""@link Flowable"")) {
                                e.append(""java.lang.RuntimeException: Observable doc mentions Flowable but not in the signature\r\n at io.reactivex.rxjava3.core."")
                                .append(""Observable.method(Observable.java:"").append(m.javadocLine + lineNumber(m.javadoc, idx) - 1).append("")\r\n\r\n"");
                            }
                        }

                        jdx = idx + 6;
                    } else {
                        break;
                    }
                }
                jdx = 0;
                for (;;) {
                    int idx = m.javadoc.indexOf(""Publisher"", jdx);
                    if (idx >= 0) {
                        if (!m.signature.contains(""Publisher"")) {
                            e.append(""java.lang.RuntimeException: Observable doc mentions Publisher but not in the signature\r\n at io.reactivex.rxjava3.core."")
                            .append(""Observable.method(Observable.java:"").append(m.javadocLine + lineNumber(m.javadoc, idx) - 1).append("")\r\n\r\n"");
                        }
                        jdx = idx + 6;
                    } else {
                        break;
                    }
                }
                jdx = 0;
                for (;;) {
                    int idx = m.javadoc.indexOf(""Subscriber"", jdx);
                    if (idx >= 0) {
                        if (!m.signature.contains(""Publisher"")
                                && !m.signature.contains(""Flowable"")) {
                            e.append(""java.lang.RuntimeException: Observable doc mentions Subscriber but not using Flowable\r\n at io.reactivex.rxjava3.core."")
                            .append(""Observable.method(Observable.java:"").append(m.javadocLine + lineNumber(m.javadoc, idx) - 1).append("")\r\n\r\n"");
                        }

                        jdx = idx + 6;
                    } else {
                        break;
                    }
                }
                checkAtReturnAndSignatureMatch(""Observable"", m, e, ""Flowable"", ""Observable"", ""Maybe"", ""Single"", ""Completable"", ""ConnectableObservable"", ""Disposable"", ""Iterable"", ""Stream"", ""Future"", ""CompletionStage"");

                aOrAn(e, m, ""Observable"");
                missingClosingDD(e, m, ""Observable"", ""io.reactivex.rxjava3.core"");
                backpressureMentionedWithoutAnnotation(e, m, ""Observable"");
            }
        }

        if (e.length() != 0) {
            System.out.println(e);

            fail(e.toString());
        }
    }",maybe_loop_control
idx,"{
        List<RxMethod> list = BaseTypeParser.parse(TestHelper.findSource(""Single""), ""Single"");

        assertFalse(list.isEmpty());

        StringBuilder e = new StringBuilder();

        for (RxMethod m : list) {
            int jdx;
            if (m.javadoc != null) {
                jdx = 0;
                for (;;) {
                    int idx = m.javadoc.indexOf(""onNext"", jdx);
                    if (idx >= 0) {
                        if (!m.signature.contains(""Publisher"")
                                && !m.signature.contains(""Flowable"")
                                && !m.signature.contains(""Observable"")
                                && !m.signature.contains(""ObservableSource"")) {
                            e.append(""java.lang.RuntimeException: Single doc mentions onNext but no Flowable/Observable in signature\r\n at io.reactivex.rxjava3.core."")
                            .append(""Single.method(Single.java:"").append(m.javadocLine + lineNumber(m.javadoc, idx) - 1).append("")\r\n\r\n"");
                        }

                        jdx = idx + 6;
                    } else {
                        break;
                    }
                }
                jdx = 0;
                for (;;) {
                    int idx = m.javadoc.indexOf(""Subscriber"", jdx);
                    if (idx >= 0) {
                        if (!m.signature.contains(""Publisher"")
                                && !m.signature.contains(""Flowable"")
                                && !m.signature.contains(""TestSubscriber"")) {
                            e.append(""java.lang.RuntimeException: Single doc mentions Subscriber but not using Flowable\r\n at io.reactivex.rxjava3.core."")
                            .append(""Single.method(Single.java:"").append(m.javadocLine + lineNumber(m.javadoc, idx) - 1).append("")\r\n\r\n"");
                        }

                        jdx = idx + 6;
                    } else {
                        break;
                    }
                }
                jdx = 0;
                for (;;) {
                    int idx = m.javadoc.indexOf("" Subscription"", jdx);
                    if (idx >= 0) {
                        if (!m.signature.contains(""Flowable"")
                                && !m.signature.contains(""Publisher"")
                        ) {
                            e.append(""java.lang.RuntimeException: Single doc mentions Subscription but not using Flowable\r\n at io.reactivex.rxjava3.core."")
                            .append(""Single.method(Single.java:"").append(m.javadocLine + lineNumber(m.javadoc, idx) - 1).append("")\r\n\r\n"");
                        }

                        jdx = idx + 6;
                    } else {
                        break;
                    }
                }
                jdx = 0;
                for (;;) {
                    int idx = m.javadoc.indexOf(""Observer"", jdx);
                    if (idx >= 0) {
                        if (!m.signature.contains(""ObservableSource"")
                                && !m.signature.contains(""Observable"")
                                && !m.signature.contains(""TestObserver"")) {

                            if (idx < 6 || !m.javadoc.substring(idx - 6, idx + 8).equals(""SingleObserver"")) {
                                e.append(""java.lang.RuntimeException: Single doc mentions Observer but not using Observable\r\n at io.reactivex.rxjava3.core."")
                                .append(""Single.method(Single.java:"").append(m.javadocLine + lineNumber(m.javadoc, idx) - 1).append("")\r\n\r\n"");
                            }
                        }

                        jdx = idx + 6;
                    } else {
                        break;
                    }
                }
                jdx = 0;
                for (;;) {
                    int idx = m.javadoc.indexOf(""Publisher"", jdx);
                    if (idx >= 0) {
                        if (!m.signature.contains(""Publisher"")) {
                            if (idx == 0 || !m.javadoc.substring(idx - 1, idx + 9).equals(""(Publisher"")) {
                                e.append(""java.lang.RuntimeException: Single doc mentions Publisher but not in the signature\r\n at io.reactivex.rxjava3.core."")
                                .append(""Single.method(Single.java:"").append(m.javadocLine + lineNumber(m.javadoc, idx) - 1).append("")\r\n\r\n"");
                            }
                        }

                        jdx = idx + 6;
                    } else {
                        break;
                    }
                }
                jdx = 0;
                for (;;) {
                    int idx = m.javadoc.indexOf("" Flowable"", jdx);
                    if (idx >= 0) {
                        if (!m.signature.contains(""Flowable"")) {
                            e.append(""java.lang.RuntimeException: Single doc mentions Flowable but not in the signature\r\n at io.reactivex.rxjava3.core."")
                            .append(""Single.method(Single.java:"").append(m.javadocLine + lineNumber(m.javadoc, idx) - 1).append("")\r\n\r\n"");
                        }
                        jdx = idx + 6;
                    } else {
                        break;
                    }
                }
                jdx = 0;
                for (;;) {
                    int idx = m.javadoc.indexOf("" Maybe"", jdx);
                    if (idx >= 0) {
                        if (!m.signature.contains(""Maybe"")) {
                            e.append(""java.lang.RuntimeException: Single doc mentions Maybe but not in the signature\r\n at io.reactivex.rxjava3.core."")
                            .append(""Single.method(Single.java:"").append(m.javadocLine + lineNumber(m.javadoc, idx) - 1).append("")\r\n\r\n"");
                        }
                        jdx = idx + 6;
                    } else {
                        break;
                    }
                }
                jdx = 0;
                for (;;) {
                    int idx = m.javadoc.indexOf("" MaybeSource"", jdx);
                    if (idx >= 0) {
                        if (!m.signature.contains(""MaybeSource"")) {
                            e.append(""java.lang.RuntimeException: Single doc mentions SingleSource but not in the signature\r\n at io.reactivex.rxjava3.core."")
                            .append(""Maybe.method(Maybe.java:"").append(m.javadocLine + lineNumber(m.javadoc, idx) - 1).append("")\r\n\r\n"");
                        }
                        jdx = idx + 6;
                    } else {
                        break;
                    }
                }
                jdx = 0;
                for (;;) {
                    int idx = m.javadoc.indexOf("" Observable"", jdx);
                    if (idx >= 0) {
                        if (!m.signature.contains(""Observable"")) {
                            e.append(""java.lang.RuntimeException: Single doc mentions Observable but not in the signature\r\n at io.reactivex.rxjava3.core."")
                            .append(""Single.method(Single.java:"").append(m.javadocLine + lineNumber(m.javadoc, idx) - 1).append("")\r\n\r\n"");
                        }
                        jdx = idx + 6;
                    } else {
                        break;
                    }
                }
                jdx = 0;
                for (;;) {
                    int idx = m.javadoc.indexOf("" ObservableSource"", jdx);
                    if (idx >= 0) {
                        if (!m.signature.contains(""ObservableSource"")) {
                            e.append(""java.lang.RuntimeException: Single doc mentions ObservableSource but not in the signature\r\n at io.reactivex.rxjava3.core."")
                            .append(""Single.method(Single.java:"").append(m.javadocLine + lineNumber(m.javadoc, idx) - 1).append("")\r\n\r\n"");
                        }
                        jdx = idx + 6;
                    } else {
                        break;
                    }
                }

                checkAtReturnAndSignatureMatch(""Single"", m, e, ""Flowable"", ""Observable"", ""Maybe"", ""Single"", ""Completable"", ""Disposable"", ""Iterable"", ""Stream"", ""Future"", ""CompletionStage"");

                aOrAn(e, m, ""Single"");
                missingClosingDD(e, m, ""Single"", ""io.reactivex.rxjava3.core"");
                backpressureMentionedWithoutAnnotation(e, m, ""Single"");
            }
        }

        if (e.length() != 0) {
            System.out.println(e);

            fail(e.toString());
        }
    }",break_loop_control
m,"{
        List<RxMethod> list = BaseTypeParser.parse(TestHelper.findSource(""Single""), ""Single"");

        assertFalse(list.isEmpty());

        StringBuilder e = new StringBuilder();

        for (RxMethod m : list) {
            int jdx;
            if (m.javadoc != null) {
                jdx = 0;
                for (;;) {
                    int idx = m.javadoc.indexOf(""onNext"", jdx);
                    if (idx >= 0) {
                        if (!m.signature.contains(""Publisher"")
                                && !m.signature.contains(""Flowable"")
                                && !m.signature.contains(""Observable"")
                                && !m.signature.contains(""ObservableSource"")) {
                            e.append(""java.lang.RuntimeException: Single doc mentions onNext but no Flowable/Observable in signature\r\n at io.reactivex.rxjava3.core."")
                            .append(""Single.method(Single.java:"").append(m.javadocLine + lineNumber(m.javadoc, idx) - 1).append("")\r\n\r\n"");
                        }

                        jdx = idx + 6;
                    } else {
                        break;
                    }
                }
                jdx = 0;
                for (;;) {
                    int idx = m.javadoc.indexOf(""Subscriber"", jdx);
                    if (idx >= 0) {
                        if (!m.signature.contains(""Publisher"")
                                && !m.signature.contains(""Flowable"")
                                && !m.signature.contains(""TestSubscriber"")) {
                            e.append(""java.lang.RuntimeException: Single doc mentions Subscriber but not using Flowable\r\n at io.reactivex.rxjava3.core."")
                            .append(""Single.method(Single.java:"").append(m.javadocLine + lineNumber(m.javadoc, idx) - 1).append("")\r\n\r\n"");
                        }

                        jdx = idx + 6;
                    } else {
                        break;
                    }
                }
                jdx = 0;
                for (;;) {
                    int idx = m.javadoc.indexOf("" Subscription"", jdx);
                    if (idx >= 0) {
                        if (!m.signature.contains(""Flowable"")
                                && !m.signature.contains(""Publisher"")
                        ) {
                            e.append(""java.lang.RuntimeException: Single doc mentions Subscription but not using Flowable\r\n at io.reactivex.rxjava3.core."")
                            .append(""Single.method(Single.java:"").append(m.javadocLine + lineNumber(m.javadoc, idx) - 1).append("")\r\n\r\n"");
                        }

                        jdx = idx + 6;
                    } else {
                        break;
                    }
                }
                jdx = 0;
                for (;;) {
                    int idx = m.javadoc.indexOf(""Observer"", jdx);
                    if (idx >= 0) {
                        if (!m.signature.contains(""ObservableSource"")
                                && !m.signature.contains(""Observable"")
                                && !m.signature.contains(""TestObserver"")) {

                            if (idx < 6 || !m.javadoc.substring(idx - 6, idx + 8).equals(""SingleObserver"")) {
                                e.append(""java.lang.RuntimeException: Single doc mentions Observer but not using Observable\r\n at io.reactivex.rxjava3.core."")
                                .append(""Single.method(Single.java:"").append(m.javadocLine + lineNumber(m.javadoc, idx) - 1).append("")\r\n\r\n"");
                            }
                        }

                        jdx = idx + 6;
                    } else {
                        break;
                    }
                }
                jdx = 0;
                for (;;) {
                    int idx = m.javadoc.indexOf(""Publisher"", jdx);
                    if (idx >= 0) {
                        if (!m.signature.contains(""Publisher"")) {
                            if (idx == 0 || !m.javadoc.substring(idx - 1, idx + 9).equals(""(Publisher"")) {
                                e.append(""java.lang.RuntimeException: Single doc mentions Publisher but not in the signature\r\n at io.reactivex.rxjava3.core."")
                                .append(""Single.method(Single.java:"").append(m.javadocLine + lineNumber(m.javadoc, idx) - 1).append("")\r\n\r\n"");
                            }
                        }

                        jdx = idx + 6;
                    } else {
                        break;
                    }
                }
                jdx = 0;
                for (;;) {
                    int idx = m.javadoc.indexOf("" Flowable"", jdx);
                    if (idx >= 0) {
                        if (!m.signature.contains(""Flowable"")) {
                            e.append(""java.lang.RuntimeException: Single doc mentions Flowable but not in the signature\r\n at io.reactivex.rxjava3.core."")
                            .append(""Single.method(Single.java:"").append(m.javadocLine + lineNumber(m.javadoc, idx) - 1).append("")\r\n\r\n"");
                        }
                        jdx = idx + 6;
                    } else {
                        break;
                    }
                }
                jdx = 0;
                for (;;) {
                    int idx = m.javadoc.indexOf("" Maybe"", jdx);
                    if (idx >= 0) {
                        if (!m.signature.contains(""Maybe"")) {
                            e.append(""java.lang.RuntimeException: Single doc mentions Maybe but not in the signature\r\n at io.reactivex.rxjava3.core."")
                            .append(""Single.method(Single.java:"").append(m.javadocLine + lineNumber(m.javadoc, idx) - 1).append("")\r\n\r\n"");
                        }
                        jdx = idx + 6;
                    } else {
                        break;
                    }
                }
                jdx = 0;
                for (;;) {
                    int idx = m.javadoc.indexOf("" MaybeSource"", jdx);
                    if (idx >= 0) {
                        if (!m.signature.contains(""MaybeSource"")) {
                            e.append(""java.lang.RuntimeException: Single doc mentions SingleSource but not in the signature\r\n at io.reactivex.rxjava3.core."")
                            .append(""Maybe.method(Maybe.java:"").append(m.javadocLine + lineNumber(m.javadoc, idx) - 1).append("")\r\n\r\n"");
                        }
                        jdx = idx + 6;
                    } else {
                        break;
                    }
                }
                jdx = 0;
                for (;;) {
                    int idx = m.javadoc.indexOf("" Observable"", jdx);
                    if (idx >= 0) {
                        if (!m.signature.contains(""Observable"")) {
                            e.append(""java.lang.RuntimeException: Single doc mentions Observable but not in the signature\r\n at io.reactivex.rxjava3.core."")
                            .append(""Single.method(Single.java:"").append(m.javadocLine + lineNumber(m.javadoc, idx) - 1).append("")\r\n\r\n"");
                        }
                        jdx = idx + 6;
                    } else {
                        break;
                    }
                }
                jdx = 0;
                for (;;) {
                    int idx = m.javadoc.indexOf("" ObservableSource"", jdx);
                    if (idx >= 0) {
                        if (!m.signature.contains(""ObservableSource"")) {
                            e.append(""java.lang.RuntimeException: Single doc mentions ObservableSource but not in the signature\r\n at io.reactivex.rxjava3.core."")
                            .append(""Single.method(Single.java:"").append(m.javadocLine + lineNumber(m.javadoc, idx) - 1).append("")\r\n\r\n"");
                        }
                        jdx = idx + 6;
                    } else {
                        break;
                    }
                }

                checkAtReturnAndSignatureMatch(""Single"", m, e, ""Flowable"", ""Observable"", ""Maybe"", ""Single"", ""Completable"", ""Disposable"", ""Iterable"", ""Stream"", ""Future"", ""CompletionStage"");

                aOrAn(e, m, ""Single"");
                missingClosingDD(e, m, ""Single"", ""io.reactivex.rxjava3.core"");
                backpressureMentionedWithoutAnnotation(e, m, ""Single"");
            }
        }

        if (e.length() != 0) {
            System.out.println(e);

            fail(e.toString());
        }
    }",iterator
m,"{
        List<RxMethod> list = BaseTypeParser.parse(TestHelper.findSource(""Completable""), ""Completable"");

        assertFalse(list.isEmpty());

        StringBuilder e = new StringBuilder();

        for (RxMethod m : list) {
            int jdx;
            if (m.javadoc != null) {
                jdx = 0;
                for (;;) {
                    int idx = m.javadoc.indexOf(""onNext"", jdx);
                    if (idx >= 0) {
                        if (!m.signature.contains(""Publisher"")
                                && !m.signature.contains(""Flowable"")
                                && !m.signature.contains(""Observable"")
                                && !m.signature.contains(""ObservableSource"")) {
                            e.append(""java.lang.RuntimeException: Completable doc mentions onNext but no Flowable/Observable in signature\r\n at io.reactivex.rxjava3.core."")
                            .append(""Completable.method(Completable.java:"").append(m.javadocLine + lineNumber(m.javadoc, idx) - 1).append("")\r\n\r\n"");
                        }

                        jdx = idx + 6;
                    } else {
                        break;
                    }
                }
                jdx = 0;
                for (;;) {
                    int idx = m.javadoc.indexOf(""Subscriber"", jdx);
                    if (idx >= 0) {
                        if (!m.signature.contains(""Publisher"")
                                && !m.signature.contains(""Flowable"")
                                && !m.signature.contains(""TestSubscriber"")) {
                            e.append(""java.lang.RuntimeException: Completable doc mentions Subscriber but not using Flowable\r\n at io.reactivex.rxjava3.core."")
                            .append(""Completable.method(Completable.java:"").append(m.javadocLine + lineNumber(m.javadoc, idx) - 1).append("")\r\n\r\n"");
                        }

                        jdx = idx + 6;
                    } else {
                        break;
                    }
                }
                jdx = 0;
                for (;;) {
                    int idx = m.javadoc.indexOf("" Subscription"", jdx);
                    if (idx >= 0) {
                        if (!m.signature.contains(""Flowable"")
                                && !m.signature.contains(""Publisher"")
                        ) {
                            e.append(""java.lang.RuntimeException: Completable doc mentions Subscription but not using Flowable\r\n at io.reactivex.rxjava3.core."")
                            .append(""Completable.method(Completable.java:"").append(m.javadocLine + lineNumber(m.javadoc, idx) - 1).append("")\r\n\r\n"");
                        }

                        jdx = idx + 6;
                    } else {
                        break;
                    }
                }
                jdx = 0;
                for (;;) {
                    int idx = m.javadoc.indexOf(""Observer"", jdx);
                    if (idx >= 0) {
                        if (!m.signature.contains(""ObservableSource"")
                                && !m.signature.contains(""Observable"")
                                && !m.signature.contains(""TestObserver"")) {

                            if (idx < 11 || !m.javadoc.substring(idx - 11, idx + 8).equals(""CompletableObserver"")) {
                                e.append(""java.lang.RuntimeException: Completable doc mentions Observer but not using Observable\r\n at io.reactivex.rxjava3.core."")
                                .append(""Completable.method(Completable.java:"").append(m.javadocLine + lineNumber(m.javadoc, idx) - 1).append("")\r\n\r\n"");
                            }
                        }

                        jdx = idx + 6;
                    } else {
                        break;
                    }
                }
                jdx = 0;
                for (;;) {
                    int idx = m.javadoc.indexOf(""Publisher"", jdx);
                    if (idx >= 0) {
                        if (!m.signature.contains(""Publisher"")) {
                            if (idx == 0 || !m.javadoc.substring(idx - 1, idx + 9).equals(""(Publisher"")) {
                                e.append(""java.lang.RuntimeException: Completable doc mentions Publisher but not in the signature\r\n at io.reactivex.rxjava3.core."")
                                .append(""Completable.method(Completable.java:"").append(m.javadocLine + lineNumber(m.javadoc, idx) - 1).append("")\r\n\r\n"");
                            }
                        }

                        jdx = idx + 6;
                    } else {
                        break;
                    }
                }
                jdx = 0;
                for (;;) {
                    int idx = m.javadoc.indexOf(""Flowable"", jdx);
                    if (idx >= 0) {
                        if (!m.signature.contains(""Flowable"")) {
                            Pattern p = Pattern.compile(""@see\\s+#[A-Za-z0-9 _.,()]*Flowable"");
                            if (!p.matcher(m.javadoc).find()) {
                                e.append(""java.lang.RuntimeException: Completable doc mentions Flowable but not in the signature\r\n at io.reactivex.rxjava3.core."")
                                .append(""Completable.method(Completable.java:"").append(m.javadocLine + lineNumber(m.javadoc, idx) - 1).append("")\r\n\r\n"");
                            }
                        }
                        jdx = idx + 6;
                    } else {
                        break;
                    }
                }
                jdx = 0;
                for (;;) {
                    int idx = m.javadoc.indexOf(""Single"", jdx);
                    if (idx >= 0) {
                        if (!m.signature.contains(""Single"")) {
                            Pattern p = Pattern.compile(""@see\\s+#[A-Za-z0-9 _.,()]*Single"");
                            if (!p.matcher(m.javadoc).find()) {
                                e.append(""java.lang.RuntimeException: Completable doc mentions Single but not in the signature\r\n at io.reactivex.rxjava3.core."")
                                .append(""Completable.method(Completable.java:"").append(m.javadocLine + lineNumber(m.javadoc, idx) - 1).append("")\r\n\r\n"");
                            }
                        }
                        jdx = idx + 6;
                    } else {
                        break;
                    }
                }
                jdx = 0;
                for (;;) {
                    int idx = m.javadoc.indexOf(""SingleSource"", jdx);
                    if (idx >= 0) {
                        if (!m.signature.contains(""SingleSource"")) {
                            Pattern p = Pattern.compile(""@see\\s+#[A-Za-z0-9 _.,()]*SingleSource"");
                            if (!p.matcher(m.javadoc).find()) {
                                e.append(""java.lang.RuntimeException: Completable doc mentions SingleSource but not in the signature\r\n at io.reactivex.rxjava3.core."")
                                .append(""Completable.method(Completable.java:"").append(m.javadocLine + lineNumber(m.javadoc, idx) - 1).append("")\r\n\r\n"");
                            }
                        }
                        jdx = idx + 6;
                    } else {
                        break;
                    }
                }
                jdx = 0;
                for (;;) {
                    int idx = m.javadoc.indexOf("" Observable"", jdx);
                    if (idx >= 0) {
                        if (!m.signature.contains(""Observable"")) {
                            Pattern p = Pattern.compile(""@see\\s+#[A-Za-z0-9 _.,()]*Observable"");
                            if (!p.matcher(m.javadoc).find()) {
                                e.append(""java.lang.RuntimeException: Completable doc mentions Observable but not in the signature\r\n at io.reactivex.rxjava3.core."")
                                .append(""Completable.method(Completable.java:"").append(m.javadocLine + lineNumber(m.javadoc, idx) - 1).append("")\r\n\r\n"");
                            }
                        }
                        jdx = idx + 6;
                    } else {
                        break;
                    }
                }
                jdx = 0;
                for (;;) {
                    int idx = m.javadoc.indexOf(""ObservableSource"", jdx);
                    if (idx >= 0) {
                        if (!m.signature.contains(""ObservableSource"")) {
                            Pattern p = Pattern.compile(""@see\\s+#[A-Za-z0-9 _.,()]*ObservableSource"");
                            if (!p.matcher(m.javadoc).find()) {
                                e.append(""java.lang.RuntimeException: Completable doc mentions ObservableSource but not in the signature\r\n at io.reactivex.rxjava3.core."")
                                .append(""Completable.method(Completable.java:"").append(m.javadocLine + lineNumber(m.javadoc, idx) - 1).append("")\r\n\r\n"");
                            }
                        }
                        jdx = idx + 6;
                    } else {
                        break;
                    }
                }

                checkAtReturnAndSignatureMatch(""Completable"", m, e, ""Flowable"", ""Observable"", ""Maybe"", ""Single"", ""Completable"", ""Disposable"", ""Iterable"", ""Stream"", ""Future"", ""CompletionStage"");

                aOrAn(e, m, ""Completable"");
                missingClosingDD(e, m, ""Completable"", ""io.reactivex.rxjava3.core"");
                backpressureMentionedWithoutAnnotation(e, m, ""Completable"");
            }
        }

        if (e.length() != 0) {
            System.out.println(e);

            fail(e.toString());
        }
    }",iterator
idx,"{
        List<RxMethod> list = BaseTypeParser.parse(TestHelper.findSource(""Completable""), ""Completable"");

        assertFalse(list.isEmpty());

        StringBuilder e = new StringBuilder();

        for (RxMethod m : list) {
            int jdx;
            if (m.javadoc != null) {
                jdx = 0;
                for (;;) {
                    int idx = m.javadoc.indexOf(""onNext"", jdx);
                    if (idx >= 0) {
                        if (!m.signature.contains(""Publisher"")
                                && !m.signature.contains(""Flowable"")
                                && !m.signature.contains(""Observable"")
                                && !m.signature.contains(""ObservableSource"")) {
                            e.append(""java.lang.RuntimeException: Completable doc mentions onNext but no Flowable/Observable in signature\r\n at io.reactivex.rxjava3.core."")
                            .append(""Completable.method(Completable.java:"").append(m.javadocLine + lineNumber(m.javadoc, idx) - 1).append("")\r\n\r\n"");
                        }

                        jdx = idx + 6;
                    } else {
                        break;
                    }
                }
                jdx = 0;
                for (;;) {
                    int idx = m.javadoc.indexOf(""Subscriber"", jdx);
                    if (idx >= 0) {
                        if (!m.signature.contains(""Publisher"")
                                && !m.signature.contains(""Flowable"")
                                && !m.signature.contains(""TestSubscriber"")) {
                            e.append(""java.lang.RuntimeException: Completable doc mentions Subscriber but not using Flowable\r\n at io.reactivex.rxjava3.core."")
                            .append(""Completable.method(Completable.java:"").append(m.javadocLine + lineNumber(m.javadoc, idx) - 1).append("")\r\n\r\n"");
                        }

                        jdx = idx + 6;
                    } else {
                        break;
                    }
                }
                jdx = 0;
                for (;;) {
                    int idx = m.javadoc.indexOf("" Subscription"", jdx);
                    if (idx >= 0) {
                        if (!m.signature.contains(""Flowable"")
                                && !m.signature.contains(""Publisher"")
                        ) {
                            e.append(""java.lang.RuntimeException: Completable doc mentions Subscription but not using Flowable\r\n at io.reactivex.rxjava3.core."")
                            .append(""Completable.method(Completable.java:"").append(m.javadocLine + lineNumber(m.javadoc, idx) - 1).append("")\r\n\r\n"");
                        }

                        jdx = idx + 6;
                    } else {
                        break;
                    }
                }
                jdx = 0;
                for (;;) {
                    int idx = m.javadoc.indexOf(""Observer"", jdx);
                    if (idx >= 0) {
                        if (!m.signature.contains(""ObservableSource"")
                                && !m.signature.contains(""Observable"")
                                && !m.signature.contains(""TestObserver"")) {

                            if (idx < 11 || !m.javadoc.substring(idx - 11, idx + 8).equals(""CompletableObserver"")) {
                                e.append(""java.lang.RuntimeException: Completable doc mentions Observer but not using Observable\r\n at io.reactivex.rxjava3.core."")
                                .append(""Completable.method(Completable.java:"").append(m.javadocLine + lineNumber(m.javadoc, idx) - 1).append("")\r\n\r\n"");
                            }
                        }

                        jdx = idx + 6;
                    } else {
                        break;
                    }
                }
                jdx = 0;
                for (;;) {
                    int idx = m.javadoc.indexOf(""Publisher"", jdx);
                    if (idx >= 0) {
                        if (!m.signature.contains(""Publisher"")) {
                            if (idx == 0 || !m.javadoc.substring(idx - 1, idx + 9).equals(""(Publisher"")) {
                                e.append(""java.lang.RuntimeException: Completable doc mentions Publisher but not in the signature\r\n at io.reactivex.rxjava3.core."")
                                .append(""Completable.method(Completable.java:"").append(m.javadocLine + lineNumber(m.javadoc, idx) - 1).append("")\r\n\r\n"");
                            }
                        }

                        jdx = idx + 6;
                    } else {
                        break;
                    }
                }
                jdx = 0;
                for (;;) {
                    int idx = m.javadoc.indexOf(""Flowable"", jdx);
                    if (idx >= 0) {
                        if (!m.signature.contains(""Flowable"")) {
                            Pattern p = Pattern.compile(""@see\\s+#[A-Za-z0-9 _.,()]*Flowable"");
                            if (!p.matcher(m.javadoc).find()) {
                                e.append(""java.lang.RuntimeException: Completable doc mentions Flowable but not in the signature\r\n at io.reactivex.rxjava3.core."")
                                .append(""Completable.method(Completable.java:"").append(m.javadocLine + lineNumber(m.javadoc, idx) - 1).append("")\r\n\r\n"");
                            }
                        }
                        jdx = idx + 6;
                    } else {
                        break;
                    }
                }
                jdx = 0;
                for (;;) {
                    int idx = m.javadoc.indexOf(""Single"", jdx);
                    if (idx >= 0) {
                        if (!m.signature.contains(""Single"")) {
                            Pattern p = Pattern.compile(""@see\\s+#[A-Za-z0-9 _.,()]*Single"");
                            if (!p.matcher(m.javadoc).find()) {
                                e.append(""java.lang.RuntimeException: Completable doc mentions Single but not in the signature\r\n at io.reactivex.rxjava3.core."")
                                .append(""Completable.method(Completable.java:"").append(m.javadocLine + lineNumber(m.javadoc, idx) - 1).append("")\r\n\r\n"");
                            }
                        }
                        jdx = idx + 6;
                    } else {
                        break;
                    }
                }
                jdx = 0;
                for (;;) {
                    int idx = m.javadoc.indexOf(""SingleSource"", jdx);
                    if (idx >= 0) {
                        if (!m.signature.contains(""SingleSource"")) {
                            Pattern p = Pattern.compile(""@see\\s+#[A-Za-z0-9 _.,()]*SingleSource"");
                            if (!p.matcher(m.javadoc).find()) {
                                e.append(""java.lang.RuntimeException: Completable doc mentions SingleSource but not in the signature\r\n at io.reactivex.rxjava3.core."")
                                .append(""Completable.method(Completable.java:"").append(m.javadocLine + lineNumber(m.javadoc, idx) - 1).append("")\r\n\r\n"");
                            }
                        }
                        jdx = idx + 6;
                    } else {
                        break;
                    }
                }
                jdx = 0;
                for (;;) {
                    int idx = m.javadoc.indexOf("" Observable"", jdx);
                    if (idx >= 0) {
                        if (!m.signature.contains(""Observable"")) {
                            Pattern p = Pattern.compile(""@see\\s+#[A-Za-z0-9 _.,()]*Observable"");
                            if (!p.matcher(m.javadoc).find()) {
                                e.append(""java.lang.RuntimeException: Completable doc mentions Observable but not in the signature\r\n at io.reactivex.rxjava3.core."")
                                .append(""Completable.method(Completable.java:"").append(m.javadocLine + lineNumber(m.javadoc, idx) - 1).append("")\r\n\r\n"");
                            }
                        }
                        jdx = idx + 6;
                    } else {
                        break;
                    }
                }
                jdx = 0;
                for (;;) {
                    int idx = m.javadoc.indexOf(""ObservableSource"", jdx);
                    if (idx >= 0) {
                        if (!m.signature.contains(""ObservableSource"")) {
                            Pattern p = Pattern.compile(""@see\\s+#[A-Za-z0-9 _.,()]*ObservableSource"");
                            if (!p.matcher(m.javadoc).find()) {
                                e.append(""java.lang.RuntimeException: Completable doc mentions ObservableSource but not in the signature\r\n at io.reactivex.rxjava3.core."")
                                .append(""Completable.method(Completable.java:"").append(m.javadocLine + lineNumber(m.javadoc, idx) - 1).append("")\r\n\r\n"");
                            }
                        }
                        jdx = idx + 6;
                    } else {
                        break;
                    }
                }

                checkAtReturnAndSignatureMatch(""Completable"", m, e, ""Flowable"", ""Observable"", ""Maybe"", ""Single"", ""Completable"", ""Disposable"", ""Iterable"", ""Stream"", ""Future"", ""CompletionStage"");

                aOrAn(e, m, ""Completable"");
                missingClosingDD(e, m, ""Completable"", ""io.reactivex.rxjava3.core"");
                backpressureMentionedWithoutAnnotation(e, m, ""Completable"");
            }
        }

        if (e.length() != 0) {
            System.out.println(e);

            fail(e.toString());
        }
    }",break_loop_control
t,"{
        for (String t : types) {
            String regex;
            if (t.contains(""Completable"")) {
                regex = ""(?s).*?\\s"" + t + ""\\s+\\w+\\(.*"";
            } else {
                regex = ""(?s).*?\\s"" + t + ""\\<.*?\\>\\s+\\w+\\(.*"";
            }
            if (m.signature.matches(regex)) {
                for (String at : AT_RETURN_WORDS) {
                    for (String u : types) {
                        if (!t.equals(u)) {
                            int idx = m.javadoc.indexOf(at + ""{@code "" + u);
                            if (idx >= 0) {
                                e.append(""Returns "").append(t)
                                .append("" but docs return "")
                                .append(u)
                                .append(""\r\n at io.reactivex.rxjava3.core."")
                                .append(className)
                                .append("".method("")
                                .append(className)
                                .append("".java:"")
                                .append(m.javadocLine + lineNumber(m.javadoc, idx) - 1)
                                .append("")\r\n\r\n"");
                            }
                        }
                    }
                }
            }
        }
    }",iterator
at,"{
        for (String t : types) {
            String regex;
            if (t.contains(""Completable"")) {
                regex = ""(?s).*?\\s"" + t + ""\\s+\\w+\\(.*"";
            } else {
                regex = ""(?s).*?\\s"" + t + ""\\<.*?\\>\\s+\\w+\\(.*"";
            }
            if (m.signature.matches(regex)) {
                for (String at : AT_RETURN_WORDS) {
                    for (String u : types) {
                        if (!t.equals(u)) {
                            int idx = m.javadoc.indexOf(at + ""{@code "" + u);
                            if (idx >= 0) {
                                e.append(""Returns "").append(t)
                                .append("" but docs return "")
                                .append(u)
                                .append(""\r\n at io.reactivex.rxjava3.core."")
                                .append(className)
                                .append("".method("")
                                .append(className)
                                .append("".java:"")
                                .append(m.javadocLine + lineNumber(m.javadoc, idx) - 1)
                                .append("")\r\n\r\n"");
                            }
                        }
                    }
                }
            }
        }
    }",iterator
u,"{
        for (String t : types) {
            String regex;
            if (t.contains(""Completable"")) {
                regex = ""(?s).*?\\s"" + t + ""\\s+\\w+\\(.*"";
            } else {
                regex = ""(?s).*?\\s"" + t + ""\\<.*?\\>\\s+\\w+\\(.*"";
            }
            if (m.signature.matches(regex)) {
                for (String at : AT_RETURN_WORDS) {
                    for (String u : types) {
                        if (!t.equals(u)) {
                            int idx = m.javadoc.indexOf(at + ""{@code "" + u);
                            if (idx >= 0) {
                                e.append(""Returns "").append(t)
                                .append("" but docs return "")
                                .append(u)
                                .append(""\r\n at io.reactivex.rxjava3.core."")
                                .append(className)
                                .append("".method("")
                                .append(className)
                                .append("".java:"")
                                .append(m.javadocLine + lineNumber(m.javadoc, idx) - 1)
                                .append("")\r\n\r\n"");
                            }
                        }
                    }
                }
            }
        }
    }",iterator
idx,"{
        int jdx = 0;
        int idx;
        for (;;) {
            idx = m.javadoc.indexOf(wrongPre + "" "" + word, jdx);
            if (idx >= 0) {
                e.append(""java.lang.RuntimeException: a/an typo "")
                .append(word)
                .append(""\r\n at io.reactivex.rxjava3.core."")
                .append(baseTypeName)
                .append("".method("")
                .append(baseTypeName)
                .append("".java:"").append(m.javadocLine + lineNumber(m.javadoc, idx) - 1).append("")\r\n\r\n"");
                jdx = idx + 6;
            } else {
                break;
            }
        }

        jdx = 0;
        for (;;) {
            idx = m.javadoc.indexOf(wrongPre + "" {@link "" + word, jdx);
            if (idx >= 0) {
                e.append(""java.lang.RuntimeException: a/an typo "")
                .append(word)
                .append(""\r\n at io.reactivex.rxjava3.core."")
                .append(baseTypeName)
                .append("".method("")
                .append(baseTypeName)
                .append("".java:"").append(m.javadocLine + lineNumber(m.javadoc, idx) - 1).append("")\r\n\r\n"");
                jdx = idx + 6;
            } else {
                break;
            }
        }

        jdx = 0;
        for (;;) {
            idx = m.javadoc.indexOf(wrongPre + "" {@linkplain "" + word, jdx);
            if (idx >= 0) {
                e.append(""java.lang.RuntimeException: a/an typo "")
                .append(word)
                .append(""\r\n at io.reactivex.rxjava3.core."")
                .append(baseTypeName)
                .append("".method("")
                .append(baseTypeName)
                .append("".java:"").append(m.javadocLine + lineNumber(m.javadoc, idx) - 1).append("")\r\n\r\n"");
                jdx = idx + 6;
            } else {
                break;
            }
        }

        jdx = 0;
        for (;;) {
            idx = m.javadoc.indexOf(wrongPre + "" {@code "" + word, jdx);
            if (idx >= 0) {
                e.append(""java.lang.RuntimeException: a/an typo "")
                .append(word)
                .append(""\r\n at io.reactivex.rxjava3.core."")
                .append(baseTypeName)
                .append("".method("")
                .append(baseTypeName)
                .append("".java:"").append(m.javadocLine + lineNumber(m.javadoc, idx) - 1).append("")\r\n\r\n"");
                jdx = idx + 6;
            } else {
                break;
            }
        }

        // remove linebreaks and multi-spaces
        String javadoc2 = m.javadoc.replace(""\n"", "" "").replace(""\r"", "" "")
                .replace("" * "", "" "")
                .replaceAll(""\\s+"", "" "");

        // strip {@xxx } tags
        int kk = 0;
        for (;;) {
            int jj = javadoc2.indexOf(""{@"", kk);
            if (jj < 0) {
                break;
            }
            int nn = javadoc2.indexOf("" "", jj + 2);
            int mm = javadoc2.indexOf(""}"", jj + 2);

            javadoc2 = javadoc2.substring(0, jj) + javadoc2.substring(nn + 1, mm) + javadoc2.substring(mm + 1);

            kk = mm + 1;
        }

        jdx = 0;
        for (;;) {
            idx = javadoc2.indexOf(wrongPre + "" "" + word, jdx);
            if (idx >= 0) {
                e.append(""java.lang.RuntimeException: a/an typo "")
                .append(word)
                .append(""\r\n at io.reactivex.rxjava3.core."")
                .append(baseTypeName)
                .append("".method("")
                .append(baseTypeName)
                .append("".java:"").append(m.javadocLine).append("")\r\n\r\n"");
                jdx = idx + wrongPre.length() + 1 + word.length();
            } else {
                break;
            }
        }
    }",break_loop_control
jj,"{
        int jdx = 0;
        int idx;
        for (;;) {
            idx = m.javadoc.indexOf(wrongPre + "" "" + word, jdx);
            if (idx >= 0) {
                e.append(""java.lang.RuntimeException: a/an typo "")
                .append(word)
                .append(""\r\n at io.reactivex.rxjava3.core."")
                .append(baseTypeName)
                .append("".method("")
                .append(baseTypeName)
                .append("".java:"").append(m.javadocLine + lineNumber(m.javadoc, idx) - 1).append("")\r\n\r\n"");
                jdx = idx + 6;
            } else {
                break;
            }
        }

        jdx = 0;
        for (;;) {
            idx = m.javadoc.indexOf(wrongPre + "" {@link "" + word, jdx);
            if (idx >= 0) {
                e.append(""java.lang.RuntimeException: a/an typo "")
                .append(word)
                .append(""\r\n at io.reactivex.rxjava3.core."")
                .append(baseTypeName)
                .append("".method("")
                .append(baseTypeName)
                .append("".java:"").append(m.javadocLine + lineNumber(m.javadoc, idx) - 1).append("")\r\n\r\n"");
                jdx = idx + 6;
            } else {
                break;
            }
        }

        jdx = 0;
        for (;;) {
            idx = m.javadoc.indexOf(wrongPre + "" {@linkplain "" + word, jdx);
            if (idx >= 0) {
                e.append(""java.lang.RuntimeException: a/an typo "")
                .append(word)
                .append(""\r\n at io.reactivex.rxjava3.core."")
                .append(baseTypeName)
                .append("".method("")
                .append(baseTypeName)
                .append("".java:"").append(m.javadocLine + lineNumber(m.javadoc, idx) - 1).append("")\r\n\r\n"");
                jdx = idx + 6;
            } else {
                break;
            }
        }

        jdx = 0;
        for (;;) {
            idx = m.javadoc.indexOf(wrongPre + "" {@code "" + word, jdx);
            if (idx >= 0) {
                e.append(""java.lang.RuntimeException: a/an typo "")
                .append(word)
                .append(""\r\n at io.reactivex.rxjava3.core."")
                .append(baseTypeName)
                .append("".method("")
                .append(baseTypeName)
                .append("".java:"").append(m.javadocLine + lineNumber(m.javadoc, idx) - 1).append("")\r\n\r\n"");
                jdx = idx + 6;
            } else {
                break;
            }
        }

        // remove linebreaks and multi-spaces
        String javadoc2 = m.javadoc.replace(""\n"", "" "").replace(""\r"", "" "")
                .replace("" * "", "" "")
                .replaceAll(""\\s+"", "" "");

        // strip {@xxx } tags
        int kk = 0;
        for (;;) {
            int jj = javadoc2.indexOf(""{@"", kk);
            if (jj < 0) {
                break;
            }
            int nn = javadoc2.indexOf("" "", jj + 2);
            int mm = javadoc2.indexOf(""}"", jj + 2);

            javadoc2 = javadoc2.substring(0, jj) + javadoc2.substring(nn + 1, mm) + javadoc2.substring(mm + 1);

            kk = mm + 1;
        }

        jdx = 0;
        for (;;) {
            idx = javadoc2.indexOf(wrongPre + "" "" + word, jdx);
            if (idx >= 0) {
                e.append(""java.lang.RuntimeException: a/an typo "")
                .append(word)
                .append(""\r\n at io.reactivex.rxjava3.core."")
                .append(baseTypeName)
                .append("".method("")
                .append(baseTypeName)
                .append("".java:"").append(m.javadocLine).append("")\r\n\r\n"");
                jdx = idx + wrongPre.length() + 1 + word.length();
            } else {
                break;
            }
        }
    }",break_loop_control
idx1,"{
        int jdx = 0;
        for (;;) {
            int idx1 = m.javadoc.indexOf(""<dd>"", jdx);
            int idx2 = m.javadoc.indexOf(""</dd>"", jdx);

            if (idx1 < 0 && idx2 < 0) {
                break;
            }

            int idx3 = m.javadoc.indexOf(""<dd>"", idx1 + 4);

            if (idx1 > 0 && idx2 > 0 && (idx3 < 0 || (idx2 < idx3 && idx3 > 0))) {
                jdx = idx2 + 5;
            } else {
                e.append(""java.lang.RuntimeException: unbalanced <dd></dd> "")
                .append(""\r\n at "")
                .append(packageName)
                .append(""."")
                .append(baseTypeName)
                .append("".method("")
                .append(baseTypeName)
                .append("".java:"").append(m.javadocLine + lineNumber(m.javadoc, idx1) - 1).append("")\r\n\r\n"");
                break;
            }
        }
    }",break_loop_control
idx2,"{
        int jdx = 0;
        for (;;) {
            int idx1 = m.javadoc.indexOf(""<dd>"", jdx);
            int idx2 = m.javadoc.indexOf(""</dd>"", jdx);

            if (idx1 < 0 && idx2 < 0) {
                break;
            }

            int idx3 = m.javadoc.indexOf(""<dd>"", idx1 + 4);

            if (idx1 > 0 && idx2 > 0 && (idx3 < 0 || (idx2 < idx3 && idx3 > 0))) {
                jdx = idx2 + 5;
            } else {
                e.append(""java.lang.RuntimeException: unbalanced <dd></dd> "")
                .append(""\r\n at "")
                .append(packageName)
                .append(""."")
                .append(baseTypeName)
                .append("".method("")
                .append(baseTypeName)
                .append("".java:"").append(m.javadocLine + lineNumber(m.javadoc, idx1) - 1).append("")\r\n\r\n"");
                break;
            }
        }
    }",break_loop_control
eventPool,"{
    // nextInt is normally exclusive of the top value,
    // so add 1 to make it inclusive
    var randomNum = rand.nextInt((MAX_ID - MIN_ID) + 1) + MIN_ID;
    while (eventPool.containsKey(randomNum)) {
      randomNum = rand.nextInt((MAX_ID - MIN_ID) + 1) + MIN_ID;
    }

    return randomNum;
  }",maybe_loop_control
option,"{
    var eventManager = new EventManager();

    var s = new Scanner(System.in);
    var option = -1;
    while (option != 4) {
      LOGGER.info(""Hello. Would you like to boil some eggs?"");
      LOGGER.info(""(1) BOIL AN EGG \n(2) STOP BOILING THIS EGG \n(3) HOW ARE MY EGGS? \n(4) EXIT"");
      LOGGER.info(""Choose [1,2,3,4]: "");
      option = s.nextInt();

      if (option == 1) {
        processOption1(eventManager, s);
      } else if (option == 2) {
        processOption2(eventManager, s);
      } else if (option == 3) {
        processOption3(eventManager, s);
      } else if (option == 4) {
        eventManager.shutdown();
      }
    }

    s.close();
  }",loop_control
i,"{
    var json = new StringBuilder().append(""{"");

    var i = 0;
    var fieldsLength = fields.length;
    while (i < fieldsLength) {
      json.append(getString(video, Video.class.getDeclaredField(fields[i])));
      if (i != fieldsLength - 1) {
        json.append("","");
      }
      i++;
    }
    json.append(""}"");
    return json.toString();
  }",loop_control
i,"{
    var retries = 0;
    var result = FAILURE.getRemoteServiceStatusValue();

    for (int i = 0; i < RETRIES; i++) {
      if (retries >= RETRIES) {
        return FAILURE.getRemoteServiceStatusValue();
      }

      if ((result = checkLatency(value)) == FAILURE.getRemoteServiceStatusValue()) {
        LOGGER.info(""Failed to reach remote: ({})"", i + 1);
        retries++;
        try {
          sleep(DELAY_MS);
        } catch (InterruptedException e) {
          LOGGER.error(""Thread sleep state interrupted"", e);
          Thread.currentThread().interrupt();
        }
      } else {
        break;
      }
    }
    return result;
  }",loop_control
health,"{
    final var model = mock(GiantModel.class);
    final var view = mock(GiantView.class);
    final var controller = new GiantController(model, view);

    verifyZeroInteractions(model, view);

    for (final var health : Health.values()) {
      controller.setHealth(health);
      verify(model).setHealth(health);
      verifyZeroInteractions(view);
    }

    controller.getHealth();
    //noinspection ResultOfMethodCallIgnored
    verify(model).getHealth();

    verifyNoMoreInteractions(model, view);
  }",iterator
fatigue,"{
    final var model = mock(GiantModel.class);
    final var view = mock(GiantView.class);
    final var controller = new GiantController(model, view);

    verifyZeroInteractions(model, view);

    for (final var fatigue : Fatigue.values()) {
      controller.setFatigue(fatigue);
      verify(model).setFatigue(fatigue);
      verifyZeroInteractions(view);
    }

    controller.getFatigue();
    //noinspection ResultOfMethodCallIgnored
    verify(model).getFatigue();

    verifyNoMoreInteractions(model, view);
  }",iterator
nourishment,"{
    final var model = mock(GiantModel.class);
    final var view = mock(GiantView.class);
    final var controller = new GiantController(model, view);

    verifyZeroInteractions(model, view);

    for (final var nourishment : Nourishment.values()) {
      controller.setNourishment(nourishment);
      verify(model).setNourishment(nourishment);
      verifyZeroInteractions(view);
    }

    controller.getNourishment();
    //noinspection ResultOfMethodCallIgnored
    verify(model).getNourishment();

    verifyNoMoreInteractions(model, view);
  }",iterator
health,"{
    final var model = new GiantModel(Health.HEALTHY, Fatigue.ALERT, Nourishment.SATURATED);
    assertEquals(Health.HEALTHY, model.getHealth());
    var messageFormat = ""The giant looks %s, alert and saturated."";
    for (final var health : Health.values()) {
      model.setHealth(health);
      assertEquals(health, model.getHealth());
      assertEquals(String.format(messageFormat, health), model.toString());
    }
  }",iterator
fatigue,"{
    final var model = new GiantModel(Health.HEALTHY, Fatigue.ALERT, Nourishment.SATURATED);
    assertEquals(Fatigue.ALERT, model.getFatigue());
    var messageFormat = ""The giant looks healthy, %s and saturated."";
    for (final var fatigue : Fatigue.values()) {
      model.setFatigue(fatigue);
      assertEquals(fatigue, model.getFatigue());
      assertEquals(String.format(messageFormat, fatigue), model.toString());
    }
  }",iterator
nourishment,"{
    final var model = new GiantModel(Health.HEALTHY, Fatigue.ALERT, Nourishment.SATURATED);
    assertEquals(Nourishment.SATURATED, model.getNourishment());
    var messageFormat = ""The giant looks healthy, alert and %s."";
    for (final var nourishment : Nourishment.values()) {
      model.setNourishment(nourishment);
      assertEquals(nourishment, model.getNourishment());
      assertEquals(String.format(messageFormat, nourishment), model.toString());
    }
  }",iterator
i,"{
    for (var i = 0; i < Instruction.values().length; i++) {
      if (Instruction.values()[i].getIntValue() == value) {
        return Instruction.values()[i];
      }
    }
    throw new IllegalArgumentException(""Invalid instruction value"");
  }",loop_control
i,"{
    for (var i = 0; i < bytecode.length; i++) {
      Instruction instruction = Instruction.getInstruction(bytecode[i]);
      switch (instruction) {
        case LITERAL:
          // Read the next byte from the bytecode.
          int value = bytecode[++i];
          // Push the next value to stack
          stack.push(value);
          break;
        case SET_AGILITY:
          var amount = stack.pop();
          var wizard = stack.pop();
          setAgility(wizard, amount);
          break;
        case SET_WISDOM:
          amount = stack.pop();
          wizard = stack.pop();
          setWisdom(wizard, amount);
          break;
        case SET_HEALTH:
          amount = stack.pop();
          wizard = stack.pop();
          setHealth(wizard, amount);
          break;
        case GET_HEALTH:
          wizard = stack.pop();
          stack.push(getHealth(wizard));
          break;
        case GET_AGILITY:
          wizard = stack.pop();
          stack.push(getAgility(wizard));
          break;
        case GET_WISDOM:
          wizard = stack.pop();
          stack.push(getWisdom(wizard));
          break;
        case ADD:
          var a = stack.pop();
          var b = stack.pop();
          stack.push(a + b);
          break;
        case DIVIDE:
          a = stack.pop();
          b = stack.pop();
          stack.push(b / a);
          break;
        case PLAY_SOUND:
          wizard = stack.pop();
          getWizards()[wizard].playSound();
          break;
        case SPAWN_PARTICLES:
          wizard = stack.pop();
          getWizards()[wizard].spawnParticles();
          break;
        default:
          throw new IllegalArgumentException(""Invalid instruction value"");
      }
      LOGGER.info(""Executed "" + instruction.name() + "", Stack contains "" + getStack());
    }
  }",loop_control
i,"{
    if (instructions == null || instructions.trim().length() == 0) {
      return new int[0];
    }

    var splitedInstructions = instructions.trim().split("" "");
    var bytecode = new int[splitedInstructions.length];
    for (var i = 0; i < splitedInstructions.length; i++) {
      if (isValidInstruction(splitedInstructions[i])) {
        bytecode[i] = Instruction.valueOf(splitedInstructions[i]).getIntValue();
      } else if (isValidInt(splitedInstructions[i])) {
        bytecode[i] = Integer.parseInt(splitedInstructions[i]);
      } else {
        var errorMessage = ""Invalid instruction or number: "" + splitedInstructions[i];
        throw new IllegalArgumentException(errorMessage);
      }
    }

    return bytecode;
  }",loop_control
count,"{
    var count = this.msgCount;

    try {
      while (count > 0) {
        var statusMsg = ""Message-"" + count + "" submitted by "" + Thread.currentThread().getName();
        this.submit(new Message(statusMsg));

        LOGGER.info(statusMsg);

        // reduce the message count.
        count--;

        // Make the current thread to sleep after every Message submission.
        Thread.sleep(1000);
      }
    } catch (Exception e) {
      LOGGER.error(e.getMessage());
    }
  }",loop_control
isCompleted,"{
      synchronized (lock) {
        while (!isCompleted()) {
          lock.wait();
        }
      }
    }",maybe_loop_control
i,"{
    init();
    // Walk the pending requests.
    for (var i = headIndex; i != tailIndex; i = (i + 1) % MAX_PENDING) {
      var playMessage = getPendingAudio()[i];
      if (playMessage.getStream() == stream) {
        // Use the larger of the two volumes.
        playMessage.setVolume(Math.max(volume, playMessage.getVolume()));

        // Don't need to enqueue.
        return;
      }
    }
    getPendingAudio()[tailIndex] = new PlayMessage(stream, volume);
    tailIndex = (tailIndex + 1) % MAX_PENDING;
  }",loop_control
saga,"{
    state.cleanUp();
    LOGGER.info("" The new saga is about to start"");
    var result = FINISHED;
    K tempVal = value;

    while (true) {
      var next = state.current();
      var ch = saga.get(next);
      var srvOpt = sd.find(ch.name);

      if (srvOpt.isEmpty()) {
        state.directionToBack();
        state.back();
        continue;
      }

      var srv = srvOpt.get();

      if (state.isForward()) {
        var processRes = srv.process(tempVal);
        if (processRes.isSuccess()) {
          next = state.forward();
          tempVal = (K) processRes.getValue();
        } else {
          state.directionToBack();
        }
      } else {
        var rlRes = srv.rollback(tempVal);
        if (rlRes.isSuccess()) {
          next = state.back();
          tempVal = (K) rlRes.getValue();
        } else {
          result = CRASHED;
          next = state.back();
        }
      }


      if (!saga.isPresent(next)) {
        return state.isForward() ? FINISHED : result == CRASHED ? CRASHED : ROLLBACK;
      }
    }

  }",break_loop_control
fromIterator,"{
    return new LazyFluentIterable<>() {
      @Override
      public Iterator<E> iterator() {
        return new DecoratingIterator<>(iterable.iterator()) {
          @Override
          public E computeNext() {
            while (fromIterator.hasNext()) {
              var candidate = fromIterator.next();
              if (predicate.test(candidate)) {
                return candidate;
              }
            }

            return null;
          }
        };
      }
    };
  }",maybe_loop_control
resultIterator,"{
    var resultIterator = last(1).iterator();
    return resultIterator.hasNext() ? Optional.of(resultIterator.next()) : Optional.empty();
  }",iterator
currentIndex,"{
    return new LazyFluentIterable<>() {
      @Override
      public Iterator<E> iterator() {
        return new DecoratingIterator<>(iterable.iterator()) {
          private int stopIndex;
          private int totalElementsCount;
          private List<E> list;
          private int currentIndex;

          @Override
          public E computeNext() {
            initialize();

            while (currentIndex < stopIndex && fromIterator.hasNext()) {
              currentIndex++;
              fromIterator.next();
            }
            if (currentIndex >= stopIndex && fromIterator.hasNext()) {
              return fromIterator.next();
            }
            return null;
          }

          private void initialize() {
            if (list == null) {
              list = new ArrayList<>();
              iterable.forEach(list::add);
              totalElementsCount = list.size();
              stopIndex = totalElementsCount - count;
            }
          }
        };
      }
    };
  }",loop_control
oldTypeIterator,"{
    return new LazyFluentIterable<>() {
      @Override
      public Iterator<T> iterator() {
        return new DecoratingIterator<>(null) {
          final Iterator<E> oldTypeIterator = iterable.iterator();

          @Override
          public T computeNext() {
            if (oldTypeIterator.hasNext()) {
              E candidate = oldTypeIterator.next();
              return function.apply(candidate);
            } else {
              return null;
            }
          }
        };
      }
    };
  }",iterator
iterator,"{
    var iterator = iterator();
    while (iterator.hasNext()) {
      var nextElement = iterator.next();
      if (!predicate.test(nextElement)) {
        iterator.remove();
      }
    }
    return this;
  }",iterator
resultIterator,"{
    var resultIterator = first(1).iterator();
    return resultIterator.hasNext() ? Optional.of(resultIterator.next()) : Optional.empty();
  }",iterator
iterator,"{
    var iterator = iterator();
    var currentCount = 0;
    while (iterator.hasNext()) {
      iterator.next();
      if (currentCount >= count) {
        iterator.remove();
      }
      currentCount++;
    }
    return this;
  }",iterator
iterator,"{
    var remainingElementsCount = getRemainingElementsCount();
    var iterator = iterator();
    var currentIndex = 0;
    while (iterator.hasNext()) {
      iterator.next();
      if (currentIndex < remainingElementsCount - count) {
        iterator.remove();
      }
      currentIndex++;
    }

    return this;
  }",iterator
ignored,"{
    var counter = 0;
    for (var ignored : this) {
      counter++;
    }
    return counter;
  }",iterator
i,"{
    var titleList = new String[]{""HQ"", ""The Rough Dancer and Cyclical Night"",
                                 ""The Black Light"", ""Symphony No.5""};
    var artistList = new String[]{""Roy Harper"", ""Astor Piazzola"",
                                  ""The Black Light"", ""CBSO""};
    var isClassicalList = new boolean[]{false, false, false, true};
    var composerList = new String[]{null, null, null, ""Sibelius""};

    var result = new DisplayedAlbums();
    for (var i = 1; i <= titleList.length; i++) {
      result.addAlbums(titleList[i - 1], artistList[i - 1],
              isClassicalList[i - 1], composerList[i - 1]);
    }
    return result;
  }",loop_control
i,"{
    var result = new String[data.getAlbums().size()];
    for (var i = 0; i < result.length; i++) {
      result[i] = data.getAlbums().get(i).getTitle();
    }
    return result;
  }",loop_control
id,"{
    final var queue = spy(new ItemQueue());
    for (var id = 0; id < ITEM_COUNT; id++) {
      queue.put(new Item(""producer"", id));
    }

    reset(queue); // Don't count the preparation above as interactions with the queue
    final var consumer = new Consumer(""consumer"", queue);

    for (var id = 0; id < ITEM_COUNT; id++) {
      consumer.consume();
    }

    verify(queue, times(ITEM_COUNT)).take();
  }",loop_control
i,"{

    var queue = new ItemQueue();

    var executorService = Executors.newFixedThreadPool(5);
    for (var i = 0; i < 2; i++) {

      final var producer = new Producer(""Producer_"" + i, queue);
      executorService.submit(() -> {
        while (true) {
          producer.produce();
        }
      });
    }

    for (var i = 0; i < 3; i++) {
      final var consumer = new Consumer(""Consumer_"" + i, queue);
      executorService.submit(() -> {
        while (true) {
          consumer.consume();
        }
      });
    }

    executorService.shutdown();
    try {
      executorService.awaitTermination(10, TimeUnit.SECONDS);
      executorService.shutdownNow();
    } catch (InterruptedException e) {
      LOGGER.error(""Error waiting for ExecutorService shutdown"");
    }
  }",loop_control
res,"{
    assertTimeout(ofMillis(10000), () -> {
      // Create 10000 tasks and inside each callable instantiate the singleton class
      final var tasks = IntStream.range(0, 10000)
          .<Callable<S>>mapToObj(i -> this.singletonInstanceMethod::get)
          .collect(Collectors.toCollection(ArrayList::new));

      // Use up to 8 concurrent threads to handle the tasks
      final var executorService = Executors.newFixedThreadPool(8);
      final var results = executorService.invokeAll(tasks);

      // wait for all of the threads to complete
      final var expectedInstance = this.singletonInstanceMethod.get();
      for (var res : results) {
        final var instance = res.get();
        assertNotNull(instance);
        assertSame(expectedInstance, instance);
      }

      // tidy up the executor
      executorService.shutdown();
    });

  }",iterator
isRunning,"{
    while (isRunning) {
      processInput();
      update();
      render();
    }
  }",maybe_loop_control
entity,"{
    for (var entity : entities) {
      entity.update();
    }
  }",iterator
i,"{
    super(""Client System"");
    setDefaultCloseOperation(WindowConstants.EXIT_ON_CLOSE);
    setSize(300, 300);
    jl = new JLabel(""RUNNING..."");
    jtFields = new JTextField[3];
    for (var i = 0; i < 3; i++) {
      jtFields[i] = new JTextField();
    }
    jtAreas = new JTextArea[2];
    for (var i = 0; i < 2; i++) {
      jtAreas[i] = new JTextArea();
    }
    clearButton = new JButton(""Clear"");
    processButton = new JButton(""Process"");

    setup();
  }",loop_control
last,"{
    Filter last = this;
    while (last.getNext() != null) {
      last = last.getNext();
    }
    return last;
  }",maybe_loop_control
infinite,"{
    this.name = name;
    this.status = 0;
    this.requests = new LinkedBlockingQueue<>();
    thread = new Thread(() -> {
      boolean infinite = true;
      while (infinite) {
        try {
          requests.take().run();
        } catch (InterruptedException e) {
          if (this.status != 0) {
            logger.error(""Thread was interrupted. --> {}"", e.getMessage()); 
          }
          infinite = false;
          Thread.currentThread().interrupt();
        }
      }
    });
    thread.start();
  }",maybe_loop_control
i,"{
    List<ActiveCreature> creatures = new ArrayList<>();
    try {
      for (int i = 0;i < NUM_CREATURES;i++) {
        creatures.add(new Orc(Orc.class.getSimpleName() + i));
        creatures.get(i).eat();
        creatures.get(i).roam();
      }
      Thread.sleep(1000);
    } catch (InterruptedException e) {
      logger.error(e.getMessage());
      Thread.currentThread().interrupt();
    } finally {
      for (int i = 0;i < NUM_CREATURES;i++) {
        creatures.get(i).kill(0);
      }
    }
  }",loop_control
q,"{
    var finder = Finder.contains(query);

    for (String q : excludeQueries) {
      finder = finder.not(Finder.contains(q));
    }
    return finder;

  }",iterator
query,"{
    var finder = identMult();

    for (String query : queries) {
      finder = finder.and(Finder.contains(query));
    }
    return finder;
  }",iterator
query,"{
    var finder = identSum();

    for (String query : queries) {
      finder = finder.or(Finder.contains(query));
    }
    return finder;
  }",iterator
isLockFree,"{
      synchronized (globalMutex) {

        // Wait until the lock is free.
        while (!isLockFree()) {
          try {
            globalMutex.wait();
          } catch (InterruptedException e) {
            LOGGER.info(""InterruptedException while waiting for globalMutex to begin writing"", e);
            Thread.currentThread().interrupt();
          }
        }
        // When the lock is free, acquire it by placing an entry in globalMutex
        globalMutex.add(this);
      }
    }",maybe_loop_control
i,"{

    var executeService = Executors.newFixedThreadPool(10);
    var lock = new ReaderWriterLock();

    // Start writers
    for (var i = 0; i < 5; i++) {
      var writingTime = ThreadLocalRandom.current().nextLong(5000);
      executeService.submit(new Writer(""Writer "" + i, lock.writeLock(), writingTime));
    }
    LOGGER.info(""Writers added..."");

    // Start readers
    for (var i = 0; i < 5; i++) {
      var readingTime = ThreadLocalRandom.current().nextLong(10);
      executeService.submit(new Reader(""Reader "" + i, lock.readLock(), readingTime));
    }
    LOGGER.info(""Readers added..."");

    try {
      Thread.sleep(5000L);
    } catch (InterruptedException e) {
      LOGGER.error(""Error sleeping before adding more readers"", e);
      Thread.currentThread().interrupt();
    }

    // Start readers
    for (var i = 6; i < 10; i++) {
      var readingTime = ThreadLocalRandom.current().nextLong(10);
      executeService.submit(new Reader(""Reader "" + i, lock.readLock(), readingTime));
    }
    LOGGER.info(""More readers added..."");


    // In the system console, it can see that the read operations are executed concurrently while
    // write operations are exclusive.
    executeService.shutdown();
    try {
      executeService.awaitTermination(5, TimeUnit.SECONDS);
    } catch (InterruptedException e) {
      LOGGER.error(""Error waiting for ExecutorService shutdown"", e);
      Thread.currentThread().interrupt();
    }

  }",loop_control
pendingWrite,"{
    var pendingWrites = channelToPendingWrites.get(key.channel());
    Object pendingWrite;
    while ((pendingWrite = pendingWrites.poll()) != null) {
      // ask the concrete channel to make sense of data and write it to java channel
      doWrite(pendingWrite, key);
    }
    // We don't have anything more to write so channel is interested in reading more data
    reactor.changeOps(key, SelectionKey.OP_READ);
  }",maybe_loop_control
iterator,"{
    // honor interrupt request
    while (!Thread.interrupted()) {
      // honor any pending commands first
      processPendingCommands();

      /*
       * Synchronous event de-multiplexing happens here, this is blocking call which returns when it
       * is possible to initiate non-blocking operation on any of the registered channels.
       */
      selector.select();

      /*
       * Represents the events that have occurred on registered handles.
       */
      var keys = selector.selectedKeys();
      var iterator = keys.iterator();

      while (iterator.hasNext()) {
        var key = iterator.next();
        if (!key.isValid()) {
          iterator.remove();
          continue;
        }
        processKey(key);
      }
      keys.clear();
    }
  }",iterator
iterator,"{
    var iterator = pendingCommands.iterator();
    while (iterator.hasNext()) {
      var command = iterator.next();
      command.run();
      iterator.remove();
    }
  }",iterator
i,"{
      for (var i = 0; i < 4; i++) {
        writer.println(clientName + "" - Log request: "" + i);
        writer.flush();

        var data = new byte[1024];
        var read = inputStream.read(data, 0, data.length);
        if (read == 0) {
          LOGGER.info(""Read zero bytes"");
        } else {
          LOGGER.info(new String(data, 0, read));
        }

        artificialDelayOf(100);
      }
    }",loop_control
i,"{
      try (var socket = new DatagramSocket()) {
        for (var i = 0; i < 4; i++) {

          var message = clientName + "" - Log request: "" + i;
          var bytes = message.getBytes();
          var request = new DatagramPacket(bytes, bytes.length, remoteAddress);

          socket.send(request);

          var data = new byte[1024];
          var reply = new DatagramPacket(data, data.length);
          socket.receive(reply);
          if (reply.getLength() == 0) {
            LOGGER.info(""Read zero bytes"");
          } else {
            LOGGER.info(new String(reply.getData(), 0, reply.getLength()));
          }

          artificialDelayOf(100);
        }
      } catch (IOException e1) {
        LOGGER.error(""error sending packets"", e1);
      }
    }",loop_control
channel,"{
    reactor.stop();
    dispatcher.stop();
    for (var channel : channels) {
      channel.getJavaChannel().close();
    }
  }",iterator
i,"{

    var queueManager = new QueueManager(10);

    // push some message to queue
    // Low Priority message
    for (var i = 0; i < 10; i++) {
      queueManager.publishMessage(new Message(""Low Message Priority"", 0));
    }

    // High Priority message
    for (var i = 0; i < 10; i++) {
      queueManager.publishMessage(new Message(""High Message Priority"", 1));
    }

    // run worker
    var worker = new Worker(queueManager);
    worker.run();


  }",loop_control
index,"{
    var index = 0;
    while (hasLeftChild(index)) {

      var smallerIndex = leftChildIndex(index);

      if (hasRightChild(index) && right(index).compareTo(left(index)) > 0) {
        smallerIndex = rightChildIndex(index);
      }

      if (queue[index].compareTo(queue[smallerIndex]) > 0) {
        break;
      } else {
        swap(index, smallerIndex);
      }

      index = smallerIndex;


    }

  }",break_loop_control
index,"{
    var index = 0;
    while (hasLeftChild(index)) {

      var smallerIndex = leftChildIndex(index);

      if (hasRightChild(index) && right(index).compareTo(left(index)) > 0) {
        smallerIndex = rightChildIndex(index);
      }

      if (queue[index].compareTo(queue[smallerIndex]) > 0) {
        break;
      } else {
        swap(index, smallerIndex);
      }

      index = smallerIndex;


    }

  }",loop_control
index,"{
    var index = size - 1;
    while (hasParent(index) && parent(index).compareTo(queue[index]) < 0) {
      swap(parentIndex(index), index);
      index = parentIndex(index);
    }
  }",loop_control
i,"{
    for (var i = 0; i <= size / 2; i++) {
      LOGGER.info("" PARENT : "" + queue[i] + "" LEFT CHILD : ""
          + left(i) + "" RIGHT CHILD :"" + right(i));
    }
  }",loop_control
iterator,"{
    final var chest = new TreasureChest();
    final var iterator = chest.iterator(expectedItem.getType());
    assertNotNull(iterator);

    while (iterator.hasNext()) {
      final var item = iterator.next();
      assertNotNull(item);
      assertEquals(expectedItem.getType(), item.getType());

      final var name = item.toString();
      assertNotNull(name);
      if (expectedItem.toString().equals(name)) {
        return;
      }
    }

    fail(""Expected to find item ["" + expectedItem + ""] using iterator, but we didn't."");

  }",iterator
expectedItem,"{
    final var chest = new TreasureChest();
    final var iterator = chest.iterator(expectedItem.getType());
    assertNotNull(iterator);

    while (iterator.hasNext()) {
      final var item = iterator.next();
      assertNotNull(item);
      assertEquals(expectedItem.getType(), item.getType());

      final var name = item.toString();
      assertNotNull(name);
      if (expectedItem.toString().equals(name)) {
        return;
      }
    }

    fail(""Expected to find item ["" + expectedItem + ""] using iterator, but we didn't."");

  }",break_loop_control
item,"{
    final var chest = new TreasureChest();
    final var items = chest.getItems();
    assertNotNull(items);

    for (final var item : items) {
      assertNotNull(item);
      assertNotNull(item.getType());
      assertNotNull(item.toString());

      final var sameType = expectedItem.getType() == item.getType();
      final var sameName = expectedItem.toString().equals(item.toString());
      if (sameType && sameName) {
        return;
      }
    }

    fail(""Expected to find item ["" + expectedItem + ""] in the item list, but we didn't."");

  }",iterator
sameType,"{
    final var chest = new TreasureChest();
    final var items = chest.getItems();
    assertNotNull(items);

    for (final var item : items) {
      assertNotNull(item);
      assertNotNull(item.getType());
      assertNotNull(item.toString());

      final var sameType = expectedItem.getType() == item.getType();
      final var sameName = expectedItem.toString().equals(item.toString());
      if (sameType && sameName) {
        return;
      }
    }

    fail(""Expected to find item ["" + expectedItem + ""] in the item list, but we didn't."");

  }",break_loop_control
sameName,"{
    final var chest = new TreasureChest();
    final var items = chest.getItems();
    assertNotNull(items);

    for (final var item : items) {
      assertNotNull(item);
      assertNotNull(item.getType());
      assertNotNull(item.toString());

      final var sameType = expectedItem.getType() == item.getType();
      final var sameName = expectedItem.toString().equals(item.toString());
      if (sameType && sameName) {
        return;
      }
    }

    fail(""Expected to find item ["" + expectedItem + ""] in the item list, but we didn't."");

  }",break_loop_control
iter,"{
    var iter = new BstIterator<>(emptyRoot);
    assertThrows(NoSuchElementException.class, iter::next,
        ""next() should throw an IllegalStateException if hasNext() is false."");
  }",iterator
iter,"{
    var iter = new BstIterator<>(nonEmptyRoot);
    assertEquals(Integer.valueOf(1), iter.next().getVal(), ""First Node is 1."");
    assertEquals(Integer.valueOf(3), iter.next().getVal(), ""Second Node is 3."");
    assertEquals(Integer.valueOf(4), iter.next().getVal(), ""Third Node is 4."");
    assertEquals(Integer.valueOf(5), iter.next().getVal(), ""Fourth Node is 5."");
    assertEquals(Integer.valueOf(6), iter.next().getVal(), ""Fifth Node is 6."");
    assertEquals(Integer.valueOf(7), iter.next().getVal(), ""Sixth Node is 7."");
  }",iterator
iter,"{
    var iter = new BstIterator<>(emptyRoot);
    assertFalse(iter.hasNext(), ""hasNext() should return false for empty tree."");
  }",iterator
iter,"{
    var iter = new BstIterator<>(nonEmptyRoot);
    assertTrue(iter.hasNext(), ""hasNext() should return true for populated tree."");
  }",iterator
iter,"{
    var iter = new BstIterator<>(nonEmptyRoot);
    assertTrue(iter.hasNext(), ""Iterator hasNext() should be true."");
    assertEquals(Integer.valueOf(1), iter.next().getVal(), ""First Node is 1."");
    assertTrue(iter.hasNext(), ""Iterator hasNext() should be true."");
    assertEquals(Integer.valueOf(3), iter.next().getVal(), ""Second Node is 3."");
    assertTrue(iter.hasNext(), ""Iterator hasNext() should be true."");
    assertEquals(Integer.valueOf(4), iter.next().getVal(), ""Third Node is 4."");
    assertTrue(iter.hasNext(), ""Iterator hasNext() should be true."");
    assertEquals(Integer.valueOf(5), iter.next().getVal(), ""Fourth Node is 5."");
    assertTrue(iter.hasNext(), ""Iterator hasNext() should be true."");
    assertEquals(Integer.valueOf(6), iter.next().getVal(), ""Fifth Node is 6."");
    assertTrue(iter.hasNext(), ""Iterator hasNext() should be true."");
    assertEquals(Integer.valueOf(7), iter.next().getVal(), ""Sixth Node is 7."");
    assertFalse(iter.hasNext(), ""Iterator hasNext() should be false, end of tree."");
  }",iterator
itemIterator,"{
    LOGGER.info(""------------------------"");
    LOGGER.info(""Item Iterator for ItemType "" + itemType + "": "");
    var itemIterator = TREASURE_CHEST.iterator(itemType);
    while (itemIterator.hasNext()) {
      LOGGER.info(itemIterator.next().toString());
    }
  }",iterator
bstIterator,"{
    LOGGER.info(""------------------------"");
    LOGGER.info(""BST Iterator: "");
    var root = buildIntegerBst();
    var bstIterator = new BstIterator<>(root);
    while (bstIterator.hasNext()) {
      LOGGER.info(""Next node: "" + bstIterator.next().getVal());
    }
  }",iterator
tempIdx,"{
    var items = chest.getItems();
    var tempIdx = idx;
    while (true) {
      tempIdx++;
      if (tempIdx >= items.size()) {
        tempIdx = -1;
        break;
      }
      if (type.equals(ItemType.ANY) || items.get(tempIdx).getType().equals(type)) {
        break;
      }
    }
    return tempIdx;
  }",break_loop_control
items,"{
    var items = chest.getItems();
    var tempIdx = idx;
    while (true) {
      tempIdx++;
      if (tempIdx >= items.size()) {
        tempIdx = -1;
        break;
      }
      if (type.equals(ItemType.ANY) || items.get(tempIdx).getType().equals(type)) {
        break;
      }
    }
    return tempIdx;
  }",break_loop_control
node,"{
    while (node != null) {
      pathStack.push(node);
      node = node.getLeft();
    }
  }",maybe_loop_control
curr,"{
    TreeNode<T> parent = null;
    var curr = this;

    while (curr != null) {
      parent = curr;
      curr = curr.traverseOneLevelDown(valToInsert);
    }

    return parent;
  }",maybe_loop_control
i,"{
        Logger logger = Logger.getLogger(""monitor"");
        var bank = new Bank(4, 1000, logger);
        Runnable runnable = () -> {
            try {
                Thread.sleep((long) (Math.random() * 1000));
                Random random = new Random();
                for (int i = 0; i < 1000000; i++)
                    bank.transfer(random.nextInt(4), random.nextInt(4), (int) (Math.random() * 1000));
            } catch (InterruptedException e) {
                logger.info(e.getMessage());
            }
        };
        ExecutorService executorService = Executors.newFixedThreadPool(5);
        for (int i = 0; i < 5; i++) {
            executorService.execute(runnable);
        }
    }",loop_control
account,"{
        int balance = 0;
        for (int account : accounts) {
            balance += account;
        }
        return balance;
    }",iterator
stat,"{
    final var prototype = new Character();

    for (final var stat : Stats.values()) {
      assertFalse(prototype.has(stat));
      assertNull(prototype.get(stat));

      final var expectedValue = stat.ordinal();
      prototype.set(stat, expectedValue);
      assertTrue(prototype.has(stat));
      assertEquals(expectedValue, prototype.get(stat));

      prototype.remove(stat);
      assertFalse(prototype.has(stat));
      assertNull(prototype.get(stat));
    }

  }",iterator
stat,"{
    final var prototype = new Character();
    Arrays.stream(Stats.values()).forEach(stat -> prototype.set(stat, stat.ordinal()));

    final var mage = new Character(Type.MAGE, prototype);
    for (final var stat : Stats.values()) {
      final var expectedValue = stat.ordinal();
      assertTrue(mage.has(stat));
      assertEquals(expectedValue, mage.get(stat));
    }
  }",iterator
stat,"{
    var builder = new StringBuilder();
    if (name != null) {
      builder.append(""Player: "").append(name).append('\n');
    }

    if (type != null) {
      builder.append(""Character type: "").append(type.name()).append('\n');
    }

    builder.append(""Stats:\n"");
    for (var stat : Stats.values()) {
      var value = this.get(stat);
      if (value == null) {
        continue;
      }
      builder.append("" - "").append(stat.name()).append(':').append(value).append('\n');
    }
    return builder.toString();
  }",iterator
i,"{
    final var server = mock(Server.class);
    when(server.getHost()).thenReturn(""testhost"");
    when(server.getPort()).thenReturn(1234);
    doNothing().when(server).serve(any(Request.class));

    final var loadBalancer = new LoadBalancer();
    loadBalancer.addServer(server);

    verifyZeroInteractions(server);

    final var request = new Request(""test"");
    for (var i = 0; i < loadBalancer.getNoOfServers() * 2; i++) {
      loadBalancer.serverRequest(request);
    }

    verify(server, times(2)).serve(request);
    verifyNoMoreInteractions(server);

  }",loop_control
port,"{
    var id = 0;
    for (var port : new int[]{8080, 8081, 8082, 8083, 8084}) {
      SERVERS.add(new Server(""localhost"", port, ++id));
    }
  }",iterator
serviceName,"{
    final var serviceNames = List.of(""jndi/serviceA"", ""jndi/serviceB"");

    for (final var serviceName : serviceNames) {
      final var service = ServiceLocator.getService(serviceName);
      assertNotNull(service);
      assertEquals(serviceName, service.getName());
      assertTrue(service.getId() > 0); // The id is generated randomly, but the minimum value is '1'
      assertSame(service, ServiceLocator.getService(serviceName));
    }

  }",iterator
action,"{
    final var member = memberSupplier.get();

    for (final var action : Action.values()) {
      member.partyAction(action);
      assertEquals(member.toString() + "" "" + action.getDescription(), appender.getLastMessage());
    }

    assertEquals(Action.values().length, appender.getLogSize());
  }",iterator
action,"{
    final var member = memberSupplier.get();

    member.act(Action.GOLD);
    assertEquals(0, appender.getLogSize());

    final var party = mock(Party.class);
    member.joinedParty(party);
    assertEquals(member.toString() + "" joins the party"", appender.getLastMessage());

    for (final var action : Action.values()) {
      member.act(action);
      assertEquals(member.toString() + "" "" + action.toString(), appender.getLastMessage());
      verify(party).act(member, action);
    }

    assertEquals(Action.values().length + 1, appender.getLogSize());
  }",iterator
member,"{
    for (var member : members) {
      if (!member.equals(actor)) {
        member.partyAction(action);
      }
    }
  }",iterator
i,"{
    StringBuilder log = new StringBuilder(""Black Pixels: "");
    var pixels = buffer.getPixels();
    for (var i = 0; i < pixels.length; ++i) {
      if (pixels[i] == Pixel.BLACK) {
        var y = i / FrameBuffer.WIDTH;
        var x = i % FrameBuffer.WIDTH;
        log.append("" ("").append(x).append("", "").append(y).append("")"");
      }
    }
    LOGGER.info(log.toString());
  }",loop_control
id,"{
    for (var id = 1; id <= numberOfWorkers; id++) {
      var worker = new Worker(id, this, taskSet, taskHandler);
      workers.add(worker);
    }
    promoteLeader();
  }",loop_control
i,"{
    var rand = new SecureRandom();
    for (var i = 0; i < 5; i++) {
      var time = Math.abs(rand.nextInt(1000));
      taskSet.addTask(new Task(time));
    }
  }",loop_control
i,"{
    var points = new ArrayList<Point>();
    var rand = new Random();
    for (int i = 0; i < 20; i++) {
      var p = new Bubble(rand.nextInt(300), rand.nextInt(300), i, rand.nextInt(2) + 1);
      points.add(p);
    }
    var field = new Rect(150, 150, 300, 300); //size of field
    var queryRange = new Rect(70, 130, 100, 100); //result = all points lying in this rectangle
    //points found in the query range using quadtree and normal method is same
    var points1 = QuadTreeTest.quadTreeTest(points, field, queryRange);
    var points2 = QuadTreeTest.verify(points, queryRange);
    assertEquals(points1, points2);
  }",loop_control
point,"{
    var toBePopped = false; //if any other bubble collides with it, made true
    for (var point : toCheck) {
      var otherId = point.id;
      if (allBubbles.get(otherId) != null && //the bubble hasn't been popped yet
          this.id != otherId && //the two bubbles are not the same
          this.touches(allBubbles.get(otherId))) { //the bubbles touch
        allBubbles.get(otherId).pop(allBubbles);
        toBePopped = true;
      }
    }
    if (toBePopped) {
      this.pop(allBubbles);
    }
  }",iterator
i,"{
    var bubbles1 = new HashMap<Integer, Bubble>();
    var bubbles2 = new HashMap<Integer, Bubble>();
    var rand = new SecureRandom();
    for (int i = 0; i < 10000; i++) {
      var b = new Bubble(rand.nextInt(300), rand.nextInt(300), i, rand.nextInt(2) + 1);
      bubbles1.put(i, b);
      bubbles2.put(i, b);
      LOGGER.info(BUBBLE, i, "" with radius "", b.radius,
          "" added at ("", b.coordinateX, "","", b.coordinateY + "")"");
    }

    var start1 = System.currentTimeMillis();
    App.noSpatialPartition(20, bubbles1);
    var end1 = System.currentTimeMillis();
    var start2 = System.currentTimeMillis();
    App.withSpatialPartition(300, 300, 20, bubbles2);
    var end2 = System.currentTimeMillis();
    LOGGER.info(""Without spatial partition takes "", (end1 - start1), ""ms"");
    LOGGER.info(""With spatial partition takes "", (end2 - start2), ""ms"");
  }",loop_control
d,"{
        for (double d = 0.1; d < 2; d = d + 0.1) {
            paymentTime *= d;
            queueTaskTime *= d;
            Commander c = buildCommanderObjectVanilla();
            var order = new Order(new User(""K"", ""J""), ""pen"", 1f);
            for (Order.MessageSent ms : Order.MessageSent.values()) {
                c.placeOrder(order);
                assertFalse(StringUtils.isBlank(order.id));
            }
        }
    }",loop_control
ms,"{
        for (double d = 0.1; d < 2; d = d + 0.1) {
            paymentTime *= d;
            queueTaskTime *= d;
            Commander c = buildCommanderObjectVanilla();
            var order = new Order(new User(""K"", ""J""), ""pen"", 1f);
            for (Order.MessageSent ms : Order.MessageSent.values()) {
                c.placeOrder(order);
                assertFalse(StringUtils.isBlank(order.id));
            }
        }
    }",iterator
d,"{
        for (double d = 0.1; d < 2; d = d + 0.1) {
            paymentTime *= d;
            queueTaskTime *= d;
            Commander c = buildCommanderObject(true);
            var order = new Order(new User(""K"", ""J""), ""pen"", 1f);
            for (Order.MessageSent ms : Order.MessageSent.values()) {
                c.placeOrder(order);
                assertFalse(StringUtils.isBlank(order.id));
            }
        }
    }",loop_control
ms,"{
        for (double d = 0.1; d < 2; d = d + 0.1) {
            paymentTime *= d;
            queueTaskTime *= d;
            Commander c = buildCommanderObject(true);
            var order = new Order(new User(""K"", ""J""), ""pen"", 1f);
            for (Order.MessageSent ms : Order.MessageSent.values()) {
                c.placeOrder(order);
                assertFalse(StringUtils.isBlank(order.id));
            }
        }
    }",iterator
d,"{
        for (double d = 0.1; d < 2; d = d + 0.1) {
            paymentTime *= d;
            queueTaskTime *= d;
            Commander c = buildCommanderObject(false);
            var order = new Order(new User(""K"", ""J""), ""pen"", 1f);
            for (Order.MessageSent ms : Order.MessageSent.values()) {
                c.placeOrder(order);
                assertFalse(StringUtils.isBlank(order.id));
            }
        }
    }",loop_control
ms,"{
        for (double d = 0.1; d < 2; d = d + 0.1) {
            paymentTime *= d;
            queueTaskTime *= d;
            Commander c = buildCommanderObject(false);
            var order = new Order(new User(""K"", ""J""), ""pen"", 1f);
            for (Order.MessageSent ms : Order.MessageSent.values()) {
                c.placeOrder(order);
                assertFalse(StringUtils.isBlank(order.id));
            }
        }
    }",iterator
d,"{
        for (double d = 0.1; d < 2; d = d + 0.1) {
            paymentTime *= d;
            queueTaskTime *= d;
            Commander c = buildCommanderObjectNoPaymentException1();
            var order = new Order(new User(""K"", ""J""), ""pen"", 1f);
            for (Order.MessageSent ms : Order.MessageSent.values()) {
                c.placeOrder(order);
                assertFalse(StringUtils.isBlank(order.id));
            }
        }
    }",loop_control
ms,"{
        for (double d = 0.1; d < 2; d = d + 0.1) {
            paymentTime *= d;
            queueTaskTime *= d;
            Commander c = buildCommanderObjectNoPaymentException1();
            var order = new Order(new User(""K"", ""J""), ""pen"", 1f);
            for (Order.MessageSent ms : Order.MessageSent.values()) {
                c.placeOrder(order);
                assertFalse(StringUtils.isBlank(order.id));
            }
        }
    }",iterator
d,"{
        for (double d = 0.1; d < 2; d = d + 0.1) {
            paymentTime *= d;
            queueTaskTime *= d;
            Commander c = buildCommanderObjectNoPaymentException2();
            var order = new Order(new User(""K"", ""J""), ""pen"", 1f);
            for (Order.MessageSent ms : Order.MessageSent.values()) {
                c.placeOrder(order);
                assertFalse(StringUtils.isBlank(order.id));
            }
        }
    }",loop_control
ms,"{
        for (double d = 0.1; d < 2; d = d + 0.1) {
            paymentTime *= d;
            queueTaskTime *= d;
            Commander c = buildCommanderObjectNoPaymentException2();
            var order = new Order(new User(""K"", ""J""), ""pen"", 1f);
            for (Order.MessageSent ms : Order.MessageSent.values()) {
                c.placeOrder(order);
                assertFalse(StringUtils.isBlank(order.id));
            }
        }
    }",iterator
d,"{
        for (double d = 0.1; d < 2; d = d + 0.1) {
            paymentTime *= d;
            queueTaskTime *= d;
            Commander c = buildCommanderObjectNoPaymentException3();
            var order = new Order(new User(""K"", ""J""), ""pen"", 1f);
            for (Order.MessageSent ms : Order.MessageSent.values()) {
                c.placeOrder(order);
                assertFalse(StringUtils.isBlank(order.id));
            }
        }
    }",loop_control
ms,"{
        for (double d = 0.1; d < 2; d = d + 0.1) {
            paymentTime *= d;
            queueTaskTime *= d;
            Commander c = buildCommanderObjectNoPaymentException3();
            var order = new Order(new User(""K"", ""J""), ""pen"", 1f);
            for (Order.MessageSent ms : Order.MessageSent.values()) {
                c.placeOrder(order);
                assertFalse(StringUtils.isBlank(order.id));
            }
        }
    }",iterator
d,"{
        for (double d = 0.1; d < 2; d = d + 0.1) {
            paymentTime *= d;
            queueTaskTime *= d;
            Commander c = buildCommanderObjectNoPaymentException3();
            var order = new Order(new User(""K"", ""J""), ""pen"", 1f);
            for (Order.MessageSent ms : Order.MessageSent.values()) {
                c.placeOrder(order);
                c.placeOrder(order);
                c.placeOrder(order);
                assertFalse(StringUtils.isBlank(order.id));
            }
        }
    }",loop_control
ms,"{
        for (double d = 0.1; d < 2; d = d + 0.1) {
            paymentTime *= d;
            queueTaskTime *= d;
            Commander c = buildCommanderObjectNoPaymentException3();
            var order = new Order(new User(""K"", ""J""), ""pen"", 1f);
            for (Order.MessageSent ms : Order.MessageSent.values()) {
                c.placeOrder(order);
                c.placeOrder(order);
                c.placeOrder(order);
                assertFalse(StringUtils.isBlank(order.id));
            }
        }
    }",iterator
d,"{
        for (double d = 0.1; d < 2; d = d + 0.1) {
            paymentTime *= d;
            queueTaskTime *= d;
            messageTime *= d;
            employeeTime *= d;
            queueTime *= d;
            Commander c = buildCommanderObjectUnknownException();
            var order = new Order(new User(""K"", ""J""), ""pen"", 1f);
            for (Order.MessageSent ms : Order.MessageSent.values()) {
                c.placeOrder(order);
                assertFalse(StringUtils.isBlank(order.id));
            }
        }
    }",loop_control
ms,"{
        for (double d = 0.1; d < 2; d = d + 0.1) {
            paymentTime *= d;
            queueTaskTime *= d;
            messageTime *= d;
            employeeTime *= d;
            queueTime *= d;
            Commander c = buildCommanderObjectUnknownException();
            var order = new Order(new User(""K"", ""J""), ""pen"", 1f);
            for (Order.MessageSent ms : Order.MessageSent.values()) {
                c.placeOrder(order);
                assertFalse(StringUtils.isBlank(order.id));
            }
        }
    }",iterator
d,"{
        for (double d = 0.1; d < 2; d = d + 0.1) {
            paymentTime *= d;
            queueTaskTime *= d;
            messageTime *= d;
            employeeTime *= d;
            queueTime *= d;
            Commander c = buildCommanderObject(true);
            var order = new Order(new User(""K"", ""J""), ""pen"", 1f);
            for (Order.MessageSent ms : Order.MessageSent.values()) {
                c.placeOrder(order);
                assertFalse(StringUtils.isBlank(order.id));
            }
        }
    }",loop_control
ms,"{
        for (double d = 0.1; d < 2; d = d + 0.1) {
            paymentTime *= d;
            queueTaskTime *= d;
            messageTime *= d;
            employeeTime *= d;
            queueTime *= d;
            Commander c = buildCommanderObject(true);
            var order = new Order(new User(""K"", ""J""), ""pen"", 1f);
            for (Order.MessageSent ms : Order.MessageSent.values()) {
                c.placeOrder(order);
                assertFalse(StringUtils.isBlank(order.id));
            }
        }
    }",iterator
d,"{
        for (double d = 0.1; d < 2; d = d + 0.1) {
            paymentTime *= d;
            queueTaskTime *= d;
            messageTime *= d;
            employeeTime *= d;
            queueTime *= d;
            Commander c = buildCommanderObject(false);
            var order = new Order(new User(""K"", ""J""), ""pen"", 1f);
            for (Order.MessageSent ms : Order.MessageSent.values()) {
                c.placeOrder(order);
                assertFalse(StringUtils.isBlank(order.id));
            }
        }
    }",loop_control
ms,"{
        for (double d = 0.1; d < 2; d = d + 0.1) {
            paymentTime *= d;
            queueTaskTime *= d;
            messageTime *= d;
            employeeTime *= d;
            queueTime *= d;
            Commander c = buildCommanderObject(false);
            var order = new Order(new User(""K"", ""J""), ""pen"", 1f);
            for (Order.MessageSent ms : Order.MessageSent.values()) {
                c.placeOrder(order);
                assertFalse(StringUtils.isBlank(order.id));
            }
        }
    }",iterator
d,"{
        for (double d = 0.1; d < 2; d = d + 0.1) {
            paymentTime *= d;
            queueTaskTime *= d;
            messageTime *= d;
            employeeTime *= d;
            queueTime *= d;
            Commander c = buildCommanderObjectNoPaymentException1();
            var order = new Order(new User(""K"", ""J""), ""pen"", 1f);
            for (Order.MessageSent ms : Order.MessageSent.values()) {
                c.placeOrder(order);
                assertFalse(StringUtils.isBlank(order.id));
            }
        }
    }",loop_control
ms,"{
        for (double d = 0.1; d < 2; d = d + 0.1) {
            paymentTime *= d;
            queueTaskTime *= d;
            messageTime *= d;
            employeeTime *= d;
            queueTime *= d;
            Commander c = buildCommanderObjectNoPaymentException1();
            var order = new Order(new User(""K"", ""J""), ""pen"", 1f);
            for (Order.MessageSent ms : Order.MessageSent.values()) {
                c.placeOrder(order);
                assertFalse(StringUtils.isBlank(order.id));
            }
        }
    }",iterator
d,"{
        for (double d = 0.1; d < 2; d = d + 0.1) {
            paymentTime *= d;
            queueTaskTime *= d;
            messageTime *= d;
            employeeTime *= d;
            queueTime *= d;
            Commander c = buildCommanderObjectUnknownException();
            var order = new Order(new User(""K"", ""J""), ""pen"", 1f);
            for (Order.MessageSent ms : Order.MessageSent.values()) {
                c.placeOrder(order);
                assertFalse(StringUtils.isBlank(order.id));
            }
        }
    }",loop_control
ms,"{
        for (double d = 0.1; d < 2; d = d + 0.1) {
            paymentTime *= d;
            queueTaskTime *= d;
            messageTime *= d;
            employeeTime *= d;
            queueTime *= d;
            Commander c = buildCommanderObjectUnknownException();
            var order = new Order(new User(""K"", ""J""), ""pen"", 1f);
            for (Order.MessageSent ms : Order.MessageSent.values()) {
                c.placeOrder(order);
                assertFalse(StringUtils.isBlank(order.id));
            }
        }
    }",iterator
d,"{
        for (double d = 0.1; d < 2; d = d + 0.1) {
            paymentTime *= d;
            queueTaskTime *= d;
            messageTime *= d;
            employeeTime *= d;
            queueTime *= d;
            Commander c = buildCommanderObjectWithDB();
            var order = new Order(new User(""K"", null), ""pen"", 1f);
            for (Order.MessageSent ms : Order.MessageSent.values()) {
                c.placeOrder(order);
                assertFalse(StringUtils.isBlank(order.id));
            }
        }
    }",loop_control
ms,"{
        for (double d = 0.1; d < 2; d = d + 0.1) {
            paymentTime *= d;
            queueTaskTime *= d;
            messageTime *= d;
            employeeTime *= d;
            queueTime *= d;
            Commander c = buildCommanderObjectWithDB();
            var order = new Order(new User(""K"", null), ""pen"", 1f);
            for (Order.MessageSent ms : Order.MessageSent.values()) {
                c.placeOrder(order);
                assertFalse(StringUtils.isBlank(order.id));
            }
        }
    }",iterator
d,"{
        for (double d = 0.1; d < 2; d = d + 0.1) {
            paymentTime *= d;
            queueTaskTime *= d;
            messageTime *= d;
            employeeTime *= d;
            queueTime *= d;

            for (Exception e : exceptionList) {

                Commander c = buildCommanderObjectWithDB(true, true, e);
                var order = new Order(new User(""K"", null), ""pen"", 1f);
                for (Order.MessageSent ms : Order.MessageSent.values()) {
                    c.placeOrder(order);
                    assertFalse(StringUtils.isBlank(order.id));
                }

                c = buildCommanderObjectWithDB(true, false, e);
                order = new Order(new User(""K"", null), ""pen"", 1f);
                for (Order.MessageSent ms : Order.MessageSent.values()) {
                    c.placeOrder(order);
                    assertFalse(StringUtils.isBlank(order.id));
                }

                c = buildCommanderObjectWithDB(false, false, e);
                order = new Order(new User(""K"", null), ""pen"", 1f);
                for (Order.MessageSent ms : Order.MessageSent.values()) {
                    c.placeOrder(order);
                    assertFalse(StringUtils.isBlank(order.id));
                }

                c = buildCommanderObjectWithDB(false, true, e);
                order = new Order(new User(""K"", null), ""pen"", 1f);
                for (Order.MessageSent ms : Order.MessageSent.values()) {
                    c.placeOrder(order);
                    assertFalse(StringUtils.isBlank(order.id));
                }
            }
        }
    }",loop_control
e,"{
        for (double d = 0.1; d < 2; d = d + 0.1) {
            paymentTime *= d;
            queueTaskTime *= d;
            messageTime *= d;
            employeeTime *= d;
            queueTime *= d;

            for (Exception e : exceptionList) {

                Commander c = buildCommanderObjectWithDB(true, true, e);
                var order = new Order(new User(""K"", null), ""pen"", 1f);
                for (Order.MessageSent ms : Order.MessageSent.values()) {
                    c.placeOrder(order);
                    assertFalse(StringUtils.isBlank(order.id));
                }

                c = buildCommanderObjectWithDB(true, false, e);
                order = new Order(new User(""K"", null), ""pen"", 1f);
                for (Order.MessageSent ms : Order.MessageSent.values()) {
                    c.placeOrder(order);
                    assertFalse(StringUtils.isBlank(order.id));
                }

                c = buildCommanderObjectWithDB(false, false, e);
                order = new Order(new User(""K"", null), ""pen"", 1f);
                for (Order.MessageSent ms : Order.MessageSent.values()) {
                    c.placeOrder(order);
                    assertFalse(StringUtils.isBlank(order.id));
                }

                c = buildCommanderObjectWithDB(false, true, e);
                order = new Order(new User(""K"", null), ""pen"", 1f);
                for (Order.MessageSent ms : Order.MessageSent.values()) {
                    c.placeOrder(order);
                    assertFalse(StringUtils.isBlank(order.id));
                }
            }
        }
    }",loop_control
ms,"{
        for (double d = 0.1; d < 2; d = d + 0.1) {
            paymentTime *= d;
            queueTaskTime *= d;
            messageTime *= d;
            employeeTime *= d;
            queueTime *= d;

            for (Exception e : exceptionList) {

                Commander c = buildCommanderObjectWithDB(true, true, e);
                var order = new Order(new User(""K"", null), ""pen"", 1f);
                for (Order.MessageSent ms : Order.MessageSent.values()) {
                    c.placeOrder(order);
                    assertFalse(StringUtils.isBlank(order.id));
                }

                c = buildCommanderObjectWithDB(true, false, e);
                order = new Order(new User(""K"", null), ""pen"", 1f);
                for (Order.MessageSent ms : Order.MessageSent.values()) {
                    c.placeOrder(order);
                    assertFalse(StringUtils.isBlank(order.id));
                }

                c = buildCommanderObjectWithDB(false, false, e);
                order = new Order(new User(""K"", null), ""pen"", 1f);
                for (Order.MessageSent ms : Order.MessageSent.values()) {
                    c.placeOrder(order);
                    assertFalse(StringUtils.isBlank(order.id));
                }

                c = buildCommanderObjectWithDB(false, true, e);
                order = new Order(new User(""K"", null), ""pen"", 1f);
                for (Order.MessageSent ms : Order.MessageSent.values()) {
                    c.placeOrder(order);
                    assertFalse(StringUtils.isBlank(order.id));
                }
            }
        }
    }",iterator
d,"{
        for (double d = 0.1; d < 2; d = d + 0.1) {
            paymentTime *= d;
            queueTaskTime *= d;
            messageTime *= d;
            employeeTime *= d;
            queueTime *= d;
            Commander c = buildCommanderObjectWithoutDB();
            var order = new Order(new User(""K"", null), ""pen"", 1f);
            for (Order.MessageSent ms : Order.MessageSent.values()) {
                c.placeOrder(order);
                assertFalse(StringUtils.isBlank(order.id));
            }
        }
    }",loop_control
ms,"{
        for (double d = 0.1; d < 2; d = d + 0.1) {
            paymentTime *= d;
            queueTaskTime *= d;
            messageTime *= d;
            employeeTime *= d;
            queueTime *= d;
            Commander c = buildCommanderObjectWithoutDB();
            var order = new Order(new User(""K"", null), ""pen"", 1f);
            for (Order.MessageSent ms : Order.MessageSent.values()) {
                c.placeOrder(order);
                assertFalse(StringUtils.isBlank(order.id));
            }
        }
    }",iterator
d,"{
        for (double d = 0.1; d < 2; d = d + 0.1) {
            paymentTime *= d;
            queueTaskTime *= d;
            messageTime *= d;
            employeeTime *= d;
            queueTime *= d;

            for (Exception e : exceptionList) {

                Commander c = buildCommanderObjectWithoutDB(true, true, e);
                var order = new Order(new User(""K"", null), ""pen"", 1f);
                for (Order.MessageSent ms : Order.MessageSent.values()) {
                    c.placeOrder(order);
                    assertFalse(StringUtils.isBlank(order.id));
                }

                c = buildCommanderObjectWithoutDB(true, false, e);
                order = new Order(new User(""K"", null), ""pen"", 1f);
                for (Order.MessageSent ms : Order.MessageSent.values()) {
                    c.placeOrder(order);
                    assertFalse(StringUtils.isBlank(order.id));
                }

                c = buildCommanderObjectWithoutDB(false, false, e);
                order = new Order(new User(""K"", null), ""pen"", 1f);
                for (Order.MessageSent ms : Order.MessageSent.values()) {
                    c.placeOrder(order);
                    assertFalse(StringUtils.isBlank(order.id));
                }

                c = buildCommanderObjectWithoutDB(false, true, e);
                order = new Order(new User(""K"", null), ""pen"", 1f);
                for (Order.MessageSent ms : Order.MessageSent.values()) {
                    c.placeOrder(order);
                    assertFalse(StringUtils.isBlank(order.id));
                }
            }
        }
    }",loop_control
ms,"{
        for (double d = 0.1; d < 2; d = d + 0.1) {
            paymentTime *= d;
            queueTaskTime *= d;
            messageTime *= d;
            employeeTime *= d;
            queueTime *= d;

            for (Exception e : exceptionList) {

                Commander c = buildCommanderObjectWithoutDB(true, true, e);
                var order = new Order(new User(""K"", null), ""pen"", 1f);
                for (Order.MessageSent ms : Order.MessageSent.values()) {
                    c.placeOrder(order);
                    assertFalse(StringUtils.isBlank(order.id));
                }

                c = buildCommanderObjectWithoutDB(true, false, e);
                order = new Order(new User(""K"", null), ""pen"", 1f);
                for (Order.MessageSent ms : Order.MessageSent.values()) {
                    c.placeOrder(order);
                    assertFalse(StringUtils.isBlank(order.id));
                }

                c = buildCommanderObjectWithoutDB(false, false, e);
                order = new Order(new User(""K"", null), ""pen"", 1f);
                for (Order.MessageSent ms : Order.MessageSent.values()) {
                    c.placeOrder(order);
                    assertFalse(StringUtils.isBlank(order.id));
                }

                c = buildCommanderObjectWithoutDB(false, true, e);
                order = new Order(new User(""K"", null), ""pen"", 1f);
                for (Order.MessageSent ms : Order.MessageSent.values()) {
                    c.placeOrder(order);
                    assertFalse(StringUtils.isBlank(order.id));
                }
            }
        }
    }",iterator
e,"{
        for (double d = 0.1; d < 2; d = d + 0.1) {
            paymentTime *= d;
            queueTaskTime *= d;
            messageTime *= d;
            employeeTime *= d;
            queueTime *= d;

            for (Exception e : exceptionList) {

                Commander c = buildCommanderObjectWithoutDB(true, true, e);
                var order = new Order(new User(""K"", null), ""pen"", 1f);
                for (Order.MessageSent ms : Order.MessageSent.values()) {
                    c.placeOrder(order);
                    assertFalse(StringUtils.isBlank(order.id));
                }

                c = buildCommanderObjectWithoutDB(true, false, e);
                order = new Order(new User(""K"", null), ""pen"", 1f);
                for (Order.MessageSent ms : Order.MessageSent.values()) {
                    c.placeOrder(order);
                    assertFalse(StringUtils.isBlank(order.id));
                }

                c = buildCommanderObjectWithoutDB(false, false, e);
                order = new Order(new User(""K"", null), ""pen"", 1f);
                for (Order.MessageSent ms : Order.MessageSent.values()) {
                    c.placeOrder(order);
                    assertFalse(StringUtils.isBlank(order.id));
                }

                c = buildCommanderObjectWithoutDB(false, true, e);
                order = new Order(new User(""K"", null), ""pen"", 1f);
                for (Order.MessageSent ms : Order.MessageSent.values()) {
                    c.placeOrder(order);
                    assertFalse(StringUtils.isBlank(order.id));
                }
            }
        }
    }",iterator
i,"{
    final var testData = new ArrayList<Arguments>();
    for (var i = -10; i < 10; i++) {
      for (var j = -10; j < 10; j++) {
        testData.add(Arguments.of(
            new NumberExpression(i),
            new NumberExpression(j),
            resultCalc.applyAsInt(i, j)
        ));
      }
    }
    return testData.stream();
  }",loop_control
j,"{
    final var testData = new ArrayList<Arguments>();
    for (var i = -10; i < 10; i++) {
      for (var j = -10; j < 10; j++) {
        testData.add(Arguments.of(
            new NumberExpression(i),
            new NumberExpression(j),
            resultCalc.applyAsInt(i, j)
        ));
      }
    }
    return testData.stream();
  }",loop_control
s,"{

    // the halfling kids are learning some basic math at school
    // define the math string we want to parse
    final var tokenString = ""4 3 2 - 1 + *"";

    // the stack holds the parsed expressions
    var stack = new Stack<Expression>();

    // tokenize the string and go through them one by one
    var tokenList = tokenString.split("" "");
    for (var s : tokenList) {
      if (isOperator(s)) {
        // when an operator is encountered we expect that the numbers can be popped from the top of
        // the stack
        var rightExpression = stack.pop();
        var leftExpression = stack.pop();
        LOGGER.info(""popped from stack left: {} right: {}"",
            leftExpression.interpret(), rightExpression.interpret());
        var operator = getOperatorInstance(s, leftExpression, rightExpression);
        LOGGER.info(""operator: {}"", operator);
        var result = operator.interpret();
        // the operation result is pushed on top of the stack
        var resultExpression = new NumberExpression(result);
        stack.push(resultExpression);
        LOGGER.info(""push result to stack: {}"", resultExpression.interpret());
      } else {
        // numbers are pushed on top of the stack
        var i = new NumberExpression(s);
        stack.push(i);
        LOGGER.info(""push to stack: {}"", i.interpret());
      }
    }
    // in the end, the final result lies on top of the stack
    LOGGER.info(""result: {}"", stack.pop().interpret());
  }",iterator
weekday,"{

    for (final var weekday : Weekday.values()) {
      // Pass each week of the day, day by day to the event emitter
      emitter.timePasses(weekday);

      if (weekday == specialDay) {
        // On a special day, every observer should have received the event
        for (final var observer : observers) {
          verify(observer, times(1)).onEvent(eq(event));
        }
      } else {
        // On any other normal day, the observers should have received nothing at all
        verifyZeroInteractions(observers);
      }
    }

    // The observers should not have received any additional events after the week
    verifyNoMoreInteractions(observers);
  }",iterator
observer,"{

    for (final var weekday : Weekday.values()) {
      // Pass each week of the day, day by day to the event emitter
      emitter.timePasses(weekday);

      if (weekday == specialDay) {
        // On a special day, every observer should have received the event
        for (final var observer : observers) {
          verify(observer, times(1)).onEvent(eq(event));
        }
      } else {
        // On any other normal day, the observers should have received nothing at all
        verifyZeroInteractions(observers);
      }
    }

    // The observers should not have received any additional events after the week
    verifyNoMoreInteractions(observers);
  }",iterator
num,"{
    LOGGER.info(""Source module {}"", VERSION);
    var sum = 0;
    for (final var num : nums) {
      sum += num;
    }
    return sum;
  }",iterator
num,"{
    LOGGER.info(""Source module {}"", VERSION);
    var sum = 1;
    for (final var num : nums) {
      sum *= num;
    }
    return sum;
  }",iterator
i,"{
        System.setProperty(""BlobStorageConnectionString"", ""https://www.dummyEndpoint.com/api/blobs"");

        var messageBody = new MessageBody<UsageDetail>();
        var usageDetailsList = new ArrayList<UsageDetail>();
        var random = new Random();
        for (int i = 0; i < 51; i++) {
            var usageDetail = new UsageDetail();
            usageDetail.setUserId(""userId"" + i);
            usageDetail.setData(random.nextInt(500));
            usageDetail.setDuration(random.nextInt(500));

            usageDetailsList.add(usageDetail);
        }
        messageBody.setData(usageDetailsList);

        // Create message header
        var messageHeader = new MessageHeader();
        messageHeader.setId(UUID.randomUUID().toString());
        messageHeader.setSubject(""UsageDetailPublisher"");
        messageHeader.setTopic(""usagecostprocessorfunction-topic"");
        messageHeader.setEventType(""UsageDetail"");
        messageHeader.setEventTime(OffsetDateTime.now().toString());
        this.messageReference = new MessageReference(""callusageapp"", messageHeader.getId() + ""/input.json"");
        messageHeader.setData(messageReference);
        messageHeader.setDataVersion(""v1.0"");

        // Create entire message
        this.messageToPublish = new Message<>();
        this.messageToPublish.setMessageHeader(messageHeader);
        this.messageToPublish.setMessageBody(messageBody);

        when(mockContainerClient.getBlobClient(anyString())).thenReturn(mockBlobClient);
        when(mockBlobServiceClient.getBlobContainerClient(anyString())).thenReturn(mockContainerClient);
    }",loop_control
i,"{
        var messageBodyUsageDetail = new MessageBody<UsageDetail>();
        var usageDetailsList = new ArrayList<UsageDetail>();

        var messageBodyUsageCostDetail = new MessageBody<UsageCostDetail>();
        var usageCostDetailsList = new ArrayList<UsageCostDetail>();
        for (int i = 0; i < 2; i++) {
            var usageDetail = new UsageDetail();
            usageDetail.setUserId(""userId"" + i);
            usageDetail.setData(i + 1);
            usageDetail.setDuration(i + 1);
            usageDetailsList.add(usageDetail);

            var usageCostDetail = new UsageCostDetail();
            usageCostDetail.setUserId(usageDetail.getUserId());
            usageCostDetail.setDataCost(usageDetail.getData() * 0.20);
            usageCostDetail.setCallCost(usageDetail.getDuration() * 0.30);
            usageCostDetailsList.add(usageCostDetail);
        }
        messageBodyUsageDetail.setData(usageDetailsList);
        messageBodyUsageCostDetail.setData(usageCostDetailsList);

        // Create message header
        var messageHeader = new MessageHeader();
        messageHeader.setId(UUID.randomUUID().toString());
        messageHeader.setSubject(""UsageDetailPublisher"");
        messageHeader.setTopic(""usagecostprocessorfunction-topic"");
        messageHeader.setEventType(""UsageDetail"");
        messageHeader.setEventTime(OffsetDateTime.now().toString());
        this.messageReference = new MessageReference(""callusageapp"", ""d8284456-dfff-4bd4-9cef-ea99f70f4835/input.json"");
        messageHeader.setData(messageReference);
        messageHeader.setDataVersion(""v1.0"");

        // Create entire message
        messageToRead = new Message<>();
        messageToRead.setMessageHeader(messageHeader);
        messageToRead.setMessageBody(messageBodyUsageDetail);

        messageToDrop = new Message<>();
        messageToDrop.setMessageHeader(messageHeader);
        messageToDrop.setMessageBody(messageBodyUsageCostDetail);

    }",loop_control
eventGridEvent,"{
    try {
      var eventGridEvents = EventGridEvent.fromString(request.getBody().get());
      for (var eventGridEvent : eventGridEvents) {
        // Handle system events
        if (eventGridEvent.getEventType()
            .equals(""Microsoft.EventGrid.SubscriptionValidationEvent"")) {
          SubscriptionValidationEventData subscriptionValidationEventData = eventGridEvent.getData()
              .toObject(SubscriptionValidationEventData.class);
          // Handle the subscription validation event
          var responseData = new SubscriptionValidationResponse();
          responseData.setValidationResponse(subscriptionValidationEventData.getValidationCode());
          return request.createResponseBuilder(HttpStatus.OK).body(responseData).build();

        } else if (eventGridEvent.getEventType().equals(""UsageDetail"")) {
          // Get message header and reference
          var messageReference = eventGridEvent.getData()
              .toObject(MessageReference.class);

          // Read message from persistent storage
          var message = this.messageHandlerUtilityForUsageDetail
              .readFromPersistantStorage(messageReference, context.getLogger());

          // Get Data and generate cost details
          List<UsageDetail> usageDetailsList = BinaryData.fromObject(
              message.getMessageBody().getData())
              .toObject(new TypeReference<>() {
              });
          var usageCostDetailsList = calculateUsageCostDetails(usageDetailsList);

          // Create message body
          var newMessageBody = new MessageBody<UsageCostDetail>();
          newMessageBody.setData(usageCostDetailsList);

          // Create message header
          var newMessageReference = new MessageReference(""callusageapp"",
              eventGridEvent.getId() + ""/output.json"");
          var newMessageHeader = new MessageHeader();
          newMessageHeader.setId(eventGridEvent.getId());
          newMessageHeader.setSubject(""UsageCostProcessor"");
          newMessageHeader.setTopic("""");
          newMessageHeader.setEventType(""UsageCostDetail"");
          newMessageHeader.setEventTime(OffsetDateTime.now().toString());
          newMessageHeader.setData(newMessageReference);
          newMessageHeader.setDataVersion(""v1.0"");

          // Create entire message
          var newMessage = new Message<UsageCostDetail>();
          newMessage.setMessageHeader(newMessageHeader);
          newMessage.setMessageBody(newMessageBody);

          // Drop data to persistent storage
          this.messageHandlerUtilityForUsageCostDetail.dropToPersistantStorage(newMessage,
              context.getLogger());

          context.getLogger().info(""Message is dropped successfully"");
          return request.createResponseBuilder(HttpStatus.OK)
              .body(""Message is dropped successfully"").build();
        }
      }
    } catch (Exception e) {
      context.getLogger().warning(e.getMessage());
    }

    return request.createResponseBuilder(HttpStatus.INTERNAL_SERVER_ERROR).body(null).build();
  }",iterator
eventGridEvent,"{
    try {

      var eventGridEvents = EventGridEvent.fromString(request.getBody().get());

      for (EventGridEvent eventGridEvent : eventGridEvents) {
        // Handle system events
        if (eventGridEvent.getEventType()
            .equals(""Microsoft.EventGrid.SubscriptionValidationEvent"")) {
          SubscriptionValidationEventData subscriptionValidationEventData = eventGridEvent.getData()
              .toObject(SubscriptionValidationEventData.class);
          // Handle the subscription validation event
          var responseData = new SubscriptionValidationResponse();
          responseData.setValidationResponse(subscriptionValidationEventData.getValidationCode());
          return request.createResponseBuilder(HttpStatus.OK).body(responseData).build();

        } else if (eventGridEvent.getEventType().equals(""UsageDetail"")) {
          // Create message body
          var messageBody = new MessageBody<UsageDetail>();
          var usageDetailsList = new ArrayList<UsageDetail>();
          var random = new Random();
          for (int i = 0; i < 51; i++) {
            var usageDetail = new UsageDetail();
            usageDetail.setUserId(""userId"" + i);
            usageDetail.setData(random.nextInt(500));
            usageDetail.setDuration(random.nextInt(500));

            usageDetailsList.add(usageDetail);
          }
          messageBody.setData(usageDetailsList);

          // Create message header
          var messageHeader = new MessageHeader();
          messageHeader.setId(UUID.randomUUID().toString());
          messageHeader.setSubject(""UsageDetailPublisher"");
          messageHeader.setTopic(""usagecostprocessorfunction-topic"");
          messageHeader.setEventType(""UsageDetail"");
          messageHeader.setEventTime(OffsetDateTime.now().toString());
          var messageReference = new MessageReference(""callusageapp"",
              messageHeader.getId() + ""/input.json"");
          messageHeader.setData(messageReference);
          messageHeader.setDataVersion(""v1.0"");

          // Create entire message
          var message = new Message<UsageDetail>();
          message.setMessageHeader(messageHeader);
          message.setMessageBody(messageBody);

          // Drop data to persistent storage
          this.messageHandlerUtility.dropToPersistantStorage(message, context.getLogger());

          // Publish event to event grid topic
          eventHandlerUtility.publishEvent(messageHeader, context.getLogger());

          context.getLogger().info(""Message is dropped and event is published successfully"");
          return request.createResponseBuilder(HttpStatus.OK).body(message).build();
        }
      }
    } catch (Exception e) {
      context.getLogger().warning(e.getMessage());
    }

    return request.createResponseBuilder(HttpStatus.OK).body(null).build();
  }",iterator
i,"{
    try {

      var eventGridEvents = EventGridEvent.fromString(request.getBody().get());

      for (EventGridEvent eventGridEvent : eventGridEvents) {
        // Handle system events
        if (eventGridEvent.getEventType()
            .equals(""Microsoft.EventGrid.SubscriptionValidationEvent"")) {
          SubscriptionValidationEventData subscriptionValidationEventData = eventGridEvent.getData()
              .toObject(SubscriptionValidationEventData.class);
          // Handle the subscription validation event
          var responseData = new SubscriptionValidationResponse();
          responseData.setValidationResponse(subscriptionValidationEventData.getValidationCode());
          return request.createResponseBuilder(HttpStatus.OK).body(responseData).build();

        } else if (eventGridEvent.getEventType().equals(""UsageDetail"")) {
          // Create message body
          var messageBody = new MessageBody<UsageDetail>();
          var usageDetailsList = new ArrayList<UsageDetail>();
          var random = new Random();
          for (int i = 0; i < 51; i++) {
            var usageDetail = new UsageDetail();
            usageDetail.setUserId(""userId"" + i);
            usageDetail.setData(random.nextInt(500));
            usageDetail.setDuration(random.nextInt(500));

            usageDetailsList.add(usageDetail);
          }
          messageBody.setData(usageDetailsList);

          // Create message header
          var messageHeader = new MessageHeader();
          messageHeader.setId(UUID.randomUUID().toString());
          messageHeader.setSubject(""UsageDetailPublisher"");
          messageHeader.setTopic(""usagecostprocessorfunction-topic"");
          messageHeader.setEventType(""UsageDetail"");
          messageHeader.setEventTime(OffsetDateTime.now().toString());
          var messageReference = new MessageReference(""callusageapp"",
              messageHeader.getId() + ""/input.json"");
          messageHeader.setData(messageReference);
          messageHeader.setDataVersion(""v1.0"");

          // Create entire message
          var message = new Message<UsageDetail>();
          message.setMessageHeader(messageHeader);
          message.setMessageBody(messageBody);

          // Drop data to persistent storage
          this.messageHandlerUtility.dropToPersistantStorage(message, context.getLogger());

          // Publish event to event grid topic
          eventHandlerUtility.publishEvent(messageHeader, context.getLogger());

          context.getLogger().info(""Message is dropped and event is published successfully"");
          return request.createResponseBuilder(HttpStatus.OK).body(message).build();
        }
      }
    } catch (Exception e) {
      context.getLogger().warning(e.getMessage());
    }

    return request.createResponseBuilder(HttpStatus.OK).body(null).build();
  }",loop_control
layer,"{
    final var service = new CakeBakingServiceImpl();

    final var initialLayers = service.getAvailableLayers();
    assertNotNull(initialLayers);
    assertTrue(initialLayers.isEmpty());

    service.saveNewLayer(new CakeLayerInfo(""Layer1"", 1000));
    service.saveNewLayer(new CakeLayerInfo(""Layer2"", 2000));

    final var availableLayers = service.getAvailableLayers();
    assertNotNull(availableLayers);
    assertEquals(2, availableLayers.size());
    for (final var layer : availableLayers) {
      assertNotNull(layer.id);
      assertNotNull(layer.name);
      assertNotNull(layer.toString());
      assertTrue(layer.calories > 0);
    }

  }",iterator
topping,"{
    final var service = new CakeBakingServiceImpl();

    final var initialToppings = service.getAvailableToppings();
    assertNotNull(initialToppings);
    assertTrue(initialToppings.isEmpty());

    service.saveNewTopping(new CakeToppingInfo(""Topping1"", 1000));
    service.saveNewTopping(new CakeToppingInfo(""Topping2"", 2000));

    final var availableToppings = service.getAvailableToppings();
    assertNotNull(availableToppings);
    assertEquals(2, availableToppings.size());
    for (final var topping : availableToppings) {
      assertNotNull(topping.id);
      assertNotNull(topping.name);
      assertNotNull(topping.toString());
      assertTrue(topping.calories > 0);
    }

  }",iterator
cakeInfo,"{
    final var service = new CakeBakingServiceImpl();

    final var initialCakes = service.getAllCakes();
    assertNotNull(initialCakes);
    assertTrue(initialCakes.isEmpty());

    final var topping1 = new CakeToppingInfo(""Topping1"", 1000);
    final var topping2 = new CakeToppingInfo(""Topping2"", 2000);
    service.saveNewTopping(topping1);
    service.saveNewTopping(topping2);

    final var layer1 = new CakeLayerInfo(""Layer1"", 1000);
    final var layer2 = new CakeLayerInfo(""Layer2"", 2000);
    final var layer3 = new CakeLayerInfo(""Layer3"", 2000);
    service.saveNewLayer(layer1);
    service.saveNewLayer(layer2);
    service.saveNewLayer(layer3);

    service.bakeNewCake(new CakeInfo(topping1, List.of(layer1, layer2)));
    service.bakeNewCake(new CakeInfo(topping2, Collections.singletonList(layer3)));

    final var allCakes = service.getAllCakes();
    assertNotNull(allCakes);
    assertEquals(2, allCakes.size());
    for (final var cakeInfo : allCakes) {
      assertNotNull(cakeInfo.id);
      assertNotNull(cakeInfo.cakeToppingInfo);
      assertNotNull(cakeInfo.cakeLayerInfos);
      assertNotNull(cakeInfo.toString());
      assertFalse(cakeInfo.cakeLayerInfos.isEmpty());
      assertTrue(cakeInfo.calculateTotalCalories() > 0);
    }

  }",iterator
info,"{
    var allToppings = getAvailableToppingEntities();
    var matchingToppings =
        allToppings.stream().filter(t -> t.getName().equals(cakeInfo.cakeToppingInfo.name))
            .collect(Collectors.toList());
    if (matchingToppings.isEmpty()) {
      throw new CakeBakingException(String.format(""Topping %s is not available"",
          cakeInfo.cakeToppingInfo.name));
    }
    var allLayers = getAvailableLayerEntities();
    Set<CakeLayer> foundLayers = new HashSet<>();
    for (var info : cakeInfo.cakeLayerInfos) {
      var found = allLayers.stream().filter(layer -> layer.getName().equals(info.name)).findFirst();
      if (found.isEmpty()) {
        throw new CakeBakingException(String.format(""Layer %s is not available"", info.name));
      } else {
        foundLayers.add(found.get());
      }
    }
    var toppingBean = context.getBean(CakeToppingDao.class);
    var topping = toppingBean.findById(matchingToppings.iterator().next().getId());
    var cakeBean = context.getBean(CakeDao.class);
    if (topping.isPresent()) {
      var cake = new Cake();
      cake.setTopping(topping.get());
      cake.setLayers(foundLayers);
      cakeBean.save(cake);
      topping.get().setCake(cake);
      toppingBean.save(topping.get());
      var layerBean = context.getBean(CakeLayerDao.class);
      for (var layer : foundLayers) {
        layer.setCake(cake);
        layerBean.save(layer);
      }
    } else {
      throw new CakeBakingException(String.format(""Topping %s is not available"",
          cakeInfo.cakeToppingInfo.name));
    }
  }",iterator
layer,"{
    var allToppings = getAvailableToppingEntities();
    var matchingToppings =
        allToppings.stream().filter(t -> t.getName().equals(cakeInfo.cakeToppingInfo.name))
            .collect(Collectors.toList());
    if (matchingToppings.isEmpty()) {
      throw new CakeBakingException(String.format(""Topping %s is not available"",
          cakeInfo.cakeToppingInfo.name));
    }
    var allLayers = getAvailableLayerEntities();
    Set<CakeLayer> foundLayers = new HashSet<>();
    for (var info : cakeInfo.cakeLayerInfos) {
      var found = allLayers.stream().filter(layer -> layer.getName().equals(info.name)).findFirst();
      if (found.isEmpty()) {
        throw new CakeBakingException(String.format(""Layer %s is not available"", info.name));
      } else {
        foundLayers.add(found.get());
      }
    }
    var toppingBean = context.getBean(CakeToppingDao.class);
    var topping = toppingBean.findById(matchingToppings.iterator().next().getId());
    var cakeBean = context.getBean(CakeDao.class);
    if (topping.isPresent()) {
      var cake = new Cake();
      cake.setTopping(topping.get());
      cake.setLayers(foundLayers);
      cakeBean.save(cake);
      topping.get().setCake(cake);
      toppingBean.save(topping.get());
      var layerBean = context.getBean(CakeLayerDao.class);
      for (var layer : foundLayers) {
        layer.setCake(cake);
        layerBean.save(layer);
      }
    } else {
      throw new CakeBakingException(String.format(""Topping %s is not available"",
          cakeInfo.cakeToppingInfo.name));
    }
  }",iterator
topping,"{
    var bean = context.getBean(CakeToppingDao.class);
    List<CakeTopping> result = new ArrayList<>();
    for (CakeTopping topping : bean.findAll()) {
      if (topping.getCake() == null) {
        result.add(topping);
      }
    }
    return result;
  }",iterator
next,"{
    var bean = context.getBean(CakeToppingDao.class);
    List<CakeToppingInfo> result = new ArrayList<>();
    for (CakeTopping next : bean.findAll()) {
      if (next.getCake() == null) {
        result.add(new CakeToppingInfo(next.getId(), next.getName(), next.getCalories()));
      }
    }
    return result;
  }",iterator
next,"{
    var bean = context.getBean(CakeLayerDao.class);
    List<CakeLayer> result = new ArrayList<>();
    for (CakeLayer next : bean.findAll()) {
      if (next.getCake() == null) {
        result.add(next);
      }
    }
    return result;
  }",iterator
next,"{
    var bean = context.getBean(CakeLayerDao.class);
    List<CakeLayerInfo> result = new ArrayList<>();
    for (CakeLayer next : bean.findAll()) {
      if (next.getCake() == null) {
        result.add(new CakeLayerInfo(next.getId(), next.getName(), next.getCalories()));
      }
    }
    return result;
  }",iterator
cake,"{
    var cakeBean = context.getBean(CakeDao.class);
    List<CakeInfo> result = new ArrayList<>();
    for (Cake cake : cakeBean.findAll()) {
      var cakeToppingInfo =
          new CakeToppingInfo(cake.getTopping().getId(), cake.getTopping().getName(), cake
              .getTopping().getCalories());
      List<CakeLayerInfo> cakeLayerInfos = new ArrayList<>();
      for (var layer : cake.getLayers()) {
        cakeLayerInfos.add(new CakeLayerInfo(layer.getId(), layer.getName(), layer.getCalories()));
      }
      var cakeInfo = new CakeInfo(cake.getId(), cakeToppingInfo, cakeLayerInfos);
      result.add(cakeInfo);
    }
    return result;
  }",iterator
layer,"{
    var cakeBean = context.getBean(CakeDao.class);
    List<CakeInfo> result = new ArrayList<>();
    for (Cake cake : cakeBean.findAll()) {
      var cakeToppingInfo =
          new CakeToppingInfo(cake.getTopping().getId(), cake.getTopping().getName(), cake
              .getTopping().getCalories());
      List<CakeLayerInfo> cakeLayerInfos = new ArrayList<>();
      for (var layer : cake.getLayers()) {
        cakeLayerInfos.add(new CakeLayerInfo(layer.getId(), layer.getName(), layer.getCalories()));
      }
      var cakeInfo = new CakeInfo(cake.getId(), cakeToppingInfo, cakeLayerInfos);
      result.add(cakeInfo);
    }
    return result;
  }",iterator
i,"{
    final var observer = mock(WeatherObserver.class);
    final var weather = new Weather();
    weather.addObserver(observer);

    final var inOrder = inOrder(observer);
    final var weatherTypes = WeatherType.values();
    for (var i = 1; i < 20; i++) {
      weather.timePasses();
      inOrder.verify(observer).update(weatherTypes[i % weatherTypes.length]);
    }

    verifyNoMoreInteractions(observer);
  }",loop_control
i,"{
    final var observer = mock(Race.class);
    final var weather = new GWeather();
    weather.addObserver(observer);

    final var inOrder = inOrder(observer);
    final var weatherTypes = WeatherType.values();
    for (var i = 1; i < 20; i++) {
      weather.timePasses();
      inOrder.verify(observer).update(weather, weatherTypes[i % weatherTypes.length]);
    }

    verifyNoMoreInteractions(observer);
  }",loop_control
obs,"{
    for (var obs : observers) {
      obs.update(currentWeather);
    }
  }",iterator
observer,"{
    for (var observer : observers) {
      observer.update((S) this, argument);
    }
  }",iterator
i,"{
    final var washingMachine = new WashingMachine();
    var executorService = Executors.newFixedThreadPool(3);
    for (int i = 0; i < 3; i++) {
      executorService.execute(washingMachine::wash);
    }
    executorService.shutdown();
    try {
      if (!executorService.awaitTermination(10, TimeUnit.SECONDS)) {
        executorService.shutdownNow();
      }
    } catch (InterruptedException ie) {
      LOGGER.error(""ERROR: Waiting on executor service shutdown!"");
      Thread.currentThread().interrupt();
    }
  }",loop_control
book,"{
    final var dao = getDao();
    final var allBooks = dao.findAll();
    for (final var book : allBooks) {
      final var spellByName = dao.findByName(book.getName());
      assertNotNull(spellByName);
      assertEquals(book.getId(), spellByName.getId());
      assertEquals(book.getName(), spellByName.getName());
    }
  }",iterator
i,"{
    for (int i = 0; i < INITIAL_COUNT; i++) {
      final var className = dao.persistentClass.getSimpleName();
      final var entityName = String.format(""%s%d"", className, ID_GENERATOR.incrementAndGet());
      this.dao.persist(this.factory.apply(entityName));
    }
  }",loop_control
entity,"{
    final var all = this.dao.findAll();
    for (final var entity : all) {
      final var byId = this.dao.find(entity.getId());
      assertNotNull(byId);
      assertEquals(byId.getId(), byId.getId());
    }
  }",iterator
spell,"{
    final var dao = getDao();
    final var allWizards = dao.findAll();
    for (final var spell : allWizards) {
      final var byName = dao.findByName(spell.getName());
      assertNotNull(byName);
      assertEquals(spell.getId(), byName.getId());
      assertEquals(spell.getName(), byName.getName());
    }
  }",iterator
spell,"{
    final var dao = getDao();
    final var allSpells = dao.findAll();
    for (final var spell : allSpells) {
      final var spellByName = dao.findByName(spell.getName());
      assertNotNull(spellByName);
      assertEquals(spell.getId(), spellByName.getId());
      assertEquals(spell.getName(), spellByName.getName());
    }
  }",iterator
car,"{
    List<Car> carsSortedByYear = new ArrayList<>();

    for (Car car : cars) {
      if (car.getYear() > 2000) {
        carsSortedByYear.add(car);
      }
    }

    Collections.sort(carsSortedByYear, new Comparator<Car>() {
      @Override
      public int compare(Car car1, Car car2) {
        return car1.getYear() - car2.getYear();
      }
    });

    List<String> models = new ArrayList<>();
    for (Car car : carsSortedByYear) {
      models.add(car.getModel());
    }

    return models;
  }",iterator
car,"{
    Map<Category, List<Car>> groupingByCategory = new HashMap<>();
    for (Car car : cars) {
      if (groupingByCategory.containsKey(car.getCategory())) {
        groupingByCategory.get(car.getCategory()).add(car);
      } else {
        List<Car> categoryCars = new ArrayList<>();
        categoryCars.add(car);
        groupingByCategory.put(car.getCategory(), categoryCars);
      }
    }
    return groupingByCategory;
  }",iterator
person,"{
    List<Car> cars = new ArrayList<>();
    for (Person person : persons) {
      cars.addAll(person.getCars());
    }

    List<Car> sedanCars = new ArrayList<>();
    for (Car car : cars) {
      if (Category.SEDAN.equals(car.getCategory())) {
        sedanCars.add(car);
      }
    }

    sedanCars.sort(new Comparator<Car>() {
      @Override
      public int compare(Car o1, Car o2) {
        return o1.getYear() - o2.getYear();
      }
    });

    return sedanCars;
  }",iterator
car,"{
    List<Car> cars = new ArrayList<>();
    for (Person person : persons) {
      cars.addAll(person.getCars());
    }

    List<Car> sedanCars = new ArrayList<>();
    for (Car car : cars) {
      if (Category.SEDAN.equals(car.getCategory())) {
        sedanCars.add(car);
      }
    }

    sedanCars.sort(new Comparator<Car>() {
      @Override
      public int compare(Car o1, Car o2) {
        return o1.getYear() - o2.getYear();
      }
    });

    return sedanCars;
  }",iterator
content,"{
    for (final var content : Content.values()) {
      final var toString = content.toString();
      assertNotNull(toString);
      assertFalse(toString.trim().isEmpty());
    }
  }",iterator
menuItem,"{
    for (final var menuItem : MenuItem.values()) {
      final var toString = menuItem.toString();
      assertNotNull(toString);
      assertFalse(toString.trim().isEmpty());
    }
  }",iterator
item,"{
    for (var item : MenuItem.values()) {
      if (selected.equals(item)) {
        LOGGER.info(""* {}"", item);
      } else {
        LOGGER.info(item.toString());
      }
    }
  }",iterator
customer,"{
    for (var customer : generateSampleCustomers()) {
      customerDao.add(customer);
    }
  }",iterator
room,"{
    for (var room : generateSampleRooms()) {
      hotelDao.add(room);
    }
  }",iterator
room,"{
    for (var room : generateSampleRooms()) {
      hotelDao.add(room);
    }
  }",iterator
i,"{
    var rows = 10;
    var columns = 10;
    var inputMatrix = new int[rows][columns];
    var rand = new Random();
    for (var i = 0; i < rows; i++) {
      for (var j = 0; j < columns; j++) {
        inputMatrix[i][j] = rand.nextInt(10);
      }
    }
    var i = new ArrayInput(inputMatrix);
    var table = i.divideData(4);
    var division1 = new int[][]{inputMatrix[0], inputMatrix[1], inputMatrix[2]};
    var division2 = new int[][]{inputMatrix[3], inputMatrix[4], inputMatrix[5]};
    var division3 = new int[][]{inputMatrix[6], inputMatrix[7]};
    var division4 = new int[][]{inputMatrix[8], inputMatrix[9]};
    assertTrue(matricesSame(table.get(0).data, division1)
        && matricesSame(table.get(1).data, division2)
        && matricesSame(table.get(2).data, division3)
        && matricesSame(table.get(3).data, division4));
  }",loop_control
j,"{
    var rows = 10;
    var columns = 10;
    var inputMatrix = new int[rows][columns];
    var rand = new Random();
    for (var i = 0; i < rows; i++) {
      for (var j = 0; j < columns; j++) {
        inputMatrix[i][j] = rand.nextInt(10);
      }
    }
    var i = new ArrayInput(inputMatrix);
    var table = i.divideData(4);
    var division1 = new int[][]{inputMatrix[0], inputMatrix[1], inputMatrix[2]};
    var division2 = new int[][]{inputMatrix[3], inputMatrix[4], inputMatrix[5]};
    var division3 = new int[][]{inputMatrix[6], inputMatrix[7]};
    var division4 = new int[][]{inputMatrix[8], inputMatrix[9]};
    assertTrue(matricesSame(table.get(0).data, division1)
        && matricesSame(table.get(1).data, division2)
        && matricesSame(table.get(2).data, division3)
        && matricesSame(table.get(3).data, division4));
  }",loop_control
i,"{
    //compares if 2 arrays have the same value
    if (a1.length != a2.length) {
      return false;
    } else {
      var answer = false;
      for (var i = 0; i < a1.length; i++) {
        if (a1[i] == a2[i]) {
          answer = true;
        } else {
          answer = false;
          break;
        }
      }
      return answer;
    }
  }",loop_control
i,"{
    //compares if 2 arrays have the same value
    if (a1.length != a2.length) {
      return false;
    } else {
      var answer = false;
      for (var i = 0; i < a1.length; i++) {
        if (a1[i] == a2[i]) {
          answer = true;
        } else {
          answer = false;
          break;
        }
      }
      return answer;
    }
  }",break_loop_control
i,"{
    if (m1.length != m2.length) {
      return false;
    } else {
      var answer = false;
      for (var i = 0; i < m1.length; i++) {
        if (arraysSame(m1[i], m2[i])) {
          answer = true;
        } else {
          answer = false;
          break;
        }
      }
      return answer;
    }
  }",loop_control
i,"{
    if (m1.length != m2.length) {
      return false;
    } else {
      var answer = false;
      for (var i = 0; i < m1.length; i++) {
        if (arraysSame(m1[i], m2[i])) {
          answer = true;
        } else {
          answer = false;
          break;
        }
      }
      return answer;
    }
  }",break_loop_control
i,"{
    var matrix = new int[rows][columns];
    for (var i = 0; i < rows; i++) {
      for (var j = 0; j < columns; j++) {
        //filling cells in matrix
        matrix[i][j] = RANDOM.nextInt(10);
      }
    }
    return matrix;
  }",loop_control
j,"{
    var matrix = new int[rows][columns];
    for (var i = 0; i < rows; i++) {
      for (var j = 0; j < columns; j++) {
        //filling cells in matrix
        matrix[i][j] = RANDOM.nextInt(10);
      }
    }
    return matrix;
  }",loop_control
ints,"{
    //prints out int[][]
    for (var ints : matrix) {
      for (var j = 0; j < matrix[0].length; j++) {
        LOGGER.info(ints[j] + "" "");
      }
      LOGGER.info("""");
    }
  }",iterator
j,"{
    //prints out int[][]
    for (var ints : matrix) {
      for (var j = 0; j < matrix[0].length; j++) {
        LOGGER.info(ints[j] + "" "");
      }
      LOGGER.info("""");
    }
  }",loop_control
i,"{
    if (this.data == null) {
      return null;
    } else {
      var divisions = makeDivisions(this.data, num);
      var result = new ArrayList<Input<int[][]>>(num);
      var rowsDone = 0; //number of rows divided so far
      for (var i = 0; i < num; i++) {
        var rows = divisions[i];
        if (rows != 0) {
          var divided = new int[rows][this.data[0].length];
          System.arraycopy(this.data, rowsDone, divided, 0, rows);
          rowsDone += rows;
          var dividedInput = new ArrayInput(divided);
          result.add(dividedInput);
        } else {
          break; //rest of divisions will also be 0
        }
      }
      return result;
    }
  }",loop_control
rows,"{
    if (this.data == null) {
      return null;
    } else {
      var divisions = makeDivisions(this.data, num);
      var result = new ArrayList<Input<int[][]>>(num);
      var rowsDone = 0; //number of rows divided so far
      for (var i = 0; i < num; i++) {
        var rows = divisions[i];
        if (rows != 0) {
          var divided = new int[rows][this.data[0].length];
          System.arraycopy(this.data, rowsDone, divided, 0, rows);
          rowsDone += rows;
          var dividedInput = new ArrayInput(divided);
          result.add(dividedInput);
        } else {
          break; //rest of divisions will also be 0
        }
      }
      return result;
    }
  }",break_loop_control
i,"{
    //number of rows in result matrix is equal to number of columns in input matrix and vice versa
    var arrayInput = (ArrayInput) this.getReceivedData();
    final var rows = arrayInput.data[0].length;
    final var cols = arrayInput.data.length;
    var resultData = new int[rows][cols];
    for (var i = 0; i < cols; i++) {
      for (var j = 0; j < rows; j++) {
        //flipping element positions along diagonal
        resultData[j][i] = arrayInput.data[i][j];
      }
    }
    return new ArrayResult(resultData);
  }",loop_control
j,"{
    //number of rows in result matrix is equal to number of columns in input matrix and vice versa
    var arrayInput = (ArrayInput) this.getReceivedData();
    final var rows = arrayInput.data[0].length;
    final var cols = arrayInput.data.length;
    var resultData = new int[rows][cols];
    for (var i = 0; i < cols; i++) {
      for (var j = 0; j < rows; j++) {
        //flipping element positions along diagonal
        resultData[j][i] = arrayInput.data[i][j];
      }
    }
    return new ArrayResult(resultData);
  }",loop_control
i,"{
    var dividedInput = input.divideData(numOfWorkers);
    if (dividedInput != null) {
      this.expectedNumResults = dividedInput.size();
      for (var i = 0; i < this.expectedNumResults; i++) {
        //ith division given to ith worker in this.workers
        this.workers.get(i).setReceivedData(this, dividedInput.get(i));
        this.workers.get(i).start();
      }
      for (var i = 0; i < this.expectedNumResults; i++) {
        try {
          this.workers.get(i).join();
        } catch (InterruptedException e) {
          System.err.println(""Error while executing thread"");
        }
      }
    }
  }",loop_control
elements,"{
    // number of rows in final result is number of rows in any of obtained results from workers
    var allResultData = this.getAllResultData();
    var rows = ((ArrayResult) allResultData.elements().nextElement()).data.length;
    var elements = allResultData.elements();
    var columns = 0; // columns = sum of number of columns in all results obtained from workers
    while (elements.hasMoreElements()) {
      columns += ((ArrayResult) elements.nextElement()).data[0].length;
    }
    var resultData = new int[rows][columns];
    var columnsDone = 0; //columns aggregated so far
    var workers = this.getWorkers();
    for (var i = 0; i < this.getExpectedNumResults(); i++) {
      //result obtained from ith worker
      var worker = workers.get(i);
      var workerId = worker.getWorkerId();
      var work = ((ArrayResult) allResultData.get(workerId)).data;
      for (var m = 0; m < work.length; m++) {
        //m = row number, n = columns number
        System.arraycopy(work[m], 0, resultData[m], columnsDone, work[0].length);
      }
      columnsDone += work[0].length;
    }
    return new ArrayResult(resultData);
  }",maybe_loop_control
i,"{
    // number of rows in final result is number of rows in any of obtained results from workers
    var allResultData = this.getAllResultData();
    var rows = ((ArrayResult) allResultData.elements().nextElement()).data.length;
    var elements = allResultData.elements();
    var columns = 0; // columns = sum of number of columns in all results obtained from workers
    while (elements.hasMoreElements()) {
      columns += ((ArrayResult) elements.nextElement()).data[0].length;
    }
    var resultData = new int[rows][columns];
    var columnsDone = 0; //columns aggregated so far
    var workers = this.getWorkers();
    for (var i = 0; i < this.getExpectedNumResults(); i++) {
      //result obtained from ith worker
      var worker = workers.get(i);
      var workerId = worker.getWorkerId();
      var work = ((ArrayResult) allResultData.get(workerId)).data;
      for (var m = 0; m < work.length; m++) {
        //m = row number, n = columns number
        System.arraycopy(work[m], 0, resultData[m], columnsDone, work[0].length);
      }
      columnsDone += work[0].length;
    }
    return new ArrayResult(resultData);
  }",loop_control
m,"{
    // number of rows in final result is number of rows in any of obtained results from workers
    var allResultData = this.getAllResultData();
    var rows = ((ArrayResult) allResultData.elements().nextElement()).data.length;
    var elements = allResultData.elements();
    var columns = 0; // columns = sum of number of columns in all results obtained from workers
    while (elements.hasMoreElements()) {
      columns += ((ArrayResult) elements.nextElement()).data[0].length;
    }
    var resultData = new int[rows][columns];
    var columnsDone = 0; //columns aggregated so far
    var workers = this.getWorkers();
    for (var i = 0; i < this.getExpectedNumResults(); i++) {
      //result obtained from ith worker
      var worker = workers.get(i);
      var workerId = worker.getWorkerId();
      var work = ((ArrayResult) allResultData.get(workerId)).data;
      for (var m = 0; m < work.length; m++) {
        //m = row number, n = columns number
        System.arraycopy(work[m], 0, resultData[m], columnsDone, work[0].length);
      }
      columnsDone += work[0].length;
    }
    return new ArrayResult(resultData);
  }",loop_control
i,"{
    var cp = new CellPool(10);
    var ht = new Hashtable<String, Boolean>();
    var parentTypes = 0;
    for (var i = 0; i < cp.randomCode.length; i++) {
      ht.putIfAbsent(cp.randomCode[i].name, true);
      if (cp.randomCode[i].name.equals(""fruit"") || cp.randomCode[i].name.equals(""candy"")) {
        parentTypes++;
      }
    }
    assertTrue(ht.size() == 5 && parentTypes == 0);
  }",loop_control
o,"{
    var parser = new JSONParser();
    var workingDirectory = new File("""").getAbsolutePath();
    var filePath = List.of(""src"", ""main"", ""java"", ""com"", ""iluwatar"", ""typeobject"", ""candy.json"");
    var absolutePath = workingDirectory + File.separator + String.join(File.separator, filePath);
    var jo = (JSONObject) parser.parse(new FileReader(absolutePath));
    var a = (JSONArray) jo.get(""candies"");
    for (var o : a) {
      var candy = (JSONObject) o;
      var name = (String) candy.get(""name"");
      var parentName = (String) candy.get(""parent"");
      var t = (String) candy.get(""type"");
      var type = Type.CRUSHABLE_CANDY;
      if (t.equals(""rewardFruit"")) {
        type = Type.REWARD_FRUIT;
      }
      var points = Integer.parseInt((String) candy.get(""points""));
      var c = new Candy(name, parentName, type, points);
      this.candies.put(name, c);
    }
    setParentAndPoints();
  }",iterator
e,"{
    for (var e = this.candies.keys(); e.hasMoreElements(); ) {
      var c = this.candies.get(e.nextElement());
      if (c.parentName == null) {
        c.parent = null;
      } else {
        c.parent = this.candies.get(c.parentName);
      }
      if (c.getPoints() == 0 && c.parent != null) {
        c.setPoints(c.parent.getPoints());
      }
    }
  }",maybe_loop_control
y,"{
    for (var y = this.positionY; y > 0; y--) {
      cellMatrix[y][this.positionX] = cellMatrix[y - 1][this.positionX];
      cellMatrix[y][this.positionX].positionY = y;
    }
    var newC = pool.getNewCell();
    cellMatrix[0][this.positionX] = newC;
    cellMatrix[0][this.positionX].positionX = this.positionX;
    cellMatrix[0][this.positionX].positionY = 0;
  }",loop_control
i,"{
    this.cells = new Cell[num][num];
    this.pool = pool;
    this.totalPoints = 0;
    for (var i = 0; i < num; i++) {
      for (var j = 0; j < num; j++) {
        this.cells[i][j] = this.pool.getNewCell();
        this.cells[i][j].positionX = j;
        this.cells[i][j].positionY = i;
      }
    }
  }",loop_control
j,"{
    this.cells = new Cell[num][num];
    this.pool = pool;
    this.totalPoints = 0;
    for (var i = 0; i < num; i++) {
      for (var j = 0; j < num; j++) {
        this.cells[i][j] = this.pool.getNewCell();
        this.cells[i][j].positionX = j;
        this.cells[i][j].positionY = i;
      }
    }
  }",loop_control
j,"{
    LOGGER.info("""");
    for (Cell[] cell : cells) {
      for (var j = 0; j < cells.length; j++) {
        var candyName = cell[j].candy.name;
        if (candyName.length() < 20) {
          var totalSpaces = 20 - candyName.length();
          LOGGER.info(numOfSpaces(totalSpaces / 2) + cell[j].candy.name
              + numOfSpaces(totalSpaces - totalSpaces / 2) + ""|"");
        } else {
          LOGGER.info(candyName + ""|"");
        }
      }
      LOGGER.info("""");
    }
    LOGGER.info("""");
  }",loop_control
cell,"{
    LOGGER.info("""");
    for (Cell[] cell : cells) {
      for (var j = 0; j < cells.length; j++) {
        var candyName = cell[j].candy.name;
        if (candyName.length() < 20) {
          var totalSpaces = 20 - candyName.length();
          LOGGER.info(numOfSpaces(totalSpaces / 2) + cell[j].candy.name
              + numOfSpaces(totalSpaces - totalSpaces / 2) + ""|"");
        } else {
          LOGGER.info(candyName + ""|"");
        }
      }
      LOGGER.info("""");
    }
    LOGGER.info("""");
  }",iterator
i,"{
    for (var i = 0; i < this.cells.length; i++) {
      if (this.cells[cells.length - 1][i].candy.getType().equals(Type.REWARD_FRUIT)) {
        return true;
      }
    }
    for (var i = 0; i < this.cells.length; i++) {
      for (var j = 0; j < this.cells.length; j++) {
        if (!this.cells[i][j].candy.getType().equals(Type.REWARD_FRUIT)) {
          var adj = adjacentCells(i, j);
          for (Cell cell : adj) {
            if (this.cells[i][j].candy.name.equals(cell.candy.name)) {
              return true;
            }
          }
        }
      }
    }
    return false;
  }",loop_control
j,"{
    for (var i = 0; i < this.cells.length; i++) {
      if (this.cells[cells.length - 1][i].candy.getType().equals(Type.REWARD_FRUIT)) {
        return true;
      }
    }
    for (var i = 0; i < this.cells.length; i++) {
      for (var j = 0; j < this.cells.length; j++) {
        if (!this.cells[i][j].candy.getType().equals(Type.REWARD_FRUIT)) {
          var adj = adjacentCells(i, j);
          for (Cell cell : adj) {
            if (this.cells[i][j].candy.name.equals(cell.candy.name)) {
              return true;
            }
          }
        }
      }
    }
    return false;
  }",loop_control
cell,"{
    for (var i = 0; i < this.cells.length; i++) {
      if (this.cells[cells.length - 1][i].candy.getType().equals(Type.REWARD_FRUIT)) {
        return true;
      }
    }
    for (var i = 0; i < this.cells.length; i++) {
      for (var j = 0; j < this.cells.length; j++) {
        if (!this.cells[i][j].candy.getType().equals(Type.REWARD_FRUIT)) {
          var adj = adjacentCells(i, j);
          for (Cell cell : adj) {
            if (this.cells[i][j].candy.name.equals(cell.candy.name)) {
              return true;
            }
          }
        }
      }
    }
    return false;
  }",iterator
end,"{
    var start = System.currentTimeMillis();
    var end = System.currentTimeMillis();
    while (end - start + timeSoFar < totalTime && continueRound()) {
      for (var i = 0; i < this.cells.length; i++) {
        var points = 0;
        var j = this.cells.length - 1;
        while (this.cells[j][i].candy.getType().equals(Type.REWARD_FRUIT)) {
          points = this.cells[j][i].candy.getPoints();
          this.cells[j][i].crush(pool, this.cells);
          handleChange(points);
        }
      }
      for (var i = 0; i < this.cells.length; i++) {
        var j = cells.length - 1;
        var points = 0;
        while (j > 0) {
          points = this.cells[j][i].interact(this.cells[j - 1][i], this.pool, this.cells);
          if (points != 0) {
            handleChange(points);
          } else {
            j = j - 1;
          }
        }
      }
      for (Cell[] cell : this.cells) {
        var j = 0;
        var points = 0;
        while (j < cells.length - 1) {
          points = cell[j].interact(cell[j + 1], this.pool, this.cells);
          if (points != 0) {
            handleChange(points);
          } else {
            j = j + 1;
          }
        }
      }
      end = System.currentTimeMillis();
    }
  }",loop_control
start,"{
    var start = System.currentTimeMillis();
    var end = System.currentTimeMillis();
    while (end - start + timeSoFar < totalTime && continueRound()) {
      for (var i = 0; i < this.cells.length; i++) {
        var points = 0;
        var j = this.cells.length - 1;
        while (this.cells[j][i].candy.getType().equals(Type.REWARD_FRUIT)) {
          points = this.cells[j][i].candy.getPoints();
          this.cells[j][i].crush(pool, this.cells);
          handleChange(points);
        }
      }
      for (var i = 0; i < this.cells.length; i++) {
        var j = cells.length - 1;
        var points = 0;
        while (j > 0) {
          points = this.cells[j][i].interact(this.cells[j - 1][i], this.pool, this.cells);
          if (points != 0) {
            handleChange(points);
          } else {
            j = j - 1;
          }
        }
      }
      for (Cell[] cell : this.cells) {
        var j = 0;
        var points = 0;
        while (j < cells.length - 1) {
          points = cell[j].interact(cell[j + 1], this.pool, this.cells);
          if (points != 0) {
            handleChange(points);
          } else {
            j = j + 1;
          }
        }
      }
      end = System.currentTimeMillis();
    }
  }",loop_control
i,"{
    var start = System.currentTimeMillis();
    var end = System.currentTimeMillis();
    while (end - start + timeSoFar < totalTime && continueRound()) {
      for (var i = 0; i < this.cells.length; i++) {
        var points = 0;
        var j = this.cells.length - 1;
        while (this.cells[j][i].candy.getType().equals(Type.REWARD_FRUIT)) {
          points = this.cells[j][i].candy.getPoints();
          this.cells[j][i].crush(pool, this.cells);
          handleChange(points);
        }
      }
      for (var i = 0; i < this.cells.length; i++) {
        var j = cells.length - 1;
        var points = 0;
        while (j > 0) {
          points = this.cells[j][i].interact(this.cells[j - 1][i], this.pool, this.cells);
          if (points != 0) {
            handleChange(points);
          } else {
            j = j - 1;
          }
        }
      }
      for (Cell[] cell : this.cells) {
        var j = 0;
        var points = 0;
        while (j < cells.length - 1) {
          points = cell[j].interact(cell[j + 1], this.pool, this.cells);
          if (points != 0) {
            handleChange(points);
          } else {
            j = j + 1;
          }
        }
      }
      end = System.currentTimeMillis();
    }
  }",loop_control
j,"{
    var start = System.currentTimeMillis();
    var end = System.currentTimeMillis();
    while (end - start + timeSoFar < totalTime && continueRound()) {
      for (var i = 0; i < this.cells.length; i++) {
        var points = 0;
        var j = this.cells.length - 1;
        while (this.cells[j][i].candy.getType().equals(Type.REWARD_FRUIT)) {
          points = this.cells[j][i].candy.getPoints();
          this.cells[j][i].crush(pool, this.cells);
          handleChange(points);
        }
      }
      for (var i = 0; i < this.cells.length; i++) {
        var j = cells.length - 1;
        var points = 0;
        while (j > 0) {
          points = this.cells[j][i].interact(this.cells[j - 1][i], this.pool, this.cells);
          if (points != 0) {
            handleChange(points);
          } else {
            j = j - 1;
          }
        }
      }
      for (Cell[] cell : this.cells) {
        var j = 0;
        var points = 0;
        while (j < cells.length - 1) {
          points = cell[j].interact(cell[j + 1], this.pool, this.cells);
          if (points != 0) {
            handleChange(points);
          } else {
            j = j + 1;
          }
        }
      }
      end = System.currentTimeMillis();
    }
  }",loop_control
cell,"{
    var start = System.currentTimeMillis();
    var end = System.currentTimeMillis();
    while (end - start + timeSoFar < totalTime && continueRound()) {
      for (var i = 0; i < this.cells.length; i++) {
        var points = 0;
        var j = this.cells.length - 1;
        while (this.cells[j][i].candy.getType().equals(Type.REWARD_FRUIT)) {
          points = this.cells[j][i].candy.getPoints();
          this.cells[j][i].crush(pool, this.cells);
          handleChange(points);
        }
      }
      for (var i = 0; i < this.cells.length; i++) {
        var j = cells.length - 1;
        var points = 0;
        while (j > 0) {
          points = this.cells[j][i].interact(this.cells[j - 1][i], this.pool, this.cells);
          if (points != 0) {
            handleChange(points);
          } else {
            j = j - 1;
          }
        }
      }
      for (Cell[] cell : this.cells) {
        var j = 0;
        var points = 0;
        while (j < cells.length - 1) {
          points = cell[j].interact(cell[j + 1], this.pool, this.cells);
          if (points != 0) {
            handleChange(points);
          } else {
            j = j + 1;
          }
        }
      }
      end = System.currentTimeMillis();
    }
  }",iterator
i,"{
    this.pool = new ArrayList<>(num);
    try {
      this.randomCode = assignRandomCandytypes();
    } catch (Exception e) {
      e.printStackTrace();
      //manually initialising this.randomCode
      this.randomCode = new Candy[5];
      randomCode[0] = new Candy(""cherry"", FRUIT, Type.REWARD_FRUIT, 20);
      randomCode[1] = new Candy(""mango"", FRUIT, Type.REWARD_FRUIT, 20);
      randomCode[2] = new Candy(""purple popsicle"", CANDY, Type.CRUSHABLE_CANDY, 10);
      randomCode[3] = new Candy(""green jellybean"", CANDY, Type.CRUSHABLE_CANDY, 10);
      randomCode[4] = new Candy(""orange gum"", CANDY, Type.CRUSHABLE_CANDY, 10);
    }
    for (int i = 0; i < num; i++) {
      var c = new Cell();
      c.candy = randomCode[RANDOM.nextInt(randomCode.length)];
      this.pool.add(c);
    }
    this.pointer = num - 1;
  }",loop_control
e,"{
    var jp = new JsonParser();
    jp.parse();
    var randomCode = new Candy[jp.candies.size() - 2]; //exclude generic types 'fruit' and 'candy'
    var i = 0;
    for (var e = jp.candies.keys(); e.hasMoreElements(); ) {
      var s = e.nextElement();
      if (!s.equals(FRUIT) && !s.equals(CANDY)) {
        //not generic
        randomCode[i] = jp.candies.get(s);
        i++;
      }
    }
    return randomCode;
  }",maybe_loop_control
arg,"{
    for (String arg : args) {
      if (arg.equals(USE_MONGO_DB)) {
        return true;
      }
    }
    return false;
  }",iterator
i,"{

    // defaults
    final var paramNumber = defaultParam(""number"", ec, 3);

    // validate
    if (paramNumber < 0 || paramNumber > names.size()) {
      throw new IllegalArgumentException(String.format(""number must be in range [0,%d)"",
          names.size()));
    }

    //
    // execute
    //
    ec.executeChild(this, new SimpleObjectsTearDown());

    for (var i = 0; i < paramNumber; i++) {
      final var fs = new SimpleObjectCreate().setName(names.get(i));
      ec.executeChild(this, fs.getName(), fs);
      simpleObjects.add(fs.getSimpleObject());
    }
  }",loop_control
letter,"{
    for (char letter : letters) {
      this.add(new Letter(letter));
    }
  }",iterator
name,"{
    for (final var name : NazgulName.values()) {
      final var nazgul = Nazgul.getInstance(name);
      assertNotNull(nazgul);
      assertSame(nazgul, Nazgul.getInstance(name));
      assertEquals(name, nazgul.getName());
    }
  }",iterator
weapon,"{
    var weaponsToBeInserted = context.get(UnitActions.INSERT.getActionValue());
    for (var weapon : weaponsToBeInserted) {
      LOGGER.info(""Inserting a new weapon {} to sales rack."", weapon.getName());
      weaponDatabase.insert(weapon);
    }
  }",iterator
weapon,"{
    var modifiedWeapons = context.get(UnitActions.MODIFY.getActionValue());
    for (var weapon : modifiedWeapons) {
      LOGGER.info(""Scheduling {} for modification work."", weapon.getName());
      weaponDatabase.modify(weapon);
    }
  }",iterator
weapon,"{
    var deletedWeapons = context.get(UnitActions.DELETE.getActionValue());
    for (var weapon : deletedWeapons) {
      LOGGER.info(""Scrapping {}."", weapon.getName());
      weaponDatabase.delete(weapon);
    }
  }",iterator
i,"{
    final var stew = new ImmutableStew(1, 2, 3, 4);
    final var expectedMessage = ""Mixing the immutable stew we find: 1 potatoes, ""
        + ""2 carrots, 3 meat and 4 peppers"";

    for (var i = 0; i < 20; i++) {
      stew.mix();
      assertEquals(expectedMessage, appender.getLastMessage());
    }

    assertEquals(20, appender.getLogSize());
  }",loop_control
i,"{
    var stew = new Stew(1, 2, 3, 4);
    var expectedMessage = ""Mixing the stew we find: 1 potatoes, 2 carrots, 3 meat and 4 peppers"";

    for (var i = 0; i < 20; i++) {
      stew.mix();
      assertEquals(expectedMessage, appender.getLastMessage());
    }

    assertEquals(20, appender.getLogSize());
  }",loop_control
dt,"{
    // Format date value as DD.MM.YYYY
    if (res == null || res.getDateList() == null || res.getDateList().size() == 0) {
      return null;
    }
    var returnList = new ArrayList<String>();

    for (var dt : res.getDateList()) {
      var cal = Calendar.getInstance();
      cal.setTime(dt);
      returnList.add(cal.get(Calendar.DAY_OF_MONTH) + "".""
          + cal.get(Calendar.MONTH) + "".""
          + cal.get(Calendar.YEAR)
      );
    }
    return returnList;
  }",iterator
i,"{
    // Create a callable
    var callableDf = new DateFormatCallable(""dd/MM/yyyy"", ""15/12/2015"");
    // start thread using the Callable instance
    var executor = Executors.newCachedThreadPool();
    var futureResult1 = executor.submit(callableDf);
    var futureResult2 = executor.submit(callableDf);
    var futureResult3 = executor.submit(callableDf);
    var futureResult4 = executor.submit(callableDf);
    try {
      result[0] = futureResult1.get();
      result[1] = futureResult2.get();
      result[2] = futureResult3.get();
      result[3] = futureResult4.get();
      for (var i = 0; i < result.length; i++) {
        createdDateValues[i] = convertDatesToString(result[i]);
      }
    } catch (Exception e) {
      fail(""Setup failed: "" + e);
    }
    executor.shutdown();
  }",loop_control
dt,"{
    // Format date value as DD.MM.YYYY
    if (res == null || res.getDateList() == null || res.getDateList().size() == 0) {
      return null;
    }
    var returnList = new StringArrayList();

    for (var dt : res.getDateList()) {
      var cal = Calendar.getInstance();
      cal.setTime(dt);
      returnList.add(cal.get(Calendar.DAY_OF_MONTH) + "".""
          + cal.get(Calendar.MONTH) + "".""
          + cal.get(Calendar.YEAR)
      );
    }
    return returnList;
  }",iterator
createdDateValue,"{
    for (var createdDateValue : createdDateValues) {
      assertEquals(expectedDateValues, createdDateValue);
    }
  }",iterator
value,"{
    for (var value : result) {
      assertEquals(expectedCounterDateValues, value.getDateList().size());
    }
  }",iterator
value,"{
    for (var value : result) {
      assertEquals(expectedCounterExceptions, value.getExceptionList().size());
    }
  }",iterator
value,"{
    var counterDateValues = 0;
    var counterExceptions = 0;

    // Create a callable
    var callableDf = new DateFormatCallable(""dd/MM/yyyy"", ""15/12/2015"");
    // start 4 threads, each using the same Callable instance
    var executor = Executors.newCachedThreadPool();

    var futureResult1 = executor.submit(callableDf);
    var futureResult2 = executor.submit(callableDf);
    var futureResult3 = executor.submit(callableDf);
    var futureResult4 = executor.submit(callableDf);
    try {
      var result = new Result[4];
      result[0] = futureResult1.get();
      result[1] = futureResult2.get();
      result[2] = futureResult3.get();
      result[3] = futureResult4.get();

      // Print results of thread executions (converted dates and raised exceptions)
      // and count them
      for (var value : result) {
        counterDateValues = counterDateValues + printAndCountDates(value);
        counterExceptions = counterExceptions + printAndCountExceptions(value);
      }

      // a correct run should deliver 20 times 15.12.2015
      // and a correct run shouldn't deliver any exception
      LOGGER.info(""The List dateList contains "" + counterDateValues + "" date values"");
      LOGGER.info(""The List exceptionList contains "" + counterExceptions + "" exceptions"");

    } catch (Exception e) {
      LOGGER.info(""Abnormal end of program. Program throws exception: "" + e);
    }
    executor.shutdown();
  }",iterator
dt,"{
    // a correct run should deliver 5 times 15.12.2015 per each thread
    var counter = 0;
    for (var dt : res.getDateList()) {
      counter++;
      var cal = Calendar.getInstance();
      cal.setTime(dt);
      // Formatted output of the date value: DD.MM.YYYY
      LOGGER.info(cal.get(Calendar.DAY_OF_MONTH) + "".""
          + cal.get(Calendar.MONTH) + "".""
          + cal.get(Calendar.YEAR)
      );
    }
    return counter;
  }",iterator
ex,"{
    // a correct run shouldn't deliver any exception
    var counter = 0;
    for (var ex : res.getExceptionList()) {
      counter++;
      LOGGER.info(ex);
    }
    return counter;
  }",iterator
message,"{
    final var messages = List.of(
        createMessage(""you"", ""Hello!""),
        createMessage(""me"", ""Hi!""),
        Message.POISON_PILL,
        createMessage(""late_for_the_party"", ""Hello? Anyone here?"")
    );

    final var queue = new SimpleMessageQueue(messages.size());
    for (final var message : messages) {
      queue.put(message);
    }

    new Consumer(""NSA"", queue).consume();

    assertTrue(appender.logContains(""Message [Hello!] from [you] received by [NSA]""));
    assertTrue(appender.logContains(""Message [Hi!] from [me] received by [NSA]""));
    assertTrue(appender.logContains(""Consumer NSA receive request to terminate.""));
  }",iterator
i,"{
    for (var i = 0; i < 10; i++) {
      assertEquals(this.expectedExecutionTime * i, this.factory.apply(i).getTimeMs());
    }
  }",loop_control
user,"{
    // get service
    var userService = new UserService();
    // use create service to add users
    for (var user: generateSampleUsers()) {
      var id = userService.createUser(user);
      LOGGER.info(""Add user"" + user + ""at"" + id + ""."");
    }
    // use list service to get users
    var users = userService.listUser();
    LOGGER.info(String.valueOf(users));
    // use get service to get a user
    var user = userService.getUser(1);
    LOGGER.info(String.valueOf(user));
    // change password of user 1
    user.setPassword(""new123"");
    // use update service to update user 1
    userService.updateUser(1, user);
    // use delete service to delete user 2
    userService.deleteUser(2);
    // close service
    userService.close();
  }",iterator
iterator,"{
    LOGGER.info(""list all users."");
    List<User> users = new ArrayList<>();
    try (var session = factory.openSession()) {
      var tx = session.beginTransaction();
      List<User> userIter = session.createQuery(""FROM User"").list();
      for (var iterator = userIter.iterator(); iterator.hasNext();) {
        users.add(iterator.next());
      }
      tx.commit();
    } catch (HibernateException e) {
      LOGGER.debug(""fail to get users"", e);
    }
    return users;
  }",iterator
anchor,"{
    // uses XPath to find list of html anchor tags with the class album in it
    var albumLinks = (List<HtmlAnchor>) page.getByXPath(""//tr[@class='album']//a"");
    for (var anchor : albumLinks) {
      if (anchor.getTextContent().equals(albumTitle)) {
        try {
          anchor.click();
          return new AlbumPage(webClient);
        } catch (IOException e) {
          e.printStackTrace();
        }
      }
    }
    throw new IllegalArgumentException(""No links with the album title: "" + albumTitle);
  }",iterator
anchor,"{
    // uses XPath to find list of html anchor tags with the class album in it
    var albumLinks = (List<HtmlAnchor>) page.getByXPath(""//tr[@class='album']//a"");
    for (var anchor : albumLinks) {
      if (anchor.getTextContent().equals(albumTitle)) {
        try {
          anchor.click();
          return new AlbumPage(webClient);
        } catch (IOException e) {
          LOGGER.error(""An error occured on selectAlbum"", e);
        }
      }
    }
    throw new IllegalArgumentException(""No links with the album title: "" + albumTitle);
  }",iterator
i,"{
    assertTimeout(ofMillis(5000), () -> {
      final var pool = new OliphauntPool();
      assertEquals(""Pool available=0 inUse=0"", pool.toString());

      final var expectedOliphaunt = pool.checkOut();
      assertEquals(""Pool available=0 inUse=1"", pool.toString());

      pool.checkIn(expectedOliphaunt);
      assertEquals(""Pool available=1 inUse=0"", pool.toString());

      for (int i = 0; i < 100; i++) {
        final var oliphaunt = pool.checkOut();
        assertEquals(""Pool available=0 inUse=1"", pool.toString());
        assertSame(expectedOliphaunt, oliphaunt);
        assertEquals(expectedOliphaunt.getId(), oliphaunt.getId());
        assertEquals(expectedOliphaunt.toString(), oliphaunt.toString());

        pool.checkIn(oliphaunt);
        assertEquals(""Pool available=1 inUse=0"", pool.toString());
      }
    });
  }",loop_control
i,"{
    // The target object for this example.
    var sword = new SwordOfAragorn();
    // Creation of creatures.
    List<Creature> creatures = new ArrayList<>();
    for (var i = 0; i < WORKERS; i++) {
      creatures.add(new Elf(String.format(""Elf %s"", i)));
      creatures.add(new Orc(String.format(""Orc %s"", i)));
      creatures.add(new Human(String.format(""Human %s"", i)));
    }
    int totalFiends = WORKERS * MULTIPLICATION_FACTOR;
    ExecutorService service = Executors.newFixedThreadPool(totalFiends);
    // Attach every creature and the sword is a Fiend to fight for the sword.
    for (var i = 0; i < totalFiends; i = i + MULTIPLICATION_FACTOR) {
      service.submit(new Feind(creatures.get(i), sword));
      service.submit(new Feind(creatures.get(i + 1), sword));
      service.submit(new Feind(creatures.get(i + 2), sword));
    }
    // Wait for program to terminate.
    try {
      if (!service.awaitTermination(WAIT_TIME, TimeUnit.SECONDS)) {
        LOGGER.info(""The master of the sword is now {}."", sword.getLocker().getName());
      }
    } catch (InterruptedException e) {
      LOGGER.error(e.getMessage());
      Thread.currentThread().interrupt();
    } finally {
      service.shutdown();
    }
  }",loop_control
lockable,"{
    LOGGER.info(""{} {} has been slayed!"", type, name);
    for (Lockable lockable : instruments) {
      lockable.unlock(this);
    }
    this.instruments.clear();
  }",iterator
id,"{
    // admin resets the lottery
    administration.resetLottery();
    assertEquals(0, administration.getAllSubmittedTickets().size());

    // players submit the lottery tickets
    var ticket1 = service.submitTicket(LotteryTestUtils.createLotteryTicket(""cvt@bbb.com"",
        ""123-12312"", ""+32425255"", Set.of(1, 2, 3, 4)));
    assertTrue(ticket1.isPresent());
    var ticket2 = service.submitTicket(LotteryTestUtils.createLotteryTicket(""ant@bac.com"",
        ""123-12312"", ""+32423455"", Set.of(11, 12, 13, 14)));
    assertTrue(ticket2.isPresent());
    var ticket3 = service.submitTicket(LotteryTestUtils.createLotteryTicket(""arg@boo.com"",
        ""123-12312"", ""+32421255"", Set.of(6, 8, 13, 19)));
    assertTrue(ticket3.isPresent());
    assertEquals(3, administration.getAllSubmittedTickets().size());

    // perform lottery
    var winningNumbers = administration.performLottery();

    // cheat a bit for testing sake, use winning numbers to submit another ticket
    var ticket4 = service.submitTicket(LotteryTestUtils.createLotteryTicket(""lucky@orb.com"",
        ""123-12312"", ""+12421255"", winningNumbers.getNumbers()));
    assertTrue(ticket4.isPresent());
    assertEquals(4, administration.getAllSubmittedTickets().size());

    // check winners
    var tickets = administration.getAllSubmittedTickets();
    for (var id : tickets.keySet()) {
      var checkResult = service.checkTicketForPrize(id, winningNumbers);
      assertNotEquals(CheckResult.TICKET_NOT_SUBMITTED, checkResult.getResult());
      if (checkResult.getResult().equals(CheckResult.WIN_PRIZE)) {
        assertTrue(checkResult.getPrizeAmount() > 0);
      } else {
        assertEquals(0, checkResult.getPrizeAmount());
      }
    }

    // check another ticket that has not been submitted
    var checkResult = service.checkTicketForPrize(new LotteryTicketId(), winningNumbers);
    assertEquals(CheckResult.TICKET_NOT_SUBMITTED, checkResult.getResult());
    assertEquals(0, checkResult.getPrizeAmount());
  }",iterator
i,"{
    for (var i = 0; i < numTickets; i++) {
      var randomPlayerDetails = getRandomPlayerDetails();
      var lotteryNumbers = LotteryNumbers.createRandom();
      var lotteryTicketId = new LotteryTicketId();
      var ticket = new LotteryTicket(lotteryTicketId, randomPlayerDetails, lotteryNumbers);
      lotteryService.submitTicket(ticket);
    }
  }",loop_control
id,"{
    var numbers = LotteryNumbers.createRandom();
    var tickets = getAllSubmittedTickets();
    for (var id : tickets.keySet()) {
      var lotteryTicket = tickets.get(id);
      var playerDetails = lotteryTicket.getPlayerDetails();
      var playerAccount = playerDetails.getBankAccount();
      var result = LotteryUtils.checkTicketForPrize(repository, id, numbers).getResult();
      if (result == LotteryTicketCheckResult.CheckResult.WIN_PRIZE) {
        if (wireTransfers.transferFunds(PRIZE_AMOUNT, SERVICE_BANK_ACCOUNT, playerAccount)) {
          notifications.ticketWon(playerDetails, PRIZE_AMOUNT);
        } else {
          notifications.prizeError(playerDetails, PRIZE_AMOUNT);
        }
      } else if (result == LotteryTicketCheckResult.CheckResult.NO_PRIZE) {
        notifications.ticketDidNotWin(playerDetails);
      }
    }
    return numbers;
  }",iterator
i,"{
    //Check if there is selected text
    if (editor.getCurrentTab().getSelectedText() != null) {
      String selection = editor.getCurrentTab().getSelectedText();
      char[] stuff = selection.toCharArray();
      // Randomly swap a bunch of characters in the text
      for (int i = 0; i < stuff.length / 10; i++) {
        int a = (int) (Math.random() * stuff.length);
        int b = (int) (Math.random() * stuff.length);
        if (stuff[a] == '\n' || stuff[b] == '\n') {
          continue;  // skip newline characters
        }
        stuff[a] = selection.charAt(b);
        stuff[b] = selection.charAt(a);
      }
      editor.getCurrentTab().setSelectedText(new String(stuff));
      editor.statusNotice(""Now that feels better, doesn't it?"");

    } else {
      //When there is no selected text
     editor.statusError(""No selection, no dice."");
    }
  }",loop_control
warning,"{

    if (uploader == null)
      uploader = getUploaderByPreferences(noUploadPort);

    boolean success = false;

    if (uploader.requiresAuthorization() && !PreferencesData.has(uploader.getAuthorizationKey())) {
      BaseNoGui.showError(tr(""Authorization required""),
        tr(""No authorization data found""), null);
    }

    boolean useNewWarningsAccumulator = false;
    if (warningsAccumulator == null) {
      warningsAccumulator = new LinkedList<>();
      useNewWarningsAccumulator = true;
    }

    try {
      success = uploader.uploadUsingPreferences(data.getFolder(), data.getBuildPath().getAbsolutePath(), suggestedClassName, usingProgrammer, warningsAccumulator);
    } finally {
      if (uploader.requiresAuthorization() && !success) {
        PreferencesData.remove(uploader.getAuthorizationKey());
      }
    }

    if (useNewWarningsAccumulator) {
      for (String warning : warningsAccumulator) {
        System.out.print(tr(""Warning""));
        System.out.print("": "");
        System.out.println(warning);
      }
    }

    return success;
  }",iterator
progressListener,"{
    if (s.startsWith(""===info ||| Progress"") || s.startsWith(""===Progress"")) {
      Map<String, Object> parsedMessage = parser.parse(s);
      Object[] args = (Object[]) parsedMessage.get(""args"");
      for (CompilerProgressListener progressListener : progressListeners){
        progressListener.progress(Double.valueOf(args[0].toString()).intValue());
      }
      return;
    }

    if (parent != null) {
      parent.message(s);
    }
  }",iterator
entry,"{
    List<String> cmd = new ArrayList<>();
    cmd.add(BaseNoGui.getContentFile(""arduino-builder"").getAbsolutePath());
    cmd.add(action.value);
    cmd.add(""-logger=machine"");

    File installedPackagesFolder = new File(BaseNoGui.getSettingsFolder(), ""packages"");

    addPathFlagIfPathExists(cmd, ""-hardware"", BaseNoGui.getHardwareFolder());
    addPathFlagIfPathExists(cmd, ""-hardware"", installedPackagesFolder);
    addPathFlagIfPathExists(cmd, ""-hardware"", BaseNoGui.getSketchbookHardwareFolder());

    addPathFlagIfPathExists(cmd, ""-tools"", BaseNoGui.getContentFile(""tools-builder""));
    addPathFlagIfPathExists(cmd, ""-tools"", Paths.get(BaseNoGui.getHardwarePath(), ""tools"", ""avr"").toFile());
    addPathFlagIfPathExists(cmd, ""-tools"", installedPackagesFolder);

    addPathFlagIfPathExists(cmd, ""-built-in-libraries"", BaseNoGui.getContentFile(""libraries""));
    addPathFlagIfPathExists(cmd, ""-libraries"", BaseNoGui.getSketchbookLibrariesFolder().folder);

    String fqbn = Stream.of(aPackage.getId(), platform.getId(), board.getId(), boardOptions(board)).filter(s -> !s.isEmpty()).collect(Collectors.joining("":""));
    cmd.add(""-fqbn="" + fqbn);

    if (!"""".equals(vidpid)) {
      cmd.add(""-vid-pid="" + vidpid);
    }

    cmd.add(""-ide-version="" + BaseNoGui.REVISION);
    cmd.add(""-build-path"");
    cmd.add(buildPath);
    cmd.add(""-warnings="" + PreferencesData.get(""compiler.warning_level""));

    if (PreferencesData.getBoolean(""compiler.cache_core"") == true && buildCache != null) {
      cmd.add(""-build-cache"");
      cmd.add(buildCache.getAbsolutePath());
    }

    PreferencesData.getMap()
      .subTree(""runtime.build_properties_custom"")
      .entrySet()
      .stream()
      .forEach(kv -> cmd.add(""-prefs="" + kv.getKey() + ""="" + kv.getValue()));

    cmd.add(""-prefs=build.warn_data_percentage="" + PreferencesData.get(""build.warn_data_percentage""));

    for (Map.Entry<String, String> entry : BaseNoGui.getBoardPreferences().entrySet()) {
        if (entry.getKey().startsWith(""runtime.tools"")) {
          cmd.add(""-prefs="" + entry.getKey() + ""="" + entry.getValue());
        }
    }

    //commandLine.addArgument(""-debug-level=10"", false);

    if (verbose) {
      cmd.add(""-verbose"");
    }

    cmd.add(pathToSketch.getAbsolutePath());

    if (verbose) {
      System.out.println(StringUtils.join(cmd, ' '));
    }

    int result;
    try {
      Process proc = ProcessUtils.exec(cmd.toArray(new String[0]));
      MessageSiphon in = new MessageSiphon(proc.getInputStream(), (msg) -> {
        try {
          outStream.write(msg.getBytes());
        } catch (Exception e) {
          exception = new RunnerException(e);
        }
      });
      MessageSiphon err = new MessageSiphon(proc.getErrorStream(), (msg) -> {
        try {
          errStream.write(msg.getBytes());
        } catch (Exception e) {
          exception = new RunnerException(e);
        }
      });

      in.join();
      err.join();
      result = proc.waitFor();
    } catch (Exception e) {
      throw new RunnerException(e);
    }

    if (exception != null)
      throw exception;

    if (result > 1) {
      System.err.println(I18n.format(tr(""{0} returned {1}""), cmd.get(0), result));
    }

    if (result != 0) {
      RunnerException re = new RunnerException(I18n.format(tr(""Error compiling for board {0}.""), board.getName()));
      re.hideStackTrace();
      throw re;
    }
  }",iterator
i,"{
    List<String> compiledSketches = new ArrayList<>(prefs.subTree(""recipe.output.tmp_file"", 1).values());
    List<String> copyOfCompiledSketches = new ArrayList<>(prefs.subTree(""recipe.output.save_file"", 1).values());

    if (isExportCompiledSketchSupported(compiledSketches, copyOfCompiledSketches, prefs)) {
      System.err.println(tr(""Warning: This core does not support exporting sketches. Please consider upgrading it or contacting its author""));
      return;
    }

    PreferencesMap dict = new PreferencesMap(prefs);
    dict.put(""ide_version"", """" + BaseNoGui.REVISION);
    PreferencesMap withBootloaderDict = new PreferencesMap(dict);
    dict.put(""build.project_name"", dict.get(""build.project_name"") + "".with_bootloader"");

    if (!compiledSketches.isEmpty()) {
      for (int i = 0; i < compiledSketches.size(); i++) {
        saveHex(compiledSketches.get(i), copyOfCompiledSketches.get(i), dict);
        saveHex(compiledSketches.get(i), copyOfCompiledSketches.get(i), withBootloaderDict);
      }
    } else {
      try {
        saveHex(prefs.getOrExcept(""recipe.output.tmp_file""), prefs.getOrExcept(""recipe.output.save_file""), dict);
        saveHex(prefs.getOrExcept(""recipe.output.tmp_file""), prefs.getOrExcept(""recipe.output.save_file""), withBootloaderDict);
      } catch (PreferencesMapException e) {
        throw new RunnerException(e);
      }
    }
  }",loop_control
recipe,"{
    List<String> patterns = prefs.keySet().stream().filter(key -> key.startsWith(""recipe."" + recipeClass) && key.endsWith("".pattern"")).collect(Collectors.toList());
    Collections.sort(patterns);
    for (String recipe : patterns) {
      runRecipe(recipe, prefs);
    }
  }",iterator
string,"{
    // eliminate any empty array entries
    List<String> stringList = new ArrayList<>();
    for (String string : command) {
      string = string.trim();
      if (string.length() != 0)
        stringList.add(string);
    }
    command = stringList.toArray(new String[stringList.size()]);
    if (command.length == 0)
      return;

    if (verbose) {
      for (String c : command)
        System.out.print(c + "" "");
      System.out.println();
    }

    DefaultExecutor executor = new DefaultExecutor();
    executor.setStreamHandler(new PumpStreamHandler() {

      @Override
      protected Thread createPump(InputStream is, OutputStream os, boolean closeWhenExhausted) {
        final Thread result = new Thread(new MyStreamPumper(is, Compiler.this));
        result.setName(""MyStreamPumper Thread"");
        result.setDaemon(true);
        return result;

      }
    });

    CommandLine commandLine = new DoubleQuotedArgumentsOnWindowsCommandLine(command[0]);
    for (int i = 1; i < command.length; i++) {
      commandLine.addArgument(command[i], false);
    }

    int result;
    executor.setExitValues(null);
    try {
      result = executor.execute(commandLine);
    } catch (IOException e) {
      RunnerException re = new RunnerException(e.getMessage());
      re.hideStackTrace();
      throw re;
    }
    executor.setExitValues(new int[0]);

    // an error was queued up by message(), barf this back to compile(),
    // which will barf it back to Editor. if you're having trouble
    // discerning the imagery, consider how cows regurgitate their food
    // to digest it, and the fact that they have five stomaches.
    //
    //System.out.println(""throwing up "" + exception);
    if (exception != null)
      throw exception;

    if (result > 1) {
      // a failure in the tool (e.g. unable to locate a sub-executable)
      System.err
        .println(I18n.format(tr(""{0} returned {1}""), command[0], result));
    }

    if (result != 0) {
      RunnerException re = new RunnerException(tr(""Error compiling.""));
      re.hideStackTrace();
      throw re;
    }
  }",iterator
c,"{
    // eliminate any empty array entries
    List<String> stringList = new ArrayList<>();
    for (String string : command) {
      string = string.trim();
      if (string.length() != 0)
        stringList.add(string);
    }
    command = stringList.toArray(new String[stringList.size()]);
    if (command.length == 0)
      return;

    if (verbose) {
      for (String c : command)
        System.out.print(c + "" "");
      System.out.println();
    }

    DefaultExecutor executor = new DefaultExecutor();
    executor.setStreamHandler(new PumpStreamHandler() {

      @Override
      protected Thread createPump(InputStream is, OutputStream os, boolean closeWhenExhausted) {
        final Thread result = new Thread(new MyStreamPumper(is, Compiler.this));
        result.setName(""MyStreamPumper Thread"");
        result.setDaemon(true);
        return result;

      }
    });

    CommandLine commandLine = new DoubleQuotedArgumentsOnWindowsCommandLine(command[0]);
    for (int i = 1; i < command.length; i++) {
      commandLine.addArgument(command[i], false);
    }

    int result;
    executor.setExitValues(null);
    try {
      result = executor.execute(commandLine);
    } catch (IOException e) {
      RunnerException re = new RunnerException(e.getMessage());
      re.hideStackTrace();
      throw re;
    }
    executor.setExitValues(new int[0]);

    // an error was queued up by message(), barf this back to compile(),
    // which will barf it back to Editor. if you're having trouble
    // discerning the imagery, consider how cows regurgitate their food
    // to digest it, and the fact that they have five stomaches.
    //
    //System.out.println(""throwing up "" + exception);
    if (exception != null)
      throw exception;

    if (result > 1) {
      // a failure in the tool (e.g. unable to locate a sub-executable)
      System.err
        .println(I18n.format(tr(""{0} returned {1}""), command[0], result));
    }

    if (result != 0) {
      RunnerException re = new RunnerException(tr(""Error compiling.""));
      re.hideStackTrace();
      throw re;
    }
  }",iterator
i,"{
    // eliminate any empty array entries
    List<String> stringList = new ArrayList<>();
    for (String string : command) {
      string = string.trim();
      if (string.length() != 0)
        stringList.add(string);
    }
    command = stringList.toArray(new String[stringList.size()]);
    if (command.length == 0)
      return;

    if (verbose) {
      for (String c : command)
        System.out.print(c + "" "");
      System.out.println();
    }

    DefaultExecutor executor = new DefaultExecutor();
    executor.setStreamHandler(new PumpStreamHandler() {

      @Override
      protected Thread createPump(InputStream is, OutputStream os, boolean closeWhenExhausted) {
        final Thread result = new Thread(new MyStreamPumper(is, Compiler.this));
        result.setName(""MyStreamPumper Thread"");
        result.setDaemon(true);
        return result;

      }
    });

    CommandLine commandLine = new DoubleQuotedArgumentsOnWindowsCommandLine(command[0]);
    for (int i = 1; i < command.length; i++) {
      commandLine.addArgument(command[i], false);
    }

    int result;
    executor.setExitValues(null);
    try {
      result = executor.execute(commandLine);
    } catch (IOException e) {
      RunnerException re = new RunnerException(e.getMessage());
      re.hideStackTrace();
      throw re;
    }
    executor.setExitValues(new int[0]);

    // an error was queued up by message(), barf this back to compile(),
    // which will barf it back to Editor. if you're having trouble
    // discerning the imagery, consider how cows regurgitate their food
    // to digest it, and the fact that they have five stomaches.
    //
    //System.out.println(""throwing up "" + exception);
    if (exception != null)
      throw exception;

    if (result > 1) {
      // a failure in the tool (e.g. unable to locate a sub-executable)
      System.err
        .println(I18n.format(tr(""{0} returned {1}""), command[0], result));
    }

    if (result != 0) {
      RunnerException re = new RunnerException(tr(""Error compiling.""));
      re.hideStackTrace();
      throw re;
    }
  }",loop_control
file,"{
    for (SketchFile file : sketch.getFiles()) {
      if (new File(fileName).getName().equals(file.getFileName())) {
        return new RunnerException(message, file, line, col);
      }
    }
    return null;
  }",iterator
file,"{
    boolean preserveTempFiles = PreferencesData.getBoolean(""runtime.preserve.temp.files"");
    if (preserveTempFiles) {
      return;
    }
    List<File> copyOfFiles;
    synchronized (this) {
      copyOfFiles = new LinkedList<>(files);
    }
    Collections.reverse(copyOfFiles);
    for (File file : copyOfFiles) {
      if (file.exists() && file.canWrite()) {
        FileUtils.recursiveDelete(file);
      }
    }
  }",iterator
c,"{
    // Skip empty commands
    if (command == null || command.length == 0)
      return true;

    notFoundError = false;
    int result = -1;

    try {
      if (verbose) {
        for (String c : command)
          System.out.print(c + "" "");
        System.out.println();
      }
      Process process = ProcessUtils.exec(command);
      programmerPid = process;
      new MessageSiphon(process.getInputStream(), this, 100);
      new MessageSiphon(process.getErrorStream(), this, 100);

      // wait for the process to finish, but not forever
      // kill the flasher process after 5 minutes to avoid 100% cpu spinning
      if (!process.waitFor(5, TimeUnit.MINUTES)) {
        process.destroyForcibly();
      }
      if (!process.isAlive()) {
        result = process.exitValue();
      } else {
        result = 0;
      }
    } catch (Exception e) {
      e.printStackTrace();
    }

    return result == 0;
  }",iterator
targetPackage,"{
    if (identificationPrefs == null || identificationPrefs.isEmpty()) return null;
    for (TargetPackage targetPackage : BaseNoGui.packages.values()) {
      for (TargetPlatform targetPlatform : targetPackage.getPlatforms().values()) {
        for (TargetBoard board : targetPlatform.getBoards().values()) {
          if (matchesBoard(board)) {
            setBoardName(board.getName());
            return board;
          }
        }
      }
    }
    return null;
  }",iterator
targetPlatform,"{
    if (identificationPrefs == null || identificationPrefs.isEmpty()) return null;
    for (TargetPackage targetPackage : BaseNoGui.packages.values()) {
      for (TargetPlatform targetPlatform : targetPackage.getPlatforms().values()) {
        for (TargetBoard board : targetPlatform.getBoards().values()) {
          if (matchesBoard(board)) {
            setBoardName(board.getName());
            return board;
          }
        }
      }
    }
    return null;
  }",iterator
board,"{
    if (identificationPrefs == null || identificationPrefs.isEmpty()) return null;
    for (TargetPackage targetPackage : BaseNoGui.packages.values()) {
      for (TargetPlatform targetPlatform : targetPackage.getPlatforms().values()) {
        for (TargetBoard board : targetPlatform.getBoards().values()) {
          if (matchesBoard(board)) {
            setBoardName(board.getName());
            return board;
          }
        }
      }
    }
    return null;
  }",iterator
board,"{
    if (identificationPrefs == null || identificationPrefs.isEmpty()) return null;
    for (TargetPackage targetPackage : BaseNoGui.packages.values()) {
      for (TargetPlatform targetPlatform : targetPackage.getPlatforms().values()) {
        for (TargetBoard board : targetPlatform.getBoards().values()) {
          if (matchesBoard(board)) {
            setBoardName(board.getName());
            return board;
          }
        }
      }
    }
    return null;
  }",break_loop_control
prop,"{
    PreferencesMap identificationProps = getIdentificationPrefs();
    PreferencesMap boardProps = board.getPreferences();

    String wildMatcher = identificationProps.get(""."");
    if (wildMatcher != null) {
      if (wildMatcher.equals(board.getId())) {
        return true;
      }
      if (wildMatcher.equals(board.getFQBN())) {
        return true;
      }
    }

    // Identification properties are defined in boards.txt with a "".N"" suffix
    // for example:
    //
    // uno.name=Arduino/Genuino Uno
    // uno.vid.0=0x2341
    // uno.pid.0=0x0043
    // uno.vid.1=0x2341
    // uno.pid.1=0x0001
    // uno.vid.2=0x2A03
    // uno.pid.2=0x0043
    // uno.vid.3=0x2341
    // uno.pid.3=0x0243
    //
    // so we must search starting from suffix "".0"" and increasing until we
    // found a match or the board has no more identification properties defined

    for (int suffix = 0;; suffix++) {
      boolean found = true;
      for (String prop : identificationProps.keySet()) {
        String value = identificationProps.get(prop);
        prop += ""."" + suffix;
        if (!boardProps.containsKey(prop)) {
          return false;
        }
        if (!value.equalsIgnoreCase(boardProps.get(prop))) {
          found = false;
          break;
        }
      }
      if (found) {
        return true;
      }
    }
  }",iterator
value,"{
    PreferencesMap identificationProps = getIdentificationPrefs();
    PreferencesMap boardProps = board.getPreferences();

    String wildMatcher = identificationProps.get(""."");
    if (wildMatcher != null) {
      if (wildMatcher.equals(board.getId())) {
        return true;
      }
      if (wildMatcher.equals(board.getFQBN())) {
        return true;
      }
    }

    // Identification properties are defined in boards.txt with a "".N"" suffix
    // for example:
    //
    // uno.name=Arduino/Genuino Uno
    // uno.vid.0=0x2341
    // uno.pid.0=0x0043
    // uno.vid.1=0x2341
    // uno.pid.1=0x0001
    // uno.vid.2=0x2A03
    // uno.pid.2=0x0043
    // uno.vid.3=0x2341
    // uno.pid.3=0x0243
    //
    // so we must search starting from suffix "".0"" and increasing until we
    // found a match or the board has no more identification properties defined

    for (int suffix = 0;; suffix++) {
      boolean found = true;
      for (String prop : identificationProps.keySet()) {
        String value = identificationProps.get(prop);
        prop += ""."" + suffix;
        if (!boardProps.containsKey(prop)) {
          return false;
        }
        if (!value.equalsIgnoreCase(boardProps.get(prop))) {
          found = false;
          break;
        }
      }
      if (found) {
        return true;
      }
    }
  }",break_loop_control
found,"{
    PreferencesMap identificationProps = getIdentificationPrefs();
    PreferencesMap boardProps = board.getPreferences();

    String wildMatcher = identificationProps.get(""."");
    if (wildMatcher != null) {
      if (wildMatcher.equals(board.getId())) {
        return true;
      }
      if (wildMatcher.equals(board.getFQBN())) {
        return true;
      }
    }

    // Identification properties are defined in boards.txt with a "".N"" suffix
    // for example:
    //
    // uno.name=Arduino/Genuino Uno
    // uno.vid.0=0x2341
    // uno.pid.0=0x0043
    // uno.vid.1=0x2341
    // uno.pid.1=0x0001
    // uno.vid.2=0x2A03
    // uno.pid.2=0x0043
    // uno.vid.3=0x2341
    // uno.pid.3=0x0243
    //
    // so we must search starting from suffix "".0"" and increasing until we
    // found a match or the board has no more identification properties defined

    for (int suffix = 0;; suffix++) {
      boolean found = true;
      for (String prop : identificationProps.keySet()) {
        String value = identificationProps.get(prop);
        prop += ""."" + suffix;
        if (!boardProps.containsKey(prop)) {
          return false;
        }
        if (!value.equalsIgnoreCase(boardProps.get(prop))) {
          found = false;
          break;
        }
      }
      if (found) {
        return true;
      }
    }
  }",break_loop_control
boardProps,"{
    PreferencesMap identificationProps = getIdentificationPrefs();
    PreferencesMap boardProps = board.getPreferences();

    String wildMatcher = identificationProps.get(""."");
    if (wildMatcher != null) {
      if (wildMatcher.equals(board.getId())) {
        return true;
      }
      if (wildMatcher.equals(board.getFQBN())) {
        return true;
      }
    }

    // Identification properties are defined in boards.txt with a "".N"" suffix
    // for example:
    //
    // uno.name=Arduino/Genuino Uno
    // uno.vid.0=0x2341
    // uno.pid.0=0x0043
    // uno.vid.1=0x2341
    // uno.pid.1=0x0001
    // uno.vid.2=0x2A03
    // uno.pid.2=0x0043
    // uno.vid.3=0x2341
    // uno.pid.3=0x0243
    //
    // so we must search starting from suffix "".0"" and increasing until we
    // found a match or the board has no more identification properties defined

    for (int suffix = 0;; suffix++) {
      boolean found = true;
      for (String prop : identificationProps.keySet()) {
        String value = identificationProps.get(prop);
        prop += ""."" + suffix;
        if (!boardProps.containsKey(prop)) {
          return false;
        }
        if (!value.equalsIgnoreCase(boardProps.get(prop))) {
          found = false;
          break;
        }
      }
      if (found) {
        return true;
      }
    }
  }",break_loop_control
targetPackage,"{
//    this.packages = packages;

    discoverers = new ArrayList<>();
    discoverers.add(serialDiscoverer);
    discoverers.add(networkDiscoverer);

    // Search for discoveries in installed packages
    for (TargetPackage targetPackage : packages.values()) {
      for (TargetPlatform platform: targetPackage.getPlatforms().values()) {
        //System.out.println(""installed: ""+platform);
        PreferencesMap prefs = platform.getPreferences().subTree(""discovery"");
        PreferencesMap pathPrefs = new PreferencesMap();
        File platformFolder = platform.getFolder();
        pathPrefs.put(""runtime.platform.path"", platformFolder.getAbsolutePath());
        pathPrefs.put(""runtime.hardware.path"", platformFolder.getParentFile().getAbsolutePath());
        for (String discoveryName : prefs.firstLevelMap().keySet()) {
          PreferencesMap discoveryPrefs = prefs.subTree(discoveryName);

          String pattern = discoveryPrefs.get(""pattern"");
          if (pattern == null) {
            System.out.println(format(tr(""No recipes defined for discovery '{0}'""),discoveryName));
            continue;
          }
          try {
            if (PreferencesData.getBoolean(""discovery.debug"")) {
              System.out.println(""found discovery: "" + discoveryName + "" -> "" + pattern);
              System.out.println(""with pathnames -> "" + pathPrefs);
              System.out.println(""with preferencess -> "" + discoveryPrefs);
            }
            pattern = StringReplacer.replaceFromMapping(pattern, PreferencesData.getMap());
            pattern = StringReplacer.replaceFromMapping(pattern, pathPrefs);
            String[] cmd = StringReplacer.formatAndSplit(pattern, discoveryPrefs);
            discoverers.add(new PluggableDiscovery(discoveryName, cmd));
          } catch (Exception e) {
            if (PreferencesData.getBoolean(""discovery.debug"")) {
              System.out.println(format(tr(""Could not start discovery '{0}': {1}""), discoveryName, e.getMessage()));
            }
          }
        }
      }
    }

    // Start all discoverers
    for (Discovery d : discoverers) {
      try {
        new Thread(d).start();
      } catch (Exception e) {
        System.err.println(tr(""Error starting discovery method: "") + d.toString());
        e.printStackTrace();
      }
    }

    Thread closeHook = new Thread(() -> {
      for (Discovery d : discoverers) {
        try {
          d.stop();
        } catch (Exception e) {
          e.printStackTrace(); //just printing as the JVM is terminating
        }
      }
    });
    closeHook.setName(""DiscoveryManager closeHook"");
    Runtime.getRuntime().addShutdownHook(closeHook);
  }",iterator
platform,"{
//    this.packages = packages;

    discoverers = new ArrayList<>();
    discoverers.add(serialDiscoverer);
    discoverers.add(networkDiscoverer);

    // Search for discoveries in installed packages
    for (TargetPackage targetPackage : packages.values()) {
      for (TargetPlatform platform: targetPackage.getPlatforms().values()) {
        //System.out.println(""installed: ""+platform);
        PreferencesMap prefs = platform.getPreferences().subTree(""discovery"");
        PreferencesMap pathPrefs = new PreferencesMap();
        File platformFolder = platform.getFolder();
        pathPrefs.put(""runtime.platform.path"", platformFolder.getAbsolutePath());
        pathPrefs.put(""runtime.hardware.path"", platformFolder.getParentFile().getAbsolutePath());
        for (String discoveryName : prefs.firstLevelMap().keySet()) {
          PreferencesMap discoveryPrefs = prefs.subTree(discoveryName);

          String pattern = discoveryPrefs.get(""pattern"");
          if (pattern == null) {
            System.out.println(format(tr(""No recipes defined for discovery '{0}'""),discoveryName));
            continue;
          }
          try {
            if (PreferencesData.getBoolean(""discovery.debug"")) {
              System.out.println(""found discovery: "" + discoveryName + "" -> "" + pattern);
              System.out.println(""with pathnames -> "" + pathPrefs);
              System.out.println(""with preferencess -> "" + discoveryPrefs);
            }
            pattern = StringReplacer.replaceFromMapping(pattern, PreferencesData.getMap());
            pattern = StringReplacer.replaceFromMapping(pattern, pathPrefs);
            String[] cmd = StringReplacer.formatAndSplit(pattern, discoveryPrefs);
            discoverers.add(new PluggableDiscovery(discoveryName, cmd));
          } catch (Exception e) {
            if (PreferencesData.getBoolean(""discovery.debug"")) {
              System.out.println(format(tr(""Could not start discovery '{0}': {1}""), discoveryName, e.getMessage()));
            }
          }
        }
      }
    }

    // Start all discoverers
    for (Discovery d : discoverers) {
      try {
        new Thread(d).start();
      } catch (Exception e) {
        System.err.println(tr(""Error starting discovery method: "") + d.toString());
        e.printStackTrace();
      }
    }

    Thread closeHook = new Thread(() -> {
      for (Discovery d : discoverers) {
        try {
          d.stop();
        } catch (Exception e) {
          e.printStackTrace(); //just printing as the JVM is terminating
        }
      }
    });
    closeHook.setName(""DiscoveryManager closeHook"");
    Runtime.getRuntime().addShutdownHook(closeHook);
  }",iterator
discoveryName,"{
//    this.packages = packages;

    discoverers = new ArrayList<>();
    discoverers.add(serialDiscoverer);
    discoverers.add(networkDiscoverer);

    // Search for discoveries in installed packages
    for (TargetPackage targetPackage : packages.values()) {
      for (TargetPlatform platform: targetPackage.getPlatforms().values()) {
        //System.out.println(""installed: ""+platform);
        PreferencesMap prefs = platform.getPreferences().subTree(""discovery"");
        PreferencesMap pathPrefs = new PreferencesMap();
        File platformFolder = platform.getFolder();
        pathPrefs.put(""runtime.platform.path"", platformFolder.getAbsolutePath());
        pathPrefs.put(""runtime.hardware.path"", platformFolder.getParentFile().getAbsolutePath());
        for (String discoveryName : prefs.firstLevelMap().keySet()) {
          PreferencesMap discoveryPrefs = prefs.subTree(discoveryName);

          String pattern = discoveryPrefs.get(""pattern"");
          if (pattern == null) {
            System.out.println(format(tr(""No recipes defined for discovery '{0}'""),discoveryName));
            continue;
          }
          try {
            if (PreferencesData.getBoolean(""discovery.debug"")) {
              System.out.println(""found discovery: "" + discoveryName + "" -> "" + pattern);
              System.out.println(""with pathnames -> "" + pathPrefs);
              System.out.println(""with preferencess -> "" + discoveryPrefs);
            }
            pattern = StringReplacer.replaceFromMapping(pattern, PreferencesData.getMap());
            pattern = StringReplacer.replaceFromMapping(pattern, pathPrefs);
            String[] cmd = StringReplacer.formatAndSplit(pattern, discoveryPrefs);
            discoverers.add(new PluggableDiscovery(discoveryName, cmd));
          } catch (Exception e) {
            if (PreferencesData.getBoolean(""discovery.debug"")) {
              System.out.println(format(tr(""Could not start discovery '{0}': {1}""), discoveryName, e.getMessage()));
            }
          }
        }
      }
    }

    // Start all discoverers
    for (Discovery d : discoverers) {
      try {
        new Thread(d).start();
      } catch (Exception e) {
        System.err.println(tr(""Error starting discovery method: "") + d.toString());
        e.printStackTrace();
      }
    }

    Thread closeHook = new Thread(() -> {
      for (Discovery d : discoverers) {
        try {
          d.stop();
        } catch (Exception e) {
          e.printStackTrace(); //just printing as the JVM is terminating
        }
      }
    });
    closeHook.setName(""DiscoveryManager closeHook"");
    Runtime.getRuntime().addShutdownHook(closeHook);
  }",iterator
d,"{
//    this.packages = packages;

    discoverers = new ArrayList<>();
    discoverers.add(serialDiscoverer);
    discoverers.add(networkDiscoverer);

    // Search for discoveries in installed packages
    for (TargetPackage targetPackage : packages.values()) {
      for (TargetPlatform platform: targetPackage.getPlatforms().values()) {
        //System.out.println(""installed: ""+platform);
        PreferencesMap prefs = platform.getPreferences().subTree(""discovery"");
        PreferencesMap pathPrefs = new PreferencesMap();
        File platformFolder = platform.getFolder();
        pathPrefs.put(""runtime.platform.path"", platformFolder.getAbsolutePath());
        pathPrefs.put(""runtime.hardware.path"", platformFolder.getParentFile().getAbsolutePath());
        for (String discoveryName : prefs.firstLevelMap().keySet()) {
          PreferencesMap discoveryPrefs = prefs.subTree(discoveryName);

          String pattern = discoveryPrefs.get(""pattern"");
          if (pattern == null) {
            System.out.println(format(tr(""No recipes defined for discovery '{0}'""),discoveryName));
            continue;
          }
          try {
            if (PreferencesData.getBoolean(""discovery.debug"")) {
              System.out.println(""found discovery: "" + discoveryName + "" -> "" + pattern);
              System.out.println(""with pathnames -> "" + pathPrefs);
              System.out.println(""with preferencess -> "" + discoveryPrefs);
            }
            pattern = StringReplacer.replaceFromMapping(pattern, PreferencesData.getMap());
            pattern = StringReplacer.replaceFromMapping(pattern, pathPrefs);
            String[] cmd = StringReplacer.formatAndSplit(pattern, discoveryPrefs);
            discoverers.add(new PluggableDiscovery(discoveryName, cmd));
          } catch (Exception e) {
            if (PreferencesData.getBoolean(""discovery.debug"")) {
              System.out.println(format(tr(""Could not start discovery '{0}': {1}""), discoveryName, e.getMessage()));
            }
          }
        }
      }
    }

    // Start all discoverers
    for (Discovery d : discoverers) {
      try {
        new Thread(d).start();
      } catch (Exception e) {
        System.err.println(tr(""Error starting discovery method: "") + d.toString());
        e.printStackTrace();
      }
    }

    Thread closeHook = new Thread(() -> {
      for (Discovery d : discoverers) {
        try {
          d.stop();
        } catch (Exception e) {
          e.printStackTrace(); //just printing as the JVM is terminating
        }
      }
    });
    closeHook.setName(""DiscoveryManager closeHook"");
    Runtime.getRuntime().addShutdownHook(closeHook);
  }",iterator
d,"{
    List<BoardPort> res = new ArrayList<>();
    for (Discovery d : discoverers) {
      res.addAll(d.listDiscoveredBoards());
    }
    return res;
  }",iterator
d,"{
    List<BoardPort> res = new ArrayList<>();
    for (Discovery d : discoverers) {
      res.addAll(d.listDiscoveredBoards(complete));
    }
    return res;
  }",iterator
boardPort,"{
    for (BoardPort boardPort : discovery()) {
      if (boardPort.getAddress().equals(address)) {
        return boardPort;
      }
    }
    return null;
  }",iterator
boardPort,"{
    for (BoardPort boardPort : discovery(complete)) {
      if (boardPort.getAddress().equals(address)) {
        return boardPort;
      }
    }
    return null;
  }",iterator
boardPort,"{
    for (BoardPort boardPort : discovery(complete)) {
      if (boardPort.getAddress().equals(address)) {
        return boardPort;
      }
    }
    return null;
  }",break_loop_control
boardPort,"{
    for (BoardPort boardPort : discovery()) {
      if (boardPort.getAddress().equals(address)) {
        return boardPort;
      }
    }
    return null;
  }",break_loop_control
inetAddress,"{
    while (BaseNoGui.packages == null) {
      try {
        Thread.sleep(1000);
      } catch (InterruptedException e) {
        e.printStackTrace();
      }
    }

    ServiceInfo info = serviceEvent.getInfo();

    for (InetAddress inetAddress : info.getInet4Addresses()) {
      String address = inetAddress.getHostAddress();
      String name = serviceEvent.getName();

      BoardPort port = new BoardPort();

      String board = null;
      String description = null;
      if (info.hasData()) {
        board = info.getPropertyString(""board"");
        description = info.getPropertyString(""description"");
        port.getPrefs().put(""board"", board);
        port.getPrefs().put(""distro_version"", info.getPropertyString(""distro_version""));
        port.getPrefs().put(""port"", """" + info.getPort());

        //Add additional fields to permit generic ota updates
        //and make sure we do not intefere with Arduino boards
        // define ""ssh_upload=no"" TXT property to use generic uploader
        // define ""tcp_check=no"" TXT property if you are not using TCP
        // define ""auth_upload=yes"" TXT property if you want to use authenticated generic upload
        String useSSH = info.getPropertyString(""ssh_upload"");
        String checkTCP = info.getPropertyString(""tcp_check"");
        String useAuth = info.getPropertyString(""auth_upload"");
        if(useSSH == null || !useSSH.contentEquals(""no"")) useSSH = ""yes"";
        if(checkTCP == null || !checkTCP.contentEquals(""no"")) checkTCP = ""yes"";
        if(useAuth == null || !useAuth.contentEquals(""yes"")) useAuth = ""no"";
        port.getPrefs().put(""ssh_upload"", useSSH);
        port.getPrefs().put(""tcp_check"", checkTCP);
        port.getPrefs().put(""auth_upload"", useAuth);
      }

      String label = name + "" at "" + address;
      if (board != null && BaseNoGui.packages != null) {
        String boardName = BaseNoGui.getPlatform().resolveDeviceByBoardID(BaseNoGui.packages, board);
        port.setBoardName(boardName);
      } else if (description != null) {
        label += "" ("" + description + "")"";
      }

      port.setAddress(address);
      port.setProtocol(""network"");
      port.setLabel(label);

      synchronized (boardPortsDiscoveredWithJmDNS) {
        removeDuplicateBoards(port);
        boardPortsDiscoveredWithJmDNS.add(port);
      }
    }
  }",iterator
port,"{
      if (complete) {
        return new ArrayList<>(serialBoardPorts);
      }
      List<BoardPort> onlineBoardPorts = new ArrayList<>();
      for (BoardPort port : serialBoardPorts) {
        if (port.isOnline() == true) {
          onlineBoardPorts.add(port);
        }
      }
      return onlineBoardPorts;
  }",iterator
board,"{
    Platform platform = BaseNoGui.getPlatform();
    if (platform == null) {
      return;
    }

    List<String> ports = platform.listSerials();
    if (ports.equals(oldPorts)) {
      return;
    }

    oldPorts.clear();
    oldPorts.addAll(ports);

    // set unreachable ports offline
    for (BoardPort board : boardPorts) {
      if (!ports.contains(board.toCompleteString())) {
        board.setOnlineStatus(false);
      }
    }

    // add information for newly added ports
    for (String newPort : ports) {

      // if port has been already discovered bring it back online
      BoardPort oldBoardPort = boardPorts.stream() //
          .filter(bp -> bp.toCompleteString().equalsIgnoreCase(newPort)) //
          .findAny().orElse(null);
      if (oldBoardPort != null) {
        oldBoardPort.setOnlineStatus(true);
        continue;
      }

      // Otherwise build a BoardPort object out of it and add it to
      // to the known boardPorts

      String[] parts = newPort.split(""_"");
      if (parts.length < 3) {
        // something went horribly wrong
        continue;
      }
      if (parts.length > 3) {
        // port name with _ in it (like CP2102 on OSX)
        for (int i = 1; i < (parts.length-2); i++) {
          parts[0] += ""_"" + parts[i];
        }
        parts[1] = parts[parts.length-2];
        parts[2] = parts[parts.length-1];
      }

      String port = parts[0];

      BoardPort boardPort = new BoardPort();
      boardPorts.add(boardPort);
      boardPort.setAddress(port);
      boardPort.setProtocol(""serial"");
      boardPort.setOnlineStatus(true);
      boardPort.setLabel(port);

      Map<String, Object> boardData = platform.resolveDeviceByVendorIdProductId(port, BaseNoGui.packages);
      if (boardData != null) {
        boardPort.getPrefs().put(""vid"", boardData.get(""vid"").toString());
        boardPort.getPrefs().put(""pid"", boardData.get(""pid"").toString());

        String iserial = boardData.get(""iserial"").toString();
        boardPort.getPrefs().put(""iserial"", iserial);

        TargetBoard board = (TargetBoard) boardData.get(""board"");
        if (board != null) {
          String boardName = board.getName();
          boardPort.setBoardName(boardName);
        }
      } else if (!parts[1].equals(""0000"")) {
        boardPort.getPrefs().put(""vid"", parts[1]);
        boardPort.getPrefs().put(""pid"", parts[2]);
        // ask Cloud API to match the board with known VID/PID pair
        boardCloudResolver.getBoardBy(parts[1], parts[2]);
      } else {
        boardPort.getPrefs().put(""vid"", ""0000"");
        boardPort.getPrefs().put(""pid"", ""0000"");
        boardPort.getPrefs().put(""iserial"", """");
      }
    }
    setSerialBoardPorts(boardPorts);
  }",iterator
newPort,"{
    Platform platform = BaseNoGui.getPlatform();
    if (platform == null) {
      return;
    }

    List<String> ports = platform.listSerials();
    if (ports.equals(oldPorts)) {
      return;
    }

    oldPorts.clear();
    oldPorts.addAll(ports);

    // set unreachable ports offline
    for (BoardPort board : boardPorts) {
      if (!ports.contains(board.toCompleteString())) {
        board.setOnlineStatus(false);
      }
    }

    // add information for newly added ports
    for (String newPort : ports) {

      // if port has been already discovered bring it back online
      BoardPort oldBoardPort = boardPorts.stream() //
          .filter(bp -> bp.toCompleteString().equalsIgnoreCase(newPort)) //
          .findAny().orElse(null);
      if (oldBoardPort != null) {
        oldBoardPort.setOnlineStatus(true);
        continue;
      }

      // Otherwise build a BoardPort object out of it and add it to
      // to the known boardPorts

      String[] parts = newPort.split(""_"");
      if (parts.length < 3) {
        // something went horribly wrong
        continue;
      }
      if (parts.length > 3) {
        // port name with _ in it (like CP2102 on OSX)
        for (int i = 1; i < (parts.length-2); i++) {
          parts[0] += ""_"" + parts[i];
        }
        parts[1] = parts[parts.length-2];
        parts[2] = parts[parts.length-1];
      }

      String port = parts[0];

      BoardPort boardPort = new BoardPort();
      boardPorts.add(boardPort);
      boardPort.setAddress(port);
      boardPort.setProtocol(""serial"");
      boardPort.setOnlineStatus(true);
      boardPort.setLabel(port);

      Map<String, Object> boardData = platform.resolveDeviceByVendorIdProductId(port, BaseNoGui.packages);
      if (boardData != null) {
        boardPort.getPrefs().put(""vid"", boardData.get(""vid"").toString());
        boardPort.getPrefs().put(""pid"", boardData.get(""pid"").toString());

        String iserial = boardData.get(""iserial"").toString();
        boardPort.getPrefs().put(""iserial"", iserial);

        TargetBoard board = (TargetBoard) boardData.get(""board"");
        if (board != null) {
          String boardName = board.getName();
          boardPort.setBoardName(boardName);
        }
      } else if (!parts[1].equals(""0000"")) {
        boardPort.getPrefs().put(""vid"", parts[1]);
        boardPort.getPrefs().put(""pid"", parts[2]);
        // ask Cloud API to match the board with known VID/PID pair
        boardCloudResolver.getBoardBy(parts[1], parts[2]);
      } else {
        boardPort.getPrefs().put(""vid"", ""0000"");
        boardPort.getPrefs().put(""pid"", ""0000"");
        boardPort.getPrefs().put(""iserial"", """");
      }
    }
    setSerialBoardPorts(boardPorts);
  }",iterator
i,"{
    Platform platform = BaseNoGui.getPlatform();
    if (platform == null) {
      return;
    }

    List<String> ports = platform.listSerials();
    if (ports.equals(oldPorts)) {
      return;
    }

    oldPorts.clear();
    oldPorts.addAll(ports);

    // set unreachable ports offline
    for (BoardPort board : boardPorts) {
      if (!ports.contains(board.toCompleteString())) {
        board.setOnlineStatus(false);
      }
    }

    // add information for newly added ports
    for (String newPort : ports) {

      // if port has been already discovered bring it back online
      BoardPort oldBoardPort = boardPorts.stream() //
          .filter(bp -> bp.toCompleteString().equalsIgnoreCase(newPort)) //
          .findAny().orElse(null);
      if (oldBoardPort != null) {
        oldBoardPort.setOnlineStatus(true);
        continue;
      }

      // Otherwise build a BoardPort object out of it and add it to
      // to the known boardPorts

      String[] parts = newPort.split(""_"");
      if (parts.length < 3) {
        // something went horribly wrong
        continue;
      }
      if (parts.length > 3) {
        // port name with _ in it (like CP2102 on OSX)
        for (int i = 1; i < (parts.length-2); i++) {
          parts[0] += ""_"" + parts[i];
        }
        parts[1] = parts[parts.length-2];
        parts[2] = parts[parts.length-1];
      }

      String port = parts[0];

      BoardPort boardPort = new BoardPort();
      boardPorts.add(boardPort);
      boardPort.setAddress(port);
      boardPort.setProtocol(""serial"");
      boardPort.setOnlineStatus(true);
      boardPort.setLabel(port);

      Map<String, Object> boardData = platform.resolveDeviceByVendorIdProductId(port, BaseNoGui.packages);
      if (boardData != null) {
        boardPort.getPrefs().put(""vid"", boardData.get(""vid"").toString());
        boardPort.getPrefs().put(""pid"", boardData.get(""pid"").toString());

        String iserial = boardData.get(""iserial"").toString();
        boardPort.getPrefs().put(""iserial"", iserial);

        TargetBoard board = (TargetBoard) boardData.get(""board"");
        if (board != null) {
          String boardName = board.getName();
          boardPort.setBoardName(boardName);
        }
      } else if (!parts[1].equals(""0000"")) {
        boardPort.getPrefs().put(""vid"", parts[1]);
        boardPort.getPrefs().put(""pid"", parts[2]);
        // ask Cloud API to match the board with known VID/PID pair
        boardCloudResolver.getBoardBy(parts[1], parts[2]);
      } else {
        boardPort.getPrefs().put(""vid"", ""0000"");
        boardPort.getPrefs().put(""pid"", ""0000"");
        boardPort.getPrefs().put(""iserial"", """");
      }
    }
    setSerialBoardPorts(boardPorts);
  }",loop_control
file,"{
    File[] files = from.listFiles();
    if (files == null) {
      return;
    }

    for (File file : files) {
      if (!FILES_NOT_TO_COPY.contains(file.getName())) {
        if (file.isDirectory() && file.canExecute()) {
          scp.startFolder(file.getName());
          recursiveSCP(file, scp);
          scp.endFolder();
        } else if (file.isFile() && file.canRead()) {
          scp.sendFile(file);
        }
      }
    }
  }",iterator
line,"{
    List<String> mergedSketch = Files.readAllLines(sketch.toPath(), StandardCharsets.UTF_8);
    mergedSketch.remove(mergedSketch.size() - 1);
    mergedSketch.addAll(Files.readAllLines(bootloader.toPath(), StandardCharsets.UTF_8));

    FileWriter writer = null;
    try {
      writer = new FileWriter(sketch);
      for (String line : mergedSketch) {
        writer.write(line);
        writer.write(""\n"");
      }
    } finally {
      if (writer != null) {
        writer.close();
      }
    }
  }",iterator
elapsed,"{
    // Wait for a port to appear on the list
    int elapsed = 0;
    while (elapsed < timeout) {
      List<String> now = Serial.list();
      List<String> diff = new ArrayList<>(now);
      diff.removeAll(before);
      if (verbose) {
        System.out.print(""PORTS {"");
        for (String p : before)
          System.out.print(p + "", "");
        System.out.print(""} / {"");
        for (String p : now)
          System.out.print(p + "", "");
        System.out.print(""} => {"");
        for (String p : diff)
          System.out.print(p + "", "");
        System.out.println(""}"");
      }
      if (diff.size() > 0) {
        String newPort = diff.get(0);
        if (verbose)
          System.out.println(""Found upload port: "" + newPort);
        return newPort;
      }

      // Keep track of port that disappears
      before = now;
      Thread.sleep(250);
      elapsed += 250;

      // On Windows and OS X, it can take a few seconds for the port to disappear and
      // come back, so use a time out before assuming that the selected port is the
      // bootloader (not the sketch).
      if (elapsed >= 5000 && now.contains(uploadPort)) {
        if (verbose)
          System.out.println(""Uploading using selected port: "" + uploadPort);
        return uploadPort;
      }
    }

    // Something happened while detecting port
    throw new RunnerException(tr(""Couldn't find a Board on the selected port. Check that you have the correct port selected.  If it is correct, try pressing the board's reset button after initiating the upload.""), false);
  }",loop_control
p,"{
    // Wait for a port to appear on the list
    int elapsed = 0;
    while (elapsed < timeout) {
      List<String> now = Serial.list();
      List<String> diff = new ArrayList<>(now);
      diff.removeAll(before);
      if (verbose) {
        System.out.print(""PORTS {"");
        for (String p : before)
          System.out.print(p + "", "");
        System.out.print(""} / {"");
        for (String p : now)
          System.out.print(p + "", "");
        System.out.print(""} => {"");
        for (String p : diff)
          System.out.print(p + "", "");
        System.out.println(""}"");
      }
      if (diff.size() > 0) {
        String newPort = diff.get(0);
        if (verbose)
          System.out.println(""Found upload port: "" + newPort);
        return newPort;
      }

      // Keep track of port that disappears
      before = now;
      Thread.sleep(250);
      elapsed += 250;

      // On Windows and OS X, it can take a few seconds for the port to disappear and
      // come back, so use a time out before assuming that the selected port is the
      // bootloader (not the sketch).
      if (elapsed >= 5000 && now.contains(uploadPort)) {
        if (verbose)
          System.out.println(""Uploading using selected port: "" + uploadPort);
        return uploadPort;
      }
    }

    // Something happened while detecting port
    throw new RunnerException(tr(""Couldn't find a Board on the selected port. Check that you have the correct port selected.  If it is correct, try pressing the board's reset button after initiating the upload.""), false);
  }",iterator
entry,"{

    // Folders timestamps must be set at the end of archive extraction
    // (because creating a file in a folder alters the folder's timestamp)
    Map<File, Long> foldersTimestamps = new HashMap<>();

    ArchiveInputStream in = null;
    try {

      // Create an ArchiveInputStream with the correct archiving algorithm
      if (archiveFile.getName().endsWith(""tar.bz2"")) {
        in = new TarArchiveInputStream(new BZip2CompressorInputStream(new FileInputStream(archiveFile)));
      } else if (archiveFile.getName().endsWith(""zip"")) {
        in = new ZipArchiveInputStream(new FileInputStream(archiveFile));
      } else if (archiveFile.getName().endsWith(""tar.gz"")) {
        in = new TarArchiveInputStream(new GzipCompressorInputStream(new FileInputStream(archiveFile)));
      } else if (archiveFile.getName().endsWith(""tar.xz"")) {
        in = new TarArchiveInputStream(new XZCompressorInputStream(new FileInputStream(archiveFile)));
      } else if (archiveFile.getName().endsWith(""tar"")) {
        in = new TarArchiveInputStream(new FileInputStream(archiveFile));
      } else {
        throw new IOException(""Archive format not supported."");
      }

      String pathPrefix = """";

      Map<File, File> hardLinks = new HashMap<>();
      Map<File, Integer> hardLinksMode = new HashMap<>();
      Map<File, String> symLinks = new HashMap<>();
      Map<File, Long> symLinksModifiedTimes = new HashMap<>();

      // Cycle through all the archive entries
      while (true) {
        ArchiveEntry entry = in.getNextEntry();
        if (entry == null) {
          break;
        }

        // Extract entry info
        long size = entry.getSize();
        String name = entry.getName();
        boolean isDirectory = entry.isDirectory();
        boolean isLink = false;
        boolean isSymLink = false;
        String linkName = null;
        Integer mode = null;
        long modifiedTime = entry.getLastModifiedDate().getTime();

        {
          // Skip MacOSX metadata
          // http://superuser.com/questions/61185/why-do-i-get-files-like-foo-in-my-tarball-on-os-x
          int slash = name.lastIndexOf('/');
          if (slash == -1) {
            if (name.startsWith(""._"")) {
              continue;
            }
          } else {
            if (name.substring(slash + 1).startsWith(""._"")) {
              continue;
            }
          }
        }

        // Skip git metadata
        // http://www.unix.com/unix-for-dummies-questions-and-answers/124958-file-pax_global_header-means-what.html
        if (name.contains(""pax_global_header"")) {
          continue;
        }

        if (entry instanceof TarArchiveEntry) {
          TarArchiveEntry tarEntry = (TarArchiveEntry) entry;
          mode = tarEntry.getMode();
          isLink = tarEntry.isLink();
          isSymLink = tarEntry.isSymbolicLink();
          linkName = tarEntry.getLinkName();
        }

        // On the first archive entry, if requested, detect the common path
        // prefix to be stripped from filenames
        if (stripPath > 0 && pathPrefix.isEmpty()) {
          int slash = 0;
          while (stripPath > 0) {
            slash = name.indexOf(""/"", slash);
            if (slash == -1) {
              throw new IOException(""Invalid archive: it must contain a single root folder"");
            }
            slash++;
            stripPath--;
          }
          pathPrefix = name.substring(0, slash);
        }

        // Strip the common path prefix when requested
        if (!name.startsWith(pathPrefix)) {
          throw new IOException(""Invalid archive: it must contain a single root folder while file "" + name + "" is outside "" + pathPrefix);
        }
        name = name.substring(pathPrefix.length());
        if (name.isEmpty()) {
          continue;
        }
        File outputFile = new File(destFolder, name);

        File outputLinkedFile = null;
        if (isLink) {
          if (!linkName.startsWith(pathPrefix)) {
            throw new IOException(""Invalid archive: it must contain a single root folder while file "" + linkName + "" is outside "" + pathPrefix);
          }
          linkName = linkName.substring(pathPrefix.length());
          outputLinkedFile = new File(destFolder, linkName);
        }
        if (isSymLink) {
          // Symbolic links are referenced with relative paths
          outputLinkedFile = new File(linkName);
          if (outputLinkedFile.isAbsolute()) {
            System.err.println(I18n.format(tr(""Warning: file {0} links to an absolute path {1}""), outputFile, outputLinkedFile));
            System.err.println();
          }
        }

        // Safety check
        if (isDirectory) {
          if (outputFile.isFile() && !overwrite) {
            throw new IOException(""Can't create folder "" + outputFile + "", a file with the same name exists!"");
          }
        } else {
          // - isLink
          // - isSymLink
          // - anything else
          if (outputFile.exists() && !overwrite) {
            throw new IOException(""Can't extract file "" + outputFile + "", file already exists!"");
          }
        }

        // Extract the entry
        if (isDirectory) {
          if (!outputFile.exists() && !outputFile.mkdirs()) {
            throw new IOException(""Could not create folder: "" + outputFile);
          }
          foldersTimestamps.put(outputFile, modifiedTime);
        } else if (isLink) {
          hardLinks.put(outputFile, outputLinkedFile);
          hardLinksMode.put(outputFile, mode);
        } else if (isSymLink) {
          symLinks.put(outputFile, linkName);
          symLinksModifiedTimes.put(outputFile, modifiedTime);
        } else {
          // Create the containing folder if not exists
          if (!outputFile.getParentFile().isDirectory()) {
            outputFile.getParentFile().mkdirs();
          }
          copyStreamToFile(in, size, outputFile);
          outputFile.setLastModified(modifiedTime);
        }

        // Set file/folder permission
        if (mode != null && !isSymLink && outputFile.exists()) {
          platform.chmod(outputFile, mode);
        }
      }

      for (Map.Entry<File, File> entry : hardLinks.entrySet()) {
        if (entry.getKey().exists() && overwrite) {
          entry.getKey().delete();
        }
        platform.link(entry.getValue(), entry.getKey());
        Integer mode = hardLinksMode.get(entry.getKey());
        if (mode != null) {
          platform.chmod(entry.getKey(), mode);
        }
      }

      for (Map.Entry<File, String> entry : symLinks.entrySet()) {
        if (entry.getKey().exists() && overwrite) {
          entry.getKey().delete();
        }
        platform.symlink(entry.getValue(), entry.getKey());
        entry.getKey().setLastModified(symLinksModifiedTimes.get(entry.getKey()));
      }

    } finally {
      IOUtils.closeQuietly(in);
    }

    // Set folders timestamps
    for (File folder : foldersTimestamps.keySet()) {
      folder.setLastModified(foldersTimestamps.get(folder));
    }
  }",break_loop_control
stripPath,"{

    // Folders timestamps must be set at the end of archive extraction
    // (because creating a file in a folder alters the folder's timestamp)
    Map<File, Long> foldersTimestamps = new HashMap<>();

    ArchiveInputStream in = null;
    try {

      // Create an ArchiveInputStream with the correct archiving algorithm
      if (archiveFile.getName().endsWith(""tar.bz2"")) {
        in = new TarArchiveInputStream(new BZip2CompressorInputStream(new FileInputStream(archiveFile)));
      } else if (archiveFile.getName().endsWith(""zip"")) {
        in = new ZipArchiveInputStream(new FileInputStream(archiveFile));
      } else if (archiveFile.getName().endsWith(""tar.gz"")) {
        in = new TarArchiveInputStream(new GzipCompressorInputStream(new FileInputStream(archiveFile)));
      } else if (archiveFile.getName().endsWith(""tar.xz"")) {
        in = new TarArchiveInputStream(new XZCompressorInputStream(new FileInputStream(archiveFile)));
      } else if (archiveFile.getName().endsWith(""tar"")) {
        in = new TarArchiveInputStream(new FileInputStream(archiveFile));
      } else {
        throw new IOException(""Archive format not supported."");
      }

      String pathPrefix = """";

      Map<File, File> hardLinks = new HashMap<>();
      Map<File, Integer> hardLinksMode = new HashMap<>();
      Map<File, String> symLinks = new HashMap<>();
      Map<File, Long> symLinksModifiedTimes = new HashMap<>();

      // Cycle through all the archive entries
      while (true) {
        ArchiveEntry entry = in.getNextEntry();
        if (entry == null) {
          break;
        }

        // Extract entry info
        long size = entry.getSize();
        String name = entry.getName();
        boolean isDirectory = entry.isDirectory();
        boolean isLink = false;
        boolean isSymLink = false;
        String linkName = null;
        Integer mode = null;
        long modifiedTime = entry.getLastModifiedDate().getTime();

        {
          // Skip MacOSX metadata
          // http://superuser.com/questions/61185/why-do-i-get-files-like-foo-in-my-tarball-on-os-x
          int slash = name.lastIndexOf('/');
          if (slash == -1) {
            if (name.startsWith(""._"")) {
              continue;
            }
          } else {
            if (name.substring(slash + 1).startsWith(""._"")) {
              continue;
            }
          }
        }

        // Skip git metadata
        // http://www.unix.com/unix-for-dummies-questions-and-answers/124958-file-pax_global_header-means-what.html
        if (name.contains(""pax_global_header"")) {
          continue;
        }

        if (entry instanceof TarArchiveEntry) {
          TarArchiveEntry tarEntry = (TarArchiveEntry) entry;
          mode = tarEntry.getMode();
          isLink = tarEntry.isLink();
          isSymLink = tarEntry.isSymbolicLink();
          linkName = tarEntry.getLinkName();
        }

        // On the first archive entry, if requested, detect the common path
        // prefix to be stripped from filenames
        if (stripPath > 0 && pathPrefix.isEmpty()) {
          int slash = 0;
          while (stripPath > 0) {
            slash = name.indexOf(""/"", slash);
            if (slash == -1) {
              throw new IOException(""Invalid archive: it must contain a single root folder"");
            }
            slash++;
            stripPath--;
          }
          pathPrefix = name.substring(0, slash);
        }

        // Strip the common path prefix when requested
        if (!name.startsWith(pathPrefix)) {
          throw new IOException(""Invalid archive: it must contain a single root folder while file "" + name + "" is outside "" + pathPrefix);
        }
        name = name.substring(pathPrefix.length());
        if (name.isEmpty()) {
          continue;
        }
        File outputFile = new File(destFolder, name);

        File outputLinkedFile = null;
        if (isLink) {
          if (!linkName.startsWith(pathPrefix)) {
            throw new IOException(""Invalid archive: it must contain a single root folder while file "" + linkName + "" is outside "" + pathPrefix);
          }
          linkName = linkName.substring(pathPrefix.length());
          outputLinkedFile = new File(destFolder, linkName);
        }
        if (isSymLink) {
          // Symbolic links are referenced with relative paths
          outputLinkedFile = new File(linkName);
          if (outputLinkedFile.isAbsolute()) {
            System.err.println(I18n.format(tr(""Warning: file {0} links to an absolute path {1}""), outputFile, outputLinkedFile));
            System.err.println();
          }
        }

        // Safety check
        if (isDirectory) {
          if (outputFile.isFile() && !overwrite) {
            throw new IOException(""Can't create folder "" + outputFile + "", a file with the same name exists!"");
          }
        } else {
          // - isLink
          // - isSymLink
          // - anything else
          if (outputFile.exists() && !overwrite) {
            throw new IOException(""Can't extract file "" + outputFile + "", file already exists!"");
          }
        }

        // Extract the entry
        if (isDirectory) {
          if (!outputFile.exists() && !outputFile.mkdirs()) {
            throw new IOException(""Could not create folder: "" + outputFile);
          }
          foldersTimestamps.put(outputFile, modifiedTime);
        } else if (isLink) {
          hardLinks.put(outputFile, outputLinkedFile);
          hardLinksMode.put(outputFile, mode);
        } else if (isSymLink) {
          symLinks.put(outputFile, linkName);
          symLinksModifiedTimes.put(outputFile, modifiedTime);
        } else {
          // Create the containing folder if not exists
          if (!outputFile.getParentFile().isDirectory()) {
            outputFile.getParentFile().mkdirs();
          }
          copyStreamToFile(in, size, outputFile);
          outputFile.setLastModified(modifiedTime);
        }

        // Set file/folder permission
        if (mode != null && !isSymLink && outputFile.exists()) {
          platform.chmod(outputFile, mode);
        }
      }

      for (Map.Entry<File, File> entry : hardLinks.entrySet()) {
        if (entry.getKey().exists() && overwrite) {
          entry.getKey().delete();
        }
        platform.link(entry.getValue(), entry.getKey());
        Integer mode = hardLinksMode.get(entry.getKey());
        if (mode != null) {
          platform.chmod(entry.getKey(), mode);
        }
      }

      for (Map.Entry<File, String> entry : symLinks.entrySet()) {
        if (entry.getKey().exists() && overwrite) {
          entry.getKey().delete();
        }
        platform.symlink(entry.getValue(), entry.getKey());
        entry.getKey().setLastModified(symLinksModifiedTimes.get(entry.getKey()));
      }

    } finally {
      IOUtils.closeQuietly(in);
    }

    // Set folders timestamps
    for (File folder : foldersTimestamps.keySet()) {
      folder.setLastModified(foldersTimestamps.get(folder));
    }
  }",loop_control
entry,"{

    // Folders timestamps must be set at the end of archive extraction
    // (because creating a file in a folder alters the folder's timestamp)
    Map<File, Long> foldersTimestamps = new HashMap<>();

    ArchiveInputStream in = null;
    try {

      // Create an ArchiveInputStream with the correct archiving algorithm
      if (archiveFile.getName().endsWith(""tar.bz2"")) {
        in = new TarArchiveInputStream(new BZip2CompressorInputStream(new FileInputStream(archiveFile)));
      } else if (archiveFile.getName().endsWith(""zip"")) {
        in = new ZipArchiveInputStream(new FileInputStream(archiveFile));
      } else if (archiveFile.getName().endsWith(""tar.gz"")) {
        in = new TarArchiveInputStream(new GzipCompressorInputStream(new FileInputStream(archiveFile)));
      } else if (archiveFile.getName().endsWith(""tar.xz"")) {
        in = new TarArchiveInputStream(new XZCompressorInputStream(new FileInputStream(archiveFile)));
      } else if (archiveFile.getName().endsWith(""tar"")) {
        in = new TarArchiveInputStream(new FileInputStream(archiveFile));
      } else {
        throw new IOException(""Archive format not supported."");
      }

      String pathPrefix = """";

      Map<File, File> hardLinks = new HashMap<>();
      Map<File, Integer> hardLinksMode = new HashMap<>();
      Map<File, String> symLinks = new HashMap<>();
      Map<File, Long> symLinksModifiedTimes = new HashMap<>();

      // Cycle through all the archive entries
      while (true) {
        ArchiveEntry entry = in.getNextEntry();
        if (entry == null) {
          break;
        }

        // Extract entry info
        long size = entry.getSize();
        String name = entry.getName();
        boolean isDirectory = entry.isDirectory();
        boolean isLink = false;
        boolean isSymLink = false;
        String linkName = null;
        Integer mode = null;
        long modifiedTime = entry.getLastModifiedDate().getTime();

        {
          // Skip MacOSX metadata
          // http://superuser.com/questions/61185/why-do-i-get-files-like-foo-in-my-tarball-on-os-x
          int slash = name.lastIndexOf('/');
          if (slash == -1) {
            if (name.startsWith(""._"")) {
              continue;
            }
          } else {
            if (name.substring(slash + 1).startsWith(""._"")) {
              continue;
            }
          }
        }

        // Skip git metadata
        // http://www.unix.com/unix-for-dummies-questions-and-answers/124958-file-pax_global_header-means-what.html
        if (name.contains(""pax_global_header"")) {
          continue;
        }

        if (entry instanceof TarArchiveEntry) {
          TarArchiveEntry tarEntry = (TarArchiveEntry) entry;
          mode = tarEntry.getMode();
          isLink = tarEntry.isLink();
          isSymLink = tarEntry.isSymbolicLink();
          linkName = tarEntry.getLinkName();
        }

        // On the first archive entry, if requested, detect the common path
        // prefix to be stripped from filenames
        if (stripPath > 0 && pathPrefix.isEmpty()) {
          int slash = 0;
          while (stripPath > 0) {
            slash = name.indexOf(""/"", slash);
            if (slash == -1) {
              throw new IOException(""Invalid archive: it must contain a single root folder"");
            }
            slash++;
            stripPath--;
          }
          pathPrefix = name.substring(0, slash);
        }

        // Strip the common path prefix when requested
        if (!name.startsWith(pathPrefix)) {
          throw new IOException(""Invalid archive: it must contain a single root folder while file "" + name + "" is outside "" + pathPrefix);
        }
        name = name.substring(pathPrefix.length());
        if (name.isEmpty()) {
          continue;
        }
        File outputFile = new File(destFolder, name);

        File outputLinkedFile = null;
        if (isLink) {
          if (!linkName.startsWith(pathPrefix)) {
            throw new IOException(""Invalid archive: it must contain a single root folder while file "" + linkName + "" is outside "" + pathPrefix);
          }
          linkName = linkName.substring(pathPrefix.length());
          outputLinkedFile = new File(destFolder, linkName);
        }
        if (isSymLink) {
          // Symbolic links are referenced with relative paths
          outputLinkedFile = new File(linkName);
          if (outputLinkedFile.isAbsolute()) {
            System.err.println(I18n.format(tr(""Warning: file {0} links to an absolute path {1}""), outputFile, outputLinkedFile));
            System.err.println();
          }
        }

        // Safety check
        if (isDirectory) {
          if (outputFile.isFile() && !overwrite) {
            throw new IOException(""Can't create folder "" + outputFile + "", a file with the same name exists!"");
          }
        } else {
          // - isLink
          // - isSymLink
          // - anything else
          if (outputFile.exists() && !overwrite) {
            throw new IOException(""Can't extract file "" + outputFile + "", file already exists!"");
          }
        }

        // Extract the entry
        if (isDirectory) {
          if (!outputFile.exists() && !outputFile.mkdirs()) {
            throw new IOException(""Could not create folder: "" + outputFile);
          }
          foldersTimestamps.put(outputFile, modifiedTime);
        } else if (isLink) {
          hardLinks.put(outputFile, outputLinkedFile);
          hardLinksMode.put(outputFile, mode);
        } else if (isSymLink) {
          symLinks.put(outputFile, linkName);
          symLinksModifiedTimes.put(outputFile, modifiedTime);
        } else {
          // Create the containing folder if not exists
          if (!outputFile.getParentFile().isDirectory()) {
            outputFile.getParentFile().mkdirs();
          }
          copyStreamToFile(in, size, outputFile);
          outputFile.setLastModified(modifiedTime);
        }

        // Set file/folder permission
        if (mode != null && !isSymLink && outputFile.exists()) {
          platform.chmod(outputFile, mode);
        }
      }

      for (Map.Entry<File, File> entry : hardLinks.entrySet()) {
        if (entry.getKey().exists() && overwrite) {
          entry.getKey().delete();
        }
        platform.link(entry.getValue(), entry.getKey());
        Integer mode = hardLinksMode.get(entry.getKey());
        if (mode != null) {
          platform.chmod(entry.getKey(), mode);
        }
      }

      for (Map.Entry<File, String> entry : symLinks.entrySet()) {
        if (entry.getKey().exists() && overwrite) {
          entry.getKey().delete();
        }
        platform.symlink(entry.getValue(), entry.getKey());
        entry.getKey().setLastModified(symLinksModifiedTimes.get(entry.getKey()));
      }

    } finally {
      IOUtils.closeQuietly(in);
    }

    // Set folders timestamps
    for (File folder : foldersTimestamps.keySet()) {
      folder.setLastModified(foldersTimestamps.get(folder));
    }
  }",iterator
folder,"{

    // Folders timestamps must be set at the end of archive extraction
    // (because creating a file in a folder alters the folder's timestamp)
    Map<File, Long> foldersTimestamps = new HashMap<>();

    ArchiveInputStream in = null;
    try {

      // Create an ArchiveInputStream with the correct archiving algorithm
      if (archiveFile.getName().endsWith(""tar.bz2"")) {
        in = new TarArchiveInputStream(new BZip2CompressorInputStream(new FileInputStream(archiveFile)));
      } else if (archiveFile.getName().endsWith(""zip"")) {
        in = new ZipArchiveInputStream(new FileInputStream(archiveFile));
      } else if (archiveFile.getName().endsWith(""tar.gz"")) {
        in = new TarArchiveInputStream(new GzipCompressorInputStream(new FileInputStream(archiveFile)));
      } else if (archiveFile.getName().endsWith(""tar.xz"")) {
        in = new TarArchiveInputStream(new XZCompressorInputStream(new FileInputStream(archiveFile)));
      } else if (archiveFile.getName().endsWith(""tar"")) {
        in = new TarArchiveInputStream(new FileInputStream(archiveFile));
      } else {
        throw new IOException(""Archive format not supported."");
      }

      String pathPrefix = """";

      Map<File, File> hardLinks = new HashMap<>();
      Map<File, Integer> hardLinksMode = new HashMap<>();
      Map<File, String> symLinks = new HashMap<>();
      Map<File, Long> symLinksModifiedTimes = new HashMap<>();

      // Cycle through all the archive entries
      while (true) {
        ArchiveEntry entry = in.getNextEntry();
        if (entry == null) {
          break;
        }

        // Extract entry info
        long size = entry.getSize();
        String name = entry.getName();
        boolean isDirectory = entry.isDirectory();
        boolean isLink = false;
        boolean isSymLink = false;
        String linkName = null;
        Integer mode = null;
        long modifiedTime = entry.getLastModifiedDate().getTime();

        {
          // Skip MacOSX metadata
          // http://superuser.com/questions/61185/why-do-i-get-files-like-foo-in-my-tarball-on-os-x
          int slash = name.lastIndexOf('/');
          if (slash == -1) {
            if (name.startsWith(""._"")) {
              continue;
            }
          } else {
            if (name.substring(slash + 1).startsWith(""._"")) {
              continue;
            }
          }
        }

        // Skip git metadata
        // http://www.unix.com/unix-for-dummies-questions-and-answers/124958-file-pax_global_header-means-what.html
        if (name.contains(""pax_global_header"")) {
          continue;
        }

        if (entry instanceof TarArchiveEntry) {
          TarArchiveEntry tarEntry = (TarArchiveEntry) entry;
          mode = tarEntry.getMode();
          isLink = tarEntry.isLink();
          isSymLink = tarEntry.isSymbolicLink();
          linkName = tarEntry.getLinkName();
        }

        // On the first archive entry, if requested, detect the common path
        // prefix to be stripped from filenames
        if (stripPath > 0 && pathPrefix.isEmpty()) {
          int slash = 0;
          while (stripPath > 0) {
            slash = name.indexOf(""/"", slash);
            if (slash == -1) {
              throw new IOException(""Invalid archive: it must contain a single root folder"");
            }
            slash++;
            stripPath--;
          }
          pathPrefix = name.substring(0, slash);
        }

        // Strip the common path prefix when requested
        if (!name.startsWith(pathPrefix)) {
          throw new IOException(""Invalid archive: it must contain a single root folder while file "" + name + "" is outside "" + pathPrefix);
        }
        name = name.substring(pathPrefix.length());
        if (name.isEmpty()) {
          continue;
        }
        File outputFile = new File(destFolder, name);

        File outputLinkedFile = null;
        if (isLink) {
          if (!linkName.startsWith(pathPrefix)) {
            throw new IOException(""Invalid archive: it must contain a single root folder while file "" + linkName + "" is outside "" + pathPrefix);
          }
          linkName = linkName.substring(pathPrefix.length());
          outputLinkedFile = new File(destFolder, linkName);
        }
        if (isSymLink) {
          // Symbolic links are referenced with relative paths
          outputLinkedFile = new File(linkName);
          if (outputLinkedFile.isAbsolute()) {
            System.err.println(I18n.format(tr(""Warning: file {0} links to an absolute path {1}""), outputFile, outputLinkedFile));
            System.err.println();
          }
        }

        // Safety check
        if (isDirectory) {
          if (outputFile.isFile() && !overwrite) {
            throw new IOException(""Can't create folder "" + outputFile + "", a file with the same name exists!"");
          }
        } else {
          // - isLink
          // - isSymLink
          // - anything else
          if (outputFile.exists() && !overwrite) {
            throw new IOException(""Can't extract file "" + outputFile + "", file already exists!"");
          }
        }

        // Extract the entry
        if (isDirectory) {
          if (!outputFile.exists() && !outputFile.mkdirs()) {
            throw new IOException(""Could not create folder: "" + outputFile);
          }
          foldersTimestamps.put(outputFile, modifiedTime);
        } else if (isLink) {
          hardLinks.put(outputFile, outputLinkedFile);
          hardLinksMode.put(outputFile, mode);
        } else if (isSymLink) {
          symLinks.put(outputFile, linkName);
          symLinksModifiedTimes.put(outputFile, modifiedTime);
        } else {
          // Create the containing folder if not exists
          if (!outputFile.getParentFile().isDirectory()) {
            outputFile.getParentFile().mkdirs();
          }
          copyStreamToFile(in, size, outputFile);
          outputFile.setLastModified(modifiedTime);
        }

        // Set file/folder permission
        if (mode != null && !isSymLink && outputFile.exists()) {
          platform.chmod(outputFile, mode);
        }
      }

      for (Map.Entry<File, File> entry : hardLinks.entrySet()) {
        if (entry.getKey().exists() && overwrite) {
          entry.getKey().delete();
        }
        platform.link(entry.getValue(), entry.getKey());
        Integer mode = hardLinksMode.get(entry.getKey());
        if (mode != null) {
          platform.chmod(entry.getKey(), mode);
        }
      }

      for (Map.Entry<File, String> entry : symLinks.entrySet()) {
        if (entry.getKey().exists() && overwrite) {
          entry.getKey().delete();
        }
        platform.symlink(entry.getValue(), entry.getKey());
        entry.getKey().setLastModified(symLinksModifiedTimes.get(entry.getKey()));
      }

    } finally {
      IOUtils.closeQuietly(in);
    }

    // Set folders timestamps
    for (File folder : foldersTimestamps.keySet()) {
      folder.setLastModified(foldersTimestamps.get(folder));
    }
  }",iterator
b,"{
    FileInputStream in = null;
    try {
      in = new FileInputStream(file);
      byte buff[] = new byte[10240];
      MessageDigest digest = MessageDigest.getInstance(algorithm);
      while (in.available() > 0) {
        int read = in.read(buff);
        digest.update(buff, 0, read);
      }
      byte[] hash = digest.digest();
      String res = """";
      for (byte b : hash) {
        int c = b & 0xFF;
        if (c < 0x10)
          res += ""0"";
        res += Integer.toHexString(c);
      }
      return algorithm + "":"" + res;
    } finally {
      IOUtils.closeQuietly(in);
    }
  }",iterator
in,"{
    FileInputStream in = null;
    try {
      in = new FileInputStream(file);
      byte buff[] = new byte[10240];
      MessageDigest digest = MessageDigest.getInstance(algorithm);
      while (in.available() > 0) {
        int read = in.read(buff);
        digest.update(buff, 0, read);
      }
      byte[] hash = digest.digest();
      String res = """";
      for (byte b : hash) {
        int c = b & 0xFF;
        if (c < 0x10)
          res += ""0"";
        res += Integer.toHexString(c);
      }
      return algorithm + "":"" + res;
    } finally {
      IOUtils.closeQuietly(in);
    }
  }",maybe_loop_control
language,"{
    for (Language language : languages) {
      if (language.getIsoCode().equals(isoCode)) {
        return true;
      }
    }
    return false;
  }",iterator
language,"{
    for (Language language : languages) {
      if (language.getIsoCode().equals(isoCode)) {
        return true;
      }
    }
    return false;
  }",break_loop_control
i,"{
    if (!argsAsString.startsWith(""["") || !argsAsString.endsWith(""]"")) {
      throw new IllegalArgumentException(argsAsString);
    }

    argsAsString = argsAsString.substring(1, argsAsString.length() - 1);
    if (argsAsString.isEmpty()) {
      return new Object[0];
    }

    List<String> args = new ArrayList<>(Arrays.asList(argsAsString.split("" "")));
    List<String> additionalArgs = addAsManyEmptyArgsAsEndingSpaces(argsAsString, args);

    for (int i = 0; i < args.size(); i++) {
      try {
        args.set(i, URLDecoder.decode(args.get(i), ""UTF-8""));
      } catch (UnsupportedEncodingException e) {
        throw new RuntimeException(e);
      }
    }

    args.addAll(additionalArgs);

    return args.toArray();
  }",loop_control
i,"{
    List<String> additionalArgs = new LinkedList<>();

    if (argsAsString.charAt(argsAsString.length() - 1) == ' ') {
      String allArgsButEndingSpacesAsString = args.stream().collect(Collectors.joining("" ""));
      String endingSpacesOnly = argsAsString.replace(allArgsButEndingSpacesAsString, """");
      for (int i = 0; i < endingSpacesOnly.length(); i++) {
        additionalArgs.add("""");
      }
    }
    return additionalArgs;
  }",loop_control
c,"{
    for (HostDependentDownloadableContribution c : getSystems()) {
      if (c.isCompatible(platform))
        return c;
    }
    return null;
  }",iterator
c,"{
    for (HostDependentDownloadableContribution c : getSystems()) {
      if (c.isCompatible(platform))
        return c;
    }
    return null;
  }",break_loop_control
sys,"{
    String res;
    res = ""Tool name : "" + getName() + "" "" + getVersion() + ""\n"";
    for (HostDependentDownloadableContribution sys : getSystems()) {
      res += ""     sys"";
      if (platform != null) {
        res += sys.isCompatible(platform) ? ""*"" : "" "";
      }
      res += "" : "" + sys + ""\n"";
    }
    return res;
  }",iterator
pack,"{
    for (ContributedPackage pack : getPackages()) {
      if (pack.getName().equals(packageName))
        return pack;
    }
    return null;
  }",iterator
pack,"{
    for (ContributedPackage pack : getPackages()) {
      if (pack.getName().equals(packageName))
        return pack;
    }
    return null;
  }",break_loop_control
pack,"{
    categories.clear();
    for (ContributedPackage pack : getPackages()) {
      pack.getPlatforms().stream()
        .filter(platform -> !categories.contains(platform.getCategory()))
        .forEach(platform -> categories.add(platform.getCategory()));
    }
  }",iterator
pack,"{
    for (ContributedPackage pack : getPackages()) {
      if (pack.getName().equals(packageName)) {
        return pack;
      }
    }
    return null;
  }",iterator
pack,"{
    for (ContributedPackage pack : getPackages()) {
      if (pack.getName().equals(packageName)) {
        return pack;
      }
    }
    return null;
  }",break_loop_control
c,"{
    String res = """";
    res += ""Categories: "";
    for (String c : getCategories())
      res += ""'"" + c + ""' "";
    res += ""\n"";
    for (ContributedPackage pack : getPackages())
      res += pack + ""\n"";
    return res;
  }",iterator
pack,"{
    String res = """";
    res += ""Categories: "";
    for (String c : getCategories())
      res += ""'"" + c + ""' "";
    res += ""\n"";
    for (ContributedPackage pack : getPackages())
      res += pack + ""\n"";
    return res;
  }",iterator
platform,"{
    if (architecture == null || version == null) {
      return null;
    }
    for (ContributedPlatform platform : getPlatforms()) {
      if (platform.getArchitecture().equals(architecture) && version.equals(platform.getParsedVersion()))
        return platform;
    }
    return null;
  }",iterator
platform,"{
    if (architecture == null || version == null) {
      return null;
    }
    for (ContributedPlatform platform : getPlatforms()) {
      if (platform.getArchitecture().equals(architecture) && version.equals(platform.getParsedVersion()))
        return platform;
    }
    return null;
  }",break_loop_control
tool,"{
    if (getTools() == null) {
      return null;
    }
    for (ContributedTool tool : getTools()) {
      if (tool.getName().equals(name) && tool.getVersion().equals(version))
        return tool;
    }
    return null;
  }",iterator
tool,"{
    if (getTools() == null) {
      return null;
    }
    for (ContributedTool tool : getTools()) {
      if (tool.getName().equals(name) && tool.getVersion().equals(version))
        return tool;
    }
    return null;
  }",break_loop_control
platform,"{
    for (ContributedPlatform platform : getPlatforms()) {
      for (ContributedTool tool : platform.getResolvedTools()) {
        if (toolName.equals(tool.getName()) && version.equals(tool.getVersion())) {
          return tool;
        }
      }
    }
    return null;
  }",iterator
tool,"{
    for (ContributedPlatform platform : getPlatforms()) {
      for (ContributedTool tool : platform.getResolvedTools()) {
        if (toolName.equals(tool.getName()) && version.equals(tool.getVersion())) {
          return tool;
        }
      }
    }
    return null;
  }",iterator
tool,"{
    for (ContributedPlatform platform : getPlatforms()) {
      for (ContributedTool tool : platform.getResolvedTools()) {
        if (toolName.equals(tool.getName()) && version.equals(tool.getVersion())) {
          return tool;
        }
      }
    }
    return null;
  }",break_loop_control
plat,"{
    String res;
    res = ""Package name      : "" + getName() + ""\n"";
    res += ""        maintaner : "" + getMaintainer() + "" ("" + getEmail() + "")\n"";
    if (getPlatforms() != null) {
      for (ContributedPlatform plat : getPlatforms()) {
        res += ""\n        Plaform   : name         : "" + plat.getName();
        if (plat.isInstalled()) {
          res += ""\n                    "" + plat;
        }
        res += ""\n                    category     : "" + plat.getCategory();
        res += ""\n                    architecture : "" +
          plat.getArchitecture() + "" "" + plat.getParsedVersion() + ""\n"";
        if (plat.getToolsDependencies() != null)
          for (ContributedToolReference t : plat.getToolsDependencies()) {
            res += ""                    tool dep     : "" + t.getName() + "" "" +
              t.getVersion() + ""\n"";
          }
        if (plat.getBoards() != null)
          for (ContributedBoard board : plat.getBoards())
            res += ""                    board        : "" + board.getName() +
              ""\n"";
      }
    }
    if (getTools() != null) {
      for (ContributedTool tool : getTools())
        res += tool + ""\n"";
    }
    return res;
  }",iterator
t,"{
    String res;
    res = ""Package name      : "" + getName() + ""\n"";
    res += ""        maintaner : "" + getMaintainer() + "" ("" + getEmail() + "")\n"";
    if (getPlatforms() != null) {
      for (ContributedPlatform plat : getPlatforms()) {
        res += ""\n        Plaform   : name         : "" + plat.getName();
        if (plat.isInstalled()) {
          res += ""\n                    "" + plat;
        }
        res += ""\n                    category     : "" + plat.getCategory();
        res += ""\n                    architecture : "" +
          plat.getArchitecture() + "" "" + plat.getParsedVersion() + ""\n"";
        if (plat.getToolsDependencies() != null)
          for (ContributedToolReference t : plat.getToolsDependencies()) {
            res += ""                    tool dep     : "" + t.getName() + "" "" +
              t.getVersion() + ""\n"";
          }
        if (plat.getBoards() != null)
          for (ContributedBoard board : plat.getBoards())
            res += ""                    board        : "" + board.getName() +
              ""\n"";
      }
    }
    if (getTools() != null) {
      for (ContributedTool tool : getTools())
        res += tool + ""\n"";
    }
    return res;
  }",iterator
board,"{
    String res;
    res = ""Package name      : "" + getName() + ""\n"";
    res += ""        maintaner : "" + getMaintainer() + "" ("" + getEmail() + "")\n"";
    if (getPlatforms() != null) {
      for (ContributedPlatform plat : getPlatforms()) {
        res += ""\n        Plaform   : name         : "" + plat.getName();
        if (plat.isInstalled()) {
          res += ""\n                    "" + plat;
        }
        res += ""\n                    category     : "" + plat.getCategory();
        res += ""\n                    architecture : "" +
          plat.getArchitecture() + "" "" + plat.getParsedVersion() + ""\n"";
        if (plat.getToolsDependencies() != null)
          for (ContributedToolReference t : plat.getToolsDependencies()) {
            res += ""                    tool dep     : "" + t.getName() + "" "" +
              t.getVersion() + ""\n"";
          }
        if (plat.getBoards() != null)
          for (ContributedBoard board : plat.getBoards())
            res += ""                    board        : "" + board.getName() +
              ""\n"";
      }
    }
    if (getTools() != null) {
      for (ContributedTool tool : getTools())
        res += tool + ""\n"";
    }
    return res;
  }",iterator
tool,"{
    String res;
    res = ""Package name      : "" + getName() + ""\n"";
    res += ""        maintaner : "" + getMaintainer() + "" ("" + getEmail() + "")\n"";
    if (getPlatforms() != null) {
      for (ContributedPlatform plat : getPlatforms()) {
        res += ""\n        Plaform   : name         : "" + plat.getName();
        if (plat.isInstalled()) {
          res += ""\n                    "" + plat;
        }
        res += ""\n                    category     : "" + plat.getCategory();
        res += ""\n                    architecture : "" +
          plat.getArchitecture() + "" "" + plat.getParsedVersion() + ""\n"";
        if (plat.getToolsDependencies() != null)
          for (ContributedToolReference t : plat.getToolsDependencies()) {
            res += ""                    tool dep     : "" + t.getName() + "" "" +
              t.getVersion() + ""\n"";
          }
        if (plat.getBoards() != null)
          for (ContributedBoard board : plat.getBoards())
            res += ""                    board        : "" + board.getName() +
              ""\n"";
      }
    }
    if (getTools() != null) {
      for (ContributedTool tool : getTools())
        res += tool + ""\n"";
    }
    return res;
  }",iterator
dep,"{
    resolvedToolReferences = new HashMap<>();

    // If there are no dependencies return empty list
    if (getToolsDependencies() == null) {
      return;
    }

    // For each tool dependency
    for (ContributedToolReference dep : getToolsDependencies()) {
      // Search the referenced tool
      ContributedTool tool = dep.resolve(packages);
      if (tool == null) {
        System.err.println(""Index error: could not find referenced tool "" + dep);
      } else {
        resolvedToolReferences.put(dep, tool);
      }
    }
  }",iterator
tool,"{
    List<String> errors = new LinkedList<>();
    if (contributedPlatform.isInstalled()) {
      throw new Exception(""Platform is already installed!"");
    }

    // Do not download already installed tools
    List<ContributedTool> tools = new ArrayList<>();
    for (ContributedTool tool : contributedPlatform.getResolvedTools()) {
      DownloadableContribution downloadable = tool.getDownloadableContribution(platform);
      if (downloadable == null) {
        throw new Exception(format(tr(""Tool {0} is not available for your operating system.""), tool.getName()));
      }
      // Download the tool if it's not installed or it's a built-in tool
      if (!tool.isInstalled() || tool.isBuiltIn()) {
        tools.add(tool);
      }
    }

    DownloadableContributionsDownloader downloader = new DownloadableContributionsDownloader(BaseNoGui.indexer.getStagingFolder());

    // Calculate progress increases
    MultiStepProgress progress = new MultiStepProgress((tools.size() + 1) * 2);

    // Download all
    try {
      // Download platform
      downloader.download(contributedPlatform, progress, tr(""Downloading boards definitions.""), progressListener, false);
      progress.stepDone();

      // Download tools
      int i = 1;
      for (ContributedTool tool : tools) {
        String msg = format(tr(""Downloading tools ({0}/{1}).""), i, tools.size());
        i++;
        downloader.download(tool.getDownloadableContribution(platform), progress, msg, progressListener, false);
        progress.stepDone();
      }
    } catch (InterruptedException e) {
      // Download interrupted... just exit
      return errors;
    }

    ContributedPackage pack = contributedPlatform.getParentPackage();
    File packageFolder = new File(BaseNoGui.indexer.getPackagesFolder(), pack.getName());

    // TODO: Extract to temporary folders and move to the final destination only
    // once everything is successfully unpacked. If the operation fails remove
    // all the temporary folders and abort installation.

    List<Map.Entry<ContributedToolReference, ContributedTool>> resolvedToolReferences = contributedPlatform
      .getResolvedToolReferences().entrySet().stream()
      .filter((entry) -> !entry.getValue().isInstalled()
        || entry.getValue().isBuiltIn())
      .collect(Collectors.toList());

    int i = 1;
    for (Map.Entry<ContributedToolReference, ContributedTool> entry : resolvedToolReferences) {
      progress.setStatus(format(tr(""Installing tools ({0}/{1})...""), i, resolvedToolReferences.size()));
      progressListener.onProgress(progress);
      i++;
      ContributedTool tool = entry.getValue();
      Path destFolder = Paths.get(BaseNoGui.indexer.getPackagesFolder().getAbsolutePath(), entry.getKey().getPackager(), ""tools"", tool.getName(), tool.getVersion());

      Files.createDirectories(destFolder);

      DownloadableContribution toolContrib = tool.getDownloadableContribution(platform);
      assert toolContrib.getDownloadedFile() != null;
      new ArchiveExtractor(platform).extract(toolContrib.getDownloadedFile(), destFolder.toFile(), 1);
      try {
        findAndExecutePostInstallScriptIfAny(destFolder.toFile(), contributedPlatform.getParentPackage().isTrusted(), PreferencesData.areInsecurePackagesAllowed());
      } catch (IOException e) {
        errors.add(tr(""Error running post install script""));
      }
      tool.setInstalled(true);
      tool.setInstalledFolder(destFolder.toFile());
      progress.stepDone();
    }

    // Unpack platform on the correct location
    progress.setStatus(tr(""Installing boards...""));
    progressListener.onProgress(progress);
    File platformFolder = new File(packageFolder, ""hardware"" + File.separator + contributedPlatform.getArchitecture());
    File destFolder = new File(platformFolder, contributedPlatform.getParsedVersion());
    Files.createDirectories(destFolder.toPath());
    new ArchiveExtractor(platform).extract(contributedPlatform.getDownloadedFile(), destFolder, 1);
    contributedPlatform.setInstalled(true);
    contributedPlatform.setInstalledFolder(destFolder);
    try {
      findAndExecutePostInstallScriptIfAny(destFolder, contributedPlatform.getParentPackage().isTrusted(), PreferencesData.areInsecurePackagesAllowed());
    } catch (IOException e) {
      e.printStackTrace();
      errors.add(tr(""Error running post install script""));
    }
    progress.stepDone();

    progress.setStatus(tr(""Installation completed!""));
    progressListener.onProgress(progress);

    return errors;
  }",iterator
entry,"{
    List<String> errors = new LinkedList<>();
    if (contributedPlatform.isInstalled()) {
      throw new Exception(""Platform is already installed!"");
    }

    // Do not download already installed tools
    List<ContributedTool> tools = new ArrayList<>();
    for (ContributedTool tool : contributedPlatform.getResolvedTools()) {
      DownloadableContribution downloadable = tool.getDownloadableContribution(platform);
      if (downloadable == null) {
        throw new Exception(format(tr(""Tool {0} is not available for your operating system.""), tool.getName()));
      }
      // Download the tool if it's not installed or it's a built-in tool
      if (!tool.isInstalled() || tool.isBuiltIn()) {
        tools.add(tool);
      }
    }

    DownloadableContributionsDownloader downloader = new DownloadableContributionsDownloader(BaseNoGui.indexer.getStagingFolder());

    // Calculate progress increases
    MultiStepProgress progress = new MultiStepProgress((tools.size() + 1) * 2);

    // Download all
    try {
      // Download platform
      downloader.download(contributedPlatform, progress, tr(""Downloading boards definitions.""), progressListener, false);
      progress.stepDone();

      // Download tools
      int i = 1;
      for (ContributedTool tool : tools) {
        String msg = format(tr(""Downloading tools ({0}/{1}).""), i, tools.size());
        i++;
        downloader.download(tool.getDownloadableContribution(platform), progress, msg, progressListener, false);
        progress.stepDone();
      }
    } catch (InterruptedException e) {
      // Download interrupted... just exit
      return errors;
    }

    ContributedPackage pack = contributedPlatform.getParentPackage();
    File packageFolder = new File(BaseNoGui.indexer.getPackagesFolder(), pack.getName());

    // TODO: Extract to temporary folders and move to the final destination only
    // once everything is successfully unpacked. If the operation fails remove
    // all the temporary folders and abort installation.

    List<Map.Entry<ContributedToolReference, ContributedTool>> resolvedToolReferences = contributedPlatform
      .getResolvedToolReferences().entrySet().stream()
      .filter((entry) -> !entry.getValue().isInstalled()
        || entry.getValue().isBuiltIn())
      .collect(Collectors.toList());

    int i = 1;
    for (Map.Entry<ContributedToolReference, ContributedTool> entry : resolvedToolReferences) {
      progress.setStatus(format(tr(""Installing tools ({0}/{1})...""), i, resolvedToolReferences.size()));
      progressListener.onProgress(progress);
      i++;
      ContributedTool tool = entry.getValue();
      Path destFolder = Paths.get(BaseNoGui.indexer.getPackagesFolder().getAbsolutePath(), entry.getKey().getPackager(), ""tools"", tool.getName(), tool.getVersion());

      Files.createDirectories(destFolder);

      DownloadableContribution toolContrib = tool.getDownloadableContribution(platform);
      assert toolContrib.getDownloadedFile() != null;
      new ArchiveExtractor(platform).extract(toolContrib.getDownloadedFile(), destFolder.toFile(), 1);
      try {
        findAndExecutePostInstallScriptIfAny(destFolder.toFile(), contributedPlatform.getParentPackage().isTrusted(), PreferencesData.areInsecurePackagesAllowed());
      } catch (IOException e) {
        errors.add(tr(""Error running post install script""));
      }
      tool.setInstalled(true);
      tool.setInstalledFolder(destFolder.toFile());
      progress.stepDone();
    }

    // Unpack platform on the correct location
    progress.setStatus(tr(""Installing boards...""));
    progressListener.onProgress(progress);
    File platformFolder = new File(packageFolder, ""hardware"" + File.separator + contributedPlatform.getArchitecture());
    File destFolder = new File(platformFolder, contributedPlatform.getParsedVersion());
    Files.createDirectories(destFolder.toPath());
    new ArchiveExtractor(platform).extract(contributedPlatform.getDownloadedFile(), destFolder, 1);
    contributedPlatform.setInstalled(true);
    contributedPlatform.setInstalledFolder(destFolder);
    try {
      findAndExecutePostInstallScriptIfAny(destFolder, contributedPlatform.getParentPackage().isTrusted(), PreferencesData.areInsecurePackagesAllowed());
    } catch (IOException e) {
      e.printStackTrace();
      errors.add(tr(""Error running post install script""));
    }
    progress.stepDone();

    progress.setStatus(tr(""Installation completed!""));
    progressListener.onProgress(progress);

    return errors;
  }",iterator
tool,"{
    if (contributedPlatform == null || contributedPlatform.isBuiltIn()) {
      return new LinkedList<>();
    }
    List<String> errors = new LinkedList<>();
    try {
      findAndExecutePreUninstallScriptIfAny(contributedPlatform.getInstalledFolder(), contributedPlatform.getParentPackage().isTrusted(), PreferencesData.areInsecurePackagesAllowed());
    } catch (IOException e) {
      errors.add(tr(""Error running post install script""));
    }

    // Check if the tools are no longer needed
    for (ContributedTool tool : contributedPlatform.getResolvedTools()) {
      // Do not remove used tools
      if (BaseNoGui.indexer.isContributedToolUsed(contributedPlatform, tool))
        continue;

      // Do not remove built-in tools
      if (tool.isBuiltIn())
        continue;

      // Ok, delete the tool
      File destFolder = tool.getInstalledFolder();
      FileUtils.recursiveDelete(destFolder);
      tool.setInstalled(false);
      tool.setInstalledFolder(null);

      // We removed the version folder (.../tools/TOOL_NAME/VERSION)
      // now try to remove the containing TOOL_NAME folder
      // (and silently fail if another version of the tool is installed)
      try {
        Files.delete(destFolder.getParentFile().toPath());
      } catch (Exception e) {
        // ignore
      }
    }

    FileUtils.recursiveDelete(contributedPlatform.getInstalledFolder());
    contributedPlatform.setInstalled(false);
    contributedPlatform.setInstalledFolder(null);

    return errors;
  }",iterator
packageIndexURLString,"{
    MultiStepProgress progress = new MultiStepProgress(1);

    final DownloadableContributionsDownloader downloader = new DownloadableContributionsDownloader(BaseNoGui.indexer.getStagingFolder());

    final Set<String> packageIndexURLs = new HashSet<>(
      PreferencesData.getCollection(Constants.PREF_BOARDS_MANAGER_ADDITIONAL_URLS)
    );
    packageIndexURLs.add(Constants.PACKAGE_INDEX_URL);

    for (String packageIndexURLString : packageIndexURLs) {
      try {
        // Extract the file name from the URL
        final URL packageIndexURL = new URL(packageIndexURLString);

        downloader.downloadIndexAndSignature(progress, packageIndexURL, progressListener, signatureVerifier);
      } catch (Exception e) {
        System.err.println(e.getMessage());
      }
    }

    progress.stepDone();
  }",iterator
indexFile,"{
    // Read bundled index...
    File bundledIndexFile = new File(builtInHardwareFolder, Constants.BUNDLED_INDEX_FILE_NAME);
    mergeContributions(bundledIndexFile);

    // ...and overlay the default index if present
    File defaultIndexFile = getIndexFile(Constants.DEFAULT_INDEX_FILE_NAME);
    if (defaultIndexFile.exists()) {
      // Check main index signature
      if (signatureVerifier.isSigned(defaultIndexFile)) {
        mergeContributions(defaultIndexFile);
      } else if (PreferencesData.areInsecurePackagesAllowed()) {
        System.err.println(format(tr(""Warning: forced trusting untrusted contributions"")));
        mergeContributions(defaultIndexFile);
      } else {
        BaseNoGui
            .showWarning(Constants.DEFAULT_INDEX_FILE_NAME,
                              tr(""A package index has an invalid signature and needs to be updated.\n""
                                 + ""Please open the Board Manager from the menu\n""
                                 + ""\n"" //
                                 + ""      Tools -> Board -> Board Manager\n""
                                 + ""\nto update it""),
                              null);
      }
    }

    // Set main and bundled indexes as trusted
    index.getPackages().forEach(pack -> pack.setTrusted(true));

    // Overlay 3rd party indexes
    List<File> indexFiles = get3rdPartyIndexFiles();
    for (File indexFile : indexFiles) {
      try {
        mergeContributions(indexFile);
      } catch (JsonProcessingException e) {
        System.err.println(format(tr(""Skipping contributed index file {0}, parsing error occured:""), indexFile));
        System.err.println(e);
      }
    }

    // Fill tools and toolsDependency cross references
    List<ContributedPackage> packages = index.getPackages();
    Collection<ContributedPackage> packagesWithTools = packages.stream()
      .filter(input -> input.getTools() != null && !input.getTools().isEmpty())
      .collect(Collectors.toList());

    for (ContributedPackage pack : packages) {
      // Fill references to package in tools
      for (ContributedTool tool : pack.getTools()) {
        tool.setPackage(pack);
      }

      for (ContributedPlatform plat : pack.getPlatforms()) {
        // Set a reference to parent packages
        plat.setParentPackage(pack);

        // Resolve tools dependencies (works also as a check for file integrity)
        plat.resolveToolsDependencies(packagesWithTools);
      }
    }

    index.fillCategories();
  }",iterator
tool,"{
    // Read bundled index...
    File bundledIndexFile = new File(builtInHardwareFolder, Constants.BUNDLED_INDEX_FILE_NAME);
    mergeContributions(bundledIndexFile);

    // ...and overlay the default index if present
    File defaultIndexFile = getIndexFile(Constants.DEFAULT_INDEX_FILE_NAME);
    if (defaultIndexFile.exists()) {
      // Check main index signature
      if (signatureVerifier.isSigned(defaultIndexFile)) {
        mergeContributions(defaultIndexFile);
      } else if (PreferencesData.areInsecurePackagesAllowed()) {
        System.err.println(format(tr(""Warning: forced trusting untrusted contributions"")));
        mergeContributions(defaultIndexFile);
      } else {
        BaseNoGui
            .showWarning(Constants.DEFAULT_INDEX_FILE_NAME,
                              tr(""A package index has an invalid signature and needs to be updated.\n""
                                 + ""Please open the Board Manager from the menu\n""
                                 + ""\n"" //
                                 + ""      Tools -> Board -> Board Manager\n""
                                 + ""\nto update it""),
                              null);
      }
    }

    // Set main and bundled indexes as trusted
    index.getPackages().forEach(pack -> pack.setTrusted(true));

    // Overlay 3rd party indexes
    List<File> indexFiles = get3rdPartyIndexFiles();
    for (File indexFile : indexFiles) {
      try {
        mergeContributions(indexFile);
      } catch (JsonProcessingException e) {
        System.err.println(format(tr(""Skipping contributed index file {0}, parsing error occured:""), indexFile));
        System.err.println(e);
      }
    }

    // Fill tools and toolsDependency cross references
    List<ContributedPackage> packages = index.getPackages();
    Collection<ContributedPackage> packagesWithTools = packages.stream()
      .filter(input -> input.getTools() != null && !input.getTools().isEmpty())
      .collect(Collectors.toList());

    for (ContributedPackage pack : packages) {
      // Fill references to package in tools
      for (ContributedTool tool : pack.getTools()) {
        tool.setPackage(pack);
      }

      for (ContributedPlatform plat : pack.getPlatforms()) {
        // Set a reference to parent packages
        plat.setParentPackage(pack);

        // Resolve tools dependencies (works also as a check for file integrity)
        plat.resolveToolsDependencies(packagesWithTools);
      }
    }

    index.fillCategories();
  }",iterator
pack,"{
    // Read bundled index...
    File bundledIndexFile = new File(builtInHardwareFolder, Constants.BUNDLED_INDEX_FILE_NAME);
    mergeContributions(bundledIndexFile);

    // ...and overlay the default index if present
    File defaultIndexFile = getIndexFile(Constants.DEFAULT_INDEX_FILE_NAME);
    if (defaultIndexFile.exists()) {
      // Check main index signature
      if (signatureVerifier.isSigned(defaultIndexFile)) {
        mergeContributions(defaultIndexFile);
      } else if (PreferencesData.areInsecurePackagesAllowed()) {
        System.err.println(format(tr(""Warning: forced trusting untrusted contributions"")));
        mergeContributions(defaultIndexFile);
      } else {
        BaseNoGui
            .showWarning(Constants.DEFAULT_INDEX_FILE_NAME,
                              tr(""A package index has an invalid signature and needs to be updated.\n""
                                 + ""Please open the Board Manager from the menu\n""
                                 + ""\n"" //
                                 + ""      Tools -> Board -> Board Manager\n""
                                 + ""\nto update it""),
                              null);
      }
    }

    // Set main and bundled indexes as trusted
    index.getPackages().forEach(pack -> pack.setTrusted(true));

    // Overlay 3rd party indexes
    List<File> indexFiles = get3rdPartyIndexFiles();
    for (File indexFile : indexFiles) {
      try {
        mergeContributions(indexFile);
      } catch (JsonProcessingException e) {
        System.err.println(format(tr(""Skipping contributed index file {0}, parsing error occured:""), indexFile));
        System.err.println(e);
      }
    }

    // Fill tools and toolsDependency cross references
    List<ContributedPackage> packages = index.getPackages();
    Collection<ContributedPackage> packagesWithTools = packages.stream()
      .filter(input -> input.getTools() != null && !input.getTools().isEmpty())
      .collect(Collectors.toList());

    for (ContributedPackage pack : packages) {
      // Fill references to package in tools
      for (ContributedTool tool : pack.getTools()) {
        tool.setPackage(pack);
      }

      for (ContributedPlatform plat : pack.getPlatforms()) {
        // Set a reference to parent packages
        plat.setParentPackage(pack);

        // Resolve tools dependencies (works also as a check for file integrity)
        plat.resolveToolsDependencies(packagesWithTools);
      }
    }

    index.fillCategories();
  }",iterator
plat,"{
    // Read bundled index...
    File bundledIndexFile = new File(builtInHardwareFolder, Constants.BUNDLED_INDEX_FILE_NAME);
    mergeContributions(bundledIndexFile);

    // ...and overlay the default index if present
    File defaultIndexFile = getIndexFile(Constants.DEFAULT_INDEX_FILE_NAME);
    if (defaultIndexFile.exists()) {
      // Check main index signature
      if (signatureVerifier.isSigned(defaultIndexFile)) {
        mergeContributions(defaultIndexFile);
      } else if (PreferencesData.areInsecurePackagesAllowed()) {
        System.err.println(format(tr(""Warning: forced trusting untrusted contributions"")));
        mergeContributions(defaultIndexFile);
      } else {
        BaseNoGui
            .showWarning(Constants.DEFAULT_INDEX_FILE_NAME,
                              tr(""A package index has an invalid signature and needs to be updated.\n""
                                 + ""Please open the Board Manager from the menu\n""
                                 + ""\n"" //
                                 + ""      Tools -> Board -> Board Manager\n""
                                 + ""\nto update it""),
                              null);
      }
    }

    // Set main and bundled indexes as trusted
    index.getPackages().forEach(pack -> pack.setTrusted(true));

    // Overlay 3rd party indexes
    List<File> indexFiles = get3rdPartyIndexFiles();
    for (File indexFile : indexFiles) {
      try {
        mergeContributions(indexFile);
      } catch (JsonProcessingException e) {
        System.err.println(format(tr(""Skipping contributed index file {0}, parsing error occured:""), indexFile));
        System.err.println(e);
      }
    }

    // Fill tools and toolsDependency cross references
    List<ContributedPackage> packages = index.getPackages();
    Collection<ContributedPackage> packagesWithTools = packages.stream()
      .filter(input -> input.getTools() != null && !input.getTools().isEmpty())
      .collect(Collectors.toList());

    for (ContributedPackage pack : packages) {
      // Fill references to package in tools
      for (ContributedTool tool : pack.getTools()) {
        tool.setPackage(pack);
      }

      for (ContributedPlatform plat : pack.getPlatforms()) {
        // Set a reference to parent packages
        plat.setParentPackage(pack);

        // Resolve tools dependencies (works also as a check for file integrity)
        plat.resolveToolsDependencies(packagesWithTools);
      }
    }

    index.fillCategories();
  }",iterator
urlString,"{
    List<File> indexFiles = new ArrayList<>();
    for (String urlString : PreferencesData.getCollection(Constants.PREF_BOARDS_MANAGER_ADDITIONAL_URLS)) {
      URL url;
      try {
        url = new URL(urlString);
        String filename = FilenameUtils.getName(url.getPath());
        indexFiles.add(getIndexFile(filename));
      } catch (MalformedURLException e) {
        System.err.println(format(tr(""Malformed Additional Board Manager URL '{0}': {1}""), urlString, e.getMessage()));
      }
    }

    File[] testIndexFiles = preferencesFolder.listFiles((dir, name) -> {
      if (!new File(dir, name).isFile())
        return false;
      if (!name.startsWith(""test_package_"") || !name.endsWith(""_index.json""))
        return false;
      return true;
    });
    if (testIndexFiles == null) {
      System.err.println(
          format(tr(""Error reading package indexes folder: {0}\n(maybe a permission problem?)""), preferencesFolder));
    }
    indexFiles.addAll(Arrays.asList(testIndexFiles));
    return indexFiles;
  }",iterator
contributedPackage,"{
    if (!indexFile.exists())
      return;

    ContributionsIndex contributionsIndex = parseIndex(indexFile);
    boolean signed = signatureVerifier.isSigned(indexFile);
    boolean trustall = PreferencesData.areInsecurePackagesAllowed();

    for (ContributedPackage contributedPackage : contributionsIndex.getPackages()) {
      contributedPackage.setTrusted(signed || trustall);
      if (!contributedPackage.isTrusted()) {
        for (ContributedPlatform contributedPlatform : contributedPackage.getPlatforms()) {
          contributedPlatform.setCategory(""Contributed"");
        }
      }

      ContributedPackage targetPackage = index.getPackage(contributedPackage.getName());

      if (targetPackage == null) {
        index.getPackages().add(contributedPackage);
      } else {
        if (contributedPackage.isTrusted() || !isPackageNameProtected(contributedPackage)) {
          if (isPackageNameProtected(contributedPackage) && trustall) {
            System.err.println(format(tr(""Warning: forced trusting untrusted contributions"")));
          }
          List<ContributedPlatform> platforms = contributedPackage.getPlatforms();
          if (platforms == null) {
            platforms = new LinkedList<>();
          }
          for (ContributedPlatform contributedPlatform : platforms) {
            ContributedPlatform plat = targetPackage.findPlatform(contributedPlatform.getArchitecture(), contributedPlatform.getVersion());
            if (plat != null) {
              targetPackage.getPlatforms().remove(plat);
            }
            targetPackage.getPlatforms().add(contributedPlatform);
          }
          List<ContributedTool> tools = contributedPackage.getTools();
          if (tools == null) {
            tools = new LinkedList<>();
          }
          for (ContributedTool contributedTool : tools) {
            ContributedTool tool = targetPackage.findTool(contributedTool.getName(), contributedTool.getVersion());
            if (tool != null) {
              targetPackage.getTools().remove(tool);
            }
            targetPackage.getTools().add(contributedTool);
          }
        }
      }
    }
  }",iterator
contributedPlatform,"{
    if (!indexFile.exists())
      return;

    ContributionsIndex contributionsIndex = parseIndex(indexFile);
    boolean signed = signatureVerifier.isSigned(indexFile);
    boolean trustall = PreferencesData.areInsecurePackagesAllowed();

    for (ContributedPackage contributedPackage : contributionsIndex.getPackages()) {
      contributedPackage.setTrusted(signed || trustall);
      if (!contributedPackage.isTrusted()) {
        for (ContributedPlatform contributedPlatform : contributedPackage.getPlatforms()) {
          contributedPlatform.setCategory(""Contributed"");
        }
      }

      ContributedPackage targetPackage = index.getPackage(contributedPackage.getName());

      if (targetPackage == null) {
        index.getPackages().add(contributedPackage);
      } else {
        if (contributedPackage.isTrusted() || !isPackageNameProtected(contributedPackage)) {
          if (isPackageNameProtected(contributedPackage) && trustall) {
            System.err.println(format(tr(""Warning: forced trusting untrusted contributions"")));
          }
          List<ContributedPlatform> platforms = contributedPackage.getPlatforms();
          if (platforms == null) {
            platforms = new LinkedList<>();
          }
          for (ContributedPlatform contributedPlatform : platforms) {
            ContributedPlatform plat = targetPackage.findPlatform(contributedPlatform.getArchitecture(), contributedPlatform.getVersion());
            if (plat != null) {
              targetPackage.getPlatforms().remove(plat);
            }
            targetPackage.getPlatforms().add(contributedPlatform);
          }
          List<ContributedTool> tools = contributedPackage.getTools();
          if (tools == null) {
            tools = new LinkedList<>();
          }
          for (ContributedTool contributedTool : tools) {
            ContributedTool tool = targetPackage.findTool(contributedTool.getName(), contributedTool.getVersion());
            if (tool != null) {
              targetPackage.getTools().remove(tool);
            }
            targetPackage.getTools().add(contributedTool);
          }
        }
      }
    }
  }",iterator
contributedTool,"{
    if (!indexFile.exists())
      return;

    ContributionsIndex contributionsIndex = parseIndex(indexFile);
    boolean signed = signatureVerifier.isSigned(indexFile);
    boolean trustall = PreferencesData.areInsecurePackagesAllowed();

    for (ContributedPackage contributedPackage : contributionsIndex.getPackages()) {
      contributedPackage.setTrusted(signed || trustall);
      if (!contributedPackage.isTrusted()) {
        for (ContributedPlatform contributedPlatform : contributedPackage.getPlatforms()) {
          contributedPlatform.setCategory(""Contributed"");
        }
      }

      ContributedPackage targetPackage = index.getPackage(contributedPackage.getName());

      if (targetPackage == null) {
        index.getPackages().add(contributedPackage);
      } else {
        if (contributedPackage.isTrusted() || !isPackageNameProtected(contributedPackage)) {
          if (isPackageNameProtected(contributedPackage) && trustall) {
            System.err.println(format(tr(""Warning: forced trusting untrusted contributions"")));
          }
          List<ContributedPlatform> platforms = contributedPackage.getPlatforms();
          if (platforms == null) {
            platforms = new LinkedList<>();
          }
          for (ContributedPlatform contributedPlatform : platforms) {
            ContributedPlatform plat = targetPackage.findPlatform(contributedPlatform.getArchitecture(), contributedPlatform.getVersion());
            if (plat != null) {
              targetPackage.getPlatforms().remove(plat);
            }
            targetPackage.getPlatforms().add(contributedPlatform);
          }
          List<ContributedTool> tools = contributedPackage.getTools();
          if (tools == null) {
            tools = new LinkedList<>();
          }
          for (ContributedTool contributedTool : tools) {
            ContributedTool tool = targetPackage.findTool(contributedTool.getName(), contributedTool.getVersion());
            if (tool != null) {
              targetPackage.getTools().remove(tool);
            }
            targetPackage.getTools().add(contributedTool);
          }
        }
      }
    }
  }",iterator
folder,"{
    if (index == null || builtInHardwareFolder == null) {
      return;
    }
    for (File folder : builtInHardwareFolder.listFiles(ONLY_DIRS)) {
      ContributedPackage pack = index.findPackage(folder.getName());
      if (pack == null)
        continue;
      syncBuiltInPackageWithFilesystem(pack, folder);

      File toolsFolder = new File(builtInHardwareFolder, ""tools"");
      if (!toolsFolder.isDirectory())
        continue;

      for (File toolFolder : toolsFolder.listFiles(ONLY_DIRS)) {

        // builtin_tools_versions.txt contains tools versions in the format:
        // ""PACKAGER.TOOL_NAME=TOOL_VERSION""
        // for example:
        // ""arduino.avrdude=6.0.1-arduino5""

        File versionsFile = new File(toolFolder, ""builtin_tools_versions.txt"");
        if (!versionsFile.isFile())
          continue;
        PreferencesMap toolsVersion = new PreferencesMap(versionsFile).subTree(pack.getName());
        for (String name : toolsVersion.keySet()) {
          String version = toolsVersion.get(name);
          ContributedTool tool = syncToolWithFilesystem(pack, toolFolder, name, version);
          if (tool != null)
            tool.setBuiltIn(true);
        }
      }
    }
  }",iterator
toolFolder,"{
    if (index == null || builtInHardwareFolder == null) {
      return;
    }
    for (File folder : builtInHardwareFolder.listFiles(ONLY_DIRS)) {
      ContributedPackage pack = index.findPackage(folder.getName());
      if (pack == null)
        continue;
      syncBuiltInPackageWithFilesystem(pack, folder);

      File toolsFolder = new File(builtInHardwareFolder, ""tools"");
      if (!toolsFolder.isDirectory())
        continue;

      for (File toolFolder : toolsFolder.listFiles(ONLY_DIRS)) {

        // builtin_tools_versions.txt contains tools versions in the format:
        // ""PACKAGER.TOOL_NAME=TOOL_VERSION""
        // for example:
        // ""arduino.avrdude=6.0.1-arduino5""

        File versionsFile = new File(toolFolder, ""builtin_tools_versions.txt"");
        if (!versionsFile.isFile())
          continue;
        PreferencesMap toolsVersion = new PreferencesMap(versionsFile).subTree(pack.getName());
        for (String name : toolsVersion.keySet()) {
          String version = toolsVersion.get(name);
          ContributedTool tool = syncToolWithFilesystem(pack, toolFolder, name, version);
          if (tool != null)
            tool.setBuiltIn(true);
        }
      }
    }
  }",iterator
name,"{
    if (index == null || builtInHardwareFolder == null) {
      return;
    }
    for (File folder : builtInHardwareFolder.listFiles(ONLY_DIRS)) {
      ContributedPackage pack = index.findPackage(folder.getName());
      if (pack == null)
        continue;
      syncBuiltInPackageWithFilesystem(pack, folder);

      File toolsFolder = new File(builtInHardwareFolder, ""tools"");
      if (!toolsFolder.isDirectory())
        continue;

      for (File toolFolder : toolsFolder.listFiles(ONLY_DIRS)) {

        // builtin_tools_versions.txt contains tools versions in the format:
        // ""PACKAGER.TOOL_NAME=TOOL_VERSION""
        // for example:
        // ""arduino.avrdude=6.0.1-arduino5""

        File versionsFile = new File(toolFolder, ""builtin_tools_versions.txt"");
        if (!versionsFile.isFile())
          continue;
        PreferencesMap toolsVersion = new PreferencesMap(versionsFile).subTree(pack.getName());
        for (String name : toolsVersion.keySet()) {
          String version = toolsVersion.get(name);
          ContributedTool tool = syncToolWithFilesystem(pack, toolFolder, name, version);
          if (tool != null)
            tool.setBuiltIn(true);
        }
      }
    }
  }",iterator
platformFolder,"{
    // Scan all hardware folders and mark as installed all the tools found.
    for (File platformFolder : hardwareFolder.listFiles(ONLY_DIRS)) {
      File platformTxt = new File(platformFolder, ""platform.txt"");
      String version = new PreferencesMap(platformTxt).get(""version"");
      ContributedPlatform p = syncHardwareWithFilesystem(pack, platformFolder, platformFolder.getName(), version);
      if (p != null) {
        p.setBuiltIn(true);
      }
    }
  }",iterator
folder,"{
    if (!packagesFolder.isDirectory()) {
      return;
    }

    if (index == null) {
      return;
    }

    // Scan all hardware folders and mark as installed all the
    // platforms found.
    for (File folder : packagesFolder.listFiles(ONLY_DIRS)) {
      ContributedPackage pack = index.findPackage(folder.getName());
      if (pack != null) {
        syncPackageWithFilesystem(pack, folder);
      }
    }
  }",iterator
platformFolder,"{
    // Scan all hardware folders and mark as installed all the tools found.
    File hardwareFolder = new File(root, ""hardware"");
    if (hardwareFolder.isDirectory()) {
      for (File platformFolder : hardwareFolder.listFiles(ONLY_DIRS)) {
        for (File versionFolder : platformFolder.listFiles(ONLY_DIRS)) {
          syncHardwareWithFilesystem(pack, versionFolder, platformFolder.getName(), versionFolder.getName());
        }
      }
    }

    // Scan all tools folders and mark as installed all the tools found.
    File toolsFolder = new File(root, ""tools"");
    if (toolsFolder.isDirectory()) {
      for (File toolFolder : toolsFolder.listFiles(ONLY_DIRS)) {
        for (File versionFolder : toolFolder.listFiles(ONLY_DIRS)) {
          syncToolWithFilesystem(pack, versionFolder, toolFolder.getName(), versionFolder.getName());
        }
      }
    }
  }",iterator
versionFolder,"{
    // Scan all hardware folders and mark as installed all the tools found.
    File hardwareFolder = new File(root, ""hardware"");
    if (hardwareFolder.isDirectory()) {
      for (File platformFolder : hardwareFolder.listFiles(ONLY_DIRS)) {
        for (File versionFolder : platformFolder.listFiles(ONLY_DIRS)) {
          syncHardwareWithFilesystem(pack, versionFolder, platformFolder.getName(), versionFolder.getName());
        }
      }
    }

    // Scan all tools folders and mark as installed all the tools found.
    File toolsFolder = new File(root, ""tools"");
    if (toolsFolder.isDirectory()) {
      for (File toolFolder : toolsFolder.listFiles(ONLY_DIRS)) {
        for (File versionFolder : toolFolder.listFiles(ONLY_DIRS)) {
          syncToolWithFilesystem(pack, versionFolder, toolFolder.getName(), versionFolder.getName());
        }
      }
    }
  }",iterator
toolFolder,"{
    // Scan all hardware folders and mark as installed all the tools found.
    File hardwareFolder = new File(root, ""hardware"");
    if (hardwareFolder.isDirectory()) {
      for (File platformFolder : hardwareFolder.listFiles(ONLY_DIRS)) {
        for (File versionFolder : platformFolder.listFiles(ONLY_DIRS)) {
          syncHardwareWithFilesystem(pack, versionFolder, platformFolder.getName(), versionFolder.getName());
        }
      }
    }

    // Scan all tools folders and mark as installed all the tools found.
    File toolsFolder = new File(root, ""tools"");
    if (toolsFolder.isDirectory()) {
      for (File toolFolder : toolsFolder.listFiles(ONLY_DIRS)) {
        for (File versionFolder : toolFolder.listFiles(ONLY_DIRS)) {
          syncToolWithFilesystem(pack, versionFolder, toolFolder.getName(), versionFolder.getName());
        }
      }
    }
  }",iterator
aPackage,"{
    List<TargetPackage> packages = new ArrayList<>();

    if (index == null) {
      return packages;
    }

    for (ContributedPackage aPackage : index.getPackages()) {
      ContributedTargetPackage targetPackage = new ContributedTargetPackage(aPackage.getName());

      List<ContributedPlatform> platforms = aPackage.getPlatforms().stream() //
          .filter(p -> p.isInstalled()) //
          .collect(Collectors.toList());
      Collections.sort(platforms, ContributedPlatform.BUILTIN_AS_LAST);

      for (ContributedPlatform p : platforms) {
        String arch = p.getArchitecture();
        File folder = p.getInstalledFolder();

        try {
          TargetPlatform targetPlatform = new ContributedTargetPlatform(arch, folder, targetPackage);
          if (!targetPackage.hasPlatform(targetPlatform)) {
            targetPackage.addPlatform(targetPlatform);
          }
        } catch (TargetPlatformException e) {
          System.err.println(e.getMessage());
        }
      }

      if (targetPackage.hasPlatforms()) {
        packages.add(targetPackage);
      }
    }

    Collections.sort(packages, (package1, package2) -> {
      assert package1.getId() != null && package2.getId() != null;
      return package1.getId().toLowerCase().compareTo(package2.getId().toLowerCase());
    });

    return packages;
  }",iterator
p,"{
    List<TargetPackage> packages = new ArrayList<>();

    if (index == null) {
      return packages;
    }

    for (ContributedPackage aPackage : index.getPackages()) {
      ContributedTargetPackage targetPackage = new ContributedTargetPackage(aPackage.getName());

      List<ContributedPlatform> platforms = aPackage.getPlatforms().stream() //
          .filter(p -> p.isInstalled()) //
          .collect(Collectors.toList());
      Collections.sort(platforms, ContributedPlatform.BUILTIN_AS_LAST);

      for (ContributedPlatform p : platforms) {
        String arch = p.getArchitecture();
        File folder = p.getInstalledFolder();

        try {
          TargetPlatform targetPlatform = new ContributedTargetPlatform(arch, folder, targetPackage);
          if (!targetPackage.hasPlatform(targetPlatform)) {
            targetPackage.addPlatform(targetPlatform);
          }
        } catch (TargetPlatformException e) {
          System.err.println(e.getMessage());
        }
      }

      if (targetPackage.hasPlatforms()) {
        packages.add(targetPackage);
      }
    }

    Collections.sort(packages, (package1, package2) -> {
      assert package1.getId() != null && package2.getId() != null;
      return package1.getId().toLowerCase().compareTo(package2.getId().toLowerCase());
    });

    return packages;
  }",iterator
pack,"{
    for (ContributedPackage pack : index.getPackages()) {
      for (ContributedPlatform p : pack.getPlatforms()) {
        if (platformToIgnore.equals(p)) {
          continue;
        }
        if (!p.isInstalled() || p.isBuiltIn()) {
          continue;
        }
        for (ContributedTool requiredTool : p.getResolvedTools()) {
          if (requiredTool.equals(tool))
            return true;
        }
      }
    }
    return false;
  }",iterator
p,"{
    for (ContributedPackage pack : index.getPackages()) {
      for (ContributedPlatform p : pack.getPlatforms()) {
        if (platformToIgnore.equals(p)) {
          continue;
        }
        if (!p.isInstalled() || p.isBuiltIn()) {
          continue;
        }
        for (ContributedTool requiredTool : p.getResolvedTools()) {
          if (requiredTool.equals(tool))
            return true;
        }
      }
    }
    return false;
  }",iterator
requiredTool,"{
    for (ContributedPackage pack : index.getPackages()) {
      for (ContributedPlatform p : pack.getPlatforms()) {
        if (platformToIgnore.equals(p)) {
          continue;
        }
        if (!p.isInstalled() || p.isBuiltIn()) {
          continue;
        }
        for (ContributedTool requiredTool : p.getResolvedTools()) {
          if (requiredTool.equals(tool))
            return true;
        }
      }
    }
    return false;
  }",iterator
requiredTool,"{
    for (ContributedPackage pack : index.getPackages()) {
      for (ContributedPlatform p : pack.getPlatforms()) {
        if (platformToIgnore.equals(p)) {
          continue;
        }
        if (!p.isInstalled() || p.isBuiltIn()) {
          continue;
        }
        for (ContributedTool requiredTool : p.getResolvedTools()) {
          if (requiredTool.equals(tool))
            return true;
        }
      }
    }
    return false;
  }",break_loop_control
pack,"{
    Set<ContributedTool> tools = new HashSet<>();
    if (index == null) {
      return tools;
    }
    for (ContributedPackage pack : index.getPackages()) {
      Collection<ContributedPlatform> platforms = pack.getPlatforms().stream() //
          .filter(p -> p.isInstalled()) //
          .collect(Collectors.toList());
      Map<String, List<ContributedPlatform>> platformsByName = platforms.stream().collect(Collectors.groupingBy(ContributedPlatform::getName));

      platformsByName.forEach((platformName, platformsWithName) -> {
        if (platformsWithName.size() > 1) {
          platformsWithName = platformsWithName.stream() //
              .filter(p -> !p.isBuiltIn()) //
              .collect(Collectors.toList());
        }
        for (ContributedPlatform p : platformsWithName) {
          tools.addAll(p.getResolvedTools());
        }
      });
    }
    return tools;
  }",iterator
p,"{
    Set<ContributedTool> tools = new HashSet<>();
    if (index == null) {
      return tools;
    }
    for (ContributedPackage pack : index.getPackages()) {
      Collection<ContributedPlatform> platforms = pack.getPlatforms().stream() //
          .filter(p -> p.isInstalled()) //
          .collect(Collectors.toList());
      Map<String, List<ContributedPlatform>> platformsByName = platforms.stream().collect(Collectors.groupingBy(ContributedPlatform::getName));

      platformsByName.forEach((platformName, platformsWithName) -> {
        if (platformsWithName.size() > 1) {
          platformsWithName = platformsWithName.stream() //
              .filter(p -> !p.isBuiltIn()) //
              .collect(Collectors.toList());
        }
        for (ContributedPlatform p : platformsWithName) {
          tools.addAll(p.getResolvedTools());
        }
      });
    }
    return tools;
  }",iterator
plat,"{
    for (ContributedPlatform plat : getInstalledPlatforms()) {
      if (plat.getInstalledFolder().equals(targetPlatform.getFolder()))
        return plat;
    }
    return null;
  }",iterator
plat,"{
    for (ContributedPlatform plat : getInstalledPlatforms()) {
      if (plat.getInstalledFolder().equals(targetPlatform.getFolder()))
        return plat;
    }
    return null;
  }",break_loop_control
pack,"{
    for (ContributedPackage pack : packages) {
      assert pack.getTools() != null;
      for (ContributedTool tool : pack.getTools())
        if (tool.getName().equals(getName()) &&
            tool.getVersion().equals(getVersion()) &&
            pack.getName().equals(getPackager()))
          return tool;
    }
    return null;
  }",iterator
tool,"{
    for (ContributedPackage pack : packages) {
      assert pack.getTools() != null;
      for (ContributedTool tool : pack.getTools())
        if (tool.getName().equals(getName()) &&
            tool.getVersion().equals(getVersion()) &&
            pack.getName().equals(getPackager()))
          return tool;
    }
    return null;
  }",iterator
tool,"{
    for (ContributedPackage pack : packages) {
      assert pack.getTools() != null;
      for (ContributedTool tool : pack.getTools())
        if (tool.getName().equals(getName()) &&
            tool.getVersion().equals(getVersion()) &&
            pack.getName().equals(getPackager()))
          return tool;
    }
    return null;
  }",break_loop_control
r,"{
    for (ContributedLibrary r : releases) {
      if (r == lib) {
        selected = r;
        return;
      }
    }
  }",iterator
r,"{
    for (ContributedLibrary r : releases) {
      if (r == lib) {
        selected = r;
        return;
      }
    }
  }",break_loop_control
lib,"{
    // Clear all installed flags
    installedLibraries.clear();

    if (index.getLibraries() == null) {
      return;
    }

    for (ContributedLibrary lib : index.getLibraries()) {
      lib.unsetInstalledUserLibrary();
    }

    // Rescan libraries
    for (UserLibraryFolder folderDesc : librariesFolders) {
      scanInstalledLibraries(folderDesc);
    }

    installedLibraries.stream() //
        .filter(l -> l.getTypes().contains(""Contributed"")) //
        .filter(l -> l.getLocation() == Location.CORE || l.getLocation() == Location.REFERENCED_CORE) //
        .forEach(l -> {
          File libFolder = l.getInstalledFolder();
          Optional<ContributedPlatform> platform = BaseNoGui.indexer.getPlatformByFolder(libFolder);
          if (platform.isPresent()) {
            l.setTypes(Collections.singletonList(platform.get().getCategory()));
          }
        });
  }",iterator
folderDesc,"{
    // Clear all installed flags
    installedLibraries.clear();

    if (index.getLibraries() == null) {
      return;
    }

    for (ContributedLibrary lib : index.getLibraries()) {
      lib.unsetInstalledUserLibrary();
    }

    // Rescan libraries
    for (UserLibraryFolder folderDesc : librariesFolders) {
      scanInstalledLibraries(folderDesc);
    }

    installedLibraries.stream() //
        .filter(l -> l.getTypes().contains(""Contributed"")) //
        .filter(l -> l.getLocation() == Location.CORE || l.getLocation() == Location.REFERENCED_CORE) //
        .forEach(l -> {
          File libFolder = l.getInstalledFolder();
          Optional<ContributedPlatform> platform = BaseNoGui.indexer.getPlatformByFolder(libFolder);
          if (platform.isPresent()) {
            l.setTypes(Collections.singletonList(platform.get().getCategory()));
          }
        });
  }",iterator
list,"{
    File list[] = folderDesc.folder.listFiles(OnlyDirs.ONLY_DIRS);
    // if a bad folder or something like that, this might come back null
    if (list == null)
      return;

    for (File subfolder : list) {
      String subfolderName = subfolder.getName();
      if (!BaseNoGui.isSanitaryName(subfolderName)) {

        // Detect whether the current folder name has already had a notification.
        if (!badLibNotified.contains(subfolderName)) {

          badLibNotified.add(subfolderName);

          String mess = I18n.format(tr(""The library \""{0}\"" cannot be used.\n""
              + ""Library folder names must start with a letter or number, followed by letters,\n""
              + ""numbers, dashes, dots and underscores. Maximum length is 63 characters.""),
              subfolderName);
          BaseNoGui.showMessage(tr(""Ignoring library with bad name""), mess);
        }
        continue;
      }

      try {
        scanLibrary(new UserLibraryFolder(subfolder, folderDesc.location));
      } catch (IOException e) {
        System.out.println(I18n.format(tr(""Invalid library found in {0}: {1}""), subfolder, e.getMessage()));
      }
    }
  }",iterator
lib,"{
    if (name == null || version == null) {
      return null;
    }
    for (ContributedLibrary lib : find(name)) {
      if (version.equals(lib.getParsedVersion())) {
        return lib;
      }
    }
    return null;
  }",iterator
library,"{
    StringBuilder sb = new StringBuilder();
    for (ContributedLibrary library : getLibraries()) {
      sb.append(library.toString());
    }
    return sb.toString();
  }",iterator
lib,"{
    List<String> categories = new LinkedList<>();
    for (ContributedLibrary lib : getLibraries()) {
      if (lib.getCategory() != null && !categories.contains(lib.getCategory())) {
        categories.add(lib.getCategory());
      }
    }
    Collections.sort(categories);

    return categories;
  }",iterator
lib,"{
    Collection<String> typesAccumulator = new HashSet<>();
    for (ContributedLibrary lib : getLibraries()) {
      if (lib.getTypes() != null) {
        typesAccumulator.addAll(lib.getTypes());
      }
    }

    List<String> types = new LinkedList<>(typesAccumulator);
    Collections.sort(types);

    return types;
  }",iterator
dep,"{
    List<ContributedLibraryDependency> requirements = library.getDependencies();
    if (requirements == null) {
      // No deps for this library, great!
      return true;
    }

    for (ContributedLibraryDependency dep : requirements) {

      // If the current solution already contains this dependency, skip over
      boolean alreadyInSolution = solution.stream()
          .anyMatch(l -> l.getName().equals(dep.getName()));
      if (alreadyInSolution)
        continue;

      // Generate possible matching dependencies
      List<ContributedLibrary> possibleDeps = findMatchingDependencies(dep);

      // If there are no dependencies available add as ""missing"" lib
      if (possibleDeps.isEmpty()) {
        solution.add(new UnavailableContributedLibrary(dep));
        continue;
      }

      // Pick the installed version if available
      ContributedLibrary selected;
      Optional<ContributedLibrary> installed = possibleDeps.stream()
          .filter(l -> l.getInstalledLibrary().isPresent()).findAny();
      if (installed.isPresent()) {
        selected = installed.get();
      } else {
        // otherwise pick the latest version
        selected = possibleDeps.stream().reduce(VersionComparator::max).get();
      }

      // Add dependency to the solution and process recursively
      solution.add(selected);
      if (!resolveDependeciesOf(solution, selected)) {
        return false;
      }
    }
    return true;
  }",iterator
selected,"{
    List<ContributedLibraryDependency> requirements = library.getDependencies();
    if (requirements == null) {
      // No deps for this library, great!
      return true;
    }

    for (ContributedLibraryDependency dep : requirements) {

      // If the current solution already contains this dependency, skip over
      boolean alreadyInSolution = solution.stream()
          .anyMatch(l -> l.getName().equals(dep.getName()));
      if (alreadyInSolution)
        continue;

      // Generate possible matching dependencies
      List<ContributedLibrary> possibleDeps = findMatchingDependencies(dep);

      // If there are no dependencies available add as ""missing"" lib
      if (possibleDeps.isEmpty()) {
        solution.add(new UnavailableContributedLibrary(dep));
        continue;
      }

      // Pick the installed version if available
      ContributedLibrary selected;
      Optional<ContributedLibrary> installed = possibleDeps.stream()
          .filter(l -> l.getInstalledLibrary().isPresent()).findAny();
      if (installed.isPresent()) {
        selected = installed.get();
      } else {
        // otherwise pick the latest version
        selected = possibleDeps.stream().reduce(VersionComparator::max).get();
      }

      // Add dependency to the solution and process recursively
      solution.add(selected);
      if (!resolveDependeciesOf(solution, selected)) {
        return false;
      }
    }
    return true;
  }",break_loop_control
lib,"{
    MultiStepProgress progress = new MultiStepProgress(3 * libs.size() + 1);

    for (ContributedLibrary lib : libs) {
      // Do install library (3 steps)
      performInstall(lib, progressListener, progress);
    }

    // Rescan index (1 step)
    rescanLibraryIndex(progress, progressListener);
  }",iterator
reqArch,"{
    if (reqArchs.contains(""*""))
      return true;
    for (String reqArch : reqArchs)
      if (supportsArchitecture(reqArch))
        return true;
    return false;
  }",iterator
reqArch,"{
    if (reqArchs.contains(""*""))
      return true;
    for (String reqArch : reqArchs)
      if (supportsArchitecture(reqArch))
        return true;
    return false;
  }",break_loop_control
a,"{
    String res = """";
    res += ""  ContributedLibrary : "" + getName() + ""\n"";
    res += ""              author : "" + getAuthor() + ""\n"";
    res += ""          maintainer : "" + getMaintainer() + ""\n"";
    res += ""             version : "" + getParsedVersion() + ""\n"";
    res += ""             website : "" + getUrl() + ""\n"";
    res += ""            category : "" + getCategory() + ""\n"";
    res += ""             license : "" + getLicense() + ""\n"";
    res += ""             descrip : "" + getSentence() + ""\n"";
    if (getParagraph() != null && !getParagraph().isEmpty())
      res += ""                       "" + getParagraph() + ""\n"";
    res += ""       architectures : "";
    if (getArchitectures() != null)
      for (String a : getArchitectures()) {
        res += a + "","";
      }
    res += ""\n"";
    res += ""            requires :\n"";
    if (getDependencies() != null)
      for (ContributedLibraryDependency r : getDependencies()) {
        res += ""                       "" + r;
      }
    res += ""\n"";

    // DownloadableContribution
    res += super.toString();

    return res;
  }",iterator
r,"{
    String res = """";
    res += ""  ContributedLibrary : "" + getName() + ""\n"";
    res += ""              author : "" + getAuthor() + ""\n"";
    res += ""          maintainer : "" + getMaintainer() + ""\n"";
    res += ""             version : "" + getParsedVersion() + ""\n"";
    res += ""             website : "" + getUrl() + ""\n"";
    res += ""            category : "" + getCategory() + ""\n"";
    res += ""             license : "" + getLicense() + ""\n"";
    res += ""             descrip : "" + getSentence() + ""\n"";
    if (getParagraph() != null && !getParagraph().isEmpty())
      res += ""                       "" + getParagraph() + ""\n"";
    res += ""       architectures : "";
    if (getArchitectures() != null)
      for (String a : getArchitectures()) {
        res += a + "","";
      }
    res += ""\n"";
    res += ""            requires :\n"";
    if (getDependencies() != null)
      for (ContributedLibraryDependency r : getDependencies()) {
        res += ""                       "" + r;
      }
    res += ""\n"";

    // DownloadableContribution
    res += super.toString();

    return res;
  }",iterator
counter,"{
        int counter = 0;
        List<Byte> newArr = new ArrayList<>();
        while (counter < targetSize && (array.length - 1 - counter >= 0)) {
            newArr.add(0, array[array.length - 1 - counter]);
            counter++;
        }

        int size = newArr.size();
        for (int i = 0; i < (targetSize - size); i++) {

            newArr.add(0, (byte) 0);
        }

        byte[] ret = new byte[newArr.size()];
        for (int i = 0; i < newArr.size(); i++) {
            ret[i] = newArr.get(i);
        }
        return ret;
    }",loop_control
i,"{
        int counter = 0;
        List<Byte> newArr = new ArrayList<>();
        while (counter < targetSize && (array.length - 1 - counter >= 0)) {
            newArr.add(0, array[array.length - 1 - counter]);
            counter++;
        }

        int size = newArr.size();
        for (int i = 0; i < (targetSize - size); i++) {

            newArr.add(0, (byte) 0);
        }

        byte[] ret = new byte[newArr.size()];
        for (int i = 0; i < newArr.size(); i++) {
            ret[i] = newArr.get(i);
        }
        return ret;
    }",loop_control
file,"{
    Set<SketchFile> result = new TreeSet<>(CODE_DOCS_COMPARATOR);
    for (File file : FileUtils.listFiles(folder, false, EXTENSIONS)) {
      if (BaseNoGui.isSanitaryName(FileUtils.splitFilename(file).basename)) {
        result.add(new SketchFile(this, file));
      } else if (showWarnings) {
        System.err.println(I18n.format(tr(""File name {0} is invalid: ignored""), file.getName()));
      }
    }

    if (result.size() == 0)
      throw new IOException(tr(""No valid code files found""));

    return new ArrayList<>(result);
  }",iterator
file,"{
    for (SketchFile file : getFiles()) {
      if (file.isModified())
        file.save();
    }
  }",iterator
file,"{
    for (SketchFile file : files) {
      if (file.isModified())
        return true;
    }
    return false;
  }",iterator
file,"{
    int i = 0;
    for (SketchFile file : files) {
      if (file.getFile().equals(filename))
        return i;
      i++;
    }
    return -1;
  }",iterator
file,"{
    int i = 0;
    for (SketchFile file : files) {
      if (file.getFile().equals(filename))
        return i;
      i++;
    }
    return -1;
  }",break_loop_control
file,"{
    // Check intended rename (throws if there is a problem)
    File newPrimary = checkNewFoldername(newFolder);

    // Rename the sketch folder
    if (!getFolder().renameTo(newFolder))
      throw new IOException(tr(""Failed to rename sketch folder""));

    folder = newFolder;

    // Tell each file about its new name
    for (SketchFile file : files)
      file.renamedTo(new File(newFolder, file.getFileName()));

    // And finally, rename the primary file
    getPrimaryFile().renameTo(newPrimary.getName());
  }",iterator
file,"{
    // Check intented rename (throws if there is a problem)
    File newPrimary = checkNewFoldername(newFolder);

    // Create the folder
    if (!newFolder.mkdirs()) {
      String msg = I18n.format(tr(""Could not create directory \""{0}\""""), newFolder.getAbsolutePath());
      throw new IOException(msg);
    }

    // Save the files to their new location
    for (SketchFile file : files) {
      if (file.isPrimary())
        file.saveAs(newPrimary);
      else
        file.saveAs(new File(newFolder, file.getFileName()));
    }


    // Copy the data folder (this may take a while.. add progress bar?)
    if (getDataFolder().exists()) {
      File newDataFolder = new File(newFolder, ""data"");
      // Check if data folder exits, if not try to create the data folder
      if (!newDataFolder.exists() && !newDataFolder.mkdirs()) {
        String msg = I18n.format(tr(""Could not create directory \""{0}\""""), newFolder.getAbsolutePath());
        throw new IOException(msg);
      }
      // Copy the data files into the new folder
      FileUtils.copy(getDataFolder(), newDataFolder);
    }
    
    // Change folder to the new folder
    folder = newFolder;
    
  }",iterator
c,"{
    int count = 1;
    for (char c : what.toCharArray()) {
      if (c == '\n') count++;
    }
    return count;
  }",iterator
menuId,"{
    TargetBoard board = getTargetBoard();
    if (board == null)
      return null;
    String boardId = board.getId();

    PreferencesMap prefs = new PreferencesMap(board.getPreferences());

    String extendedName = prefs.get(""name"");
    for (String menuId : board.getMenuIds()) {
      if (!board.hasMenu(menuId))
        continue;

      // Get ""custom_[MENU_ID]"" preference (for example ""custom_cpu"")
      String entry = PreferencesData.get(""custom_"" + menuId);
      if (entry != null && entry.startsWith(boardId)) {

        String selectionId = entry.substring(boardId.length() + 1);
        prefs.putAll(board.getMenuPreferences(menuId, selectionId));

        // Update the name with the extended configuration
        extendedName += "", "" + board.getMenuLabel(menuId, selectionId);
      }
    }
    prefs.put(""name"", extendedName);

    // Resolve tools needed for this board
    List<ContributedTool> requiredTools = new ArrayList<>();

    // Add all tools dependencies specified in package index
    ContributedPlatform p = indexer.getContributedPlaform(getTargetPlatform());
    if (p != null)
      requiredTools.addAll(p.getResolvedTools());

    // Add all tools dependencies from the (possibily) referenced core
    String core = prefs.get(""build.core"");
    if (core != null && core.contains("":"")) {
      String split[] = core.split("":"");
      TargetPlatform referenced = BaseNoGui.getCurrentTargetPlatformFromPackage(split[0]);
      if (referenced != null) {
        ContributedPlatform referencedPlatform = indexer.getContributedPlaform(referenced);
        if (referencedPlatform != null)
          requiredTools.addAll(referencedPlatform.getResolvedTools());
      } else {
        String msg = tr(""The current selected board needs the core '{0}' that is not installed."");
        System.out.println(I18n.format(msg, core));
      }
    }

    String prefix = ""runtime.tools."";
    for (ContributedTool tool : requiredTools) {
      File folder = tool.getInstalledFolder();
      if (folder == null) {
        continue;
      }
      String toolPath = folder.getAbsolutePath();
      prefs.put(prefix + tool.getName() + "".path"", toolPath);
      prefs.put(prefix + tool.getName() + ""-"" + tool.getVersion() + "".path"", toolPath);
      PreferencesData.set(prefix + tool.getName() + "".path"", toolPath);
      PreferencesData.set(prefix + tool.getName() + ""-"" + tool.getVersion() + "".path"", toolPath);
    }
    return prefs;
  }",iterator
tool,"{
    TargetBoard board = getTargetBoard();
    if (board == null)
      return null;
    String boardId = board.getId();

    PreferencesMap prefs = new PreferencesMap(board.getPreferences());

    String extendedName = prefs.get(""name"");
    for (String menuId : board.getMenuIds()) {
      if (!board.hasMenu(menuId))
        continue;

      // Get ""custom_[MENU_ID]"" preference (for example ""custom_cpu"")
      String entry = PreferencesData.get(""custom_"" + menuId);
      if (entry != null && entry.startsWith(boardId)) {

        String selectionId = entry.substring(boardId.length() + 1);
        prefs.putAll(board.getMenuPreferences(menuId, selectionId));

        // Update the name with the extended configuration
        extendedName += "", "" + board.getMenuLabel(menuId, selectionId);
      }
    }
    prefs.put(""name"", extendedName);

    // Resolve tools needed for this board
    List<ContributedTool> requiredTools = new ArrayList<>();

    // Add all tools dependencies specified in package index
    ContributedPlatform p = indexer.getContributedPlaform(getTargetPlatform());
    if (p != null)
      requiredTools.addAll(p.getResolvedTools());

    // Add all tools dependencies from the (possibily) referenced core
    String core = prefs.get(""build.core"");
    if (core != null && core.contains("":"")) {
      String split[] = core.split("":"");
      TargetPlatform referenced = BaseNoGui.getCurrentTargetPlatformFromPackage(split[0]);
      if (referenced != null) {
        ContributedPlatform referencedPlatform = indexer.getContributedPlaform(referenced);
        if (referencedPlatform != null)
          requiredTools.addAll(referencedPlatform.getResolvedTools());
      } else {
        String msg = tr(""The current selected board needs the core '{0}' that is not installed."");
        System.out.println(I18n.format(msg, core));
      }
    }

    String prefix = ""runtime.tools."";
    for (ContributedTool tool : requiredTools) {
      File folder = tool.getInstalledFolder();
      if (folder == null) {
        continue;
      }
      String toolPath = folder.getAbsolutePath();
      prefs.put(prefix + tool.getName() + "".path"", toolPath);
      prefs.put(prefix + tool.getName() + ""-"" + tool.getVersion() + "".path"", toolPath);
      PreferencesData.set(prefix + tool.getName() + "".path"", toolPath);
      PreferencesData.set(prefix + tool.getName() + ""-"" + tool.getVersion() + "".path"", toolPath);
    }
    return prefs;
  }",iterator
entry,"{
    if (parser.getGetPref() != null) {
      String value = PreferencesData.get(parser.getGetPref(), null);
      if (value != null) {
        System.out.println(value);
        System.exit(0);
      } else {
        System.exit(4);
      }
    } else {
      System.out.println(""#PREFDUMP#"");
      PreferencesMap prefs = PreferencesData.getMap();
      for (Map.Entry<String, String> entry : prefs.entrySet()) {
        System.out.println(entry.getKey() + ""="" + entry.getValue());
      }
      System.exit(0);
    }
  }",iterator
target,"{
    if (!folder.isDirectory()) {
      return;
    }

    String list[] = folder.list(new OnlyDirs());

    // if a bad folder or something like that, this might come back null
    if (list == null) {
      return;
    }

    // alphabetize list, since it's not always alpha order
    // replaced hella slow bubble sort with this feller for 0093
    Arrays.sort(list, String.CASE_INSENSITIVE_ORDER);

    for (String target : list) {
      // Skip reserved 'tools' folder.
      if (target.equals(""tools"")) {
        continue;
      }
      File subfolder = new File(folder, target);

      TargetPackage targetPackage;
      if (packages.containsKey(target)) {
        targetPackage = packages.get(target);
      } else {
        targetPackage = new LegacyTargetPackage(target);
        packages.put(target, targetPackage);
      }
      try {
        loadTargetPackage(targetPackage, subfolder);
      } catch (TargetPlatformException e) {
        System.out.println(""WARNING: Error loading hardware folder "" + new File(folder, target));
        System.out.println(""  "" + e.getMessage());
      }
    }
  }",iterator
subFolder,"{
    File[] folders = _folder.listFiles(ONLY_DIRS);
    if (folders == null) {
      return;
    }

    for (File subFolder : folders) {
      if (!subFolder.exists() || !subFolder.canRead()) {
        continue;
      }
      String arch = subFolder.getName();
      try {
        TargetPlatform p = new LegacyTargetPlatform(arch, subFolder, targetPackage);
        targetPackage.getPlatforms().put(arch, p);
      } catch (TargetPlatformException e) {
        System.err.println(e.getMessage());
      }
    }

    if (targetPackage.getPlatforms().size() == 0) {
      throw new TargetPlatformException(I18n.format(tr(""No valid hardware definitions found in folder {0}.""), _folder.getName()));
    }
  }",iterator
pack,"{
    for (TargetPackage pack : idx.createTargetPackages()) {
      packages.put(pack.getId(), pack);
    }
  }",iterator
tool,"{
    String prefix = ""runtime.tools."";
    if (removeOldKeys) {
      PreferencesData.removeAllKeysWithPrefix(prefix);
    }

    Map<String, String> latestVersions = new HashMap<>();
    for (ContributedTool tool : installedTools) {
      File installedFolder = tool.getInstalledFolder();
      String toolPath;
      if (installedFolder != null) {
        toolPath = installedFolder.getAbsolutePath();
      } else {
        toolPath = Constants.PREF_REMOVE_PLACEHOLDER;
      }
      String toolName = tool.getName();
      String toolVersion = tool.getVersion();
      PreferencesData.set(prefix + toolName + ""-"" + toolVersion + "".path"", toolPath);
      PreferencesData.set(prefix + tool.getPackager() + ""-"" + toolName + ""-"" + toolVersion + "".path"", toolPath);
      // In the generic tool property put the path of the latest version if more are available
      try {
        if (!latestVersions.containsKey(toolName) || VersionComparator.greaterThan(toolVersion, latestVersions.get(toolName))) {
          latestVersions.put(toolName, toolVersion);
          PreferencesData.set(prefix + toolName + "".path"", toolPath);
        }
      } catch (Exception e) {
        // Ignore invalid versions
      }
    }
  }",iterator
lib,"{
    // Populate importToLibraryTable. Each header filename maps to
    // a list of libraries. Compiler.java will use only the first
    // library on each list. The others are used only to advise
    // user of ambiguously matched and duplicate libraries.
    importToLibraryTable = new HashMap<>();
    for (UserLibrary lib : librariesIndexer.getInstalledLibraries()) {
      try {
        String headers[] = headerListFromIncludePath(lib.getSrcFolder());
        for (String header : headers) {
          LibraryList list = importToLibraryTable.get(header);
          if (list == null) {
            // This is the first library found with this header
            list = new LibraryList();
            list.addFirst(lib);
            importToLibraryTable.put(header, list);
          } else {
            UserLibrary old = list.peekFirst();
            boolean useThisLib = true;
            // This is the case where 2 libraries have a .h header
            // with the same name.  We must decide which library to
            // use when a sketch has #include ""name.h""
            //
            // When all other factors are equal, ""libName"" is
            // used in preference to ""oldName"", because getLibraries()
            // gives the library list in order from less specific to
            // more specific locations.
            //
            // But often one library is more clearly the user's
            // intention to use.  Many cases are tested, always first
            // for ""libName"", then for ""oldName"".
            //
            String name = header.substring(0, header.length() - 2); // name without "".h""
            String oldName = old.getInstalledFolder().getName();  // just the library folder name
            String libName = lib.getInstalledFolder().getName();  // just the library folder name
            //System.out.println(""name conflict: "" + name);
            //System.out.println("" old = "" + oldName + "" -> "" + old.getInstalledFolder().getPath());
            //System.out.println("" new = "" + libName + "" -> "" + lib.getInstalledFolder().getPath());
            String name_lc = name.toLowerCase();
            String oldName_lc = oldName.toLowerCase();
            String libName_lc = libName.toLowerCase();
            // always favor a perfect name match
            if (libName.equals(name)) {
            } else if (oldName.equals(name)) {
                useThisLib = false;
            // check for ""-master"" appended (zip file from github)
            } else if (libName.equals(name+""-master"")) {
            } else if (oldName.equals(name+""-master"")) {
                useThisLib = false;
            // next, favor a match with other stuff appended
            } else if (libName.startsWith(name)) {
            } else if (oldName.startsWith(name)) {
                useThisLib = false;
            // otherwise, favor a match with stuff prepended
            } else if (libName.endsWith(name)) {
            } else if (oldName.endsWith(name)) {
                useThisLib = false;
            // as a last resort, match if stuff prepended and appended
            } else if (libName.contains(name)) {
            } else if (oldName.contains(name)) {
                useThisLib = false;
            // repeat all the above tests, with case insensitive matching
            } else if (libName_lc.equals(name_lc)) {
            } else if (oldName_lc.equals(name_lc)) {
                useThisLib = false;
            } else if (libName_lc.equals(name_lc+""-master"")) {
            } else if (oldName_lc.equals(name_lc+""-master"")) {
                useThisLib = false;
            } else if (libName_lc.startsWith(name_lc)) {
            } else if (oldName_lc.startsWith(name_lc)) {
                useThisLib = false;
            } else if (libName_lc.endsWith(name_lc)) {
            } else if (oldName_lc.endsWith(name_lc)) {
                useThisLib = false;
            } else if (libName_lc.contains(name_lc)) {
            } else if (oldName_lc.contains(name_lc)) {
                useThisLib = false;
            } else {
              // none of these tests matched, so just default to ""libName"".
            }
            if (useThisLib) {
              list.addFirst(lib);
            } else {
              list.addLast(lib);
            }
          }
        }
      } catch (IOException e) {
        showWarning(tr(""Error""), I18n
            .format(""Unable to list header files in {0}"", lib.getSrcFolder()), e);
      }
    }
  }",iterator
header,"{
    // Populate importToLibraryTable. Each header filename maps to
    // a list of libraries. Compiler.java will use only the first
    // library on each list. The others are used only to advise
    // user of ambiguously matched and duplicate libraries.
    importToLibraryTable = new HashMap<>();
    for (UserLibrary lib : librariesIndexer.getInstalledLibraries()) {
      try {
        String headers[] = headerListFromIncludePath(lib.getSrcFolder());
        for (String header : headers) {
          LibraryList list = importToLibraryTable.get(header);
          if (list == null) {
            // This is the first library found with this header
            list = new LibraryList();
            list.addFirst(lib);
            importToLibraryTable.put(header, list);
          } else {
            UserLibrary old = list.peekFirst();
            boolean useThisLib = true;
            // This is the case where 2 libraries have a .h header
            // with the same name.  We must decide which library to
            // use when a sketch has #include ""name.h""
            //
            // When all other factors are equal, ""libName"" is
            // used in preference to ""oldName"", because getLibraries()
            // gives the library list in order from less specific to
            // more specific locations.
            //
            // But often one library is more clearly the user's
            // intention to use.  Many cases are tested, always first
            // for ""libName"", then for ""oldName"".
            //
            String name = header.substring(0, header.length() - 2); // name without "".h""
            String oldName = old.getInstalledFolder().getName();  // just the library folder name
            String libName = lib.getInstalledFolder().getName();  // just the library folder name
            //System.out.println(""name conflict: "" + name);
            //System.out.println("" old = "" + oldName + "" -> "" + old.getInstalledFolder().getPath());
            //System.out.println("" new = "" + libName + "" -> "" + lib.getInstalledFolder().getPath());
            String name_lc = name.toLowerCase();
            String oldName_lc = oldName.toLowerCase();
            String libName_lc = libName.toLowerCase();
            // always favor a perfect name match
            if (libName.equals(name)) {
            } else if (oldName.equals(name)) {
                useThisLib = false;
            // check for ""-master"" appended (zip file from github)
            } else if (libName.equals(name+""-master"")) {
            } else if (oldName.equals(name+""-master"")) {
                useThisLib = false;
            // next, favor a match with other stuff appended
            } else if (libName.startsWith(name)) {
            } else if (oldName.startsWith(name)) {
                useThisLib = false;
            // otherwise, favor a match with stuff prepended
            } else if (libName.endsWith(name)) {
            } else if (oldName.endsWith(name)) {
                useThisLib = false;
            // as a last resort, match if stuff prepended and appended
            } else if (libName.contains(name)) {
            } else if (oldName.contains(name)) {
                useThisLib = false;
            // repeat all the above tests, with case insensitive matching
            } else if (libName_lc.equals(name_lc)) {
            } else if (oldName_lc.equals(name_lc)) {
                useThisLib = false;
            } else if (libName_lc.equals(name_lc+""-master"")) {
            } else if (oldName_lc.equals(name_lc+""-master"")) {
                useThisLib = false;
            } else if (libName_lc.startsWith(name_lc)) {
            } else if (oldName_lc.startsWith(name_lc)) {
                useThisLib = false;
            } else if (libName_lc.endsWith(name_lc)) {
            } else if (oldName_lc.endsWith(name_lc)) {
                useThisLib = false;
            } else if (libName_lc.contains(name_lc)) {
            } else if (oldName_lc.contains(name_lc)) {
                useThisLib = false;
            } else {
              // none of these tests matched, so just default to ""libName"".
            }
            if (useThisLib) {
              list.addFirst(lib);
            } else {
              list.addLast(lib);
            }
          }
        }
      } catch (IOException e) {
        showWarning(tr(""Error""), I18n
            .format(""Unable to list header files in {0}"", lib.getSrcFolder()), e);
      }
    }
  }",iterator
i,"{
    String preferencesFile = null;

    // Do a first pass over the commandline arguments, the rest of them
    // will be processed by the Base constructor. Note that this loop
    // does not look at the last element of args, to prevent crashing
    // when no parameter was specified to an option. Later, Base() will
    // then show an error for these.
    for (int i = 0; i < args.length - 1; i++) {
      if (args[i].equals(""--preferences-file"")) {
        ++i;
        preferencesFile = args[i];
        continue;
      }
    }

    // run static initialization that grabs all the prefs
    PreferencesData.init(absoluteFile(preferencesFile));
  }",loop_control
i,"{
    char c[] = origName.toCharArray();
    StringBuffer buffer = new StringBuffer();

    for (int i = 0; i < c.length; i++) {
      if (((c[i] >= '0') && (c[i] <= '9')) ||
          ((c[i] >= 'a') && (c[i] <= 'z')) ||
          ((c[i] >= 'A') && (c[i] <= 'Z')) ||
          ((i > 0) && (c[i] == '-')) ||
          ((i > 0) && (c[i] == '.'))) {
        buffer.append(c[i]);
      } else {
        buffer.append('_');
      }
    }
    // let's not be ridiculous about the length of filenames.
    // in fact, Mac OS 9 can handle 255 chars, though it can't really
    // deal with filenames longer than 31 chars in the Finder.
    // but limiting to that for sketches would mean setting the
    // upper-bound on the character limit here to 25 characters
    // (to handle the base name + "".class"")
    if (buffer.length() > 63) {
      buffer.setLength(63);
    }
    return buffer.toString();
  }",loop_control
item,"{
    File temp = File.createTempFile(file.getName(), null, file.getParentFile());
    // Split the file content using minimum common separator \n
    // then trim any other character (\r) so saveStrings can print it in the correct
    // format for every OS
    String strArray[] = str.split(""\n"");
    for (String item : strArray) {
      item.trim();
    }
    PApplet.saveStrings(temp, strArray);

    try {
      file = file.toPath().toRealPath().toFile().getCanonicalFile();
    } catch (IOException e) {
    }

    if (file.exists()) {
      boolean result = file.delete();
      if (!result) {
        throw new IOException(
      I18n.format(
        tr(""Could not remove old version of {0}""),
        file.getAbsolutePath()));
      }
    }
    boolean result = temp.renameTo(file);
    if (!result) {
      throw new IOException(
    I18n.format(
      tr(""Could not replace {0}""),
      file.getAbsolutePath()));
    }
  }",iterator
port,"{
    List<String> list = new LinkedList<>();
    for (String port : listSerialsNative()) {
      list.add(port.split(""_"")[0]);
    }
    return list;
  }",iterator
targetPackage,"{
    String vid_pid_iSerial = resolveDeviceAttachedToNative(serial);
    for (TargetPackage targetPackage : packages.values()) {
      for (TargetPlatform targetPlatform : targetPackage.getPlatforms().values()) {
        for (TargetBoard board : targetPlatform.getBoards().values()) {
          List<String> vids = new LinkedList<>(board.getPreferences().subTree(""vid"", 1).values());
          if (!vids.isEmpty()) {
            List<String> pids = new LinkedList<>(board.getPreferences().subTree(""pid"", 1).values());
            List<String> descriptors = new LinkedList<>(board.getPreferences().subTree(""descriptor"", 1).values());
            for (int i = 0; i < vids.size(); i++) {
              String vidPid = vids.get(i) + ""_"" + pids.get(i);
              if (vid_pid_iSerial.toUpperCase().contains(vidPid.toUpperCase())) {
                if (!descriptors.isEmpty()) {
                  boolean matched = false;
                  for (int j = 0; j < descriptors.size(); j++) {
                    if (vid_pid_iSerial.toUpperCase().contains(descriptors.get(j).toUpperCase())) {
                      matched = true;
                      break;
                    }
                  }
                  if (matched == false) {
                    continue;
                  }
                }
                Map<String, Object> boardData = new HashMap<>();
                boardData.put(""board"", board);
                // remove 0x from VID / PID to keep them as reported by liblistserial
                boardData.put(""vid"", vids.get(i).replaceAll(""0x"", """"));
                boardData.put(""pid"", pids.get(i).replaceAll(""0x"", """"));
                String extrafields = vid_pid_iSerial.substring(vidPid.length() + 1);
                String[] parts = extrafields.split(""_"");
                boardData.put(""iserial"", parts[0]);
                return boardData;
              }
            }
          }
        }
      }
    }
    return null;
  }",iterator
targetPlatform,"{
    String vid_pid_iSerial = resolveDeviceAttachedToNative(serial);
    for (TargetPackage targetPackage : packages.values()) {
      for (TargetPlatform targetPlatform : targetPackage.getPlatforms().values()) {
        for (TargetBoard board : targetPlatform.getBoards().values()) {
          List<String> vids = new LinkedList<>(board.getPreferences().subTree(""vid"", 1).values());
          if (!vids.isEmpty()) {
            List<String> pids = new LinkedList<>(board.getPreferences().subTree(""pid"", 1).values());
            List<String> descriptors = new LinkedList<>(board.getPreferences().subTree(""descriptor"", 1).values());
            for (int i = 0; i < vids.size(); i++) {
              String vidPid = vids.get(i) + ""_"" + pids.get(i);
              if (vid_pid_iSerial.toUpperCase().contains(vidPid.toUpperCase())) {
                if (!descriptors.isEmpty()) {
                  boolean matched = false;
                  for (int j = 0; j < descriptors.size(); j++) {
                    if (vid_pid_iSerial.toUpperCase().contains(descriptors.get(j).toUpperCase())) {
                      matched = true;
                      break;
                    }
                  }
                  if (matched == false) {
                    continue;
                  }
                }
                Map<String, Object> boardData = new HashMap<>();
                boardData.put(""board"", board);
                // remove 0x from VID / PID to keep them as reported by liblistserial
                boardData.put(""vid"", vids.get(i).replaceAll(""0x"", """"));
                boardData.put(""pid"", pids.get(i).replaceAll(""0x"", """"));
                String extrafields = vid_pid_iSerial.substring(vidPid.length() + 1);
                String[] parts = extrafields.split(""_"");
                boardData.put(""iserial"", parts[0]);
                return boardData;
              }
            }
          }
        }
      }
    }
    return null;
  }",iterator
board,"{
    String vid_pid_iSerial = resolveDeviceAttachedToNative(serial);
    for (TargetPackage targetPackage : packages.values()) {
      for (TargetPlatform targetPlatform : targetPackage.getPlatforms().values()) {
        for (TargetBoard board : targetPlatform.getBoards().values()) {
          List<String> vids = new LinkedList<>(board.getPreferences().subTree(""vid"", 1).values());
          if (!vids.isEmpty()) {
            List<String> pids = new LinkedList<>(board.getPreferences().subTree(""pid"", 1).values());
            List<String> descriptors = new LinkedList<>(board.getPreferences().subTree(""descriptor"", 1).values());
            for (int i = 0; i < vids.size(); i++) {
              String vidPid = vids.get(i) + ""_"" + pids.get(i);
              if (vid_pid_iSerial.toUpperCase().contains(vidPid.toUpperCase())) {
                if (!descriptors.isEmpty()) {
                  boolean matched = false;
                  for (int j = 0; j < descriptors.size(); j++) {
                    if (vid_pid_iSerial.toUpperCase().contains(descriptors.get(j).toUpperCase())) {
                      matched = true;
                      break;
                    }
                  }
                  if (matched == false) {
                    continue;
                  }
                }
                Map<String, Object> boardData = new HashMap<>();
                boardData.put(""board"", board);
                // remove 0x from VID / PID to keep them as reported by liblistserial
                boardData.put(""vid"", vids.get(i).replaceAll(""0x"", """"));
                boardData.put(""pid"", pids.get(i).replaceAll(""0x"", """"));
                String extrafields = vid_pid_iSerial.substring(vidPid.length() + 1);
                String[] parts = extrafields.split(""_"");
                boardData.put(""iserial"", parts[0]);
                return boardData;
              }
            }
          }
        }
      }
    }
    return null;
  }",iterator
i,"{
    String vid_pid_iSerial = resolveDeviceAttachedToNative(serial);
    for (TargetPackage targetPackage : packages.values()) {
      for (TargetPlatform targetPlatform : targetPackage.getPlatforms().values()) {
        for (TargetBoard board : targetPlatform.getBoards().values()) {
          List<String> vids = new LinkedList<>(board.getPreferences().subTree(""vid"", 1).values());
          if (!vids.isEmpty()) {
            List<String> pids = new LinkedList<>(board.getPreferences().subTree(""pid"", 1).values());
            List<String> descriptors = new LinkedList<>(board.getPreferences().subTree(""descriptor"", 1).values());
            for (int i = 0; i < vids.size(); i++) {
              String vidPid = vids.get(i) + ""_"" + pids.get(i);
              if (vid_pid_iSerial.toUpperCase().contains(vidPid.toUpperCase())) {
                if (!descriptors.isEmpty()) {
                  boolean matched = false;
                  for (int j = 0; j < descriptors.size(); j++) {
                    if (vid_pid_iSerial.toUpperCase().contains(descriptors.get(j).toUpperCase())) {
                      matched = true;
                      break;
                    }
                  }
                  if (matched == false) {
                    continue;
                  }
                }
                Map<String, Object> boardData = new HashMap<>();
                boardData.put(""board"", board);
                // remove 0x from VID / PID to keep them as reported by liblistserial
                boardData.put(""vid"", vids.get(i).replaceAll(""0x"", """"));
                boardData.put(""pid"", pids.get(i).replaceAll(""0x"", """"));
                String extrafields = vid_pid_iSerial.substring(vidPid.length() + 1);
                String[] parts = extrafields.split(""_"");
                boardData.put(""iserial"", parts[0]);
                return boardData;
              }
            }
          }
        }
      }
    }
    return null;
  }",loop_control
j,"{
    String vid_pid_iSerial = resolveDeviceAttachedToNative(serial);
    for (TargetPackage targetPackage : packages.values()) {
      for (TargetPlatform targetPlatform : targetPackage.getPlatforms().values()) {
        for (TargetBoard board : targetPlatform.getBoards().values()) {
          List<String> vids = new LinkedList<>(board.getPreferences().subTree(""vid"", 1).values());
          if (!vids.isEmpty()) {
            List<String> pids = new LinkedList<>(board.getPreferences().subTree(""pid"", 1).values());
            List<String> descriptors = new LinkedList<>(board.getPreferences().subTree(""descriptor"", 1).values());
            for (int i = 0; i < vids.size(); i++) {
              String vidPid = vids.get(i) + ""_"" + pids.get(i);
              if (vid_pid_iSerial.toUpperCase().contains(vidPid.toUpperCase())) {
                if (!descriptors.isEmpty()) {
                  boolean matched = false;
                  for (int j = 0; j < descriptors.size(); j++) {
                    if (vid_pid_iSerial.toUpperCase().contains(descriptors.get(j).toUpperCase())) {
                      matched = true;
                      break;
                    }
                  }
                  if (matched == false) {
                    continue;
                  }
                }
                Map<String, Object> boardData = new HashMap<>();
                boardData.put(""board"", board);
                // remove 0x from VID / PID to keep them as reported by liblistserial
                boardData.put(""vid"", vids.get(i).replaceAll(""0x"", """"));
                boardData.put(""pid"", pids.get(i).replaceAll(""0x"", """"));
                String extrafields = vid_pid_iSerial.substring(vidPid.length() + 1);
                String[] parts = extrafields.split(""_"");
                boardData.put(""iserial"", parts[0]);
                return boardData;
              }
            }
          }
        }
      }
    }
    return null;
  }",loop_control
targetPackage,"{
    assert packages != null;
    assert boardId != null;
    for (TargetPackage targetPackage : packages.values()) {
      for (TargetPlatform targetPlatform : targetPackage.getPlatforms().values()) {
        for (TargetBoard board : targetPlatform.getBoards().values()) {
          if (boardId.equals(board.getId())) {
            return board.getName();
          }
        }
      }
    }
    return null;
  }",iterator
targetPlatform,"{
    assert packages != null;
    assert boardId != null;
    for (TargetPackage targetPackage : packages.values()) {
      for (TargetPlatform targetPlatform : targetPackage.getPlatforms().values()) {
        for (TargetBoard board : targetPlatform.getBoards().values()) {
          if (boardId.equals(board.getId())) {
            return board.getName();
          }
        }
      }
    }
    return null;
  }",iterator
board,"{
    assert packages != null;
    assert boardId != null;
    for (TargetPackage targetPackage : packages.values()) {
      for (TargetPlatform targetPlatform : targetPackage.getPlatforms().values()) {
        for (TargetBoard board : targetPlatform.getBoards().values()) {
          if (boardId.equals(board.getId())) {
            return board.getName();
          }
        }
      }
    }
    return null;
  }",iterator
boardId,"{
    assert packages != null;
    assert boardId != null;
    for (TargetPackage targetPackage : packages.values()) {
      for (TargetPlatform targetPlatform : targetPackage.getPlatforms().values()) {
        for (TargetBoard board : targetPlatform.getBoards().values()) {
          if (boardId.equals(board.getId())) {
            return board.getName();
          }
        }
      }
    }
    return null;
  }",break_loop_control
key,"{
    if (!doSave)
      return;

    if (getBoolean(""preferences.readonly""))
      return;

    // on startup, don't worry about it
    // this is trying to update the prefs for who is open
    // before Preferences.init() has been called.
    if (preferencesFile == null) return;

    // Fix for 0163 to properly use Unicode when writing preferences.txt
    PrintWriter writer = null;
    try {
      writer = PApplet.createWriter(preferencesFile);

      String[] keys = prefs.keySet().toArray(new String[0]);
      Arrays.sort(keys);
      for (String key : keys) {
        if (key.startsWith(""runtime.""))
          continue;
        writer.println(key + ""="" + prefs.get(key));
      }

      writer.flush();
    } catch (Throwable e) {
      System.err.println(format(tr(""Could not write preferences file: {0}""), e.getMessage()));
      return;
    } finally {
      IOUtils.closeQuietly(writer);
    }

    try {
      BaseNoGui.getPlatform().fixPrefsFilePermissions(preferencesFile);
    } catch (Exception e) {
      //ignore
    }
  }",iterator
i,"{

        @Override
        public int compare(String valueA, String valueB) {

            if(valueA.equalsIgnoreCase(valueB)){
                return valueA.compareTo(valueB);
            }

            int minLength = Math.min(valueA.length(), valueB.length());

            int shiftA = 0;
            int shiftB = 0;

            for(int i = 0; i < minLength; i++){
                char charA = valueA.charAt(i - shiftA);
                char charB = valueB.charAt(i - shiftB);
                if(charA != charB){
                    if(Character.isDigit(charA) && Character.isDigit(charB)){
                        int[] resultsA = getNumberAndLastIndex(valueA, i - shiftA);
                        int[] resultsB = getNumberAndLastIndex(valueB, i - shiftB);

                        if(resultsA[0] != resultsB[0]){
                            return resultsA[0] - resultsB[0];
                        }

                        if(valueA.length() < valueB.length()){
                            i = resultsA[1];
                            shiftB = resultsA[1] - resultsB[1];
                        }
                        else {
                            i = resultsB[1];
                            shiftA = resultsB[1] - resultsA[1];
                        }
                    }
                    else {
                        if(Character.toLowerCase(charA) - Character.toLowerCase(charB) != 0){
                            return Character.toLowerCase(charA) - Character.toLowerCase(charB);
                        }
                    }
                }
            }
            return valueA.compareToIgnoreCase(valueB);
        }

        /**
         * Evaluate port <b>index/number</b> from <b>startIndex</b> to the number end. For example:
         * for port name <b>serial-123-FF</b> you should invoke this method with <b>startIndex = 7</b>
         *
         * @return If port <b>index/number</b> correctly evaluated it value will be returned<br>
         * <b>returnArray[0] = index/number</b><br>
         * <b>returnArray[1] = stopIndex</b><br>
         *
         * If incorrect:<br>
         * <b>returnArray[0] = -1</b><br>
         * <b>returnArray[1] = startIndex</b><br>
         *
         * For this name <b>serial-123-FF</b> result is:
         * <b>returnArray[0] = 123</b><br>
         * <b>returnArray[1] = 10</b><br>
         */
        private int[] getNumberAndLastIndex(String str, int startIndex) {
            String numberValue = """";
            int[] returnValues = {-1, startIndex};
            for(int i = startIndex; i < str.length(); i++){
                returnValues[1] = i;
                char c = str.charAt(i);
                if(Character.isDigit(c)){
                    numberValue += c;
                }
                else {
                    break;
                }
            }
            try {
                returnValues[0] = Integer.valueOf(numberValue);
            }
            catch (Exception ex) {
                //Do nothing
            }
            return returnValues;
        }
    }",loop_control
resultsA,"{

        @Override
        public int compare(String valueA, String valueB) {

            if(valueA.equalsIgnoreCase(valueB)){
                return valueA.compareTo(valueB);
            }

            int minLength = Math.min(valueA.length(), valueB.length());

            int shiftA = 0;
            int shiftB = 0;

            for(int i = 0; i < minLength; i++){
                char charA = valueA.charAt(i - shiftA);
                char charB = valueB.charAt(i - shiftB);
                if(charA != charB){
                    if(Character.isDigit(charA) && Character.isDigit(charB)){
                        int[] resultsA = getNumberAndLastIndex(valueA, i - shiftA);
                        int[] resultsB = getNumberAndLastIndex(valueB, i - shiftB);

                        if(resultsA[0] != resultsB[0]){
                            return resultsA[0] - resultsB[0];
                        }

                        if(valueA.length() < valueB.length()){
                            i = resultsA[1];
                            shiftB = resultsA[1] - resultsB[1];
                        }
                        else {
                            i = resultsB[1];
                            shiftA = resultsB[1] - resultsA[1];
                        }
                    }
                    else {
                        if(Character.toLowerCase(charA) - Character.toLowerCase(charB) != 0){
                            return Character.toLowerCase(charA) - Character.toLowerCase(charB);
                        }
                    }
                }
            }
            return valueA.compareToIgnoreCase(valueB);
        }

        /**
         * Evaluate port <b>index/number</b> from <b>startIndex</b> to the number end. For example:
         * for port name <b>serial-123-FF</b> you should invoke this method with <b>startIndex = 7</b>
         *
         * @return If port <b>index/number</b> correctly evaluated it value will be returned<br>
         * <b>returnArray[0] = index/number</b><br>
         * <b>returnArray[1] = stopIndex</b><br>
         *
         * If incorrect:<br>
         * <b>returnArray[0] = -1</b><br>
         * <b>returnArray[1] = startIndex</b><br>
         *
         * For this name <b>serial-123-FF</b> result is:
         * <b>returnArray[0] = 123</b><br>
         * <b>returnArray[1] = 10</b><br>
         */
        private int[] getNumberAndLastIndex(String str, int startIndex) {
            String numberValue = """";
            int[] returnValues = {-1, startIndex};
            for(int i = startIndex; i < str.length(); i++){
                returnValues[1] = i;
                char c = str.charAt(i);
                if(Character.isDigit(c)){
                    numberValue += c;
                }
                else {
                    break;
                }
            }
            try {
                returnValues[0] = Integer.valueOf(numberValue);
            }
            catch (Exception ex) {
                //Do nothing
            }
            return returnValues;
        }
    }",break_loop_control
resultsB,"{

        @Override
        public int compare(String valueA, String valueB) {

            if(valueA.equalsIgnoreCase(valueB)){
                return valueA.compareTo(valueB);
            }

            int minLength = Math.min(valueA.length(), valueB.length());

            int shiftA = 0;
            int shiftB = 0;

            for(int i = 0; i < minLength; i++){
                char charA = valueA.charAt(i - shiftA);
                char charB = valueB.charAt(i - shiftB);
                if(charA != charB){
                    if(Character.isDigit(charA) && Character.isDigit(charB)){
                        int[] resultsA = getNumberAndLastIndex(valueA, i - shiftA);
                        int[] resultsB = getNumberAndLastIndex(valueB, i - shiftB);

                        if(resultsA[0] != resultsB[0]){
                            return resultsA[0] - resultsB[0];
                        }

                        if(valueA.length() < valueB.length()){
                            i = resultsA[1];
                            shiftB = resultsA[1] - resultsB[1];
                        }
                        else {
                            i = resultsB[1];
                            shiftA = resultsB[1] - resultsA[1];
                        }
                    }
                    else {
                        if(Character.toLowerCase(charA) - Character.toLowerCase(charB) != 0){
                            return Character.toLowerCase(charA) - Character.toLowerCase(charB);
                        }
                    }
                }
            }
            return valueA.compareToIgnoreCase(valueB);
        }

        /**
         * Evaluate port <b>index/number</b> from <b>startIndex</b> to the number end. For example:
         * for port name <b>serial-123-FF</b> you should invoke this method with <b>startIndex = 7</b>
         *
         * @return If port <b>index/number</b> correctly evaluated it value will be returned<br>
         * <b>returnArray[0] = index/number</b><br>
         * <b>returnArray[1] = stopIndex</b><br>
         *
         * If incorrect:<br>
         * <b>returnArray[0] = -1</b><br>
         * <b>returnArray[1] = startIndex</b><br>
         *
         * For this name <b>serial-123-FF</b> result is:
         * <b>returnArray[0] = 123</b><br>
         * <b>returnArray[1] = 10</b><br>
         */
        private int[] getNumberAndLastIndex(String str, int startIndex) {
            String numberValue = """";
            int[] returnValues = {-1, startIndex};
            for(int i = startIndex; i < str.length(); i++){
                returnValues[1] = i;
                char c = str.charAt(i);
                if(Character.isDigit(c)){
                    numberValue += c;
                }
                else {
                    break;
                }
            }
            try {
                returnValues[0] = Integer.valueOf(numberValue);
            }
            catch (Exception ex) {
                //Do nothing
            }
            return returnValues;
        }
    }",break_loop_control
c,"{

        @Override
        public int compare(String valueA, String valueB) {

            if(valueA.equalsIgnoreCase(valueB)){
                return valueA.compareTo(valueB);
            }

            int minLength = Math.min(valueA.length(), valueB.length());

            int shiftA = 0;
            int shiftB = 0;

            for(int i = 0; i < minLength; i++){
                char charA = valueA.charAt(i - shiftA);
                char charB = valueB.charAt(i - shiftB);
                if(charA != charB){
                    if(Character.isDigit(charA) && Character.isDigit(charB)){
                        int[] resultsA = getNumberAndLastIndex(valueA, i - shiftA);
                        int[] resultsB = getNumberAndLastIndex(valueB, i - shiftB);

                        if(resultsA[0] != resultsB[0]){
                            return resultsA[0] - resultsB[0];
                        }

                        if(valueA.length() < valueB.length()){
                            i = resultsA[1];
                            shiftB = resultsA[1] - resultsB[1];
                        }
                        else {
                            i = resultsB[1];
                            shiftA = resultsB[1] - resultsA[1];
                        }
                    }
                    else {
                        if(Character.toLowerCase(charA) - Character.toLowerCase(charB) != 0){
                            return Character.toLowerCase(charA) - Character.toLowerCase(charB);
                        }
                    }
                }
            }
            return valueA.compareToIgnoreCase(valueB);
        }

        /**
         * Evaluate port <b>index/number</b> from <b>startIndex</b> to the number end. For example:
         * for port name <b>serial-123-FF</b> you should invoke this method with <b>startIndex = 7</b>
         *
         * @return If port <b>index/number</b> correctly evaluated it value will be returned<br>
         * <b>returnArray[0] = index/number</b><br>
         * <b>returnArray[1] = stopIndex</b><br>
         *
         * If incorrect:<br>
         * <b>returnArray[0] = -1</b><br>
         * <b>returnArray[1] = startIndex</b><br>
         *
         * For this name <b>serial-123-FF</b> result is:
         * <b>returnArray[0] = 123</b><br>
         * <b>returnArray[1] = 10</b><br>
         */
        private int[] getNumberAndLastIndex(String str, int startIndex) {
            String numberValue = """";
            int[] returnValues = {-1, startIndex};
            for(int i = startIndex; i < str.length(); i++){
                returnValues[1] = i;
                char c = str.charAt(i);
                if(Character.isDigit(c)){
                    numberValue += c;
                }
                else {
                    break;
                }
            }
            try {
                returnValues[0] = Integer.valueOf(numberValue);
            }
            catch (Exception ex) {
                //Do nothing
            }
            return returnValues;
        }
    }",break_loop_control
portName,"{
        String[] portNames = serialInterface.getSerialPortNames();
        if(portNames == null){
            return new String[]{};
        }
        TreeSet<String> ports = new TreeSet<>(comparator);
        for(String portName : portNames){
            if(pattern.matcher(portName).find()){
                ports.add(portName);
            }
        }
        return ports.toArray(new String[ports.size()]);
    }",iterator
file,"{
        searchPath = (searchPath.equals("""") ? searchPath : (searchPath.endsWith(""/"") ? searchPath : searchPath + ""/""));
        String[] returnArray = new String[]{};
        File dir = new File(searchPath);
        if(dir.exists() && dir.isDirectory()){
            File[] files = dir.listFiles();
            if(files.length > 0){
                TreeSet<String> portsTree = new TreeSet<>(comparator);
                for(File file : files){
                    String fileName = file.getName();
                    if(!file.isDirectory() && !file.isFile() && pattern.matcher(fileName).find()){
                        String portName = searchPath + fileName;
                        // For linux ttyS0..31 serial ports check existence by opening each of them
                        if (fileName.startsWith(""ttyS"")) {
	                        long portHandle = serialInterface.openPort(portName, false);//Open port without TIOCEXCL
	                        if(portHandle < 0 && portHandle != SerialNativeInterface.ERR_PORT_BUSY){
	                            continue;
	                        }
	                        else if(portHandle != SerialNativeInterface.ERR_PORT_BUSY) {
	                            serialInterface.closePort(portHandle);
	                        }
                        }
                        portsTree.add(portName);
                    }
                }
                returnArray = portsTree.toArray(returnArray);
            }
        }
        return returnArray;
    }",iterator
folder,"{
    if (!file.delete()) {
      return false;
    }

    List<Path> tempBuildFolders = Stream.of(tempBuildFolder, tempBuildFolder.resolve(""sketch""))
        .filter(path -> Files.exists(path)).collect(Collectors.toList());

    for (Path folder : tempBuildFolders) {
      if (!deleteCompiledFilesFrom(folder)) {
        return false;
      }
    }

    sketch.removeFile(this);

    return true;
  }",iterator
folder,"{
    if (!file.delete()) {
      return false;
    }

    List<Path> tempBuildFolders = Stream.of(tempBuildFolder, tempBuildFolder.resolve(""sketch""))
        .filter(path -> Files.exists(path)).collect(Collectors.toList());

    for (Path folder : tempBuildFolders) {
      if (!deleteCompiledFilesFrom(folder)) {
        return false;
      }
    }

    sketch.removeFile(this);

    return true;
  }",break_loop_control
compiledFile,"{
    List<Path> compiledFiles = Files.list(tempBuildFolder)
      .filter(pathname -> pathname.getFileName().toString().startsWith(getFileName()))
      .collect(Collectors.toList());

    for (Path compiledFile : compiledFiles) {
      try {
        Files.delete(compiledFile);
      } catch (IOException e) {
        return false;
      }
    }
    return true;
  }",iterator
l,"{
    for (UserLibrary l : this)
      if (l.getName().equals(name))
        return l;
    return null;
  }",iterator
l,"{
    for (UserLibrary l : this)
      if (l.getName().equals(name))
        return l;
    return null;
  }",break_loop_control
lib,"{
    LibraryList res = new LibraryList();
    for (UserLibrary lib : this) {
      if (FileUtils.isSubDirectory(subFolder, lib.getInstalledFolder())) {
        res.add(lib);
      }
    }
    return res;
  }",iterator
l,"{
    for (UserLibrary l : this)
      if (l == lib) return true;
    return false;
  }",iterator
l,"{
    for (UserLibrary l : this)
      if (l == lib) return true;
    return false;
  }",break_loop_control
p,"{
    File libFolder = libFolderDesc.folder;
    Location location = libFolderDesc.location;

    // Parse metadata
    File propertiesFile = new File(libFolder, ""library.properties"");
    PreferencesMap properties = new PreferencesMap();
    properties.load(propertiesFile);

    // Library sanity checks
    // ---------------------

    // Compatibility with 1.5 rev.1 libraries:
    // ""email"" field changed to ""maintainer""
    if (!properties.containsKey(""maintainer"") && properties.containsKey(""email"")) {
      properties.put(""maintainer"", properties.get(""email""));
    }

    // Compatibility with 1.5 rev.1 libraries:
    // ""arch"" folder no longer supported
    File archFolder = new File(libFolder, ""arch"");
    if (archFolder.isDirectory())
      throw new IOException(""'arch' folder is no longer supported! See http://goo.gl/gfFJzU for more information"");

    // Check mandatory properties
    for (String p : Constants.LIBRARY_MANDATORY_PROPERTIES)
      if (!properties.containsKey(p))
        throw new IOException(""Missing '"" + p + ""' from library"");

    // Check layout
    LibraryLayout layout;
    File srcFolder = new File(libFolder, ""src"");

    if (srcFolder.exists() && srcFolder.isDirectory()) {
      // Layout with a single ""src"" folder and recursive compilation
      layout = LibraryLayout.RECURSIVE;
    } else {
      // Layout with source code on library's root and ""utility"" folders
      layout = LibraryLayout.FLAT;
    }

    // Warn if root folder contains development leftovers
    File[] files = libFolder.listFiles();
    if (files == null) {
      throw new IOException(""Unable to list files of library in "" + libFolder);
    }

    // Extract metadata info
    String architectures = properties.get(""architectures"");
    if (architectures == null)
      architectures = ""*""; // defaults to ""any""
    List<String> archs = new ArrayList<>();
    for (String arch : architectures.split("",""))
      archs.add(arch.trim());

    String category = properties.get(""category"");
    if (category == null) {
      category = ""Uncategorized"";
    }
    if (!Constants.LIBRARY_CATEGORIES.contains(category)) {
      category = ""Uncategorized"";
    }

    String license = properties.get(""license"");
    if (license == null) {
      license = ""Unspecified"";
    }

    String types = properties.get(""types"");
    if (types == null) {
      types = ""Contributed"";
    }
    List<String> typesList = new LinkedList<>();
    for (String type : types.split("","")) {
      typesList.add(type.trim());
    }

    List<String> includes = null;
    if (properties.containsKey(""includes"") && !properties.get(""includes"").trim().isEmpty()) {
      includes = new ArrayList<>();
      for (String i : properties.get(""includes"").split("",""))
        includes.add(i.trim());
    }

    String declaredVersion = properties.get(""version"").trim();
    Optional<Version> version = VersionHelper.valueOf(declaredVersion);
    if (!version.isPresent()) {
      System.out.println(
          format(tr(""Invalid version '{0}' for library in: {1}""), declaredVersion, libFolder.getAbsolutePath()));
    }

    UserLibrary res = new UserLibrary();
    res.installedFolder = libFolder;
    res.name = properties.get(""name"").trim();
    res.version = version.isPresent() ? version.get().toString() : declaredVersion;
    res.author = properties.get(""author"").trim();
    res.maintainer = properties.get(""maintainer"").trim();
    res.sentence = properties.get(""sentence"").trim();
    res.paragraph = properties.get(""paragraph"").trim();
    res.website = properties.get(""url"").trim();
    res.category = category.trim();
    res.license = license.trim();
    res.architectures = archs;
    res.layout = layout;
    res.declaredTypes = typesList;
    res.onGoingDevelopment = Files.exists(Paths.get(libFolder.getAbsolutePath(), Constants.LIBRARY_DEVELOPMENT_FLAG_FILE));
    res.includes = includes;
    res.location = location;
    return res;
  }",iterator
arch,"{
    File libFolder = libFolderDesc.folder;
    Location location = libFolderDesc.location;

    // Parse metadata
    File propertiesFile = new File(libFolder, ""library.properties"");
    PreferencesMap properties = new PreferencesMap();
    properties.load(propertiesFile);

    // Library sanity checks
    // ---------------------

    // Compatibility with 1.5 rev.1 libraries:
    // ""email"" field changed to ""maintainer""
    if (!properties.containsKey(""maintainer"") && properties.containsKey(""email"")) {
      properties.put(""maintainer"", properties.get(""email""));
    }

    // Compatibility with 1.5 rev.1 libraries:
    // ""arch"" folder no longer supported
    File archFolder = new File(libFolder, ""arch"");
    if (archFolder.isDirectory())
      throw new IOException(""'arch' folder is no longer supported! See http://goo.gl/gfFJzU for more information"");

    // Check mandatory properties
    for (String p : Constants.LIBRARY_MANDATORY_PROPERTIES)
      if (!properties.containsKey(p))
        throw new IOException(""Missing '"" + p + ""' from library"");

    // Check layout
    LibraryLayout layout;
    File srcFolder = new File(libFolder, ""src"");

    if (srcFolder.exists() && srcFolder.isDirectory()) {
      // Layout with a single ""src"" folder and recursive compilation
      layout = LibraryLayout.RECURSIVE;
    } else {
      // Layout with source code on library's root and ""utility"" folders
      layout = LibraryLayout.FLAT;
    }

    // Warn if root folder contains development leftovers
    File[] files = libFolder.listFiles();
    if (files == null) {
      throw new IOException(""Unable to list files of library in "" + libFolder);
    }

    // Extract metadata info
    String architectures = properties.get(""architectures"");
    if (architectures == null)
      architectures = ""*""; // defaults to ""any""
    List<String> archs = new ArrayList<>();
    for (String arch : architectures.split("",""))
      archs.add(arch.trim());

    String category = properties.get(""category"");
    if (category == null) {
      category = ""Uncategorized"";
    }
    if (!Constants.LIBRARY_CATEGORIES.contains(category)) {
      category = ""Uncategorized"";
    }

    String license = properties.get(""license"");
    if (license == null) {
      license = ""Unspecified"";
    }

    String types = properties.get(""types"");
    if (types == null) {
      types = ""Contributed"";
    }
    List<String> typesList = new LinkedList<>();
    for (String type : types.split("","")) {
      typesList.add(type.trim());
    }

    List<String> includes = null;
    if (properties.containsKey(""includes"") && !properties.get(""includes"").trim().isEmpty()) {
      includes = new ArrayList<>();
      for (String i : properties.get(""includes"").split("",""))
        includes.add(i.trim());
    }

    String declaredVersion = properties.get(""version"").trim();
    Optional<Version> version = VersionHelper.valueOf(declaredVersion);
    if (!version.isPresent()) {
      System.out.println(
          format(tr(""Invalid version '{0}' for library in: {1}""), declaredVersion, libFolder.getAbsolutePath()));
    }

    UserLibrary res = new UserLibrary();
    res.installedFolder = libFolder;
    res.name = properties.get(""name"").trim();
    res.version = version.isPresent() ? version.get().toString() : declaredVersion;
    res.author = properties.get(""author"").trim();
    res.maintainer = properties.get(""maintainer"").trim();
    res.sentence = properties.get(""sentence"").trim();
    res.paragraph = properties.get(""paragraph"").trim();
    res.website = properties.get(""url"").trim();
    res.category = category.trim();
    res.license = license.trim();
    res.architectures = archs;
    res.layout = layout;
    res.declaredTypes = typesList;
    res.onGoingDevelopment = Files.exists(Paths.get(libFolder.getAbsolutePath(), Constants.LIBRARY_DEVELOPMENT_FLAG_FILE));
    res.includes = includes;
    res.location = location;
    return res;
  }",iterator
type,"{
    File libFolder = libFolderDesc.folder;
    Location location = libFolderDesc.location;

    // Parse metadata
    File propertiesFile = new File(libFolder, ""library.properties"");
    PreferencesMap properties = new PreferencesMap();
    properties.load(propertiesFile);

    // Library sanity checks
    // ---------------------

    // Compatibility with 1.5 rev.1 libraries:
    // ""email"" field changed to ""maintainer""
    if (!properties.containsKey(""maintainer"") && properties.containsKey(""email"")) {
      properties.put(""maintainer"", properties.get(""email""));
    }

    // Compatibility with 1.5 rev.1 libraries:
    // ""arch"" folder no longer supported
    File archFolder = new File(libFolder, ""arch"");
    if (archFolder.isDirectory())
      throw new IOException(""'arch' folder is no longer supported! See http://goo.gl/gfFJzU for more information"");

    // Check mandatory properties
    for (String p : Constants.LIBRARY_MANDATORY_PROPERTIES)
      if (!properties.containsKey(p))
        throw new IOException(""Missing '"" + p + ""' from library"");

    // Check layout
    LibraryLayout layout;
    File srcFolder = new File(libFolder, ""src"");

    if (srcFolder.exists() && srcFolder.isDirectory()) {
      // Layout with a single ""src"" folder and recursive compilation
      layout = LibraryLayout.RECURSIVE;
    } else {
      // Layout with source code on library's root and ""utility"" folders
      layout = LibraryLayout.FLAT;
    }

    // Warn if root folder contains development leftovers
    File[] files = libFolder.listFiles();
    if (files == null) {
      throw new IOException(""Unable to list files of library in "" + libFolder);
    }

    // Extract metadata info
    String architectures = properties.get(""architectures"");
    if (architectures == null)
      architectures = ""*""; // defaults to ""any""
    List<String> archs = new ArrayList<>();
    for (String arch : architectures.split("",""))
      archs.add(arch.trim());

    String category = properties.get(""category"");
    if (category == null) {
      category = ""Uncategorized"";
    }
    if (!Constants.LIBRARY_CATEGORIES.contains(category)) {
      category = ""Uncategorized"";
    }

    String license = properties.get(""license"");
    if (license == null) {
      license = ""Unspecified"";
    }

    String types = properties.get(""types"");
    if (types == null) {
      types = ""Contributed"";
    }
    List<String> typesList = new LinkedList<>();
    for (String type : types.split("","")) {
      typesList.add(type.trim());
    }

    List<String> includes = null;
    if (properties.containsKey(""includes"") && !properties.get(""includes"").trim().isEmpty()) {
      includes = new ArrayList<>();
      for (String i : properties.get(""includes"").split("",""))
        includes.add(i.trim());
    }

    String declaredVersion = properties.get(""version"").trim();
    Optional<Version> version = VersionHelper.valueOf(declaredVersion);
    if (!version.isPresent()) {
      System.out.println(
          format(tr(""Invalid version '{0}' for library in: {1}""), declaredVersion, libFolder.getAbsolutePath()));
    }

    UserLibrary res = new UserLibrary();
    res.installedFolder = libFolder;
    res.name = properties.get(""name"").trim();
    res.version = version.isPresent() ? version.get().toString() : declaredVersion;
    res.author = properties.get(""author"").trim();
    res.maintainer = properties.get(""maintainer"").trim();
    res.sentence = properties.get(""sentence"").trim();
    res.paragraph = properties.get(""paragraph"").trim();
    res.website = properties.get(""url"").trim();
    res.category = category.trim();
    res.license = license.trim();
    res.architectures = archs;
    res.layout = layout;
    res.declaredTypes = typesList;
    res.onGoingDevelopment = Files.exists(Paths.get(libFolder.getAbsolutePath(), Constants.LIBRARY_DEVELOPMENT_FLAG_FILE));
    res.includes = includes;
    res.location = location;
    return res;
  }",iterator
i,"{
    File libFolder = libFolderDesc.folder;
    Location location = libFolderDesc.location;

    // Parse metadata
    File propertiesFile = new File(libFolder, ""library.properties"");
    PreferencesMap properties = new PreferencesMap();
    properties.load(propertiesFile);

    // Library sanity checks
    // ---------------------

    // Compatibility with 1.5 rev.1 libraries:
    // ""email"" field changed to ""maintainer""
    if (!properties.containsKey(""maintainer"") && properties.containsKey(""email"")) {
      properties.put(""maintainer"", properties.get(""email""));
    }

    // Compatibility with 1.5 rev.1 libraries:
    // ""arch"" folder no longer supported
    File archFolder = new File(libFolder, ""arch"");
    if (archFolder.isDirectory())
      throw new IOException(""'arch' folder is no longer supported! See http://goo.gl/gfFJzU for more information"");

    // Check mandatory properties
    for (String p : Constants.LIBRARY_MANDATORY_PROPERTIES)
      if (!properties.containsKey(p))
        throw new IOException(""Missing '"" + p + ""' from library"");

    // Check layout
    LibraryLayout layout;
    File srcFolder = new File(libFolder, ""src"");

    if (srcFolder.exists() && srcFolder.isDirectory()) {
      // Layout with a single ""src"" folder and recursive compilation
      layout = LibraryLayout.RECURSIVE;
    } else {
      // Layout with source code on library's root and ""utility"" folders
      layout = LibraryLayout.FLAT;
    }

    // Warn if root folder contains development leftovers
    File[] files = libFolder.listFiles();
    if (files == null) {
      throw new IOException(""Unable to list files of library in "" + libFolder);
    }

    // Extract metadata info
    String architectures = properties.get(""architectures"");
    if (architectures == null)
      architectures = ""*""; // defaults to ""any""
    List<String> archs = new ArrayList<>();
    for (String arch : architectures.split("",""))
      archs.add(arch.trim());

    String category = properties.get(""category"");
    if (category == null) {
      category = ""Uncategorized"";
    }
    if (!Constants.LIBRARY_CATEGORIES.contains(category)) {
      category = ""Uncategorized"";
    }

    String license = properties.get(""license"");
    if (license == null) {
      license = ""Unspecified"";
    }

    String types = properties.get(""types"");
    if (types == null) {
      types = ""Contributed"";
    }
    List<String> typesList = new LinkedList<>();
    for (String type : types.split("","")) {
      typesList.add(type.trim());
    }

    List<String> includes = null;
    if (properties.containsKey(""includes"") && !properties.get(""includes"").trim().isEmpty()) {
      includes = new ArrayList<>();
      for (String i : properties.get(""includes"").split("",""))
        includes.add(i.trim());
    }

    String declaredVersion = properties.get(""version"").trim();
    Optional<Version> version = VersionHelper.valueOf(declaredVersion);
    if (!version.isPresent()) {
      System.out.println(
          format(tr(""Invalid version '{0}' for library in: {1}""), declaredVersion, libFolder.getAbsolutePath()));
    }

    UserLibrary res = new UserLibrary();
    res.installedFolder = libFolder;
    res.name = properties.get(""name"").trim();
    res.version = version.isPresent() ? version.get().toString() : declaredVersion;
    res.author = properties.get(""author"").trim();
    res.maintainer = properties.get(""maintainer"").trim();
    res.sentence = properties.get(""sentence"").trim();
    res.paragraph = properties.get(""paragraph"").trim();
    res.website = properties.get(""url"").trim();
    res.category = category.trim();
    res.license = license.trim();
    res.architectures = archs;
    res.layout = layout;
    res.declaredTypes = typesList;
    res.onGoingDevelopment = Files.exists(Paths.get(libFolder.getAbsolutePath(), Constants.LIBRARY_DEVELOPMENT_FLAG_FILE));
    res.includes = includes;
    res.location = location;
    return res;
  }",iterator
port,"{
    if (showAll) {
      return super.filterPorts(ports, true);
    }

    List<BoardPort> filteredPorts = new LinkedList<>();
    for (BoardPort port : ports) {
      if (!port.getAddress().startsWith(""/dev/tty."")) {
        filteredPorts.add(port);
      }
    }

    return filteredPorts;
  }",iterator
i,"{
    // No problems on linux and mac
    if (!OSUtils.isWindows()) {
      return Runtime.getRuntime().exec(command);
    }

    // Brutal hack to workaround windows command line parsing.
    // http://stackoverflow.com/questions/5969724/java-runtime-exec-fails-to-escape-characters-properly
    // http://msdn.microsoft.com/en-us/library/a1y7w461.aspx
    // http://bugs.sun.com/view_bug.do?bug_id=6468220
    // http://bugs.sun.com/view_bug.do?bug_id=6518827
    String[] cmdLine = new String[command.length];
    for (int i = 0; i < command.length; i++)
      cmdLine[i] = command[i].replace(""\"""", ""\\\"""");

    ProcessBuilder pb = new ProcessBuilder(cmdLine);
    Map<String, String> env = pb.environment();
    env.put(""CYGWIN"", ""nodosfilewarning"");
    return pb.start();
  }",loop_control
i,"{
    // If the key is not missing -> everything is OK
    String checkedValue = inDict.get(key);
    if (checkedValue != null && !checkedValue.isEmpty())
      return;

    PreferencesMap dict = new PreferencesMap(inDict);

    // Find a random tag that is not contained in the dictionary and the src pattern
    String tag;
    while (true) {
      tag = UUID.randomUUID().toString();
      if (src.contains(tag))
        continue;
      if (dict.values().contains(tag))
        continue;
      if (dict.keySet().contains(tag))
        continue;
      break;
    }

    // Inject tag inside the dictionary
    dict.put(key, tag);

    // Recursive replace with a max depth of 10 levels.
    String res;
    for (int i = 0; i < 10; i++) {
      // Do a replace with dictionary
      res = StringReplacer.replaceFromMapping(src, dict);
      if (res.equals(src))
        break;
      src = res;
    }

    // If the resulting string contains the tag, then the key is required
    if (src.contains(tag)) {
      throw new PreferencesMapException(key);
    }
  }",loop_control
res,"{
    // If the key is not missing -> everything is OK
    String checkedValue = inDict.get(key);
    if (checkedValue != null && !checkedValue.isEmpty())
      return;

    PreferencesMap dict = new PreferencesMap(inDict);

    // Find a random tag that is not contained in the dictionary and the src pattern
    String tag;
    while (true) {
      tag = UUID.randomUUID().toString();
      if (src.contains(tag))
        continue;
      if (dict.values().contains(tag))
        continue;
      if (dict.keySet().contains(tag))
        continue;
      break;
    }

    // Inject tag inside the dictionary
    dict.put(key, tag);

    // Recursive replace with a max depth of 10 levels.
    String res;
    for (int i = 0; i < 10; i++) {
      // Do a replace with dictionary
      res = StringReplacer.replaceFromMapping(src, dict);
      if (res.equals(src))
        break;
      src = res;
    }

    // If the resulting string contains the tag, then the key is required
    if (src.contains(tag)) {
      throw new PreferencesMapException(key);
    }
  }",break_loop_control
i,"{
    String res;

    // Recursive replace with a max depth of 10 levels.
    for (int i = 0; i < 10; i++) {
      // Do a replace with dictionary
      res = StringReplacer.replaceFromMapping(src, dict);
      if (res.equals(src))
        break;
      src = res;
    }

    // Split the resulting string in arguments
    return quotedSplit(src, ""\""'"", false);
  }",loop_control
res,"{
    String res;

    // Recursive replace with a max depth of 10 levels.
    for (int i = 0; i < 10; i++) {
      // Do a replace with dictionary
      res = StringReplacer.replaceFromMapping(src, dict);
      if (res.equals(src))
        break;
      src = res;
    }

    // Split the resulting string in arguments
    return quotedSplit(src, ""\""'"", false);
  }",break_loop_control
i,"{
    List<String> res = new ArrayList<>();
    String escapedArg = null;
    String escapingChar = null;
    for (String i : src.split("" "")) {
      if (escapingChar == null) {
        // If the first char is not an escape char..
        String first = null;
        if (i.length() > 0)
          first = i.substring(0, 1);
        if (first == null || !quoteChars.contains(first)) {
          if (i.trim().length() != 0 || acceptEmptyArguments)
            res.add(i);
          continue;
        }

        escapingChar = first;
        i = i.substring(1);
        escapedArg = """";
      }

      if (!i.endsWith(escapingChar)) {
        escapedArg += i + "" "";
        continue;
      }

      escapedArg += i.substring(0, i.length() - 1);
      if (escapedArg.trim().length() != 0 || acceptEmptyArguments)
        res.add(escapedArg);
      escapingChar = null;
    }
    if (escapingChar != null)
      throw new Exception(""Invalid quoting: no closing ["" + escapingChar +
          ""] char found."");
    return res.toArray(new String[0]);
  }",iterator
entry,"{
    for (Map.Entry<String, String> entry : map.entrySet()) {
      String keyword = leftDelimiter + entry.getKey() + rightDelimiter;
      if (entry.getValue() != null && keyword != null) {
          src = src.replace(keyword, entry.getValue());
      }
    }
    return src;
  }",iterator
port,"{
    if (isReachableByEcho(address)) {
      return true;
    }

    boolean reachable = false;
    for (Integer port : ports) {
      reachable = reachable || isPortOpen(address, port);
    }

    return reachable;
  }",iterator
targetPackage,"{
    assert packages != null;
    assert boardId != null;
    for (TargetPackage targetPackage : packages.values()) {
      for (TargetPlatform targetPlatform : targetPackage.getPlatforms().values()) {
        for (TargetBoard board : targetPlatform.getBoards().values()) {
          if (boardId.equals(board.getId())) {
            return board.getName();
          }
        }
      }
    }
    return null;
  }",iterator
targetPlatform,"{
    assert packages != null;
    assert boardId != null;
    for (TargetPackage targetPackage : packages.values()) {
      for (TargetPlatform targetPlatform : targetPackage.getPlatforms().values()) {
        for (TargetBoard board : targetPlatform.getBoards().values()) {
          if (boardId.equals(board.getId())) {
            return board.getName();
          }
        }
      }
    }
    return null;
  }",iterator
board,"{
    assert packages != null;
    assert boardId != null;
    for (TargetPackage targetPackage : packages.values()) {
      for (TargetPlatform targetPlatform : targetPackage.getPlatforms().values()) {
        for (TargetBoard board : targetPlatform.getBoards().values()) {
          if (boardId.equals(board.getId())) {
            return board.getName();
          }
        }
      }
    }
    return null;
  }",iterator
line,"{
    String[] lines = PApplet.loadStrings(input);
    for (String line : lines) {
      if (line.length() == 0 || line.charAt(0) == '#')
        continue;

      int equals = line.indexOf('=');
      if (equals != -1) {
        String key = line.substring(0, equals).trim();
        String value = line.substring(equals + 1).trim();

        key = processPlatformSuffix(key, "".linux"", OSUtils.isLinux());
        key = processPlatformSuffix(key, "".windows"", OSUtils.isWindows());
        key = processPlatformSuffix(key, "".macosx"", OSUtils.isMacOS());

        if (key != null)
          put(key, value);
      }
    }
  }",iterator
key,"{
    PreferencesMap res = new PreferencesMap();
    for (String key : keySet()) {
      if (key.contains("".""))
        continue;
      res.put(key, get(key));
    }
    return res;
  }",iterator
key,"{
    Map<String, PreferencesMap> res = new LinkedHashMap<>();
    for (String key : keySet()) {
      int dot = key.indexOf('.');
      if (dot == -1)
        continue;

      String parent = key.substring(0, dot);
      String child = key.substring(dot + 1);

      if (!res.containsKey(parent))
        res.put(parent, new PreferencesMap());
      res.get(parent).put(child, get(key));
    }
    return res;
  }",iterator
key,"{
    PreferencesMap res = new PreferencesMap();
    parent += ""."";
    int parentLen = parent.length();
    for (String key : keySet()) {
      if (key.startsWith(parent)) {
        String newKey = key.substring(parentLen);
        int keySubLevels = newKey.split(""\\."").length;
        if (sublevels == -1 || keySubLevels == sublevels) {
          res.put(newKey, get(key));
        }
      }
    }
    return res;
  }",iterator
k,"{
    String res = indent + ""{\n"";
    SortedSet<String> treeSet = new TreeSet<>(keySet());
    for (String k : treeSet)
      res += indent + ""  "" + k + "" = "" + get(k) + ""\n"";
    res += indent + ""}\n"";
    return res;
  }",iterator
parentFile,"{
    try {
      base = base.getCanonicalFile();
      child = child.getCanonicalFile();
    } catch (IOException e) {
      return false;
    }

    File parentFile = child;
    while (parentFile != null) {
      if (base.equals(parentFile)) {
        return true;
      }
      parentFile = parentFile.getParentFile();
    }
    return false;
  }",maybe_loop_control
readBytes,"{
    FileInputStream fis = null;
    FileOutputStream fos = null;
    try {
      fis = new FileInputStream(source);
      fos = new FileOutputStream(dest);
      byte[] buf = new byte[4096];
      int readBytes = -1;
      while ((readBytes = fis.read(buf, 0, buf.length)) != -1) {
        fos.write(buf, 0, readBytes);
      }
    } finally {
      IOUtils.closeQuietly(fis);
      IOUtils.closeQuietly(fos);
    }
  }",maybe_loop_control
file,"{
    for (File file : sourceFolder.listFiles()) {
      File destFile = new File(destFolder, file.getName());
      if (file.isDirectory() && !SOURCE_CONTROL_FOLDERS.contains(file.getName())) {
        if (!destFile.exists() && !destFile.mkdir()) {
          throw new IOException(""Unable to create folder: "" + destFile);
        }
        copy(file, destFile);
      } else if (!file.isDirectory()) {
        copyFile(file, destFile);
      }
    }
  }",iterator
current,"{
    if (file == null) {
      return;
    }
    if (file.isDirectory()) {
      File[] files = file.listFiles();
      if (files == null) {
        return;
      }
      for (File current : files) {
        recursiveDelete(current);
      }
    }
    file.delete();
  }",iterator
line,"{
    BufferedReader reader = null;
    try {
      reader = new BufferedReader(new InputStreamReader(new FileInputStream(file), encoding));
      StringBuilder sb = new StringBuilder();
      String line;
      while ((line = reader.readLine()) != null) {
        sb.append(line).append(""\n"");
      }
      return sb.toString();
    } finally {
      IOUtils.closeQuietly(reader);
    }
  }",maybe_loop_control
file,"{
    List<File> result = new ArrayList<>();
    if (!folder.exists()) {
      return result;
    }

    for (File file : folder.listFiles()) {
      if (isSCCSOrHiddenFile(file))
        continue;

      if (file.isDirectory()) {
        if (recursive)
          result.addAll(listFiles(file, true, extensions));
        continue;
      }

      if (extensions.isEmpty() || hasExtension(file, extensions))
        result.add(file);
    }
    return result;
  }",iterator
i,"{
    for (int i = 0; i < args.length; i++) {
      ACTION a = actions.get(args[i]);
      if (a != null) {
        if (action != ACTION.GUI && action != ACTION.NOOP) {
          Set<String> strings = actions.keySet();
          String[] valid = strings.toArray(new String[strings.size()]);
          String mess = I18n.format(tr(""Can only pass one of: {0}""), PApplet.join(valid, "", ""));
          BaseNoGui.showError(null, mess, 3);
        }
        if (a == ACTION.GET_PREF) {
          i++;
          if (i < args.length) {
            getPref = args[i];
          }
        }
        if (a == ACTION.INSTALL_BOARD) {
          i++;
          if (i >= args.length) {
            BaseNoGui.showError(null, I18n.format(tr(""Argument required for {0}""), a.value), 3);
          }
          boardToInstall = args[i];
        }
        if (a == ACTION.INSTALL_LIBRARY) {
          i++;
          if (i >= args.length) {
            BaseNoGui.showError(null, I18n.format(tr(""Argument required for {0}""), a.value), 3);
          }
          libraryToInstall = args[i];
        }
        action = a;
        continue;
      }
      if (args[i].startsWith(""-psn"")) {
        //discard
        continue;
      }
      if (args[i].equals(""--verbose"") || args[i].equals(""-v"")) {
        doVerboseBuild = true;
        doVerboseUpload = true;
        if (action == ACTION.GUI)
          action = ACTION.NOOP;
        continue;
      }
      if (args[i].equals(""--preserve-temp-files"")) {
        preserveTempFiles = true;
        if (action == ACTION.GUI)
          action = ACTION.NOOP;
        continue;
      }
      if (args[i].equals(""--verbose-build"")) {
        doVerboseBuild = true;
        if (action == ACTION.GUI)
          action = ACTION.NOOP;
        continue;
      }
      if (args[i].equals(""--verbose-upload"")) {
        doVerboseUpload = true;
        if (action == ACTION.GUI)
          action = ACTION.NOOP;
        continue;
      }
      if (args[i].equals(""--useprogrammer"")) {
        doUseProgrammer = true;
        if (action == ACTION.GUI)
          action = ACTION.NOOP;
        continue;
      }
      if (args[i].equals(""--nouploadport"")) {
        noUploadPort = true;
        if (action == ACTION.GUI)
          action = ACTION.NOOP;
        continue;
      }
      if (args[i].equals(""--board"")) {
        i++;
        if (i >= args.length)
          BaseNoGui.showError(null, tr(""Argument required for --board""), 3);
        if (action == ACTION.GUI)
          action = ACTION.NOOP;
        continue;
      }
      if (args[i].equals(""--port"")) {
        i++;
        if (i >= args.length)
          BaseNoGui.showError(null, tr(""Argument required for --port""), 3);
        uploadPort = Optional.of(args[i]);
        if (action == ACTION.GUI)
          action = ACTION.NOOP;
        continue;
      }
      if (args[i].equals(""--curdir"")) {
        BaseNoGui.showError(null, tr(""--curdir no longer supported""), 3);
        return;
      }
      if (args[i].equals(""--buildpath"")) {
        i++;
        if (i >= args.length) {
          BaseNoGui.showError(null, ""Argument required for --buildpath"", 3);
        }
        File buildFolder = new File(args[i]);
        if (!buildFolder.exists()) {
          BaseNoGui.showError(null, ""The build path doesn't exist"", 3);
        }
        if (!buildFolder.isDirectory()) {
          BaseNoGui.showError(null, ""The build path is not a folder"", 3);
        }
        PreferencesData.set(""build.path"", buildFolder.getAbsolutePath());
        continue;
      }
      if (args[i].equals(""--pref"")) {
        i++;
        if (i >= args.length)
          BaseNoGui.showError(null, tr(""Argument required for --pref""), 3);
        processPrefArgument(args[i]);
        if (action == ACTION.GUI)
          action = ACTION.NOOP;
        continue;
      }
      if (args[i].equals(""--save-prefs"")) {
        forceSavePrefs = true;
        continue;
      }
      if (args[i].equals(""--preferences-file"")) {
        i++;
        if (i >= args.length)
          BaseNoGui.showError(null, tr(""Argument required for --preferences-file""), 3);
        // Argument should be already processed by Base.main(...)
        continue;
      }
      if (args[i].startsWith(""--""))
        BaseNoGui.showError(null, I18n.format(tr(""unknown option: {0}""), args[i]), 3);

      filenames.add(args[i]);
    }

    checkAction();
  }",loop_control
i,"{
    for (int i = 0; i < args.length; i++) {
      if (args[i].equals(""--board"")) {
        i++;
        if (i >= args.length) {
          BaseNoGui.showError(null, tr(""Argument required for --board""), 3);
        }
        processBoardArgument(args[i]);
        if (action == ACTION.GUI) {
          action = ACTION.NOOP;
        }
      }
    }
  }",loop_control
option,"{
    // No board selected? Nothing to do
    if (selectBoard == null)
      return;

    String[] split = selectBoard.split("":"", 4);

    if (split.length < 3) {
      BaseNoGui.showError(null, I18n.format(tr(""{0}: Invalid board name, it should be of the form \""package:arch:board\"" or \""package:arch:board:options\""""), selectBoard), 3);
    }

    TargetPackage targetPackage = BaseNoGui.getTargetPackage(split[0]);
    if (targetPackage == null) {
      BaseNoGui.showError(null, I18n.format(tr(""{0}: Unknown package""), split[0]), 3);
      return;
    }

    TargetPlatform targetPlatform = targetPackage.get(split[1]);
    if (targetPlatform == null) {
      BaseNoGui.showError(null, I18n.format(tr(""{0}: Unknown architecture""), split[1]), 3);
      return;
    }

    TargetBoard targetBoard = targetPlatform.getBoard(split[2]);
    if (targetBoard == null || !targetBoard.getId().equals(split[2])) {
      BaseNoGui.showError(null, I18n.format(tr(""{0}: Unknown board""), split[2]), 3);
      return;
    }

    BaseNoGui.selectBoard(targetBoard);
    BaseNoGui.onBoardOrPortChange();

    if (split.length > 3) {
      String[] options = split[3].split("","");
      for (String option : options) {
        String[] keyValue = option.split(""="", 2);

        if (keyValue.length != 2)
          BaseNoGui.showError(null, I18n.format(tr(""{0}: Invalid option, should be of the form \""name=value\""""), option, targetBoard.getId()), 3);
        String key = keyValue[0].trim();
        String value = keyValue[1].trim();

        if (!targetBoard.hasMenu(key))
          BaseNoGui.showError(null, I18n.format(tr(""{0}: Invalid option for board \""{1}\""""), key, targetBoard.getId()), 3);
        if (targetBoard.getMenuLabel(key, value) == null)
          BaseNoGui.showError(null, I18n.format(tr(""{0}: Invalid value for option \""{1}\"" for board \""{2}\""""), value, key, targetBoard.getId()), 3);

        PreferencesData.set(""custom_"" + key, targetBoard.getId() + ""_"" + value);
      }
    }
  }",iterator
ext,"{
    for (String ext : extensions) {
      if (name.endsWith(ext)) {
        return true;
      }
    }
    return false;
  }",iterator
name,"{
    for (String ext : extensions) {
      if (name.endsWith(ext)) {
        return true;
      }
    }
    return false;
  }",break_loop_control
line,"{
    BufferedReader reader = new BufferedReader(new StringReader(output));
    String line;
    while ((line = reader.readLine()) != null) {
      String[] lineParts = line.split("" "");
      if (lineParts.length > 0 && lineParts[0].toUpperCase().equals(serial.toUpperCase())) {
        String vidPidPart = lineParts[lineParts.length - 1];
        Matcher vidMatcher = vidRegExp.matcher(vidPidPart);
        Matcher pidMatcher = pidRegExp.matcher(vidPidPart);
        if (vidMatcher.find() && pidMatcher.find()) {
          return (""0x"" + vidMatcher.group(1) + ""_0x"" + pidMatcher.group(1)).toUpperCase();
        }
      }
    }

    return null;
  }",iterator
vidMatcher,"{
    BufferedReader reader = new BufferedReader(new StringReader(output));
    String line;
    while ((line = reader.readLine()) != null) {
      String[] lineParts = line.split("" "");
      if (lineParts.length > 0 && lineParts[0].toUpperCase().equals(serial.toUpperCase())) {
        String vidPidPart = lineParts[lineParts.length - 1];
        Matcher vidMatcher = vidRegExp.matcher(vidPidPart);
        Matcher pidMatcher = pidRegExp.matcher(vidPidPart);
        if (vidMatcher.find() && pidMatcher.find()) {
          return (""0x"" + vidMatcher.group(1) + ""_0x"" + pidMatcher.group(1)).toUpperCase();
        }
      }
    }

    return null;
  }",break_loop_control
pidMatcher,"{
    BufferedReader reader = new BufferedReader(new StringReader(output));
    String line;
    while ((line = reader.readLine()) != null) {
      String[] lineParts = line.split("" "");
      if (lineParts.length > 0 && lineParts[0].toUpperCase().equals(serial.toUpperCase())) {
        String vidPidPart = lineParts[lineParts.length - 1];
        Matcher vidMatcher = vidRegExp.matcher(vidPidPart);
        Matcher pidMatcher = pidRegExp.matcher(vidPidPart);
        if (vidMatcher.find() && pidMatcher.find()) {
          return (""0x"" + vidMatcher.group(1) + ""_0x"" + pidMatcher.group(1)).toUpperCase();
        }
      }
    }

    return null;
  }",break_loop_control
lineParts,"{
    BufferedReader reader = new BufferedReader(new StringReader(output));
    String line;
    while ((line = reader.readLine()) != null) {
      String[] lineParts = line.split("" "");
      if (lineParts.length > 0 && lineParts[0].toUpperCase().equals(serial.toUpperCase())) {
        String vidPidPart = lineParts[lineParts.length - 1];
        Matcher vidMatcher = vidRegExp.matcher(vidPidPart);
        Matcher pidMatcher = pidRegExp.matcher(vidPidPart);
        if (vidMatcher.find() && pidMatcher.find()) {
          return (""0x"" + vidMatcher.group(1) + ""_0x"" + pidMatcher.group(1)).toUpperCase();
        }
      }
    }

    return null;
  }",break_loop_control
item,"{
    String path = System.getProperty(""java.library.path"");
    String[] pieces = PApplet.split(path, File.pathSeparatorChar);
    String[] legit = new String[pieces.length];
    int legitCount = 0;
    for (String item : pieces) {
      if (item.startsWith(""\"""")) {
        item = item.substring(1);
      }
      if (item.endsWith(""\"""")) {
        item = item.substring(0, item.length() - 1);
      }
      if (item.endsWith(File.separator)) {
        item = item.substring(0, item.length() - File.separator.length());
      }
      File directory = new File(item);
      if (!directory.exists()) {
        continue;
      }
      if (item.trim().length() == 0) {
        continue;
      }
      legit[legitCount++] = item;
    }
    legit = PApplet.subset(legit, 0, legitCount);
    String newPath = PApplet.join(legit, File.pathSeparator);
    if (!newPath.equals(path)) {
      System.setProperty(""java.library.path"", newPath);
    }
  }",iterator
toker,"{
    StringTokenizer toker = new StringTokenizer(what, delim);
    String pieces[] = new String[toker.countTokens()];

    int index = 0;
    while (toker.hasMoreTokens()) {
      pieces[index++] = toker.nextToken();
    }
    return pieces;
  }",maybe_loop_control
i,"{
    // do this so that the exception occurs inside the user's
    // program, rather than appearing to be a bug inside split()
    if (what == null)
      return null;

    char chars[] = what.toCharArray();
    int splitCount = 0; // 1;
    for (int i = 0; i < chars.length; i++) {
      if (chars[i] == delim)
        splitCount++;
    }
    if (splitCount == 0) {
      String splits[] = new String[1];
      splits[0] = new String(what);
      return splits;
    }
    String splits[] = new String[splitCount + 1];
    int splitIndex = 0;
    int startIndex = 0;
    for (int i = 0; i < chars.length; i++) {
      if (chars[i] == delim) {
        splits[splitIndex++] = new String(chars, startIndex, i - startIndex);
        startIndex = i + 1;
      }
    }
    splits[splitIndex] = new String(chars, startIndex, chars.length
                                                       - startIndex);
    return splits;
  }",loop_control
i,"{
    StringBuffer buffer = new StringBuffer();
    for (int i = 0; i < str.length; i++) {
      if (i != 0) buffer.append(separator);
      buffer.append(str[i]);
    }
    return buffer.toString();
  }",loop_control
i,"{
    int output[] = new int[what.length];
    for (int i = 0; i < what.length; i++) {
      try {
        output[i] = Integer.parseInt(what[i]);
      } catch (NumberFormatException e) {
        output[i] = missing;
      }
    }
    return output;
  }",loop_control
line,"{
    BufferedReader reader = null;
    try {
      reader = new BufferedReader(new InputStreamReader(input, ""UTF-8""));

      String lines[] = new String[100];
      int lineCount = 0;
      String line = null;
      while ((line = reader.readLine()) != null) {
        if (lineCount == lines.length) {
          String temp[] = new String[lineCount << 1];
          System.arraycopy(lines, 0, temp, 0, lineCount);
          lines = temp;
        }
        lines[lineCount++] = line;
      }

      if (lineCount == lines.length) {
        return lines;
      }

      // resize array to appropriate amount for these lines
      String output[] = new String[lineCount];
      System.arraycopy(lines, 0, output, 0, lineCount);
      return output;

    } catch (IOException e) {
      e.printStackTrace();
      //throw new RuntimeException(""Error inside loadStrings()"");
    } finally {
      IOUtils.closeQuietly(reader);
    }
    return null;
  }",maybe_loop_control
string,"{
    PrintWriter writer = null;
    try {
      writer = createWriter(output);
      if (writer == null) {
        return;
      }
      for (String string : strings) {
        writer.println(string);
      }
      writer.flush();
    } finally {
      IOUtils.closeQuietly(writer);
    }
  }",iterator
m,"{
    Pattern p = Pattern.compile(regexp, Pattern.MULTILINE | Pattern.DOTALL);
    Matcher m = p.matcher(what);
    ArrayList<String[]> results = new ArrayList<>();
    int count = m.groupCount() + 1;
    while (m.find()) {
      String[] groups = new String[count];
      for (int i = 0; i < count; i++) {
        groups[i] = m.group(i);
      }
      results.add(groups);
    }
    if (results.isEmpty()) {
      return null;
    }
    String[][] matches = new String[results.size()][count];
    for (int i = 0; i < matches.length; i++) {
      matches[i] = results.get(i);
    }
    return matches;
  }",maybe_loop_control
i,"{
    Pattern p = Pattern.compile(regexp, Pattern.MULTILINE | Pattern.DOTALL);
    Matcher m = p.matcher(what);
    ArrayList<String[]> results = new ArrayList<>();
    int count = m.groupCount() + 1;
    while (m.find()) {
      String[] groups = new String[count];
      for (int i = 0; i < count; i++) {
        groups[i] = m.group(i);
      }
      results.add(groups);
    }
    if (results.isEmpty()) {
      return null;
    }
    String[][] matches = new String[results.size()][count];
    for (int i = 0; i < matches.length; i++) {
      matches[i] = results.get(i);
    }
    return matches;
  }",loop_control
i,"{
    Matcher m = pattern.matcher(what);
    if (m.find()) {
      int count = m.groupCount() + 1;
      String[] groups = new String[count];
      for (int i = 0; i < count; i++) {
        groups[i] = m.group(i);
      }
      return groups;
    }
    return null;
  }",loop_control
i,"{
    String formatted[] = new String[num.length];
    for (int i = 0; i < formatted.length; i++) {
      formatted[i] = nf(num[i], digits);
    }
    return formatted;
  }",loop_control
i,"{
    String s[] = new String[x.length];
    for (int i = 0; i < x.length; i++) s[i] = String.valueOf(x[i]);
    return s;
  }",loop_control
boardId,"{

    id = _name;
    folder = _folder;
    containerPackage = parent;

    // If there is no boards.txt, this is not a valid 1.5 hardware folder
    File boardsFile = new File(folder, ""boards.txt"");
    if (!boardsFile.exists() || !boardsFile.canRead())
      throw new TargetPlatformException(
          format(tr(""Could not find boards.txt in {0}. Is it pre-1.5?""),
                 folder.getAbsolutePath()));

    // Load boards
    try {
      PreferencesMap bPrefs = new PreferencesMap(
          boardsFile);

      // Allow overriding values in boards.txt. This allows changing
      // boards.txt (e.g. to add user-specific items to a menu), without
      // having to modify boards.txt (which, when running from git,
      // prevents files being marked as changed).
      File localboardsFile = new File(folder, ""boards.local.txt"");
      try {
        if (localboardsFile.exists() && localboardsFile.canRead()) {
          bPrefs.load(localboardsFile);
        }
      } catch (IOException e) {
        throw new TargetPlatformException(
            format(tr(""Error loading {0}""), localboardsFile.getAbsolutePath()), e);
      }
      Map<String, PreferencesMap> boardsPreferences = bPrefs.firstLevelMap();

      // Create custom menus for this platform
      PreferencesMap menus = boardsPreferences.get(""menu"");
      if (menus != null)
        customMenus = menus.topLevelMap();
      boardsPreferences.remove(""menu"");

      // Create boards
      Set<String> boardIds = boardsPreferences.keySet();
      for (String boardId : boardIds) {
        PreferencesMap prefs = boardsPreferences.get(boardId);
        TargetBoard board = new LegacyTargetBoard(boardId, prefs, this);
        boards.put(boardId, board);

        // Pick the first board as default
        if (defaultBoard == null)
          defaultBoard = board;
      }
    } catch (IOException e) {
      throw new TargetPlatformException(format(tr(""Error loading {0}""),
                                               boardsFile.getAbsolutePath()), e);
    }

    File platformsFile = new File(folder, ""platform.txt"");
    try {
      if (platformsFile.exists() && platformsFile.canRead()) {
        preferences.load(platformsFile);
      }
    } catch (IOException e) {
      throw new TargetPlatformException(
          format(tr(""Error loading {0}""), platformsFile.getAbsolutePath()), e);
    }

    // Allow overriding values in platform.txt. This allows changing
    // platform.txt (e.g. to use a system-wide toolchain), without
    // having to modify platform.txt (which, when running from git,
    // prevents files being marked as changed).
    File localPlatformsFile = new File(folder, ""platform.local.txt"");
    try {
      if (localPlatformsFile.exists() && localPlatformsFile.canRead()) {
        preferences.load(localPlatformsFile);
      }
    } catch (IOException e) {
      throw new TargetPlatformException(
          format(tr(""Error loading {0}""), localPlatformsFile.getAbsolutePath()), e);
    }

    if (!preferences.containsKey(""rewriting"") || !""disabled"".equals(preferences.get(""rewriting""))) {
      try {
        rewriteKeysOfOldPlatformsTxtAndWarnAboutIt();
      } catch (IOException e) {
        throw new TargetPlatformException(e);
      }
    }

    File progFile = new File(folder, ""programmers.txt"");
    try {
      if (progFile.exists() && progFile.canRead()) {
        PreferencesMap prefs = new PreferencesMap();
        prefs.load(progFile);
        programmers = prefs.firstLevelMap();
      }
    } catch (IOException e) {
      throw new TargetPlatformException(format(tr(""Error loading {0}""),
                                               progFile.getAbsolutePath()), e);
    }
  }",iterator
entry,"{
    File platformRewrite = new File(BaseNoGui.getHardwareFolder(), ""platform.keys.rewrite.txt"");
    PreferencesMap platformRewriteProps = new PreferencesMap(platformRewrite);

    PreferencesMap oldProps = platformRewriteProps.subTree(""old"");
    PreferencesMap newProps = platformRewriteProps.subTree(""new"");

    for (Map.Entry<String, String> entry : oldProps.entrySet()) {
      String preferencesKey = entry.getKey().substring(entry.getKey().indexOf(""."") + 1);
      if (preferences.containsKey(preferencesKey) && entry.getValue().equals(preferences.get(preferencesKey))) {
        preferences.put(preferencesKey, newProps.get(entry.getKey()));
      }
    }

    PreferencesMap addedProps = platformRewriteProps.subTree(""added"");
    for (Map.Entry<String, String> entry : addedProps.entrySet()) {
      String keyToAdd = entry.getKey();
      String[] keyToAddParts = keyToAdd.split(""\\."");
      String keyToAddFirstLevel = keyToAddParts[0];
      String keyToAddSecondLevel = keyToAddParts[0] + ""."" + keyToAddParts[1];
      if (!preferences.subTree(keyToAddFirstLevel).isEmpty() && !preferences.subTree(keyToAddSecondLevel).isEmpty() && !preferences.containsKey(keyToAdd)) {
        preferences.put(keyToAdd, entry.getValue());
      }
    }
  }",iterator
boardId,"{
    String res = ""TargetPlatform: name="" + id + "" boards={\n"";
    for (String boardId : boards.keySet())
      res += ""  "" + boardId + "" = "" + boards.get(boardId) + ""\n"";
    return res + ""}"";
  }",iterator
running,"{

    int r = 0;
    try {
      String pattern = prefs.get(""recipe.size.pattern"");
      String cmd[] = StringReplacer.formatAndSplit(pattern, prefs);

      exception = null;
      textSize = -1;
      dataSize = -1;
      eepromSize = -1;
      Process process = ProcessUtils.exec(cmd);
      MessageSiphon in = new MessageSiphon(process.getInputStream(), this);
      MessageSiphon err = new MessageSiphon(process.getErrorStream(), this);

      boolean running = true;
      while(running) {
        try {
          in.join();
          err.join();
          r = process.waitFor();
          running = false;
        } catch (InterruptedException intExc) { }
      }
    } catch (Exception e) {
      // The default Throwable.toString() never returns null, but apparently
      // some sub-class has overridden it to do so, thus we need to check for
      // it.  See: http://www.arduino.cc/cgi-bin/yabb2/YaBB.pl?num=1166589459
      exception = new RunnerException(
        (e.toString() == null) ? e.getClass().getName() + r : e.toString() + r);
    }
    
    if (exception != null)
      throw exception;
      
    if (textSize == -1)
      throw new RunnerException(firstLine);
      
    return new long[] { textSize, dataSize, eepromSize };
  }",maybe_loop_control
canRun,"{
    try {
      // process data until we hit EOF; this will happily block
      // (effectively sleeping the thread) until new data comes in.
      // when the program is finally done, null will come through.
      //
      StringBuilder currentLine = new StringBuilder();
      long lineStartTime = 0;
      while (canRun) {
        // First, try to read as many characters as possible. Take care
        // not to block when:
        //  1. lineTimeout is nonzero, and
        //  2. we have some characters buffered already
        while (lineTimeout == 0 || currentLine.length() == 0 || streamReader.ready()) {
          int c = streamReader.read();
          if (c == -1)
            return; // EOF
          if (!canRun)
            return;

          // Keep track of the line start time
          if (currentLine.length() == 0)
            lineStartTime = System.nanoTime();

          // Store the character line
          currentLine.append((char)c);

          if (c == '\n') {
            // We read a full line, pass it on
            consumer.message(currentLine.toString());
            currentLine.setLength(0);
          }
        }

        // No more characters available. Wait until lineTimeout
        // milliseconds have passed since the start of the line and then
        // try reading again. If the time has already passed, then just
        // pass on the characters read so far.
        long passed = (System.nanoTime() - lineStartTime) / 1000;
        if (passed < this.lineTimeout) {
          Thread.sleep(this.lineTimeout - passed);
          continue;
        }

        consumer.message(currentLine.toString());
        currentLine.setLength(0);
      }
      //EditorConsole.systemOut.println(""messaging thread done"");
    } catch (NullPointerException npe) {
      // Fairly common exception during shutdown
    } catch (SocketException e) {
      // socket has been close while we were wainting for data. nothing to see here, move along
    } catch (Exception e) {
      // On Linux and sometimes on Mac OS X, a ""bad file descriptor""
      // message comes up when closing an applet that's run externally.
      // That message just gets supressed here..
      String mess = e.getMessage();
      if ((mess != null) &&
              (mess.indexOf(""Bad file descriptor"") != -1)) {
        //if (e.getMessage().indexOf(""Bad file descriptor"") == -1) {
        //System.err.println(""MessageSiphon err "" + e);
        //e.printStackTrace();
      } else {
        e.printStackTrace();
      }
    } finally {
      thread = null;
    }
  }",maybe_loop_control
lineTimeout,"{
    try {
      // process data until we hit EOF; this will happily block
      // (effectively sleeping the thread) until new data comes in.
      // when the program is finally done, null will come through.
      //
      StringBuilder currentLine = new StringBuilder();
      long lineStartTime = 0;
      while (canRun) {
        // First, try to read as many characters as possible. Take care
        // not to block when:
        //  1. lineTimeout is nonzero, and
        //  2. we have some characters buffered already
        while (lineTimeout == 0 || currentLine.length() == 0 || streamReader.ready()) {
          int c = streamReader.read();
          if (c == -1)
            return; // EOF
          if (!canRun)
            return;

          // Keep track of the line start time
          if (currentLine.length() == 0)
            lineStartTime = System.nanoTime();

          // Store the character line
          currentLine.append((char)c);

          if (c == '\n') {
            // We read a full line, pass it on
            consumer.message(currentLine.toString());
            currentLine.setLength(0);
          }
        }

        // No more characters available. Wait until lineTimeout
        // milliseconds have passed since the start of the line and then
        // try reading again. If the time has already passed, then just
        // pass on the characters read so far.
        long passed = (System.nanoTime() - lineStartTime) / 1000;
        if (passed < this.lineTimeout) {
          Thread.sleep(this.lineTimeout - passed);
          continue;
        }

        consumer.message(currentLine.toString());
        currentLine.setLength(0);
      }
      //EditorConsole.systemOut.println(""messaging thread done"");
    } catch (NullPointerException npe) {
      // Fairly common exception during shutdown
    } catch (SocketException e) {
      // socket has been close while we were wainting for data. nothing to see here, move along
    } catch (Exception e) {
      // On Linux and sometimes on Mac OS X, a ""bad file descriptor""
      // message comes up when closing an applet that's run externally.
      // That message just gets supressed here..
      String mess = e.getMessage();
      if ((mess != null) &&
              (mess.indexOf(""Bad file descriptor"") != -1)) {
        //if (e.getMessage().indexOf(""Bad file descriptor"") == -1) {
        //System.err.println(""MessageSiphon err "" + e);
        //e.printStackTrace();
      } else {
        e.printStackTrace();
      }
    } finally {
      thread = null;
    }
  }",loop_control
currentLine,"{
    try {
      // process data until we hit EOF; this will happily block
      // (effectively sleeping the thread) until new data comes in.
      // when the program is finally done, null will come through.
      //
      StringBuilder currentLine = new StringBuilder();
      long lineStartTime = 0;
      while (canRun) {
        // First, try to read as many characters as possible. Take care
        // not to block when:
        //  1. lineTimeout is nonzero, and
        //  2. we have some characters buffered already
        while (lineTimeout == 0 || currentLine.length() == 0 || streamReader.ready()) {
          int c = streamReader.read();
          if (c == -1)
            return; // EOF
          if (!canRun)
            return;

          // Keep track of the line start time
          if (currentLine.length() == 0)
            lineStartTime = System.nanoTime();

          // Store the character line
          currentLine.append((char)c);

          if (c == '\n') {
            // We read a full line, pass it on
            consumer.message(currentLine.toString());
            currentLine.setLength(0);
          }
        }

        // No more characters available. Wait until lineTimeout
        // milliseconds have passed since the start of the line and then
        // try reading again. If the time has already passed, then just
        // pass on the characters read so far.
        long passed = (System.nanoTime() - lineStartTime) / 1000;
        if (passed < this.lineTimeout) {
          Thread.sleep(this.lineTimeout - passed);
          continue;
        }

        consumer.message(currentLine.toString());
        currentLine.setLength(0);
      }
      //EditorConsole.systemOut.println(""messaging thread done"");
    } catch (NullPointerException npe) {
      // Fairly common exception during shutdown
    } catch (SocketException e) {
      // socket has been close while we were wainting for data. nothing to see here, move along
    } catch (Exception e) {
      // On Linux and sometimes on Mac OS X, a ""bad file descriptor""
      // message comes up when closing an applet that's run externally.
      // That message just gets supressed here..
      String mess = e.getMessage();
      if ((mess != null) &&
              (mess.indexOf(""Bad file descriptor"") != -1)) {
        //if (e.getMessage().indexOf(""Bad file descriptor"") == -1) {
        //System.err.println(""MessageSiphon err "" + e);
        //e.printStackTrace();
      } else {
        e.printStackTrace();
      }
    } finally {
      thread = null;
    }
  }",maybe_loop_control
streamReader,"{
    try {
      // process data until we hit EOF; this will happily block
      // (effectively sleeping the thread) until new data comes in.
      // when the program is finally done, null will come through.
      //
      StringBuilder currentLine = new StringBuilder();
      long lineStartTime = 0;
      while (canRun) {
        // First, try to read as many characters as possible. Take care
        // not to block when:
        //  1. lineTimeout is nonzero, and
        //  2. we have some characters buffered already
        while (lineTimeout == 0 || currentLine.length() == 0 || streamReader.ready()) {
          int c = streamReader.read();
          if (c == -1)
            return; // EOF
          if (!canRun)
            return;

          // Keep track of the line start time
          if (currentLine.length() == 0)
            lineStartTime = System.nanoTime();

          // Store the character line
          currentLine.append((char)c);

          if (c == '\n') {
            // We read a full line, pass it on
            consumer.message(currentLine.toString());
            currentLine.setLength(0);
          }
        }

        // No more characters available. Wait until lineTimeout
        // milliseconds have passed since the start of the line and then
        // try reading again. If the time has already passed, then just
        // pass on the characters read so far.
        long passed = (System.nanoTime() - lineStartTime) / 1000;
        if (passed < this.lineTimeout) {
          Thread.sleep(this.lineTimeout - passed);
          continue;
        }

        consumer.message(currentLine.toString());
        currentLine.setLength(0);
      }
      //EditorConsole.systemOut.println(""messaging thread done"");
    } catch (NullPointerException npe) {
      // Fairly common exception during shutdown
    } catch (SocketException e) {
      // socket has been close while we were wainting for data. nothing to see here, move along
    } catch (Exception e) {
      // On Linux and sometimes on Mac OS X, a ""bad file descriptor""
      // message comes up when closing an applet that's run externally.
      // That message just gets supressed here..
      String mess = e.getMessage();
      if ((mess != null) &&
              (mess.indexOf(""Bad file descriptor"") != -1)) {
        //if (e.getMessage().indexOf(""Bad file descriptor"") == -1) {
        //System.err.println(""MessageSiphon err "" + e);
        //e.printStackTrace();
      } else {
        e.printStackTrace();
      }
    } finally {
      thread = null;
    }
  }",maybe_loop_control
c,"{
    try {
      // process data until we hit EOF; this will happily block
      // (effectively sleeping the thread) until new data comes in.
      // when the program is finally done, null will come through.
      //
      StringBuilder currentLine = new StringBuilder();
      long lineStartTime = 0;
      while (canRun) {
        // First, try to read as many characters as possible. Take care
        // not to block when:
        //  1. lineTimeout is nonzero, and
        //  2. we have some characters buffered already
        while (lineTimeout == 0 || currentLine.length() == 0 || streamReader.ready()) {
          int c = streamReader.read();
          if (c == -1)
            return; // EOF
          if (!canRun)
            return;

          // Keep track of the line start time
          if (currentLine.length() == 0)
            lineStartTime = System.nanoTime();

          // Store the character line
          currentLine.append((char)c);

          if (c == '\n') {
            // We read a full line, pass it on
            consumer.message(currentLine.toString());
            currentLine.setLength(0);
          }
        }

        // No more characters available. Wait until lineTimeout
        // milliseconds have passed since the start of the line and then
        // try reading again. If the time has already passed, then just
        // pass on the characters read so far.
        long passed = (System.nanoTime() - lineStartTime) / 1000;
        if (passed < this.lineTimeout) {
          Thread.sleep(this.lineTimeout - passed);
          continue;
        }

        consumer.message(currentLine.toString());
        currentLine.setLength(0);
      }
      //EditorConsole.systemOut.println(""messaging thread done"");
    } catch (NullPointerException npe) {
      // Fairly common exception during shutdown
    } catch (SocketException e) {
      // socket has been close while we were wainting for data. nothing to see here, move along
    } catch (Exception e) {
      // On Linux and sometimes on Mac OS X, a ""bad file descriptor""
      // message comes up when closing an applet that's run externally.
      // That message just gets supressed here..
      String mess = e.getMessage();
      if ((mess != null) &&
              (mess.indexOf(""Bad file descriptor"") != -1)) {
        //if (e.getMessage().indexOf(""Bad file descriptor"") == -1) {
        //System.err.println(""MessageSiphon err "" + e);
        //e.printStackTrace();
      } else {
        e.printStackTrace();
      }
    } finally {
      thread = null;
    }
  }",break_loop_control
canRun,"{
    try {
      // process data until we hit EOF; this will happily block
      // (effectively sleeping the thread) until new data comes in.
      // when the program is finally done, null will come through.
      //
      StringBuilder currentLine = new StringBuilder();
      long lineStartTime = 0;
      while (canRun) {
        // First, try to read as many characters as possible. Take care
        // not to block when:
        //  1. lineTimeout is nonzero, and
        //  2. we have some characters buffered already
        while (lineTimeout == 0 || currentLine.length() == 0 || streamReader.ready()) {
          int c = streamReader.read();
          if (c == -1)
            return; // EOF
          if (!canRun)
            return;

          // Keep track of the line start time
          if (currentLine.length() == 0)
            lineStartTime = System.nanoTime();

          // Store the character line
          currentLine.append((char)c);

          if (c == '\n') {
            // We read a full line, pass it on
            consumer.message(currentLine.toString());
            currentLine.setLength(0);
          }
        }

        // No more characters available. Wait until lineTimeout
        // milliseconds have passed since the start of the line and then
        // try reading again. If the time has already passed, then just
        // pass on the characters read so far.
        long passed = (System.nanoTime() - lineStartTime) / 1000;
        if (passed < this.lineTimeout) {
          Thread.sleep(this.lineTimeout - passed);
          continue;
        }

        consumer.message(currentLine.toString());
        currentLine.setLength(0);
      }
      //EditorConsole.systemOut.println(""messaging thread done"");
    } catch (NullPointerException npe) {
      // Fairly common exception during shutdown
    } catch (SocketException e) {
      // socket has been close while we were wainting for data. nothing to see here, move along
    } catch (Exception e) {
      // On Linux and sometimes on Mac OS X, a ""bad file descriptor""
      // message comes up when closing an applet that's run externally.
      // That message just gets supressed here..
      String mess = e.getMessage();
      if ((mess != null) &&
              (mess.indexOf(""Bad file descriptor"") != -1)) {
        //if (e.getMessage().indexOf(""Bad file descriptor"") == -1) {
        //System.err.println(""MessageSiphon err "" + e);
        //e.printStackTrace();
      } else {
        e.printStackTrace();
      }
    } finally {
      thread = null;
    }
  }",break_loop_control
line,"{
    List<String> lines = Files.readAllLines(file.toPath(), StandardCharsets.UTF_8);
    StringBuilder contentBuilder = new StringBuilder();
    for(String line : lines) {
      contentBuilder.append(line).append('\n');
    }
    Files.write(file.toPath(), contentBuilder.toString().getBytes(StandardCharsets.UTF_8));
  }",iterator
language,"{
    for (Language language : Languages.languages) {
      if (!language.getIsoCode().equals("""")) {
        Locale locale = toLocale(language);
        ResourceBundle bundle = ResourceBundle.getBundle(""processing.app.i18n.Resources"", locale);
        if (locale.equals(bundle.getLocale())) {
          Collections.list(bundle.getKeys()).stream().map(bundle::getString).filter(key -> !key.contains(""<html"")).forEach(key -> {
            try {
              I18n.format(key);
            } catch (IllegalArgumentException e) {
              System.out.println(language);
              System.out.println(key);
              throw e;
            }
          });
        } else {
          System.out.println(""Missing locale: "" + locale);
        }
      }
    }
  }",iterator
line,"{
    StringWriter sw = new StringWriter();

    BufferedReader reader = new BufferedReader(new InputStreamReader(is));
    String line;
    try {
      while ((line = reader.readLine()) != null) {
        sw.append(line).append('\n');
      }
      return sw.toString();
    } finally {
      is.close();
    }
  }",maybe_loop_control
f,"{
    for (File f : deleteAfter)
      FileUtils.recursiveDelete(f);
    deleteAfter = new LinkedList<File>();
  }",iterator
submenu,"{
    for (Component submenu : menu.getMenuComponents()) {
      if (submenu instanceof JMenu && text.equals(((JMenu) submenu).getText())) {
        return (JMenu) submenu;
      }
    }
    return null;
  }",iterator
submenu,"{
    for (Component submenu : menu.getMenuComponents()) {
      if (submenu instanceof JMenu && text.equals(((JMenu) submenu).getText())) {
        return (JMenu) submenu;
      }
    }
    return null;
  }",break_loop_control
e,"{

    proxyTypeButtonGroup = new javax.swing.ButtonGroup();
    manualProxyTypeButtonGroup = new javax.swing.ButtonGroup();
    javax.swing.JPanel jPanel2 = new javax.swing.JPanel();
    javax.swing.JTabbedPane jTabbedPane1 = new javax.swing.JTabbedPane();
    jPanel1 = new javax.swing.JPanel();
    sketchbookLocationLabel = new javax.swing.JLabel();
    sketchbookLocationField = new javax.swing.JTextField();
    browseButton = new javax.swing.JButton();
    comboLanguageLabel = new javax.swing.JLabel();
    comboLanguage = new JComboBox(Languages.languages);
    requiresRestartLabel = new javax.swing.JLabel();
    fontSizeLabel = new javax.swing.JLabel();
    fontSizeField = new javax.swing.JTextField();
    showVerboseLabel = new javax.swing.JLabel();
    verboseCompilationBox = new javax.swing.JCheckBox();
    verboseUploadBox = new javax.swing.JCheckBox();
    comboWarningsLabel = new javax.swing.JLabel();
    comboWarnings = new JComboBox(warningItems);
    additionalBoardsManagerLabel = new javax.swing.JLabel();
    additionalBoardsManagerField = new javax.swing.JTextField();
    extendedAdditionalUrlFieldWindow = new javax.swing.JButton();
    morePreferencesLabel = new javax.swing.JLabel();
    preferencesFileLabel = new javax.swing.JLabel();
    arduinoNotRunningLabel = new javax.swing.JLabel();
    checkboxesContainer = new javax.swing.JPanel();
    displayLineNumbersBox = new javax.swing.JCheckBox();
    enableCodeFoldingBox = new javax.swing.JCheckBox();
    verifyUploadBox = new javax.swing.JCheckBox();
    externalEditorBox = new javax.swing.JCheckBox();
    checkUpdatesBox = new javax.swing.JCheckBox();
    saveVerifyUploadBox = new javax.swing.JCheckBox();
    accessibleIDEBox = new javax.swing.JCheckBox();
    jLabel1 = new javax.swing.JLabel();
    jLabel2 = new javax.swing.JLabel();
    scaleSpinner = new javax.swing.JSpinner();
    autoScaleCheckBox = new javax.swing.JCheckBox();
    jLabel3 = new javax.swing.JLabel();
    javax.swing.JPanel jPanel4 = new javax.swing.JPanel();
    noProxy = new javax.swing.JRadioButton();
    autoProxy = new javax.swing.JRadioButton();
    manualProxy = new javax.swing.JRadioButton();
    autoProxyUsePAC = new javax.swing.JCheckBox();
    autoProxyPACURL = new javax.swing.JTextField();
    manualProxyHTTP = new javax.swing.JRadioButton();
    manualProxySOCKS = new javax.swing.JRadioButton();
    manualProxyHostNameLabel = new javax.swing.JLabel();
    manualProxyPortLabel = new javax.swing.JLabel();
    manualProxyHostName = new javax.swing.JTextField();
    manualProxyPort = new javax.swing.JTextField();
    manualProxyUsernameLabel = new javax.swing.JLabel();
    manualProxyUsername = new javax.swing.JTextField();
    manualProxyPasswordLabel = new javax.swing.JLabel();
    manualProxyPassword = new javax.swing.JPasswordField();
    autoProxyUsernameLabel = new javax.swing.JLabel();
    autoProxyUsername = new javax.swing.JTextField();
    autoProxyPassword = new javax.swing.JPasswordField();
    autoProxyPasswordLabel = new javax.swing.JLabel();
    comboThemeLabel = new javax.swing.JLabel();
    comboTheme = new JComboBox();
    requiresRestartLabel2 = new javax.swing.JLabel();
    javax.swing.JPanel jPanel3 = new javax.swing.JPanel();
    javax.swing.JButton okButton = new javax.swing.JButton();
    javax.swing.JButton cancelButton = new javax.swing.JButton();

    setDefaultCloseOperation(javax.swing.WindowConstants.DISPOSE_ON_CLOSE);
    setTitle(tr(""Preferences""));
    setModal(true);
    setResizable(false);

    jPanel2.setLayout(new javax.swing.BoxLayout(jPanel2, javax.swing.BoxLayout.Y_AXIS));

    jTabbedPane1.setFocusable(false);
    jTabbedPane1.setRequestFocusEnabled(false);

    sketchbookLocationLabel.setText(tr(""Sketchbook location:""));
    sketchbookLocationLabel.setLabelFor(sketchbookLocationField);

    sketchbookLocationField.setColumns(40);

    browseButton.setText(I18n.PROMPT_BROWSE);
    browseButton.addActionListener(new java.awt.event.ActionListener() {
      public void actionPerformed(java.awt.event.ActionEvent evt) {
        browseButtonActionPerformed(evt);
      }
    });

    comboLanguageLabel.setText(tr(""Editor language: ""));

    requiresRestartLabel.setText(tr(""  (requires restart of Arduino)""));

    comboLanguage.getAccessibleContext().setAccessibleName(""Editor language (requires restart of Arduino)"");

    fontSizeLabel.setText(tr(""Editor font size: ""));
    fontSizeLabel.setLabelFor(fontSizeField);

    fontSizeField.setColumns(4);

    showVerboseLabel.setText(tr(""Show verbose output during: ""));

    verboseCompilationBox.setText(tr(""compilation ""));
    verboseCompilationBox.getAccessibleContext().setAccessibleName(""Show verbose output during compilation"");

    verboseUploadBox.setText(tr(""upload""));
    verboseUploadBox.getAccessibleContext().setAccessibleName(""Show verbose output during upload"");

    comboWarningsLabel.setText(tr(""Compiler warnings: ""));
    comboWarningsLabel.setLabelFor(comboWarnings);

    additionalBoardsManagerLabel.setText(tr(""Additional Boards Manager URLs: ""));
    additionalBoardsManagerLabel.setToolTipText(tr(""Enter a comma separated list of urls""));
    additionalBoardsManagerLabel.setLabelFor(additionalBoardsManagerField);

    additionalBoardsManagerField.setToolTipText(tr(""Enter a comma separated list of urls""));

    extendedAdditionalUrlFieldWindow.setIcon(new ImageIcon(Theme.getThemeImage(""newwindow"", this, Theme.scale(16), Theme.scale(14))));
    extendedAdditionalUrlFieldWindow.setMargin(new java.awt.Insets(1, 1, 1, 1));
    extendedAdditionalUrlFieldWindow.addActionListener(new java.awt.event.ActionListener() {
      public void actionPerformed(java.awt.event.ActionEvent evt) {
        extendedAdditionalUrlFieldWindowActionPerformed(evt);
      }
    });
    extendedAdditionalUrlFieldWindow.getAccessibleContext().setAccessibleName(""New Window"");

    morePreferencesLabel.setForeground(Color.GRAY);
    morePreferencesLabel.setText(tr(""More preferences can be edited directly in the file""));

    preferencesFileLabel.setText(PreferencesData.getPreferencesFile().getAbsolutePath());
    preferencesFileLabel.setCursor(new java.awt.Cursor(java.awt.Cursor.HAND_CURSOR));
    preferencesFileLabel.addMouseListener(new java.awt.event.MouseAdapter() {
      public void mousePressed(java.awt.event.MouseEvent evt) {
        preferencesFileLabelMousePressed(evt);
      }
      public void mouseExited(java.awt.event.MouseEvent evt) {
        preferencesFileLabelMouseExited(evt);
      }
      public void mouseEntered(java.awt.event.MouseEvent evt) {
        preferencesFileLabelMouseEntered(evt);
      }
    });
    preferencesFileLabel.setFocusable(true);

    arduinoNotRunningLabel.setForeground(Color.GRAY);
    arduinoNotRunningLabel.setText(tr(""(edit only when Arduino is not running)""));

    checkboxesContainer.setLayout(new GridLayout(0,2));

    displayLineNumbersBox.setText(tr(""Display line numbers""));
    checkboxesContainer.add(displayLineNumbersBox);

    enableCodeFoldingBox.setText(tr(""Enable Code Folding""));
    checkboxesContainer.add(enableCodeFoldingBox);

    verifyUploadBox.setText(tr(""Verify code after upload""));
    checkboxesContainer.add(verifyUploadBox);

    externalEditorBox.setText(tr(""Use external editor""));
    externalEditorBox.addItemListener(ev -> {
      if (ev.getStateChange() == ItemEvent.SELECTED) {
        for (Editor e : base.getEditors()) {
          if (e.getSketch().isModified()) {
            String msg = tr(""You have unsaved changes!\nYou must save all your sketches to enable this option."");
            JOptionPane.showMessageDialog(null, msg,
                                          tr(""Can't enable external editor""),
                                          JOptionPane.INFORMATION_MESSAGE);
            externalEditorBox.setSelected(false);
            return;
          }
        }
      }
    });

    checkboxesContainer.add(externalEditorBox);

    checkUpdatesBox.setText(tr(""Check for updates on startup""));
    checkboxesContainer.add(checkUpdatesBox);

    saveVerifyUploadBox.setText(tr(""Save when verifying or uploading""));
    checkboxesContainer.add(saveVerifyUploadBox);

    accessibleIDEBox.setText(tr(""Use accessibility features""));
    checkboxesContainer.add(accessibleIDEBox);

    jLabel1.setText(tr(""Interface scale:""));

    jLabel2.setText(tr(""  (requires restart of Arduino)""));

    scaleSpinner.setModel(new javax.swing.SpinnerNumberModel(100, 100, 400, 5));
    scaleSpinner.setEnabled(false);
    scaleSpinner.getAccessibleContext().setAccessibleName(""Interface scale (requires restart of Arduino)"");

    autoScaleCheckBox.setSelected(true);
    autoScaleCheckBox.setText(tr(""Automatic""));
    autoScaleCheckBox.addItemListener(new java.awt.event.ItemListener() {
      public void itemStateChanged(java.awt.event.ItemEvent evt) {
        autoScaleCheckBoxItemStateChanged(evt);
      }
    });
    autoScaleCheckBox.getAccessibleContext().setAccessibleName(""Automatic interface scale (requires restart of Arduino"");

    jLabel3.setText(""%"");

    comboThemeLabel.setText(tr(""Theme: ""));

    comboTheme.getAccessibleContext().setAccessibleName(""Theme (requires restart of Arduino)"");

    requiresRestartLabel2.setText(tr(""  (requires restart of Arduino)""));

    javax.swing.GroupLayout jPanel1Layout = new javax.swing.GroupLayout(jPanel1);
    jPanel1.setLayout(jPanel1Layout);
    jPanel1Layout.setHorizontalGroup(
      jPanel1Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
      .addGroup(jPanel1Layout.createSequentialGroup()
        .addContainerGap()
        .addGroup(jPanel1Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
          .addGroup(jPanel1Layout.createSequentialGroup()
            .addComponent(sketchbookLocationField, javax.swing.GroupLayout.DEFAULT_SIZE, 400, Short.MAX_VALUE)
            .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
            .addComponent(browseButton))
          .addComponent(checkboxesContainer, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)
          .addGroup(jPanel1Layout.createSequentialGroup()
            .addGroup(jPanel1Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
              .addGroup(jPanel1Layout.createSequentialGroup()
                .addGroup(jPanel1Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                  .addComponent(jLabel1)
                  .addComponent(comboWarningsLabel))
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                .addGroup(jPanel1Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                  .addComponent(comboWarnings, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)
                  .addGroup(jPanel1Layout.createSequentialGroup()
                    .addComponent(autoScaleCheckBox)
                    .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                    .addComponent(scaleSpinner, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)
                    .addGap(0, 0, 0)
                    .addComponent(jLabel3)
                    .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                    .addComponent(jLabel2))))
              .addGroup(jPanel1Layout.createSequentialGroup()
                .addComponent(showVerboseLabel)
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                .addComponent(verboseCompilationBox)
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                .addComponent(verboseUploadBox))
              .addGroup(jPanel1Layout.createSequentialGroup()
                .addGroup(jPanel1Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                  .addComponent(comboLanguageLabel)
                  .addComponent(fontSizeLabel)
                  .addComponent(comboThemeLabel))
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                .addGroup(jPanel1Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                  .addGroup(jPanel1Layout.createSequentialGroup()
                    .addComponent(comboTheme, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)
                    .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                    .addComponent(requiresRestartLabel2))
                  .addComponent(fontSizeField, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)
                  .addGroup(jPanel1Layout.createSequentialGroup()
                    .addComponent(comboLanguage, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)
                    .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                    .addComponent(requiresRestartLabel))))
              .addComponent(arduinoNotRunningLabel)
              .addComponent(morePreferencesLabel)
              .addComponent(preferencesFileLabel)
              .addComponent(sketchbookLocationLabel)
              .addGroup(jPanel1Layout.createSequentialGroup()
                .addComponent(additionalBoardsManagerLabel)
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                .addComponent(additionalBoardsManagerField, javax.swing.GroupLayout.PREFERRED_SIZE, 500, javax.swing.GroupLayout.PREFERRED_SIZE)
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                .addComponent(extendedAdditionalUrlFieldWindow)))
            .addGap(0, 0, Short.MAX_VALUE)))
        .addContainerGap())
    );

    jPanel1Layout.linkSize(javax.swing.SwingConstants.HORIZONTAL, new java.awt.Component[] {comboLanguageLabel, comboWarningsLabel, fontSizeLabel, jLabel1, showVerboseLabel, comboThemeLabel});

    jPanel1Layout.setVerticalGroup(
      jPanel1Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
      .addGroup(javax.swing.GroupLayout.Alignment.TRAILING, jPanel1Layout.createSequentialGroup()
        .addContainerGap()
        .addComponent(sketchbookLocationLabel)
        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
        .addGroup(jPanel1Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE)
          .addComponent(sketchbookLocationField, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)
          .addComponent(browseButton))
        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
        .addGroup(jPanel1Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE)
          .addComponent(comboLanguageLabel)
          .addComponent(comboLanguage, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)
          .addComponent(requiresRestartLabel))
        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
        .addGroup(jPanel1Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE)
          .addComponent(fontSizeLabel)
          .addComponent(fontSizeField, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE))
        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
        .addGroup(jPanel1Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE)
          .addComponent(jLabel1)
          .addComponent(jLabel2)
          .addComponent(scaleSpinner, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)
          .addComponent(autoScaleCheckBox)
          .addComponent(jLabel3))
        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
        .addGroup(jPanel1Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE)
          .addComponent(comboThemeLabel)
          .addComponent(comboTheme, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)
          .addComponent(requiresRestartLabel2))
        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
        .addGroup(jPanel1Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE)
          .addComponent(showVerboseLabel)
          .addComponent(verboseCompilationBox)
          .addComponent(verboseUploadBox))
        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
        .addGroup(jPanel1Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE)
          .addComponent(comboWarningsLabel)
          .addComponent(comboWarnings, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE))
        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
        .addComponent(checkboxesContainer, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)
        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
        .addGroup(jPanel1Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
          .addGroup(jPanel1Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE)
            .addComponent(additionalBoardsManagerLabel)
            .addComponent(additionalBoardsManagerField, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE))
          .addComponent(extendedAdditionalUrlFieldWindow))
        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
        .addComponent(morePreferencesLabel)
        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
        .addComponent(preferencesFileLabel)
        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
        .addComponent(arduinoNotRunningLabel)
        .addContainerGap())
    );

    jTabbedPane1.addTab(tr(""Settings""), jPanel1);

    proxyTypeButtonGroup.add(noProxy);
    noProxy.setText(tr(""No proxy""));
    noProxy.setActionCommand(Constants.PROXY_TYPE_NONE);

    proxyTypeButtonGroup.add(autoProxy);
    autoProxy.setText(tr(""Auto-detect proxy settings""));
    autoProxy.setActionCommand(Constants.PROXY_TYPE_AUTO);
    autoProxy.addItemListener(new java.awt.event.ItemListener() {
      public void itemStateChanged(java.awt.event.ItemEvent evt) {
        autoProxyItemStateChanged(evt);
      }
    });

    proxyTypeButtonGroup.add(manualProxy);
    manualProxy.setText(tr(""Manual proxy configuration""));
    manualProxy.setActionCommand(Constants.PROXY_TYPE_MANUAL);
    manualProxy.addItemListener(new java.awt.event.ItemListener() {
      public void itemStateChanged(java.awt.event.ItemEvent evt) {
        manualProxyItemStateChanged(evt);
      }
    });

    autoProxyUsePAC.setText(tr(""Automatic proxy configuration URL:""));
    autoProxyUsePAC.addItemListener(new java.awt.event.ItemListener() {
      public void itemStateChanged(java.awt.event.ItemEvent evt) {
        autoProxyUsePACItemStateChanged(evt);
      }
    });

    manualProxyTypeButtonGroup.add(manualProxyHTTP);
    manualProxyHTTP.setText(""HTTP"");
    manualProxyHTTP.setActionCommand(Constants.PROXY_MANUAL_TYPE_HTTP);

    manualProxyTypeButtonGroup.add(manualProxySOCKS);
    manualProxySOCKS.setText(""SOCKS"");
    manualProxySOCKS.setActionCommand(Constants.PROXY_MANUAL_TYPE_SOCKS);

    manualProxyHostNameLabel.setText(tr(""Host name:""));

    manualProxyPortLabel.setText(tr(""Port number:""));

    manualProxyUsernameLabel.setText(tr(""Username:""));

    manualProxyPasswordLabel.setText(tr(""Password:""));

    manualProxyPassword.setToolTipText("""");

    autoProxyUsernameLabel.setText(tr(""Username:""));

    autoProxyPassword.setToolTipText("""");

    autoProxyPasswordLabel.setText(tr(""Password:""));

    javax.swing.GroupLayout jPanel4Layout = new javax.swing.GroupLayout(jPanel4);
    jPanel4.setLayout(jPanel4Layout);
    jPanel4Layout.setHorizontalGroup(
      jPanel4Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
      .addGroup(jPanel4Layout.createSequentialGroup()
        .addContainerGap()
        .addGroup(jPanel4Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
          .addGroup(jPanel4Layout.createSequentialGroup()
            .addGap(12, 12, 12)
            .addGroup(jPanel4Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
              .addComponent(autoProxyUsePAC)
              .addGroup(jPanel4Layout.createSequentialGroup()
                .addGap(12, 12, 12)
                .addGroup(jPanel4Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                  .addComponent(autoProxyUsernameLabel)
                  .addComponent(autoProxyPasswordLabel))))
            .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
            .addGroup(jPanel4Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
              .addComponent(autoProxyPACURL)
              .addGroup(jPanel4Layout.createSequentialGroup()
                .addGroup(jPanel4Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                  .addComponent(autoProxyUsername, javax.swing.GroupLayout.PREFERRED_SIZE, 178, javax.swing.GroupLayout.PREFERRED_SIZE)
                  .addComponent(autoProxyPassword, javax.swing.GroupLayout.PREFERRED_SIZE, 180, javax.swing.GroupLayout.PREFERRED_SIZE))
                .addGap(0, 0, Short.MAX_VALUE))))
          .addGroup(jPanel4Layout.createSequentialGroup()
            .addGroup(jPanel4Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
              .addComponent(noProxy)
              .addComponent(autoProxy)
              .addComponent(manualProxy)
              .addGroup(jPanel4Layout.createSequentialGroup()
                .addGap(12, 12, 12)
                .addGroup(jPanel4Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                  .addGroup(jPanel4Layout.createSequentialGroup()
                    .addComponent(manualProxyHTTP)
                    .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                    .addComponent(manualProxySOCKS))
                  .addGroup(jPanel4Layout.createSequentialGroup()
                    .addGroup(jPanel4Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                      .addComponent(manualProxyHostNameLabel)
                      .addComponent(manualProxyPortLabel)
                      .addComponent(manualProxyUsernameLabel)
                      .addComponent(manualProxyPasswordLabel))
                    .addGap(18, 18, 18)
                    .addGroup(jPanel4Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                      .addComponent(manualProxyHostName, javax.swing.GroupLayout.PREFERRED_SIZE, 541, javax.swing.GroupLayout.PREFERRED_SIZE)
                      .addComponent(manualProxyPort, javax.swing.GroupLayout.PREFERRED_SIZE, 74, javax.swing.GroupLayout.PREFERRED_SIZE)
                      .addGroup(jPanel4Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.TRAILING, false)
                        .addComponent(manualProxyPassword, javax.swing.GroupLayout.Alignment.LEADING)
                        .addComponent(manualProxyUsername, javax.swing.GroupLayout.Alignment.LEADING, javax.swing.GroupLayout.PREFERRED_SIZE, 180, javax.swing.GroupLayout.PREFERRED_SIZE)))))))
            .addGap(0, 0, Short.MAX_VALUE)))
        .addContainerGap())
    );
    jPanel4Layout.setVerticalGroup(
      jPanel4Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
      .addGroup(jPanel4Layout.createSequentialGroup()
        .addContainerGap()
        .addComponent(noProxy)
        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
        .addComponent(autoProxy)
        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
        .addGroup(jPanel4Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE)
          .addComponent(autoProxyUsePAC)
          .addComponent(autoProxyPACURL, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE))
        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
        .addGroup(jPanel4Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE)
          .addComponent(autoProxyUsername, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)
          .addComponent(autoProxyUsernameLabel))
        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
        .addGroup(jPanel4Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE)
          .addComponent(autoProxyPasswordLabel)
          .addComponent(autoProxyPassword, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE))
        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
        .addComponent(manualProxy)
        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
        .addGroup(jPanel4Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE)
          .addComponent(manualProxyHTTP)
          .addComponent(manualProxySOCKS))
        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
        .addGroup(jPanel4Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE)
          .addComponent(manualProxyHostNameLabel)
          .addComponent(manualProxyHostName, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE))
        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
        .addGroup(jPanel4Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE)
          .addComponent(manualProxyPort, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)
          .addComponent(manualProxyPortLabel))
        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
        .addGroup(jPanel4Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE)
          .addComponent(manualProxyUsername, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)
          .addComponent(manualProxyUsernameLabel))
        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
        .addGroup(jPanel4Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE)
          .addComponent(manualProxyPassword, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)
          .addComponent(manualProxyPasswordLabel))
        .addContainerGap(50, Short.MAX_VALUE))
    );

    jTabbedPane1.addTab(tr(""Network""), jPanel4);

    jPanel2.add(jTabbedPane1);

    okButton.setText(I18n.PROMPT_OK);
    okButton.addActionListener(new java.awt.event.ActionListener() {
      public void actionPerformed(java.awt.event.ActionEvent evt) {
        okButtonActionPerformed(evt);
      }
    });

    cancelButton.setText(I18n.PROMPT_CANCEL);
    cancelButton.addActionListener(new java.awt.event.ActionListener() {
      public void actionPerformed(java.awt.event.ActionEvent evt) {
        cancelButtonActionPerformed(evt);
      }
    });

    javax.swing.GroupLayout jPanel3Layout = new javax.swing.GroupLayout(jPanel3);
    jPanel3.setLayout(jPanel3Layout);
    jPanel3Layout.setHorizontalGroup(
      jPanel3Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
      .addGroup(javax.swing.GroupLayout.Alignment.TRAILING, jPanel3Layout.createSequentialGroup()
        .addContainerGap(javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)
        .addComponent(okButton)
        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
        .addComponent(cancelButton)
        .addContainerGap())
    );
    jPanel3Layout.setVerticalGroup(
      jPanel3Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
      .addGroup(javax.swing.GroupLayout.Alignment.TRAILING, jPanel3Layout.createSequentialGroup()
        .addGroup(jPanel3Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE)
          .addComponent(okButton)
          .addComponent(cancelButton)))
    );

    jPanel2.add(jPanel3);

    javax.swing.GroupLayout layout = new javax.swing.GroupLayout(getContentPane());
    getContentPane().setLayout(layout);
    layout.setHorizontalGroup(
      layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
      .addGap(0, 800, Short.MAX_VALUE)
      .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
        .addComponent(jPanel2, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE))
    );
    layout.setVerticalGroup(
      layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
      .addGap(0, 400, Short.MAX_VALUE)
      .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
        .addComponent(jPanel2, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE))
    );

    pack();
  }",iterator
e,"{

    proxyTypeButtonGroup = new javax.swing.ButtonGroup();
    manualProxyTypeButtonGroup = new javax.swing.ButtonGroup();
    javax.swing.JPanel jPanel2 = new javax.swing.JPanel();
    javax.swing.JTabbedPane jTabbedPane1 = new javax.swing.JTabbedPane();
    jPanel1 = new javax.swing.JPanel();
    sketchbookLocationLabel = new javax.swing.JLabel();
    sketchbookLocationField = new javax.swing.JTextField();
    browseButton = new javax.swing.JButton();
    comboLanguageLabel = new javax.swing.JLabel();
    comboLanguage = new JComboBox(Languages.languages);
    requiresRestartLabel = new javax.swing.JLabel();
    fontSizeLabel = new javax.swing.JLabel();
    fontSizeField = new javax.swing.JTextField();
    showVerboseLabel = new javax.swing.JLabel();
    verboseCompilationBox = new javax.swing.JCheckBox();
    verboseUploadBox = new javax.swing.JCheckBox();
    comboWarningsLabel = new javax.swing.JLabel();
    comboWarnings = new JComboBox(warningItems);
    additionalBoardsManagerLabel = new javax.swing.JLabel();
    additionalBoardsManagerField = new javax.swing.JTextField();
    extendedAdditionalUrlFieldWindow = new javax.swing.JButton();
    morePreferencesLabel = new javax.swing.JLabel();
    preferencesFileLabel = new javax.swing.JLabel();
    arduinoNotRunningLabel = new javax.swing.JLabel();
    checkboxesContainer = new javax.swing.JPanel();
    displayLineNumbersBox = new javax.swing.JCheckBox();
    enableCodeFoldingBox = new javax.swing.JCheckBox();
    verifyUploadBox = new javax.swing.JCheckBox();
    externalEditorBox = new javax.swing.JCheckBox();
    checkUpdatesBox = new javax.swing.JCheckBox();
    saveVerifyUploadBox = new javax.swing.JCheckBox();
    accessibleIDEBox = new javax.swing.JCheckBox();
    jLabel1 = new javax.swing.JLabel();
    jLabel2 = new javax.swing.JLabel();
    scaleSpinner = new javax.swing.JSpinner();
    autoScaleCheckBox = new javax.swing.JCheckBox();
    jLabel3 = new javax.swing.JLabel();
    javax.swing.JPanel jPanel4 = new javax.swing.JPanel();
    noProxy = new javax.swing.JRadioButton();
    autoProxy = new javax.swing.JRadioButton();
    manualProxy = new javax.swing.JRadioButton();
    autoProxyUsePAC = new javax.swing.JCheckBox();
    autoProxyPACURL = new javax.swing.JTextField();
    manualProxyHTTP = new javax.swing.JRadioButton();
    manualProxySOCKS = new javax.swing.JRadioButton();
    manualProxyHostNameLabel = new javax.swing.JLabel();
    manualProxyPortLabel = new javax.swing.JLabel();
    manualProxyHostName = new javax.swing.JTextField();
    manualProxyPort = new javax.swing.JTextField();
    manualProxyUsernameLabel = new javax.swing.JLabel();
    manualProxyUsername = new javax.swing.JTextField();
    manualProxyPasswordLabel = new javax.swing.JLabel();
    manualProxyPassword = new javax.swing.JPasswordField();
    autoProxyUsernameLabel = new javax.swing.JLabel();
    autoProxyUsername = new javax.swing.JTextField();
    autoProxyPassword = new javax.swing.JPasswordField();
    autoProxyPasswordLabel = new javax.swing.JLabel();
    comboThemeLabel = new javax.swing.JLabel();
    comboTheme = new JComboBox();
    requiresRestartLabel2 = new javax.swing.JLabel();
    javax.swing.JPanel jPanel3 = new javax.swing.JPanel();
    javax.swing.JButton okButton = new javax.swing.JButton();
    javax.swing.JButton cancelButton = new javax.swing.JButton();

    setDefaultCloseOperation(javax.swing.WindowConstants.DISPOSE_ON_CLOSE);
    setTitle(tr(""Preferences""));
    setModal(true);
    setResizable(false);

    jPanel2.setLayout(new javax.swing.BoxLayout(jPanel2, javax.swing.BoxLayout.Y_AXIS));

    jTabbedPane1.setFocusable(false);
    jTabbedPane1.setRequestFocusEnabled(false);

    sketchbookLocationLabel.setText(tr(""Sketchbook location:""));
    sketchbookLocationLabel.setLabelFor(sketchbookLocationField);

    sketchbookLocationField.setColumns(40);

    browseButton.setText(I18n.PROMPT_BROWSE);
    browseButton.addActionListener(new java.awt.event.ActionListener() {
      public void actionPerformed(java.awt.event.ActionEvent evt) {
        browseButtonActionPerformed(evt);
      }
    });

    comboLanguageLabel.setText(tr(""Editor language: ""));

    requiresRestartLabel.setText(tr(""  (requires restart of Arduino)""));

    comboLanguage.getAccessibleContext().setAccessibleName(""Editor language (requires restart of Arduino)"");

    fontSizeLabel.setText(tr(""Editor font size: ""));
    fontSizeLabel.setLabelFor(fontSizeField);

    fontSizeField.setColumns(4);

    showVerboseLabel.setText(tr(""Show verbose output during: ""));

    verboseCompilationBox.setText(tr(""compilation ""));
    verboseCompilationBox.getAccessibleContext().setAccessibleName(""Show verbose output during compilation"");

    verboseUploadBox.setText(tr(""upload""));
    verboseUploadBox.getAccessibleContext().setAccessibleName(""Show verbose output during upload"");

    comboWarningsLabel.setText(tr(""Compiler warnings: ""));
    comboWarningsLabel.setLabelFor(comboWarnings);

    additionalBoardsManagerLabel.setText(tr(""Additional Boards Manager URLs: ""));
    additionalBoardsManagerLabel.setToolTipText(tr(""Enter a comma separated list of urls""));
    additionalBoardsManagerLabel.setLabelFor(additionalBoardsManagerField);

    additionalBoardsManagerField.setToolTipText(tr(""Enter a comma separated list of urls""));

    extendedAdditionalUrlFieldWindow.setIcon(new ImageIcon(Theme.getThemeImage(""newwindow"", this, Theme.scale(16), Theme.scale(14))));
    extendedAdditionalUrlFieldWindow.setMargin(new java.awt.Insets(1, 1, 1, 1));
    extendedAdditionalUrlFieldWindow.addActionListener(new java.awt.event.ActionListener() {
      public void actionPerformed(java.awt.event.ActionEvent evt) {
        extendedAdditionalUrlFieldWindowActionPerformed(evt);
      }
    });
    extendedAdditionalUrlFieldWindow.getAccessibleContext().setAccessibleName(""New Window"");

    morePreferencesLabel.setForeground(Color.GRAY);
    morePreferencesLabel.setText(tr(""More preferences can be edited directly in the file""));

    preferencesFileLabel.setText(PreferencesData.getPreferencesFile().getAbsolutePath());
    preferencesFileLabel.setCursor(new java.awt.Cursor(java.awt.Cursor.HAND_CURSOR));
    preferencesFileLabel.addMouseListener(new java.awt.event.MouseAdapter() {
      public void mousePressed(java.awt.event.MouseEvent evt) {
        preferencesFileLabelMousePressed(evt);
      }
      public void mouseExited(java.awt.event.MouseEvent evt) {
        preferencesFileLabelMouseExited(evt);
      }
      public void mouseEntered(java.awt.event.MouseEvent evt) {
        preferencesFileLabelMouseEntered(evt);
      }
    });
    preferencesFileLabel.setFocusable(true);

    arduinoNotRunningLabel.setForeground(Color.GRAY);
    arduinoNotRunningLabel.setText(tr(""(edit only when Arduino is not running)""));

    checkboxesContainer.setLayout(new GridLayout(0,2));

    displayLineNumbersBox.setText(tr(""Display line numbers""));
    checkboxesContainer.add(displayLineNumbersBox);

    enableCodeFoldingBox.setText(tr(""Enable Code Folding""));
    checkboxesContainer.add(enableCodeFoldingBox);

    verifyUploadBox.setText(tr(""Verify code after upload""));
    checkboxesContainer.add(verifyUploadBox);

    externalEditorBox.setText(tr(""Use external editor""));
    externalEditorBox.addItemListener(ev -> {
      if (ev.getStateChange() == ItemEvent.SELECTED) {
        for (Editor e : base.getEditors()) {
          if (e.getSketch().isModified()) {
            String msg = tr(""You have unsaved changes!\nYou must save all your sketches to enable this option."");
            JOptionPane.showMessageDialog(null, msg,
                                          tr(""Can't enable external editor""),
                                          JOptionPane.INFORMATION_MESSAGE);
            externalEditorBox.setSelected(false);
            return;
          }
        }
      }
    });

    checkboxesContainer.add(externalEditorBox);

    checkUpdatesBox.setText(tr(""Check for updates on startup""));
    checkboxesContainer.add(checkUpdatesBox);

    saveVerifyUploadBox.setText(tr(""Save when verifying or uploading""));
    checkboxesContainer.add(saveVerifyUploadBox);

    accessibleIDEBox.setText(tr(""Use accessibility features""));
    checkboxesContainer.add(accessibleIDEBox);

    jLabel1.setText(tr(""Interface scale:""));

    jLabel2.setText(tr(""  (requires restart of Arduino)""));

    scaleSpinner.setModel(new javax.swing.SpinnerNumberModel(100, 100, 400, 5));
    scaleSpinner.setEnabled(false);
    scaleSpinner.getAccessibleContext().setAccessibleName(""Interface scale (requires restart of Arduino)"");

    autoScaleCheckBox.setSelected(true);
    autoScaleCheckBox.setText(tr(""Automatic""));
    autoScaleCheckBox.addItemListener(new java.awt.event.ItemListener() {
      public void itemStateChanged(java.awt.event.ItemEvent evt) {
        autoScaleCheckBoxItemStateChanged(evt);
      }
    });
    autoScaleCheckBox.getAccessibleContext().setAccessibleName(""Automatic interface scale (requires restart of Arduino"");

    jLabel3.setText(""%"");

    comboThemeLabel.setText(tr(""Theme: ""));

    comboTheme.getAccessibleContext().setAccessibleName(""Theme (requires restart of Arduino)"");

    requiresRestartLabel2.setText(tr(""  (requires restart of Arduino)""));

    javax.swing.GroupLayout jPanel1Layout = new javax.swing.GroupLayout(jPanel1);
    jPanel1.setLayout(jPanel1Layout);
    jPanel1Layout.setHorizontalGroup(
      jPanel1Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
      .addGroup(jPanel1Layout.createSequentialGroup()
        .addContainerGap()
        .addGroup(jPanel1Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
          .addGroup(jPanel1Layout.createSequentialGroup()
            .addComponent(sketchbookLocationField, javax.swing.GroupLayout.DEFAULT_SIZE, 400, Short.MAX_VALUE)
            .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
            .addComponent(browseButton))
          .addComponent(checkboxesContainer, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)
          .addGroup(jPanel1Layout.createSequentialGroup()
            .addGroup(jPanel1Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
              .addGroup(jPanel1Layout.createSequentialGroup()
                .addGroup(jPanel1Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                  .addComponent(jLabel1)
                  .addComponent(comboWarningsLabel))
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                .addGroup(jPanel1Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                  .addComponent(comboWarnings, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)
                  .addGroup(jPanel1Layout.createSequentialGroup()
                    .addComponent(autoScaleCheckBox)
                    .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                    .addComponent(scaleSpinner, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)
                    .addGap(0, 0, 0)
                    .addComponent(jLabel3)
                    .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                    .addComponent(jLabel2))))
              .addGroup(jPanel1Layout.createSequentialGroup()
                .addComponent(showVerboseLabel)
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                .addComponent(verboseCompilationBox)
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                .addComponent(verboseUploadBox))
              .addGroup(jPanel1Layout.createSequentialGroup()
                .addGroup(jPanel1Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                  .addComponent(comboLanguageLabel)
                  .addComponent(fontSizeLabel)
                  .addComponent(comboThemeLabel))
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                .addGroup(jPanel1Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                  .addGroup(jPanel1Layout.createSequentialGroup()
                    .addComponent(comboTheme, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)
                    .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                    .addComponent(requiresRestartLabel2))
                  .addComponent(fontSizeField, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)
                  .addGroup(jPanel1Layout.createSequentialGroup()
                    .addComponent(comboLanguage, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)
                    .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                    .addComponent(requiresRestartLabel))))
              .addComponent(arduinoNotRunningLabel)
              .addComponent(morePreferencesLabel)
              .addComponent(preferencesFileLabel)
              .addComponent(sketchbookLocationLabel)
              .addGroup(jPanel1Layout.createSequentialGroup()
                .addComponent(additionalBoardsManagerLabel)
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                .addComponent(additionalBoardsManagerField, javax.swing.GroupLayout.PREFERRED_SIZE, 500, javax.swing.GroupLayout.PREFERRED_SIZE)
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                .addComponent(extendedAdditionalUrlFieldWindow)))
            .addGap(0, 0, Short.MAX_VALUE)))
        .addContainerGap())
    );

    jPanel1Layout.linkSize(javax.swing.SwingConstants.HORIZONTAL, new java.awt.Component[] {comboLanguageLabel, comboWarningsLabel, fontSizeLabel, jLabel1, showVerboseLabel, comboThemeLabel});

    jPanel1Layout.setVerticalGroup(
      jPanel1Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
      .addGroup(javax.swing.GroupLayout.Alignment.TRAILING, jPanel1Layout.createSequentialGroup()
        .addContainerGap()
        .addComponent(sketchbookLocationLabel)
        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
        .addGroup(jPanel1Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE)
          .addComponent(sketchbookLocationField, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)
          .addComponent(browseButton))
        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
        .addGroup(jPanel1Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE)
          .addComponent(comboLanguageLabel)
          .addComponent(comboLanguage, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)
          .addComponent(requiresRestartLabel))
        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
        .addGroup(jPanel1Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE)
          .addComponent(fontSizeLabel)
          .addComponent(fontSizeField, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE))
        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
        .addGroup(jPanel1Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE)
          .addComponent(jLabel1)
          .addComponent(jLabel2)
          .addComponent(scaleSpinner, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)
          .addComponent(autoScaleCheckBox)
          .addComponent(jLabel3))
        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
        .addGroup(jPanel1Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE)
          .addComponent(comboThemeLabel)
          .addComponent(comboTheme, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)
          .addComponent(requiresRestartLabel2))
        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
        .addGroup(jPanel1Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE)
          .addComponent(showVerboseLabel)
          .addComponent(verboseCompilationBox)
          .addComponent(verboseUploadBox))
        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
        .addGroup(jPanel1Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE)
          .addComponent(comboWarningsLabel)
          .addComponent(comboWarnings, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE))
        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
        .addComponent(checkboxesContainer, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)
        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
        .addGroup(jPanel1Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
          .addGroup(jPanel1Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE)
            .addComponent(additionalBoardsManagerLabel)
            .addComponent(additionalBoardsManagerField, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE))
          .addComponent(extendedAdditionalUrlFieldWindow))
        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
        .addComponent(morePreferencesLabel)
        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
        .addComponent(preferencesFileLabel)
        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
        .addComponent(arduinoNotRunningLabel)
        .addContainerGap())
    );

    jTabbedPane1.addTab(tr(""Settings""), jPanel1);

    proxyTypeButtonGroup.add(noProxy);
    noProxy.setText(tr(""No proxy""));
    noProxy.setActionCommand(Constants.PROXY_TYPE_NONE);

    proxyTypeButtonGroup.add(autoProxy);
    autoProxy.setText(tr(""Auto-detect proxy settings""));
    autoProxy.setActionCommand(Constants.PROXY_TYPE_AUTO);
    autoProxy.addItemListener(new java.awt.event.ItemListener() {
      public void itemStateChanged(java.awt.event.ItemEvent evt) {
        autoProxyItemStateChanged(evt);
      }
    });

    proxyTypeButtonGroup.add(manualProxy);
    manualProxy.setText(tr(""Manual proxy configuration""));
    manualProxy.setActionCommand(Constants.PROXY_TYPE_MANUAL);
    manualProxy.addItemListener(new java.awt.event.ItemListener() {
      public void itemStateChanged(java.awt.event.ItemEvent evt) {
        manualProxyItemStateChanged(evt);
      }
    });

    autoProxyUsePAC.setText(tr(""Automatic proxy configuration URL:""));
    autoProxyUsePAC.addItemListener(new java.awt.event.ItemListener() {
      public void itemStateChanged(java.awt.event.ItemEvent evt) {
        autoProxyUsePACItemStateChanged(evt);
      }
    });

    manualProxyTypeButtonGroup.add(manualProxyHTTP);
    manualProxyHTTP.setText(""HTTP"");
    manualProxyHTTP.setActionCommand(Constants.PROXY_MANUAL_TYPE_HTTP);

    manualProxyTypeButtonGroup.add(manualProxySOCKS);
    manualProxySOCKS.setText(""SOCKS"");
    manualProxySOCKS.setActionCommand(Constants.PROXY_MANUAL_TYPE_SOCKS);

    manualProxyHostNameLabel.setText(tr(""Host name:""));

    manualProxyPortLabel.setText(tr(""Port number:""));

    manualProxyUsernameLabel.setText(tr(""Username:""));

    manualProxyPasswordLabel.setText(tr(""Password:""));

    manualProxyPassword.setToolTipText("""");

    autoProxyUsernameLabel.setText(tr(""Username:""));

    autoProxyPassword.setToolTipText("""");

    autoProxyPasswordLabel.setText(tr(""Password:""));

    javax.swing.GroupLayout jPanel4Layout = new javax.swing.GroupLayout(jPanel4);
    jPanel4.setLayout(jPanel4Layout);
    jPanel4Layout.setHorizontalGroup(
      jPanel4Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
      .addGroup(jPanel4Layout.createSequentialGroup()
        .addContainerGap()
        .addGroup(jPanel4Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
          .addGroup(jPanel4Layout.createSequentialGroup()
            .addGap(12, 12, 12)
            .addGroup(jPanel4Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
              .addComponent(autoProxyUsePAC)
              .addGroup(jPanel4Layout.createSequentialGroup()
                .addGap(12, 12, 12)
                .addGroup(jPanel4Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                  .addComponent(autoProxyUsernameLabel)
                  .addComponent(autoProxyPasswordLabel))))
            .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
            .addGroup(jPanel4Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
              .addComponent(autoProxyPACURL)
              .addGroup(jPanel4Layout.createSequentialGroup()
                .addGroup(jPanel4Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                  .addComponent(autoProxyUsername, javax.swing.GroupLayout.PREFERRED_SIZE, 178, javax.swing.GroupLayout.PREFERRED_SIZE)
                  .addComponent(autoProxyPassword, javax.swing.GroupLayout.PREFERRED_SIZE, 180, javax.swing.GroupLayout.PREFERRED_SIZE))
                .addGap(0, 0, Short.MAX_VALUE))))
          .addGroup(jPanel4Layout.createSequentialGroup()
            .addGroup(jPanel4Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
              .addComponent(noProxy)
              .addComponent(autoProxy)
              .addComponent(manualProxy)
              .addGroup(jPanel4Layout.createSequentialGroup()
                .addGap(12, 12, 12)
                .addGroup(jPanel4Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                  .addGroup(jPanel4Layout.createSequentialGroup()
                    .addComponent(manualProxyHTTP)
                    .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                    .addComponent(manualProxySOCKS))
                  .addGroup(jPanel4Layout.createSequentialGroup()
                    .addGroup(jPanel4Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                      .addComponent(manualProxyHostNameLabel)
                      .addComponent(manualProxyPortLabel)
                      .addComponent(manualProxyUsernameLabel)
                      .addComponent(manualProxyPasswordLabel))
                    .addGap(18, 18, 18)
                    .addGroup(jPanel4Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                      .addComponent(manualProxyHostName, javax.swing.GroupLayout.PREFERRED_SIZE, 541, javax.swing.GroupLayout.PREFERRED_SIZE)
                      .addComponent(manualProxyPort, javax.swing.GroupLayout.PREFERRED_SIZE, 74, javax.swing.GroupLayout.PREFERRED_SIZE)
                      .addGroup(jPanel4Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.TRAILING, false)
                        .addComponent(manualProxyPassword, javax.swing.GroupLayout.Alignment.LEADING)
                        .addComponent(manualProxyUsername, javax.swing.GroupLayout.Alignment.LEADING, javax.swing.GroupLayout.PREFERRED_SIZE, 180, javax.swing.GroupLayout.PREFERRED_SIZE)))))))
            .addGap(0, 0, Short.MAX_VALUE)))
        .addContainerGap())
    );
    jPanel4Layout.setVerticalGroup(
      jPanel4Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
      .addGroup(jPanel4Layout.createSequentialGroup()
        .addContainerGap()
        .addComponent(noProxy)
        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
        .addComponent(autoProxy)
        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
        .addGroup(jPanel4Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE)
          .addComponent(autoProxyUsePAC)
          .addComponent(autoProxyPACURL, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE))
        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
        .addGroup(jPanel4Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE)
          .addComponent(autoProxyUsername, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)
          .addComponent(autoProxyUsernameLabel))
        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
        .addGroup(jPanel4Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE)
          .addComponent(autoProxyPasswordLabel)
          .addComponent(autoProxyPassword, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE))
        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
        .addComponent(manualProxy)
        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
        .addGroup(jPanel4Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE)
          .addComponent(manualProxyHTTP)
          .addComponent(manualProxySOCKS))
        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
        .addGroup(jPanel4Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE)
          .addComponent(manualProxyHostNameLabel)
          .addComponent(manualProxyHostName, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE))
        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
        .addGroup(jPanel4Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE)
          .addComponent(manualProxyPort, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)
          .addComponent(manualProxyPortLabel))
        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
        .addGroup(jPanel4Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE)
          .addComponent(manualProxyUsername, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)
          .addComponent(manualProxyUsernameLabel))
        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
        .addGroup(jPanel4Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE)
          .addComponent(manualProxyPassword, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)
          .addComponent(manualProxyPasswordLabel))
        .addContainerGap(50, Short.MAX_VALUE))
    );

    jTabbedPane1.addTab(tr(""Network""), jPanel4);

    jPanel2.add(jTabbedPane1);

    okButton.setText(I18n.PROMPT_OK);
    okButton.addActionListener(new java.awt.event.ActionListener() {
      public void actionPerformed(java.awt.event.ActionEvent evt) {
        okButtonActionPerformed(evt);
      }
    });

    cancelButton.setText(I18n.PROMPT_CANCEL);
    cancelButton.addActionListener(new java.awt.event.ActionListener() {
      public void actionPerformed(java.awt.event.ActionEvent evt) {
        cancelButtonActionPerformed(evt);
      }
    });

    javax.swing.GroupLayout jPanel3Layout = new javax.swing.GroupLayout(jPanel3);
    jPanel3.setLayout(jPanel3Layout);
    jPanel3Layout.setHorizontalGroup(
      jPanel3Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
      .addGroup(javax.swing.GroupLayout.Alignment.TRAILING, jPanel3Layout.createSequentialGroup()
        .addContainerGap(javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)
        .addComponent(okButton)
        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
        .addComponent(cancelButton)
        .addContainerGap())
    );
    jPanel3Layout.setVerticalGroup(
      jPanel3Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
      .addGroup(javax.swing.GroupLayout.Alignment.TRAILING, jPanel3Layout.createSequentialGroup()
        .addGroup(jPanel3Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE)
          .addComponent(okButton)
          .addComponent(cancelButton)))
    );

    jPanel2.add(jPanel3);

    javax.swing.GroupLayout layout = new javax.swing.GroupLayout(getContentPane());
    getContentPane().setLayout(layout);
    layout.setHorizontalGroup(
      layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
      .addGap(0, 800, Short.MAX_VALUE)
      .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
        .addComponent(jPanel2, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE))
    );
    layout.setVerticalGroup(
      layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
      .addGap(0, 400, Short.MAX_VALUE)
      .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
        .addComponent(jPanel2, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE))
    );

    pack();
  }",break_loop_control
language,"{
    sketchbookLocationField.setText(PreferencesData.get(""sketchbook.path""));

    String currentLanguageISOCode = PreferencesData.get(""editor.languages.current"");
    for (Language language : Languages.languages) {
      if (language.getIsoCode().equals(currentLanguageISOCode)) {
        comboLanguage.setSelectedItem(language);
      }
    }

    String selectedTheme = PreferencesData.get(""theme.file"", """");
    Collection<ZippedTheme> availablethemes = Theme.getAvailablethemes();
    comboTheme.addItem(tr(""Default theme""));
    for (ZippedTheme theme : availablethemes) {
      comboTheme.addItem(theme);
      if (theme.getKey().equals(selectedTheme)) {
        comboTheme.setSelectedItem(theme);
      }
    }

    Font editorFont = PreferencesData.getFont(""editor.font"");
    fontSizeField.setText(String.valueOf(editorFont.getSize()));

    try {
      int scale = PreferencesData.getInteger(""gui.scale"", -1);
      if (scale != -1) {
        autoScaleCheckBox.setSelected(false);
        scaleSpinner.setValue(scale);
      }
    } catch (NumberFormatException ignore) {
      // In any case defaults to ""auto""
    }

    verboseCompilationBox.setSelected(PreferencesData.getBoolean(""build.verbose""));
    verboseUploadBox.setSelected(PreferencesData.getBoolean(""upload.verbose""));

    String currentWarningLevel = PreferencesData.get(""compiler.warning_level"", ""none"");
    for (WarningItem item : warningItems) {
      if (currentWarningLevel.equals(item.getValue())) {
        comboWarnings.setSelectedItem(item);
      }
    }

    displayLineNumbersBox.setSelected(PreferencesData.getBoolean(""editor.linenumbers""));

    enableCodeFoldingBox.setSelected(PreferencesData.getBoolean(""editor.code_folding""));

    verifyUploadBox.setSelected(PreferencesData.getBoolean(""upload.verify""));

    externalEditorBox.setSelected(PreferencesData.getBoolean(""editor.external""));

    if (PreferencesData.get(""compiler.cache_core"") == null) {
      PreferencesData.setBoolean(""compiler.cache_core"", true);
    }

    checkUpdatesBox.setSelected(PreferencesData.getBoolean(""update.check""));

    if (PreferencesData.get(""editor.update_extension"") == null) {
      PreferencesData.setBoolean(""editor.update_extension"", true);
    }

    accessibleIDEBox.setSelected(PreferencesData.getBoolean(""ide.accessible""));

    saveVerifyUploadBox.setSelected(PreferencesData.getBoolean(""editor.save_on_verify""));

    additionalBoardsManagerField.setText(PreferencesData.get(""boardsmanager.additional.urls""));

    disableAllProxyFields();
    String proxyType = PreferencesData.get(Constants.PREF_PROXY_TYPE, Constants.PROXY_TYPE_AUTO);

    if (Constants.PROXY_TYPE_NONE.equals(proxyType)) {
      noProxy.setSelected(true);
    } else if (Constants.PROXY_TYPE_AUTO.equals(proxyType)) {
      autoProxy.setSelected(true);
      autoProxyFieldsSetEnabled(true);
      if (!PreferencesData.get(Constants.PREF_PROXY_PAC_URL, """").isEmpty()) {
        autoProxyUsePAC.setSelected(true);
        autoProxyPACURL.setText(PreferencesData.get(Constants.PREF_PROXY_PAC_URL));
        autoProxyUsername.setText(PreferencesData.get(Constants.PREF_PROXY_USERNAME));
        autoProxyPassword.setText(PreferencesData.get(Constants.PREF_PROXY_PASSWORD));
      }
    } else {
      manualProxy.setSelected(true);
      manualProxyFieldsSetEnabled(true);
      manualProxyHostName.setText(PreferencesData.get(Constants.PREF_PROXY_MANUAL_HOSTNAME));
      manualProxyPort.setText(PreferencesData.get(Constants.PREF_PROXY_MANUAL_PORT));
      manualProxyUsername.setText(PreferencesData.get(Constants.PREF_PROXY_USERNAME));
      manualProxyPassword.setText(PreferencesData.get(Constants.PREF_PROXY_PASSWORD));
    }

    String selectedManualProxyType = PreferencesData.get(Constants.PREF_PROXY_MANUAL_TYPE, Constants.PROXY_MANUAL_TYPE_HTTP);
    manualProxyHTTP.setSelected(Constants.PROXY_MANUAL_TYPE_HTTP.equals(selectedManualProxyType));
    manualProxySOCKS.setSelected(Constants.PROXY_MANUAL_TYPE_SOCKS.equals(selectedManualProxyType));
  }",iterator
theme,"{
    sketchbookLocationField.setText(PreferencesData.get(""sketchbook.path""));

    String currentLanguageISOCode = PreferencesData.get(""editor.languages.current"");
    for (Language language : Languages.languages) {
      if (language.getIsoCode().equals(currentLanguageISOCode)) {
        comboLanguage.setSelectedItem(language);
      }
    }

    String selectedTheme = PreferencesData.get(""theme.file"", """");
    Collection<ZippedTheme> availablethemes = Theme.getAvailablethemes();
    comboTheme.addItem(tr(""Default theme""));
    for (ZippedTheme theme : availablethemes) {
      comboTheme.addItem(theme);
      if (theme.getKey().equals(selectedTheme)) {
        comboTheme.setSelectedItem(theme);
      }
    }

    Font editorFont = PreferencesData.getFont(""editor.font"");
    fontSizeField.setText(String.valueOf(editorFont.getSize()));

    try {
      int scale = PreferencesData.getInteger(""gui.scale"", -1);
      if (scale != -1) {
        autoScaleCheckBox.setSelected(false);
        scaleSpinner.setValue(scale);
      }
    } catch (NumberFormatException ignore) {
      // In any case defaults to ""auto""
    }

    verboseCompilationBox.setSelected(PreferencesData.getBoolean(""build.verbose""));
    verboseUploadBox.setSelected(PreferencesData.getBoolean(""upload.verbose""));

    String currentWarningLevel = PreferencesData.get(""compiler.warning_level"", ""none"");
    for (WarningItem item : warningItems) {
      if (currentWarningLevel.equals(item.getValue())) {
        comboWarnings.setSelectedItem(item);
      }
    }

    displayLineNumbersBox.setSelected(PreferencesData.getBoolean(""editor.linenumbers""));

    enableCodeFoldingBox.setSelected(PreferencesData.getBoolean(""editor.code_folding""));

    verifyUploadBox.setSelected(PreferencesData.getBoolean(""upload.verify""));

    externalEditorBox.setSelected(PreferencesData.getBoolean(""editor.external""));

    if (PreferencesData.get(""compiler.cache_core"") == null) {
      PreferencesData.setBoolean(""compiler.cache_core"", true);
    }

    checkUpdatesBox.setSelected(PreferencesData.getBoolean(""update.check""));

    if (PreferencesData.get(""editor.update_extension"") == null) {
      PreferencesData.setBoolean(""editor.update_extension"", true);
    }

    accessibleIDEBox.setSelected(PreferencesData.getBoolean(""ide.accessible""));

    saveVerifyUploadBox.setSelected(PreferencesData.getBoolean(""editor.save_on_verify""));

    additionalBoardsManagerField.setText(PreferencesData.get(""boardsmanager.additional.urls""));

    disableAllProxyFields();
    String proxyType = PreferencesData.get(Constants.PREF_PROXY_TYPE, Constants.PROXY_TYPE_AUTO);

    if (Constants.PROXY_TYPE_NONE.equals(proxyType)) {
      noProxy.setSelected(true);
    } else if (Constants.PROXY_TYPE_AUTO.equals(proxyType)) {
      autoProxy.setSelected(true);
      autoProxyFieldsSetEnabled(true);
      if (!PreferencesData.get(Constants.PREF_PROXY_PAC_URL, """").isEmpty()) {
        autoProxyUsePAC.setSelected(true);
        autoProxyPACURL.setText(PreferencesData.get(Constants.PREF_PROXY_PAC_URL));
        autoProxyUsername.setText(PreferencesData.get(Constants.PREF_PROXY_USERNAME));
        autoProxyPassword.setText(PreferencesData.get(Constants.PREF_PROXY_PASSWORD));
      }
    } else {
      manualProxy.setSelected(true);
      manualProxyFieldsSetEnabled(true);
      manualProxyHostName.setText(PreferencesData.get(Constants.PREF_PROXY_MANUAL_HOSTNAME));
      manualProxyPort.setText(PreferencesData.get(Constants.PREF_PROXY_MANUAL_PORT));
      manualProxyUsername.setText(PreferencesData.get(Constants.PREF_PROXY_USERNAME));
      manualProxyPassword.setText(PreferencesData.get(Constants.PREF_PROXY_PASSWORD));
    }

    String selectedManualProxyType = PreferencesData.get(Constants.PREF_PROXY_MANUAL_TYPE, Constants.PROXY_MANUAL_TYPE_HTTP);
    manualProxyHTTP.setSelected(Constants.PROXY_MANUAL_TYPE_HTTP.equals(selectedManualProxyType));
    manualProxySOCKS.setSelected(Constants.PROXY_MANUAL_TYPE_SOCKS.equals(selectedManualProxyType));
  }",iterator
item,"{
    sketchbookLocationField.setText(PreferencesData.get(""sketchbook.path""));

    String currentLanguageISOCode = PreferencesData.get(""editor.languages.current"");
    for (Language language : Languages.languages) {
      if (language.getIsoCode().equals(currentLanguageISOCode)) {
        comboLanguage.setSelectedItem(language);
      }
    }

    String selectedTheme = PreferencesData.get(""theme.file"", """");
    Collection<ZippedTheme> availablethemes = Theme.getAvailablethemes();
    comboTheme.addItem(tr(""Default theme""));
    for (ZippedTheme theme : availablethemes) {
      comboTheme.addItem(theme);
      if (theme.getKey().equals(selectedTheme)) {
        comboTheme.setSelectedItem(theme);
      }
    }

    Font editorFont = PreferencesData.getFont(""editor.font"");
    fontSizeField.setText(String.valueOf(editorFont.getSize()));

    try {
      int scale = PreferencesData.getInteger(""gui.scale"", -1);
      if (scale != -1) {
        autoScaleCheckBox.setSelected(false);
        scaleSpinner.setValue(scale);
      }
    } catch (NumberFormatException ignore) {
      // In any case defaults to ""auto""
    }

    verboseCompilationBox.setSelected(PreferencesData.getBoolean(""build.verbose""));
    verboseUploadBox.setSelected(PreferencesData.getBoolean(""upload.verbose""));

    String currentWarningLevel = PreferencesData.get(""compiler.warning_level"", ""none"");
    for (WarningItem item : warningItems) {
      if (currentWarningLevel.equals(item.getValue())) {
        comboWarnings.setSelectedItem(item);
      }
    }

    displayLineNumbersBox.setSelected(PreferencesData.getBoolean(""editor.linenumbers""));

    enableCodeFoldingBox.setSelected(PreferencesData.getBoolean(""editor.code_folding""));

    verifyUploadBox.setSelected(PreferencesData.getBoolean(""upload.verify""));

    externalEditorBox.setSelected(PreferencesData.getBoolean(""editor.external""));

    if (PreferencesData.get(""compiler.cache_core"") == null) {
      PreferencesData.setBoolean(""compiler.cache_core"", true);
    }

    checkUpdatesBox.setSelected(PreferencesData.getBoolean(""update.check""));

    if (PreferencesData.get(""editor.update_extension"") == null) {
      PreferencesData.setBoolean(""editor.update_extension"", true);
    }

    accessibleIDEBox.setSelected(PreferencesData.getBoolean(""ide.accessible""));

    saveVerifyUploadBox.setSelected(PreferencesData.getBoolean(""editor.save_on_verify""));

    additionalBoardsManagerField.setText(PreferencesData.get(""boardsmanager.additional.urls""));

    disableAllProxyFields();
    String proxyType = PreferencesData.get(Constants.PREF_PROXY_TYPE, Constants.PROXY_TYPE_AUTO);

    if (Constants.PROXY_TYPE_NONE.equals(proxyType)) {
      noProxy.setSelected(true);
    } else if (Constants.PROXY_TYPE_AUTO.equals(proxyType)) {
      autoProxy.setSelected(true);
      autoProxyFieldsSetEnabled(true);
      if (!PreferencesData.get(Constants.PREF_PROXY_PAC_URL, """").isEmpty()) {
        autoProxyUsePAC.setSelected(true);
        autoProxyPACURL.setText(PreferencesData.get(Constants.PREF_PROXY_PAC_URL));
        autoProxyUsername.setText(PreferencesData.get(Constants.PREF_PROXY_USERNAME));
        autoProxyPassword.setText(PreferencesData.get(Constants.PREF_PROXY_PASSWORD));
      }
    } else {
      manualProxy.setSelected(true);
      manualProxyFieldsSetEnabled(true);
      manualProxyHostName.setText(PreferencesData.get(Constants.PREF_PROXY_MANUAL_HOSTNAME));
      manualProxyPort.setText(PreferencesData.get(Constants.PREF_PROXY_MANUAL_PORT));
      manualProxyUsername.setText(PreferencesData.get(Constants.PREF_PROXY_USERNAME));
      manualProxyPassword.setText(PreferencesData.get(Constants.PREF_PROXY_PASSWORD));
    }

    String selectedManualProxyType = PreferencesData.get(Constants.PREF_PROXY_MANUAL_TYPE, Constants.PROXY_MANUAL_TYPE_HTTP);
    manualProxyHTTP.setSelected(Constants.PROXY_MANUAL_TYPE_HTTP.equals(selectedManualProxyType));
    manualProxySOCKS.setSelected(Constants.PROXY_MANUAL_TYPE_SOCKS.equals(selectedManualProxyType));
  }",iterator
base,"{
    if (PreferencesData.getInteger(""builtin_platform_is_newer"", -1) >= BaseNoGui.REVISION) {
      return;
    }

    List<ContributedPlatform> contributedPlatforms = BaseNoGui.indexer
        .getPackages().stream() //
        .map(pack -> pack.getPlatforms()) //
        .flatMap(platfs -> platfs.stream()) //
        .collect(Collectors.toList());

    Optional<ContributedPlatform> mayInstalledBuiltIn = contributedPlatforms
        .stream() //
        .filter(p -> p.isInstalled()) //
        .filter(p -> p.isBuiltIn()) //
        .findFirst();
    if (!mayInstalledBuiltIn.isPresent()) {
      return;
    }
    final ContributedPlatform installedBuiltIn = mayInstalledBuiltIn.get();

    ContributedPlatform installedNotBuiltIn = BaseNoGui.indexer.getInstalled(installedBuiltIn.getParentPackage().getName(), installedBuiltIn.getArchitecture());
    if (installedNotBuiltIn == null) {
      return;
    }

    while (!base.hasActiveEditor()) {
      Thread.sleep(100);
    }

    if (VersionComparator.greaterThan(installedBuiltIn.getParsedVersion(), installedNotBuiltIn.getParsedVersion())) {
      SwingUtilities.invokeLater(() -> {
        PreferencesData.setInteger(""builtin_platform_is_newer"", BaseNoGui.REVISION);
        assert base.hasActiveEditor();
        int chosenOption = JOptionPane.showConfirmDialog(base.getActiveEditor(), I18n.format(tr(""The IDE includes an updated {0} package, but you're using an older one.\nDo you want to upgrade {0}?""), installedBuiltIn.getName()), I18n.format(tr(""A newer {0} package is available""), installedBuiltIn.getName()), JOptionPane.YES_NO_OPTION, JOptionPane.QUESTION_MESSAGE);
        if (chosenOption == JOptionPane.YES_OPTION) {
          try {
            base.openBoardsManager(installedBuiltIn.getName(), """");
          } catch (Exception e) {
            e.printStackTrace();
          }
        }
      });
    }
  }",maybe_loop_control
e,"{
    updateContributionIndex();
    updateLibrariesIndex();

    boolean updatablePlatforms = checkForUpdatablePlatforms();

    boolean updatableLibraries = checkForUpdatableLibraries();

    if (!updatableLibraries && !updatablePlatforms) {
      return;
    }

    boolean setAccessible = PreferencesData.getBoolean(""ide.accessible"");
    final String text;
    final String button1Name;
    final String button2Name;
    String openAnchorBoards  = ""<a href=\"""" + boardsManagerURL + ""\"">"";
    String closeAnchorBoards = ""</a>"";
    String openAnchorLibraries  = ""<a href=\"""" + libraryManagerURL + ""\"">"";
    String closeAnchorLibraries = ""</a>"";

    // if accessibility mode and board updates are available set the button name and clear the anchors
    if(setAccessible && updatablePlatforms) {
        button1Name = tr(""Boards"");
        openAnchorBoards = """";
        closeAnchorBoards = """";
    }
    else { // when not accessibility mode or no boards to update no button is needed
      button1Name = null;
    }

    // if accessibility mode and libraries updates are available set the button name and clear the anchors
    if (setAccessible && updatableLibraries) {
      button2Name = tr(""Libraries"");
      openAnchorLibraries = """";
      closeAnchorLibraries = """";
    }
    else { // when not accessibility mode or no libraries to update no button is needed
      button2Name = null;
    }

    if (updatableLibraries && !updatablePlatforms) {
      text = I18n.format(tr(""Updates available for some of your {0}libraries{1}""), openAnchorLibraries, closeAnchorLibraries);
    } else if (!updatableLibraries && updatablePlatforms) {
      text = I18n.format(tr(""Updates available for some of your {0}boards{1}""), openAnchorBoards, closeAnchorBoards);
    } else {
      text = I18n.format(tr(""Updates available for some of your {0}boards{1} and {2}libraries{3}""), openAnchorBoards, closeAnchorBoards, openAnchorLibraries, closeAnchorLibraries);
    }

    if (cancelled) {
      return;
    }

    SwingUtilities.invokeLater(() -> {
      Editor ed = base.getActiveEditor();
      boolean accessibleIde = PreferencesData.getBoolean(""ide.accessible"");
      if (accessibleIde) {
        notificationPopup = new NotificationPopup(ed, hyperlinkListener, text, false, this, button1Name, button2Name);
      }
      else {  // if not accessible view leave it the same
        notificationPopup = new NotificationPopup(ed, hyperlinkListener, text);
      }
      if (ed.isFocused()) {
        notificationPopup.begin();
        return;
      }

      // If the IDE is not focused wait until it is focused again to
      // display the notification, this avoids the annoying side effect
      // to ""steal"" the focus from another application.
      WindowFocusListener wfl = new WindowFocusListener() {
        @Override
        public void windowLostFocus(WindowEvent evt) {
        }

        @Override
        public void windowGainedFocus(WindowEvent evt) {
          notificationPopup.begin();
          for (Editor e : base.getEditors())
            e.removeWindowFocusListener(this);
        }
      };
      for (Editor e : base.getEditors())
        e.addWindowFocusListener(wfl);
    });
  }",iterator
s,"{
    // Check if categories have changed
    Collection<String> categories = BaseNoGui.indexer.getCategories();
    if (categories.equals(oldCategories)) {
      return;
    }
    oldCategories = categories;

    categoryChooser.removeActionListener(categoryChooserActionListener);
    // Enable categories combo only if there are two or more choices
    filterField.setEnabled(getContribModel().getRowCount() > 0);
    categoryFilter = x -> true;
    categoryChooser.removeAllItems();
    categoryChooser.addItem(new DropdownAllCoresItem());
    categoryChooser.addItem(new DropdownUpdatableCoresItem());
    for (String s : categories) {
      categoryChooser.addItem(new DropdownCoreOfCategoryItem(s));
    }
    categoryChooser.addActionListener(categoryChooserActionListener);
    categoryChooser.setSelectedIndex(0);
  }",iterator
board,"{
    ContributedPlatformReleases releases = (ContributedPlatformReleases) value;

    // FIXME: happens on macosx, don't know why
    if (releases == null) {
      return;
    }

    ContributedPlatform selected = releases.getSelected();
    titledBorder.setTitle(selected.getName());
    ContributedPlatform installed = releases.getInstalled();

    boolean removable, installable, upgradable;
    if (installed == null) {
      installable = true;
      removable = false;
      upgradable = false;
    } else {
      installable = false;
      removable = !installed.isBuiltIn() && !hasBuiltInRelease;
      upgradable = new DownloadableContributionVersionComparator()
          .compare(selected, installed) > 0;
    }
    if (installable) {
      installButton.setText(tr(""Install""));
    }
    if (upgradable) {
      installButton.setText(tr(""Update""));
    }
    installButton.setVisible(installable || upgradable);
    installButtonPlaceholder.setVisible(!(installable || upgradable));
    removeButton.setVisible(removable);
    removeButtonPlaceholder.setVisible(!removable);

    String desc = ""<html><body>"";
//    desc += ""<b>"" + selected.getName() + ""</b>"";
    if (installed != null && installed.isBuiltIn()) {
      desc += "" Built-In "";
    }

    String author = selected.getParentPackage().getMaintainer();
    if (author != null && !author.isEmpty()) {
      desc += "" "" + format(""by <b>{0}</b>"", author);
    }
    if (installed != null) {
      desc += "" ""
              + format(tr(""version <b>{0}</b>""), installed.getParsedVersion())
              + "" <strong><font color=\""#00979D\"">INSTALLED</font></strong>"";
    }
    if (releases.isDeprecated()) {
      desc += "" <strong><font color=\""#C03030\"">DEPRECATED</font></strong>"";
    }
    desc += ""<br />"";

    desc += tr(""Boards included in this package:"") + ""<br />"";
    for (ContributedBoard board : selected.getBoards()) {
      desc += board.getName() + "", "";
    }
    if (desc.lastIndexOf(',') != -1) {
      desc = desc.substring(0, desc.lastIndexOf(',')) + "".<br />"";
    }

    ContributedHelp help = null;
    if (selected.getHelp() != null) {
      help = selected.getHelp();
    } else if (selected.getParentPackage().getHelp() != null) {
      help = selected.getParentPackage().getHelp();
    }

    if (help != null) {
      String url = help.getOnline();
      if (url != null && !url.isEmpty()) {
        desc = setButtonOrLink(onlineHelpButton, desc, onlineHelpLbl, url);
      }
    }

    String url = selected.getParentPackage().getWebsiteURL();
    if (url != null && !url.isEmpty()) {
      desc = setButtonOrLink(moreInfoButton, desc, moreInfoLbl, url);
    }

    desc += ""</body></html>"";
    description.setText(desc);
    // copy description to accessibility context for screen readers to use
    description.getAccessibleContext().setAccessibleDescription(desc);

    // for modelToView to work, the text area has to be sized. It doesn't
    // matter if it's visible or not.

    // See:
    // http://stackoverflow.com/questions/3081210/how-to-set-jtextarea-to-have-height-that-matches-the-size-of-a-text-it-contains
    int width = parentTable.getBounds().width;
    InstallerTableCell.setJTextPaneDimensionToFitContainedText(description,
                                                               width);
  }",iterator
plat,"{
    for (ContributedPlatform plat : releases) {
      if (plat == value) {
        selected = plat;
        return;
      }
    }
  }",iterator
pack,"{
    contributions.clear();

    // Generate ContributedPlatformReleases from all platform releases
    for (ContributedPackage pack : BaseNoGui.indexer.getPackages()) {
      for (ContributedPlatform platform : pack.getPlatforms()) {
        addContribution(platform);
      }
    }

    // Filter ContributedPlatformReleases based on search terms
    contributions.removeIf(releases -> {
      for (ContributedPlatform platform : releases.releases) {
        String compoundTargetSearchText = platform.getName() + ""\n""
                                          + platform.getBoards().stream()
                                              .map(ContributedBoard::getName)
                                              .collect(Collectors.joining("" ""));
        if (!filter.test(platform)) {
          continue;
        }
        if (!stringContainsAll(compoundTargetSearchText, filters))
          continue;
        return false;
      }
      return true;
    });

    // Sort ContributedPlatformReleases and put deprecated platforms to the bottom
    Collections.sort(contributions, (x,y)-> {
      if (x.isDeprecated() != y.isDeprecated()) {
        return x.isDeprecated() ? 1 : -1;
      }
      ContributedPlatform x1 = x.getLatest();
      ContributedPlatform y1 = y.getLatest();
      int category = (x1.getCategory().equals(""Arduino"") ? -1 : 0) + (y1.getCategory().equals(""Arduino"") ? 1 : 0);
      if (category != 0) {
        return category;
      }
      return x1.getName().compareToIgnoreCase(y1.getName());
    });

    fireTableDataChanged();
  }",iterator
platform,"{
    contributions.clear();

    // Generate ContributedPlatformReleases from all platform releases
    for (ContributedPackage pack : BaseNoGui.indexer.getPackages()) {
      for (ContributedPlatform platform : pack.getPlatforms()) {
        addContribution(platform);
      }
    }

    // Filter ContributedPlatformReleases based on search terms
    contributions.removeIf(releases -> {
      for (ContributedPlatform platform : releases.releases) {
        String compoundTargetSearchText = platform.getName() + ""\n""
                                          + platform.getBoards().stream()
                                              .map(ContributedBoard::getName)
                                              .collect(Collectors.joining("" ""));
        if (!filter.test(platform)) {
          continue;
        }
        if (!stringContainsAll(compoundTargetSearchText, filters))
          continue;
        return false;
      }
      return true;
    });

    // Sort ContributedPlatformReleases and put deprecated platforms to the bottom
    Collections.sort(contributions, (x,y)-> {
      if (x.isDeprecated() != y.isDeprecated()) {
        return x.isDeprecated() ? 1 : -1;
      }
      ContributedPlatform x1 = x.getLatest();
      ContributedPlatform y1 = y.getLatest();
      int category = (x1.getCategory().equals(""Arduino"") ? -1 : 0) + (y1.getCategory().equals(""Arduino"") ? 1 : 0);
      if (category != 0) {
        return category;
      }
      return x1.getName().compareToIgnoreCase(y1.getName());
    });

    fireTableDataChanged();
  }",iterator
s,"{
    if (set == null)
      return true;
    for (String s : set) {
      if (!string.toLowerCase().contains(s.toLowerCase()))
        return false;
    }
    return true;
  }",iterator
contribution,"{
    for (ContributedPlatformReleases contribution : contributions) {
      if (!contribution.shouldContain(platform)) {
        continue;
      }
      contribution.add(platform);
      return;
    }
    contributions.add(new ContributedPlatformReleases(platform));
  }",iterator
filter,"{
    if (string == null) {
      return false;
    }

    if (filters == null) {
      return true;
    }

    for (String filter : filters) {
      if (!string.toLowerCase().contains(filter.toLowerCase())) {
        return false;
      }
    }

    return true;
  }",iterator
releases,"{
    // Find the row interested in the change
    int row = -1;
    for (ContributedLibraryReleases releases : contributions) {
      if (releases.shouldContain(lib))
        row = contributions.indexOf(releases);
    }

    updateContributions();

    // If the library is found in the list send update event
    // or insert event on the specific row...
    for (ContributedLibraryReleases releases : contributions) {
      if (releases.shouldContain(lib)) {
        if (row == -1) {
          row = contributions.indexOf(releases);
          fireTableRowsInserted(row, row);
        } else {
          fireTableRowsUpdated(row, row);
        }
        return;
      }
    }
    // ...otherwise send a row deleted event
    fireTableRowsDeleted(row, row);
  }",iterator
releases,"{
    // Find the row interested in the change
    int row = -1;
    for (ContributedLibraryReleases releases : contributions) {
      if (releases.shouldContain(lib))
        row = contributions.indexOf(releases);
    }

    updateContributions();

    // If the library is found in the list send update event
    // or insert event on the specific row...
    for (ContributedLibraryReleases releases : contributions) {
      if (releases.shouldContain(lib)) {
        if (row == -1) {
          row = contributions.indexOf(releases);
          fireTableRowsInserted(row, row);
        } else {
          fireTableRowsUpdated(row, row);
        }
        return;
      }
    }
    // ...otherwise send a row deleted event
    fireTableRowsDeleted(row, row);
  }",break_loop_control
contribution,"{
    List<ContributedLibraryReleases> res = new ArrayList<>();
    BaseNoGui.librariesIndexer.getIndex().getLibraries(). //
        forEach(lib -> {
          for (ContributedLibraryReleases contribution : res) {
            if (!contribution.shouldContain(lib))
              continue;
            contribution.add(lib);
            return;
          }

          res.add(new ContributedLibraryReleases(lib));
        });
    return res;
  }",iterator
l,"{
    super(parent, format(tr(""Dependencies for library {0}:{1}""), lib.getName(),
                         lib.getParsedVersion()),
        ModalityType.APPLICATION_MODAL);
    Container pane = getContentPane();
    pane.setLayout(new BorderLayout());

    pane.add(Box.createHorizontalStrut(10), BorderLayout.WEST);
    pane.add(Box.createHorizontalStrut(10), BorderLayout.EAST);

    {
      JButton cancel = new JButton(tr(""Cancel""));
      cancel.addActionListener(ev -> {
        result = Result.CANCEL;
        setVisible(false);
      });

      JButton all = new JButton(tr(""Install all""));
      all.addActionListener(ev -> {
        result = Result.ALL;
        setVisible(false);
      });

      JButton none = new JButton(format(tr(""Install '{0}' only""), lib.getName()));
      none.addActionListener(ev -> {
        result = Result.NONE;
        setVisible(false);
      });

      Box buttonsBox = Box.createHorizontalBox();
      buttonsBox.add(all);
      buttonsBox.add(Box.createHorizontalStrut(5));
      buttonsBox.add(none);
      buttonsBox.add(Box.createHorizontalStrut(5));
      buttonsBox.add(cancel);

      JPanel buttonsPanel = new JPanel();
      buttonsPanel.setBorder(new EmptyBorder(7, 10, 7, 10));
      buttonsPanel.setLayout(new BoxLayout(buttonsPanel, BoxLayout.Y_AXIS));
      buttonsPanel.add(buttonsBox);

      pane.add(buttonsPanel, BorderLayout.SOUTH);
    }

    {
      String libName = format(""<b>{0}:{1}</b>"", lib.getName(),
                              lib.getParsedVersion());
      String desc = format(tr(""The library {0} needs some other library<br />dependencies currently not installed:""),
                           libName);
      desc += ""<br/><br/>"";
      for (ContributedLibrary l : dependencies) {
        if (l.getName().equals(lib.getName()))
          continue;
        if (l.getInstalledLibrary().isPresent())
          continue;
        if (l instanceof UnavailableContributedLibrary)
          continue;
        desc += format(""- <b>{0}</b><br/>"", l.getName());
      }
      desc += ""<br/>"";
      desc += tr(""Would you like to install also all the missing dependencies?"");

      JTextPane textArea = makeNewDescription();
      textArea.setContentType(""text/html"");
      textArea.setText(desc);

      JPanel libsList = new JPanel();
      libsList.setLayout(new BoxLayout(libsList, BoxLayout.Y_AXIS));
      libsList.add(textArea);
      libsList.setBorder(new EmptyBorder(7, 7, 7, 7));
      pane.add(libsList, BorderLayout.NORTH);
    }

    pack();
    setResizable(false);
    setDefaultCloseOperation(WindowConstants.DISPOSE_ON_CLOSE);

    WindowEvent closing = new WindowEvent(this, WindowEvent.WINDOW_CLOSING);
    Base.registerWindowCloseKeys(getRootPane(), e -> dispatchEvent(closing));
  }",iterator
type,"{
    // Check if categories or types have changed
    Collection<String> categories = BaseNoGui.librariesIndexer.getIndex().getCategories();
    List<String> types = new LinkedList<>(BaseNoGui.librariesIndexer.getIndex().getTypes());
    Collections.sort(types, new LibraryTypeComparator());

    if (categories.equals(oldCategories) && types.equals(oldTypes)) {
      return;
    }
    oldCategories = categories;
    oldTypes = types;

    // Load categories
    categoryFilter = x -> true;
    categoryChooser.removeActionListener(categoryChooserActionListener);
    categoryChooser.removeAllItems();
    categoryChooser.addItem(new DropdownAllLibraries());
    for (String category : categories) {
      categoryChooser.addItem(new DropdownLibraryOfCategoryItem(category));
    }
    categoryChooser.setEnabled(categoryChooser.getItemCount() > 1);
    categoryChooser.addActionListener(categoryChooserActionListener);
    categoryChooser.setSelectedIndex(0);

    // Load types
    extraFilter = x -> true;
    typeChooser.removeActionListener(typeChooserActionListener);
    typeChooser.removeAllItems();
    typeChooser.addItem(new DropdownAllLibraries());
    typeChooser.addItem(new DropdownUpdatableLibrariesItem());
    typeChooser.addItem(new DropdownInstalledLibraryItem());
    for (String type : types) {
      typeChooser.addItem(new DropdownLibraryOfTypeItem(type));
    }
    typeChooser.setEnabled(typeChooser.getItemCount() > 1);
    typeChooser.addActionListener(typeChooserActionListener);
    typeChooser.setSelectedIndex(0);

    filterField.setEnabled(contribModel.getRowCount() > 0);
  }",iterator
listener,"{
    for (FocusListener listener : filterField.getFocusListeners()) {
      listener.focusGained(new FocusEvent(filterField, FocusEvent.FOCUS_GAINED));
    }
    filterField.setText(filterText);
    filterField.applyFilter();
  }",iterator
i,"{
    for (int i = 0; i < combo.getItemCount(); i++) {
      if (dropdownItem.equals(combo.getItemAt(i).getClass().getSimpleName())) {
        combo.setSelectedIndex(i);
        return;
      }
    }
  }",loop_control
dropdownItem,"{
    for (int i = 0; i < combo.getItemCount(); i++) {
      if (dropdownItem.equals(combo.getItemAt(i).getClass().getSimpleName())) {
        combo.setSelectedIndex(i);
        return;
      }
    }
  }",break_loop_control
listener,"{
    if (delegate.getKeyListeners() == null) {
      return;
    }

    for (KeyListener listener : delegate.getKeyListeners()) {
      listener.keyTyped(keyEvent);
    }
  }",iterator
listener,"{
    if (delegate.getKeyListeners() == null) {
      return;
    }

    for (KeyListener listener : delegate.getKeyListeners()) {
      listener.keyPressed(keyEvent);
    }
  }",iterator
listener,"{
    if (delegate.getKeyListeners() == null) {
      return;
    }

    for (KeyListener listener : delegate.getKeyListeners()) {
      listener.keyReleased(keyEvent);
    }
  }",iterator
i,"{
    GraphicsEnvironment environment =
      GraphicsEnvironment.getLocalGraphicsEnvironment();
    devices = environment.getScreenDevices();
    GraphicsDevice defaultDevice = environment.getDefaultScreenDevice();

    Vector<String> names = new Vector<>();
    for (int i = 0; i < devices.length; i++) {
      String name = String.valueOf(i + 1);
      if (devices[i] == defaultDevice) {
        defaultIndex = i;
        name += "" (default)"";
      }
      names.add(name);
    }

    selector = new JComboBox(names);
    selector.addActionListener(new ActionListener() {
        public void actionPerformed(ActionEvent e) {
          int index = selector.getSelectedIndex();
          //device = devices[index];
          PreferencesData.setInteger(""run.present.display"", index + 1);
        }
      });
  }",loop_control
i,"{
      g.setColor(color);
      g.setStroke(new BasicStroke(1.0f));

      for (int i = 0; i < buffer.size() - 1; ++i) {
        g.drawLine(
          (int) (i * xstep), (int) transformY(buffer.get(i), minY, rangeY, height),
          (int) ((i + 1) * xstep), (int) transformY(buffer.get(i + 1), minY, rangeY, height)
        );
      }
    }",loop_control
g,"{
      minY = Double.POSITIVE_INFINITY;
      maxY = Double.NEGATIVE_INFINITY;
      for(Graph g : graphs) {
        if (!g.buffer.isEmpty()) {
          minY = Math.min(g.buffer.min(), minY);
          maxY = Math.max(g.buffer.max(), maxY);
        }
      }

      final double MIN_DELTA = 10.0;
      if (maxY - minY < MIN_DELTA) {
        double mid = (maxY + minY) / 2;
        maxY = mid + MIN_DELTA / 2;
        minY = mid - MIN_DELTA / 2;
      }

      Ticks ticks = new Ticks(minY, maxY, 5);
      minY = Math.min(minY, ticks.getTick(0));
      maxY = Math.max(maxY, ticks.getTick(ticks.getTickCount() - 1));
      rangeY = maxY - minY;
      minY -= 0.05 * rangeY;
      maxY += 0.05 * rangeY;
      rangeY = maxY - minY;
      return ticks;
    }",iterator
i,"{
      Graphics2D g = (Graphics2D) g1;
      g.setRenderingHint(RenderingHints.KEY_ANTIALIASING, RenderingHints.VALUE_ANTIALIAS_ON);
      g.setFont(font);
      super.paintComponent(g);

      bounds = g.getClipBounds();
      setBackground(bgColor);
      if (graphs.isEmpty()) {
        return;
      }

      Ticks ticks = computeBounds();

      g.setStroke(new BasicStroke(1.0f));
      FontMetrics fm = g.getFontMetrics();
      for (int i = 0; i < ticks.getTickCount(); ++i) {
        double tick = ticks.getTick(i);
        Rectangle2D fRect = fm.getStringBounds(String.valueOf(tick), g);
        xOffset = Math.max(xOffset, (int) fRect.getWidth() + 15);

        g.setColor(boundsColor);
        // draw tick
        g.drawLine(xOffset - 5, (int) transformY(tick), xOffset + 2, (int) transformY(tick));
        // draw tick label
        g.drawString(String.valueOf(tick), xOffset - (int) fRect.getWidth() - 10, transformY(tick) - (float) fRect.getHeight() * 0.5f + fm.getAscent());
        // draw horizontal grid lines
        g.setColor(gridColor);
        g.drawLine(xOffset + 3, (int) transformY(tick), bounds.width - xPadding, (int) transformY(tick));
      }

      // handle data count
      int cnt = xCount - BUFFER_CAPACITY;
      if (xCount < BUFFER_CAPACITY) cnt = 0;
        
      double zeroTick = ticks.getTick(0);
      double lastTick = ticks.getTick(ticks.getTickCount() - 1);
      double xTickRange = BUFFER_CAPACITY / ticks.getTickCount();
        
      for (int i = 0; i < ticks.getTickCount() + 1; i++) {
          String s;
          int xValue;
          int sWidth;
          Rectangle2D fBounds;
          if  (i == 0) {
              s = String.valueOf(cnt);
              fBounds = fm.getStringBounds(s, g);
              sWidth = (int)fBounds.getWidth()/2;
              xValue = xOffset;
          } else {
              s = String.valueOf((int)(xTickRange * i)+cnt);
              fBounds = fm.getStringBounds(s, g);
              sWidth = (int)fBounds.getWidth()/2;
              xValue = (int)((bounds.width - xOffset - xPadding) * ((xTickRange * i) / BUFFER_CAPACITY) + xOffset);
          }
          // draw graph x axis, ticks and labels
          g.setColor(boundsColor);
          g.drawString(s, xValue - sWidth, (int) bounds.y + (int) transformY(zeroTick) + 15);
          g.drawLine(xValue, (int)transformY(zeroTick) - 2, xValue, bounds.y + (int)transformY(zeroTick) + 5);
          // draw vertical grid lines
          g.setColor(gridColor);
          g.drawLine(xValue, (int)transformY(zeroTick) - 3, xValue, bounds.y + (int)transformY(lastTick));
      }
      g.setColor(boundsColor);
      // draw major y axis
      g.drawLine(bounds.x + xOffset, (int) transformY(lastTick) - 5, bounds.x + xOffset, bounds.y + (int) transformY(zeroTick) + 5);
      // draw major x axis
      g.drawLine(xOffset, (int) transformY(zeroTick), bounds.width - xPadding, (int)transformY(zeroTick));
        
      g.setTransform(AffineTransform.getTranslateInstance(xOffset, 0));
      float xstep = (float) (bounds.width - xOffset - xPadding) / (float) BUFFER_CAPACITY;

      // draw legend
      int legendXOffset = 0;
      for(int i = 0; i < graphs.size(); ++i) {
        graphs.get(i).paint(g, xstep, minY, maxY, rangeY, bounds.height);
        if(graphs.size() > 1) {
          //draw legend rectangle
          g.fillRect(10 + legendXOffset, 10, 10, 10);
          legendXOffset += 13;
          //draw label
          g.setColor(boundsColor);
          String s = graphs.get(i).label;
          if(s != null && s.length() > 0) {
            Rectangle2D fBounds = fm.getStringBounds(s, g);
            int sWidth = (int)fBounds.getWidth();
            g.drawString(s, 10 + legendXOffset, 10 + (int)fBounds.getHeight() /2);
            legendXOffset += sWidth + 3;
          }
        }
      }
    }",loop_control
serialRateString,"{
    mainPane.setLayout(new BorderLayout());

    GraphPanel graphPanel = new GraphPanel();

    mainPane.add(graphPanel, BorderLayout.CENTER);

    JPanel pane = new JPanel();
    pane.setLayout(new BoxLayout(pane, BoxLayout.X_AXIS));
    pane.setBorder(new EmptyBorder(4, 4, 4, 4));

    serialRates = new JComboBox<>();
    for (String serialRateString : serialRateStrings) serialRates.addItem(serialRateString + "" "" + tr(""baud""));

    serialRates.setMaximumSize(serialRates.getMinimumSize());

    pane.add(Box.createHorizontalGlue());
    pane.add(Box.createRigidArea(new Dimension(8, 0)));
    pane.add(serialRates);

    mainPane.add(pane, BorderLayout.SOUTH);

    textField = new JTextField(40);
    // textField is selected every time the window is focused
    addWindowFocusListener(new WindowAdapter() {
      @Override
      public void windowGainedFocus(WindowEvent e) {
        textField.requestFocusInWindow();
      }
    });

    // Add cut/copy/paste contextual menu to the text input field.
    JPopupMenu menu = new JPopupMenu();

    Action cut = new DefaultEditorKit.CutAction();
    cut.putValue(Action.NAME, tr(""Cut""));
    menu.add(cut);

    Action copy = new DefaultEditorKit.CopyAction();
    copy.putValue(Action.NAME, tr(""Copy""));
    menu.add(copy);

    Action paste = new DefaultEditorKit.PasteAction();
    paste.putValue(Action.NAME, tr(""Paste""));
    menu.add(paste);

    textField.setComponentPopupMenu(menu);

    sendButton = new JButton(tr(""Send""));

    JPanel lowerPane = new JPanel();
    lowerPane.setLayout(new BoxLayout(lowerPane, BoxLayout.X_AXIS));
    lowerPane.setBorder(new EmptyBorder(4, 4, 4, 4));

    noLineEndingAlert = new JLabel(I18n.format(tr(""You've pressed {0} but nothing was sent. Should you select a line ending?""), tr(""Send"")));
    noLineEndingAlert.setToolTipText(noLineEndingAlert.getText());
    noLineEndingAlert.setForeground(pane.getBackground());
    Dimension minimumSize = new Dimension(noLineEndingAlert.getMinimumSize());
    minimumSize.setSize(minimumSize.getWidth() / 3, minimumSize.getHeight());
    noLineEndingAlert.setMinimumSize(minimumSize);


    lineEndings = new JComboBox<String>(new String[]{tr(""No line ending""), tr(""Newline""), tr(""Carriage return""), tr(""Both NL & CR"")});
    lineEndings.addActionListener((ActionEvent event) -> {
      PreferencesData.setInteger(""serial.line_ending"", lineEndings.getSelectedIndex());
      noLineEndingAlert.setForeground(pane.getBackground());
    });
    lineEndings.setMaximumSize(lineEndings.getMinimumSize());

    lowerPane.add(textField);
    lowerPane.add(Box.createRigidArea(new Dimension(4, 0)));
    lowerPane.add(sendButton);

    pane.add(lowerPane);
    pane.add(noLineEndingAlert);
    pane.add(Box.createRigidArea(new Dimension(8, 0)));
    pane.add(lineEndings);

    applyPreferences();

    onSendCommand((ActionEvent event) -> {
      send(textField.getText());
      textField.setText("""");
    });
 
  }",iterator
linebreak,"{
    messageBuffer.append(s);
    while (true) {
      int linebreak = messageBuffer.indexOf(""\n"");
      if (linebreak == -1) {
        break;
      }
      xCount++;
      String line = messageBuffer.substring(0, linebreak);
      messageBuffer.delete(0, linebreak + 1);

      line = line.trim();
      if (line.length() == 0) {
        // the line only contained trimmable characters
        continue;
      }
      String[] parts = line.split(""[, \t]+"");
      if(parts.length == 0) {
        continue;
      }

      int validParts = 0;
      int validLabels = 0;
      for(int i = 0; i < parts.length; ++i) {
        Double value = null;
        String label = null;
        
        // column formated name value pair
        if(parts[i].contains("":"")) {
          // get label
          String[] subString = parts[i].split(""[:]+"");
            
          if(subString.length > 0) {
            int labelLength = subString[0].length();
              
            if(labelLength > 32) {
                labelLength = 32;
            }
            label = subString[0].substring(0, labelLength);
          } else {
            label = """";
          }
            
          if(subString.length > 1) {
            parts[i] = subString[1];
          } else {
            parts[i] = """";
          }
        }

        try {
          value = Double.valueOf(parts[i]);
        } catch (NumberFormatException e) {
          // ignored
        }
        //CSV header
        if(label == null && value == null) {
          label = parts[i];
        }
        
        if(value != null) {
          if(validParts >= graphs.size()) {
            graphs.add(new Graph(validParts));
          }
          graphs.get(validParts).buffer.add(value);
          validParts++;
        }
        if(label != null) {
          if(validLabels >= graphs.size()) {
            graphs.add(new Graph(validLabels));
          }
          graphs.get(validLabels).label = label;
          validLabels++;
        }
        if(validParts > validLabels) validLabels = validParts;
        else if(validLabels > validParts) validParts = validLabels;
      }
    }

    SwingUtilities.invokeLater(SerialPlotter.this::repaint);
  }",break_loop_control
i,"{
    messageBuffer.append(s);
    while (true) {
      int linebreak = messageBuffer.indexOf(""\n"");
      if (linebreak == -1) {
        break;
      }
      xCount++;
      String line = messageBuffer.substring(0, linebreak);
      messageBuffer.delete(0, linebreak + 1);

      line = line.trim();
      if (line.length() == 0) {
        // the line only contained trimmable characters
        continue;
      }
      String[] parts = line.split(""[, \t]+"");
      if(parts.length == 0) {
        continue;
      }

      int validParts = 0;
      int validLabels = 0;
      for(int i = 0; i < parts.length; ++i) {
        Double value = null;
        String label = null;
        
        // column formated name value pair
        if(parts[i].contains("":"")) {
          // get label
          String[] subString = parts[i].split(""[:]+"");
            
          if(subString.length > 0) {
            int labelLength = subString[0].length();
              
            if(labelLength > 32) {
                labelLength = 32;
            }
            label = subString[0].substring(0, labelLength);
          } else {
            label = """";
          }
            
          if(subString.length > 1) {
            parts[i] = subString[1];
          } else {
            parts[i] = """";
          }
        }

        try {
          value = Double.valueOf(parts[i]);
        } catch (NumberFormatException e) {
          // ignored
        }
        //CSV header
        if(label == null && value == null) {
          label = parts[i];
        }
        
        if(value != null) {
          if(validParts >= graphs.size()) {
            graphs.add(new Graph(validParts));
          }
          graphs.get(validParts).buffer.add(value);
          validParts++;
        }
        if(label != null) {
          if(validLabels >= graphs.size()) {
            graphs.add(new Graph(validLabels));
          }
          graphs.get(validLabels).label = label;
          validLabels++;
        }
        if(validParts > validLabels) validLabels = validParts;
        else if(validLabels > validParts) validParts = validLabels;
      }
    }

    SwingUtilities.invokeLater(SerialPlotter.this::repaint);
  }",loop_control
zipFile,"{
    if (!folder.isDirectory()) {
      return;
    }
    
    for (File zipFile : folder.listFiles((dir, name) -> name.endsWith("".zip""))) {
      ZippedTheme theme = ZippedTheme.load(namespace, zipFile);
      if (theme != null) {
        discoveredThemes.put(theme.getKey(), theme);
      }
    }
  }",iterator
channel,"{
    if (s.contains(""can't connect"")) {
      while (!channel.isClosed()) {
        try {
          Thread.sleep(100);
        } catch (InterruptedException e) {
          // ignore
        }
      }
      if (connectionAttempts < MAX_CONNECTION_ATTEMPTS) {
        s = ""\n"" + tr(""Unable to connect: retrying"") + "" ("" + connectionAttempts + "")... "";

        SwingUtilities.invokeLater(new Runnable() {
          @Override
          public void run() {
            try {
              NetworkMonitor.this.tryConnect();
            } catch (JSchException e) {
              e.printStackTrace();
            } catch (IOException e) {
              e.printStackTrace();
            }
          }
        });
      } else {
        s = ""\n"" + tr(""Unable to connect: is the sketch using the bridge?"");
      }
    }
    super.message(s);
  }",maybe_loop_control
end,"{

    // Update the console text pane font from the preferences.
    Font consoleFont = Theme.getFont(""console.font"");
    Font editorFont = PreferencesData.getFont(""editor.font"");
    Font actualFont = new Font(consoleFont.getName(), consoleFont.getStyle(), scale(editorFont.getSize()));

    AttributeSet stdOutStyleOld = stdOutStyle.copyAttributes();
    AttributeSet stdErrStyleOld = stdErrStyle.copyAttributes();
    StyleConstants.setFontSize(stdOutStyle, actualFont.getSize());
    StyleConstants.setFontSize(stdErrStyle, actualFont.getSize());

    // Re-insert console text with the new preferences if there were changes.
    // This assumes that the document has single-child paragraphs (default).
    if (!stdOutStyle.isEqual(stdOutStyleOld) || !stdErrStyle.isEqual(stdOutStyleOld)) {
      if (out != null)
        out.setAttibutes(stdOutStyle);
      if (err != null)
        err.setAttibutes(stdErrStyle);

      int start;
      for (int end = document.getLength() - 1; end >= 0; end = start - 1) {
        Element elem = document.getParagraphElement(end);
        start = elem.getStartOffset();
        AttributeSet attrs = elem.getElement(0).getAttributes();
        AttributeSet newAttrs;
        if (attrs.isEqual(stdErrStyleOld)) {
          newAttrs = stdErrStyle;
        } else if (attrs.isEqual(stdOutStyleOld)) {
          newAttrs = stdOutStyle;
        } else {
          continue;
        }
        try {
          String text = document.getText(start, end - start);
          document.remove(start, end - start);
          document.insertString(start, text, newAttrs);
        } catch (BadLocationException e) {
          // Should only happen when text is async removed (through clear()).
          // Accept this case, but throw an error when text could mess up.
          if (document.getLength() != 0) {
            throw new Error(e);
          }
        }
      }
    }
  }",loop_control
m,"{
    // Separate the string into content, newlines and lone carriage
    // returns.
    //
    // Doing so allows lone CRs to move the insertPosition back to the
    // start of the line to allow overwriting the most recent line (e.g.
    // for a progress bar). Any CR or NL that are immediately followed
    // by another NL are bunched together for efficiency, since these
    // can just be inserted into the document directly and still be
    // correct.
    //
    // The regex is written so it will necessarily match any string
    // completely if applied repeatedly. This is important because any
    // part not matched would be silently dropped.
    Matcher m = newLinePattern.matcher(str);

    while (m.find()) {
      String content = m.group(1);
      String newlines = m.group(2);
      String crs = m.group(3);

      // Replace (or append if at end of the document) the content first
      int replaceLength = Math.min(content.length(), document.getLength() - insertPosition);
      document.replace(insertPosition, replaceLength, content, attributes);
      insertPosition += content.length();

      // Then insert any newlines, but always at the end of the document
      // e.g. if insertPosition is halfway a line, do not delete
      // anything, just add the newline(s) at the end).
      if (newlines != null) {
        document.insertString(document.getLength(), newlines, attributes);
        insertPosition = document.getLength();
        startOfLine = insertPosition;
      }

      // Then, for any CRs not followed by newlines, move insertPosition
      // to the start of the line. Note that if a newline follows before
      // any content in the next call to insertString, it will be added
      // at the end of the document anyway, as expected.
      if (crs != null) {
        insertPosition = startOfLine;
      }
    }
  }",maybe_loop_control
menuItem,"{
    super(""Arduino"");
    this.base = ibase;
    this.platform = platform;

    Base.setIcon(this);

    // Install default actions for Run, Present, etc.
    resetHandlers();

    // add listener to handle window close box hit event
    addWindowListener(new WindowAdapter() {
        public void windowClosing(WindowEvent e) {
          base.handleClose(Editor.this);
        }
      });
    // don't close the window when clicked, the app will take care
    // of that via the handleQuitInternal() methods
    // http://dev.processing.org/bugs/show_bug.cgi?id=440
    setDefaultCloseOperation(JFrame.DO_NOTHING_ON_CLOSE);

    // When bringing a window to front, let the Base know
    addWindowListener(new WindowAdapter() {
        public void windowActivated(WindowEvent e) {
          base.handleActivated(Editor.this);
        }

        // added for 1.0.5
        // http://dev.processing.org/bugs/show_bug.cgi?id=1260
        public void windowDeactivated(WindowEvent e) {
          List<Component> toolsMenuItemsToRemove = new LinkedList<>();
          for (Component menuItem : toolsMenu.getMenuComponents()) {
            if (menuItem instanceof JComponent) {
              Object removeOnWindowDeactivation = ((JComponent) menuItem).getClientProperty(""removeOnWindowDeactivation"");
              if (removeOnWindowDeactivation != null && Boolean.valueOf(removeOnWindowDeactivation.toString())) {
                toolsMenuItemsToRemove.add(menuItem);
              }
            }
          }
          for (Component menuItem : toolsMenuItemsToRemove) {
            toolsMenu.remove(menuItem);
          }
          toolsMenu.remove(portMenu);
        }
      });

    //PdeKeywords keywords = new PdeKeywords();
    //sketchbook = new Sketchbook(this);

    buildMenuBar();

    // For rev 0120, placing things inside a JPanel
    Container contentPain = getContentPane();
    contentPain.setLayout(new BorderLayout());
    JPanel pane = new JPanel();
    pane.setLayout(new BorderLayout());
    contentPain.add(pane, BorderLayout.CENTER);

    Box box = Box.createVerticalBox();
    upper = Box.createVerticalBox();

    if (toolbarMenu == null) {
      toolbarMenu = new JMenu();
      base.rebuildToolbarMenu(toolbarMenu);
    }
    toolbar = new EditorToolbar(this, toolbarMenu);
    upper.add(toolbar);

    header = new EditorHeader(this);
    upper.add(header);

    // assemble console panel, consisting of status area and the console itself
    JPanel consolePanel = new JPanel();
    consolePanel.setLayout(new BorderLayout());

    status = new EditorStatus(this);
    consolePanel.add(status, BorderLayout.NORTH);

    console = new EditorConsole(base);
    console.setName(""console"");
    // windows puts an ugly border on this guy
    console.setBorder(null);
    consolePanel.add(console, BorderLayout.CENTER);

    lineStatus = new EditorLineStatus();
    consolePanel.add(lineStatus, BorderLayout.SOUTH);

    codePanel = new JPanel(new BorderLayout());
    upper.add(codePanel);

    splitPane = new JSplitPane(JSplitPane.VERTICAL_SPLIT, upper, consolePanel);

    // repaint child panes while resizing
    splitPane.setContinuousLayout(true);
    // if window increases in size, give all of increase to
    // the textarea in the uppper pane
    splitPane.setResizeWeight(1D);

    // to fix ugliness.. normally macosx java 1.3 puts an
    // ugly white border around this object, so turn it off.
    splitPane.setBorder(null);
    // By default, the split pane binds Ctrl-Tab and Ctrl-Shift-Tab for changing
    // focus. Since we do not use that, but want to use these shortcuts for
    // switching tabs, remove the bindings from the split pane. This allows the
    // events to bubble up and be handled by the EditorHeader.
    Keys.killBinding(splitPane, Keys.ctrl(KeyEvent.VK_TAB));
    Keys.killBinding(splitPane, Keys.ctrlShift(KeyEvent.VK_TAB));

    splitPane.setDividerSize(scale(splitPane.getDividerSize()));

    // the following changed from 600, 400 for netbooks
    // http://code.google.com/p/arduino/issues/detail?id=52
    splitPane.setMinimumSize(scale(new Dimension(600, 100)));
    box.add(splitPane);

    // hopefully these are no longer needed w/ swing
    // (har har har.. that was wishful thinking)
    // listener = new EditorListener(this, textarea);
    pane.add(box);

    pane.setTransferHandler(new FileDropHandler());

    // Set the minimum size for the editor window
    setMinimumSize(scale(new Dimension(
        PreferencesData.getInteger(""editor.window.width.min""),
        PreferencesData.getInteger(""editor.window.height.min""))));

    // Bring back the general options for the editor
    applyPreferences();

    // Finish preparing Editor (formerly found in Base)
    pack();

    // Set the window bounds and the divider location before setting it visible
    setPlacement(storedLocation, defaultLocation);

    // Open the document that was passed in
    boolean loaded = handleOpenInternal(file);
    if (!loaded) sketchController = null;

    // default the console output to the last opened editor
    EditorConsole.setCurrentEditorConsole(console);
  }",iterator
file,"{
      int successful = 0;

      try {
        DataFlavor uriListFlavor =
          new DataFlavor(""text/uri-list;class=java.lang.String"");

        if (transferable.isDataFlavorSupported(DataFlavor.javaFileListFlavor)) {
          List<File> list = (List<File>)
            transferable.getTransferData(DataFlavor.javaFileListFlavor);
          for (File file : list) {
            if (sketchController.addFile(file)) {
              successful++;
            }
          }
        } else if (transferable.isDataFlavorSupported(uriListFlavor)) {
          // Some platforms (Mac OS X and Linux, when this began) preferred
          // this method of moving files.
          String data = (String)transferable.getTransferData(uriListFlavor);
          String[] pieces = PApplet.splitTokens(data, ""\r\n"");
          for (String piece : pieces) {
            if (piece.startsWith(""#"")) continue;

            String path = null;
            if (piece.startsWith(""file:///"")) {
              path = piece.substring(7);
            } else if (piece.startsWith(""file:/"")) {
              path = piece.substring(5);
            }
            if (sketchController.addFile(new File(path))) {
              successful++;
            }
          }
        }
      } catch (Exception e) {
        e.printStackTrace();
        return false;
      }

      if (successful == 0) {
        statusError(tr(""No files were added to the sketch.""));

      } else if (successful == 1) {
        statusNotice(tr(""One file added to the sketch.""));

      } else {
        statusNotice(I18n.format(tr(""{0} files added to the sketch.""), successful));
      }
      return true;
    }",iterator
piece,"{
      int successful = 0;

      try {
        DataFlavor uriListFlavor =
          new DataFlavor(""text/uri-list;class=java.lang.String"");

        if (transferable.isDataFlavorSupported(DataFlavor.javaFileListFlavor)) {
          List<File> list = (List<File>)
            transferable.getTransferData(DataFlavor.javaFileListFlavor);
          for (File file : list) {
            if (sketchController.addFile(file)) {
              successful++;
            }
          }
        } else if (transferable.isDataFlavorSupported(uriListFlavor)) {
          // Some platforms (Mac OS X and Linux, when this began) preferred
          // this method of moving files.
          String data = (String)transferable.getTransferData(uriListFlavor);
          String[] pieces = PApplet.splitTokens(data, ""\r\n"");
          for (String piece : pieces) {
            if (piece.startsWith(""#"")) continue;

            String path = null;
            if (piece.startsWith(""file:///"")) {
              path = piece.substring(7);
            } else if (piece.startsWith(""file:/"")) {
              path = piece.substring(5);
            }
            if (sketchController.addFile(new File(path))) {
              successful++;
            }
          }
        }
      } catch (Exception e) {
        e.printStackTrace();
        return false;
      }

      if (successful == 0) {
        statusError(tr(""No files were added to the sketch.""));

      } else if (successful == 1) {
        statusNotice(tr(""One file added to the sketch.""));

      } else {
        statusNotice(I18n.format(tr(""{0} files added to the sketch.""), successful));
      }
      return true;
    }",iterator
tab,"{
    boolean external = PreferencesData.getBoolean(""editor.external"");
    saveMenuItem.setEnabled(!external);
    saveAsMenuItem.setEnabled(!external);
    for (EditorTab tab: tabs) {
      tab.applyPreferences();
    }
    console.applyPreferences();
    if (serialMonitor != null) {
      serialMonitor.applyPreferences();
    }
  }",iterator
menu,"{
    JMenuBar menubar = new JMenuBar();
    final JMenu fileMenu = buildFileMenu();
    fileMenu.addMenuListener(new StubMenuListener() {
      @Override
      public void menuSelected(MenuEvent e) {
        List<Component> components = Arrays.asList(fileMenu.getMenuComponents());
        if (!components.contains(sketchbookMenu)) {
          fileMenu.insert(sketchbookMenu, 3);
        }
        if (!components.contains(examplesMenu)) {
          fileMenu.insert(examplesMenu, 4);
        }
        fileMenu.revalidate();
        validate();
      }
    });
    menubar.add(fileMenu);

    menubar.add(buildEditMenu());

    final JMenu sketchMenu = new JMenu(tr(""Sketch""));
    sketchMenu.setMnemonic(KeyEvent.VK_S);
    sketchMenu.addMenuListener(new StubMenuListener() {

      @Override
      public void menuSelected(MenuEvent e) {
        buildSketchMenu(sketchMenu);
        sketchMenu.revalidate();
        validate();
      }
    });
    buildSketchMenu(sketchMenu);
    menubar.add(sketchMenu);

    final JMenu toolsMenu = buildToolsMenu();
    toolsMenu.addMenuListener(new StubMenuListener() {
      @Override
      public void menuSelected(MenuEvent e) {
        List<Component> components = Arrays.asList(toolsMenu.getMenuComponents());
        int offset = 0;
        for (JMenu menu : base.getBoardsCustomMenus()) {
          if (!components.contains(menu)) {
            toolsMenu.insert(menu, numTools + offset);
            offset++;
          }
        }
        if (!components.contains(portMenu)) {
          toolsMenu.insert(portMenu, numTools + offset);
        }
        programmersMenu.removeAll();
        base.getProgrammerMenus().forEach(programmersMenu::add);
        toolsMenu.revalidate();
        validate();
      }
    });
    menubar.add(toolsMenu);

    menubar.add(buildHelpMenu());
    setJMenuBar(menubar);
  }",iterator
recentSketchMenuItem,"{
    recentSketchesMenu.removeAll();
    for (JMenuItem recentSketchMenuItem  : base.getRecentSketchesMenuItems()) {
      recentSketchesMenu.add(recentSketchMenuItem);
    }
  }",iterator
i,"{
    toolsMenu = new JMenu(tr(""Tools""));
    toolsMenu.setMnemonic(KeyEvent.VK_T);

    addInternalTools(toolsMenu);

    JMenuItem item = newJMenuItemShift(tr(""Manage Libraries...""), 'I');
    item.addActionListener(e -> base.openLibraryManager("""", """"));
    toolsMenu.add(item);

    item = newJMenuItemShift(tr(""Serial Monitor""), 'M');
    item.addActionListener(e -> handleSerial());
    toolsMenu.add(item);

    item = newJMenuItemShift(tr(""Serial Plotter""), 'L');
    item.addActionListener(e -> handlePlotter());
    toolsMenu.add(item);

    addTools(toolsMenu, BaseNoGui.getToolsFolder());
    File sketchbookTools = new File(BaseNoGui.getSketchbookFolder(), ""tools"");
    addTools(toolsMenu, sketchbookTools);

    toolsMenu.addSeparator();

    numTools = toolsMenu.getItemCount();

    // XXX: DAM: these should probably be implemented using the Tools plugin
    // API, if possible (i.e. if it supports custom actions, etc.)

    base.getBoardsCustomMenus().stream().forEach(toolsMenu::add);

    if (portMenu == null)
      portMenu = new JMenu(tr(""Port""));
    populatePortMenu();
    toolsMenu.add(portMenu);
    MenuScroller.setScrollerFor(portMenu);
    item = new JMenuItem(tr(""Get Board Info""));
    item.addActionListener(e -> handleBoardInfo());
    toolsMenu.add(item);
    toolsMenu.addSeparator();

    base.rebuildProgrammerMenu();
    programmersMenu = new JMenu(tr(""Programmer""));
    MenuScroller.setScrollerFor(programmersMenu);
    base.getProgrammerMenus().stream().forEach(programmersMenu::add);
    toolsMenu.add(programmersMenu);

    item = new JMenuItem(tr(""Burn Bootloader""));
    item.addActionListener(e -> handleBurnBootloader());
    toolsMenu.add(item);

    toolsMenu.addMenuListener(new StubMenuListener() {
      public JMenuItem getSelectedItemRecursive(JMenu menu) {
        int count = menu.getItemCount();
        for (int i=0; i < count; i++) {
          JMenuItem item = menu.getItem(i);

          if ((item instanceof JMenu))
            item = getSelectedItemRecursive((JMenu)item);

          if (item != null && item.isSelected())
            return item;
        }
        return null;
      }

      public void menuSelected(MenuEvent e) {
        //System.out.println(""Tools menu selected."");
        populatePortMenu();
        for (Component c : toolsMenu.getMenuComponents()) {
          if ((c instanceof JMenu) && c.isVisible()) {
            JMenu menu = (JMenu)c;
            String name = menu.getText();
            if (name == null) continue;
            String basename = name;
            int index = name.indexOf(':');
            if (index > 0) basename = name.substring(0, index);

            JMenuItem item = getSelectedItemRecursive(menu);
            String sel = item != null ? item.getText() : null;
            if (sel == null) {
              if (!name.equals(basename)) menu.setText(basename);
            } else {
              if (sel.length() > 50) sel = sel.substring(0, 50) + ""..."";
              String newname = basename + "": \"""" + sel + ""\"""";
              if (!name.equals(newname)) menu.setText(newname);
            }
          }
        }
      }
    });

    return toolsMenu;
  }",loop_control
item,"{
    toolsMenu = new JMenu(tr(""Tools""));
    toolsMenu.setMnemonic(KeyEvent.VK_T);

    addInternalTools(toolsMenu);

    JMenuItem item = newJMenuItemShift(tr(""Manage Libraries...""), 'I');
    item.addActionListener(e -> base.openLibraryManager("""", """"));
    toolsMenu.add(item);

    item = newJMenuItemShift(tr(""Serial Monitor""), 'M');
    item.addActionListener(e -> handleSerial());
    toolsMenu.add(item);

    item = newJMenuItemShift(tr(""Serial Plotter""), 'L');
    item.addActionListener(e -> handlePlotter());
    toolsMenu.add(item);

    addTools(toolsMenu, BaseNoGui.getToolsFolder());
    File sketchbookTools = new File(BaseNoGui.getSketchbookFolder(), ""tools"");
    addTools(toolsMenu, sketchbookTools);

    toolsMenu.addSeparator();

    numTools = toolsMenu.getItemCount();

    // XXX: DAM: these should probably be implemented using the Tools plugin
    // API, if possible (i.e. if it supports custom actions, etc.)

    base.getBoardsCustomMenus().stream().forEach(toolsMenu::add);

    if (portMenu == null)
      portMenu = new JMenu(tr(""Port""));
    populatePortMenu();
    toolsMenu.add(portMenu);
    MenuScroller.setScrollerFor(portMenu);
    item = new JMenuItem(tr(""Get Board Info""));
    item.addActionListener(e -> handleBoardInfo());
    toolsMenu.add(item);
    toolsMenu.addSeparator();

    base.rebuildProgrammerMenu();
    programmersMenu = new JMenu(tr(""Programmer""));
    MenuScroller.setScrollerFor(programmersMenu);
    base.getProgrammerMenus().stream().forEach(programmersMenu::add);
    toolsMenu.add(programmersMenu);

    item = new JMenuItem(tr(""Burn Bootloader""));
    item.addActionListener(e -> handleBurnBootloader());
    toolsMenu.add(item);

    toolsMenu.addMenuListener(new StubMenuListener() {
      public JMenuItem getSelectedItemRecursive(JMenu menu) {
        int count = menu.getItemCount();
        for (int i=0; i < count; i++) {
          JMenuItem item = menu.getItem(i);

          if ((item instanceof JMenu))
            item = getSelectedItemRecursive((JMenu)item);

          if (item != null && item.isSelected())
            return item;
        }
        return null;
      }

      public void menuSelected(MenuEvent e) {
        //System.out.println(""Tools menu selected."");
        populatePortMenu();
        for (Component c : toolsMenu.getMenuComponents()) {
          if ((c instanceof JMenu) && c.isVisible()) {
            JMenu menu = (JMenu)c;
            String name = menu.getText();
            if (name == null) continue;
            String basename = name;
            int index = name.indexOf(':');
            if (index > 0) basename = name.substring(0, index);

            JMenuItem item = getSelectedItemRecursive(menu);
            String sel = item != null ? item.getText() : null;
            if (sel == null) {
              if (!name.equals(basename)) menu.setText(basename);
            } else {
              if (sel.length() > 50) sel = sel.substring(0, 50) + ""..."";
              String newname = basename + "": \"""" + sel + ""\"""";
              if (!name.equals(newname)) menu.setText(newname);
            }
          }
        }
      }
    });

    return toolsMenu;
  }",break_loop_control
c,"{
    toolsMenu = new JMenu(tr(""Tools""));
    toolsMenu.setMnemonic(KeyEvent.VK_T);

    addInternalTools(toolsMenu);

    JMenuItem item = newJMenuItemShift(tr(""Manage Libraries...""), 'I');
    item.addActionListener(e -> base.openLibraryManager("""", """"));
    toolsMenu.add(item);

    item = newJMenuItemShift(tr(""Serial Monitor""), 'M');
    item.addActionListener(e -> handleSerial());
    toolsMenu.add(item);

    item = newJMenuItemShift(tr(""Serial Plotter""), 'L');
    item.addActionListener(e -> handlePlotter());
    toolsMenu.add(item);

    addTools(toolsMenu, BaseNoGui.getToolsFolder());
    File sketchbookTools = new File(BaseNoGui.getSketchbookFolder(), ""tools"");
    addTools(toolsMenu, sketchbookTools);

    toolsMenu.addSeparator();

    numTools = toolsMenu.getItemCount();

    // XXX: DAM: these should probably be implemented using the Tools plugin
    // API, if possible (i.e. if it supports custom actions, etc.)

    base.getBoardsCustomMenus().stream().forEach(toolsMenu::add);

    if (portMenu == null)
      portMenu = new JMenu(tr(""Port""));
    populatePortMenu();
    toolsMenu.add(portMenu);
    MenuScroller.setScrollerFor(portMenu);
    item = new JMenuItem(tr(""Get Board Info""));
    item.addActionListener(e -> handleBoardInfo());
    toolsMenu.add(item);
    toolsMenu.addSeparator();

    base.rebuildProgrammerMenu();
    programmersMenu = new JMenu(tr(""Programmer""));
    MenuScroller.setScrollerFor(programmersMenu);
    base.getProgrammerMenus().stream().forEach(programmersMenu::add);
    toolsMenu.add(programmersMenu);

    item = new JMenuItem(tr(""Burn Bootloader""));
    item.addActionListener(e -> handleBurnBootloader());
    toolsMenu.add(item);

    toolsMenu.addMenuListener(new StubMenuListener() {
      public JMenuItem getSelectedItemRecursive(JMenu menu) {
        int count = menu.getItemCount();
        for (int i=0; i < count; i++) {
          JMenuItem item = menu.getItem(i);

          if ((item instanceof JMenu))
            item = getSelectedItemRecursive((JMenu)item);

          if (item != null && item.isSelected())
            return item;
        }
        return null;
      }

      public void menuSelected(MenuEvent e) {
        //System.out.println(""Tools menu selected."");
        populatePortMenu();
        for (Component c : toolsMenu.getMenuComponents()) {
          if ((c instanceof JMenu) && c.isVisible()) {
            JMenu menu = (JMenu)c;
            String name = menu.getText();
            if (name == null) continue;
            String basename = name;
            int index = name.indexOf(':');
            if (index > 0) basename = name.substring(0, index);

            JMenuItem item = getSelectedItemRecursive(menu);
            String sel = item != null ? item.getText() : null;
            if (sel == null) {
              if (!name.equals(basename)) menu.setText(basename);
            } else {
              if (sel.length() > 50) sel = sel.substring(0, 50) + ""..."";
              String newname = basename + "": \"""" + sel + ""\"""";
              if (!name.equals(newname)) menu.setText(newname);
            }
          }
        }
      }
    });

    return toolsMenu;
  }",iterator
folder,"{
    if (sourceFolder == null)
      return;

    Map<String, JMenuItem> toolItems = new HashMap<>();

    File[] folders = sourceFolder.listFiles(new FileFilter() {
      public boolean accept(File folder) {
        if (folder.isDirectory()) {
          //System.out.println(""checking "" + folder);
          File subfolder = new File(folder, ""tool"");
          return subfolder.exists();
        }
        return false;
      }
    });

    if (folders == null || folders.length == 0) {
      return;
    }

    for (File folder : folders) {
      File toolDirectory = new File(folder, ""tool"");

      try {
        // add dir to classpath for .classes
        //urlList.add(toolDirectory.toURL());

        // add .jar files to classpath
        File[] archives = toolDirectory.listFiles(new FilenameFilter() {
          public boolean accept(File dir, String name) {
            return (name.toLowerCase().endsWith("".jar"") ||
              name.toLowerCase().endsWith("".zip""));
          }
        });

        URL[] urlList = new URL[archives.length];
        for (int j = 0; j < urlList.length; j++) {
          urlList[j] = archives[j].toURI().toURL();
        }
        URLClassLoader loader = new URLClassLoader(urlList);

        String className = null;
        for (File archive : archives) {
          className = findClassInZipFile(folder.getName(), archive);
          if (className != null) break;
        }

        /*
        // Alternatively, could use manifest files with special attributes:
        // http://java.sun.com/j2se/1.3/docs/guide/jar/jar.html
        // Example code for loading from a manifest file:
        // http://forums.sun.com/thread.jspa?messageID=3791501
        File infoFile = new File(toolDirectory, ""tool.txt"");
        if (!infoFile.exists()) continue;

        String[] info = PApplet.loadStrings(infoFile);
        //Main-Class: org.poo.shoe.AwesomerTool
        //String className = folders[i].getName();
        String className = null;
        for (int k = 0; k < info.length; k++) {
          if (info[k].startsWith("";"")) continue;

          String[] pieces = PApplet.splitTokens(info[k], "": "");
          if (pieces.length == 2) {
            if (pieces[0].equals(""Main-Class"")) {
              className = pieces[1];
            }
          }
        }
        */
        // If no class name found, just move on.
        if (className == null) continue;

        Class<?> toolClass = Class.forName(className, true, loader);
        final Tool tool = (Tool) toolClass.newInstance();

        tool.init(Editor.this);

        String title = tool.getMenuTitle();
        JMenuItem item = new JMenuItem(title);
        item.addActionListener(event -> {
          SwingUtilities.invokeLater(tool);
          //new Thread(tool).start();
        });
        //menu.add(item);
        toolItems.put(title, item);

      } catch (Exception e) {
        e.printStackTrace();
      }
    }
    ArrayList<String> toolList = new ArrayList<>(toolItems.keySet());
    if (toolList.size() == 0) return;

    menu.addSeparator();
    Collections.sort(toolList);
    for (String title : toolList) {
      menu.add(toolItems.get(title));
    }
  }",iterator
j,"{
    if (sourceFolder == null)
      return;

    Map<String, JMenuItem> toolItems = new HashMap<>();

    File[] folders = sourceFolder.listFiles(new FileFilter() {
      public boolean accept(File folder) {
        if (folder.isDirectory()) {
          //System.out.println(""checking "" + folder);
          File subfolder = new File(folder, ""tool"");
          return subfolder.exists();
        }
        return false;
      }
    });

    if (folders == null || folders.length == 0) {
      return;
    }

    for (File folder : folders) {
      File toolDirectory = new File(folder, ""tool"");

      try {
        // add dir to classpath for .classes
        //urlList.add(toolDirectory.toURL());

        // add .jar files to classpath
        File[] archives = toolDirectory.listFiles(new FilenameFilter() {
          public boolean accept(File dir, String name) {
            return (name.toLowerCase().endsWith("".jar"") ||
              name.toLowerCase().endsWith("".zip""));
          }
        });

        URL[] urlList = new URL[archives.length];
        for (int j = 0; j < urlList.length; j++) {
          urlList[j] = archives[j].toURI().toURL();
        }
        URLClassLoader loader = new URLClassLoader(urlList);

        String className = null;
        for (File archive : archives) {
          className = findClassInZipFile(folder.getName(), archive);
          if (className != null) break;
        }

        /*
        // Alternatively, could use manifest files with special attributes:
        // http://java.sun.com/j2se/1.3/docs/guide/jar/jar.html
        // Example code for loading from a manifest file:
        // http://forums.sun.com/thread.jspa?messageID=3791501
        File infoFile = new File(toolDirectory, ""tool.txt"");
        if (!infoFile.exists()) continue;

        String[] info = PApplet.loadStrings(infoFile);
        //Main-Class: org.poo.shoe.AwesomerTool
        //String className = folders[i].getName();
        String className = null;
        for (int k = 0; k < info.length; k++) {
          if (info[k].startsWith("";"")) continue;

          String[] pieces = PApplet.splitTokens(info[k], "": "");
          if (pieces.length == 2) {
            if (pieces[0].equals(""Main-Class"")) {
              className = pieces[1];
            }
          }
        }
        */
        // If no class name found, just move on.
        if (className == null) continue;

        Class<?> toolClass = Class.forName(className, true, loader);
        final Tool tool = (Tool) toolClass.newInstance();

        tool.init(Editor.this);

        String title = tool.getMenuTitle();
        JMenuItem item = new JMenuItem(title);
        item.addActionListener(event -> {
          SwingUtilities.invokeLater(tool);
          //new Thread(tool).start();
        });
        //menu.add(item);
        toolItems.put(title, item);

      } catch (Exception e) {
        e.printStackTrace();
      }
    }
    ArrayList<String> toolList = new ArrayList<>(toolItems.keySet());
    if (toolList.size() == 0) return;

    menu.addSeparator();
    Collections.sort(toolList);
    for (String title : toolList) {
      menu.add(toolItems.get(title));
    }
  }",loop_control
archive,"{
    if (sourceFolder == null)
      return;

    Map<String, JMenuItem> toolItems = new HashMap<>();

    File[] folders = sourceFolder.listFiles(new FileFilter() {
      public boolean accept(File folder) {
        if (folder.isDirectory()) {
          //System.out.println(""checking "" + folder);
          File subfolder = new File(folder, ""tool"");
          return subfolder.exists();
        }
        return false;
      }
    });

    if (folders == null || folders.length == 0) {
      return;
    }

    for (File folder : folders) {
      File toolDirectory = new File(folder, ""tool"");

      try {
        // add dir to classpath for .classes
        //urlList.add(toolDirectory.toURL());

        // add .jar files to classpath
        File[] archives = toolDirectory.listFiles(new FilenameFilter() {
          public boolean accept(File dir, String name) {
            return (name.toLowerCase().endsWith("".jar"") ||
              name.toLowerCase().endsWith("".zip""));
          }
        });

        URL[] urlList = new URL[archives.length];
        for (int j = 0; j < urlList.length; j++) {
          urlList[j] = archives[j].toURI().toURL();
        }
        URLClassLoader loader = new URLClassLoader(urlList);

        String className = null;
        for (File archive : archives) {
          className = findClassInZipFile(folder.getName(), archive);
          if (className != null) break;
        }

        /*
        // Alternatively, could use manifest files with special attributes:
        // http://java.sun.com/j2se/1.3/docs/guide/jar/jar.html
        // Example code for loading from a manifest file:
        // http://forums.sun.com/thread.jspa?messageID=3791501
        File infoFile = new File(toolDirectory, ""tool.txt"");
        if (!infoFile.exists()) continue;

        String[] info = PApplet.loadStrings(infoFile);
        //Main-Class: org.poo.shoe.AwesomerTool
        //String className = folders[i].getName();
        String className = null;
        for (int k = 0; k < info.length; k++) {
          if (info[k].startsWith("";"")) continue;

          String[] pieces = PApplet.splitTokens(info[k], "": "");
          if (pieces.length == 2) {
            if (pieces[0].equals(""Main-Class"")) {
              className = pieces[1];
            }
          }
        }
        */
        // If no class name found, just move on.
        if (className == null) continue;

        Class<?> toolClass = Class.forName(className, true, loader);
        final Tool tool = (Tool) toolClass.newInstance();

        tool.init(Editor.this);

        String title = tool.getMenuTitle();
        JMenuItem item = new JMenuItem(title);
        item.addActionListener(event -> {
          SwingUtilities.invokeLater(tool);
          //new Thread(tool).start();
        });
        //menu.add(item);
        toolItems.put(title, item);

      } catch (Exception e) {
        e.printStackTrace();
      }
    }
    ArrayList<String> toolList = new ArrayList<>(toolItems.keySet());
    if (toolList.size() == 0) return;

    menu.addSeparator();
    Collections.sort(toolList);
    for (String title : toolList) {
      menu.add(toolItems.get(title));
    }
  }",iterator
className,"{
    if (sourceFolder == null)
      return;

    Map<String, JMenuItem> toolItems = new HashMap<>();

    File[] folders = sourceFolder.listFiles(new FileFilter() {
      public boolean accept(File folder) {
        if (folder.isDirectory()) {
          //System.out.println(""checking "" + folder);
          File subfolder = new File(folder, ""tool"");
          return subfolder.exists();
        }
        return false;
      }
    });

    if (folders == null || folders.length == 0) {
      return;
    }

    for (File folder : folders) {
      File toolDirectory = new File(folder, ""tool"");

      try {
        // add dir to classpath for .classes
        //urlList.add(toolDirectory.toURL());

        // add .jar files to classpath
        File[] archives = toolDirectory.listFiles(new FilenameFilter() {
          public boolean accept(File dir, String name) {
            return (name.toLowerCase().endsWith("".jar"") ||
              name.toLowerCase().endsWith("".zip""));
          }
        });

        URL[] urlList = new URL[archives.length];
        for (int j = 0; j < urlList.length; j++) {
          urlList[j] = archives[j].toURI().toURL();
        }
        URLClassLoader loader = new URLClassLoader(urlList);

        String className = null;
        for (File archive : archives) {
          className = findClassInZipFile(folder.getName(), archive);
          if (className != null) break;
        }

        /*
        // Alternatively, could use manifest files with special attributes:
        // http://java.sun.com/j2se/1.3/docs/guide/jar/jar.html
        // Example code for loading from a manifest file:
        // http://forums.sun.com/thread.jspa?messageID=3791501
        File infoFile = new File(toolDirectory, ""tool.txt"");
        if (!infoFile.exists()) continue;

        String[] info = PApplet.loadStrings(infoFile);
        //Main-Class: org.poo.shoe.AwesomerTool
        //String className = folders[i].getName();
        String className = null;
        for (int k = 0; k < info.length; k++) {
          if (info[k].startsWith("";"")) continue;

          String[] pieces = PApplet.splitTokens(info[k], "": "");
          if (pieces.length == 2) {
            if (pieces[0].equals(""Main-Class"")) {
              className = pieces[1];
            }
          }
        }
        */
        // If no class name found, just move on.
        if (className == null) continue;

        Class<?> toolClass = Class.forName(className, true, loader);
        final Tool tool = (Tool) toolClass.newInstance();

        tool.init(Editor.this);

        String title = tool.getMenuTitle();
        JMenuItem item = new JMenuItem(title);
        item.addActionListener(event -> {
          SwingUtilities.invokeLater(tool);
          //new Thread(tool).start();
        });
        //menu.add(item);
        toolItems.put(title, item);

      } catch (Exception e) {
        e.printStackTrace();
      }
    }
    ArrayList<String> toolList = new ArrayList<>(toolItems.keySet());
    if (toolList.size() == 0) return;

    menu.addSeparator();
    Collections.sort(toolList);
    for (String title : toolList) {
      menu.add(toolItems.get(title));
    }
  }",break_loop_control
k,"{
    if (sourceFolder == null)
      return;

    Map<String, JMenuItem> toolItems = new HashMap<>();

    File[] folders = sourceFolder.listFiles(new FileFilter() {
      public boolean accept(File folder) {
        if (folder.isDirectory()) {
          //System.out.println(""checking "" + folder);
          File subfolder = new File(folder, ""tool"");
          return subfolder.exists();
        }
        return false;
      }
    });

    if (folders == null || folders.length == 0) {
      return;
    }

    for (File folder : folders) {
      File toolDirectory = new File(folder, ""tool"");

      try {
        // add dir to classpath for .classes
        //urlList.add(toolDirectory.toURL());

        // add .jar files to classpath
        File[] archives = toolDirectory.listFiles(new FilenameFilter() {
          public boolean accept(File dir, String name) {
            return (name.toLowerCase().endsWith("".jar"") ||
              name.toLowerCase().endsWith("".zip""));
          }
        });

        URL[] urlList = new URL[archives.length];
        for (int j = 0; j < urlList.length; j++) {
          urlList[j] = archives[j].toURI().toURL();
        }
        URLClassLoader loader = new URLClassLoader(urlList);

        String className = null;
        for (File archive : archives) {
          className = findClassInZipFile(folder.getName(), archive);
          if (className != null) break;
        }

        /*
        // Alternatively, could use manifest files with special attributes:
        // http://java.sun.com/j2se/1.3/docs/guide/jar/jar.html
        // Example code for loading from a manifest file:
        // http://forums.sun.com/thread.jspa?messageID=3791501
        File infoFile = new File(toolDirectory, ""tool.txt"");
        if (!infoFile.exists()) continue;

        String[] info = PApplet.loadStrings(infoFile);
        //Main-Class: org.poo.shoe.AwesomerTool
        //String className = folders[i].getName();
        String className = null;
        for (int k = 0; k < info.length; k++) {
          if (info[k].startsWith("";"")) continue;

          String[] pieces = PApplet.splitTokens(info[k], "": "");
          if (pieces.length == 2) {
            if (pieces[0].equals(""Main-Class"")) {
              className = pieces[1];
            }
          }
        }
        */
        // If no class name found, just move on.
        if (className == null) continue;

        Class<?> toolClass = Class.forName(className, true, loader);
        final Tool tool = (Tool) toolClass.newInstance();

        tool.init(Editor.this);

        String title = tool.getMenuTitle();
        JMenuItem item = new JMenuItem(title);
        item.addActionListener(event -> {
          SwingUtilities.invokeLater(tool);
          //new Thread(tool).start();
        });
        //menu.add(item);
        toolItems.put(title, item);

      } catch (Exception e) {
        e.printStackTrace();
      }
    }
    ArrayList<String> toolList = new ArrayList<>(toolItems.keySet());
    if (toolList.size() == 0) return;

    menu.addSeparator();
    Collections.sort(toolList);
    for (String title : toolList) {
      menu.add(toolItems.get(title));
    }
  }",loop_control
title,"{
    if (sourceFolder == null)
      return;

    Map<String, JMenuItem> toolItems = new HashMap<>();

    File[] folders = sourceFolder.listFiles(new FileFilter() {
      public boolean accept(File folder) {
        if (folder.isDirectory()) {
          //System.out.println(""checking "" + folder);
          File subfolder = new File(folder, ""tool"");
          return subfolder.exists();
        }
        return false;
      }
    });

    if (folders == null || folders.length == 0) {
      return;
    }

    for (File folder : folders) {
      File toolDirectory = new File(folder, ""tool"");

      try {
        // add dir to classpath for .classes
        //urlList.add(toolDirectory.toURL());

        // add .jar files to classpath
        File[] archives = toolDirectory.listFiles(new FilenameFilter() {
          public boolean accept(File dir, String name) {
            return (name.toLowerCase().endsWith("".jar"") ||
              name.toLowerCase().endsWith("".zip""));
          }
        });

        URL[] urlList = new URL[archives.length];
        for (int j = 0; j < urlList.length; j++) {
          urlList[j] = archives[j].toURI().toURL();
        }
        URLClassLoader loader = new URLClassLoader(urlList);

        String className = null;
        for (File archive : archives) {
          className = findClassInZipFile(folder.getName(), archive);
          if (className != null) break;
        }

        /*
        // Alternatively, could use manifest files with special attributes:
        // http://java.sun.com/j2se/1.3/docs/guide/jar/jar.html
        // Example code for loading from a manifest file:
        // http://forums.sun.com/thread.jspa?messageID=3791501
        File infoFile = new File(toolDirectory, ""tool.txt"");
        if (!infoFile.exists()) continue;

        String[] info = PApplet.loadStrings(infoFile);
        //Main-Class: org.poo.shoe.AwesomerTool
        //String className = folders[i].getName();
        String className = null;
        for (int k = 0; k < info.length; k++) {
          if (info[k].startsWith("";"")) continue;

          String[] pieces = PApplet.splitTokens(info[k], "": "");
          if (pieces.length == 2) {
            if (pieces[0].equals(""Main-Class"")) {
              className = pieces[1];
            }
          }
        }
        */
        // If no class name found, just move on.
        if (className == null) continue;

        Class<?> toolClass = Class.forName(className, true, loader);
        final Tool tool = (Tool) toolClass.newInstance();

        tool.init(Editor.this);

        String title = tool.getMenuTitle();
        JMenuItem item = new JMenuItem(title);
        item.addActionListener(event -> {
          SwingUtilities.invokeLater(tool);
          //new Thread(tool).start();
        });
        //menu.add(item);
        toolItems.put(title, item);

      } catch (Exception e) {
        e.printStackTrace();
      }
    }
    ArrayList<String> toolList = new ArrayList<>(toolItems.keySet());
    if (toolList.size() == 0) return;

    menu.addSeparator();
    Collections.sort(toolList);
    for (String title : toolList) {
      menu.add(toolItems.get(title));
    }
  }",iterator
entries,"{
    // Class file to search for
    String classFileName = ""/"" + base + "".class"";

    ZipFile zipFile = null;
    try {
      zipFile = new ZipFile(file);
      Enumeration<?> entries = zipFile.entries();
      while (entries.hasMoreElements()) {
        ZipEntry entry = (ZipEntry) entries.nextElement();

        if (!entry.isDirectory()) {
          String name = entry.getName();
          //System.out.println(""entry: "" + name);

          if (name.endsWith(classFileName)) {
            //int slash = name.lastIndexOf('/');
            //String packageName = (slash == -1) ? """" : name.substring(0, slash);
            // Remove .class and convert slashes to periods.
            return name.substring(0, name.length() - 6).replace('/', '.');
          }
        }
      }
    } catch (IOException e) {
      //System.err.println(""Ignoring "" + filename + "" ("" + e.getMessage() + "")"");
      e.printStackTrace();
    } finally {
      if (zipFile != null) {
        try {
           zipFile.close();
         } catch (IOException e) {
           // noop
         }
       }
     }
     return null;
   }",maybe_loop_control
entry,"{
    // Class file to search for
    String classFileName = ""/"" + base + "".class"";

    ZipFile zipFile = null;
    try {
      zipFile = new ZipFile(file);
      Enumeration<?> entries = zipFile.entries();
      while (entries.hasMoreElements()) {
        ZipEntry entry = (ZipEntry) entries.nextElement();

        if (!entry.isDirectory()) {
          String name = entry.getName();
          //System.out.println(""entry: "" + name);

          if (name.endsWith(classFileName)) {
            //int slash = name.lastIndexOf('/');
            //String packageName = (slash == -1) ? """" : name.substring(0, slash);
            // Remove .class and convert slashes to periods.
            return name.substring(0, name.length() - 6).replace('/', '.');
          }
        }
      }
    } catch (IOException e) {
      //System.err.println(""Ignoring "" + filename + "" ("" + e.getMessage() + "")"");
      e.printStackTrace();
    } finally {
      if (zipFile != null) {
        try {
           zipFile.close();
         } catch (IOException e) {
           // noop
         }
       }
     }
     return null;
   }",break_loop_control
name,"{
    // Class file to search for
    String classFileName = ""/"" + base + "".class"";

    ZipFile zipFile = null;
    try {
      zipFile = new ZipFile(file);
      Enumeration<?> entries = zipFile.entries();
      while (entries.hasMoreElements()) {
        ZipEntry entry = (ZipEntry) entries.nextElement();

        if (!entry.isDirectory()) {
          String name = entry.getName();
          //System.out.println(""entry: "" + name);

          if (name.endsWith(classFileName)) {
            //int slash = name.lastIndexOf('/');
            //String packageName = (slash == -1) ? """" : name.substring(0, slash);
            // Remove .class and convert slashes to periods.
            return name.substring(0, name.length() - 6).replace('/', '.');
          }
        }
      }
    } catch (IOException e) {
      //System.err.println(""Ignoring "" + filename + "" ("" + e.getMessage() + "")"");
      e.printStackTrace();
    } finally {
      if (zipFile != null) {
        try {
           zipFile.close();
         } catch (IOException e) {
           // noop
         }
       }
     }
     return null;
   }",break_loop_control
tab,"{
    for (EditorTab tab : tabs)
      tab.updateKeywords(keywords);
  }",iterator
i,"{
    if(portMenu == null) {
      System.out.println(tr(""serialMenu is null""));
      return;
    }
    if (name == null) {
      System.out.println(tr(""name is null""));
      return;
    }
    JCheckBoxMenuItem selection = null;
    for (int i = 0; i < portMenu.getItemCount(); i++) {
      JMenuItem menuItem = portMenu.getItem(i);
      if (!(menuItem instanceof JCheckBoxMenuItem)) {
        continue;
      }
      JCheckBoxMenuItem checkBoxMenuItem = ((JCheckBoxMenuItem) menuItem);
      checkBoxMenuItem.setState(false);
      if (name.equals(checkBoxMenuItem.getText())) selection = checkBoxMenuItem;
    }
    if (selection != null) selection.setState(true);
    //System.out.println(item.getLabel());

    BaseNoGui.selectSerialPort(name);
    try {
      boolean reopenMonitor = ((serialMonitor != null && serialMonitor.isVisible()) ||
                                serialPlotter != null && serialPlotter.isVisible());
      if (serialMonitor != null) {
        serialMonitor.close();
      }
      if (serialPlotter != null) {
        serialPlotter.close();
      }
      if (reopenMonitor) {
        handleSerial();
      }
    } catch (Exception e) {
      // ignore
    }

    onBoardOrPortChange();
    base.onBoardOrPortChange();

    //System.out.println(""set to "" + get(""serial.port""));
  }",loop_control
port,"{
    final List<String> PROTOCOLS_ORDER = Arrays.asList(""serial"", ""network"");
    final List<String> PROTOCOLS_LABELS = Arrays.asList(tr(""Serial ports""), tr(""Network ports""));

    portMenu.removeAll();

    String selectedPort = PreferencesData.get(""serial.port"");

    List<BoardPort> ports = Base.getDiscoveryManager().discovery();

    ports = platform.filterPorts(ports, PreferencesData.getBoolean(""serial.ports.showall""));

    ports.stream() //
        .filter(port -> port.getProtocolLabel() == null || port.getProtocolLabel().isEmpty())
        .forEach(port -> {
          int labelIdx = PROTOCOLS_ORDER.indexOf(port.getProtocol());
          if (labelIdx != -1) {
            port.setProtocolLabel(PROTOCOLS_LABELS.get(labelIdx));
          } else {
            port.setProtocolLabel(port.getProtocol());
          }
        });

    Collections.sort(ports, (port1, port2) -> {
      String pr1 = port1.getProtocol();
      String pr2 = port2.getProtocol();
      int prIdx1 = PROTOCOLS_ORDER.contains(pr1) ? PROTOCOLS_ORDER.indexOf(pr1) : 999;
      int prIdx2 = PROTOCOLS_ORDER.contains(pr2) ? PROTOCOLS_ORDER.indexOf(pr2) : 999;
      int r = prIdx1 - prIdx2;
      if (r != 0)
        return r;
      r = port1.getProtocolLabel().compareTo(port2.getProtocolLabel());
      if (r != 0)
        return r;
      return port1.getAddress().compareTo(port2.getAddress());
    });

    String lastProtocol = """";
    String lastProtocolLabel = """";
    for (BoardPort port : ports) {
      if (!port.getProtocol().equals(lastProtocol) || !port.getProtocolLabel().equals(lastProtocolLabel)) {
        if (!lastProtocol.isEmpty()) {
          portMenu.addSeparator();
        }
        lastProtocol = port.getProtocol();
        lastProtocolLabel = port.getProtocolLabel();
        JMenuItem item = new JMenuItem(tr(lastProtocolLabel));
        item.setEnabled(false);
        portMenu.add(item);
      }
      String address = port.getAddress();

      BoardPortJCheckBoxMenuItem item = new BoardPortJCheckBoxMenuItem(port);
      item.setSelected(address.equals(selectedPort));
      portMenu.add(item);
    }

    portMenu.setEnabled(portMenu.getMenuComponentCount() > 0);
  }",iterator
i,"{
    for (int i = 0; i < tabs.size(); ++i) {
      if (tabs.get(i).getSketchFile() == file)
        return i;
    }
    return -1;
  }",loop_control
i,"{
    for (int i = 0; i < tabs.size(); ++i) {
      if (tabs.get(i).getSketchFile().getFile().equals(file))
        return i;
    }
    return -1;
  }",loop_control
file,"{
    tabs.clear();
    currentTabIndex = -1;
    tabs.ensureCapacity(sketch.getCodeCount());
    for (SketchFile file : sketch.getFiles()) {
      try {
        addTab(file, null);
      } catch(IOException e) {
        // TODO: Improve / move error handling
        System.err.println(e);
      }
    }
    selectTab(0);
  }",iterator
i,"{
    if (shouldSavePredicate.test(sketchController)) {
      handleSave(true);
    }
    toolbar.activateRun();
    status.progress(tr(""Compiling sketch...""));

    // do this to advance/clear the terminal window / dos prompt / etc
    for (int i = 0; i < 10; i++) System.out.println();

    // clear the console on each run, unless the user doesn't want to
    if (PreferencesData.getBoolean(""console.auto_clear"")) {
      console.clear();
    }

    // Cannot use invokeLater() here, otherwise it gets
    // placed on the event thread and causes a hang--bad idea all around.
    new Thread(verbose ? verboseHandler : nonVerboseHandler).start();
  }",loop_control
tab,"{
    for (EditorTab tab : tabs)
      tab.getTextArea().removeAllLineHighlights();
  }",iterator
i,"{
    SketchTextArea textArea = getCurrentTab().getTextArea();
    FoldManager foldManager = textArea.getFoldManager();
    if (foldManager.isLineHidden(line)) {
      for (int i = 0; i < foldManager.getFoldCount(); i++) {
        if (foldManager.getFold(i).containsLine(line)) {
          foldManager.getFold(i).setCollapsed(false);
        }
      }
    }
    textArea.addLineHighlight(line, new Color(1, 0, 0, 0.2f));
    textArea.setCaretPosition(textArea.getLineStartOffset(line));
  }",loop_control
i,"{
    List<BoardPortJCheckBoxMenuItem> items = new ArrayList<>();
    for (int i = 0; i < portMenu.getItemCount(); i++) {
      if (portMenu.getItem(i) instanceof BoardPortJCheckBoxMenuItem)
        items.add((BoardPortJCheckBoxMenuItem) portMenu.getItem(i));
    }

    String port = PreferencesData.get(""serial.port"");
    String title;
    if (port == null || port.isEmpty()) {
      title = tr(""Serial port not selected."");
    } else {
      title = I18n.format(tr(""Serial port {0} not found.""), port);
    }
    String question = tr(""Retry the upload with another serial port?"");
    BoardPortJCheckBoxMenuItem result = (BoardPortJCheckBoxMenuItem) JOptionPane
        .showInputDialog(this, title + ""\n"" + question, title,
                         JOptionPane.PLAIN_MESSAGE, null, items.toArray(), 0);
    if (result == null)
      return false;
    result.doClick();
    base.onBoardOrPortChange();
    return true;
  }",loop_control
boardPort,"{
    // Return the serial monitor window to its initial state
    if (serialMonitor != null) {
      try {
        Thread.sleep(200);
      } catch (InterruptedException e) {
          // noop
      }
      BoardPort boardPort = BaseNoGui.getDiscoveryManager().find(PreferencesData.get(""serial.port""));
      long sleptFor = 0;
      while (boardPort == null && sleptFor < MAX_TIME_AWAITING_FOR_RESUMING_SERIAL_MONITOR) {
        try {
          Thread.sleep(100);
          sleptFor += 100;
          boardPort = BaseNoGui.getDiscoveryManager().find(PreferencesData.get(""serial.port""));
        } catch (InterruptedException e) {
          // noop
        }
      }
      try {
        if (serialMonitor != null) {
          serialMonitor.resume(boardPort);
          if (boardPort == null) {
            serialMonitor.close();
            handleSerial();
          } else {
            serialMonitor.resume(boardPort);
          }
        }
      } catch (Exception e) {
        statusError(e);
      }
   }
  }",maybe_loop_control
sleptFor,"{
    // Return the serial monitor window to its initial state
    if (serialMonitor != null) {
      try {
        Thread.sleep(200);
      } catch (InterruptedException e) {
          // noop
      }
      BoardPort boardPort = BaseNoGui.getDiscoveryManager().find(PreferencesData.get(""serial.port""));
      long sleptFor = 0;
      while (boardPort == null && sleptFor < MAX_TIME_AWAITING_FOR_RESUMING_SERIAL_MONITOR) {
        try {
          Thread.sleep(100);
          sleptFor += 100;
          boardPort = BaseNoGui.getDiscoveryManager().find(PreferencesData.get(""serial.port""));
        } catch (InterruptedException e) {
          // noop
        }
      }
      try {
        if (serialMonitor != null) {
          serialMonitor.resume(boardPort);
          if (boardPort == null) {
            serialMonitor.close();
            handleSerial();
          } else {
            serialMonitor.resume(boardPort);
          }
        }
      } catch (Exception e) {
        statusError(e);
      }
   }
  }",maybe_loop_control
serialMonitor,"{
    if(serialPlotter != null) {
      if(serialPlotter.isClosed()) {
        serialPlotter = null;
      } else {
        statusError(tr(""Serial monitor not available while plotter is open""));
        return;
      }
    }

    if (serialMonitor != null) {
      // The serial monitor already exists

      if (serialMonitor.isClosed()) {
        serialMonitor.dispose();
        // If it's closed, clear the refrence to the existing
        // monitor and create a new one
        serialMonitor = null;
      }
      else {
        // If it's not closed, give it the focus
        try {
          serialMonitor.toFront();
          serialMonitor.requestFocus();
          return;
        } catch (Exception e) {
          // noop
        }
      }
    }

    BoardPort port = Base.getDiscoveryManager().find(PreferencesData.get(""serial.port""));

    if (port == null) {
      statusError(I18n.format(tr(""Board at {0} is not available""), PreferencesData.get(""serial.port"")));
      return;
    }

    serialMonitor = new MonitorFactory().newMonitor(port);

    if (serialMonitor == null) {
      String board = port.getPrefs().get(""board"");
      String boardName = BaseNoGui.getPlatform().resolveDeviceByBoardID(BaseNoGui.packages, board);
      statusError(I18n.format(tr(""Serial monitor is not supported on network ports such as {0} for the {1} in this release""), PreferencesData.get(""serial.port""), boardName));
      return;
    }

    base.addEditorFontResizeListeners(serialMonitor);
    Base.setIcon(serialMonitor);

    // If currently uploading, disable the monitor (it will be later
    // enabled when done uploading)
    if (uploading || avoidMultipleOperations) {
      try {
        serialMonitor.suspend();
      } catch (Exception e) {
        statusError(e);
      }
    }

    boolean success = false;
    do {
      if (serialMonitor.requiresAuthorization() && !PreferencesData.has(serialMonitor.getAuthorizationKey())) {
        PasswordAuthorizationDialog dialog = new PasswordAuthorizationDialog(this, tr(""Type board password to access its console""));
        dialog.setLocationRelativeTo(this);
        dialog.setVisible(true);

        if (dialog.isCancelled()) {
          statusNotice(tr(""Unable to open serial monitor""));
          return;
        }

        PreferencesData.set(serialMonitor.getAuthorizationKey(), dialog.getPassword());
      }

      try {
        if (!avoidMultipleOperations) {
          serialMonitor.open();
        }
        serialMonitor.setVisible(true);
        success = true;
        statusEmpty();
      } catch (ConnectException e) {
        statusError(tr(""Unable to connect: is the sketch using the bridge?""));
      } catch (JSchException e) {
        statusError(tr(""Unable to connect: wrong password?""));
      } catch (SerialException e) {
        String errorMessage = e.getMessage();
        if (e.getCause() != null && e.getCause() instanceof SerialPortException) {
          errorMessage += "" ("" + ((SerialPortException) e.getCause()).getExceptionType() + "")"";
        }
        serialMonitor = null;
        statusError(errorMessage);
        try {
          serialMonitor.close();
        } catch (Exception e1) {
          // noop
        }
      } catch (Exception e) {
        statusError(e);
      } finally {
        if (serialMonitor != null && serialMonitor.requiresAuthorization() && !success) {
          PreferencesData.remove(serialMonitor.getAuthorizationKey());
        }
      }

    } while (serialMonitor != null && serialMonitor.requiresAuthorization() && !success);

  }",maybe_loop_control
success,"{
    if(serialPlotter != null) {
      if(serialPlotter.isClosed()) {
        serialPlotter = null;
      } else {
        statusError(tr(""Serial monitor not available while plotter is open""));
        return;
      }
    }

    if (serialMonitor != null) {
      // The serial monitor already exists

      if (serialMonitor.isClosed()) {
        serialMonitor.dispose();
        // If it's closed, clear the refrence to the existing
        // monitor and create a new one
        serialMonitor = null;
      }
      else {
        // If it's not closed, give it the focus
        try {
          serialMonitor.toFront();
          serialMonitor.requestFocus();
          return;
        } catch (Exception e) {
          // noop
        }
      }
    }

    BoardPort port = Base.getDiscoveryManager().find(PreferencesData.get(""serial.port""));

    if (port == null) {
      statusError(I18n.format(tr(""Board at {0} is not available""), PreferencesData.get(""serial.port"")));
      return;
    }

    serialMonitor = new MonitorFactory().newMonitor(port);

    if (serialMonitor == null) {
      String board = port.getPrefs().get(""board"");
      String boardName = BaseNoGui.getPlatform().resolveDeviceByBoardID(BaseNoGui.packages, board);
      statusError(I18n.format(tr(""Serial monitor is not supported on network ports such as {0} for the {1} in this release""), PreferencesData.get(""serial.port""), boardName));
      return;
    }

    base.addEditorFontResizeListeners(serialMonitor);
    Base.setIcon(serialMonitor);

    // If currently uploading, disable the monitor (it will be later
    // enabled when done uploading)
    if (uploading || avoidMultipleOperations) {
      try {
        serialMonitor.suspend();
      } catch (Exception e) {
        statusError(e);
      }
    }

    boolean success = false;
    do {
      if (serialMonitor.requiresAuthorization() && !PreferencesData.has(serialMonitor.getAuthorizationKey())) {
        PasswordAuthorizationDialog dialog = new PasswordAuthorizationDialog(this, tr(""Type board password to access its console""));
        dialog.setLocationRelativeTo(this);
        dialog.setVisible(true);

        if (dialog.isCancelled()) {
          statusNotice(tr(""Unable to open serial monitor""));
          return;
        }

        PreferencesData.set(serialMonitor.getAuthorizationKey(), dialog.getPassword());
      }

      try {
        if (!avoidMultipleOperations) {
          serialMonitor.open();
        }
        serialMonitor.setVisible(true);
        success = true;
        statusEmpty();
      } catch (ConnectException e) {
        statusError(tr(""Unable to connect: is the sketch using the bridge?""));
      } catch (JSchException e) {
        statusError(tr(""Unable to connect: wrong password?""));
      } catch (SerialException e) {
        String errorMessage = e.getMessage();
        if (e.getCause() != null && e.getCause() instanceof SerialPortException) {
          errorMessage += "" ("" + ((SerialPortException) e.getCause()).getExceptionType() + "")"";
        }
        serialMonitor = null;
        statusError(errorMessage);
        try {
          serialMonitor.close();
        } catch (Exception e1) {
          // noop
        }
      } catch (Exception e) {
        statusError(e);
      } finally {
        if (serialMonitor != null && serialMonitor.requiresAuthorization() && !success) {
          PreferencesData.remove(serialMonitor.getAuthorizationKey());
        }
      }

    } while (serialMonitor != null && serialMonitor.requiresAuthorization() && !success);

  }",maybe_loop_control
serialPlotter,"{
    if(serialMonitor != null) {
      if(serialMonitor.isClosed()) {
        serialMonitor = null;
      } else {
        statusError(tr(""Plotter not available while serial monitor is open""));
        return;
      }
    }

    if (serialPlotter != null) {
      // The serial plotter already exists

      if (serialPlotter.isClosed()) {
        // If it's closed, clear the refrence to the existing
        // plotter and create a new one
        serialPlotter.dispose();
        serialPlotter = null;
      }
      else {
        // If it's not closed, give it the focus
        try {
          serialPlotter.toFront();
          serialPlotter.requestFocus();
          return;
        } catch (Exception e) {
          // noop
        }
      }
    }

    BoardPort port = Base.getDiscoveryManager().find(PreferencesData.get(""serial.port""));

    if (port == null) {
      statusError(I18n.format(tr(""Board at {0} is not available""), PreferencesData.get(""serial.port"")));
      return;
    }

    serialPlotter = new SerialPlotter(port);
    Base.setIcon(serialPlotter);

    // If currently uploading, disable the plotter (it will be later
    // enabled when done uploading)
    if (uploading) {
      try {
        serialPlotter.suspend();
      } catch (Exception e) {
        statusError(e);
      }
    }

    boolean success = false;
    do {
      if (serialPlotter.requiresAuthorization() && !PreferencesData.has(serialPlotter.getAuthorizationKey())) {
        PasswordAuthorizationDialog dialog = new PasswordAuthorizationDialog(this, tr(""Type board password to access its console""));
        dialog.setLocationRelativeTo(this);
        dialog.setVisible(true);

        if (dialog.isCancelled()) {
          statusNotice(tr(""Unable to open serial plotter""));
          return;
        }

        PreferencesData.set(serialPlotter.getAuthorizationKey(), dialog.getPassword());
      }

      try {
        serialPlotter.open();
        serialPlotter.setVisible(true);
        success = true;
        statusEmpty();
      } catch (ConnectException e) {
        statusError(tr(""Unable to connect: is the sketch using the bridge?""));
      } catch (JSchException e) {
        statusError(tr(""Unable to connect: wrong password?""));
      } catch (SerialException e) {
        String errorMessage = e.getMessage();
        if (e.getCause() != null && e.getCause() instanceof SerialPortException) {
          errorMessage += "" ("" + ((SerialPortException) e.getCause()).getExceptionType() + "")"";
        }
        statusError(errorMessage);
        serialPlotter = null;
      } catch (Exception e) {
        statusError(e);
      } finally {
        if (serialPlotter != null && serialPlotter.requiresAuthorization() && !success) {
          PreferencesData.remove(serialPlotter.getAuthorizationKey());
        }
      }

    } while (serialPlotter != null && serialPlotter.requiresAuthorization() && !success);

  }",maybe_loop_control
success,"{
    if(serialMonitor != null) {
      if(serialMonitor.isClosed()) {
        serialMonitor = null;
      } else {
        statusError(tr(""Plotter not available while serial monitor is open""));
        return;
      }
    }

    if (serialPlotter != null) {
      // The serial plotter already exists

      if (serialPlotter.isClosed()) {
        // If it's closed, clear the refrence to the existing
        // plotter and create a new one
        serialPlotter.dispose();
        serialPlotter = null;
      }
      else {
        // If it's not closed, give it the focus
        try {
          serialPlotter.toFront();
          serialPlotter.requestFocus();
          return;
        } catch (Exception e) {
          // noop
        }
      }
    }

    BoardPort port = Base.getDiscoveryManager().find(PreferencesData.get(""serial.port""));

    if (port == null) {
      statusError(I18n.format(tr(""Board at {0} is not available""), PreferencesData.get(""serial.port"")));
      return;
    }

    serialPlotter = new SerialPlotter(port);
    Base.setIcon(serialPlotter);

    // If currently uploading, disable the plotter (it will be later
    // enabled when done uploading)
    if (uploading) {
      try {
        serialPlotter.suspend();
      } catch (Exception e) {
        statusError(e);
      }
    }

    boolean success = false;
    do {
      if (serialPlotter.requiresAuthorization() && !PreferencesData.has(serialPlotter.getAuthorizationKey())) {
        PasswordAuthorizationDialog dialog = new PasswordAuthorizationDialog(this, tr(""Type board password to access its console""));
        dialog.setLocationRelativeTo(this);
        dialog.setVisible(true);

        if (dialog.isCancelled()) {
          statusNotice(tr(""Unable to open serial plotter""));
          return;
        }

        PreferencesData.set(serialPlotter.getAuthorizationKey(), dialog.getPassword());
      }

      try {
        serialPlotter.open();
        serialPlotter.setVisible(true);
        success = true;
        statusEmpty();
      } catch (ConnectException e) {
        statusError(tr(""Unable to connect: is the sketch using the bridge?""));
      } catch (JSchException e) {
        statusError(tr(""Unable to connect: wrong password?""));
      } catch (SerialException e) {
        String errorMessage = e.getMessage();
        if (e.getCause() != null && e.getCause() instanceof SerialPortException) {
          errorMessage += "" ("" + ((SerialPortException) e.getCause()).getExceptionType() + "")"";
        }
        statusError(errorMessage);
        serialPlotter = null;
      } catch (Exception e) {
        statusError(e);
      } finally {
        if (serialPlotter != null && serialPlotter.requiresAuthorization() && !success) {
          PreferencesData.remove(serialPlotter.getAuthorizationKey());
        }
      }

    } while (serialPlotter != null && serialPlotter.requiresAuthorization() && !success);

  }",maybe_loop_control
port,"{
    console.clear();

    String selectedPort = PreferencesData.get(""serial.port"");
    List<BoardPort> ports = Base.getDiscoveryManager().discovery();

    String label = """";
    String vid = """";
    String pid = """";
    String iserial = """";
    String protocol = """";
    boolean found = false;

    for (BoardPort port : ports) {
      if (port.getAddress().equals(selectedPort)) {
        label = port.getBoardName();
        vid = port.getPrefs().get(""vid"");
        pid = port.getPrefs().get(""pid"");
        iserial = port.getPrefs().get(""iserial"");
        protocol = port.getProtocol();
        found = true;
        break;
      }
    }

    if (!found) {
      statusNotice(tr(""Please select a port to obtain board info""));
      return;
    }

    if (protocol.equals(""network"")) {
      statusNotice(tr(""Network port, can't obtain info""));
      return;
    }

    if (vid == null || vid.equals("""") || vid.equals(""0000"")) {
      statusNotice(tr(""Native serial port, can't obtain info""));
      return;
    }

    if (iserial == null || iserial.equals("""")) {
      iserial = tr(""Upload any sketch to obtain it"");
    }

    if (label == null) {
      label = tr(""Unknown board"");
    }

    String infos = I18n.format(""BN: {0}\nVID: {1}\nPID: {2}\nSN: {3}"", label, vid, pid, iserial);
    JTextArea textArea = new JTextArea(infos);

    JOptionPane.showMessageDialog(this, textArea, tr(""Board Info""), JOptionPane.PLAIN_MESSAGE);
  }",iterator
port,"{
    console.clear();

    String selectedPort = PreferencesData.get(""serial.port"");
    List<BoardPort> ports = Base.getDiscoveryManager().discovery();

    String label = """";
    String vid = """";
    String pid = """";
    String iserial = """";
    String protocol = """";
    boolean found = false;

    for (BoardPort port : ports) {
      if (port.getAddress().equals(selectedPort)) {
        label = port.getBoardName();
        vid = port.getPrefs().get(""vid"");
        pid = port.getPrefs().get(""pid"");
        iserial = port.getPrefs().get(""iserial"");
        protocol = port.getProtocol();
        found = true;
        break;
      }
    }

    if (!found) {
      statusNotice(tr(""Please select a port to obtain board info""));
      return;
    }

    if (protocol.equals(""network"")) {
      statusNotice(tr(""Network port, can't obtain info""));
      return;
    }

    if (vid == null || vid.equals("""") || vid.equals(""0000"")) {
      statusNotice(tr(""Native serial port, can't obtain info""));
      return;
    }

    if (iserial == null || iserial.equals("""")) {
      iserial = tr(""Upload any sketch to obtain it"");
    }

    if (label == null) {
      label = tr(""Unknown board"");
    }

    String infos = I18n.format(""BN: {0}\nVID: {1}\nPID: {2}\nSN: {3}"", label, vid, pid, iserial);
    JTextArea textArea = new JTextArea(infos);

    JOptionPane.showMessageDialog(this, textArea, tr(""Board Info""), JOptionPane.PLAIN_MESSAGE);
  }",break_loop_control
i,"{
    if (touchBarImages == null) {
      loadTouchBarImages();
    }
    
    touchBar = new JTouchBar();
    touchBarButtons = new TouchBarButton[BUTTON_COUNT];
    touchBar.setCustomizationIdentifier(""Arduino"");
    
    for (int i = 0; i < BUTTON_COUNT; i++) {
      final int selection = i;
      
      // add spacers before NEW and SERIAL buttons
      if (i == NEW) {
        touchBar.addItem(new TouchBarItem(TouchBarItem.NSTouchBarItemIdentifierFixedSpaceSmall));
      } else if (i == SERIAL) {
        touchBar.addItem(new TouchBarItem(TouchBarItem.NSTouchBarItemIdentifierFlexibleSpace));
      }
      
      touchBarButtons[i] = new TouchBarButton();
      touchBarButtons[i].setImage(touchBarImages[i][ROLLOVER]);
      touchBarButtons[i].setAction(event -> {
        // Run event handler later to prevent hanging if a dialog needs to be open
        EventQueue.invokeLater(new Runnable() {
          @Override
          public void run() {
            handleSelectionPressed(selection);
          }
        });
      });
      
      TouchBarItem touchBarItem = new TouchBarItem(title[i], touchBarButtons[i], true);
      touchBarItem.setCustomizationLabel(title[i]);
      
      touchBar.addItem(touchBarItem);
    }
  }",loop_control
i,"{
    Image allButtons = Theme.getThemeImage(""buttons"", this,
                                           BUTTON_IMAGE_SIZE * BUTTON_COUNT,
                                           BUTTON_IMAGE_SIZE * 3);
    buttonImages = new Image[BUTTON_COUNT][3];

    for (int i = 0; i < BUTTON_COUNT; i++) {
      for (int state = 0; state < 3; state++) {
        Image image = createImage(BUTTON_WIDTH, BUTTON_HEIGHT);
        Graphics g = image.getGraphics();
        g.setColor(bgcolor);
        g.fillRect(0, 0, BUTTON_WIDTH, BUTTON_HEIGHT);
        int offset = (BUTTON_IMAGE_SIZE - BUTTON_WIDTH) / 2;
        g.drawImage(allButtons, -(i * BUTTON_IMAGE_SIZE) - offset,
                    (-2 + state) * BUTTON_IMAGE_SIZE, null);
        buttonImages[i][state] = image;
      }
    }
  }",loop_control
state,"{
    Image allButtons = Theme.getThemeImage(""buttons"", this,
                                           BUTTON_IMAGE_SIZE * BUTTON_COUNT,
                                           BUTTON_IMAGE_SIZE * 3);
    buttonImages = new Image[BUTTON_COUNT][3];

    for (int i = 0; i < BUTTON_COUNT; i++) {
      for (int state = 0; state < 3; state++) {
        Image image = createImage(BUTTON_WIDTH, BUTTON_HEIGHT);
        Graphics g = image.getGraphics();
        g.setColor(bgcolor);
        g.fillRect(0, 0, BUTTON_WIDTH, BUTTON_HEIGHT);
        int offset = (BUTTON_IMAGE_SIZE - BUTTON_WIDTH) / 2;
        g.drawImage(allButtons, -(i * BUTTON_IMAGE_SIZE) - offset,
                    (-2 + state) * BUTTON_IMAGE_SIZE, null);
        buttonImages[i][state] = image;
      }
    }
  }",loop_control
i,"{
    Image allButtonsRetina = Theme.getThemeImage(""buttons"", this,
                                           BUTTON_IMAGE_SIZE * BUTTON_COUNT * 2,
                                           BUTTON_IMAGE_SIZE * 3 * 2);
    touchBarImages = new com.thizzer.jtouchbar.common.Image[BUTTON_COUNT][3];

    for (int i = 0; i < BUTTON_COUNT; i++) {
      for (int state = 0; state < 3; state++) {
        BufferedImage image = new BufferedImage(BUTTON_WIDTH * 2, BUTTON_HEIGHT * 2, 
                                                BufferedImage.TYPE_INT_ARGB);
        Graphics g = image.getGraphics();

        int offset = (BUTTON_IMAGE_SIZE * 2 - BUTTON_WIDTH * 2) / 2;
        g.drawImage(allButtonsRetina, -(i * BUTTON_IMAGE_SIZE * 2) - offset,
                    (-2 + state) * BUTTON_IMAGE_SIZE * 2, null);        
        
        // convert the image to a PNG to display on the touch bar
        ByteArrayOutputStream pngStream = new ByteArrayOutputStream();
        
        try {
          ImageIO.write(image, ""PNG"", pngStream);

          touchBarImages[i][state] = new com.thizzer.jtouchbar.common.Image(pngStream.toByteArray());
        } catch (IOException e) {
          // ignore errors
        }
      }
    }
  }",loop_control
state,"{
    Image allButtonsRetina = Theme.getThemeImage(""buttons"", this,
                                           BUTTON_IMAGE_SIZE * BUTTON_COUNT * 2,
                                           BUTTON_IMAGE_SIZE * 3 * 2);
    touchBarImages = new com.thizzer.jtouchbar.common.Image[BUTTON_COUNT][3];

    for (int i = 0; i < BUTTON_COUNT; i++) {
      for (int state = 0; state < 3; state++) {
        BufferedImage image = new BufferedImage(BUTTON_WIDTH * 2, BUTTON_HEIGHT * 2, 
                                                BufferedImage.TYPE_INT_ARGB);
        Graphics g = image.getGraphics();

        int offset = (BUTTON_IMAGE_SIZE * 2 - BUTTON_WIDTH * 2) / 2;
        g.drawImage(allButtonsRetina, -(i * BUTTON_IMAGE_SIZE * 2) - offset,
                    (-2 + state) * BUTTON_IMAGE_SIZE * 2, null);        
        
        // convert the image to a PNG to display on the touch bar
        ByteArrayOutputStream pngStream = new ByteArrayOutputStream();
        
        try {
          ImageIO.write(image, ""PNG"", pngStream);

          touchBarImages[i][state] = new com.thizzer.jtouchbar.common.Image(pngStream.toByteArray());
        } catch (IOException e) {
          // ignore errors
        }
      }
    }
  }",loop_control
i,"{
    // this data is shared by all EditorToolbar instances
    if (buttonImages == null) {
      loadButtons();
    }

    // this happens once per instance of EditorToolbar
    if (stateImage == null) {
      state = new int[buttonCount];
      stateImage = new Image[buttonCount];
      for (int i = 0; i < buttonCount; i++) {
        setState(i, INACTIVE, false);
      }
      y1 = 0;
      y2 = BUTTON_HEIGHT;
      x1 = new int[buttonCount];
      x2 = new int[buttonCount];
    }

    Dimension size = getSize();
    if ((offscreen == null) ||
      (size.width != width) || (size.height != height)) {
      offscreen = createImage(size.width, size.height);
      width = size.width;
      height = size.height;

      int offsetX = 3;
      for (int i = 0; i < buttonCount; i++) {
        x1[i] = offsetX;
        if (i == 2 || i == 6) x1[i] += BUTTON_GAP;
        x2[i] = x1[i] + BUTTON_WIDTH;
        offsetX = x2[i];
      }

      // Serial button must be on the right
      x1[SERIAL] = width - BUTTON_WIDTH - 14;
      x2[SERIAL] = width - 14;
    }
    Graphics2D g = Theme.setupGraphics2D(offscreen.getGraphics());
    g.setColor(bgcolor); //getBackground());
    g.fillRect(0, 0, width, height);

    for (int i = 0; i < buttonCount; i++) {
      g.drawImage(stateImage[i], x1[i], y1, null);
    }

    g.setColor(statusColor);
    g.setFont(statusFont);

    /*
    // if i ever find the guy who wrote the java2d api, i will hurt him.
     * 
     * whereas I love the Java2D API. --jdf. lol.
     * 
    Graphics2D g2 = (Graphics2D) g;
    FontRenderContext frc = g2.getFontRenderContext();
    float statusW = (float) statusFont.getStringBounds(status, frc).getWidth();
    float statusX = (getSize().width - statusW) / 2;
    g2.drawString(status, statusX, statusY);
    */
    if (currentRollover != -1) {
      int statusY = (BUTTON_HEIGHT + g.getFontMetrics().getAscent()) / 2;
      String status = shiftPressed ? titleShift[currentRollover] : title[currentRollover];
      if (currentRollover != SERIAL)
        g.drawString(status, (buttonCount - 1) * BUTTON_WIDTH + 3 * BUTTON_GAP, statusY);
      else {
        int statusX = x1[SERIAL] - BUTTON_GAP;
        statusX -= g.getFontMetrics().stringWidth(status);
        g.drawString(status, statusX, statusY);
      }
    }

    screen.drawImage(offscreen, 0, 0, null);

    if (!isEnabled()) {
      screen.setColor(new Color(0, 0, 0, 100));
      screen.fillRect(0, 0, getWidth(), getHeight());
    }
  }",loop_control
i,"{
    // if app loads slowly and cursor is near the buttons
    // when it comes up, the app may not have time to load
    if ((x1 == null) || (x2 == null)) return -1;

    for (int i = 0; i < buttonCount; i++) {
      if ((y > y1) && (x > x1[i]) &&
        (y < y2) && (x < x2[i])) {
        //System.out.println(""sel is "" + i);
        return i;
      }
    }
    return -1;
  }",loop_control
y,"{
    // if app loads slowly and cursor is near the buttons
    // when it comes up, the app may not have time to load
    if ((x1 == null) || (x2 == null)) return -1;

    for (int i = 0; i < buttonCount; i++) {
      if ((y > y1) && (x > x1[i]) &&
        (y < y2) && (x < x2[i])) {
        //System.out.println(""sel is "" + i);
        return i;
      }
    }
    return -1;
  }",break_loop_control
x,"{
    // if app loads slowly and cursor is near the buttons
    // when it comes up, the app may not have time to load
    if ((x1 == null) || (x2 == null)) return -1;

    for (int i = 0; i < buttonCount; i++) {
      if ((y > y1) && (x > x1[i]) &&
        (y < y2) && (x < x2[i])) {
        //System.out.println(""sel is "" + i);
        return i;
      }
    }
    return -1;
  }",break_loop_control
tmp,"{
    String text = """";
    if (textarea.getSelectedText() != null)
      text = textarea.getSelectedText().trim();

    try {
      int current = textarea.getCaretPosition();
      int startOffset = 0;
      int endIndex = current;
      String tmp = textarea.getDocument().getText(current, 1);
      // TODO probably a regexp that matches Arduino lang special chars
      // already exists.
      String regexp = ""[\\s\\n();\\\\.!='\\[\\]{}]"";

      while (!tmp.matches(regexp)) {
        endIndex++;
        tmp = textarea.getDocument().getText(endIndex, 1);
      }
      // For some reason document index start at 2.
      // if( current - start < 2 ) return;

      tmp = """";
      while (!tmp.matches(regexp)) {
        startOffset++;
        if (current - startOffset < 0) {
          tmp = textarea.getDocument().getText(0, 1);
          break;
        } else
          tmp = textarea.getDocument().getText(current - startOffset, 1);
      }
      startOffset--;

      int length = endIndex - current + startOffset;
      text = textarea.getDocument().getText(current - startOffset, length);

    } catch (BadLocationException bl) {
      bl.printStackTrace();
    }
    return text;
  }",maybe_loop_control
current,"{
    String text = """";
    if (textarea.getSelectedText() != null)
      text = textarea.getSelectedText().trim();

    try {
      int current = textarea.getCaretPosition();
      int startOffset = 0;
      int endIndex = current;
      String tmp = textarea.getDocument().getText(current, 1);
      // TODO probably a regexp that matches Arduino lang special chars
      // already exists.
      String regexp = ""[\\s\\n();\\\\.!='\\[\\]{}]"";

      while (!tmp.matches(regexp)) {
        endIndex++;
        tmp = textarea.getDocument().getText(endIndex, 1);
      }
      // For some reason document index start at 2.
      // if( current - start < 2 ) return;

      tmp = """";
      while (!tmp.matches(regexp)) {
        startOffset++;
        if (current - startOffset < 0) {
          tmp = textarea.getDocument().getText(0, 1);
          break;
        } else
          tmp = textarea.getDocument().getText(current - startOffset, 1);
      }
      startOffset--;

      int length = endIndex - current + startOffset;
      text = textarea.getDocument().getText(current - startOffset, length);

    } catch (BadLocationException bl) {
      bl.printStackTrace();
    }
    return text;
  }",break_loop_control
rate,"{

    mainPane.setLayout(new BorderLayout());

    textArea = new TextAreaFIFO(8_000_000);
    textArea.setRows(16);
    textArea.setColumns(40);
    textArea.setEditable(false);

    // don't automatically update the caret.  that way we can manually decide
    // whether or not to do so based on the autoscroll checkbox.
    ((DefaultCaret) textArea.getCaret()).setUpdatePolicy(DefaultCaret.NEVER_UPDATE);

    scrollPane = new JScrollPane(textArea);

    mainPane.add(scrollPane, BorderLayout.CENTER);

    JPanel upperPane = new JPanel();
    upperPane.setLayout(new BoxLayout(upperPane, BoxLayout.X_AXIS));
    upperPane.setBorder(new EmptyBorder(4, 4, 4, 4));

    textField = new JTextField(40);
    // textField is selected every time the window is focused
    addWindowFocusListener(new WindowAdapter() {
      @Override
      public void windowGainedFocus(WindowEvent e) {
        textField.requestFocusInWindow();
      }
    });

    // Add cut/copy/paste contextual menu to the text input field.
    JPopupMenu menu = new JPopupMenu();

    Action cut = new DefaultEditorKit.CutAction();
    cut.putValue(Action.NAME, tr(""Cut""));
    menu.add(cut);

    Action copy = new DefaultEditorKit.CopyAction();
    copy.putValue(Action.NAME, tr(""Copy""));
    menu.add(copy);

    Action paste = new DefaultEditorKit.PasteAction();
    paste.putValue(Action.NAME, tr(""Paste""));
    menu.add(paste);

    textField.setComponentPopupMenu(menu);

    sendButton = new JButton(tr(""Send""));
    clearButton = new JButton(tr(""Clear output""));

    upperPane.add(textField);
    upperPane.add(Box.createRigidArea(new Dimension(4, 0)));
    upperPane.add(sendButton);

    mainPane.add(upperPane, BorderLayout.NORTH);

    final JPanel pane = new JPanel();
    pane.setLayout(new BoxLayout(pane, BoxLayout.X_AXIS));
    pane.setBorder(new EmptyBorder(4, 4, 4, 4));

    autoscrollBox = new JCheckBox(tr(""Autoscroll""), true);
    addTimeStampBox = new JCheckBox(tr(""Show timestamp""), false);

    noLineEndingAlert = new JLabel(I18n.format(tr(""You've pressed {0} but nothing was sent. Should you select a line ending?""), tr(""Send"")));
    noLineEndingAlert.setToolTipText(noLineEndingAlert.getText());
    noLineEndingAlert.setForeground(pane.getBackground());
    Dimension minimumSize = new Dimension(noLineEndingAlert.getMinimumSize());
    minimumSize.setSize(minimumSize.getWidth() / 3, minimumSize.getHeight());
    noLineEndingAlert.setMinimumSize(minimumSize);

    lineEndings = new JComboBox<>(new String[]{tr(""No line ending""), tr(""Newline""), tr(""Carriage return""), tr(""Both NL & CR"")});
    lineEndings.addActionListener((ActionEvent event) -> {
      PreferencesData.setInteger(""serial.line_ending"", lineEndings.getSelectedIndex());
      noLineEndingAlert.setForeground(pane.getBackground());
    });
    addTimeStampBox.addActionListener((ActionEvent event) ->
        PreferencesData.setBoolean(""serial.show_timestamp"", addTimeStampBox.isSelected()));

    lineEndings.setMaximumSize(lineEndings.getMinimumSize());

    serialRates = new JComboBox<>();
    for (String rate : serialRateStrings) {
      serialRates.addItem(rate + "" "" + tr(""baud""));
    }

    serialRates.setMaximumSize(serialRates.getMinimumSize());

    pane.add(autoscrollBox);
    pane.add(addTimeStampBox);
    pane.add(Box.createHorizontalGlue());
    pane.add(noLineEndingAlert);
    pane.add(Box.createRigidArea(new Dimension(8, 0)));
    pane.add(lineEndings);
    pane.add(Box.createRigidArea(new Dimension(8, 0)));
    pane.add(serialRates);
    pane.add(Box.createRigidArea(new Dimension(8, 0)));
    pane.add(clearButton);

    applyPreferences();

    mainPane.add(pane, BorderLayout.SOUTH);
  }",iterator
tokenizer,"{
    String now = new SimpleDateFormat(""HH:mm:ss.SSS -> "").format(new Date());
    final StringBuilder sb = new StringBuilder(text.length() + now.length());
    StringTokenizer tokenizer = new StringTokenizer(text, LINE_SEPARATOR, true);
    while (tokenizer.hasMoreTokens()) {
      if (isStartingLine) {
        sb.append(now);
      }
      String token = tokenizer.nextToken();
      sb.append(token);
      // tokenizer returns ""\n"" as a single token
      isStartingLine = token.equals(LINE_SEPARATOR);
    }
    return sb.toString();
  }",maybe_loop_control
file,"{
    // make sure the user didn't hide the sketch folder
    ensureExistence();

    if (isReadOnly()) {
      Base.showMessage(tr(""Sketch is read-only""),
        tr(""Some files are marked \""read-only\"", so you'll\n"" +
          ""need to re-save this sketch to another location.""));
      return saveAs();
    }

    // rename .pde files to .ino
    List<SketchFile> oldFiles = new ArrayList<>();
    for (SketchFile file : sketch.getFiles()) {
      if (file.isExtension(Sketch.OLD_SKETCH_EXTENSIONS))
        oldFiles.add(file);
    }

    if (oldFiles.size() > 0) {
      if (PreferencesData.get(""editor.update_extension"") == null) {
        Object[] options = {tr(""OK""), tr(""Cancel"")};
        int result = JOptionPane.showOptionDialog(editor,
          tr(""In Arduino 1.0, the default file extension has changed\n"" +
            ""from .pde to .ino.  New sketches (including those created\n"" +
            ""by \""Save-As\"") will use the new extension.  The extension\n"" +
            ""of existing sketches will be updated on save, but you can\n"" +
            ""disable this in the Preferences dialog.\n"" +
            ""\n"" +
            ""Save sketch and update its extension?""),
          tr("".pde -> .ino""),
          JOptionPane.OK_CANCEL_OPTION,
          JOptionPane.QUESTION_MESSAGE,
          null,
          options,
          options[0]);

        if (result != JOptionPane.OK_OPTION) return false; // save cancelled

        PreferencesData.setBoolean(""editor.update_extension"", true);
      }

      if (PreferencesData.getBoolean(""editor.update_extension"")) {
        // Do rename of all .pde files to new .ino extension
        for (SketchFile file : oldFiles) {
          File newName = FileUtils.replaceExtension(file.getFile(), Sketch.DEFAULT_SKETCH_EXTENSION);
          file.renameTo(newName.getName());
        }
      }
    }

    sketch.save();
    return true;
  }",iterator
aList,"{
    // make sure the user didn't hide the sketch folder
    ensureExistence();

    List<String> list = lib.getIncludes();
    if (list == null) {
      File srcFolder = lib.getSrcFolder();
      String[] headers = Base.headerListFromIncludePath(srcFolder);
      list = Arrays.asList(headers);
    }
    if (list.isEmpty()) {
      return;
    }

    // import statements into the main sketch file (code[0])
    // if the current code is a .java file, insert into current
    //if (current.flavor == PDE) {
    SketchFile file = editor.getCurrentTab().getSketchFile();
    if (file.isExtension(Sketch.SKETCH_EXTENSIONS))
      editor.selectTab(0);

    // could also scan the text in the file to see if each import
    // statement is already in there, but if the user has the import
    // commented out, then this will be a problem.
    StringBuilder buffer = new StringBuilder();
    for (String aList : list) {
      buffer.append(""#include <"");
      buffer.append(aList);
      buffer.append("">\n"");
    }
    buffer.append('\n');
    buffer.append(editor.getCurrentTab().getText());
    editor.getCurrentTab().setText(buffer.toString());
    editor.getCurrentTab().setSelection(0, 0);  // scroll to start
  }",iterator
progressListener,"{
    // run the preprocessor
    for (CompilerProgressListener progressListener : editor.status.getCompilerProgressListeners()){
      progressListener.progress(20);
    }

    EditorConsole.setCurrentEditorConsole(editor.console);

    ensureExistence();
       

    boolean deleteTemp = false;
    File pathToSketch = sketch.getPrimaryFile().getFile();
    if (sketch.isModified()) {
      // If any files are modified, make a copy of the sketch with the changes
      // saved, so arduino-builder will see the modifications.
      pathToSketch = saveSketchInTempFolder();
      deleteTemp = true;
    }

    try {
      return new Compiler(pathToSketch, sketch).build(editor.status.getCompilerProgressListeners(), save);
    } finally {
      // Make sure we clean up any temporary sketch copy
      if (deleteTemp)
        FileUtils.recursiveDelete(pathToSketch.getParentFile());
    }
  }",iterator
file,"{
    File tempFolder = FileUtils.createTempFolder(""arduino_modified_sketch_"");
    FileUtils.copy(sketch.getFolder(), tempFolder);

    for (SketchFile file : Stream.of(sketch.getFiles()).filter(SketchFile::isModified).collect(Collectors.toList())) {
      Files.write(Paths.get(tempFolder.getAbsolutePath(), file.getFileName()), file.getProgram().getBytes(""UTF-8""));
    }

    return Paths.get(tempFolder.getAbsolutePath(), sketch.getPrimaryFile().getFileName()).toFile();
  }",iterator
warning,"{

    UploaderUtils uploaderInstance = new UploaderUtils();
    Uploader uploader = uploaderInstance.getUploaderByPreferences(false);

    EditorConsole.setCurrentEditorConsole(editor.console);

    boolean success = false;
    do {
      if (uploader.requiresAuthorization() && !PreferencesData.has(uploader.getAuthorizationKey())) {
        PasswordAuthorizationDialog dialog = new PasswordAuthorizationDialog(editor, tr(""Type board password to upload a new sketch""));
        dialog.setLocationRelativeTo(editor);
        dialog.setVisible(true);

        if (dialog.isCancelled()) {
          editor.statusNotice(tr(""Upload cancelled""));
          return false;
        }

        PreferencesData.set(uploader.getAuthorizationKey(), dialog.getPassword());
      }

      List<String> warningsAccumulator = new LinkedList<>();
      try {
        success = uploaderInstance.upload(sketch, uploader, suggestedClassName, usingProgrammer, false, warningsAccumulator);
      } finally {
        if (uploader.requiresAuthorization() && !success) {
          PreferencesData.remove(uploader.getAuthorizationKey());
        }
      }

      for (String warning : warningsAccumulator) {
        System.out.print(tr(""Warning""));
        System.out.print("": "");
        System.out.println(warning);
      }

    } while (uploader.requiresAuthorization() && !success);

    if (!success) {
      String errorMessage = uploader.getFailureMessage();
      if (errorMessage.equals("""")) {
        errorMessage = tr(""An error occurred while uploading the sketch"");
      }
      editor.statusError(errorMessage);
    }

    return success;
  }",iterator
file,"{
    if (sketch.getFolder().exists()) return;

    Base.showWarning(tr(""Sketch Disappeared""),
                     tr(""The sketch folder has disappeared.\n "" +
                       ""Will attempt to re-save in the same location,\n"" +
                       ""but anything besides the code will be lost.""), null);
    try {
      sketch.getFolder().mkdirs();

      for (SketchFile file : sketch.getFiles()) {
        file.save();  // this will force a save
      }
      calcModified();

    } catch (Exception e) {
      Base.showWarning(tr(""Could not re-save sketch""),
                       tr(""Could not properly re-save the sketch. "" +
                         ""You may be in trouble at this point,\n"" +
                         ""and it might be time to copy and paste "" +
                         ""your code to another text editor.""), e);
    }
  }",iterator
file,"{
    for (SketchFile file : sketch.getFiles()) {
      if (file.isModified() && file.fileReadOnly() && file.fileExists()) {
        return true;
      }
    }
    return false;
  }",iterator
i,"{
    this.editor = eddie; // weird name for listener

    if (pieces == null) {
      pieces = new Image[STATUS.length][WHERE.length];
      menuButtons = new Image[STATUS.length];
      for (int i = 0; i < STATUS.length; i++) {
        for (int j = 0; j < WHERE.length; j++) {
          String path = ""tab-"" + STATUS[i] + ""-"" + WHERE[j];
          pieces[i][j] = Theme.getThemeImage(path, this, PIECE_WIDTH,
                                             PIECE_HEIGHT);
        }
        String path = ""tab-"" + STATUS[i] + ""-menu"";
        menuButtons[i] = Theme.getThemeImage(path, this, PIECE_HEIGHT,
                                             PIECE_HEIGHT);
      }
    }

    if (backgroundColor == null) {
      backgroundColor =
        Theme.getColor(""header.bgcolor"");
      textColor[SELECTED] =
        Theme.getColor(""header.text.selected.color"");
      textColor[UNSELECTED] =
        Theme.getColor(""header.text.unselected.color"");
    }

    addMouseListener(new MouseAdapter() {
        public void mousePressed(MouseEvent e) {
          int x = e.getX();
          int y = e.getY();

          if ((x > menuLeft) && (x < menuRight)) {
            popup.show(EditorHeader.this, x, y);

          } else {
            int numTabs = editor.getTabs().size();
            for (int i = 0; i < numTabs; i++) {
              if ((x > tabLeft[i]) && (x < tabRight[i])) {
                editor.selectTab(i);
                repaint();
              }
            }
          }
        }
      });
  }",loop_control
j,"{
    this.editor = eddie; // weird name for listener

    if (pieces == null) {
      pieces = new Image[STATUS.length][WHERE.length];
      menuButtons = new Image[STATUS.length];
      for (int i = 0; i < STATUS.length; i++) {
        for (int j = 0; j < WHERE.length; j++) {
          String path = ""tab-"" + STATUS[i] + ""-"" + WHERE[j];
          pieces[i][j] = Theme.getThemeImage(path, this, PIECE_WIDTH,
                                             PIECE_HEIGHT);
        }
        String path = ""tab-"" + STATUS[i] + ""-menu"";
        menuButtons[i] = Theme.getThemeImage(path, this, PIECE_HEIGHT,
                                             PIECE_HEIGHT);
      }
    }

    if (backgroundColor == null) {
      backgroundColor =
        Theme.getColor(""header.bgcolor"");
      textColor[SELECTED] =
        Theme.getColor(""header.text.selected.color"");
      textColor[UNSELECTED] =
        Theme.getColor(""header.text.unselected.color"");
    }

    addMouseListener(new MouseAdapter() {
        public void mousePressed(MouseEvent e) {
          int x = e.getX();
          int y = e.getY();

          if ((x > menuLeft) && (x < menuRight)) {
            popup.show(EditorHeader.this, x, y);

          } else {
            int numTabs = editor.getTabs().size();
            for (int i = 0; i < numTabs; i++) {
              if ((x > tabLeft[i]) && (x < tabRight[i])) {
                editor.selectTab(i);
                repaint();
              }
            }
          }
        }
      });
  }",loop_control
tab,"{
    if (screen == null) return;

    SketchController sketch = editor.getSketchController();
    if (sketch == null) return;  // ??

    Dimension size = getSize();
    if ((size.width != sizeW) || (size.height != sizeH)) {
      // component has been resized

      if ((size.width > imageW) || (size.height > imageH)) {
        // nix the image and recreate, it's too small
        offscreen = null;

      } else {
        // who cares, just resize
        sizeW = size.width;
        sizeH = size.height;
      }
    }

    if (offscreen == null) {
      sizeW = size.width;
      sizeH = size.height;
      imageW = sizeW;
      imageH = sizeH;
      offscreen = createImage(imageW, imageH);
    }

    Graphics2D g = Theme.setupGraphics2D(offscreen.getGraphics());
    if (font == null) {
      font = Theme.getFont(""header.text.font"");
    }
    g.setFont(font);  // need to set this each time through
    metrics = g.getFontMetrics();
    fontAscent = metrics.getAscent();

    // set the background for the offscreen
    g.setColor(backgroundColor);
    g.fillRect(0, 0, imageW, imageH);

    List<EditorTab> tabs = editor.getTabs();

    int codeCount = tabs.size();
    if ((tabLeft == null) || (tabLeft.length < codeCount)) {
      tabLeft = new int[codeCount];
      tabRight = new int[codeCount];
    }

    int x = scale(6); // offset from left edge of the component
    int i = 0;
    for (EditorTab tab : tabs) {
      SketchFile file = tab.getSketchFile();
      String filename = file.getPrettyName();

      // if modified, add the li'l glyph next to the name
      String text = ""  "" + filename + (file.isModified() ? "" \u00A7"" : ""  "");

      int textWidth = (int)
        font.getStringBounds(text, g.getFontRenderContext()).getWidth();

      int pieceCount = 2 + (textWidth / PIECE_WIDTH);
      int pieceWidth = pieceCount * PIECE_WIDTH;

      int state = (i == editor.getCurrentTabIndex()) ? SELECTED : UNSELECTED;
      g.drawImage(pieces[state][LEFT], x, 0, null);
      x += PIECE_WIDTH;

      int contentLeft = x;
      tabLeft[i] = x;
      for (int j = 0; j < pieceCount; j++) {
        g.drawImage(pieces[state][MIDDLE], x, 0, null);
        x += PIECE_WIDTH;
      }
      tabRight[i] = x;
      int textLeft = contentLeft + (pieceWidth - textWidth) / 2;

      g.setColor(textColor[state]);
      int tabMarginTop = sizeH - TAB_HEIGHT;
      int baseline = tabMarginTop + ((TAB_HEIGHT + fontAscent) / 2) ; 
      g.drawString(text, textLeft, baseline);

      g.drawImage(pieces[state][RIGHT], x, 0, null);
      x += PIECE_WIDTH - 1;  // overlap by 1 pixel
      i++;
    }

    menuLeft = sizeW - (16 + menuButtons[0].getWidth(this));
    menuRight = sizeW - 16;
    // draw the dropdown menu target
    g.drawImage(menuButtons[popup.isVisible() ? SELECTED : UNSELECTED],
                menuLeft, 0, null);

    screen.drawImage(offscreen, 0, 0, null);
  }",iterator
tab,"{
    if (menu != null) {
      menu.removeAll();

    } else {
      menu = new JMenu();
      MenuScroller.setScrollerFor(menu);
      popup = menu.getPopupMenu();
      popup.setLightWeightPopupEnabled(true);
    }
    JMenuItem item;

    menu.add(new JMenuItem(actions.newTab));
    menu.add(new JMenuItem(actions.renameTab));
    menu.add(new JMenuItem(actions.deleteTab));
    menu.addSeparator();
    menu.add(new JMenuItem(actions.prevTab));
    menu.add(new JMenuItem(actions.nextTab));

    Sketch sketch = editor.getSketch();
    if (sketch != null) {
      menu.addSeparator();

      int i = 0;
      for (EditorTab tab : editor.getTabs()) {
        SketchFile file = tab.getSketchFile();
        final int index = i++;
        item = new JMenuItem(file.getPrettyName());
        item.addActionListener((ActionEvent e) -> {
          editor.selectTab(index);
        });
        menu.add(item);
      }
    }
  }",iterator
handler,"{
    Handler consoleHandler = new ConsoleLogger();
    consoleHandler.setLevel(Level.ALL);
    consoleHandler.setFormatter(new LogFormatter(""%1$tl:%1$tM:%1$tS [%4$7s] %2$s: %5$s%n""));

    Logger globalLogger = Logger.getLogger(Logger.GLOBAL_LOGGER_NAME);
    globalLogger.setLevel(consoleHandler.getLevel());

    // Remove default
    Handler[] handlers = globalLogger.getHandlers();
    for(Handler handler : handlers) {
        globalLogger.removeHandler(handler);
    }
    Logger root = Logger.getLogger("""");
    handlers = root.getHandlers();
    for(Handler handler : handlers) {
      root.removeHandler(handler);
    }

    globalLogger.addHandler(consoleHandler);

    Logger.getLogger(""cc.arduino.packages.autocomplete"").setParent(globalLogger);
    Logger.getLogger(""br.com.criativasoft.cpluslibparser"").setParent(globalLogger);
    Logger.getLogger(Base.class.getPackage().getName()).setParent(globalLogger);

  }",iterator
library,"{
    Thread deleteFilesOnShutdownThread = new Thread(DeleteFilesOnShutdown.INSTANCE);
    deleteFilesOnShutdownThread.setName(""DeleteFilesOnShutdown"");
    Runtime.getRuntime().addShutdownHook(deleteFilesOnShutdownThread);

    BaseNoGui.initLogger();

    initLogger();

    BaseNoGui.initPlatform();

    BaseNoGui.getPlatform().init();

    BaseNoGui.initPortableFolder();

    // Look for a possible ""--preferences-file"" parameter and load preferences
    BaseNoGui.initParameters(args);

    CommandlineParser parser = new CommandlineParser(args);
    parser.parseArgumentsPhase1();
    commandLine = !parser.isGuiMode();

    BaseNoGui.checkInstallationFolder();

    // If no path is set, get the default sketchbook folder for this platform
    if (BaseNoGui.getSketchbookPath() == null) {
      File defaultFolder = getDefaultSketchbookFolderOrPromptForIt();
      if (BaseNoGui.getPortableFolder() != null)
        PreferencesData.set(""sketchbook.path"", BaseNoGui.getPortableSketchbookFolder());
      else
        PreferencesData.set(""sketchbook.path"", defaultFolder.getAbsolutePath());
      if (!defaultFolder.exists()) {
        defaultFolder.mkdirs();
      }
    }

    SplashScreenHelper splash;
    if (parser.isGuiMode()) {
      // Setup all notification widgets
      splash = new SplashScreenHelper(SplashScreen.getSplashScreen());
      BaseNoGui.notifier = new GUIUserNotifier(this);

      // Setup the theme coloring fun
      Theme.init();
      System.setProperty(""swing.aatext"", PreferencesData.get(""editor.antialias"", ""true""));

      // Set the look and feel before opening the window
      try {
        BaseNoGui.getPlatform().setLookAndFeel();
      } catch (Exception e) {
        // ignore
      }

      // Use native popups so they don't look so crappy on osx
      JPopupMenu.setDefaultLightWeightPopupEnabled(false);
    } else {
      splash = new SplashScreenHelper(null);
    }

    splash.splashText(tr(""Loading configuration...""));

    BaseNoGui.initVersion();

    // Don't put anything above this line that might make GUI,
    // because the platform has to be inited properly first.

    // Create a location for untitled sketches
    untitledFolder = FileUtils.createTempFolder(""untitled"" + new Random().nextInt(Integer.MAX_VALUE), "".tmp"");
    DeleteFilesOnShutdown.add(untitledFolder);

    splash.splashText(tr(""Initializing packages...""));
    BaseNoGui.initPackages();

    parser.getUploadPort().ifPresent(BaseNoGui::selectSerialPort);

    splash.splashText(tr(""Preparing boards...""));

    if (!isCommandLine()) {
      rebuildBoardsMenu();
      rebuildProgrammerMenu();
    } else {
      TargetBoard lastSelectedBoard = BaseNoGui.getTargetBoard();
      if (lastSelectedBoard != null)
        BaseNoGui.selectBoard(lastSelectedBoard);
    }

    // Setup board-dependent variables.
    onBoardOrPortChange();

    pdeKeywords = new PdeKeywords();
    pdeKeywords.reload();

    final GPGDetachedSignatureVerifier gpgDetachedSignatureVerifier = new GPGDetachedSignatureVerifier();
    contributionInstaller = new ContributionInstaller(BaseNoGui.getPlatform(), gpgDetachedSignatureVerifier);
    libraryInstaller = new LibraryInstaller(BaseNoGui.getPlatform(), gpgDetachedSignatureVerifier);

    parser.parseArgumentsPhase2();

    // Save the preferences. For GUI mode, this happens in the quit
    // handler, but for other modes we should also make sure to save
    // them.
    if (parser.isForceSavePrefs()) {
      PreferencesData.save();
    }

    if (parser.isInstallBoard()) {
      ContributionsIndexer indexer = new ContributionsIndexer(
          BaseNoGui.getSettingsFolder(), BaseNoGui.getHardwareFolder(),
          BaseNoGui.getPlatform(), gpgDetachedSignatureVerifier);
      ProgressListener progressListener = new ConsoleProgressListener();

      contributionInstaller.updateIndex(progressListener);
      indexer.parseIndex();
      indexer.syncWithFilesystem();

      String[] boardToInstallParts = parser.getBoardToInstall().split("":"");

      ContributedPlatform selected = null;
      if (boardToInstallParts.length == 3) {
        Optional<Version> version = VersionHelper.valueOf(boardToInstallParts[2]);
        if (!version.isPresent()) {
          System.out.println(format(tr(""Invalid version {0}""), boardToInstallParts[2]));
          System.exit(1);
        }
        selected = indexer.getIndex().findPlatform(boardToInstallParts[0], boardToInstallParts[1], version.get().toString());
      } else if (boardToInstallParts.length == 2) {
        List<ContributedPlatform> platformsByName = indexer.getIndex().findPlatforms(boardToInstallParts[0], boardToInstallParts[1]);
        Collections.sort(platformsByName, new DownloadableContributionVersionComparator());
        if (!platformsByName.isEmpty()) {
          selected = platformsByName.get(platformsByName.size() - 1);
        }
      }
      if (selected == null) {
        System.out.println(tr(""Selected board is not available""));
        System.exit(1);
      }

      ContributedPlatform installed = indexer.getInstalled(boardToInstallParts[0], boardToInstallParts[1]);

      if (!selected.isBuiltIn()) {
        contributionInstaller.install(selected, progressListener);
      }

      if (installed != null && !installed.isBuiltIn()) {
        contributionInstaller.remove(installed);
      }

      System.exit(0);

    } else if (parser.isInstallLibrary()) {
      BaseNoGui.onBoardOrPortChange();

      ProgressListener progressListener = new ConsoleProgressListener();
      libraryInstaller.updateIndex(progressListener);

      LibrariesIndexer indexer = new LibrariesIndexer(BaseNoGui.getSettingsFolder());
      indexer.parseIndex();
      indexer.setLibrariesFolders(BaseNoGui.getLibrariesFolders());
      indexer.rescanLibraries();

      for (String library : parser.getLibraryToInstall().split("","")) {
        String[] libraryToInstallParts = library.split("":"");

        ContributedLibrary selected = null;
        if (libraryToInstallParts.length == 2) {
          Optional<Version> version = VersionHelper.valueOf(libraryToInstallParts[1]);
          if (!version.isPresent()) {
            System.out.println(format(tr(""Invalid version {0}""), libraryToInstallParts[1]));
            System.exit(1);
          }
          selected = indexer.getIndex().find(libraryToInstallParts[0], version.get().toString());
        } else if (libraryToInstallParts.length == 1) {
          List<ContributedLibrary> librariesByName = indexer.getIndex().find(libraryToInstallParts[0]);
          Collections.sort(librariesByName, new DownloadableContributionVersionComparator());
          if (!librariesByName.isEmpty()) {
            selected = librariesByName.get(librariesByName.size() - 1);
          }
        }
        if (selected == null) {
          System.out.println(tr(""Selected library is not available""));
          System.exit(1);
        }

        Optional<ContributedLibrary> mayInstalled = indexer.getIndex().getInstalled(libraryToInstallParts[0]);
        if (mayInstalled.isPresent() && selected.isIDEBuiltIn()) {
          System.out.println(tr(I18n
              .format(""Library {0} is available as built-in in the IDE.\nRemoving the other version {1} installed in the sketchbook..."",
                      library, mayInstalled.get().getParsedVersion())));
          libraryInstaller.remove(mayInstalled.get(), progressListener);
        } else {
          libraryInstaller.install(selected, progressListener);
        }
      }

      System.exit(0);

    } else if (parser.isVerifyOrUploadMode()) {
      // Set verbosity for command line build
      PreferencesData.setBoolean(""build.verbose"", parser.isDoVerboseBuild());
      PreferencesData.setBoolean(""upload.verbose"", parser.isDoVerboseUpload());

      // Set preserve-temp flag
      PreferencesData.setBoolean(""runtime.preserve.temp.files"", parser.isPreserveTempFiles());

      // Make sure these verbosity preferences are only for the current session
      PreferencesData.setDoSave(false);

      Sketch sketch = null;
      String outputFile = null;

      try {
        // Build
        splash.splashText(tr(""Verifying...""));

        File sketchFile = BaseNoGui.absoluteFile(parser.getFilenames().get(0));
        sketch = new Sketch(sketchFile);

        outputFile = new Compiler(sketch).build(progress -> {}, false);
      } catch (Exception e) {
        // Error during build
        e.printStackTrace();
        System.exit(1);
      }

      if (parser.isUploadMode()) {
        // Upload
        splash.splashText(tr(""Uploading...""));

        try {
          List<String> warnings = new ArrayList<>();
          UploaderUtils uploader = new UploaderUtils();
          boolean res = uploader.upload(sketch, null, outputFile,
                                        parser.isDoUseProgrammer(),
                                        parser.isNoUploadPort(), warnings);
          for (String warning : warnings) {
            System.out.println(tr(""Warning"") + "": "" + warning);
          }
          if (!res) {
            throw new Exception();
          }
        } catch (Exception e) {
          // Error during upload
          System.out.flush();
          System.err.flush();
          System.err
              .println(tr(""An error occurred while uploading the sketch""));
          System.exit(1);
        }
      }

      // No errors exit gracefully
      System.exit(0);
    } else if (parser.isGuiMode()) {
      splash.splashText(tr(""Starting...""));

      for (String path : parser.getFilenames()) {
        // Correctly resolve relative paths
        File file = absoluteFile(path);

        // Fix a problem with systems that use a non-ASCII languages. Paths are
        // being passed in with 8.3 syntax, which makes the sketch loader code
        // unhappy, since the sketch folder naming doesn't match up correctly.
        // http://dev.processing.org/bugs/show_bug.cgi?id=1089
        if (OSUtils.isWindows()) {
          try {
            file = file.getCanonicalFile();
          } catch (IOException e) {
            e.printStackTrace();
          }
        }

        if (!parser.isForceSavePrefs())
          PreferencesData.setDoSave(true);
        if (handleOpen(file, retrieveSketchLocation("".default""), false) == null) {
          String mess = format(tr(""Failed to open sketch: \""{0}\""""), path);
          // Open failure is fatal in upload/verify mode
          if (parser.isVerifyOrUploadMode())
            showError(null, mess, 2);
          else
            showWarning(null, mess, null);
        }
      }

      installKeyboardInputMap();

      // Check if there were previously opened sketches to be restored
      restoreSketches();

      // Create a new empty window (will be replaced with any files to be opened)
      if (editors.isEmpty()) {
        handleNew();
      }

      new Thread(new BuiltInCoreIsNewerCheck(this)).start();

      // Check for boards which need an additional core
      new Thread(new NewBoardListener(this)).start();

      // Check for updates
      if (PreferencesData.getBoolean(""update.check"")) {
        new UpdateCheck(this);

        contributionsSelfCheck = new ContributionsSelfCheck(this, new UpdatableBoardsLibsFakeURLsHandler(this), contributionInstaller, libraryInstaller);
        new Timer(false).schedule(contributionsSelfCheck, Constants.BOARDS_LIBS_UPDATABLE_CHECK_START_PERIOD);
      }

    } else if (parser.isNoOpMode()) {
      // Do nothing (intended for only changing preferences)
      System.exit(0);
    } else if (parser.isGetPrefMode()) {
      BaseNoGui.dumpPrefs(parser);
    } else if (parser.isVersionMode()) {
      System.out.println(""Arduino: "" + BaseNoGui.VERSION_NAME_LONG);
      System.exit(0);
    }
  }",iterator
path,"{
    Thread deleteFilesOnShutdownThread = new Thread(DeleteFilesOnShutdown.INSTANCE);
    deleteFilesOnShutdownThread.setName(""DeleteFilesOnShutdown"");
    Runtime.getRuntime().addShutdownHook(deleteFilesOnShutdownThread);

    BaseNoGui.initLogger();

    initLogger();

    BaseNoGui.initPlatform();

    BaseNoGui.getPlatform().init();

    BaseNoGui.initPortableFolder();

    // Look for a possible ""--preferences-file"" parameter and load preferences
    BaseNoGui.initParameters(args);

    CommandlineParser parser = new CommandlineParser(args);
    parser.parseArgumentsPhase1();
    commandLine = !parser.isGuiMode();

    BaseNoGui.checkInstallationFolder();

    // If no path is set, get the default sketchbook folder for this platform
    if (BaseNoGui.getSketchbookPath() == null) {
      File defaultFolder = getDefaultSketchbookFolderOrPromptForIt();
      if (BaseNoGui.getPortableFolder() != null)
        PreferencesData.set(""sketchbook.path"", BaseNoGui.getPortableSketchbookFolder());
      else
        PreferencesData.set(""sketchbook.path"", defaultFolder.getAbsolutePath());
      if (!defaultFolder.exists()) {
        defaultFolder.mkdirs();
      }
    }

    SplashScreenHelper splash;
    if (parser.isGuiMode()) {
      // Setup all notification widgets
      splash = new SplashScreenHelper(SplashScreen.getSplashScreen());
      BaseNoGui.notifier = new GUIUserNotifier(this);

      // Setup the theme coloring fun
      Theme.init();
      System.setProperty(""swing.aatext"", PreferencesData.get(""editor.antialias"", ""true""));

      // Set the look and feel before opening the window
      try {
        BaseNoGui.getPlatform().setLookAndFeel();
      } catch (Exception e) {
        // ignore
      }

      // Use native popups so they don't look so crappy on osx
      JPopupMenu.setDefaultLightWeightPopupEnabled(false);
    } else {
      splash = new SplashScreenHelper(null);
    }

    splash.splashText(tr(""Loading configuration...""));

    BaseNoGui.initVersion();

    // Don't put anything above this line that might make GUI,
    // because the platform has to be inited properly first.

    // Create a location for untitled sketches
    untitledFolder = FileUtils.createTempFolder(""untitled"" + new Random().nextInt(Integer.MAX_VALUE), "".tmp"");
    DeleteFilesOnShutdown.add(untitledFolder);

    splash.splashText(tr(""Initializing packages...""));
    BaseNoGui.initPackages();

    parser.getUploadPort().ifPresent(BaseNoGui::selectSerialPort);

    splash.splashText(tr(""Preparing boards...""));

    if (!isCommandLine()) {
      rebuildBoardsMenu();
      rebuildProgrammerMenu();
    } else {
      TargetBoard lastSelectedBoard = BaseNoGui.getTargetBoard();
      if (lastSelectedBoard != null)
        BaseNoGui.selectBoard(lastSelectedBoard);
    }

    // Setup board-dependent variables.
    onBoardOrPortChange();

    pdeKeywords = new PdeKeywords();
    pdeKeywords.reload();

    final GPGDetachedSignatureVerifier gpgDetachedSignatureVerifier = new GPGDetachedSignatureVerifier();
    contributionInstaller = new ContributionInstaller(BaseNoGui.getPlatform(), gpgDetachedSignatureVerifier);
    libraryInstaller = new LibraryInstaller(BaseNoGui.getPlatform(), gpgDetachedSignatureVerifier);

    parser.parseArgumentsPhase2();

    // Save the preferences. For GUI mode, this happens in the quit
    // handler, but for other modes we should also make sure to save
    // them.
    if (parser.isForceSavePrefs()) {
      PreferencesData.save();
    }

    if (parser.isInstallBoard()) {
      ContributionsIndexer indexer = new ContributionsIndexer(
          BaseNoGui.getSettingsFolder(), BaseNoGui.getHardwareFolder(),
          BaseNoGui.getPlatform(), gpgDetachedSignatureVerifier);
      ProgressListener progressListener = new ConsoleProgressListener();

      contributionInstaller.updateIndex(progressListener);
      indexer.parseIndex();
      indexer.syncWithFilesystem();

      String[] boardToInstallParts = parser.getBoardToInstall().split("":"");

      ContributedPlatform selected = null;
      if (boardToInstallParts.length == 3) {
        Optional<Version> version = VersionHelper.valueOf(boardToInstallParts[2]);
        if (!version.isPresent()) {
          System.out.println(format(tr(""Invalid version {0}""), boardToInstallParts[2]));
          System.exit(1);
        }
        selected = indexer.getIndex().findPlatform(boardToInstallParts[0], boardToInstallParts[1], version.get().toString());
      } else if (boardToInstallParts.length == 2) {
        List<ContributedPlatform> platformsByName = indexer.getIndex().findPlatforms(boardToInstallParts[0], boardToInstallParts[1]);
        Collections.sort(platformsByName, new DownloadableContributionVersionComparator());
        if (!platformsByName.isEmpty()) {
          selected = platformsByName.get(platformsByName.size() - 1);
        }
      }
      if (selected == null) {
        System.out.println(tr(""Selected board is not available""));
        System.exit(1);
      }

      ContributedPlatform installed = indexer.getInstalled(boardToInstallParts[0], boardToInstallParts[1]);

      if (!selected.isBuiltIn()) {
        contributionInstaller.install(selected, progressListener);
      }

      if (installed != null && !installed.isBuiltIn()) {
        contributionInstaller.remove(installed);
      }

      System.exit(0);

    } else if (parser.isInstallLibrary()) {
      BaseNoGui.onBoardOrPortChange();

      ProgressListener progressListener = new ConsoleProgressListener();
      libraryInstaller.updateIndex(progressListener);

      LibrariesIndexer indexer = new LibrariesIndexer(BaseNoGui.getSettingsFolder());
      indexer.parseIndex();
      indexer.setLibrariesFolders(BaseNoGui.getLibrariesFolders());
      indexer.rescanLibraries();

      for (String library : parser.getLibraryToInstall().split("","")) {
        String[] libraryToInstallParts = library.split("":"");

        ContributedLibrary selected = null;
        if (libraryToInstallParts.length == 2) {
          Optional<Version> version = VersionHelper.valueOf(libraryToInstallParts[1]);
          if (!version.isPresent()) {
            System.out.println(format(tr(""Invalid version {0}""), libraryToInstallParts[1]));
            System.exit(1);
          }
          selected = indexer.getIndex().find(libraryToInstallParts[0], version.get().toString());
        } else if (libraryToInstallParts.length == 1) {
          List<ContributedLibrary> librariesByName = indexer.getIndex().find(libraryToInstallParts[0]);
          Collections.sort(librariesByName, new DownloadableContributionVersionComparator());
          if (!librariesByName.isEmpty()) {
            selected = librariesByName.get(librariesByName.size() - 1);
          }
        }
        if (selected == null) {
          System.out.println(tr(""Selected library is not available""));
          System.exit(1);
        }

        Optional<ContributedLibrary> mayInstalled = indexer.getIndex().getInstalled(libraryToInstallParts[0]);
        if (mayInstalled.isPresent() && selected.isIDEBuiltIn()) {
          System.out.println(tr(I18n
              .format(""Library {0} is available as built-in in the IDE.\nRemoving the other version {1} installed in the sketchbook..."",
                      library, mayInstalled.get().getParsedVersion())));
          libraryInstaller.remove(mayInstalled.get(), progressListener);
        } else {
          libraryInstaller.install(selected, progressListener);
        }
      }

      System.exit(0);

    } else if (parser.isVerifyOrUploadMode()) {
      // Set verbosity for command line build
      PreferencesData.setBoolean(""build.verbose"", parser.isDoVerboseBuild());
      PreferencesData.setBoolean(""upload.verbose"", parser.isDoVerboseUpload());

      // Set preserve-temp flag
      PreferencesData.setBoolean(""runtime.preserve.temp.files"", parser.isPreserveTempFiles());

      // Make sure these verbosity preferences are only for the current session
      PreferencesData.setDoSave(false);

      Sketch sketch = null;
      String outputFile = null;

      try {
        // Build
        splash.splashText(tr(""Verifying...""));

        File sketchFile = BaseNoGui.absoluteFile(parser.getFilenames().get(0));
        sketch = new Sketch(sketchFile);

        outputFile = new Compiler(sketch).build(progress -> {}, false);
      } catch (Exception e) {
        // Error during build
        e.printStackTrace();
        System.exit(1);
      }

      if (parser.isUploadMode()) {
        // Upload
        splash.splashText(tr(""Uploading...""));

        try {
          List<String> warnings = new ArrayList<>();
          UploaderUtils uploader = new UploaderUtils();
          boolean res = uploader.upload(sketch, null, outputFile,
                                        parser.isDoUseProgrammer(),
                                        parser.isNoUploadPort(), warnings);
          for (String warning : warnings) {
            System.out.println(tr(""Warning"") + "": "" + warning);
          }
          if (!res) {
            throw new Exception();
          }
        } catch (Exception e) {
          // Error during upload
          System.out.flush();
          System.err.flush();
          System.err
              .println(tr(""An error occurred while uploading the sketch""));
          System.exit(1);
        }
      }

      // No errors exit gracefully
      System.exit(0);
    } else if (parser.isGuiMode()) {
      splash.splashText(tr(""Starting...""));

      for (String path : parser.getFilenames()) {
        // Correctly resolve relative paths
        File file = absoluteFile(path);

        // Fix a problem with systems that use a non-ASCII languages. Paths are
        // being passed in with 8.3 syntax, which makes the sketch loader code
        // unhappy, since the sketch folder naming doesn't match up correctly.
        // http://dev.processing.org/bugs/show_bug.cgi?id=1089
        if (OSUtils.isWindows()) {
          try {
            file = file.getCanonicalFile();
          } catch (IOException e) {
            e.printStackTrace();
          }
        }

        if (!parser.isForceSavePrefs())
          PreferencesData.setDoSave(true);
        if (handleOpen(file, retrieveSketchLocation("".default""), false) == null) {
          String mess = format(tr(""Failed to open sketch: \""{0}\""""), path);
          // Open failure is fatal in upload/verify mode
          if (parser.isVerifyOrUploadMode())
            showError(null, mess, 2);
          else
            showWarning(null, mess, null);
        }
      }

      installKeyboardInputMap();

      // Check if there were previously opened sketches to be restored
      restoreSketches();

      // Create a new empty window (will be replaced with any files to be opened)
      if (editors.isEmpty()) {
        handleNew();
      }

      new Thread(new BuiltInCoreIsNewerCheck(this)).start();

      // Check for boards which need an additional core
      new Thread(new NewBoardListener(this)).start();

      // Check for updates
      if (PreferencesData.getBoolean(""update.check"")) {
        new UpdateCheck(this);

        contributionsSelfCheck = new ContributionsSelfCheck(this, new UpdatableBoardsLibsFakeURLsHandler(this), contributionInstaller, libraryInstaller);
        new Timer(false).schedule(contributionsSelfCheck, Constants.BOARDS_LIBS_UPDATABLE_CHECK_START_PERIOD);
      }

    } else if (parser.isNoOpMode()) {
      // Do nothing (intended for only changing preferences)
      System.exit(0);
    } else if (parser.isGetPrefMode()) {
      BaseNoGui.dumpPrefs(parser);
    } else if (parser.isVersionMode()) {
      System.out.println(""Arduino: "" + BaseNoGui.VERSION_NAME_LONG);
      System.exit(0);
    }
  }",iterator
warning,"{
    Thread deleteFilesOnShutdownThread = new Thread(DeleteFilesOnShutdown.INSTANCE);
    deleteFilesOnShutdownThread.setName(""DeleteFilesOnShutdown"");
    Runtime.getRuntime().addShutdownHook(deleteFilesOnShutdownThread);

    BaseNoGui.initLogger();

    initLogger();

    BaseNoGui.initPlatform();

    BaseNoGui.getPlatform().init();

    BaseNoGui.initPortableFolder();

    // Look for a possible ""--preferences-file"" parameter and load preferences
    BaseNoGui.initParameters(args);

    CommandlineParser parser = new CommandlineParser(args);
    parser.parseArgumentsPhase1();
    commandLine = !parser.isGuiMode();

    BaseNoGui.checkInstallationFolder();

    // If no path is set, get the default sketchbook folder for this platform
    if (BaseNoGui.getSketchbookPath() == null) {
      File defaultFolder = getDefaultSketchbookFolderOrPromptForIt();
      if (BaseNoGui.getPortableFolder() != null)
        PreferencesData.set(""sketchbook.path"", BaseNoGui.getPortableSketchbookFolder());
      else
        PreferencesData.set(""sketchbook.path"", defaultFolder.getAbsolutePath());
      if (!defaultFolder.exists()) {
        defaultFolder.mkdirs();
      }
    }

    SplashScreenHelper splash;
    if (parser.isGuiMode()) {
      // Setup all notification widgets
      splash = new SplashScreenHelper(SplashScreen.getSplashScreen());
      BaseNoGui.notifier = new GUIUserNotifier(this);

      // Setup the theme coloring fun
      Theme.init();
      System.setProperty(""swing.aatext"", PreferencesData.get(""editor.antialias"", ""true""));

      // Set the look and feel before opening the window
      try {
        BaseNoGui.getPlatform().setLookAndFeel();
      } catch (Exception e) {
        // ignore
      }

      // Use native popups so they don't look so crappy on osx
      JPopupMenu.setDefaultLightWeightPopupEnabled(false);
    } else {
      splash = new SplashScreenHelper(null);
    }

    splash.splashText(tr(""Loading configuration...""));

    BaseNoGui.initVersion();

    // Don't put anything above this line that might make GUI,
    // because the platform has to be inited properly first.

    // Create a location for untitled sketches
    untitledFolder = FileUtils.createTempFolder(""untitled"" + new Random().nextInt(Integer.MAX_VALUE), "".tmp"");
    DeleteFilesOnShutdown.add(untitledFolder);

    splash.splashText(tr(""Initializing packages...""));
    BaseNoGui.initPackages();

    parser.getUploadPort().ifPresent(BaseNoGui::selectSerialPort);

    splash.splashText(tr(""Preparing boards...""));

    if (!isCommandLine()) {
      rebuildBoardsMenu();
      rebuildProgrammerMenu();
    } else {
      TargetBoard lastSelectedBoard = BaseNoGui.getTargetBoard();
      if (lastSelectedBoard != null)
        BaseNoGui.selectBoard(lastSelectedBoard);
    }

    // Setup board-dependent variables.
    onBoardOrPortChange();

    pdeKeywords = new PdeKeywords();
    pdeKeywords.reload();

    final GPGDetachedSignatureVerifier gpgDetachedSignatureVerifier = new GPGDetachedSignatureVerifier();
    contributionInstaller = new ContributionInstaller(BaseNoGui.getPlatform(), gpgDetachedSignatureVerifier);
    libraryInstaller = new LibraryInstaller(BaseNoGui.getPlatform(), gpgDetachedSignatureVerifier);

    parser.parseArgumentsPhase2();

    // Save the preferences. For GUI mode, this happens in the quit
    // handler, but for other modes we should also make sure to save
    // them.
    if (parser.isForceSavePrefs()) {
      PreferencesData.save();
    }

    if (parser.isInstallBoard()) {
      ContributionsIndexer indexer = new ContributionsIndexer(
          BaseNoGui.getSettingsFolder(), BaseNoGui.getHardwareFolder(),
          BaseNoGui.getPlatform(), gpgDetachedSignatureVerifier);
      ProgressListener progressListener = new ConsoleProgressListener();

      contributionInstaller.updateIndex(progressListener);
      indexer.parseIndex();
      indexer.syncWithFilesystem();

      String[] boardToInstallParts = parser.getBoardToInstall().split("":"");

      ContributedPlatform selected = null;
      if (boardToInstallParts.length == 3) {
        Optional<Version> version = VersionHelper.valueOf(boardToInstallParts[2]);
        if (!version.isPresent()) {
          System.out.println(format(tr(""Invalid version {0}""), boardToInstallParts[2]));
          System.exit(1);
        }
        selected = indexer.getIndex().findPlatform(boardToInstallParts[0], boardToInstallParts[1], version.get().toString());
      } else if (boardToInstallParts.length == 2) {
        List<ContributedPlatform> platformsByName = indexer.getIndex().findPlatforms(boardToInstallParts[0], boardToInstallParts[1]);
        Collections.sort(platformsByName, new DownloadableContributionVersionComparator());
        if (!platformsByName.isEmpty()) {
          selected = platformsByName.get(platformsByName.size() - 1);
        }
      }
      if (selected == null) {
        System.out.println(tr(""Selected board is not available""));
        System.exit(1);
      }

      ContributedPlatform installed = indexer.getInstalled(boardToInstallParts[0], boardToInstallParts[1]);

      if (!selected.isBuiltIn()) {
        contributionInstaller.install(selected, progressListener);
      }

      if (installed != null && !installed.isBuiltIn()) {
        contributionInstaller.remove(installed);
      }

      System.exit(0);

    } else if (parser.isInstallLibrary()) {
      BaseNoGui.onBoardOrPortChange();

      ProgressListener progressListener = new ConsoleProgressListener();
      libraryInstaller.updateIndex(progressListener);

      LibrariesIndexer indexer = new LibrariesIndexer(BaseNoGui.getSettingsFolder());
      indexer.parseIndex();
      indexer.setLibrariesFolders(BaseNoGui.getLibrariesFolders());
      indexer.rescanLibraries();

      for (String library : parser.getLibraryToInstall().split("","")) {
        String[] libraryToInstallParts = library.split("":"");

        ContributedLibrary selected = null;
        if (libraryToInstallParts.length == 2) {
          Optional<Version> version = VersionHelper.valueOf(libraryToInstallParts[1]);
          if (!version.isPresent()) {
            System.out.println(format(tr(""Invalid version {0}""), libraryToInstallParts[1]));
            System.exit(1);
          }
          selected = indexer.getIndex().find(libraryToInstallParts[0], version.get().toString());
        } else if (libraryToInstallParts.length == 1) {
          List<ContributedLibrary> librariesByName = indexer.getIndex().find(libraryToInstallParts[0]);
          Collections.sort(librariesByName, new DownloadableContributionVersionComparator());
          if (!librariesByName.isEmpty()) {
            selected = librariesByName.get(librariesByName.size() - 1);
          }
        }
        if (selected == null) {
          System.out.println(tr(""Selected library is not available""));
          System.exit(1);
        }

        Optional<ContributedLibrary> mayInstalled = indexer.getIndex().getInstalled(libraryToInstallParts[0]);
        if (mayInstalled.isPresent() && selected.isIDEBuiltIn()) {
          System.out.println(tr(I18n
              .format(""Library {0} is available as built-in in the IDE.\nRemoving the other version {1} installed in the sketchbook..."",
                      library, mayInstalled.get().getParsedVersion())));
          libraryInstaller.remove(mayInstalled.get(), progressListener);
        } else {
          libraryInstaller.install(selected, progressListener);
        }
      }

      System.exit(0);

    } else if (parser.isVerifyOrUploadMode()) {
      // Set verbosity for command line build
      PreferencesData.setBoolean(""build.verbose"", parser.isDoVerboseBuild());
      PreferencesData.setBoolean(""upload.verbose"", parser.isDoVerboseUpload());

      // Set preserve-temp flag
      PreferencesData.setBoolean(""runtime.preserve.temp.files"", parser.isPreserveTempFiles());

      // Make sure these verbosity preferences are only for the current session
      PreferencesData.setDoSave(false);

      Sketch sketch = null;
      String outputFile = null;

      try {
        // Build
        splash.splashText(tr(""Verifying...""));

        File sketchFile = BaseNoGui.absoluteFile(parser.getFilenames().get(0));
        sketch = new Sketch(sketchFile);

        outputFile = new Compiler(sketch).build(progress -> {}, false);
      } catch (Exception e) {
        // Error during build
        e.printStackTrace();
        System.exit(1);
      }

      if (parser.isUploadMode()) {
        // Upload
        splash.splashText(tr(""Uploading...""));

        try {
          List<String> warnings = new ArrayList<>();
          UploaderUtils uploader = new UploaderUtils();
          boolean res = uploader.upload(sketch, null, outputFile,
                                        parser.isDoUseProgrammer(),
                                        parser.isNoUploadPort(), warnings);
          for (String warning : warnings) {
            System.out.println(tr(""Warning"") + "": "" + warning);
          }
          if (!res) {
            throw new Exception();
          }
        } catch (Exception e) {
          // Error during upload
          System.out.flush();
          System.err.flush();
          System.err
              .println(tr(""An error occurred while uploading the sketch""));
          System.exit(1);
        }
      }

      // No errors exit gracefully
      System.exit(0);
    } else if (parser.isGuiMode()) {
      splash.splashText(tr(""Starting...""));

      for (String path : parser.getFilenames()) {
        // Correctly resolve relative paths
        File file = absoluteFile(path);

        // Fix a problem with systems that use a non-ASCII languages. Paths are
        // being passed in with 8.3 syntax, which makes the sketch loader code
        // unhappy, since the sketch folder naming doesn't match up correctly.
        // http://dev.processing.org/bugs/show_bug.cgi?id=1089
        if (OSUtils.isWindows()) {
          try {
            file = file.getCanonicalFile();
          } catch (IOException e) {
            e.printStackTrace();
          }
        }

        if (!parser.isForceSavePrefs())
          PreferencesData.setDoSave(true);
        if (handleOpen(file, retrieveSketchLocation("".default""), false) == null) {
          String mess = format(tr(""Failed to open sketch: \""{0}\""""), path);
          // Open failure is fatal in upload/verify mode
          if (parser.isVerifyOrUploadMode())
            showError(null, mess, 2);
          else
            showWarning(null, mess, null);
        }
      }

      installKeyboardInputMap();

      // Check if there were previously opened sketches to be restored
      restoreSketches();

      // Create a new empty window (will be replaced with any files to be opened)
      if (editors.isEmpty()) {
        handleNew();
      }

      new Thread(new BuiltInCoreIsNewerCheck(this)).start();

      // Check for boards which need an additional core
      new Thread(new NewBoardListener(this)).start();

      // Check for updates
      if (PreferencesData.getBoolean(""update.check"")) {
        new UpdateCheck(this);

        contributionsSelfCheck = new ContributionsSelfCheck(this, new UpdatableBoardsLibsFakeURLsHandler(this), contributionInstaller, libraryInstaller);
        new Timer(false).schedule(contributionsSelfCheck, Constants.BOARDS_LIBS_UPDATABLE_CHECK_START_PERIOD);
      }

    } else if (parser.isNoOpMode()) {
      // Do nothing (intended for only changing preferences)
      System.exit(0);
    } else if (parser.isGetPrefMode()) {
      BaseNoGui.dumpPrefs(parser);
    } else if (parser.isVersionMode()) {
      System.out.println(""Arduino: "" + BaseNoGui.VERSION_NAME_LONG);
      System.exit(0);
    }
  }",iterator
i,"{
    // Iterate through all sketches that were open last time p5 was running.
    // If !windowPositionValid, then ignore the coordinates found for each.

    // Save the sketch path and window placement for each open sketch
    int count = PreferencesData.getInteger(""last.sketch.count"");
    int opened = 0;
    for (int i = count - 1; i >= 0; i--) {
      String path = PreferencesData.get(""last.sketch"" + i + "".path"");
      if (path == null) {
        continue;
      }
      if (BaseNoGui.getPortableFolder() != null && !new File(path).isAbsolute()) {
        File absolute = new File(BaseNoGui.getPortableFolder(), path);
        try {
          path = absolute.getCanonicalPath();
        } catch (IOException e) {
          // path unchanged.
        }
      }
      int[] location = retrieveSketchLocation("""" + i);
      // If file did not exist, null will be returned for the Editor
      if (handleOpen(new File(path), location, nextEditorLocation(), false, false) != null) {
        opened++;
      }
    }
    return (opened > 0);
  }",loop_control
editor,"{

    // If there is only one sketch opened save his position as default
    if (editors.size() == 1) {
      storeSketchLocation(editors.get(0), "".default"");
    }

    // Save the sketch path and window placement for each open sketch
    String untitledPath = untitledFolder.getAbsolutePath();
    List<Editor> reversedEditors = new LinkedList<>(editors);
    Collections.reverse(reversedEditors);
    int index = 0;
    for (Editor editor : reversedEditors) {
      Sketch sketch = editor.getSketch();
      String path = sketch.getMainFilePath();
      // Skip untitled sketches if they do not contains changes.
      if (path.startsWith(untitledPath) && !sketch.isModified()) {
        continue;
      }
      storeSketchLocation(editor, """" + index);
      index++;
    }
    PreferencesData.setInteger(""last.sketch.count"", index);
  }",iterator
handler,"{
    Handler consoleHandler = new ConsoleLogger();
    consoleHandler.setLevel(Level.ALL);
    consoleHandler.setFormatter(new LogFormatter(""%1$tl:%1$tM:%1$tS [%4$7s] %2$s: %5$s%n""));

    Logger globalLogger = Logger.getLogger(Logger.GLOBAL_LOGGER_NAME);
    globalLogger.setLevel(consoleHandler.getLevel());

    // Remove default
    Handler[] handlers = globalLogger.getHandlers();
    for(Handler handler : handlers) {
        globalLogger.removeHandler(handler);
    }
    Logger root = Logger.getLogger("""");
    handlers = root.getHandlers();
    for(Handler handler : handlers) {
      root.removeHandler(handler);
    }

    globalLogger.addHandler(consoleHandler);

    Logger.getLogger(""cc.arduino.packages.autocomplete"").setParent(globalLogger);
    Logger.getLogger(""br.com.criativasoft.cpluslibparser"").setParent(globalLogger);
    Logger.getLogger(Base.class.getPackage().getName()).setParent(globalLogger);

  }",iterator
library,"{
    Thread deleteFilesOnShutdownThread = new Thread(DeleteFilesOnShutdown.INSTANCE);
    deleteFilesOnShutdownThread.setName(""DeleteFilesOnShutdown"");
    Runtime.getRuntime().addShutdownHook(deleteFilesOnShutdownThread);

    BaseNoGui.initLogger();

    initLogger();

    BaseNoGui.initPlatform();

    BaseNoGui.getPlatform().init();

    BaseNoGui.initPortableFolder();

    // Look for a possible ""--preferences-file"" parameter and load preferences
    BaseNoGui.initParameters(args);

    CommandlineParser parser = new CommandlineParser(args);
    parser.parseArgumentsPhase1();
    commandLine = !parser.isGuiMode();

    BaseNoGui.checkInstallationFolder();

    // If no path is set, get the default sketchbook folder for this platform
    if (BaseNoGui.getSketchbookPath() == null) {
      File defaultFolder = getDefaultSketchbookFolderOrPromptForIt();
      if (BaseNoGui.getPortableFolder() != null)
        PreferencesData.set(""sketchbook.path"", BaseNoGui.getPortableSketchbookFolder());
      else
        PreferencesData.set(""sketchbook.path"", defaultFolder.getAbsolutePath());
      if (!defaultFolder.exists()) {
        defaultFolder.mkdirs();
      }
    }

    SplashScreenHelper splash;
    if (parser.isGuiMode()) {
      // Setup all notification widgets
      splash = new SplashScreenHelper(SplashScreen.getSplashScreen());
      BaseNoGui.notifier = new GUIUserNotifier(this);

      // Setup the theme coloring fun
      Theme.init();
      System.setProperty(""swing.aatext"", PreferencesData.get(""editor.antialias"", ""true""));

      // Set the look and feel before opening the window
      try {
        BaseNoGui.getPlatform().setLookAndFeel();
      } catch (Exception e) {
        // ignore
      }

      // Use native popups so they don't look so crappy on osx
      JPopupMenu.setDefaultLightWeightPopupEnabled(false);
    } else {
      splash = new SplashScreenHelper(null);
    }

    splash.splashText(tr(""Loading configuration...""));

    BaseNoGui.initVersion();

    // Don't put anything above this line that might make GUI,
    // because the platform has to be inited properly first.

    // Create a location for untitled sketches
    untitledFolder = FileUtils.createTempFolder(""untitled"" + new Random().nextInt(Integer.MAX_VALUE), "".tmp"");
    DeleteFilesOnShutdown.add(untitledFolder);

    splash.splashText(tr(""Initializing packages...""));
    BaseNoGui.initPackages();

    parser.getUploadPort().ifPresent(BaseNoGui::selectSerialPort);

    splash.splashText(tr(""Preparing boards...""));

    if (!isCommandLine()) {
      rebuildBoardsMenu();
      rebuildProgrammerMenu();
    } else {
      TargetBoard lastSelectedBoard = BaseNoGui.getTargetBoard();
      if (lastSelectedBoard != null)
        BaseNoGui.selectBoard(lastSelectedBoard);
    }

    // Setup board-dependent variables.
    onBoardOrPortChange();

    pdeKeywords = new PdeKeywords();
    pdeKeywords.reload();

    final GPGDetachedSignatureVerifier gpgDetachedSignatureVerifier = new GPGDetachedSignatureVerifier();
    contributionInstaller = new ContributionInstaller(BaseNoGui.getPlatform(), gpgDetachedSignatureVerifier);
    libraryInstaller = new LibraryInstaller(BaseNoGui.getPlatform(), gpgDetachedSignatureVerifier);

    parser.parseArgumentsPhase2();

    // Save the preferences. For GUI mode, this happens in the quit
    // handler, but for other modes we should also make sure to save
    // them.
    if (parser.isForceSavePrefs()) {
      PreferencesData.save();
    }

    if (parser.isInstallBoard()) {
      ContributionsIndexer indexer = new ContributionsIndexer(
          BaseNoGui.getSettingsFolder(), BaseNoGui.getHardwareFolder(),
          BaseNoGui.getPlatform(), gpgDetachedSignatureVerifier);
      ProgressListener progressListener = new ConsoleProgressListener();

      contributionInstaller.updateIndex(progressListener);
      indexer.parseIndex();
      indexer.syncWithFilesystem();

      String[] boardToInstallParts = parser.getBoardToInstall().split("":"");

      ContributedPlatform selected = null;
      if (boardToInstallParts.length == 3) {
        Optional<Version> version = VersionHelper.valueOf(boardToInstallParts[2]);
        if (!version.isPresent()) {
          System.out.println(format(tr(""Invalid version {0}""), boardToInstallParts[2]));
          System.exit(1);
        }
        selected = indexer.getIndex().findPlatform(boardToInstallParts[0], boardToInstallParts[1], version.get().toString());
      } else if (boardToInstallParts.length == 2) {
        List<ContributedPlatform> platformsByName = indexer.getIndex().findPlatforms(boardToInstallParts[0], boardToInstallParts[1]);
        Collections.sort(platformsByName, new DownloadableContributionVersionComparator());
        if (!platformsByName.isEmpty()) {
          selected = platformsByName.get(platformsByName.size() - 1);
        }
      }
      if (selected == null) {
        System.out.println(tr(""Selected board is not available""));
        System.exit(1);
      }

      ContributedPlatform installed = indexer.getInstalled(boardToInstallParts[0], boardToInstallParts[1]);

      if (!selected.isBuiltIn()) {
        contributionInstaller.install(selected, progressListener);
      }

      if (installed != null && !installed.isBuiltIn()) {
        contributionInstaller.remove(installed);
      }

      System.exit(0);

    } else if (parser.isInstallLibrary()) {
      BaseNoGui.onBoardOrPortChange();

      ProgressListener progressListener = new ConsoleProgressListener();
      libraryInstaller.updateIndex(progressListener);

      LibrariesIndexer indexer = new LibrariesIndexer(BaseNoGui.getSettingsFolder());
      indexer.parseIndex();
      indexer.setLibrariesFolders(BaseNoGui.getLibrariesFolders());
      indexer.rescanLibraries();

      for (String library : parser.getLibraryToInstall().split("","")) {
        String[] libraryToInstallParts = library.split("":"");

        ContributedLibrary selected = null;
        if (libraryToInstallParts.length == 2) {
          Optional<Version> version = VersionHelper.valueOf(libraryToInstallParts[1]);
          if (!version.isPresent()) {
            System.out.println(format(tr(""Invalid version {0}""), libraryToInstallParts[1]));
            System.exit(1);
          }
          selected = indexer.getIndex().find(libraryToInstallParts[0], version.get().toString());
        } else if (libraryToInstallParts.length == 1) {
          List<ContributedLibrary> librariesByName = indexer.getIndex().find(libraryToInstallParts[0]);
          Collections.sort(librariesByName, new DownloadableContributionVersionComparator());
          if (!librariesByName.isEmpty()) {
            selected = librariesByName.get(librariesByName.size() - 1);
          }
        }
        if (selected == null) {
          System.out.println(tr(""Selected library is not available""));
          System.exit(1);
        }

        Optional<ContributedLibrary> mayInstalled = indexer.getIndex().getInstalled(libraryToInstallParts[0]);
        if (mayInstalled.isPresent() && selected.isIDEBuiltIn()) {
          System.out.println(tr(I18n
              .format(""Library {0} is available as built-in in the IDE.\nRemoving the other version {1} installed in the sketchbook..."",
                      library, mayInstalled.get().getParsedVersion())));
          libraryInstaller.remove(mayInstalled.get(), progressListener);
        } else {
          libraryInstaller.install(selected, progressListener);
        }
      }

      System.exit(0);

    } else if (parser.isVerifyOrUploadMode()) {
      // Set verbosity for command line build
      PreferencesData.setBoolean(""build.verbose"", parser.isDoVerboseBuild());
      PreferencesData.setBoolean(""upload.verbose"", parser.isDoVerboseUpload());

      // Set preserve-temp flag
      PreferencesData.setBoolean(""runtime.preserve.temp.files"", parser.isPreserveTempFiles());

      // Make sure these verbosity preferences are only for the current session
      PreferencesData.setDoSave(false);

      Sketch sketch = null;
      String outputFile = null;

      try {
        // Build
        splash.splashText(tr(""Verifying...""));

        File sketchFile = BaseNoGui.absoluteFile(parser.getFilenames().get(0));
        sketch = new Sketch(sketchFile);

        outputFile = new Compiler(sketch).build(progress -> {}, false);
      } catch (Exception e) {
        // Error during build
        e.printStackTrace();
        System.exit(1);
      }

      if (parser.isUploadMode()) {
        // Upload
        splash.splashText(tr(""Uploading...""));

        try {
          List<String> warnings = new ArrayList<>();
          UploaderUtils uploader = new UploaderUtils();
          boolean res = uploader.upload(sketch, null, outputFile,
                                        parser.isDoUseProgrammer(),
                                        parser.isNoUploadPort(), warnings);
          for (String warning : warnings) {
            System.out.println(tr(""Warning"") + "": "" + warning);
          }
          if (!res) {
            throw new Exception();
          }
        } catch (Exception e) {
          // Error during upload
          System.out.flush();
          System.err.flush();
          System.err
              .println(tr(""An error occurred while uploading the sketch""));
          System.exit(1);
        }
      }

      // No errors exit gracefully
      System.exit(0);
    } else if (parser.isGuiMode()) {
      splash.splashText(tr(""Starting...""));

      for (String path : parser.getFilenames()) {
        // Correctly resolve relative paths
        File file = absoluteFile(path);

        // Fix a problem with systems that use a non-ASCII languages. Paths are
        // being passed in with 8.3 syntax, which makes the sketch loader code
        // unhappy, since the sketch folder naming doesn't match up correctly.
        // http://dev.processing.org/bugs/show_bug.cgi?id=1089
        if (OSUtils.isWindows()) {
          try {
            file = file.getCanonicalFile();
          } catch (IOException e) {
            e.printStackTrace();
          }
        }

        if (!parser.isForceSavePrefs())
          PreferencesData.setDoSave(true);
        if (handleOpen(file, retrieveSketchLocation("".default""), false) == null) {
          String mess = format(tr(""Failed to open sketch: \""{0}\""""), path);
          // Open failure is fatal in upload/verify mode
          if (parser.isVerifyOrUploadMode())
            showError(null, mess, 2);
          else
            showWarning(null, mess, null);
        }
      }

      installKeyboardInputMap();

      // Check if there were previously opened sketches to be restored
      restoreSketches();

      // Create a new empty window (will be replaced with any files to be opened)
      if (editors.isEmpty()) {
        handleNew();
      }

      new Thread(new BuiltInCoreIsNewerCheck(this)).start();

      // Check for boards which need an additional core
      new Thread(new NewBoardListener(this)).start();

      // Check for updates
      if (PreferencesData.getBoolean(""update.check"")) {
        new UpdateCheck(this);

        contributionsSelfCheck = new ContributionsSelfCheck(this, new UpdatableBoardsLibsFakeURLsHandler(this), contributionInstaller, libraryInstaller);
        new Timer(false).schedule(contributionsSelfCheck, Constants.BOARDS_LIBS_UPDATABLE_CHECK_START_PERIOD);
      }

    } else if (parser.isNoOpMode()) {
      // Do nothing (intended for only changing preferences)
      System.exit(0);
    } else if (parser.isGetPrefMode()) {
      BaseNoGui.dumpPrefs(parser);
    } else if (parser.isVersionMode()) {
      System.out.println(""Arduino: "" + BaseNoGui.VERSION_NAME_LONG);
      System.exit(0);
    }
  }",iterator
warning,"{
    Thread deleteFilesOnShutdownThread = new Thread(DeleteFilesOnShutdown.INSTANCE);
    deleteFilesOnShutdownThread.setName(""DeleteFilesOnShutdown"");
    Runtime.getRuntime().addShutdownHook(deleteFilesOnShutdownThread);

    BaseNoGui.initLogger();

    initLogger();

    BaseNoGui.initPlatform();

    BaseNoGui.getPlatform().init();

    BaseNoGui.initPortableFolder();

    // Look for a possible ""--preferences-file"" parameter and load preferences
    BaseNoGui.initParameters(args);

    CommandlineParser parser = new CommandlineParser(args);
    parser.parseArgumentsPhase1();
    commandLine = !parser.isGuiMode();

    BaseNoGui.checkInstallationFolder();

    // If no path is set, get the default sketchbook folder for this platform
    if (BaseNoGui.getSketchbookPath() == null) {
      File defaultFolder = getDefaultSketchbookFolderOrPromptForIt();
      if (BaseNoGui.getPortableFolder() != null)
        PreferencesData.set(""sketchbook.path"", BaseNoGui.getPortableSketchbookFolder());
      else
        PreferencesData.set(""sketchbook.path"", defaultFolder.getAbsolutePath());
      if (!defaultFolder.exists()) {
        defaultFolder.mkdirs();
      }
    }

    SplashScreenHelper splash;
    if (parser.isGuiMode()) {
      // Setup all notification widgets
      splash = new SplashScreenHelper(SplashScreen.getSplashScreen());
      BaseNoGui.notifier = new GUIUserNotifier(this);

      // Setup the theme coloring fun
      Theme.init();
      System.setProperty(""swing.aatext"", PreferencesData.get(""editor.antialias"", ""true""));

      // Set the look and feel before opening the window
      try {
        BaseNoGui.getPlatform().setLookAndFeel();
      } catch (Exception e) {
        // ignore
      }

      // Use native popups so they don't look so crappy on osx
      JPopupMenu.setDefaultLightWeightPopupEnabled(false);
    } else {
      splash = new SplashScreenHelper(null);
    }

    splash.splashText(tr(""Loading configuration...""));

    BaseNoGui.initVersion();

    // Don't put anything above this line that might make GUI,
    // because the platform has to be inited properly first.

    // Create a location for untitled sketches
    untitledFolder = FileUtils.createTempFolder(""untitled"" + new Random().nextInt(Integer.MAX_VALUE), "".tmp"");
    DeleteFilesOnShutdown.add(untitledFolder);

    splash.splashText(tr(""Initializing packages...""));
    BaseNoGui.initPackages();

    parser.getUploadPort().ifPresent(BaseNoGui::selectSerialPort);

    splash.splashText(tr(""Preparing boards...""));

    if (!isCommandLine()) {
      rebuildBoardsMenu();
      rebuildProgrammerMenu();
    } else {
      TargetBoard lastSelectedBoard = BaseNoGui.getTargetBoard();
      if (lastSelectedBoard != null)
        BaseNoGui.selectBoard(lastSelectedBoard);
    }

    // Setup board-dependent variables.
    onBoardOrPortChange();

    pdeKeywords = new PdeKeywords();
    pdeKeywords.reload();

    final GPGDetachedSignatureVerifier gpgDetachedSignatureVerifier = new GPGDetachedSignatureVerifier();
    contributionInstaller = new ContributionInstaller(BaseNoGui.getPlatform(), gpgDetachedSignatureVerifier);
    libraryInstaller = new LibraryInstaller(BaseNoGui.getPlatform(), gpgDetachedSignatureVerifier);

    parser.parseArgumentsPhase2();

    // Save the preferences. For GUI mode, this happens in the quit
    // handler, but for other modes we should also make sure to save
    // them.
    if (parser.isForceSavePrefs()) {
      PreferencesData.save();
    }

    if (parser.isInstallBoard()) {
      ContributionsIndexer indexer = new ContributionsIndexer(
          BaseNoGui.getSettingsFolder(), BaseNoGui.getHardwareFolder(),
          BaseNoGui.getPlatform(), gpgDetachedSignatureVerifier);
      ProgressListener progressListener = new ConsoleProgressListener();

      contributionInstaller.updateIndex(progressListener);
      indexer.parseIndex();
      indexer.syncWithFilesystem();

      String[] boardToInstallParts = parser.getBoardToInstall().split("":"");

      ContributedPlatform selected = null;
      if (boardToInstallParts.length == 3) {
        Optional<Version> version = VersionHelper.valueOf(boardToInstallParts[2]);
        if (!version.isPresent()) {
          System.out.println(format(tr(""Invalid version {0}""), boardToInstallParts[2]));
          System.exit(1);
        }
        selected = indexer.getIndex().findPlatform(boardToInstallParts[0], boardToInstallParts[1], version.get().toString());
      } else if (boardToInstallParts.length == 2) {
        List<ContributedPlatform> platformsByName = indexer.getIndex().findPlatforms(boardToInstallParts[0], boardToInstallParts[1]);
        Collections.sort(platformsByName, new DownloadableContributionVersionComparator());
        if (!platformsByName.isEmpty()) {
          selected = platformsByName.get(platformsByName.size() - 1);
        }
      }
      if (selected == null) {
        System.out.println(tr(""Selected board is not available""));
        System.exit(1);
      }

      ContributedPlatform installed = indexer.getInstalled(boardToInstallParts[0], boardToInstallParts[1]);

      if (!selected.isBuiltIn()) {
        contributionInstaller.install(selected, progressListener);
      }

      if (installed != null && !installed.isBuiltIn()) {
        contributionInstaller.remove(installed);
      }

      System.exit(0);

    } else if (parser.isInstallLibrary()) {
      BaseNoGui.onBoardOrPortChange();

      ProgressListener progressListener = new ConsoleProgressListener();
      libraryInstaller.updateIndex(progressListener);

      LibrariesIndexer indexer = new LibrariesIndexer(BaseNoGui.getSettingsFolder());
      indexer.parseIndex();
      indexer.setLibrariesFolders(BaseNoGui.getLibrariesFolders());
      indexer.rescanLibraries();

      for (String library : parser.getLibraryToInstall().split("","")) {
        String[] libraryToInstallParts = library.split("":"");

        ContributedLibrary selected = null;
        if (libraryToInstallParts.length == 2) {
          Optional<Version> version = VersionHelper.valueOf(libraryToInstallParts[1]);
          if (!version.isPresent()) {
            System.out.println(format(tr(""Invalid version {0}""), libraryToInstallParts[1]));
            System.exit(1);
          }
          selected = indexer.getIndex().find(libraryToInstallParts[0], version.get().toString());
        } else if (libraryToInstallParts.length == 1) {
          List<ContributedLibrary> librariesByName = indexer.getIndex().find(libraryToInstallParts[0]);
          Collections.sort(librariesByName, new DownloadableContributionVersionComparator());
          if (!librariesByName.isEmpty()) {
            selected = librariesByName.get(librariesByName.size() - 1);
          }
        }
        if (selected == null) {
          System.out.println(tr(""Selected library is not available""));
          System.exit(1);
        }

        Optional<ContributedLibrary> mayInstalled = indexer.getIndex().getInstalled(libraryToInstallParts[0]);
        if (mayInstalled.isPresent() && selected.isIDEBuiltIn()) {
          System.out.println(tr(I18n
              .format(""Library {0} is available as built-in in the IDE.\nRemoving the other version {1} installed in the sketchbook..."",
                      library, mayInstalled.get().getParsedVersion())));
          libraryInstaller.remove(mayInstalled.get(), progressListener);
        } else {
          libraryInstaller.install(selected, progressListener);
        }
      }

      System.exit(0);

    } else if (parser.isVerifyOrUploadMode()) {
      // Set verbosity for command line build
      PreferencesData.setBoolean(""build.verbose"", parser.isDoVerboseBuild());
      PreferencesData.setBoolean(""upload.verbose"", parser.isDoVerboseUpload());

      // Set preserve-temp flag
      PreferencesData.setBoolean(""runtime.preserve.temp.files"", parser.isPreserveTempFiles());

      // Make sure these verbosity preferences are only for the current session
      PreferencesData.setDoSave(false);

      Sketch sketch = null;
      String outputFile = null;

      try {
        // Build
        splash.splashText(tr(""Verifying...""));

        File sketchFile = BaseNoGui.absoluteFile(parser.getFilenames().get(0));
        sketch = new Sketch(sketchFile);

        outputFile = new Compiler(sketch).build(progress -> {}, false);
      } catch (Exception e) {
        // Error during build
        e.printStackTrace();
        System.exit(1);
      }

      if (parser.isUploadMode()) {
        // Upload
        splash.splashText(tr(""Uploading...""));

        try {
          List<String> warnings = new ArrayList<>();
          UploaderUtils uploader = new UploaderUtils();
          boolean res = uploader.upload(sketch, null, outputFile,
                                        parser.isDoUseProgrammer(),
                                        parser.isNoUploadPort(), warnings);
          for (String warning : warnings) {
            System.out.println(tr(""Warning"") + "": "" + warning);
          }
          if (!res) {
            throw new Exception();
          }
        } catch (Exception e) {
          // Error during upload
          System.out.flush();
          System.err.flush();
          System.err
              .println(tr(""An error occurred while uploading the sketch""));
          System.exit(1);
        }
      }

      // No errors exit gracefully
      System.exit(0);
    } else if (parser.isGuiMode()) {
      splash.splashText(tr(""Starting...""));

      for (String path : parser.getFilenames()) {
        // Correctly resolve relative paths
        File file = absoluteFile(path);

        // Fix a problem with systems that use a non-ASCII languages. Paths are
        // being passed in with 8.3 syntax, which makes the sketch loader code
        // unhappy, since the sketch folder naming doesn't match up correctly.
        // http://dev.processing.org/bugs/show_bug.cgi?id=1089
        if (OSUtils.isWindows()) {
          try {
            file = file.getCanonicalFile();
          } catch (IOException e) {
            e.printStackTrace();
          }
        }

        if (!parser.isForceSavePrefs())
          PreferencesData.setDoSave(true);
        if (handleOpen(file, retrieveSketchLocation("".default""), false) == null) {
          String mess = format(tr(""Failed to open sketch: \""{0}\""""), path);
          // Open failure is fatal in upload/verify mode
          if (parser.isVerifyOrUploadMode())
            showError(null, mess, 2);
          else
            showWarning(null, mess, null);
        }
      }

      installKeyboardInputMap();

      // Check if there were previously opened sketches to be restored
      restoreSketches();

      // Create a new empty window (will be replaced with any files to be opened)
      if (editors.isEmpty()) {
        handleNew();
      }

      new Thread(new BuiltInCoreIsNewerCheck(this)).start();

      // Check for boards which need an additional core
      new Thread(new NewBoardListener(this)).start();

      // Check for updates
      if (PreferencesData.getBoolean(""update.check"")) {
        new UpdateCheck(this);

        contributionsSelfCheck = new ContributionsSelfCheck(this, new UpdatableBoardsLibsFakeURLsHandler(this), contributionInstaller, libraryInstaller);
        new Timer(false).schedule(contributionsSelfCheck, Constants.BOARDS_LIBS_UPDATABLE_CHECK_START_PERIOD);
      }

    } else if (parser.isNoOpMode()) {
      // Do nothing (intended for only changing preferences)
      System.exit(0);
    } else if (parser.isGetPrefMode()) {
      BaseNoGui.dumpPrefs(parser);
    } else if (parser.isVersionMode()) {
      System.out.println(""Arduino: "" + BaseNoGui.VERSION_NAME_LONG);
      System.exit(0);
    }
  }",iterator
path,"{
    Thread deleteFilesOnShutdownThread = new Thread(DeleteFilesOnShutdown.INSTANCE);
    deleteFilesOnShutdownThread.setName(""DeleteFilesOnShutdown"");
    Runtime.getRuntime().addShutdownHook(deleteFilesOnShutdownThread);

    BaseNoGui.initLogger();

    initLogger();

    BaseNoGui.initPlatform();

    BaseNoGui.getPlatform().init();

    BaseNoGui.initPortableFolder();

    // Look for a possible ""--preferences-file"" parameter and load preferences
    BaseNoGui.initParameters(args);

    CommandlineParser parser = new CommandlineParser(args);
    parser.parseArgumentsPhase1();
    commandLine = !parser.isGuiMode();

    BaseNoGui.checkInstallationFolder();

    // If no path is set, get the default sketchbook folder for this platform
    if (BaseNoGui.getSketchbookPath() == null) {
      File defaultFolder = getDefaultSketchbookFolderOrPromptForIt();
      if (BaseNoGui.getPortableFolder() != null)
        PreferencesData.set(""sketchbook.path"", BaseNoGui.getPortableSketchbookFolder());
      else
        PreferencesData.set(""sketchbook.path"", defaultFolder.getAbsolutePath());
      if (!defaultFolder.exists()) {
        defaultFolder.mkdirs();
      }
    }

    SplashScreenHelper splash;
    if (parser.isGuiMode()) {
      // Setup all notification widgets
      splash = new SplashScreenHelper(SplashScreen.getSplashScreen());
      BaseNoGui.notifier = new GUIUserNotifier(this);

      // Setup the theme coloring fun
      Theme.init();
      System.setProperty(""swing.aatext"", PreferencesData.get(""editor.antialias"", ""true""));

      // Set the look and feel before opening the window
      try {
        BaseNoGui.getPlatform().setLookAndFeel();
      } catch (Exception e) {
        // ignore
      }

      // Use native popups so they don't look so crappy on osx
      JPopupMenu.setDefaultLightWeightPopupEnabled(false);
    } else {
      splash = new SplashScreenHelper(null);
    }

    splash.splashText(tr(""Loading configuration...""));

    BaseNoGui.initVersion();

    // Don't put anything above this line that might make GUI,
    // because the platform has to be inited properly first.

    // Create a location for untitled sketches
    untitledFolder = FileUtils.createTempFolder(""untitled"" + new Random().nextInt(Integer.MAX_VALUE), "".tmp"");
    DeleteFilesOnShutdown.add(untitledFolder);

    splash.splashText(tr(""Initializing packages...""));
    BaseNoGui.initPackages();

    parser.getUploadPort().ifPresent(BaseNoGui::selectSerialPort);

    splash.splashText(tr(""Preparing boards...""));

    if (!isCommandLine()) {
      rebuildBoardsMenu();
      rebuildProgrammerMenu();
    } else {
      TargetBoard lastSelectedBoard = BaseNoGui.getTargetBoard();
      if (lastSelectedBoard != null)
        BaseNoGui.selectBoard(lastSelectedBoard);
    }

    // Setup board-dependent variables.
    onBoardOrPortChange();

    pdeKeywords = new PdeKeywords();
    pdeKeywords.reload();

    final GPGDetachedSignatureVerifier gpgDetachedSignatureVerifier = new GPGDetachedSignatureVerifier();
    contributionInstaller = new ContributionInstaller(BaseNoGui.getPlatform(), gpgDetachedSignatureVerifier);
    libraryInstaller = new LibraryInstaller(BaseNoGui.getPlatform(), gpgDetachedSignatureVerifier);

    parser.parseArgumentsPhase2();

    // Save the preferences. For GUI mode, this happens in the quit
    // handler, but for other modes we should also make sure to save
    // them.
    if (parser.isForceSavePrefs()) {
      PreferencesData.save();
    }

    if (parser.isInstallBoard()) {
      ContributionsIndexer indexer = new ContributionsIndexer(
          BaseNoGui.getSettingsFolder(), BaseNoGui.getHardwareFolder(),
          BaseNoGui.getPlatform(), gpgDetachedSignatureVerifier);
      ProgressListener progressListener = new ConsoleProgressListener();

      contributionInstaller.updateIndex(progressListener);
      indexer.parseIndex();
      indexer.syncWithFilesystem();

      String[] boardToInstallParts = parser.getBoardToInstall().split("":"");

      ContributedPlatform selected = null;
      if (boardToInstallParts.length == 3) {
        Optional<Version> version = VersionHelper.valueOf(boardToInstallParts[2]);
        if (!version.isPresent()) {
          System.out.println(format(tr(""Invalid version {0}""), boardToInstallParts[2]));
          System.exit(1);
        }
        selected = indexer.getIndex().findPlatform(boardToInstallParts[0], boardToInstallParts[1], version.get().toString());
      } else if (boardToInstallParts.length == 2) {
        List<ContributedPlatform> platformsByName = indexer.getIndex().findPlatforms(boardToInstallParts[0], boardToInstallParts[1]);
        Collections.sort(platformsByName, new DownloadableContributionVersionComparator());
        if (!platformsByName.isEmpty()) {
          selected = platformsByName.get(platformsByName.size() - 1);
        }
      }
      if (selected == null) {
        System.out.println(tr(""Selected board is not available""));
        System.exit(1);
      }

      ContributedPlatform installed = indexer.getInstalled(boardToInstallParts[0], boardToInstallParts[1]);

      if (!selected.isBuiltIn()) {
        contributionInstaller.install(selected, progressListener);
      }

      if (installed != null && !installed.isBuiltIn()) {
        contributionInstaller.remove(installed);
      }

      System.exit(0);

    } else if (parser.isInstallLibrary()) {
      BaseNoGui.onBoardOrPortChange();

      ProgressListener progressListener = new ConsoleProgressListener();
      libraryInstaller.updateIndex(progressListener);

      LibrariesIndexer indexer = new LibrariesIndexer(BaseNoGui.getSettingsFolder());
      indexer.parseIndex();
      indexer.setLibrariesFolders(BaseNoGui.getLibrariesFolders());
      indexer.rescanLibraries();

      for (String library : parser.getLibraryToInstall().split("","")) {
        String[] libraryToInstallParts = library.split("":"");

        ContributedLibrary selected = null;
        if (libraryToInstallParts.length == 2) {
          Optional<Version> version = VersionHelper.valueOf(libraryToInstallParts[1]);
          if (!version.isPresent()) {
            System.out.println(format(tr(""Invalid version {0}""), libraryToInstallParts[1]));
            System.exit(1);
          }
          selected = indexer.getIndex().find(libraryToInstallParts[0], version.get().toString());
        } else if (libraryToInstallParts.length == 1) {
          List<ContributedLibrary> librariesByName = indexer.getIndex().find(libraryToInstallParts[0]);
          Collections.sort(librariesByName, new DownloadableContributionVersionComparator());
          if (!librariesByName.isEmpty()) {
            selected = librariesByName.get(librariesByName.size() - 1);
          }
        }
        if (selected == null) {
          System.out.println(tr(""Selected library is not available""));
          System.exit(1);
        }

        Optional<ContributedLibrary> mayInstalled = indexer.getIndex().getInstalled(libraryToInstallParts[0]);
        if (mayInstalled.isPresent() && selected.isIDEBuiltIn()) {
          System.out.println(tr(I18n
              .format(""Library {0} is available as built-in in the IDE.\nRemoving the other version {1} installed in the sketchbook..."",
                      library, mayInstalled.get().getParsedVersion())));
          libraryInstaller.remove(mayInstalled.get(), progressListener);
        } else {
          libraryInstaller.install(selected, progressListener);
        }
      }

      System.exit(0);

    } else if (parser.isVerifyOrUploadMode()) {
      // Set verbosity for command line build
      PreferencesData.setBoolean(""build.verbose"", parser.isDoVerboseBuild());
      PreferencesData.setBoolean(""upload.verbose"", parser.isDoVerboseUpload());

      // Set preserve-temp flag
      PreferencesData.setBoolean(""runtime.preserve.temp.files"", parser.isPreserveTempFiles());

      // Make sure these verbosity preferences are only for the current session
      PreferencesData.setDoSave(false);

      Sketch sketch = null;
      String outputFile = null;

      try {
        // Build
        splash.splashText(tr(""Verifying...""));

        File sketchFile = BaseNoGui.absoluteFile(parser.getFilenames().get(0));
        sketch = new Sketch(sketchFile);

        outputFile = new Compiler(sketch).build(progress -> {}, false);
      } catch (Exception e) {
        // Error during build
        e.printStackTrace();
        System.exit(1);
      }

      if (parser.isUploadMode()) {
        // Upload
        splash.splashText(tr(""Uploading...""));

        try {
          List<String> warnings = new ArrayList<>();
          UploaderUtils uploader = new UploaderUtils();
          boolean res = uploader.upload(sketch, null, outputFile,
                                        parser.isDoUseProgrammer(),
                                        parser.isNoUploadPort(), warnings);
          for (String warning : warnings) {
            System.out.println(tr(""Warning"") + "": "" + warning);
          }
          if (!res) {
            throw new Exception();
          }
        } catch (Exception e) {
          // Error during upload
          System.out.flush();
          System.err.flush();
          System.err
              .println(tr(""An error occurred while uploading the sketch""));
          System.exit(1);
        }
      }

      // No errors exit gracefully
      System.exit(0);
    } else if (parser.isGuiMode()) {
      splash.splashText(tr(""Starting...""));

      for (String path : parser.getFilenames()) {
        // Correctly resolve relative paths
        File file = absoluteFile(path);

        // Fix a problem with systems that use a non-ASCII languages. Paths are
        // being passed in with 8.3 syntax, which makes the sketch loader code
        // unhappy, since the sketch folder naming doesn't match up correctly.
        // http://dev.processing.org/bugs/show_bug.cgi?id=1089
        if (OSUtils.isWindows()) {
          try {
            file = file.getCanonicalFile();
          } catch (IOException e) {
            e.printStackTrace();
          }
        }

        if (!parser.isForceSavePrefs())
          PreferencesData.setDoSave(true);
        if (handleOpen(file, retrieveSketchLocation("".default""), false) == null) {
          String mess = format(tr(""Failed to open sketch: \""{0}\""""), path);
          // Open failure is fatal in upload/verify mode
          if (parser.isVerifyOrUploadMode())
            showError(null, mess, 2);
          else
            showWarning(null, mess, null);
        }
      }

      installKeyboardInputMap();

      // Check if there were previously opened sketches to be restored
      restoreSketches();

      // Create a new empty window (will be replaced with any files to be opened)
      if (editors.isEmpty()) {
        handleNew();
      }

      new Thread(new BuiltInCoreIsNewerCheck(this)).start();

      // Check for boards which need an additional core
      new Thread(new NewBoardListener(this)).start();

      // Check for updates
      if (PreferencesData.getBoolean(""update.check"")) {
        new UpdateCheck(this);

        contributionsSelfCheck = new ContributionsSelfCheck(this, new UpdatableBoardsLibsFakeURLsHandler(this), contributionInstaller, libraryInstaller);
        new Timer(false).schedule(contributionsSelfCheck, Constants.BOARDS_LIBS_UPDATABLE_CHECK_START_PERIOD);
      }

    } else if (parser.isNoOpMode()) {
      // Do nothing (intended for only changing preferences)
      System.exit(0);
    } else if (parser.isGetPrefMode()) {
      BaseNoGui.dumpPrefs(parser);
    } else if (parser.isVersionMode()) {
      System.out.println(""Arduino: "" + BaseNoGui.VERSION_NAME_LONG);
      System.exit(0);
    }
  }",iterator
i,"{
    // Iterate through all sketches that were open last time p5 was running.
    // If !windowPositionValid, then ignore the coordinates found for each.

    // Save the sketch path and window placement for each open sketch
    int count = PreferencesData.getInteger(""last.sketch.count"");
    int opened = 0;
    for (int i = count - 1; i >= 0; i--) {
      String path = PreferencesData.get(""last.sketch"" + i + "".path"");
      if (path == null) {
        continue;
      }
      if (BaseNoGui.getPortableFolder() != null && !new File(path).isAbsolute()) {
        File absolute = new File(BaseNoGui.getPortableFolder(), path);
        try {
          path = absolute.getCanonicalPath();
        } catch (IOException e) {
          // path unchanged.
        }
      }
      int[] location = retrieveSketchLocation("""" + i);
      // If file did not exist, null will be returned for the Editor
      if (handleOpen(new File(path), location, nextEditorLocation(), false, false) != null) {
        opened++;
      }
    }
    return (opened > 0);
  }",loop_control
editor,"{

    // If there is only one sketch opened save his position as default
    if (editors.size() == 1) {
      storeSketchLocation(editors.get(0), "".default"");
    }

    // Save the sketch path and window placement for each open sketch
    String untitledPath = untitledFolder.getAbsolutePath();
    List<Editor> reversedEditors = new LinkedList<>(editors);
    Collections.reverse(reversedEditors);
    int index = 0;
    for (Editor editor : reversedEditors) {
      Sketch sketch = editor.getSketch();
      String path = sketch.getMainFilePath();
      // Skip untitled sketches if they do not contains changes.
      if (path.startsWith(untitledPath) && !sketch.isModified()) {
        continue;
      }
      storeSketchLocation(editor, """" + index);
      index++;
    }
    PreferencesData.setInteger(""last.sketch.count"", index);
  }",iterator
index,"{
    File newbieDir = null;
    String newbieName = null;

    // In 0126, untitled sketches will begin in the temp folder,
    // and then moved to a new location because Save will default to Save As.
    File sketchbookDir = BaseNoGui.getSketchbookFolder();
    File newbieParentDir = untitledFolder;

    // Use a generic name like sketch_031008a, the date plus a char
    int index = 0;
    //SimpleDateFormat formatter = new SimpleDateFormat(""yyMMdd"");
    //SimpleDateFormat formatter = new SimpleDateFormat(""MMMdd"");
    //String purty = formatter.format(new Date()).toLowerCase();
    Calendar cal = Calendar.getInstance();
    int day = cal.get(Calendar.DAY_OF_MONTH);  // 1..31
    int month = cal.get(Calendar.MONTH);  // 0..11
    String purty = months[month] + PApplet.nf(day, 2);

    do {
      if (index == 26*26) {
        // In 0166, avoid running past zz by sending people outdoors.
        if (!breakTime) {
          showWarning(tr(""Time for a Break""),
                  tr(""You've reached the limit for auto naming of new sketches\n"" +
                          ""for the day. How about going for a walk instead?""), null);
          breakTime = true;
        } else {
          showWarning(tr(""Sunshine""),
                  tr(""No really, time for some fresh air for you.""), null);
        }
        return null;
      }

      int multiples = index / 26;

      if(multiples > 0){
        newbieName = ((char) ('a' + (multiples-1))) + """" + ((char) ('a' + (index % 26))) + """";
      }else{
        newbieName = ((char) ('a' + index)) + """";
      }
      newbieName = ""sketch_"" + purty + newbieName;
      newbieDir = new File(newbieParentDir, newbieName);
      index++;
      // Make sure it's not in the temp folder *and* it's not in the sketchbook
    } while (newbieDir.exists() || new File(sketchbookDir, newbieName).exists());

    // Make the directory for the new sketch
    newbieDir.mkdirs();

    // Make an empty pde file
    File newbieFile = new File(newbieDir, newbieName + "".ino"");
    if (!newbieFile.createNewFile()) {
      throw new IOException();
    }

    // Initialize the pde file with the BareMinimum sketch.
    // Apply user-defined tab settings.
    String sketch = FileUtils.readFileToString(
        new File(getContentFile(""examples""), ""01.Basics"" + File.separator
            + ""BareMinimum"" + File.separator + ""BareMinimum.ino""));
    String currentTab = ""  "";
    String newTab = (PreferencesData.getBoolean(""editor.tabs.expand"")
        ? StringUtils.repeat("" "",
            PreferencesData.getInteger(""editor.tabs.size""))
        : ""\t"");
    sketch = sketch.replaceAll(
        ""(?<=(^|\n)("" + currentTab + ""){0,50})"" + currentTab, newTab);
    FileUtils.writeStringToFile(newbieFile, sketch);
    return newbieFile;
  }",break_loop_control
newbieDir,"{
    File newbieDir = null;
    String newbieName = null;

    // In 0126, untitled sketches will begin in the temp folder,
    // and then moved to a new location because Save will default to Save As.
    File sketchbookDir = BaseNoGui.getSketchbookFolder();
    File newbieParentDir = untitledFolder;

    // Use a generic name like sketch_031008a, the date plus a char
    int index = 0;
    //SimpleDateFormat formatter = new SimpleDateFormat(""yyMMdd"");
    //SimpleDateFormat formatter = new SimpleDateFormat(""MMMdd"");
    //String purty = formatter.format(new Date()).toLowerCase();
    Calendar cal = Calendar.getInstance();
    int day = cal.get(Calendar.DAY_OF_MONTH);  // 1..31
    int month = cal.get(Calendar.MONTH);  // 0..11
    String purty = months[month] + PApplet.nf(day, 2);

    do {
      if (index == 26*26) {
        // In 0166, avoid running past zz by sending people outdoors.
        if (!breakTime) {
          showWarning(tr(""Time for a Break""),
                  tr(""You've reached the limit for auto naming of new sketches\n"" +
                          ""for the day. How about going for a walk instead?""), null);
          breakTime = true;
        } else {
          showWarning(tr(""Sunshine""),
                  tr(""No really, time for some fresh air for you.""), null);
        }
        return null;
      }

      int multiples = index / 26;

      if(multiples > 0){
        newbieName = ((char) ('a' + (multiples-1))) + """" + ((char) ('a' + (index % 26))) + """";
      }else{
        newbieName = ((char) ('a' + index)) + """";
      }
      newbieName = ""sketch_"" + purty + newbieName;
      newbieDir = new File(newbieParentDir, newbieName);
      index++;
      // Make sure it's not in the temp folder *and* it's not in the sketchbook
    } while (newbieDir.exists() || new File(sketchbookDir, newbieName).exists());

    // Make the directory for the new sketch
    newbieDir.mkdirs();

    // Make an empty pde file
    File newbieFile = new File(newbieDir, newbieName + "".ino"");
    if (!newbieFile.createNewFile()) {
      throw new IOException();
    }

    // Initialize the pde file with the BareMinimum sketch.
    // Apply user-defined tab settings.
    String sketch = FileUtils.readFileToString(
        new File(getContentFile(""examples""), ""01.Basics"" + File.separator
            + ""BareMinimum"" + File.separator + ""BareMinimum.ino""));
    String currentTab = ""  "";
    String newTab = (PreferencesData.getBoolean(""editor.tabs.expand"")
        ? StringUtils.repeat("" "",
            PreferencesData.getInteger(""editor.tabs.size""))
        : ""\t"");
    sketch = sketch.replaceAll(
        ""(?<=(^|\n)("" + currentTab + ""){0,50})"" + currentTab, newTab);
    FileUtils.writeStringToFile(newbieFile, sketch);
    return newbieFile;
  }",maybe_loop_control
editor,"{
    if (!file.exists()) return null;

    // Cycle through open windows to make sure that it's not already open.
    for (Editor editor : editors) {
      if (editor.getSketch().getPrimaryFile().getFile().equals(file)) {
        editor.toFront();
        return editor;
      }
    }

    Editor editor = new Editor(this, file, storedLocation, defaultLocation, BaseNoGui.getPlatform());

    // Make sure that the sketch actually loaded
    if (editor.getSketchController() == null) {
      return null;  // Just walk away quietly
    }

    editor.untitled = untitled;

    editors.add(editor);

    if (storeOpenedSketches) {
      // Store information on who's open and running
      // (in case there's a crash or something that can't be recovered)
      storeSketches();
      storeRecentSketches(editor.getSketchController());
      rebuildRecentSketchesMenuItems();
      PreferencesData.save();
    }

    // now that we're ready, show the window
    // (don't do earlier, cuz we might move it based on a window being closed)
    SwingUtilities.invokeLater(() -> editor.setVisible(true));

    return editor;
  }",iterator
editor,"{
    if (!file.exists()) return null;

    // Cycle through open windows to make sure that it's not already open.
    for (Editor editor : editors) {
      if (editor.getSketch().getPrimaryFile().getFile().equals(file)) {
        editor.toFront();
        return editor;
      }
    }

    Editor editor = new Editor(this, file, storedLocation, defaultLocation, BaseNoGui.getPlatform());

    // Make sure that the sketch actually loaded
    if (editor.getSketchController() == null) {
      return null;  // Just walk away quietly
    }

    editor.untitled = untitled;

    editors.add(editor);

    if (storeOpenedSketches) {
      // Store information on who's open and running
      // (in case there's a crash or something that can't be recovered)
      storeSketches();
      storeRecentSketches(editor.getSketchController());
      rebuildRecentSketchesMenuItems();
      PreferencesData.save();
    }

    // now that we're ready, show the window
    // (don't do earlier, cuz we might move it based on a window being closed)
    SwingUtilities.invokeLater(() -> editor.setVisible(true));

    return editor;
  }",break_loop_control
path,"{
    Set<File> recentSketches = new LinkedHashSet<File>() {

      @Override
      public boolean add(File file) {
        if (size() >= RECENT_SKETCHES_MAX_SIZE) {
          return false;
        }
        return super.add(file);
      }
    };

    for (String path : PreferencesData.getCollection(""recent.sketches"")) {
      File file = new File(path);
      if (file.exists()) {
        recentSketches.add(file);
      }
    }

    recentSketchesMenuItems.clear();
    for (final File recentSketch : recentSketches) {
      JMenuItem recentSketchMenuItem = new JMenuItem(recentSketch.getParentFile().getName());
      recentSketchMenuItem.addActionListener(new ActionListener() {
        @Override
        public void actionPerformed(ActionEvent actionEvent) {
          try {
            handleOpen(recentSketch);
          } catch (Exception e) {
            e.printStackTrace();
          }
        }
      });
      recentSketchesMenuItems.add(recentSketchMenuItem);
    }
  }",iterator
recentSketch,"{
    Set<File> recentSketches = new LinkedHashSet<File>() {

      @Override
      public boolean add(File file) {
        if (size() >= RECENT_SKETCHES_MAX_SIZE) {
          return false;
        }
        return super.add(file);
      }
    };

    for (String path : PreferencesData.getCollection(""recent.sketches"")) {
      File file = new File(path);
      if (file.exists()) {
        recentSketches.add(file);
      }
    }

    recentSketchesMenuItems.clear();
    for (final File recentSketch : recentSketches) {
      JMenuItem recentSketchMenuItem = new JMenuItem(recentSketch.getParentFile().getName());
      recentSketchMenuItem.addActionListener(new ActionListener() {
        @Override
        public void actionPerformed(ActionEvent actionEvent) {
          try {
            handleOpen(recentSketch);
          } catch (Exception e) {
            e.printStackTrace();
          }
        }
      });
      recentSketchesMenuItems.add(recentSketchMenuItem);
    }
  }",iterator
editor,"{
    for (Editor editor : editors) {
      if (!editor.checkModified()) {
        return false;
      }
    }
    return true;
  }",iterator
editor,"{
    for (Editor editor : editors) {
      if (!editor.checkModified()) {
        return false;
      }
    }
    return true;
  }",break_loop_control
lib,"{
    if (importMenu == null)
      return;
    importMenu.removeAll();

    JMenuItem menu = new JMenuItem(tr(""Manage Libraries...""));
    // Ctrl+Shift+I on Windows and Linux, Command+Shift+I on macOS
    menu.setAccelerator(KeyStroke.getKeyStroke('I',
        Toolkit.getDefaultToolkit().getMenuShortcutKeyMask() |
        ActionEvent.SHIFT_MASK));
    menu.addActionListener(e -> openLibraryManager("""", """"));
    importMenu.add(menu);
    importMenu.addSeparator();

    JMenuItem addLibraryMenuItem = new JMenuItem(tr(""Add .ZIP Library...""));
    addLibraryMenuItem.addActionListener(new ActionListener() {
      public void actionPerformed(ActionEvent e) {
        Base.this.handleAddLibrary();
        BaseNoGui.librariesIndexer.rescanLibraries();
        Base.this.onBoardOrPortChange();
        Base.this.rebuildImportMenu(Editor.importMenu);
        Base.this.rebuildExamplesMenu(Editor.examplesMenu);
      }
    });
    importMenu.add(addLibraryMenuItem);
    importMenu.addSeparator();

    // Split between user supplied libraries and IDE libraries
    TargetPlatform targetPlatform = BaseNoGui.getTargetPlatform();

    if (targetPlatform != null) {
      LibraryList libs = getSortedLibraries();
      String lastLibType = null;
      for (UserLibrary lib : libs) {
        String libType = lib.getTypes().get(0);
        if (!libType.equals(lastLibType)) {
          if (lastLibType != null) {
            importMenu.addSeparator();
          }
          lastLibType = libType;
          JMenuItem platformItem = new JMenuItem(format(tr(""{0} libraries""), tr(lastLibType)));
          platformItem.setEnabled(false);
          importMenu.add(platformItem);
        }

        AbstractAction action = new AbstractAction(lib.getName()) {
          public void actionPerformed(ActionEvent event) {
            UserLibrary l = (UserLibrary) getValue(""library"");
            try {
              activeEditor.getSketchController().importLibrary(l);
            } catch (IOException e) {
              showWarning(tr(""Error""), format(""Unable to list header files in {0}"", l.getSrcFolder()), e);
            }
          }
        };
        action.putValue(""library"", lib);

        // Add new element at the bottom
        JMenuItem item = new JMenuItem(action);
        item.putClientProperty(""library"", lib);
        importMenu.add(item);
      }
    }
  }",iterator
lib,"{
    if (menu == null) {
      return;
    }

    menu.removeAll();

    // Add examples from distribution ""example"" folder
    JMenuItem label = new JMenuItem(tr(""Built-in Examples""));
    label.setEnabled(false);
    menu.add(label);
    boolean found = addSketches(menu, BaseNoGui.getExamplesFolder());
    if (found) {
      menu.addSeparator();
    }

    // Libraries can come from 4 locations: collect info about all four
    String boardId = null;
    String referencedPlatformName = null;
    String myArch = null;
    TargetPlatform targetPlatform = BaseNoGui.getTargetPlatform();
    if (targetPlatform != null) {
      myArch = targetPlatform.getId();
      boardId = BaseNoGui.getTargetBoard().getName();
      String core = BaseNoGui.getBoardPreferences().get(""build.core"", ""arduino"");
      if (core.contains("":"")) {
        String refcore = core.split("":"")[0];
        TargetPlatform referencedPlatform = BaseNoGui.getTargetPlatform(refcore, myArch);
        if (referencedPlatform != null) {
          referencedPlatformName = referencedPlatform.getPreferences().get(""name"");
        }
      }
    }

    // Divide the libraries into 7 lists, corresponding to the 4 locations
    // with the retired IDE libs further divided into their own list, and
    // any incompatible sketchbook libs further divided into their own list.
    // The 7th list of ""other"" libraries should always be empty, but serves
    // as a safety feature to prevent any library from vanishing.
    LibraryList allLibraries = BaseNoGui.librariesIndexer.getInstalledLibraries();
    LibraryList ideLibs = new LibraryList();
    LibraryList retiredIdeLibs = new LibraryList();
    LibraryList platformLibs = new LibraryList();
    LibraryList referencedPlatformLibs = new LibraryList();
    LibraryList sketchbookLibs = new LibraryList();
    LibraryList sketchbookIncompatibleLibs = new LibraryList();
    LibraryList otherLibs = new LibraryList();
    for (UserLibrary lib : allLibraries) {
      // Get the library's location - used for sorting into categories
      Location location = lib.getLocation();
      // Is this library compatible?
      List<String> arch = lib.getArchitectures();
      boolean compatible;
      if (myArch == null || arch == null || arch.contains(""*"")) {
        compatible = true;
      } else {
        compatible = arch.contains(myArch);
      }
      // IDE Libaries (including retired)
      if (location == Location.IDE_BUILTIN) {
        if (compatible) {
          // only compatible IDE libs are shown
          if (lib.getTypes().contains(""Retired"")) {
            retiredIdeLibs.add(lib);
          } else {
            ideLibs.add(lib);
          }
        }
      // Platform Libraries
      } else if (location == Location.CORE) {
        // all platform libs are assumed to be compatible
        platformLibs.add(lib);
      // Referenced Platform Libraries
      } else if (location == Location.REFERENCED_CORE) {
        // all referenced platform libs are assumed to be compatible
        referencedPlatformLibs.add(lib);
      // Sketchbook Libraries (including incompatible)
      } else if (location == Location.SKETCHBOOK) {
        if (compatible) {
          // libraries promoted from sketchbook (behave as builtin)
          if (!lib.getTypes().isEmpty() && lib.getTypes().contains(""Arduino"")
              && lib.getArchitectures().contains(""*"")) {
            ideLibs.add(lib);
          } else {
            sketchbookLibs.add(lib);
          }
        } else {
          sketchbookIncompatibleLibs.add(lib);
        }
      // Other libraries of unknown type (should never occur)
      } else {
        otherLibs.add(lib);
      }
    }

    // Add examples from libraries
    if (!ideLibs.isEmpty()) {
      ideLibs.sort();
      label = new JMenuItem(tr(""Examples for any board""));
      label.setEnabled(false);
      menu.add(label);
    }
    for (UserLibrary lib : ideLibs) {
      addSketchesSubmenu(menu, lib);
    }

    if (!retiredIdeLibs.isEmpty()) {
      retiredIdeLibs.sort();
      JMenu retired = new JMenu(tr(""RETIRED""));
      menu.add(retired);
      for (UserLibrary lib : retiredIdeLibs) {
        addSketchesSubmenu(retired, lib);
      }
    }

    if (!platformLibs.isEmpty()) {
      menu.addSeparator();
      platformLibs.sort();
      label = new JMenuItem(format(tr(""Examples for {0}""), boardId));
      label.setEnabled(false);
      menu.add(label);
      for (UserLibrary lib : platformLibs) {
        addSketchesSubmenu(menu, lib);
      }
    }

    if (!referencedPlatformLibs.isEmpty()) {
      menu.addSeparator();
      referencedPlatformLibs.sort();
      label = new JMenuItem(format(tr(""Examples for {0}""), referencedPlatformName));
      label.setEnabled(false);
      menu.add(label);
      for (UserLibrary lib : referencedPlatformLibs) {
        addSketchesSubmenu(menu, lib);
      }
    }

    if (!sketchbookLibs.isEmpty()) {
      menu.addSeparator();
      sketchbookLibs.sort();
      label = new JMenuItem(tr(""Examples from Custom Libraries""));
      label.setEnabled(false);
      menu.add(label);
      for (UserLibrary lib : sketchbookLibs) {
        addSketchesSubmenu(menu, lib);
      }
    }

    if (!sketchbookIncompatibleLibs.isEmpty()) {
      sketchbookIncompatibleLibs.sort();
      JMenu incompatible = new JMenu(tr(""INCOMPATIBLE""));
      MenuScroller.setScrollerFor(incompatible);
      menu.add(incompatible);
      for (UserLibrary lib : sketchbookIncompatibleLibs) {
        addSketchesSubmenu(incompatible, lib);
      }
    }

    if (!otherLibs.isEmpty()) {
      menu.addSeparator();
      otherLibs.sort();
      label = new JMenuItem(tr(""Examples from Other Libraries""));
      label.setEnabled(false);
      menu.add(label);
      for (UserLibrary lib : otherLibs) {
        addSketchesSubmenu(menu, lib);
      }
    }
  }",iterator
editor,"{
    BaseNoGui.onBoardOrPortChange();

    // reload keywords when package/platform changes
    TargetPlatform tp = BaseNoGui.getTargetPlatform();
    if (tp != null) {
      String platformFolder = tp.getFolder().getAbsolutePath();
      if (priorPlatformFolder == null || !priorPlatformFolder.equals(platformFolder) || newLibraryImported) {
        pdeKeywords = new PdeKeywords();
        pdeKeywords.reload();
        priorPlatformFolder = platformFolder;
        newLibraryImported = false;
        for (Editor editor : editors) {
          editor.updateKeywords(pdeKeywords);
        }
      }
    }

    // Update editors status bar
    for (Editor editor : editors) {
      editor.onBoardOrPortChange();
    }
  }",iterator
handler,"{
    Handler consoleHandler = new ConsoleLogger();
    consoleHandler.setLevel(Level.ALL);
    consoleHandler.setFormatter(new LogFormatter(""%1$tl:%1$tM:%1$tS [%4$7s] %2$s: %5$s%n""));

    Logger globalLogger = Logger.getLogger(Logger.GLOBAL_LOGGER_NAME);
    globalLogger.setLevel(consoleHandler.getLevel());

    // Remove default
    Handler[] handlers = globalLogger.getHandlers();
    for(Handler handler : handlers) {
        globalLogger.removeHandler(handler);
    }
    Logger root = Logger.getLogger("""");
    handlers = root.getHandlers();
    for(Handler handler : handlers) {
      root.removeHandler(handler);
    }

    globalLogger.addHandler(consoleHandler);

    Logger.getLogger(""cc.arduino.packages.autocomplete"").setParent(globalLogger);
    Logger.getLogger(""br.com.criativasoft.cpluslibparser"").setParent(globalLogger);
    Logger.getLogger(Base.class.getPackage().getName()).setParent(globalLogger);

  }",iterator
library,"{
    Thread deleteFilesOnShutdownThread = new Thread(DeleteFilesOnShutdown.INSTANCE);
    deleteFilesOnShutdownThread.setName(""DeleteFilesOnShutdown"");
    Runtime.getRuntime().addShutdownHook(deleteFilesOnShutdownThread);

    BaseNoGui.initLogger();

    initLogger();

    BaseNoGui.initPlatform();

    BaseNoGui.getPlatform().init();

    BaseNoGui.initPortableFolder();

    // Look for a possible ""--preferences-file"" parameter and load preferences
    BaseNoGui.initParameters(args);

    CommandlineParser parser = new CommandlineParser(args);
    parser.parseArgumentsPhase1();
    commandLine = !parser.isGuiMode();

    BaseNoGui.checkInstallationFolder();

    // If no path is set, get the default sketchbook folder for this platform
    if (BaseNoGui.getSketchbookPath() == null) {
      File defaultFolder = getDefaultSketchbookFolderOrPromptForIt();
      if (BaseNoGui.getPortableFolder() != null)
        PreferencesData.set(""sketchbook.path"", BaseNoGui.getPortableSketchbookFolder());
      else
        PreferencesData.set(""sketchbook.path"", defaultFolder.getAbsolutePath());
      if (!defaultFolder.exists()) {
        defaultFolder.mkdirs();
      }
    }

    SplashScreenHelper splash;
    if (parser.isGuiMode()) {
      // Setup all notification widgets
      splash = new SplashScreenHelper(SplashScreen.getSplashScreen());
      BaseNoGui.notifier = new GUIUserNotifier(this);

      // Setup the theme coloring fun
      Theme.init();
      System.setProperty(""swing.aatext"", PreferencesData.get(""editor.antialias"", ""true""));

      // Set the look and feel before opening the window
      try {
        BaseNoGui.getPlatform().setLookAndFeel();
      } catch (Exception e) {
        // ignore
      }

      // Use native popups so they don't look so crappy on osx
      JPopupMenu.setDefaultLightWeightPopupEnabled(false);
    } else {
      splash = new SplashScreenHelper(null);
    }

    splash.splashText(tr(""Loading configuration...""));

    BaseNoGui.initVersion();

    // Don't put anything above this line that might make GUI,
    // because the platform has to be inited properly first.

    // Create a location for untitled sketches
    untitledFolder = FileUtils.createTempFolder(""untitled"" + new Random().nextInt(Integer.MAX_VALUE), "".tmp"");
    DeleteFilesOnShutdown.add(untitledFolder);

    splash.splashText(tr(""Initializing packages...""));
    BaseNoGui.initPackages();

    parser.getUploadPort().ifPresent(BaseNoGui::selectSerialPort);

    splash.splashText(tr(""Preparing boards...""));

    if (!isCommandLine()) {
      rebuildBoardsMenu();
      rebuildProgrammerMenu();
    } else {
      TargetBoard lastSelectedBoard = BaseNoGui.getTargetBoard();
      if (lastSelectedBoard != null)
        BaseNoGui.selectBoard(lastSelectedBoard);
    }

    // Setup board-dependent variables.
    onBoardOrPortChange();

    pdeKeywords = new PdeKeywords();
    pdeKeywords.reload();

    final GPGDetachedSignatureVerifier gpgDetachedSignatureVerifier = new GPGDetachedSignatureVerifier();
    contributionInstaller = new ContributionInstaller(BaseNoGui.getPlatform(), gpgDetachedSignatureVerifier);
    libraryInstaller = new LibraryInstaller(BaseNoGui.getPlatform(), gpgDetachedSignatureVerifier);

    parser.parseArgumentsPhase2();

    // Save the preferences. For GUI mode, this happens in the quit
    // handler, but for other modes we should also make sure to save
    // them.
    if (parser.isForceSavePrefs()) {
      PreferencesData.save();
    }

    if (parser.isInstallBoard()) {
      ContributionsIndexer indexer = new ContributionsIndexer(
          BaseNoGui.getSettingsFolder(), BaseNoGui.getHardwareFolder(),
          BaseNoGui.getPlatform(), gpgDetachedSignatureVerifier);
      ProgressListener progressListener = new ConsoleProgressListener();

      contributionInstaller.updateIndex(progressListener);
      indexer.parseIndex();
      indexer.syncWithFilesystem();

      String[] boardToInstallParts = parser.getBoardToInstall().split("":"");

      ContributedPlatform selected = null;
      if (boardToInstallParts.length == 3) {
        Optional<Version> version = VersionHelper.valueOf(boardToInstallParts[2]);
        if (!version.isPresent()) {
          System.out.println(format(tr(""Invalid version {0}""), boardToInstallParts[2]));
          System.exit(1);
        }
        selected = indexer.getIndex().findPlatform(boardToInstallParts[0], boardToInstallParts[1], version.get().toString());
      } else if (boardToInstallParts.length == 2) {
        List<ContributedPlatform> platformsByName = indexer.getIndex().findPlatforms(boardToInstallParts[0], boardToInstallParts[1]);
        Collections.sort(platformsByName, new DownloadableContributionVersionComparator());
        if (!platformsByName.isEmpty()) {
          selected = platformsByName.get(platformsByName.size() - 1);
        }
      }
      if (selected == null) {
        System.out.println(tr(""Selected board is not available""));
        System.exit(1);
      }

      ContributedPlatform installed = indexer.getInstalled(boardToInstallParts[0], boardToInstallParts[1]);

      if (!selected.isBuiltIn()) {
        contributionInstaller.install(selected, progressListener);
      }

      if (installed != null && !installed.isBuiltIn()) {
        contributionInstaller.remove(installed);
      }

      System.exit(0);

    } else if (parser.isInstallLibrary()) {
      BaseNoGui.onBoardOrPortChange();

      ProgressListener progressListener = new ConsoleProgressListener();
      libraryInstaller.updateIndex(progressListener);

      LibrariesIndexer indexer = new LibrariesIndexer(BaseNoGui.getSettingsFolder());
      indexer.parseIndex();
      indexer.setLibrariesFolders(BaseNoGui.getLibrariesFolders());
      indexer.rescanLibraries();

      for (String library : parser.getLibraryToInstall().split("","")) {
        String[] libraryToInstallParts = library.split("":"");

        ContributedLibrary selected = null;
        if (libraryToInstallParts.length == 2) {
          Optional<Version> version = VersionHelper.valueOf(libraryToInstallParts[1]);
          if (!version.isPresent()) {
            System.out.println(format(tr(""Invalid version {0}""), libraryToInstallParts[1]));
            System.exit(1);
          }
          selected = indexer.getIndex().find(libraryToInstallParts[0], version.get().toString());
        } else if (libraryToInstallParts.length == 1) {
          List<ContributedLibrary> librariesByName = indexer.getIndex().find(libraryToInstallParts[0]);
          Collections.sort(librariesByName, new DownloadableContributionVersionComparator());
          if (!librariesByName.isEmpty()) {
            selected = librariesByName.get(librariesByName.size() - 1);
          }
        }
        if (selected == null) {
          System.out.println(tr(""Selected library is not available""));
          System.exit(1);
        }

        Optional<ContributedLibrary> mayInstalled = indexer.getIndex().getInstalled(libraryToInstallParts[0]);
        if (mayInstalled.isPresent() && selected.isIDEBuiltIn()) {
          System.out.println(tr(I18n
              .format(""Library {0} is available as built-in in the IDE.\nRemoving the other version {1} installed in the sketchbook..."",
                      library, mayInstalled.get().getParsedVersion())));
          libraryInstaller.remove(mayInstalled.get(), progressListener);
        } else {
          libraryInstaller.install(selected, progressListener);
        }
      }

      System.exit(0);

    } else if (parser.isVerifyOrUploadMode()) {
      // Set verbosity for command line build
      PreferencesData.setBoolean(""build.verbose"", parser.isDoVerboseBuild());
      PreferencesData.setBoolean(""upload.verbose"", parser.isDoVerboseUpload());

      // Set preserve-temp flag
      PreferencesData.setBoolean(""runtime.preserve.temp.files"", parser.isPreserveTempFiles());

      // Make sure these verbosity preferences are only for the current session
      PreferencesData.setDoSave(false);

      Sketch sketch = null;
      String outputFile = null;

      try {
        // Build
        splash.splashText(tr(""Verifying...""));

        File sketchFile = BaseNoGui.absoluteFile(parser.getFilenames().get(0));
        sketch = new Sketch(sketchFile);

        outputFile = new Compiler(sketch).build(progress -> {}, false);
      } catch (Exception e) {
        // Error during build
        e.printStackTrace();
        System.exit(1);
      }

      if (parser.isUploadMode()) {
        // Upload
        splash.splashText(tr(""Uploading...""));

        try {
          List<String> warnings = new ArrayList<>();
          UploaderUtils uploader = new UploaderUtils();
          boolean res = uploader.upload(sketch, null, outputFile,
                                        parser.isDoUseProgrammer(),
                                        parser.isNoUploadPort(), warnings);
          for (String warning : warnings) {
            System.out.println(tr(""Warning"") + "": "" + warning);
          }
          if (!res) {
            throw new Exception();
          }
        } catch (Exception e) {
          // Error during upload
          System.out.flush();
          System.err.flush();
          System.err
              .println(tr(""An error occurred while uploading the sketch""));
          System.exit(1);
        }
      }

      // No errors exit gracefully
      System.exit(0);
    } else if (parser.isGuiMode()) {
      splash.splashText(tr(""Starting...""));

      for (String path : parser.getFilenames()) {
        // Correctly resolve relative paths
        File file = absoluteFile(path);

        // Fix a problem with systems that use a non-ASCII languages. Paths are
        // being passed in with 8.3 syntax, which makes the sketch loader code
        // unhappy, since the sketch folder naming doesn't match up correctly.
        // http://dev.processing.org/bugs/show_bug.cgi?id=1089
        if (OSUtils.isWindows()) {
          try {
            file = file.getCanonicalFile();
          } catch (IOException e) {
            e.printStackTrace();
          }
        }

        if (!parser.isForceSavePrefs())
          PreferencesData.setDoSave(true);
        if (handleOpen(file, retrieveSketchLocation("".default""), false) == null) {
          String mess = format(tr(""Failed to open sketch: \""{0}\""""), path);
          // Open failure is fatal in upload/verify mode
          if (parser.isVerifyOrUploadMode())
            showError(null, mess, 2);
          else
            showWarning(null, mess, null);
        }
      }

      installKeyboardInputMap();

      // Check if there were previously opened sketches to be restored
      restoreSketches();

      // Create a new empty window (will be replaced with any files to be opened)
      if (editors.isEmpty()) {
        handleNew();
      }

      new Thread(new BuiltInCoreIsNewerCheck(this)).start();

      // Check for boards which need an additional core
      new Thread(new NewBoardListener(this)).start();

      // Check for updates
      if (PreferencesData.getBoolean(""update.check"")) {
        new UpdateCheck(this);

        contributionsSelfCheck = new ContributionsSelfCheck(this, new UpdatableBoardsLibsFakeURLsHandler(this), contributionInstaller, libraryInstaller);
        new Timer(false).schedule(contributionsSelfCheck, Constants.BOARDS_LIBS_UPDATABLE_CHECK_START_PERIOD);
      }

    } else if (parser.isNoOpMode()) {
      // Do nothing (intended for only changing preferences)
      System.exit(0);
    } else if (parser.isGetPrefMode()) {
      BaseNoGui.dumpPrefs(parser);
    } else if (parser.isVersionMode()) {
      System.out.println(""Arduino: "" + BaseNoGui.VERSION_NAME_LONG);
      System.exit(0);
    }
  }",iterator
path,"{
    Thread deleteFilesOnShutdownThread = new Thread(DeleteFilesOnShutdown.INSTANCE);
    deleteFilesOnShutdownThread.setName(""DeleteFilesOnShutdown"");
    Runtime.getRuntime().addShutdownHook(deleteFilesOnShutdownThread);

    BaseNoGui.initLogger();

    initLogger();

    BaseNoGui.initPlatform();

    BaseNoGui.getPlatform().init();

    BaseNoGui.initPortableFolder();

    // Look for a possible ""--preferences-file"" parameter and load preferences
    BaseNoGui.initParameters(args);

    CommandlineParser parser = new CommandlineParser(args);
    parser.parseArgumentsPhase1();
    commandLine = !parser.isGuiMode();

    BaseNoGui.checkInstallationFolder();

    // If no path is set, get the default sketchbook folder for this platform
    if (BaseNoGui.getSketchbookPath() == null) {
      File defaultFolder = getDefaultSketchbookFolderOrPromptForIt();
      if (BaseNoGui.getPortableFolder() != null)
        PreferencesData.set(""sketchbook.path"", BaseNoGui.getPortableSketchbookFolder());
      else
        PreferencesData.set(""sketchbook.path"", defaultFolder.getAbsolutePath());
      if (!defaultFolder.exists()) {
        defaultFolder.mkdirs();
      }
    }

    SplashScreenHelper splash;
    if (parser.isGuiMode()) {
      // Setup all notification widgets
      splash = new SplashScreenHelper(SplashScreen.getSplashScreen());
      BaseNoGui.notifier = new GUIUserNotifier(this);

      // Setup the theme coloring fun
      Theme.init();
      System.setProperty(""swing.aatext"", PreferencesData.get(""editor.antialias"", ""true""));

      // Set the look and feel before opening the window
      try {
        BaseNoGui.getPlatform().setLookAndFeel();
      } catch (Exception e) {
        // ignore
      }

      // Use native popups so they don't look so crappy on osx
      JPopupMenu.setDefaultLightWeightPopupEnabled(false);
    } else {
      splash = new SplashScreenHelper(null);
    }

    splash.splashText(tr(""Loading configuration...""));

    BaseNoGui.initVersion();

    // Don't put anything above this line that might make GUI,
    // because the platform has to be inited properly first.

    // Create a location for untitled sketches
    untitledFolder = FileUtils.createTempFolder(""untitled"" + new Random().nextInt(Integer.MAX_VALUE), "".tmp"");
    DeleteFilesOnShutdown.add(untitledFolder);

    splash.splashText(tr(""Initializing packages...""));
    BaseNoGui.initPackages();

    parser.getUploadPort().ifPresent(BaseNoGui::selectSerialPort);

    splash.splashText(tr(""Preparing boards...""));

    if (!isCommandLine()) {
      rebuildBoardsMenu();
      rebuildProgrammerMenu();
    } else {
      TargetBoard lastSelectedBoard = BaseNoGui.getTargetBoard();
      if (lastSelectedBoard != null)
        BaseNoGui.selectBoard(lastSelectedBoard);
    }

    // Setup board-dependent variables.
    onBoardOrPortChange();

    pdeKeywords = new PdeKeywords();
    pdeKeywords.reload();

    final GPGDetachedSignatureVerifier gpgDetachedSignatureVerifier = new GPGDetachedSignatureVerifier();
    contributionInstaller = new ContributionInstaller(BaseNoGui.getPlatform(), gpgDetachedSignatureVerifier);
    libraryInstaller = new LibraryInstaller(BaseNoGui.getPlatform(), gpgDetachedSignatureVerifier);

    parser.parseArgumentsPhase2();

    // Save the preferences. For GUI mode, this happens in the quit
    // handler, but for other modes we should also make sure to save
    // them.
    if (parser.isForceSavePrefs()) {
      PreferencesData.save();
    }

    if (parser.isInstallBoard()) {
      ContributionsIndexer indexer = new ContributionsIndexer(
          BaseNoGui.getSettingsFolder(), BaseNoGui.getHardwareFolder(),
          BaseNoGui.getPlatform(), gpgDetachedSignatureVerifier);
      ProgressListener progressListener = new ConsoleProgressListener();

      contributionInstaller.updateIndex(progressListener);
      indexer.parseIndex();
      indexer.syncWithFilesystem();

      String[] boardToInstallParts = parser.getBoardToInstall().split("":"");

      ContributedPlatform selected = null;
      if (boardToInstallParts.length == 3) {
        Optional<Version> version = VersionHelper.valueOf(boardToInstallParts[2]);
        if (!version.isPresent()) {
          System.out.println(format(tr(""Invalid version {0}""), boardToInstallParts[2]));
          System.exit(1);
        }
        selected = indexer.getIndex().findPlatform(boardToInstallParts[0], boardToInstallParts[1], version.get().toString());
      } else if (boardToInstallParts.length == 2) {
        List<ContributedPlatform> platformsByName = indexer.getIndex().findPlatforms(boardToInstallParts[0], boardToInstallParts[1]);
        Collections.sort(platformsByName, new DownloadableContributionVersionComparator());
        if (!platformsByName.isEmpty()) {
          selected = platformsByName.get(platformsByName.size() - 1);
        }
      }
      if (selected == null) {
        System.out.println(tr(""Selected board is not available""));
        System.exit(1);
      }

      ContributedPlatform installed = indexer.getInstalled(boardToInstallParts[0], boardToInstallParts[1]);

      if (!selected.isBuiltIn()) {
        contributionInstaller.install(selected, progressListener);
      }

      if (installed != null && !installed.isBuiltIn()) {
        contributionInstaller.remove(installed);
      }

      System.exit(0);

    } else if (parser.isInstallLibrary()) {
      BaseNoGui.onBoardOrPortChange();

      ProgressListener progressListener = new ConsoleProgressListener();
      libraryInstaller.updateIndex(progressListener);

      LibrariesIndexer indexer = new LibrariesIndexer(BaseNoGui.getSettingsFolder());
      indexer.parseIndex();
      indexer.setLibrariesFolders(BaseNoGui.getLibrariesFolders());
      indexer.rescanLibraries();

      for (String library : parser.getLibraryToInstall().split("","")) {
        String[] libraryToInstallParts = library.split("":"");

        ContributedLibrary selected = null;
        if (libraryToInstallParts.length == 2) {
          Optional<Version> version = VersionHelper.valueOf(libraryToInstallParts[1]);
          if (!version.isPresent()) {
            System.out.println(format(tr(""Invalid version {0}""), libraryToInstallParts[1]));
            System.exit(1);
          }
          selected = indexer.getIndex().find(libraryToInstallParts[0], version.get().toString());
        } else if (libraryToInstallParts.length == 1) {
          List<ContributedLibrary> librariesByName = indexer.getIndex().find(libraryToInstallParts[0]);
          Collections.sort(librariesByName, new DownloadableContributionVersionComparator());
          if (!librariesByName.isEmpty()) {
            selected = librariesByName.get(librariesByName.size() - 1);
          }
        }
        if (selected == null) {
          System.out.println(tr(""Selected library is not available""));
          System.exit(1);
        }

        Optional<ContributedLibrary> mayInstalled = indexer.getIndex().getInstalled(libraryToInstallParts[0]);
        if (mayInstalled.isPresent() && selected.isIDEBuiltIn()) {
          System.out.println(tr(I18n
              .format(""Library {0} is available as built-in in the IDE.\nRemoving the other version {1} installed in the sketchbook..."",
                      library, mayInstalled.get().getParsedVersion())));
          libraryInstaller.remove(mayInstalled.get(), progressListener);
        } else {
          libraryInstaller.install(selected, progressListener);
        }
      }

      System.exit(0);

    } else if (parser.isVerifyOrUploadMode()) {
      // Set verbosity for command line build
      PreferencesData.setBoolean(""build.verbose"", parser.isDoVerboseBuild());
      PreferencesData.setBoolean(""upload.verbose"", parser.isDoVerboseUpload());

      // Set preserve-temp flag
      PreferencesData.setBoolean(""runtime.preserve.temp.files"", parser.isPreserveTempFiles());

      // Make sure these verbosity preferences are only for the current session
      PreferencesData.setDoSave(false);

      Sketch sketch = null;
      String outputFile = null;

      try {
        // Build
        splash.splashText(tr(""Verifying...""));

        File sketchFile = BaseNoGui.absoluteFile(parser.getFilenames().get(0));
        sketch = new Sketch(sketchFile);

        outputFile = new Compiler(sketch).build(progress -> {}, false);
      } catch (Exception e) {
        // Error during build
        e.printStackTrace();
        System.exit(1);
      }

      if (parser.isUploadMode()) {
        // Upload
        splash.splashText(tr(""Uploading...""));

        try {
          List<String> warnings = new ArrayList<>();
          UploaderUtils uploader = new UploaderUtils();
          boolean res = uploader.upload(sketch, null, outputFile,
                                        parser.isDoUseProgrammer(),
                                        parser.isNoUploadPort(), warnings);
          for (String warning : warnings) {
            System.out.println(tr(""Warning"") + "": "" + warning);
          }
          if (!res) {
            throw new Exception();
          }
        } catch (Exception e) {
          // Error during upload
          System.out.flush();
          System.err.flush();
          System.err
              .println(tr(""An error occurred while uploading the sketch""));
          System.exit(1);
        }
      }

      // No errors exit gracefully
      System.exit(0);
    } else if (parser.isGuiMode()) {
      splash.splashText(tr(""Starting...""));

      for (String path : parser.getFilenames()) {
        // Correctly resolve relative paths
        File file = absoluteFile(path);

        // Fix a problem with systems that use a non-ASCII languages. Paths are
        // being passed in with 8.3 syntax, which makes the sketch loader code
        // unhappy, since the sketch folder naming doesn't match up correctly.
        // http://dev.processing.org/bugs/show_bug.cgi?id=1089
        if (OSUtils.isWindows()) {
          try {
            file = file.getCanonicalFile();
          } catch (IOException e) {
            e.printStackTrace();
          }
        }

        if (!parser.isForceSavePrefs())
          PreferencesData.setDoSave(true);
        if (handleOpen(file, retrieveSketchLocation("".default""), false) == null) {
          String mess = format(tr(""Failed to open sketch: \""{0}\""""), path);
          // Open failure is fatal in upload/verify mode
          if (parser.isVerifyOrUploadMode())
            showError(null, mess, 2);
          else
            showWarning(null, mess, null);
        }
      }

      installKeyboardInputMap();

      // Check if there were previously opened sketches to be restored
      restoreSketches();

      // Create a new empty window (will be replaced with any files to be opened)
      if (editors.isEmpty()) {
        handleNew();
      }

      new Thread(new BuiltInCoreIsNewerCheck(this)).start();

      // Check for boards which need an additional core
      new Thread(new NewBoardListener(this)).start();

      // Check for updates
      if (PreferencesData.getBoolean(""update.check"")) {
        new UpdateCheck(this);

        contributionsSelfCheck = new ContributionsSelfCheck(this, new UpdatableBoardsLibsFakeURLsHandler(this), contributionInstaller, libraryInstaller);
        new Timer(false).schedule(contributionsSelfCheck, Constants.BOARDS_LIBS_UPDATABLE_CHECK_START_PERIOD);
      }

    } else if (parser.isNoOpMode()) {
      // Do nothing (intended for only changing preferences)
      System.exit(0);
    } else if (parser.isGetPrefMode()) {
      BaseNoGui.dumpPrefs(parser);
    } else if (parser.isVersionMode()) {
      System.out.println(""Arduino: "" + BaseNoGui.VERSION_NAME_LONG);
      System.exit(0);
    }
  }",iterator
i,"{
    // Iterate through all sketches that were open last time p5 was running.
    // If !windowPositionValid, then ignore the coordinates found for each.

    // Save the sketch path and window placement for each open sketch
    int count = PreferencesData.getInteger(""last.sketch.count"");
    int opened = 0;
    for (int i = count - 1; i >= 0; i--) {
      String path = PreferencesData.get(""last.sketch"" + i + "".path"");
      if (path == null) {
        continue;
      }
      if (BaseNoGui.getPortableFolder() != null && !new File(path).isAbsolute()) {
        File absolute = new File(BaseNoGui.getPortableFolder(), path);
        try {
          path = absolute.getCanonicalPath();
        } catch (IOException e) {
          // path unchanged.
        }
      }
      int[] location = retrieveSketchLocation("""" + i);
      // If file did not exist, null will be returned for the Editor
      if (handleOpen(new File(path), location, nextEditorLocation(), false, false) != null) {
        opened++;
      }
    }
    return (opened > 0);
  }",loop_control
editor,"{

    // If there is only one sketch opened save his position as default
    if (editors.size() == 1) {
      storeSketchLocation(editors.get(0), "".default"");
    }

    // Save the sketch path and window placement for each open sketch
    String untitledPath = untitledFolder.getAbsolutePath();
    List<Editor> reversedEditors = new LinkedList<>(editors);
    Collections.reverse(reversedEditors);
    int index = 0;
    for (Editor editor : reversedEditors) {
      Sketch sketch = editor.getSketch();
      String path = sketch.getMainFilePath();
      // Skip untitled sketches if they do not contains changes.
      if (path.startsWith(untitledPath) && !sketch.isModified()) {
        continue;
      }
      storeSketchLocation(editor, """" + index);
      index++;
    }
    PreferencesData.setInteger(""last.sketch.count"", index);
  }",iterator
index,"{
    File newbieDir = null;
    String newbieName = null;

    // In 0126, untitled sketches will begin in the temp folder,
    // and then moved to a new location because Save will default to Save As.
    File sketchbookDir = BaseNoGui.getSketchbookFolder();
    File newbieParentDir = untitledFolder;

    // Use a generic name like sketch_031008a, the date plus a char
    int index = 0;
    //SimpleDateFormat formatter = new SimpleDateFormat(""yyMMdd"");
    //SimpleDateFormat formatter = new SimpleDateFormat(""MMMdd"");
    //String purty = formatter.format(new Date()).toLowerCase();
    Calendar cal = Calendar.getInstance();
    int day = cal.get(Calendar.DAY_OF_MONTH);  // 1..31
    int month = cal.get(Calendar.MONTH);  // 0..11
    String purty = months[month] + PApplet.nf(day, 2);

    do {
      if (index == 26*26) {
        // In 0166, avoid running past zz by sending people outdoors.
        if (!breakTime) {
          showWarning(tr(""Time for a Break""),
                  tr(""You've reached the limit for auto naming of new sketches\n"" +
                          ""for the day. How about going for a walk instead?""), null);
          breakTime = true;
        } else {
          showWarning(tr(""Sunshine""),
                  tr(""No really, time for some fresh air for you.""), null);
        }
        return null;
      }

      int multiples = index / 26;

      if(multiples > 0){
        newbieName = ((char) ('a' + (multiples-1))) + """" + ((char) ('a' + (index % 26))) + """";
      }else{
        newbieName = ((char) ('a' + index)) + """";
      }
      newbieName = ""sketch_"" + purty + newbieName;
      newbieDir = new File(newbieParentDir, newbieName);
      index++;
      // Make sure it's not in the temp folder *and* it's not in the sketchbook
    } while (newbieDir.exists() || new File(sketchbookDir, newbieName).exists());

    // Make the directory for the new sketch
    newbieDir.mkdirs();

    // Make an empty pde file
    File newbieFile = new File(newbieDir, newbieName + "".ino"");
    if (!newbieFile.createNewFile()) {
      throw new IOException();
    }

    // Initialize the pde file with the BareMinimum sketch.
    // Apply user-defined tab settings.
    String sketch = FileUtils.readFileToString(
        new File(getContentFile(""examples""), ""01.Basics"" + File.separator
            + ""BareMinimum"" + File.separator + ""BareMinimum.ino""));
    String currentTab = ""  "";
    String newTab = (PreferencesData.getBoolean(""editor.tabs.expand"")
        ? StringUtils.repeat("" "",
            PreferencesData.getInteger(""editor.tabs.size""))
        : ""\t"");
    sketch = sketch.replaceAll(
        ""(?<=(^|\n)("" + currentTab + ""){0,50})"" + currentTab, newTab);
    FileUtils.writeStringToFile(newbieFile, sketch);
    return newbieFile;
  }",break_loop_control
newbieDir,"{
    File newbieDir = null;
    String newbieName = null;

    // In 0126, untitled sketches will begin in the temp folder,
    // and then moved to a new location because Save will default to Save As.
    File sketchbookDir = BaseNoGui.getSketchbookFolder();
    File newbieParentDir = untitledFolder;

    // Use a generic name like sketch_031008a, the date plus a char
    int index = 0;
    //SimpleDateFormat formatter = new SimpleDateFormat(""yyMMdd"");
    //SimpleDateFormat formatter = new SimpleDateFormat(""MMMdd"");
    //String purty = formatter.format(new Date()).toLowerCase();
    Calendar cal = Calendar.getInstance();
    int day = cal.get(Calendar.DAY_OF_MONTH);  // 1..31
    int month = cal.get(Calendar.MONTH);  // 0..11
    String purty = months[month] + PApplet.nf(day, 2);

    do {
      if (index == 26*26) {
        // In 0166, avoid running past zz by sending people outdoors.
        if (!breakTime) {
          showWarning(tr(""Time for a Break""),
                  tr(""You've reached the limit for auto naming of new sketches\n"" +
                          ""for the day. How about going for a walk instead?""), null);
          breakTime = true;
        } else {
          showWarning(tr(""Sunshine""),
                  tr(""No really, time for some fresh air for you.""), null);
        }
        return null;
      }

      int multiples = index / 26;

      if(multiples > 0){
        newbieName = ((char) ('a' + (multiples-1))) + """" + ((char) ('a' + (index % 26))) + """";
      }else{
        newbieName = ((char) ('a' + index)) + """";
      }
      newbieName = ""sketch_"" + purty + newbieName;
      newbieDir = new File(newbieParentDir, newbieName);
      index++;
      // Make sure it's not in the temp folder *and* it's not in the sketchbook
    } while (newbieDir.exists() || new File(sketchbookDir, newbieName).exists());

    // Make the directory for the new sketch
    newbieDir.mkdirs();

    // Make an empty pde file
    File newbieFile = new File(newbieDir, newbieName + "".ino"");
    if (!newbieFile.createNewFile()) {
      throw new IOException();
    }

    // Initialize the pde file with the BareMinimum sketch.
    // Apply user-defined tab settings.
    String sketch = FileUtils.readFileToString(
        new File(getContentFile(""examples""), ""01.Basics"" + File.separator
            + ""BareMinimum"" + File.separator + ""BareMinimum.ino""));
    String currentTab = ""  "";
    String newTab = (PreferencesData.getBoolean(""editor.tabs.expand"")
        ? StringUtils.repeat("" "",
            PreferencesData.getInteger(""editor.tabs.size""))
        : ""\t"");
    sketch = sketch.replaceAll(
        ""(?<=(^|\n)("" + currentTab + ""){0,50})"" + currentTab, newTab);
    FileUtils.writeStringToFile(newbieFile, sketch);
    return newbieFile;
  }",maybe_loop_control
editor,"{
    if (!file.exists()) return null;

    // Cycle through open windows to make sure that it's not already open.
    for (Editor editor : editors) {
      if (editor.getSketch().getPrimaryFile().getFile().equals(file)) {
        editor.toFront();
        return editor;
      }
    }

    Editor editor = new Editor(this, file, storedLocation, defaultLocation, BaseNoGui.getPlatform());

    // Make sure that the sketch actually loaded
    if (editor.getSketchController() == null) {
      return null;  // Just walk away quietly
    }

    editor.untitled = untitled;

    editors.add(editor);

    if (storeOpenedSketches) {
      // Store information on who's open and running
      // (in case there's a crash or something that can't be recovered)
      storeSketches();
      storeRecentSketches(editor.getSketchController());
      rebuildRecentSketchesMenuItems();
      PreferencesData.save();
    }

    // now that we're ready, show the window
    // (don't do earlier, cuz we might move it based on a window being closed)
    SwingUtilities.invokeLater(() -> editor.setVisible(true));

    return editor;
  }",iterator
editor,"{
    if (!file.exists()) return null;

    // Cycle through open windows to make sure that it's not already open.
    for (Editor editor : editors) {
      if (editor.getSketch().getPrimaryFile().getFile().equals(file)) {
        editor.toFront();
        return editor;
      }
    }

    Editor editor = new Editor(this, file, storedLocation, defaultLocation, BaseNoGui.getPlatform());

    // Make sure that the sketch actually loaded
    if (editor.getSketchController() == null) {
      return null;  // Just walk away quietly
    }

    editor.untitled = untitled;

    editors.add(editor);

    if (storeOpenedSketches) {
      // Store information on who's open and running
      // (in case there's a crash or something that can't be recovered)
      storeSketches();
      storeRecentSketches(editor.getSketchController());
      rebuildRecentSketchesMenuItems();
      PreferencesData.save();
    }

    // now that we're ready, show the window
    // (don't do earlier, cuz we might move it based on a window being closed)
    SwingUtilities.invokeLater(() -> editor.setVisible(true));

    return editor;
  }",break_loop_control
path,"{
    Set<File> recentSketches = new LinkedHashSet<File>() {

      @Override
      public boolean add(File file) {
        if (size() >= RECENT_SKETCHES_MAX_SIZE) {
          return false;
        }
        return super.add(file);
      }
    };

    for (String path : PreferencesData.getCollection(""recent.sketches"")) {
      File file = new File(path);
      if (file.exists()) {
        recentSketches.add(file);
      }
    }

    recentSketchesMenuItems.clear();
    for (final File recentSketch : recentSketches) {
      JMenuItem recentSketchMenuItem = new JMenuItem(recentSketch.getParentFile().getName());
      recentSketchMenuItem.addActionListener(new ActionListener() {
        @Override
        public void actionPerformed(ActionEvent actionEvent) {
          try {
            handleOpen(recentSketch);
          } catch (Exception e) {
            e.printStackTrace();
          }
        }
      });
      recentSketchesMenuItems.add(recentSketchMenuItem);
    }
  }",iterator
recentSketch,"{
    Set<File> recentSketches = new LinkedHashSet<File>() {

      @Override
      public boolean add(File file) {
        if (size() >= RECENT_SKETCHES_MAX_SIZE) {
          return false;
        }
        return super.add(file);
      }
    };

    for (String path : PreferencesData.getCollection(""recent.sketches"")) {
      File file = new File(path);
      if (file.exists()) {
        recentSketches.add(file);
      }
    }

    recentSketchesMenuItems.clear();
    for (final File recentSketch : recentSketches) {
      JMenuItem recentSketchMenuItem = new JMenuItem(recentSketch.getParentFile().getName());
      recentSketchMenuItem.addActionListener(new ActionListener() {
        @Override
        public void actionPerformed(ActionEvent actionEvent) {
          try {
            handleOpen(recentSketch);
          } catch (Exception e) {
            e.printStackTrace();
          }
        }
      });
      recentSketchesMenuItems.add(recentSketchMenuItem);
    }
  }",iterator
editor,"{
    for (Editor editor : editors) {
      if (!editor.checkModified()) {
        return false;
      }
    }
    return true;
  }",iterator
editor,"{
    for (Editor editor : editors) {
      if (!editor.checkModified()) {
        return false;
      }
    }
    return true;
  }",break_loop_control
lib,"{
    if (importMenu == null)
      return;
    importMenu.removeAll();

    JMenuItem menu = new JMenuItem(tr(""Manage Libraries...""));
    // Ctrl+Shift+I on Windows and Linux, Command+Shift+I on macOS
    menu.setAccelerator(KeyStroke.getKeyStroke('I',
        Toolkit.getDefaultToolkit().getMenuShortcutKeyMask() |
        ActionEvent.SHIFT_MASK));
    menu.addActionListener(e -> openLibraryManager("""", """"));
    importMenu.add(menu);
    importMenu.addSeparator();

    JMenuItem addLibraryMenuItem = new JMenuItem(tr(""Add .ZIP Library...""));
    addLibraryMenuItem.addActionListener(new ActionListener() {
      public void actionPerformed(ActionEvent e) {
        Base.this.handleAddLibrary();
        BaseNoGui.librariesIndexer.rescanLibraries();
        Base.this.onBoardOrPortChange();
        Base.this.rebuildImportMenu(Editor.importMenu);
        Base.this.rebuildExamplesMenu(Editor.examplesMenu);
      }
    });
    importMenu.add(addLibraryMenuItem);
    importMenu.addSeparator();

    // Split between user supplied libraries and IDE libraries
    TargetPlatform targetPlatform = BaseNoGui.getTargetPlatform();

    if (targetPlatform != null) {
      LibraryList libs = getSortedLibraries();
      String lastLibType = null;
      for (UserLibrary lib : libs) {
        String libType = lib.getTypes().get(0);
        if (!libType.equals(lastLibType)) {
          if (lastLibType != null) {
            importMenu.addSeparator();
          }
          lastLibType = libType;
          JMenuItem platformItem = new JMenuItem(format(tr(""{0} libraries""), tr(lastLibType)));
          platformItem.setEnabled(false);
          importMenu.add(platformItem);
        }

        AbstractAction action = new AbstractAction(lib.getName()) {
          public void actionPerformed(ActionEvent event) {
            UserLibrary l = (UserLibrary) getValue(""library"");
            try {
              activeEditor.getSketchController().importLibrary(l);
            } catch (IOException e) {
              showWarning(tr(""Error""), format(""Unable to list header files in {0}"", l.getSrcFolder()), e);
            }
          }
        };
        action.putValue(""library"", lib);

        // Add new element at the bottom
        JMenuItem item = new JMenuItem(action);
        item.putClientProperty(""library"", lib);
        importMenu.add(item);
      }
    }
  }",iterator
lib,"{
    if (menu == null) {
      return;
    }

    menu.removeAll();

    // Add examples from distribution ""example"" folder
    JMenuItem label = new JMenuItem(tr(""Built-in Examples""));
    label.setEnabled(false);
    menu.add(label);
    boolean found = addSketches(menu, BaseNoGui.getExamplesFolder());
    if (found) {
      menu.addSeparator();
    }

    // Libraries can come from 4 locations: collect info about all four
    String boardId = null;
    String referencedPlatformName = null;
    String myArch = null;
    TargetPlatform targetPlatform = BaseNoGui.getTargetPlatform();
    if (targetPlatform != null) {
      myArch = targetPlatform.getId();
      boardId = BaseNoGui.getTargetBoard().getName();
      String core = BaseNoGui.getBoardPreferences().get(""build.core"", ""arduino"");
      if (core.contains("":"")) {
        String refcore = core.split("":"")[0];
        TargetPlatform referencedPlatform = BaseNoGui.getTargetPlatform(refcore, myArch);
        if (referencedPlatform != null) {
          referencedPlatformName = referencedPlatform.getPreferences().get(""name"");
        }
      }
    }

    // Divide the libraries into 7 lists, corresponding to the 4 locations
    // with the retired IDE libs further divided into their own list, and
    // any incompatible sketchbook libs further divided into their own list.
    // The 7th list of ""other"" libraries should always be empty, but serves
    // as a safety feature to prevent any library from vanishing.
    LibraryList allLibraries = BaseNoGui.librariesIndexer.getInstalledLibraries();
    LibraryList ideLibs = new LibraryList();
    LibraryList retiredIdeLibs = new LibraryList();
    LibraryList platformLibs = new LibraryList();
    LibraryList referencedPlatformLibs = new LibraryList();
    LibraryList sketchbookLibs = new LibraryList();
    LibraryList sketchbookIncompatibleLibs = new LibraryList();
    LibraryList otherLibs = new LibraryList();
    for (UserLibrary lib : allLibraries) {
      // Get the library's location - used for sorting into categories
      Location location = lib.getLocation();
      // Is this library compatible?
      List<String> arch = lib.getArchitectures();
      boolean compatible;
      if (myArch == null || arch == null || arch.contains(""*"")) {
        compatible = true;
      } else {
        compatible = arch.contains(myArch);
      }
      // IDE Libaries (including retired)
      if (location == Location.IDE_BUILTIN) {
        if (compatible) {
          // only compatible IDE libs are shown
          if (lib.getTypes().contains(""Retired"")) {
            retiredIdeLibs.add(lib);
          } else {
            ideLibs.add(lib);
          }
        }
      // Platform Libraries
      } else if (location == Location.CORE) {
        // all platform libs are assumed to be compatible
        platformLibs.add(lib);
      // Referenced Platform Libraries
      } else if (location == Location.REFERENCED_CORE) {
        // all referenced platform libs are assumed to be compatible
        referencedPlatformLibs.add(lib);
      // Sketchbook Libraries (including incompatible)
      } else if (location == Location.SKETCHBOOK) {
        if (compatible) {
          // libraries promoted from sketchbook (behave as builtin)
          if (!lib.getTypes().isEmpty() && lib.getTypes().contains(""Arduino"")
              && lib.getArchitectures().contains(""*"")) {
            ideLibs.add(lib);
          } else {
            sketchbookLibs.add(lib);
          }
        } else {
          sketchbookIncompatibleLibs.add(lib);
        }
      // Other libraries of unknown type (should never occur)
      } else {
        otherLibs.add(lib);
      }
    }

    // Add examples from libraries
    if (!ideLibs.isEmpty()) {
      ideLibs.sort();
      label = new JMenuItem(tr(""Examples for any board""));
      label.setEnabled(false);
      menu.add(label);
    }
    for (UserLibrary lib : ideLibs) {
      addSketchesSubmenu(menu, lib);
    }

    if (!retiredIdeLibs.isEmpty()) {
      retiredIdeLibs.sort();
      JMenu retired = new JMenu(tr(""RETIRED""));
      menu.add(retired);
      for (UserLibrary lib : retiredIdeLibs) {
        addSketchesSubmenu(retired, lib);
      }
    }

    if (!platformLibs.isEmpty()) {
      menu.addSeparator();
      platformLibs.sort();
      label = new JMenuItem(format(tr(""Examples for {0}""), boardId));
      label.setEnabled(false);
      menu.add(label);
      for (UserLibrary lib : platformLibs) {
        addSketchesSubmenu(menu, lib);
      }
    }

    if (!referencedPlatformLibs.isEmpty()) {
      menu.addSeparator();
      referencedPlatformLibs.sort();
      label = new JMenuItem(format(tr(""Examples for {0}""), referencedPlatformName));
      label.setEnabled(false);
      menu.add(label);
      for (UserLibrary lib : referencedPlatformLibs) {
        addSketchesSubmenu(menu, lib);
      }
    }

    if (!sketchbookLibs.isEmpty()) {
      menu.addSeparator();
      sketchbookLibs.sort();
      label = new JMenuItem(tr(""Examples from Custom Libraries""));
      label.setEnabled(false);
      menu.add(label);
      for (UserLibrary lib : sketchbookLibs) {
        addSketchesSubmenu(menu, lib);
      }
    }

    if (!sketchbookIncompatibleLibs.isEmpty()) {
      sketchbookIncompatibleLibs.sort();
      JMenu incompatible = new JMenu(tr(""INCOMPATIBLE""));
      MenuScroller.setScrollerFor(incompatible);
      menu.add(incompatible);
      for (UserLibrary lib : sketchbookIncompatibleLibs) {
        addSketchesSubmenu(incompatible, lib);
      }
    }

    if (!otherLibs.isEmpty()) {
      menu.addSeparator();
      otherLibs.sort();
      label = new JMenuItem(tr(""Examples from Other Libraries""));
      label.setEnabled(false);
      menu.add(label);
      for (UserLibrary lib : otherLibs) {
        addSketchesSubmenu(menu, lib);
      }
    }
  }",iterator
editor,"{
    BaseNoGui.onBoardOrPortChange();

    // reload keywords when package/platform changes
    TargetPlatform tp = BaseNoGui.getTargetPlatform();
    if (tp != null) {
      String platformFolder = tp.getFolder().getAbsolutePath();
      if (priorPlatformFolder == null || !priorPlatformFolder.equals(platformFolder) || newLibraryImported) {
        pdeKeywords = new PdeKeywords();
        pdeKeywords.reload();
        priorPlatformFolder = platformFolder;
        newLibraryImported = false;
        for (Editor editor : editors) {
          editor.updateKeywords(pdeKeywords);
        }
      }
    }

    // Update editors status bar
    for (Editor editor : editors) {
      editor.onBoardOrPortChange();
    }
  }",iterator
targetPlatform,"{
    boardsCustomMenus = new LinkedList<>();

    // The first custom menu is the ""Board"" selection submenu
    JMenu boardMenu = new JMenu(tr(""Board""));
    boardMenu.putClientProperty(""removeOnWindowDeactivation"", true);
    MenuScroller.setScrollerFor(boardMenu).setTopFixedCount(1);

    boardMenu.add(new JMenuItem(new AbstractAction(tr(""Boards Manager..."")) {
      public void actionPerformed(ActionEvent actionevent) {
        String filterText = """";
        String dropdownItem = """";
        if (actionevent instanceof Event) {
          Event e = ((Event) actionevent);
          filterText = e.getPayload().get(""filterText"").toString();
          dropdownItem = e.getPayload().get(""dropdownItem"").toString();
        }
        try {
          openBoardsManager(filterText, dropdownItem);
        } catch (Exception e) {
          //TODO show error
          e.printStackTrace();
        }
      }
    }));
    boardsCustomMenus.add(boardMenu);

    // If there are no platforms installed we are done
    if (BaseNoGui.packages.size() == 0)
      return;

    // Separate ""Install boards..."" command from installed boards
    boardMenu.add(new JSeparator());

    // Generate custom menus for all platforms
    for (TargetPackage targetPackage : BaseNoGui.packages.values()) {
      for (TargetPlatform targetPlatform : targetPackage.platforms()) {
        for (String customMenuTitle : targetPlatform.getCustomMenus().values()) {
          JMenu customMenu = new JMenu(tr(customMenuTitle));
          customMenu.putClientProperty(""platform"", getPlatformUniqueId(targetPlatform));
          customMenu.putClientProperty(""removeOnWindowDeactivation"", true);
          boardsCustomMenus.add(customMenu);
          MenuScroller.setScrollerFor(customMenu);
        }
      }
    }

    List<JMenuItem> menuItemsToClickAfterStartup = new LinkedList<>();

    ButtonGroup boardsButtonGroup = new ButtonGroup();
    Map<String, ButtonGroup> buttonGroupsMap = new HashMap<>();

    List<JMenu> platformMenus = new ArrayList<>();

    // Cycle through all packages
    for (TargetPackage targetPackage : BaseNoGui.packages.values()) {
      // For every package cycle through all platform
      for (TargetPlatform targetPlatform : targetPackage.platforms()) {

        // Add a title for each platform
        String platformLabel = targetPlatform.getPreferences().get(""name"");
        if (platformLabel == null)
          platformLabel = targetPackage.getId() + ""-"" + targetPlatform.getId();

        // add an hint that this core lives in sketchbook
        if (targetPlatform.isInSketchbook())
          platformLabel += "" (in sketchbook)"";

        JMenu platformBoardsMenu = new JMenu(platformLabel);
        MenuScroller.setScrollerFor(platformBoardsMenu);
        platformMenus.add(platformBoardsMenu);

        // Cycle through all boards of this platform
        for (TargetBoard board : targetPlatform.getBoards().values()) {
          if (board.getPreferences().get(""hide"") != null)
            continue;
          JMenuItem item = createBoardMenusAndCustomMenus(boardsCustomMenus, menuItemsToClickAfterStartup,
                  buttonGroupsMap,
                  board, targetPlatform, targetPackage);
          platformBoardsMenu.add(item);
          boardsButtonGroup.add(item);
        }
      }
    }

    platformMenus.sort((x,y) -> x.getText().compareToIgnoreCase(y.getText()));

    JMenuItem firstBoardItem = null;
    if (platformMenus.size() == 1) {
      // When just one platform exists, add the board items directly,
      // rather than using a submenu
      for (Component boardItem : platformMenus.get(0).getMenuComponents()) {
        boardMenu.add(boardItem);
        if (firstBoardItem == null)
          firstBoardItem = (JMenuItem)boardItem;
      }
    } else {
      // For multiple platforms, use submenus
      for (JMenu platformMenu : platformMenus) {
        if (firstBoardItem == null && platformMenu.getItemCount() > 0)
          firstBoardItem = platformMenu.getItem(0);
        boardMenu.add(platformMenu);
      }
    }

    if (firstBoardItem == null) {
      throw new IllegalStateException(""No available boards"");
    }

    // If there is no current board yet (first startup, or selected
    // board no longer defined), select first available board.
    if (menuItemsToClickAfterStartup.isEmpty()) {
      menuItemsToClickAfterStartup.add(firstBoardItem);
    }

    for (JMenuItem menuItemToClick : menuItemsToClickAfterStartup) {
      menuItemToClick.setSelected(true);
      menuItemToClick.getAction().actionPerformed(new ActionEvent(this, -1, """"));
    }
  }",iterator
targetPackage,"{
    boardsCustomMenus = new LinkedList<>();

    // The first custom menu is the ""Board"" selection submenu
    JMenu boardMenu = new JMenu(tr(""Board""));
    boardMenu.putClientProperty(""removeOnWindowDeactivation"", true);
    MenuScroller.setScrollerFor(boardMenu).setTopFixedCount(1);

    boardMenu.add(new JMenuItem(new AbstractAction(tr(""Boards Manager..."")) {
      public void actionPerformed(ActionEvent actionevent) {
        String filterText = """";
        String dropdownItem = """";
        if (actionevent instanceof Event) {
          Event e = ((Event) actionevent);
          filterText = e.getPayload().get(""filterText"").toString();
          dropdownItem = e.getPayload().get(""dropdownItem"").toString();
        }
        try {
          openBoardsManager(filterText, dropdownItem);
        } catch (Exception e) {
          //TODO show error
          e.printStackTrace();
        }
      }
    }));
    boardsCustomMenus.add(boardMenu);

    // If there are no platforms installed we are done
    if (BaseNoGui.packages.size() == 0)
      return;

    // Separate ""Install boards..."" command from installed boards
    boardMenu.add(new JSeparator());

    // Generate custom menus for all platforms
    for (TargetPackage targetPackage : BaseNoGui.packages.values()) {
      for (TargetPlatform targetPlatform : targetPackage.platforms()) {
        for (String customMenuTitle : targetPlatform.getCustomMenus().values()) {
          JMenu customMenu = new JMenu(tr(customMenuTitle));
          customMenu.putClientProperty(""platform"", getPlatformUniqueId(targetPlatform));
          customMenu.putClientProperty(""removeOnWindowDeactivation"", true);
          boardsCustomMenus.add(customMenu);
          MenuScroller.setScrollerFor(customMenu);
        }
      }
    }

    List<JMenuItem> menuItemsToClickAfterStartup = new LinkedList<>();

    ButtonGroup boardsButtonGroup = new ButtonGroup();
    Map<String, ButtonGroup> buttonGroupsMap = new HashMap<>();

    List<JMenu> platformMenus = new ArrayList<>();

    // Cycle through all packages
    for (TargetPackage targetPackage : BaseNoGui.packages.values()) {
      // For every package cycle through all platform
      for (TargetPlatform targetPlatform : targetPackage.platforms()) {

        // Add a title for each platform
        String platformLabel = targetPlatform.getPreferences().get(""name"");
        if (platformLabel == null)
          platformLabel = targetPackage.getId() + ""-"" + targetPlatform.getId();

        // add an hint that this core lives in sketchbook
        if (targetPlatform.isInSketchbook())
          platformLabel += "" (in sketchbook)"";

        JMenu platformBoardsMenu = new JMenu(platformLabel);
        MenuScroller.setScrollerFor(platformBoardsMenu);
        platformMenus.add(platformBoardsMenu);

        // Cycle through all boards of this platform
        for (TargetBoard board : targetPlatform.getBoards().values()) {
          if (board.getPreferences().get(""hide"") != null)
            continue;
          JMenuItem item = createBoardMenusAndCustomMenus(boardsCustomMenus, menuItemsToClickAfterStartup,
                  buttonGroupsMap,
                  board, targetPlatform, targetPackage);
          platformBoardsMenu.add(item);
          boardsButtonGroup.add(item);
        }
      }
    }

    platformMenus.sort((x,y) -> x.getText().compareToIgnoreCase(y.getText()));

    JMenuItem firstBoardItem = null;
    if (platformMenus.size() == 1) {
      // When just one platform exists, add the board items directly,
      // rather than using a submenu
      for (Component boardItem : platformMenus.get(0).getMenuComponents()) {
        boardMenu.add(boardItem);
        if (firstBoardItem == null)
          firstBoardItem = (JMenuItem)boardItem;
      }
    } else {
      // For multiple platforms, use submenus
      for (JMenu platformMenu : platformMenus) {
        if (firstBoardItem == null && platformMenu.getItemCount() > 0)
          firstBoardItem = platformMenu.getItem(0);
        boardMenu.add(platformMenu);
      }
    }

    if (firstBoardItem == null) {
      throw new IllegalStateException(""No available boards"");
    }

    // If there is no current board yet (first startup, or selected
    // board no longer defined), select first available board.
    if (menuItemsToClickAfterStartup.isEmpty()) {
      menuItemsToClickAfterStartup.add(firstBoardItem);
    }

    for (JMenuItem menuItemToClick : menuItemsToClickAfterStartup) {
      menuItemToClick.setSelected(true);
      menuItemToClick.getAction().actionPerformed(new ActionEvent(this, -1, """"));
    }
  }",iterator
platformMenu,"{
    boardsCustomMenus = new LinkedList<>();

    // The first custom menu is the ""Board"" selection submenu
    JMenu boardMenu = new JMenu(tr(""Board""));
    boardMenu.putClientProperty(""removeOnWindowDeactivation"", true);
    MenuScroller.setScrollerFor(boardMenu).setTopFixedCount(1);

    boardMenu.add(new JMenuItem(new AbstractAction(tr(""Boards Manager..."")) {
      public void actionPerformed(ActionEvent actionevent) {
        String filterText = """";
        String dropdownItem = """";
        if (actionevent instanceof Event) {
          Event e = ((Event) actionevent);
          filterText = e.getPayload().get(""filterText"").toString();
          dropdownItem = e.getPayload().get(""dropdownItem"").toString();
        }
        try {
          openBoardsManager(filterText, dropdownItem);
        } catch (Exception e) {
          //TODO show error
          e.printStackTrace();
        }
      }
    }));
    boardsCustomMenus.add(boardMenu);

    // If there are no platforms installed we are done
    if (BaseNoGui.packages.size() == 0)
      return;

    // Separate ""Install boards..."" command from installed boards
    boardMenu.add(new JSeparator());

    // Generate custom menus for all platforms
    for (TargetPackage targetPackage : BaseNoGui.packages.values()) {
      for (TargetPlatform targetPlatform : targetPackage.platforms()) {
        for (String customMenuTitle : targetPlatform.getCustomMenus().values()) {
          JMenu customMenu = new JMenu(tr(customMenuTitle));
          customMenu.putClientProperty(""platform"", getPlatformUniqueId(targetPlatform));
          customMenu.putClientProperty(""removeOnWindowDeactivation"", true);
          boardsCustomMenus.add(customMenu);
          MenuScroller.setScrollerFor(customMenu);
        }
      }
    }

    List<JMenuItem> menuItemsToClickAfterStartup = new LinkedList<>();

    ButtonGroup boardsButtonGroup = new ButtonGroup();
    Map<String, ButtonGroup> buttonGroupsMap = new HashMap<>();

    List<JMenu> platformMenus = new ArrayList<>();

    // Cycle through all packages
    for (TargetPackage targetPackage : BaseNoGui.packages.values()) {
      // For every package cycle through all platform
      for (TargetPlatform targetPlatform : targetPackage.platforms()) {

        // Add a title for each platform
        String platformLabel = targetPlatform.getPreferences().get(""name"");
        if (platformLabel == null)
          platformLabel = targetPackage.getId() + ""-"" + targetPlatform.getId();

        // add an hint that this core lives in sketchbook
        if (targetPlatform.isInSketchbook())
          platformLabel += "" (in sketchbook)"";

        JMenu platformBoardsMenu = new JMenu(platformLabel);
        MenuScroller.setScrollerFor(platformBoardsMenu);
        platformMenus.add(platformBoardsMenu);

        // Cycle through all boards of this platform
        for (TargetBoard board : targetPlatform.getBoards().values()) {
          if (board.getPreferences().get(""hide"") != null)
            continue;
          JMenuItem item = createBoardMenusAndCustomMenus(boardsCustomMenus, menuItemsToClickAfterStartup,
                  buttonGroupsMap,
                  board, targetPlatform, targetPackage);
          platformBoardsMenu.add(item);
          boardsButtonGroup.add(item);
        }
      }
    }

    platformMenus.sort((x,y) -> x.getText().compareToIgnoreCase(y.getText()));

    JMenuItem firstBoardItem = null;
    if (platformMenus.size() == 1) {
      // When just one platform exists, add the board items directly,
      // rather than using a submenu
      for (Component boardItem : platformMenus.get(0).getMenuComponents()) {
        boardMenu.add(boardItem);
        if (firstBoardItem == null)
          firstBoardItem = (JMenuItem)boardItem;
      }
    } else {
      // For multiple platforms, use submenus
      for (JMenu platformMenu : platformMenus) {
        if (firstBoardItem == null && platformMenu.getItemCount() > 0)
          firstBoardItem = platformMenu.getItem(0);
        boardMenu.add(platformMenu);
      }
    }

    if (firstBoardItem == null) {
      throw new IllegalStateException(""No available boards"");
    }

    // If there is no current board yet (first startup, or selected
    // board no longer defined), select first available board.
    if (menuItemsToClickAfterStartup.isEmpty()) {
      menuItemsToClickAfterStartup.add(firstBoardItem);
    }

    for (JMenuItem menuItemToClick : menuItemsToClickAfterStartup) {
      menuItemToClick.setSelected(true);
      menuItemToClick.getAction().actionPerformed(new ActionEvent(this, -1, """"));
    }
  }",iterator
menuItemToClick,"{
    boardsCustomMenus = new LinkedList<>();

    // The first custom menu is the ""Board"" selection submenu
    JMenu boardMenu = new JMenu(tr(""Board""));
    boardMenu.putClientProperty(""removeOnWindowDeactivation"", true);
    MenuScroller.setScrollerFor(boardMenu).setTopFixedCount(1);

    boardMenu.add(new JMenuItem(new AbstractAction(tr(""Boards Manager..."")) {
      public void actionPerformed(ActionEvent actionevent) {
        String filterText = """";
        String dropdownItem = """";
        if (actionevent instanceof Event) {
          Event e = ((Event) actionevent);
          filterText = e.getPayload().get(""filterText"").toString();
          dropdownItem = e.getPayload().get(""dropdownItem"").toString();
        }
        try {
          openBoardsManager(filterText, dropdownItem);
        } catch (Exception e) {
          //TODO show error
          e.printStackTrace();
        }
      }
    }));
    boardsCustomMenus.add(boardMenu);

    // If there are no platforms installed we are done
    if (BaseNoGui.packages.size() == 0)
      return;

    // Separate ""Install boards..."" command from installed boards
    boardMenu.add(new JSeparator());

    // Generate custom menus for all platforms
    for (TargetPackage targetPackage : BaseNoGui.packages.values()) {
      for (TargetPlatform targetPlatform : targetPackage.platforms()) {
        for (String customMenuTitle : targetPlatform.getCustomMenus().values()) {
          JMenu customMenu = new JMenu(tr(customMenuTitle));
          customMenu.putClientProperty(""platform"", getPlatformUniqueId(targetPlatform));
          customMenu.putClientProperty(""removeOnWindowDeactivation"", true);
          boardsCustomMenus.add(customMenu);
          MenuScroller.setScrollerFor(customMenu);
        }
      }
    }

    List<JMenuItem> menuItemsToClickAfterStartup = new LinkedList<>();

    ButtonGroup boardsButtonGroup = new ButtonGroup();
    Map<String, ButtonGroup> buttonGroupsMap = new HashMap<>();

    List<JMenu> platformMenus = new ArrayList<>();

    // Cycle through all packages
    for (TargetPackage targetPackage : BaseNoGui.packages.values()) {
      // For every package cycle through all platform
      for (TargetPlatform targetPlatform : targetPackage.platforms()) {

        // Add a title for each platform
        String platformLabel = targetPlatform.getPreferences().get(""name"");
        if (platformLabel == null)
          platformLabel = targetPackage.getId() + ""-"" + targetPlatform.getId();

        // add an hint that this core lives in sketchbook
        if (targetPlatform.isInSketchbook())
          platformLabel += "" (in sketchbook)"";

        JMenu platformBoardsMenu = new JMenu(platformLabel);
        MenuScroller.setScrollerFor(platformBoardsMenu);
        platformMenus.add(platformBoardsMenu);

        // Cycle through all boards of this platform
        for (TargetBoard board : targetPlatform.getBoards().values()) {
          if (board.getPreferences().get(""hide"") != null)
            continue;
          JMenuItem item = createBoardMenusAndCustomMenus(boardsCustomMenus, menuItemsToClickAfterStartup,
                  buttonGroupsMap,
                  board, targetPlatform, targetPackage);
          platformBoardsMenu.add(item);
          boardsButtonGroup.add(item);
        }
      }
    }

    platformMenus.sort((x,y) -> x.getText().compareToIgnoreCase(y.getText()));

    JMenuItem firstBoardItem = null;
    if (platformMenus.size() == 1) {
      // When just one platform exists, add the board items directly,
      // rather than using a submenu
      for (Component boardItem : platformMenus.get(0).getMenuComponents()) {
        boardMenu.add(boardItem);
        if (firstBoardItem == null)
          firstBoardItem = (JMenuItem)boardItem;
      }
    } else {
      // For multiple platforms, use submenus
      for (JMenu platformMenu : platformMenus) {
        if (firstBoardItem == null && platformMenu.getItemCount() > 0)
          firstBoardItem = platformMenu.getItem(0);
        boardMenu.add(platformMenu);
      }
    }

    if (firstBoardItem == null) {
      throw new IllegalStateException(""No available boards"");
    }

    // If there is no current board yet (first startup, or selected
    // board no longer defined), select first available board.
    if (menuItemsToClickAfterStartup.isEmpty()) {
      menuItemsToClickAfterStartup.add(firstBoardItem);
    }

    for (JMenuItem menuItemToClick : menuItemsToClickAfterStartup) {
      menuItemToClick.setSelected(true);
      menuItemToClick.getAction().actionPerformed(new ActionEvent(this, -1, """"));
    }
  }",iterator
customMenuTitle,"{
    boardsCustomMenus = new LinkedList<>();

    // The first custom menu is the ""Board"" selection submenu
    JMenu boardMenu = new JMenu(tr(""Board""));
    boardMenu.putClientProperty(""removeOnWindowDeactivation"", true);
    MenuScroller.setScrollerFor(boardMenu).setTopFixedCount(1);

    boardMenu.add(new JMenuItem(new AbstractAction(tr(""Boards Manager..."")) {
      public void actionPerformed(ActionEvent actionevent) {
        String filterText = """";
        String dropdownItem = """";
        if (actionevent instanceof Event) {
          Event e = ((Event) actionevent);
          filterText = e.getPayload().get(""filterText"").toString();
          dropdownItem = e.getPayload().get(""dropdownItem"").toString();
        }
        try {
          openBoardsManager(filterText, dropdownItem);
        } catch (Exception e) {
          //TODO show error
          e.printStackTrace();
        }
      }
    }));
    boardsCustomMenus.add(boardMenu);

    // If there are no platforms installed we are done
    if (BaseNoGui.packages.size() == 0)
      return;

    // Separate ""Install boards..."" command from installed boards
    boardMenu.add(new JSeparator());

    // Generate custom menus for all platforms
    for (TargetPackage targetPackage : BaseNoGui.packages.values()) {
      for (TargetPlatform targetPlatform : targetPackage.platforms()) {
        for (String customMenuTitle : targetPlatform.getCustomMenus().values()) {
          JMenu customMenu = new JMenu(tr(customMenuTitle));
          customMenu.putClientProperty(""platform"", getPlatformUniqueId(targetPlatform));
          customMenu.putClientProperty(""removeOnWindowDeactivation"", true);
          boardsCustomMenus.add(customMenu);
          MenuScroller.setScrollerFor(customMenu);
        }
      }
    }

    List<JMenuItem> menuItemsToClickAfterStartup = new LinkedList<>();

    ButtonGroup boardsButtonGroup = new ButtonGroup();
    Map<String, ButtonGroup> buttonGroupsMap = new HashMap<>();

    List<JMenu> platformMenus = new ArrayList<>();

    // Cycle through all packages
    for (TargetPackage targetPackage : BaseNoGui.packages.values()) {
      // For every package cycle through all platform
      for (TargetPlatform targetPlatform : targetPackage.platforms()) {

        // Add a title for each platform
        String platformLabel = targetPlatform.getPreferences().get(""name"");
        if (platformLabel == null)
          platformLabel = targetPackage.getId() + ""-"" + targetPlatform.getId();

        // add an hint that this core lives in sketchbook
        if (targetPlatform.isInSketchbook())
          platformLabel += "" (in sketchbook)"";

        JMenu platformBoardsMenu = new JMenu(platformLabel);
        MenuScroller.setScrollerFor(platformBoardsMenu);
        platformMenus.add(platformBoardsMenu);

        // Cycle through all boards of this platform
        for (TargetBoard board : targetPlatform.getBoards().values()) {
          if (board.getPreferences().get(""hide"") != null)
            continue;
          JMenuItem item = createBoardMenusAndCustomMenus(boardsCustomMenus, menuItemsToClickAfterStartup,
                  buttonGroupsMap,
                  board, targetPlatform, targetPackage);
          platformBoardsMenu.add(item);
          boardsButtonGroup.add(item);
        }
      }
    }

    platformMenus.sort((x,y) -> x.getText().compareToIgnoreCase(y.getText()));

    JMenuItem firstBoardItem = null;
    if (platformMenus.size() == 1) {
      // When just one platform exists, add the board items directly,
      // rather than using a submenu
      for (Component boardItem : platformMenus.get(0).getMenuComponents()) {
        boardMenu.add(boardItem);
        if (firstBoardItem == null)
          firstBoardItem = (JMenuItem)boardItem;
      }
    } else {
      // For multiple platforms, use submenus
      for (JMenu platformMenu : platformMenus) {
        if (firstBoardItem == null && platformMenu.getItemCount() > 0)
          firstBoardItem = platformMenu.getItem(0);
        boardMenu.add(platformMenu);
      }
    }

    if (firstBoardItem == null) {
      throw new IllegalStateException(""No available boards"");
    }

    // If there is no current board yet (first startup, or selected
    // board no longer defined), select first available board.
    if (menuItemsToClickAfterStartup.isEmpty()) {
      menuItemsToClickAfterStartup.add(firstBoardItem);
    }

    for (JMenuItem menuItemToClick : menuItemsToClickAfterStartup) {
      menuItemToClick.setSelected(true);
      menuItemToClick.getAction().actionPerformed(new ActionEvent(this, -1, """"));
    }
  }",iterator
board,"{
    boardsCustomMenus = new LinkedList<>();

    // The first custom menu is the ""Board"" selection submenu
    JMenu boardMenu = new JMenu(tr(""Board""));
    boardMenu.putClientProperty(""removeOnWindowDeactivation"", true);
    MenuScroller.setScrollerFor(boardMenu).setTopFixedCount(1);

    boardMenu.add(new JMenuItem(new AbstractAction(tr(""Boards Manager..."")) {
      public void actionPerformed(ActionEvent actionevent) {
        String filterText = """";
        String dropdownItem = """";
        if (actionevent instanceof Event) {
          Event e = ((Event) actionevent);
          filterText = e.getPayload().get(""filterText"").toString();
          dropdownItem = e.getPayload().get(""dropdownItem"").toString();
        }
        try {
          openBoardsManager(filterText, dropdownItem);
        } catch (Exception e) {
          //TODO show error
          e.printStackTrace();
        }
      }
    }));
    boardsCustomMenus.add(boardMenu);

    // If there are no platforms installed we are done
    if (BaseNoGui.packages.size() == 0)
      return;

    // Separate ""Install boards..."" command from installed boards
    boardMenu.add(new JSeparator());

    // Generate custom menus for all platforms
    for (TargetPackage targetPackage : BaseNoGui.packages.values()) {
      for (TargetPlatform targetPlatform : targetPackage.platforms()) {
        for (String customMenuTitle : targetPlatform.getCustomMenus().values()) {
          JMenu customMenu = new JMenu(tr(customMenuTitle));
          customMenu.putClientProperty(""platform"", getPlatformUniqueId(targetPlatform));
          customMenu.putClientProperty(""removeOnWindowDeactivation"", true);
          boardsCustomMenus.add(customMenu);
          MenuScroller.setScrollerFor(customMenu);
        }
      }
    }

    List<JMenuItem> menuItemsToClickAfterStartup = new LinkedList<>();

    ButtonGroup boardsButtonGroup = new ButtonGroup();
    Map<String, ButtonGroup> buttonGroupsMap = new HashMap<>();

    List<JMenu> platformMenus = new ArrayList<>();

    // Cycle through all packages
    for (TargetPackage targetPackage : BaseNoGui.packages.values()) {
      // For every package cycle through all platform
      for (TargetPlatform targetPlatform : targetPackage.platforms()) {

        // Add a title for each platform
        String platformLabel = targetPlatform.getPreferences().get(""name"");
        if (platformLabel == null)
          platformLabel = targetPackage.getId() + ""-"" + targetPlatform.getId();

        // add an hint that this core lives in sketchbook
        if (targetPlatform.isInSketchbook())
          platformLabel += "" (in sketchbook)"";

        JMenu platformBoardsMenu = new JMenu(platformLabel);
        MenuScroller.setScrollerFor(platformBoardsMenu);
        platformMenus.add(platformBoardsMenu);

        // Cycle through all boards of this platform
        for (TargetBoard board : targetPlatform.getBoards().values()) {
          if (board.getPreferences().get(""hide"") != null)
            continue;
          JMenuItem item = createBoardMenusAndCustomMenus(boardsCustomMenus, menuItemsToClickAfterStartup,
                  buttonGroupsMap,
                  board, targetPlatform, targetPackage);
          platformBoardsMenu.add(item);
          boardsButtonGroup.add(item);
        }
      }
    }

    platformMenus.sort((x,y) -> x.getText().compareToIgnoreCase(y.getText()));

    JMenuItem firstBoardItem = null;
    if (platformMenus.size() == 1) {
      // When just one platform exists, add the board items directly,
      // rather than using a submenu
      for (Component boardItem : platformMenus.get(0).getMenuComponents()) {
        boardMenu.add(boardItem);
        if (firstBoardItem == null)
          firstBoardItem = (JMenuItem)boardItem;
      }
    } else {
      // For multiple platforms, use submenus
      for (JMenu platformMenu : platformMenus) {
        if (firstBoardItem == null && platformMenu.getItemCount() > 0)
          firstBoardItem = platformMenu.getItem(0);
        boardMenu.add(platformMenu);
      }
    }

    if (firstBoardItem == null) {
      throw new IllegalStateException(""No available boards"");
    }

    // If there is no current board yet (first startup, or selected
    // board no longer defined), select first available board.
    if (menuItemsToClickAfterStartup.isEmpty()) {
      menuItemsToClickAfterStartup.add(firstBoardItem);
    }

    for (JMenuItem menuItemToClick : menuItemsToClickAfterStartup) {
      menuItemToClick.setSelected(true);
      menuItemToClick.getAction().actionPerformed(new ActionEvent(this, -1, """"));
    }
  }",iterator
menuId,"{
    String selPackage = PreferencesData.get(""target_package"");
    String selPlatform = PreferencesData.get(""target_platform"");
    String selBoard = PreferencesData.get(""board"");

    String boardId = board.getId();
    String packageName = targetPackage.getId();
    String platformName = targetPlatform.getId();

    // Setup a menu item for the current board
    @SuppressWarnings(""serial"")
    Action action = new AbstractAction(board.getName()) {
      public void actionPerformed(ActionEvent actionevent) {
        BaseNoGui.selectBoard((TargetBoard) getValue(""b""));
        filterVisibilityOfSubsequentBoardMenus(boardsCustomMenus, (TargetBoard) getValue(""b""), 1);

        onBoardOrPortChange();
        rebuildImportMenu(Editor.importMenu);
        rebuildExamplesMenu(Editor.examplesMenu);
        rebuildProgrammerMenu();
      }
    };
    action.putValue(""b"", board);

    JRadioButtonMenuItem item = new JRadioButtonMenuItem(action);

    if (selBoard.equals(boardId) && selPackage.equals(packageName)
            && selPlatform.equals(platformName)) {
      menuItemsToClickAfterStartup.add(item);
    }

    PreferencesMap customMenus = targetPlatform.getCustomMenus();
    for (final String menuId : customMenus.keySet()) {
      String title = customMenus.get(menuId);
      JMenu menu = getBoardCustomMenu(tr(title), getPlatformUniqueId(targetPlatform));

      if (board.hasMenu(menuId)) {
        PreferencesMap boardCustomMenu = board.getMenuLabels(menuId);
        for (String customMenuOption : boardCustomMenu.keySet()) {
          @SuppressWarnings(""serial"")
          Action subAction = new AbstractAction(tr(boardCustomMenu.get(customMenuOption))) {
            public void actionPerformed(ActionEvent e) {
              PreferencesData.set(""custom_"" + menuId, ((List<TargetBoard>) getValue(""board"")).get(0).getId() + ""_"" + getValue(""custom_menu_option""));
              onBoardOrPortChange();
            }
          };
          List<TargetBoard> boards = (List<TargetBoard>) subAction.getValue(""board"");
          if (boards == null) {
            boards = new ArrayList<>();
          }
          boards.add(board);
          subAction.putValue(""board"", boards);
          subAction.putValue(""custom_menu_option"", customMenuOption);

          if (!buttonGroupsMap.containsKey(menuId)) {
            buttonGroupsMap.put(menuId, new ButtonGroup());
          }

          JRadioButtonMenuItem subItem = new JRadioButtonMenuItem(subAction);
          menu.add(subItem);
          buttonGroupsMap.get(menuId).add(subItem);

          String selectedCustomMenuEntry = PreferencesData.get(""custom_"" + menuId);
          if (selBoard.equals(boardId) && (boardId + ""_"" + customMenuOption).equals(selectedCustomMenuEntry)) {
            menuItemsToClickAfterStartup.add(subItem);
          }
        }
      }
    }

    return item;
  }",iterator
customMenuOption,"{
    String selPackage = PreferencesData.get(""target_package"");
    String selPlatform = PreferencesData.get(""target_platform"");
    String selBoard = PreferencesData.get(""board"");

    String boardId = board.getId();
    String packageName = targetPackage.getId();
    String platformName = targetPlatform.getId();

    // Setup a menu item for the current board
    @SuppressWarnings(""serial"")
    Action action = new AbstractAction(board.getName()) {
      public void actionPerformed(ActionEvent actionevent) {
        BaseNoGui.selectBoard((TargetBoard) getValue(""b""));
        filterVisibilityOfSubsequentBoardMenus(boardsCustomMenus, (TargetBoard) getValue(""b""), 1);

        onBoardOrPortChange();
        rebuildImportMenu(Editor.importMenu);
        rebuildExamplesMenu(Editor.examplesMenu);
        rebuildProgrammerMenu();
      }
    };
    action.putValue(""b"", board);

    JRadioButtonMenuItem item = new JRadioButtonMenuItem(action);

    if (selBoard.equals(boardId) && selPackage.equals(packageName)
            && selPlatform.equals(platformName)) {
      menuItemsToClickAfterStartup.add(item);
    }

    PreferencesMap customMenus = targetPlatform.getCustomMenus();
    for (final String menuId : customMenus.keySet()) {
      String title = customMenus.get(menuId);
      JMenu menu = getBoardCustomMenu(tr(title), getPlatformUniqueId(targetPlatform));

      if (board.hasMenu(menuId)) {
        PreferencesMap boardCustomMenu = board.getMenuLabels(menuId);
        for (String customMenuOption : boardCustomMenu.keySet()) {
          @SuppressWarnings(""serial"")
          Action subAction = new AbstractAction(tr(boardCustomMenu.get(customMenuOption))) {
            public void actionPerformed(ActionEvent e) {
              PreferencesData.set(""custom_"" + menuId, ((List<TargetBoard>) getValue(""board"")).get(0).getId() + ""_"" + getValue(""custom_menu_option""));
              onBoardOrPortChange();
            }
          };
          List<TargetBoard> boards = (List<TargetBoard>) subAction.getValue(""board"");
          if (boards == null) {
            boards = new ArrayList<>();
          }
          boards.add(board);
          subAction.putValue(""board"", boards);
          subAction.putValue(""custom_menu_option"", customMenuOption);

          if (!buttonGroupsMap.containsKey(menuId)) {
            buttonGroupsMap.put(menuId, new ButtonGroup());
          }

          JRadioButtonMenuItem subItem = new JRadioButtonMenuItem(subAction);
          menu.add(subItem);
          buttonGroupsMap.get(menuId).add(subItem);

          String selectedCustomMenuEntry = PreferencesData.get(""custom_"" + menuId);
          if (selBoard.equals(boardId) && (boardId + ""_"" + customMenuOption).equals(selectedCustomMenuEntry)) {
            menuItemsToClickAfterStartup.add(subItem);
          }
        }
      }
    }

    return item;
  }",iterator
i,"{
    for (int i = fromIndex; i < boardsCustomMenus.size(); i++) {
      JMenu menu = boardsCustomMenus.get(i);
      for (int m = 0; m < menu.getItemCount(); m++) {
        JMenuItem menuItem = menu.getItem(m);
        for (TargetBoard t_board : (List<TargetBoard>)menuItem.getAction().getValue(""board"")) {
          menuItem.setVisible(t_board.equals(board));
        }
      }
      menu.setVisible(ifThereAreVisibleItemsOn(menu));

      if (menu.isVisible()) {
        JMenuItem visibleSelectedOrFirstMenuItem = selectVisibleSelectedOrFirstMenuItem(menu);
        if (!visibleSelectedOrFirstMenuItem.isSelected()) {
          visibleSelectedOrFirstMenuItem.setSelected(true);
          visibleSelectedOrFirstMenuItem.getAction().actionPerformed(null);
        }
      }
    }
  }",loop_control
m,"{
    for (int i = fromIndex; i < boardsCustomMenus.size(); i++) {
      JMenu menu = boardsCustomMenus.get(i);
      for (int m = 0; m < menu.getItemCount(); m++) {
        JMenuItem menuItem = menu.getItem(m);
        for (TargetBoard t_board : (List<TargetBoard>)menuItem.getAction().getValue(""board"")) {
          menuItem.setVisible(t_board.equals(board));
        }
      }
      menu.setVisible(ifThereAreVisibleItemsOn(menu));

      if (menu.isVisible()) {
        JMenuItem visibleSelectedOrFirstMenuItem = selectVisibleSelectedOrFirstMenuItem(menu);
        if (!visibleSelectedOrFirstMenuItem.isSelected()) {
          visibleSelectedOrFirstMenuItem.setSelected(true);
          visibleSelectedOrFirstMenuItem.getAction().actionPerformed(null);
        }
      }
    }
  }",loop_control
t_board,"{
    for (int i = fromIndex; i < boardsCustomMenus.size(); i++) {
      JMenu menu = boardsCustomMenus.get(i);
      for (int m = 0; m < menu.getItemCount(); m++) {
        JMenuItem menuItem = menu.getItem(m);
        for (TargetBoard t_board : (List<TargetBoard>)menuItem.getAction().getValue(""board"")) {
          menuItem.setVisible(t_board.equals(board));
        }
      }
      menu.setVisible(ifThereAreVisibleItemsOn(menu));

      if (menu.isVisible()) {
        JMenuItem visibleSelectedOrFirstMenuItem = selectVisibleSelectedOrFirstMenuItem(menu);
        if (!visibleSelectedOrFirstMenuItem.isSelected()) {
          visibleSelectedOrFirstMenuItem.setSelected(true);
          visibleSelectedOrFirstMenuItem.getAction().actionPerformed(null);
        }
      }
    }
  }",iterator
i,"{
    for (int i = 0; i < menu.getItemCount(); i++) {
      if (menu.getItem(i).isVisible()) {
        return true;
      }
    }
    return false;
  }",loop_control
menu,"{
    for (int i = 0; i < menu.getItemCount(); i++) {
      if (menu.getItem(i).isVisible()) {
        return true;
      }
    }
    return false;
  }",break_loop_control
menu,"{
    for (JMenu menu : boardsCustomMenus) {
      if (label.equals(menu.getText()) && menu.getClientProperty(""platform"").equals(platformUniqueId)) {
        return menu;
      }
    }
    throw new Exception(""Custom menu not found!"");
  }",iterator
label,"{
    for (JMenu menu : boardsCustomMenus) {
      if (label.equals(menu.getText()) && menu.getClientProperty(""platform"").equals(platformUniqueId)) {
        return menu;
      }
    }
    throw new Exception(""Custom menu not found!"");
  }",break_loop_control
menu,"{
    for (JMenu menu : boardsCustomMenus) {
      if (label.equals(menu.getText()) && menu.getClientProperty(""platform"").equals(platformUniqueId)) {
        return menu;
      }
    }
    throw new Exception(""Custom menu not found!"");
  }",break_loop_control
i,"{
    JMenuItem firstVisible = null;
    for (int i = 0; i < menu.getItemCount(); i++) {
      JMenuItem item = menu.getItem(i);
      if (item != null && item.isVisible()) {
        if (item.isSelected()) {
          return item;
        }
        if (firstVisible == null) {
          firstVisible = item;
        }
      }
    }

    if (firstVisible != null) {
      return firstVisible;
    }

    throw new IllegalStateException(""Menu has no enabled items"");
  }",loop_control
item,"{
    JMenuItem firstVisible = null;
    for (int i = 0; i < menu.getItemCount(); i++) {
      JMenuItem item = menu.getItem(i);
      if (item != null && item.isVisible()) {
        if (item.isSelected()) {
          return item;
        }
        if (firstVisible == null) {
          firstVisible = item;
        }
      }
    }

    if (firstVisible != null) {
      return firstVisible;
    }

    throw new IllegalStateException(""Menu has no enabled items"");
  }",break_loop_control
programmer,"{
    for (String programmer : platform.getProgrammers().keySet()) {
      String id = platform.getContainerPackage().getId() + "":"" + programmer;

      @SuppressWarnings(""serial"")
      AbstractAction action = new AbstractAction(platform.getProgrammer(programmer).get(""name"")) {
        public void actionPerformed(ActionEvent actionevent) {
          PreferencesData.set(""programmer"", """" + getValue(""id""));
        }
      };
      action.putValue(""id"", id);
      JMenuItem item = new JRadioButtonMenuItem(action);
      if (PreferencesData.get(""programmer"").equals(id)) {
        item.setSelected(true);
      }
      group.add(item);
      menus.add(item);
    }
  }",iterator
subfolder,"{
    if (folder == null)
      return false;

    if (!folder.isDirectory()) return false;

    File[] files = folder.listFiles();
    // If a bad folder or unreadable or whatever, this will come back null
    if (files == null) return false;

    // Alphabetize files, since it's not always alpha order
    Arrays.sort(files, new Comparator<File>() {
      @Override
      public int compare(File file, File file2) {
        return file.getName().compareToIgnoreCase(file2.getName());
      }
    });

    boolean ifound = false;
    for (File subfolder : files) {
      if (!FileUtils.isSCCSOrHiddenFile(subfolder) && subfolder.isDirectory()
          && addSketchesSubmenu(menu, subfolder.getName(), subfolder)) {
        ifound = true;
      }
    }
    return ifound;
  }",iterator
lib,"{

    LibraryList list = new LibraryList(libs);
    list.sort();

    for (UserLibrary lib : list) {
      @SuppressWarnings(""serial"")
      AbstractAction action = new AbstractAction(lib.getName()) {
        public void actionPerformed(ActionEvent event) {
          UserLibrary l = (UserLibrary) getValue(""library"");
          try {
            activeEditor.getSketchController().importLibrary(l);
          } catch (IOException e) {
            showWarning(tr(""Error""), format(""Unable to list header files in {0}"", l.getSrcFolder()), e);
          }
        }
      };
      action.putValue(""library"", lib);

      // Add new element at the bottom
      JMenuItem item = new JMenuItem(action);
      item.putClientProperty(""library"", lib);
      menu.add(item);

      // XXX: DAM: should recurse here so that library folders can be nested
    }
  }",iterator
bytesRead,"{
    int size = (int) file.length();
    FileInputStream input = null;
    try {
      input = new FileInputStream(file);
      byte buffer[] = new byte[size];
      int offset = 0;
      int bytesRead;
      while ((bytesRead = input.read(buffer, offset, size - offset)) != -1) {
        offset += bytesRead;
        if (bytesRead == 0) break;
      }
      return buffer;
    } finally {
      IOUtils.closeQuietly(input);
    }
  }",maybe_loop_control
bytesRead,"{
    int size = (int) file.length();
    FileInputStream input = null;
    try {
      input = new FileInputStream(file);
      byte buffer[] = new byte[size];
      int offset = 0;
      int bytesRead;
      while ((bytesRead = input.read(buffer, offset, size - offset)) != -1) {
        offset += bytesRead;
        if (bytesRead == 0) break;
      }
      return buffer;
    } finally {
      IOUtils.closeQuietly(input);
    }
  }",break_loop_control
i,"{
    HashMap<String, String> outgoing = new HashMap<>();
    if (!inputFile.exists()) return outgoing;  // return empty hash

    String lines[] = PApplet.loadStrings(inputFile);
    for (int i = 0; i < lines.length; i++) {
      int hash = lines[i].indexOf('#');
      String line = (hash == -1) ?
              lines[i].trim() : lines[i].substring(0, hash).trim();
      if (line.length() == 0) continue;

      int equals = line.indexOf('=');
      if (equals == -1) {
        System.err.println(""ignoring illegal line in "" + inputFile);
        System.err.println(""  "" + line);
        continue;
      }
      String attr = line.substring(0, equals).trim();
      String valu = line.substring(equals + 1).trim();
      outgoing.put(attr, valu);
    }
    return outgoing;
  }",loop_control
bytesRead,"{
    InputStream from = null;
    OutputStream to = null;
    try {
      from = new BufferedInputStream(new FileInputStream(sourceFile));
      to = new BufferedOutputStream(new FileOutputStream(targetFile));
      byte[] buffer = new byte[16 * 1024];
      int bytesRead;
      while ((bytesRead = from.read(buffer)) != -1) {
        to.write(buffer, 0, bytesRead);
      }
      to.flush();
    } finally {
      IOUtils.closeQuietly(from);
      IOUtils.closeQuietly(to);
    }

    targetFile.setLastModified(sourceFile.lastModified());
  }",maybe_loop_control
i,"{
    int size = 0;

    String files[] = folder.list();
    // null if folder doesn't exist, happens when deleting sketch
    if (files == null) return -1;

    for (int i = 0; i < files.length; i++) {
      if (files[i].equals(""."") || (files[i].equals("".."")) ||
              files[i].equals("".DS_Store"")) continue;
      File fella = new File(folder, files[i]);
      if (fella.isDirectory()) {
        size += calcFolderSize(fella);
      } else {
        size += (int) fella.length();
      }
    }
    return size;
  }",loop_control
base,"{
    while (base.getActiveEditor() == null) {
      try {
        Thread.sleep(1000);
      } catch (InterruptedException e) {
        e.printStackTrace();
      }
    }
    BaseNoGui.addPropertyChangeListener(this);
    checkForNewBoardAttached();
  }",maybe_loop_control
e,"{
    String newBoardManagerLink = BaseNoGui.getBoardManagerLink();
    if (newBoardManagerLink.isEmpty()) {
      return;
    }

    SwingUtilities.invokeLater(() -> {

      ed = base.getActiveEditor();
      NotificationPopup notificationPopup = new NotificationPopup(ed, 
                 new UpdatableBoardsLibsFakeURLsHandler(base), 
                 newBoardManagerLink, false);
      if (ed.isFocused()) {
        notificationPopup.begin();
        return;
      }

      // If the IDE is not focused wait until it is focused again to
      // display the notification, this avoids the annoying side effect
      // to ""steal"" the focus from another application.
      WindowFocusListener wfl = new WindowFocusListener() {
        @Override
        public void windowLostFocus(WindowEvent evt) {
        }

        @Override
        public void windowGainedFocus(WindowEvent evt) {
          notificationPopup.begin();
          for (Editor e : base.getEditors())
            e.removeWindowFocusListener(this);
        }
      };

      for (Editor e : base.getEditors())
        e.addWindowFocusListener(wfl);
    });
  }",iterator
i,"{
    this.description = description;
    this.extensions = new String[exts.length];
    for (int i = 0; i < exts.length; i++) {
      this.extensions[i] = exts[i].toLowerCase(Locale.ENGLISH);
    }
  }",loop_control
extension,"{
    if (f == null) {
      return false;
    }

    if (f.isDirectory()) {
      return true;
    }

    String fileName = f.getName();
    int i = fileName.lastIndexOf('.');
    if (i > 0 && i < fileName.length() - 1) {
      String fileExtension = fileName.substring(i + 1).toLowerCase(Locale.ENGLISH);
      for (String extension : extensions) {
        if (extension.equals(fileExtension)) {
          return true;
        }
      }
    }

    return false;
  }",iterator
extension,"{
    if (f == null) {
      return false;
    }

    if (f.isDirectory()) {
      return true;
    }

    String fileName = f.getName();
    int i = fileName.lastIndexOf('.');
    if (i > 0 && i < fileName.length() - 1) {
      String fileExtension = fileName.substring(i + 1).toLowerCase(Locale.ENGLISH);
      for (String extension : extensions) {
        if (extension.equals(fileExtension)) {
          return true;
        }
      }
    }

    return false;
  }",break_loop_control
file,"{
    Application application = Application.getApplication();

    application.addAppEventListener(new AppReOpenedListener() {
      @Override
        public void appReOpened(AppReOpenedEvent aroe) {
          try {
            if (Base.INSTANCE.getEditors().size() == 0) {
              Base.INSTANCE.handleNew();
            }
          } catch (Exception e) {
            // TODO Auto-generated catch block
            e.printStackTrace();
          }
      }
    });
    application.setAboutHandler(new AboutHandler() {
      @Override
      public void handleAbout(AppEvent.AboutEvent aboutEvent) {
        new Thread(() -> {
          if (waitForBase()) {
            Base.INSTANCE.handleAbout();
          }
        }).start();
      }
    });
    application.setPreferencesHandler(new PreferencesHandler() {
      @Override
      public void handlePreferences(AppEvent.PreferencesEvent preferencesEvent) {
        new Thread(() -> {
          if (waitForBase()) {
            Base.INSTANCE.handlePrefs();
          }
        }).start();
      }
    });
    application.setOpenFileHandler(new OpenFilesHandler() {
      @Override
      public void openFiles(final AppEvent.OpenFilesEvent openFilesEvent) {
        new Thread(() -> {
          if (waitForBase()) {
            for (File file : openFilesEvent.getFiles()) {
              System.out.println(file);
              try {
                Base.INSTANCE.handleOpen(file);
                List<Editor> editors = Base.INSTANCE.getEditors();
                if (editors.size() == 2 && editors.get(0).getSketchController().isUntitled()) {
                  Base.INSTANCE.handleClose(editors.get(0));
                }
              } catch (Exception e) {
                throw new RuntimeException(e);
              }
            }
          }
        }).start();
      }
    });
    application.setQuitHandler(new QuitHandler() {
      @Override
      public void handleQuitRequestWith(AppEvent.QuitEvent quitEvent, QuitResponse quitResponse) {
        new Thread(() -> {
          if (waitForBase()) {
            if (Base.INSTANCE.handleQuit()) {
              quitResponse.performQuit();
            } else {
              quitResponse.cancelQuit();
            }
          }
        }).start();
      }
    });
  }",iterator
slept,"{
    int slept = 0;
    while (Base.INSTANCE == null) {
      if (slept >= MAX_WAIT_FOR_BASE) {
        return false;
      }
      sleep(100);
      slept += 100;
    }
    return true;
  }",break_loop_control
set,"{
    int[] sets = { KeyboardFocusManager.FORWARD_TRAVERSAL_KEYS,
        KeyboardFocusManager.BACKWARD_TRAVERSAL_KEYS,
        KeyboardFocusManager.UP_CYCLE_TRAVERSAL_KEYS,
        KeyboardFocusManager.DOWN_CYCLE_TRAVERSAL_KEYS };
    for (int set : sets) {
      Set<AWTKeyStroke> keys = component.getFocusTraversalKeys(set);
      // keys is immutable, so create a new set to allow changes
      keys = new HashSet<>(keys);
      if (set == 0)
        keys.add(ctrlAlt('Z'));

      // If the given keystroke was present in the set, replace it with the
      // updated set with the keystroke removed.
      if (keys.remove(keystroke))
        component.setFocusTraversalKeys(set, keys);
    }
  }",iterator
potentialStep,"{
    double range = max - min;
    double exp;
    if (range == 0.0) {
      exp = 0;
    } else {
      exp = Math.floor(Math.log10(range / (tickCount - 1)));
    }
    double scale = Math.pow(10, exp);

    double rawTickStep = (range / (tickCount - 1)) / scale;
    for (double potentialStep : new double[]{1.0, 1.5, 2.0, 2.5, 3.0, 4.0, 5.0, 6.0, 8.0, 10.0}) {
      if (potentialStep < rawTickStep) {
        continue;
      }

      tickStep = potentialStep * scale;
      tickMin = tickStep * Math.floor(min / tickStep);
      tickMax = tickMin + tickStep * (tickCount - 1);
      if (tickMax >= max) {
        break;
      }
    }

    tickCount -= (int) Math.floor((tickMax - max) / tickStep);
    this.tickCount = tickCount;

    ticks = new double[tickCount];
    for (int i = 0; i < tickCount; ++i) {
      ticks[i] = tickMin + i * tickStep;
    }
  }",iterator
tickMax,"{
    double range = max - min;
    double exp;
    if (range == 0.0) {
      exp = 0;
    } else {
      exp = Math.floor(Math.log10(range / (tickCount - 1)));
    }
    double scale = Math.pow(10, exp);

    double rawTickStep = (range / (tickCount - 1)) / scale;
    for (double potentialStep : new double[]{1.0, 1.5, 2.0, 2.5, 3.0, 4.0, 5.0, 6.0, 8.0, 10.0}) {
      if (potentialStep < rawTickStep) {
        continue;
      }

      tickStep = potentialStep * scale;
      tickMin = tickStep * Math.floor(min / tickStep);
      tickMax = tickMin + tickStep * (tickCount - 1);
      if (tickMax >= max) {
        break;
      }
    }

    tickCount -= (int) Math.floor((tickMax - max) / tickStep);
    this.tickCount = tickCount;

    ticks = new double[tickCount];
    for (int i = 0; i < tickCount; ++i) {
      ticks[i] = tickMin + i * tickStep;
    }
  }",break_loop_control
i,"{
    double range = max - min;
    double exp;
    if (range == 0.0) {
      exp = 0;
    } else {
      exp = Math.floor(Math.log10(range / (tickCount - 1)));
    }
    double scale = Math.pow(10, exp);

    double rawTickStep = (range / (tickCount - 1)) / scale;
    for (double potentialStep : new double[]{1.0, 1.5, 2.0, 2.5, 3.0, 4.0, 5.0, 6.0, 8.0, 10.0}) {
      if (potentialStep < rawTickStep) {
        continue;
      }

      tickStep = potentialStep * scale;
      tickMin = tickStep * Math.floor(min / tickStep);
      tickMax = tickMin + tickStep * (tickCount - 1);
      if (tickMax >= max) {
        break;
      }
    }

    tickCount -= (int) Math.floor((tickMax - max) / tickStep);
    this.tickCount = tickCount;

    ticks = new double[tickCount];
    for (int i = 0; i < tickCount; ++i) {
      ticks[i] = tickMin + i * tickStep;
    }
  }",loop_control
i,"{
    if (size() == 0) {
      throw new NoSuchElementException();
    }

    double out = get(0);
    for (int i = 1; i < size(); ++i) {
      out = Math.min(out, get(i));
    }

    return out;
  }",loop_control
i,"{
    if (size() == 0) {
      throw new NoSuchElementException();
    }

    double out = get(0);
    for (int i = 1; i < size(); ++i) {
      out = Math.max(out, get(i));
    }

    return out;
  }",loop_control
newbie,"{
    SketchController sketch = editor.getSketchController();
    
    // first save the sketch so that things don't archive strangely
    boolean success = false;
    try {
      success = sketch.save();
    } catch (Exception e) {
      e.printStackTrace();
    }
    if (!success) {
      Base.showWarning(tr(""Couldn't archive sketch""),
                       tr(""Archiving the sketch has been canceled because\nthe sketch couldn't save properly.""), null);
      return;
    }

    File location = sketch.getSketch().getFolder();
    String name = location.getName();
    File parent = new File(location.getParent());

    //System.out.println(""loc "" + location);
    //System.out.println(""par "" + parent);

    File newbie = null;
    String namely = null;
    int index = 0;
    do {
      // only use the date if the sketch name isn't the default name
      useDate = !name.startsWith(""sketch_"");

      if (useDate) {
        String purty = dateFormat.format(new Date());
        String stamp = purty + ((char) ('a' + index));
        namely = name + ""-"" + stamp;
        newbie = new File(parent, namely + "".zip"");

      } else {
        String diggie = numberFormat.format(index + 1);
        namely = name + ""-"" + diggie;
        newbie = new File(parent, namely + "".zip"");
      }
      index++;
    } while (newbie.exists());

    // open up a prompt for where to save this fella
    FileDialog fd = new FileDialog(editor, tr(""Archive sketch as:""), FileDialog.SAVE);
    fd.setDirectory(parent.getAbsolutePath());
    fd.setFile(newbie.getName());
    fd.setVisible(true);

    String directory = fd.getDirectory();
    String filename = fd.getFile();

    // only write the file if not canceled
    if (filename != null) {
      newbie = new File(directory, filename);

      ZipOutputStream zos = null;
      try {
        //System.out.println(newbie);
        zos = new ZipOutputStream(new FileOutputStream(newbie));

        // recursively fill the zip file
        buildZip(location, name, zos);

        // close up the jar file
        zos.flush();
        editor.statusNotice(""Created archive "" + newbie.getName() + ""."");
      } catch (IOException e) {
        e.printStackTrace();
      } finally {
        IOUtils.closeQuietly(zos);
      }
    } else {
      editor.statusNotice(tr(""Archive sketch canceled.""));
    }
  }",maybe_loop_control
i,"{
    String files[] = dir.list();
    if (files == null) {
      throw new IOException(""Unable to list files from "" + dir);
    }
    for (int i = 0; i < files.length; i++) {
      if (files[i].equals(""."") ||
          files[i].equals("".."")) continue;

      File sub = new File(dir, files[i]);
      String nowfar = (sofar == null) ?
        files[i] : (sofar + ""/"" + files[i]);

      if (sub.isDirectory()) {
        // directories are empty entries and have / at the end
        ZipEntry entry = new ZipEntry(nowfar + ""/"");
        //System.out.println(entry);
        zos.putNextEntry(entry);
        zos.closeEntry();
        buildZip(sub, nowfar, zos);

      } else {
        ZipEntry entry = new ZipEntry(nowfar);
        entry.setTime(sub.lastModified());
        zos.putNextEntry(entry);
        zos.write(Base.loadBytesRaw(sub));
        zos.closeEntry();
      }
    }
  }",loop_control
i,"{
    StringBuilder cf = new StringBuilder(html ? ""<pre>\n"" : ""[code]\n"");

    int selStart = textarea.getSelectionStart();
    int selStop = textarea.getSelectionEnd();

    int startLine;
    int stopLine;
    try {
      startLine = textarea.getLineOfOffset(selStart);
      stopLine = textarea.getLineOfOffset(selStop);
    } catch (BadLocationException e) {
      return;
    }

    // If no selection, convert all the lines
    if (selStart == selStop) {
      startLine = 0;
      stopLine = textarea.getLineCount() - 1;
    } else {
      // Make sure the selection doesn't end at the beginning of the last line
      try {
        if (textarea.getLineStartOffset(stopLine) == selStop) {
          stopLine--;
        }
      } catch (BadLocationException e) {
        // ignore
      }
    }

    // Read the code line by line
    for (int i = startLine; i <= stopLine; i++) {
      appendFormattedLine(cf, i);
    }

    cf.append(html ? ""\n</pre>"" : ""\n[/code]"");

    StringSelection formatted = new StringSelection(cf.toString());
    Clipboard clipboard = Toolkit.getDefaultToolkit().getSystemClipboard();
    clipboard.setContents(formatted, (clipboard1, contents) -> {
      // i don't care about ownership
    });
    Clipboard unixclipboard = Toolkit.getDefaultToolkit().getSystemSelection();
    if (unixclipboard != null) unixclipboard.setContents(formatted, null);

    editor.statusNotice(""Code formatted for "" + (html ? ""HTML"" : ""the Arduino forum"") + "" has been copied to the clipboard."");
  }",loop_control
j,"{
    Segment segment = new Segment();

    textarea.getTextLine(line, segment);

    if (!html) {
      char[] segmentArray = segment.array;
      int segmentOffset = segment.offset;
      int segmentCount = segment.count;

      for (int j = 0; j < segmentCount; j++) {
        char c = segmentArray[j + segmentOffset];
        appendToHTML(c, buffer);
      }
      return;
    }

    Token tokenList = textarea.getTokenListForLine(line);

    while (tokenList != null) {
      if (tokenList.getType() != Token.NULL) {
        tokenList.appendHTMLRepresentation(buffer, textarea, false);
      }
      tokenList = tokenList.getNextToken();
    }

    buffer.append('\n');
  }",loop_control
i,"{
    Sketch sketch = editor.getSketch();
    //SketchCode code = sketch.current;
    
    if (sketch.isModified()) {
      int result = 
        JOptionPane.showConfirmDialog(editor, 
                                      tr(""Discard all changes and reload sketch?""),
                                      tr(""Fix Encoding & Reload""),
                                      JOptionPane.YES_NO_OPTION,
                                      JOptionPane.QUESTION_MESSAGE);

      if (result == JOptionPane.NO_OPTION) {
        return;
      }
    }
    try {
      for (int i = 0; i < sketch.getCodeCount(); i++) {
        SketchFile file = sketch.getFile(i);
        editor.findTab(file).setText(loadWithLocalEncoding(file.getFile()));
      }
    } catch (IOException e) {
      String msg = 
        tr(""An error occurred while trying to fix the file encoding.\nDo not attempt to save this sketch as it may overwrite\nthe old version. Use Open to re-open the sketch and try again.\n"") +
        e.getMessage();
      Base.showWarning(tr(""Fix Encoding & Reload""), msg, e);
    }
  }",loop_control
line,"{
    // FileReader uses the default encoding, which is what we want.
    BufferedReader reader = null;
    try {
      reader = new BufferedReader(new FileReader(file));

      StringBuffer buffer = new StringBuffer();
      String line;
      while ((line = reader.readLine()) != null) {
        buffer.append(line);
        buffer.append('\n');
      }
      return buffer.toString();
    } finally {
      IOUtils.closeQuietly(reader);
    }
  }",maybe_loop_control
i,"{
    if (menuItems != null && menuItems.length > 0) {
      firstIndex = Math.max(topFixedCount, firstIndex);
      firstIndex = Math.min(menuItems.length - bottomFixedCount - scrollCount, firstIndex);

      if (firstIndex < 0) {
        return;
      }

      upItem.setEnabled(firstIndex > topFixedCount);
      downItem.setEnabled(firstIndex + scrollCount < menuItems.length - bottomFixedCount);

      menu.removeAll();
      for (int i = 0; i < topFixedCount; i++) {
        menu.add(menuItems[i]);
      }
      if (topFixedCount > 0) {
        menu.addSeparator();
      }

      menu.add(upItem);
      for (int i = firstIndex; i < scrollCount + firstIndex; i++) {
        menu.add(menuItems[i]);
      }
      menu.add(downItem);

      if (bottomFixedCount > 0) {
        menu.addSeparator();
      }
      for (int i = menuItems.length - bottomFixedCount; i < menuItems.length; i++) {
        menu.add(menuItems[i]);
      }

      JComponent parent = (JComponent) upItem.getParent();
      parent.revalidate();
      parent.repaint();
    }
  }",loop_control
component,"{
      menu.removeAll();
      for (Component component : allMenuItems) {
        menu.add(component);
      }
    }",iterator
entries,"{
    String tmpFolderName = folderNameFromZip() + random.nextInt(1000000);

    File tmpFolder = new File(destFolder, tmpFolderName);

    if (!tmpFolder.mkdir()) {
      throw new IOException(""Unable to create folder "" + tmpFolderName);
    }

    Enumeration<? extends ZipEntry> entries = zipFile.entries();
    while (entries.hasMoreElements()) {
      ZipEntry entry = entries.nextElement();
      ensureFoldersOfEntryExist(tmpFolder, entry);
      File entryFile = new File(tmpFolder, entry.getName());
      if (entry.isDirectory()) {
        entryFile.mkdir();
      } else {
        FileOutputStream fos = null;
        InputStream zipInputStream = null;
        try {
          fos = new FileOutputStream(entryFile);
          zipInputStream = zipFile.getInputStream(entry);
          byte[] buffer = new byte[1024 * 4];
          int len = -1;
          while ((len = zipInputStream.read(buffer)) != -1) {
            fos.write(buffer, 0, len);
          }
        } finally {
          IOUtils.closeQuietly(fos);
          IOUtils.closeQuietly(zipInputStream);
        }
      }
    }

    deleteUndesiredFoldersAndFiles(tmpFolder);

    // Test.zip may or may not contain Test folder. If it does, we keep it. If not, we use zip name.
    ensureOneLevelFolder(tmpFolder);
  }",maybe_loop_control
len,"{
    String tmpFolderName = folderNameFromZip() + random.nextInt(1000000);

    File tmpFolder = new File(destFolder, tmpFolderName);

    if (!tmpFolder.mkdir()) {
      throw new IOException(""Unable to create folder "" + tmpFolderName);
    }

    Enumeration<? extends ZipEntry> entries = zipFile.entries();
    while (entries.hasMoreElements()) {
      ZipEntry entry = entries.nextElement();
      ensureFoldersOfEntryExist(tmpFolder, entry);
      File entryFile = new File(tmpFolder, entry.getName());
      if (entry.isDirectory()) {
        entryFile.mkdir();
      } else {
        FileOutputStream fos = null;
        InputStream zipInputStream = null;
        try {
          fos = new FileOutputStream(entryFile);
          zipInputStream = zipFile.getInputStream(entry);
          byte[] buffer = new byte[1024 * 4];
          int len = -1;
          while ((len = zipInputStream.read(buffer)) != -1) {
            fos.write(buffer, 0, len);
          }
        } finally {
          IOUtils.closeQuietly(fos);
          IOUtils.closeQuietly(zipInputStream);
        }
      }
    }

    deleteUndesiredFoldersAndFiles(tmpFolder);

    // Test.zip may or may not contain Test folder. If it does, we keep it. If not, we use zip name.
    ensureOneLevelFolder(tmpFolder);
  }",maybe_loop_control
file,"{
    for (File file : folder.listFiles()) {
      if (file.isDirectory() && ""__MACOSX"".equals(file.getName())) {
        FileUtils.recursiveDelete(file);
      } else if (file.getName().startsWith(""."")) {
        FileUtils.recursiveDelete(file);
      }
    }
  }",iterator
i,"{
    String[] parts = entry.getName().split(""/"");
    File current = folder;
    for (int i = 0; i < parts.length - 1; i++) {
      current = new File(current, parts[i]);
      current.mkdir();
    }
  }",loop_control
i,"{
      // Guaranteed to return a non-null array
      Object[] listeners = listenerList.getListenerList();
      // Process the listeners last to first, notifying
      // those that are interested in this event
      for (int i = listeners.length - 2; i >= 0; i -= 2) {
        if (listeners[i] == HyperlinkListener.class) {
          ((HyperlinkListener) listeners[i + 1]).hyperlinkUpdate(e);
        }
      }
    }",loop_control
lib,"{
    try {
      parseKeywordsTxt(new File(BaseNoGui.getContentFile(""lib""), ""keywords.txt""));
      TargetPlatform tp = BaseNoGui.getTargetPlatform();
      if (tp != null) {
        File platformKeywords = new File(tp.getFolder(), ""keywords.txt"");
        if (platformKeywords.exists()) parseKeywordsTxt(platformKeywords);
      }
      for (UserLibrary lib : BaseNoGui.librariesIndexer.getInstalledLibraries()) {
        File keywords = new File(lib.getInstalledFolder(), ""keywords.txt"");
        if (keywords.exists()) {
          parseKeywordsTxt(keywords);
        }
      }
    } catch (Exception e) {
      Base.showError(""Problem loading keywords"", ""Could not load keywords.txt,\nplease re-install Arduino."", e);
      System.exit(1);
    }
  }",iterator
line,"{
    BufferedReader reader = null;
    try {
      reader = new BufferedReader(new InputStreamReader(new FileInputStream(input)));

      String line;
      while ((line = reader.readLine()) != null) {
        //System.out.println(""line is "" + line);
        // in case there's any garbage on the line
        line = line.trim();
        if (line.length() == 0 || line.startsWith(""#"")) {
          continue;
        }

        String pieces[] = line.split(""\t"");

        String keyword = pieces[0].trim();
        if (keyword.startsWith(""\\#"")) {
          keyword = keyword.replace(""\\#"", ""#"");
        }

        if (pieces.length >= 2) {
          keywordOldToken.put(keyword, pieces[1]);
        }

        if (pieces.length >= 3) {
          parseHTMLReferenceFileName(pieces[2], keyword);
        }
        if (pieces.length >= 4) {
          parseRSyntaxTextAreaTokenType(pieces[3], keyword);
        }
      }

      fillMissingTokenType();
    } finally {
      IOUtils.closeQuietly(reader);
    }

  }",maybe_loop_control
oldTokenEntry,"{
    for (Map.Entry<String, String> oldTokenEntry : keywordOldToken.entrySet()) {
      String keyword = oldTokenEntry.getKey();
      if (!keywordTokenTypeAsString.containsKey(keyword)) {
        if (""KEYWORD1"".equals(oldTokenEntry.getValue())) {
          parseRSyntaxTextAreaTokenType(""DATA_TYPE"", keyword);
        }
        else if (""LITERAL1"".equals(oldTokenEntry.getValue())) {      
          parseRSyntaxTextAreaTokenType(""RESERVED_WORD_2"", keyword);
        }
        else {
          parseRSyntaxTextAreaTokenType(""FUNCTION"", keyword);
        }
      }
    }
  }",iterator
line1,"{

      if (!textArea.isEditable() || !textArea.isEnabled()) {
        UIManager.getLookAndFeel().provideErrorFeedback(textArea);
        return;
      }

      RSyntaxDocument doc = (RSyntaxDocument) textArea.getDocument();
      Element map = doc.getDefaultRootElement();
      Caret c = textArea.getCaret();
      int dot = c.getDot();
      int mark = c.getMark();
      int line1 = map.getElementIndex(dot);
      int line2 = map.getElementIndex(mark);
      int start = Math.min(line1, line2);
      int end = Math.max(line1, line2);

      org.fife.ui.rsyntaxtextarea.Token t = doc.getTokenListForLine(start);
      int languageIndex = t != null ? t.getLanguageIndex() : 0;
      String[] startEnd = doc.getLineCommentStartAndEnd(languageIndex);

      if (startEnd == null) {
        UIManager.getLookAndFeel().provideErrorFeedback(textArea);
        return;
      }

      // Don't toggle comment on last line if there is no
      // text selected on it.
      if (start != end) {
        Element elem = map.getElement(end);
        if (Math.max(dot, mark) == elem.getStartOffset()) {
          end--;
        }
      }

      textArea.beginAtomicEdit();
      try {
        boolean add = getDoAdd(doc, map, start, end, startEnd);
        for (line1 = start; line1 <= end; line1++) {
          Element elem = map.getElement(line1);
          handleToggleComment(elem, doc, startEnd, add);
        }
      } catch (BadLocationException ble) {
        ble.printStackTrace();
        UIManager.getLookAndFeel().provideErrorFeedback(textArea);
      } finally {
        textArea.endAtomicEdit();
      }

    }",loop_control
i,"{
      boolean doAdd = false;
      for (int i = startLine; i <= endLine; i++) {
        Element elem = map.getElement(i);
        int start = elem.getStartOffset();
        String t = doc.getText(start, elem.getEndOffset() - start - 1).trim();
        if (!t.startsWith(startEnd[0]) ||
          (startEnd[1] != null && !t.endsWith(startEnd[1]))) {
          doAdd = true;
          break;
        }
      }
      return doAdd;
    }",loop_control
t,"{
      boolean doAdd = false;
      for (int i = startLine; i <= endLine; i++) {
        Element elem = map.getElement(i);
        int start = elem.getStartOffset();
        String t = doc.getText(start, elem.getEndOffset() - start - 1).trim();
        if (!t.startsWith(startEnd[0]) ||
          (startEnd[1] != null && !t.endsWith(startEnd[1]))) {
          doAdd = true;
          break;
        }
      }
      return doAdd;
    }",break_loop_control
t,"{
      boolean doAdd = false;
      for (int i = startLine; i <= endLine; i++) {
        Element elem = map.getElement(i);
        int start = elem.getStartOffset();
        String t = doc.getText(start, elem.getEndOffset() - start - 1).trim();
        if (!t.startsWith(startEnd[0]) ||
          (startEnd[1] != null && !t.endsWith(startEnd[1]))) {
          doAdd = true;
          break;
        }
      }
      return doAdd;
    }",break_loop_control
e,"{
        ZipFile zipFile = new ZipFile(zip);
        for (Enumeration<? extends ZipEntry> e = zipFile.entries(); e.hasMoreElements();) {
            ZipEntry entry = e.nextElement();
            if (entry.getName().endsWith("".class"")) {
                StringWriter sw = new StringWriter();
                // PrintWriter pw = new PrintWriter(sw);

                try (InputStream is = zipFile.getInputStream(entry)) {
                    verify(new ClassReader(ZipUtil.toByteArray(is)));
                }
                Assert.assertTrue(sw.toString(), sw.toString().length() == 0);
            }
        }
    }",maybe_loop_control
f,"{
        Class<?> c = com.android.dx.command.Main.class;
        Method m = c.getMethod(""main"", String[].class);

        if (distFile == null) {
            distFile = File.createTempFile(""dex"", "".dex"");
        }
        List<String> args = new ArrayList<String>();
        args.addAll(Arrays.asList(""--dex"", ""--no-strict"", ""--output="" + distFile.getCanonicalPath()));
        for (Path f : files) {
            args.add(f.toAbsolutePath().toString());
        }
        m.invoke(null, new Object[] { args.toArray(new String[0]) });
        return distFile;
    }",iterator
f,"{
        Class<?> c = com.android.dx.command.Main.class;
        Method m = c.getMethod(""main"", String[].class);

        if (distFile == null) {
            distFile = File.createTempFile(""dex"", "".dex"");
        }
        List<String> args = new ArrayList<String>();
        args.addAll(Arrays.asList(""--dex"", ""--no-strict"", ""--output="" + distFile.getCanonicalPath()));
        for (File f : files) {
            args.add(f.getCanonicalPath());
        }
        m.invoke(null, new Object[] { args.toArray(new String[0]) });
        return distFile;
    }",iterator
ext,"{
        final List<Path> list = new ArrayList<>();

        try {
            Files.walkFileTree(file.toPath(), new SimpleFileVisitor<Path>() {
                @Override
                public FileVisitResult visitFile(Path file, BasicFileAttributes attrs) throws IOException {
                    String name = file.getFileName().toString();
                    boolean add = false;
                    for (String ext : exts) {
                        if (name.endsWith(ext)) {
                            add = true;
                            break;
                        }
                    }
                    if (add) {
                        list.add(file);
                    }
                    return super.visitFile(file, attrs);
                }
            });
        } catch (IOException e) {
            e.printStackTrace();
        }
        return list;
    }",iterator
name,"{
        final List<Path> list = new ArrayList<>();

        try {
            Files.walkFileTree(file.toPath(), new SimpleFileVisitor<Path>() {
                @Override
                public FileVisitResult visitFile(Path file, BasicFileAttributes attrs) throws IOException {
                    String name = file.getFileName().toString();
                    boolean add = false;
                    for (String ext : exts) {
                        if (name.endsWith(ext)) {
                            add = true;
                            break;
                        }
                    }
                    if (add) {
                        list.add(file);
                    }
                    return super.visitFile(file, attrs);
                }
            });
        } catch (IOException e) {
            e.printStackTrace();
        }
        return list;
    }",break_loop_control
j,"{
        Frame[] frames = a.getFrames();
        Textifier t = new Textifier();
        TraceMethodVisitor mv = new TraceMethodVisitor(t);
        String format = ""%05d %-"" + (method.maxStack + method.maxLocals + 6) + ""s|%s"";
        for (int j = 0; j < method.instructions.size(); ++j) {
            method.instructions.get(j).accept(mv);

            StringBuffer s = new StringBuffer();
            Frame f = frames[j];
            if (f == null) {
                s.append('?');
            } else {
                for (int k = 0; k < f.getLocals(); ++k) {
                    s.append(getShortName(f.getLocal(k).toString()));
                }
                s.append("" : "");
                for (int k = 0; k < f.getStackSize(); ++k) {
                    s.append(getShortName(f.getStack(k).toString()));
                }
            }
            pw.printf(format, j, s, buf.get(t)); // mv.text.get(j));
        }
        for (int j = 0; j < method.tryCatchBlocks.size(); ++j) {
            ((TryCatchBlockNode) method.tryCatchBlocks.get(j)).accept(mv);
            pw.print("" "" + buf.get(t));
        }
        pw.println();
        pw.flush();
    }",loop_control
k,"{
        Frame[] frames = a.getFrames();
        Textifier t = new Textifier();
        TraceMethodVisitor mv = new TraceMethodVisitor(t);
        String format = ""%05d %-"" + (method.maxStack + method.maxLocals + 6) + ""s|%s"";
        for (int j = 0; j < method.instructions.size(); ++j) {
            method.instructions.get(j).accept(mv);

            StringBuffer s = new StringBuffer();
            Frame f = frames[j];
            if (f == null) {
                s.append('?');
            } else {
                for (int k = 0; k < f.getLocals(); ++k) {
                    s.append(getShortName(f.getLocal(k).toString()));
                }
                s.append("" : "");
                for (int k = 0; k < f.getStackSize(); ++k) {
                    s.append(getShortName(f.getStack(k).toString()));
                }
            }
            pw.printf(format, j, s, buf.get(t)); // mv.text.get(j));
        }
        for (int j = 0; j < method.tryCatchBlocks.size(); ++j) {
            ((TryCatchBlockNode) method.tryCatchBlocks.get(j)).accept(mv);
            pw.print("" "" + buf.get(t));
        }
        pw.println();
        pw.flush();
    }",loop_control
i,"{
        ClassNode cn = new ClassNode();
        cr.accept(new CheckClassAdapter(cn, false), ClassReader.SKIP_DEBUG);

        List methods = cn.methods;

        for (int i = 0; i < methods.size(); ++i) {
            MethodNode method = (MethodNode) methods.get(i);

            List tryCatchBlocks = method.tryCatchBlocks;
            for (int j = 0; j < tryCatchBlocks.size(); j++) {
                TryCatchBlockNode tcn = (TryCatchBlockNode) tryCatchBlocks.get(j);
                if (tcn.start.equals(tcn.end)) {
                    throw new DexException(""try/catch block %d in %s has same start(%s) and end(%s)"", j, method.name,
                            tcn.start.getLabel(), tcn.end.getLabel());
                }
            }

            BasicVerifier verifier = new BasicVerifier();
            Analyzer a = new Analyzer(verifier);
            try {
                a.analyze(cn.name, method);
            } catch (Exception e) {
                out.println(cr.getClassName() + ""."" + method.name + method.desc);
                printAnalyzerResult(method, a, out);
                e.printStackTrace(out);
                out.flush();
                throw new DexException(""method "" + method.name + "" "" + method.desc, e);
            }
        }
    }",loop_control
j,"{
        ClassNode cn = new ClassNode();
        cr.accept(new CheckClassAdapter(cn, false), ClassReader.SKIP_DEBUG);

        List methods = cn.methods;

        for (int i = 0; i < methods.size(); ++i) {
            MethodNode method = (MethodNode) methods.get(i);

            List tryCatchBlocks = method.tryCatchBlocks;
            for (int j = 0; j < tryCatchBlocks.size(); j++) {
                TryCatchBlockNode tcn = (TryCatchBlockNode) tryCatchBlocks.get(j);
                if (tcn.start.equals(tcn.end)) {
                    throw new DexException(""try/catch block %d in %s has same start(%s) and end(%s)"", j, method.name,
                            tcn.start.getLabel(), tcn.end.getLabel());
                }
            }

            BasicVerifier verifier = new BasicVerifier();
            Analyzer a = new Analyzer(verifier);
            try {
                a.analyze(cn.name, method);
            } catch (Exception e) {
                out.println(cr.getClassName() + ""."" + method.name + method.desc);
                printAnalyzerResult(method, a, out);
                e.printStackTrace(out);
                out.flush();
                throw new DexException(""method "" + method.name + "" "" + method.desc, e);
            }
        }
    }",loop_control
f,"{
        try {
            for (Path f : TestUtils.listTestDexFiles()) {
                System.out.println(""asmifier file "" + f);
                File distDir = new File(""target"", getBaseName(f.getFileName().toString()) + ""_asmifier.zip"");
                try (FileSystem fs = BaseCmd.createZip(distDir.toPath())) {
                    ASMifierFileV.doFile(f, fs.getPath(""/""));
                }
            }
        } catch (Exception e) {
            DexFileReader.niceExceptionMessage(e, 0);
            throw e;
        }
    }",iterator
f,"{
            Collection<Path> files = TestUtils.listTestDexFiles();

            List<Runner> runners = new ArrayList<>(files.size());

            for (final Path f : files) {
                final DexFileNode fileNode = readDex(f);
                runners.add(new ParentRunner<DexClassNode>(testClass) {
                    @Override
                    protected List<DexClassNode> getChildren() {
                        return fileNode.clzs;
                    }

                    @Override
                    protected String getName() {
                        return ""d2j ["" + f.toString() + ""]"";
                    }

                    @Override
                    protected Description describeChild(DexClassNode child) {
                        return Description.createTestDescription(testClass, ""c ["" + child.className + ""]"");
                    }

                    @Override
                    protected void runChild(final DexClassNode child, RunNotifier notifier) {
                        runLeaf(new Statement() {
                            @Override
                            public void evaluate() throws Throwable {
                                TestUtils.translateAndCheck(fileNode, child);
                            }
                        }, describeChild(child), notifier);
                    }
                });
            }
            this.runners = runners;
        }",iterator
i,"{
        DexMethodVisitor mv = cv.visitMethod(ACC_PUBLIC | ACC_STATIC, new Method(""La;"", ""a"", new String[] {}, ""I""));
        DexCodeVisitor code = mv.visitCode();
        code.visitRegister(2000); // 2000 locals
        for (int i = 0; i < 2000; i++) {// 2000 insns
            code.visitConstStmt(Op.CONST, i, i);
        }
        for (int i = 0; i < 18000; i++) {// 18000 insns
            code.visitConstStmt(Op.CONST, 25, i);
        }
        code.visitStmt1R(Op.RETURN, 25);
        code.visitEnd();
        mv.visitEnd();
    }",loop_control
p,"{
            URL url = testClass.getResource(""/smalis/writeString.smali"");
            System.out.println(""url is "" + url);
            Assert.assertNotNull(url);

            final String file = url.getFile();
            Assert.assertNotNull(file);

            Path dirxpath = new File(file).toPath();

            final Path basePath = dirxpath.getParent();

            final Set<Path> files = new TreeSet<>();
            try {
                Files.walkFileTree(basePath, new SimpleFileVisitor<Path>() {
                    @Override
                    public FileVisitResult visitFile(Path file, BasicFileAttributes attrs) throws IOException {
                        if (file.getFileName().toString().endsWith("".smali"")) {
                            files.add(file);
                        }
                        return super.visitFile(file, attrs);
                    }
                });
            } catch (IOException e) {
                throw new RuntimeException(e);
            }

            List<Runner> runners = new ArrayList<>();
            for (final Path p : files) {

                Smali smali = new Smali();
                final DexFileNode fileNode = new DexFileNode();
                try {
                    smali.smaliFile(p, fileNode);
                } catch (IOException e) {
                    throw new RuntimeException(e);
                }
                runners.add(new ParentRunner<DexClassNode>(testClass) {
                    @Override
                    protected List<DexClassNode> getChildren() {
                        return fileNode.clzs;
                    }

                    @Override
                    protected String getName() {
                        return ""s2j ["" + basePath.relativize(p) + ""]"";
                    }

                    @Override
                    protected Description describeChild(DexClassNode child) {
                        return Description.createTestDescription(testClass, ""["" + child.className + ""]"");
                    }

                    @Override
                    protected void runChild(final DexClassNode child, RunNotifier notifier) {
                        runLeaf(new Statement() {
                            @Override
                            public void evaluate() throws Throwable {
                                if(p.getFileName().toString().contains(""mayfail"")) {
                                    try {
                                        TestUtils.translateAndCheck(fileNode, child);
                                    } catch (Exception ex) {
                                        ex.printStackTrace();
                                    }
                                } else {
                                    TestUtils.translateAndCheck(fileNode, child);
                                }
                            }
                        }, describeChild(child), notifier);
                    }
                });
            }
            this.runners = runners;
        }",iterator
ln,"{
        List<String> lines = Files.readAllLines(zipEntry, StandardCharsets.UTF_8);
        StringBuilder sb = new StringBuilder();
        boolean hasMethod = false;
        boolean inMethodContent = false;
        for (String ln : lines) {
            if (!inMethodContent) {
                if (ln.startsWith("".method"")) {
                    // append here to keep the line number
                    sb.append("".class LTT;.super Ljava/lang/Object;"");
                    sb.append(ln);
                    inMethodContent = true;
                    hasMethod = true;
                }
            } else {
                sb.append(ln);
                if (ln.startsWith("".end method"")) {
                    inMethodContent = false;
                }
            }
            sb.append(""\n"");
        }
        if (!hasMethod) {
            return null;
        }
        return sb.toString();
    }",iterator
ln,"{
        List<String> lines = Files.readAllLines(m, StandardCharsets.UTF_8);
        StringBuilder sb = new StringBuilder();

        boolean found = false;
        for (String ln : lines) {
            if (!found) {
                if (ln.startsWith("".method"")) {
                    // append here to keep the line number
                    sb.append("".class LTT;.super Ljava/lang/Object;"");
                    sb.append(ln).append(""\n"");
                    found = true;
                } else {
                    sb.append(""\n"");
                }
            } else {
                sb.append(ln).append(""\n"");
            }
        }

        return sb.toString();
    }",iterator
provider,"{
            URL url = testClass.getResource(""/smalis/writeString.smali"");
            System.out.println(""url is "" + url);
            Assert.assertNotNull(url);

            final String file = url.getFile();
            Assert.assertNotNull(file);

            final Path basePath = new File(file).toPath().getParent().getParent().resolve(""d2j-error-zips"");

            final Set<Path> files = new TreeSet<>();
            try {
                Files.walkFileTree(basePath, new SimpleFileVisitor<Path>() {
                    @Override
                    public FileVisitResult visitFile(Path file, BasicFileAttributes attrs) throws IOException {
                        if (file.getFileName().toString().endsWith("".zip"")) {
                            files.add(file);
                        }
                        return super.visitFile(file, attrs);
                    }
                });
            } catch (IOException e) {
                throw new RuntimeException(e);
            }
            FileSystemProvider zipFSP = null;
            for (FileSystemProvider provider : FileSystemProvider.installedProviders()) {
                String scheme = provider.getScheme();
                if (scheme.equals(""zip"") || scheme.equals(""jar"")) {
                    zipFSP = provider;
                    break;
                }
            }
            Assert.assertNotNull(zipFSP);

            List<Runner> runners = new ArrayList<>();
            for (final Path p : files) {
                Map<String, ?> env = new HashMap<>();
                try (FileSystem fs = zipFSP.newFileSystem(p, env)) {
                    List<Path> methods = Files.walk(fs.getPath(""/""))
                            .filter(Files::isReadable)
                            .filter(Files::isRegularFile)
                            .filter(px -> {
                                String fn = px.getFileName().toString();
                                return fn.startsWith(""m-"") && fn.endsWith("".txt"") || fn.equals(""summary.txt"");
                            })
                            .collect(Collectors.toList());

                    for (Path m : methods) {
                        processEachEntry(testClass, runners, p.getFileName().toString(), m);
                    }
                } catch (Exception e) {
                    throw new RuntimeException(e);
                }
            }
            this.runners = runners;
        }",iterator
scheme,"{
            URL url = testClass.getResource(""/smalis/writeString.smali"");
            System.out.println(""url is "" + url);
            Assert.assertNotNull(url);

            final String file = url.getFile();
            Assert.assertNotNull(file);

            final Path basePath = new File(file).toPath().getParent().getParent().resolve(""d2j-error-zips"");

            final Set<Path> files = new TreeSet<>();
            try {
                Files.walkFileTree(basePath, new SimpleFileVisitor<Path>() {
                    @Override
                    public FileVisitResult visitFile(Path file, BasicFileAttributes attrs) throws IOException {
                        if (file.getFileName().toString().endsWith("".zip"")) {
                            files.add(file);
                        }
                        return super.visitFile(file, attrs);
                    }
                });
            } catch (IOException e) {
                throw new RuntimeException(e);
            }
            FileSystemProvider zipFSP = null;
            for (FileSystemProvider provider : FileSystemProvider.installedProviders()) {
                String scheme = provider.getScheme();
                if (scheme.equals(""zip"") || scheme.equals(""jar"")) {
                    zipFSP = provider;
                    break;
                }
            }
            Assert.assertNotNull(zipFSP);

            List<Runner> runners = new ArrayList<>();
            for (final Path p : files) {
                Map<String, ?> env = new HashMap<>();
                try (FileSystem fs = zipFSP.newFileSystem(p, env)) {
                    List<Path> methods = Files.walk(fs.getPath(""/""))
                            .filter(Files::isReadable)
                            .filter(Files::isRegularFile)
                            .filter(px -> {
                                String fn = px.getFileName().toString();
                                return fn.startsWith(""m-"") && fn.endsWith("".txt"") || fn.equals(""summary.txt"");
                            })
                            .collect(Collectors.toList());

                    for (Path m : methods) {
                        processEachEntry(testClass, runners, p.getFileName().toString(), m);
                    }
                } catch (Exception e) {
                    throw new RuntimeException(e);
                }
            }
            this.runners = runners;
        }",break_loop_control
p,"{
            URL url = testClass.getResource(""/smalis/writeString.smali"");
            System.out.println(""url is "" + url);
            Assert.assertNotNull(url);

            final String file = url.getFile();
            Assert.assertNotNull(file);

            final Path basePath = new File(file).toPath().getParent().getParent().resolve(""d2j-error-zips"");

            final Set<Path> files = new TreeSet<>();
            try {
                Files.walkFileTree(basePath, new SimpleFileVisitor<Path>() {
                    @Override
                    public FileVisitResult visitFile(Path file, BasicFileAttributes attrs) throws IOException {
                        if (file.getFileName().toString().endsWith("".zip"")) {
                            files.add(file);
                        }
                        return super.visitFile(file, attrs);
                    }
                });
            } catch (IOException e) {
                throw new RuntimeException(e);
            }
            FileSystemProvider zipFSP = null;
            for (FileSystemProvider provider : FileSystemProvider.installedProviders()) {
                String scheme = provider.getScheme();
                if (scheme.equals(""zip"") || scheme.equals(""jar"")) {
                    zipFSP = provider;
                    break;
                }
            }
            Assert.assertNotNull(zipFSP);

            List<Runner> runners = new ArrayList<>();
            for (final Path p : files) {
                Map<String, ?> env = new HashMap<>();
                try (FileSystem fs = zipFSP.newFileSystem(p, env)) {
                    List<Path> methods = Files.walk(fs.getPath(""/""))
                            .filter(Files::isReadable)
                            .filter(Files::isRegularFile)
                            .filter(px -> {
                                String fn = px.getFileName().toString();
                                return fn.startsWith(""m-"") && fn.endsWith("".txt"") || fn.equals(""summary.txt"");
                            })
                            .collect(Collectors.toList());

                    for (Path m : methods) {
                        processEachEntry(testClass, runners, p.getFileName().toString(), m);
                    }
                } catch (Exception e) {
                    throw new RuntimeException(e);
                }
            }
            this.runners = runners;
        }",iterator
m,"{
            URL url = testClass.getResource(""/smalis/writeString.smali"");
            System.out.println(""url is "" + url);
            Assert.assertNotNull(url);

            final String file = url.getFile();
            Assert.assertNotNull(file);

            final Path basePath = new File(file).toPath().getParent().getParent().resolve(""d2j-error-zips"");

            final Set<Path> files = new TreeSet<>();
            try {
                Files.walkFileTree(basePath, new SimpleFileVisitor<Path>() {
                    @Override
                    public FileVisitResult visitFile(Path file, BasicFileAttributes attrs) throws IOException {
                        if (file.getFileName().toString().endsWith("".zip"")) {
                            files.add(file);
                        }
                        return super.visitFile(file, attrs);
                    }
                });
            } catch (IOException e) {
                throw new RuntimeException(e);
            }
            FileSystemProvider zipFSP = null;
            for (FileSystemProvider provider : FileSystemProvider.installedProviders()) {
                String scheme = provider.getScheme();
                if (scheme.equals(""zip"") || scheme.equals(""jar"")) {
                    zipFSP = provider;
                    break;
                }
            }
            Assert.assertNotNull(zipFSP);

            List<Runner> runners = new ArrayList<>();
            for (final Path p : files) {
                Map<String, ?> env = new HashMap<>();
                try (FileSystem fs = zipFSP.newFileSystem(p, env)) {
                    List<Path> methods = Files.walk(fs.getPath(""/""))
                            .filter(Files::isReadable)
                            .filter(Files::isRegularFile)
                            .filter(px -> {
                                String fn = px.getFileName().toString();
                                return fn.startsWith(""m-"") && fn.endsWith("".txt"") || fn.equals(""summary.txt"");
                            })
                            .collect(Collectors.toList());

                    for (Path m : methods) {
                        processEachEntry(testClass, runners, p.getFileName().toString(), m);
                    }
                } catch (Exception e) {
                    throw new RuntimeException(e);
                }
            }
            this.runners = runners;
        }",iterator
m,"{

            String smaliContent = null;
            if (zipEntry.getFileName().toString().equals(""summary.txt"")) {
                smaliContent = parseSmaliContentFromSummary(zipEntry);
            } else {
                smaliContent = parseSmaliContent(zipEntry);
            }
            if (smaliContent == null) {
                return;
            }


            String finalSmaliContent = smaliContent;
            runners.add(new ParentRunner<String>(testClass) {
                @Override
                protected List<String> getChildren() {
                    return Arrays.asList(finalSmaliContent);
                }

                @Override
                protected String getName() {
                    return ""s2j ["" + zipFileName + ""]"";
                }

                @Override
                protected Description describeChild(String child) {
                    return Description.createTestDescription(testClass, ""["" + zipFileName + "":"" + zipEntry + ""]"");
                }

                @Override
                protected void runChild(final String child, RunNotifier notifier) {
                    runLeaf(new Statement() {
                        @Override
                        public void evaluate() throws Throwable {
                            DexClassNode classNode = Smali.smaliFile2Node(zipEntry.toString(), child);
                            if (classNode.methods.size() > 1) { // split into methods
                                for (DexMethodNode m : classNode.methods) {
                                    DexClassNode sub = new DexClassNode(0, ""Lx;"", ""Ly;"", new String[0]);
                                    sub.methods.add(m);
                                    TestUtils.translateAndCheck(null, sub);
                                }
                            } else {
                                TestUtils.translateAndCheck(null, classNode);
                            }
                        }
                    }, describeChild(child), notifier);
                }
            });
        }",iterator
f,"{
            URL url = testClass.getResource(""/"" + testClass.getName().replace('.', '/') + "".class"");
            Assert.assertNotNull(url);
            String file = url.getFile();
            Assert.assertNotNull(file);
            String dirx = file.substring(0, file.length() - testClass.getName().length() - "".class"".length());

            dir = new File(dirx, ""res"");
            Map<String, FileSet> m = new HashMap<>();
            for (Path f : TestUtils.listPath(dir, "".class"")) {
                String name = getBaseName(f.getFileName().toString());

                int i = name.indexOf('$');
                String z = i > 0 ? name.substring(0, i) : name;
                FileSet fs = m.get(z);
                if (fs == null) {
                    fs = new FileSet();
                    fs.name = z;
                    m.put(z, fs);
                }
                fs.files.add(f);
            }
            this.fileSetList = new ArrayList<>(m.values());
        }",iterator
classNode,"{
            runLeaf(new Statement() {
                @Override
                public void evaluate() throws Throwable {
                    File dex = TestUtils.dexP(child.files, new File(dir, child.name + "".dex""));
                    File distFile = new File(dex.getParentFile(), getBaseName(dex.getName()) + ""_d2j.jar"");
                    DexFileNode fileNode = new DexFileNode();
                    DexFileReader r = new DexFileReader(dex);
                    r.accept(fileNode);
                    for (DexClassNode classNode : fileNode.clzs) {
                        TestUtils.translateAndCheck(fileNode, classNode);
                    }
                }
            }, describeChild(child), notifier);
        }",iterator
i,"{
        long count = 0;
        for (int i = 0; i < 5; i++) {
            ++count;
        }
        return count >= Integer.MAX_VALUE ? Integer.MAX_VALUE : (int) count;
    }",loop_control
i,"{
        char[] d = src.toCharArray();
        byte[] ret = new byte[src.length() / 2];
        for (int i = 0; i < ret.length; i++) {
            char h = d[2 * i];
            char l = d[2 * i + 1];
            int hh = 0;
            if (h >= '0' && h <= '9') {
                hh = h - '0';
            } else if (h >= 'a' && h <= 'f') {
                hh = h - 'a' + 10;
            } else if (h >= 'A' && h <= 'F') {
                hh = h - 'A' + 10;
            } else {
                throw new RuntimeException();
            }
            int ll = 0;
            if (l >= '0' && l <= '9') {
                ll = h - '0';
            } else if (l >= 'a' && l <= 'f') {
                ll = h - 'a' + 10;
            } else if (l >= 'A' && l <= 'F') {
                ll = h - 'A' + 10;
            } else {
                throw new RuntimeException();
            }
            d[i] = (char) ((hh << 4) | ll);
        }
        return ret;
    }",loop_control
ann,"{
        if (anns != null) {
            for (DexAnnotationNode ann : anns) {
                if (ann.visibility != Visibility.SYSTEM) {
                    accept(ann, cv);
                }
            }
        }
    }",iterator
ann,"{
        if (anns != null) {
            for (DexAnnotationNode ann : anns) {
                if (ann.visibility != Visibility.SYSTEM) {
                    accept(ann, fv);
                }
            }
        }
    }",iterator
ann,"{
        if (anns != null) {
            for (DexAnnotationNode ann : anns) {
                if (ann.visibility != Visibility.SYSTEM) {
                    accept(ann, mv);
                }
            }
        }
    }",iterator
item,"{
        for (DexAnnotationNode.Item item : items) {
            accept(av, item.name, item.value);
        }
    }",iterator
e,"{
        if (o instanceof Object[]) {
            AnnotationVisitor arrayVisitor = dav.visitArray(name);
            if (arrayVisitor != null) {
                Object[] array = (Object[]) o;
                for (Object e : array) {
                    accept(arrayVisitor, null, e);
                }
                arrayVisitor.visitEnd();
            }
        } else if (o instanceof DexAnnotationNode) {
            DexAnnotationNode ann = (DexAnnotationNode) o;
            AnnotationVisitor av = dav.visitAnnotation(name, ann.type);
            if (av != null) {
                for (DexAnnotationNode.Item item : ann.items) {
                    accept(av, item.name, item.value);
                }
                av.visitEnd();
            }
        } else if (o instanceof Field) {
            Field f = (Field) o;
            dav.visitEnum(name, f.getType(), f.getName());
        } else if (o instanceof DexType) {
            dav.visit(name, Type.getType(((DexType) o).desc));
        } else if (o instanceof Method) {
            System.err.println(""WARN: ignored method annotation value"");
        } else {
            if (o == null) {
                System.err.println(""WARN: ignored null annotation value"");
            } else {
                dav.visit(name, o);
            }
        }
    }",iterator
item,"{
        if (o instanceof Object[]) {
            AnnotationVisitor arrayVisitor = dav.visitArray(name);
            if (arrayVisitor != null) {
                Object[] array = (Object[]) o;
                for (Object e : array) {
                    accept(arrayVisitor, null, e);
                }
                arrayVisitor.visitEnd();
            }
        } else if (o instanceof DexAnnotationNode) {
            DexAnnotationNode ann = (DexAnnotationNode) o;
            AnnotationVisitor av = dav.visitAnnotation(name, ann.type);
            if (av != null) {
                for (DexAnnotationNode.Item item : ann.items) {
                    accept(av, item.name, item.value);
                }
                av.visitEnd();
            }
        } else if (o instanceof Field) {
            Field f = (Field) o;
            dav.visitEnum(name, f.getType(), f.getName());
        } else if (o instanceof DexType) {
            dav.visit(name, Type.getType(((DexType) o).desc));
        } else if (o instanceof Method) {
            System.err.println(""WARN: ignored method annotation value"");
        } else {
            if (o == null) {
                System.err.println(""WARN: ignored null annotation value"");
            } else {
                dav.visit(name, o);
            }
        }
    }",iterator
ann,"{
        String xthrows[] = null;
        String signature = null;
        if (methodNode.anns != null) {
            for (DexAnnotationNode ann : methodNode.anns) {
                if (ann.visibility == Visibility.SYSTEM) {
                    switch (ann.type) {
                    case DexConstants.ANNOTATION_THROWS_TYPE: {
                        Object[] strs = (Object[]) findAnnotationAttribute(ann, ""value"");
                        if (strs != null) {
                            xthrows = new String[strs.length];
                            for (int i = 0; i < strs.length; i++) {
                                DexType type = (DexType) strs[i];
                                xthrows[i] = toInternalName(type);
                            }
                        }
                    }
                        break;
                    case DexConstants.ANNOTATION_SIGNATURE_TYPE: {
                        Object[] strs = (Object[]) findAnnotationAttribute(ann, ""value"");
                        if (strs != null) {
                            StringBuilder sb = new StringBuilder();
                            for (Object str : strs) {
                                sb.append(str);
                            }
                            signature = sb.toString();
                        }
                    }
                        break;
                    }
                }
            }
        }
        if (isSignatureNotValid(signature, false)) {
            System.err.println(""Applying workaround to method ""
                    + methodNode.method
                    + "" with original signature "" + signature
                    + "" by changing its signature to null"");
            signature = null;
        }
        int access = methodNode.access;
        // clear ACC_DECLARED_SYNCHRONIZED and ACC_CONSTRUCTOR from method flags
        final int cleanFlag = ~((DexConstants.ACC_DECLARED_SYNCHRONIZED | DexConstants.ACC_CONSTRUCTOR));
        access &= cleanFlag;
        return cv.visitMethod(access, methodNode.method.getName(), methodNode.method.getDesc(), signature, xthrows);
    }",iterator
i,"{
        String xthrows[] = null;
        String signature = null;
        if (methodNode.anns != null) {
            for (DexAnnotationNode ann : methodNode.anns) {
                if (ann.visibility == Visibility.SYSTEM) {
                    switch (ann.type) {
                    case DexConstants.ANNOTATION_THROWS_TYPE: {
                        Object[] strs = (Object[]) findAnnotationAttribute(ann, ""value"");
                        if (strs != null) {
                            xthrows = new String[strs.length];
                            for (int i = 0; i < strs.length; i++) {
                                DexType type = (DexType) strs[i];
                                xthrows[i] = toInternalName(type);
                            }
                        }
                    }
                        break;
                    case DexConstants.ANNOTATION_SIGNATURE_TYPE: {
                        Object[] strs = (Object[]) findAnnotationAttribute(ann, ""value"");
                        if (strs != null) {
                            StringBuilder sb = new StringBuilder();
                            for (Object str : strs) {
                                sb.append(str);
                            }
                            signature = sb.toString();
                        }
                    }
                        break;
                    }
                }
            }
        }
        if (isSignatureNotValid(signature, false)) {
            System.err.println(""Applying workaround to method ""
                    + methodNode.method
                    + "" with original signature "" + signature
                    + "" by changing its signature to null"");
            signature = null;
        }
        int access = methodNode.access;
        // clear ACC_DECLARED_SYNCHRONIZED and ACC_CONSTRUCTOR from method flags
        final int cleanFlag = ~((DexConstants.ACC_DECLARED_SYNCHRONIZED | DexConstants.ACC_CONSTRUCTOR));
        access &= cleanFlag;
        return cv.visitMethod(access, methodNode.method.getName(), methodNode.method.getDesc(), signature, xthrows);
    }",loop_control
str,"{
        String xthrows[] = null;
        String signature = null;
        if (methodNode.anns != null) {
            for (DexAnnotationNode ann : methodNode.anns) {
                if (ann.visibility == Visibility.SYSTEM) {
                    switch (ann.type) {
                    case DexConstants.ANNOTATION_THROWS_TYPE: {
                        Object[] strs = (Object[]) findAnnotationAttribute(ann, ""value"");
                        if (strs != null) {
                            xthrows = new String[strs.length];
                            for (int i = 0; i < strs.length; i++) {
                                DexType type = (DexType) strs[i];
                                xthrows[i] = toInternalName(type);
                            }
                        }
                    }
                        break;
                    case DexConstants.ANNOTATION_SIGNATURE_TYPE: {
                        Object[] strs = (Object[]) findAnnotationAttribute(ann, ""value"");
                        if (strs != null) {
                            StringBuilder sb = new StringBuilder();
                            for (Object str : strs) {
                                sb.append(str);
                            }
                            signature = sb.toString();
                        }
                    }
                        break;
                    }
                }
            }
        }
        if (isSignatureNotValid(signature, false)) {
            System.err.println(""Applying workaround to method ""
                    + methodNode.method
                    + "" with original signature "" + signature
                    + "" by changing its signature to null"");
            signature = null;
        }
        int access = methodNode.access;
        // clear ACC_DECLARED_SYNCHRONIZED and ACC_CONSTRUCTOR from method flags
        final int cleanFlag = ~((DexConstants.ACC_DECLARED_SYNCHRONIZED | DexConstants.ACC_CONSTRUCTOR));
        access &= cleanFlag;
        return cv.visitMethod(access, methodNode.method.getName(), methodNode.method.getDesc(), signature, xthrows);
    }",iterator
classNode,"{
        Map<String, Clz> classes = new HashMap<>();
        for (DexClassNode classNode : fileNode.clzs) {
            Clz clz = get(classes, classNode.className);
            clz.access = (clz.access & ~ACC_INTERFACE_ABSTRACT) | classNode.access;
            if (classNode.anns != null) {
                for (DexAnnotationNode ann : classNode.anns) {
                    if (ann.visibility == Visibility.SYSTEM) {
                        switch (ann.type) {
                        case DexConstants.ANNOTATION_ENCLOSING_CLASS_TYPE: {
                            DexType type = (DexType) findAnnotationAttribute(ann, ""value"");
                            Clz enclosingClass = get(classes, type.desc);
                            clz.enclosingClass = enclosingClass;

                            // apply patch from ChaeHoon Lim,
                            // obfuscated code may declare itself as enclosing class
                            // which cause dex2jar to endless loop
                            //if(!clz.name.equals(clz.enclosingClass.name)) {
                            //    enclosingClass.addInner(clz);
                            //}
                            enclosingClass.addInner(clz);

                        }
                            break;
                        case DexConstants.ANNOTATION_ENCLOSING_METHOD_TYPE: {
                            Method m = (Method) findAnnotationAttribute(ann, ""value"");
                            Clz enclosingClass = get(classes, m.getOwner());
                            clz.enclosingClass = enclosingClass;
                            clz.enclosingMethod = m;
                            enclosingClass.addInner(clz);
                        }
                            break;
                        case DexConstants.ANNOTATION_INNER_CLASS_TYPE: {
                            for (DexAnnotationNode.Item it : ann.items) {
                                if (""accessFlags"".equals(it.name)) {
                                    clz.access |= (Integer) it.value & ~ACC_INTERFACE_ABSTRACT;
                                } else if (""name"".equals(it.name)) {
                                    clz.innerName = (String) it.value;
                                }
                            }
                        }
                            break;
                        case DexConstants.ANNOTATION_MEMBER_CLASSES_TYPE: {
                            Object ts[] = (Object[]) findAnnotationAttribute(ann, ""value"");
                            for (Object v : ts) {
                                DexType type = (DexType) v;
                                Clz inner = get(classes, type.desc);
                                clz.addInner(inner);
                                inner.enclosingClass = clz;
                            }
                        }
                            break;
                        }
                    }
                }
            }
        }
        return classes;
    }",iterator
it,"{
        Map<String, Clz> classes = new HashMap<>();
        for (DexClassNode classNode : fileNode.clzs) {
            Clz clz = get(classes, classNode.className);
            clz.access = (clz.access & ~ACC_INTERFACE_ABSTRACT) | classNode.access;
            if (classNode.anns != null) {
                for (DexAnnotationNode ann : classNode.anns) {
                    if (ann.visibility == Visibility.SYSTEM) {
                        switch (ann.type) {
                        case DexConstants.ANNOTATION_ENCLOSING_CLASS_TYPE: {
                            DexType type = (DexType) findAnnotationAttribute(ann, ""value"");
                            Clz enclosingClass = get(classes, type.desc);
                            clz.enclosingClass = enclosingClass;

                            // apply patch from ChaeHoon Lim,
                            // obfuscated code may declare itself as enclosing class
                            // which cause dex2jar to endless loop
                            //if(!clz.name.equals(clz.enclosingClass.name)) {
                            //    enclosingClass.addInner(clz);
                            //}
                            enclosingClass.addInner(clz);

                        }
                            break;
                        case DexConstants.ANNOTATION_ENCLOSING_METHOD_TYPE: {
                            Method m = (Method) findAnnotationAttribute(ann, ""value"");
                            Clz enclosingClass = get(classes, m.getOwner());
                            clz.enclosingClass = enclosingClass;
                            clz.enclosingMethod = m;
                            enclosingClass.addInner(clz);
                        }
                            break;
                        case DexConstants.ANNOTATION_INNER_CLASS_TYPE: {
                            for (DexAnnotationNode.Item it : ann.items) {
                                if (""accessFlags"".equals(it.name)) {
                                    clz.access |= (Integer) it.value & ~ACC_INTERFACE_ABSTRACT;
                                } else if (""name"".equals(it.name)) {
                                    clz.innerName = (String) it.value;
                                }
                            }
                        }
                            break;
                        case DexConstants.ANNOTATION_MEMBER_CLASSES_TYPE: {
                            Object ts[] = (Object[]) findAnnotationAttribute(ann, ""value"");
                            for (Object v : ts) {
                                DexType type = (DexType) v;
                                Clz inner = get(classes, type.desc);
                                clz.addInner(inner);
                                inner.enclosingClass = clz;
                            }
                        }
                            break;
                        }
                    }
                }
            }
        }
        return classes;
    }",iterator
ann,"{
        Map<String, Clz> classes = new HashMap<>();
        for (DexClassNode classNode : fileNode.clzs) {
            Clz clz = get(classes, classNode.className);
            clz.access = (clz.access & ~ACC_INTERFACE_ABSTRACT) | classNode.access;
            if (classNode.anns != null) {
                for (DexAnnotationNode ann : classNode.anns) {
                    if (ann.visibility == Visibility.SYSTEM) {
                        switch (ann.type) {
                        case DexConstants.ANNOTATION_ENCLOSING_CLASS_TYPE: {
                            DexType type = (DexType) findAnnotationAttribute(ann, ""value"");
                            Clz enclosingClass = get(classes, type.desc);
                            clz.enclosingClass = enclosingClass;

                            // apply patch from ChaeHoon Lim,
                            // obfuscated code may declare itself as enclosing class
                            // which cause dex2jar to endless loop
                            //if(!clz.name.equals(clz.enclosingClass.name)) {
                            //    enclosingClass.addInner(clz);
                            //}
                            enclosingClass.addInner(clz);

                        }
                            break;
                        case DexConstants.ANNOTATION_ENCLOSING_METHOD_TYPE: {
                            Method m = (Method) findAnnotationAttribute(ann, ""value"");
                            Clz enclosingClass = get(classes, m.getOwner());
                            clz.enclosingClass = enclosingClass;
                            clz.enclosingMethod = m;
                            enclosingClass.addInner(clz);
                        }
                            break;
                        case DexConstants.ANNOTATION_INNER_CLASS_TYPE: {
                            for (DexAnnotationNode.Item it : ann.items) {
                                if (""accessFlags"".equals(it.name)) {
                                    clz.access |= (Integer) it.value & ~ACC_INTERFACE_ABSTRACT;
                                } else if (""name"".equals(it.name)) {
                                    clz.innerName = (String) it.value;
                                }
                            }
                        }
                            break;
                        case DexConstants.ANNOTATION_MEMBER_CLASSES_TYPE: {
                            Object ts[] = (Object[]) findAnnotationAttribute(ann, ""value"");
                            for (Object v : ts) {
                                DexType type = (DexType) v;
                                Clz inner = get(classes, type.desc);
                                clz.addInner(inner);
                                inner.enclosingClass = clz;
                            }
                        }
                            break;
                        }
                    }
                }
            }
        }
        return classes;
    }",iterator
v,"{
        Map<String, Clz> classes = new HashMap<>();
        for (DexClassNode classNode : fileNode.clzs) {
            Clz clz = get(classes, classNode.className);
            clz.access = (clz.access & ~ACC_INTERFACE_ABSTRACT) | classNode.access;
            if (classNode.anns != null) {
                for (DexAnnotationNode ann : classNode.anns) {
                    if (ann.visibility == Visibility.SYSTEM) {
                        switch (ann.type) {
                        case DexConstants.ANNOTATION_ENCLOSING_CLASS_TYPE: {
                            DexType type = (DexType) findAnnotationAttribute(ann, ""value"");
                            Clz enclosingClass = get(classes, type.desc);
                            clz.enclosingClass = enclosingClass;

                            // apply patch from ChaeHoon Lim,
                            // obfuscated code may declare itself as enclosing class
                            // which cause dex2jar to endless loop
                            //if(!clz.name.equals(clz.enclosingClass.name)) {
                            //    enclosingClass.addInner(clz);
                            //}
                            enclosingClass.addInner(clz);

                        }
                            break;
                        case DexConstants.ANNOTATION_ENCLOSING_METHOD_TYPE: {
                            Method m = (Method) findAnnotationAttribute(ann, ""value"");
                            Clz enclosingClass = get(classes, m.getOwner());
                            clz.enclosingClass = enclosingClass;
                            clz.enclosingMethod = m;
                            enclosingClass.addInner(clz);
                        }
                            break;
                        case DexConstants.ANNOTATION_INNER_CLASS_TYPE: {
                            for (DexAnnotationNode.Item it : ann.items) {
                                if (""accessFlags"".equals(it.name)) {
                                    clz.access |= (Integer) it.value & ~ACC_INTERFACE_ABSTRACT;
                                } else if (""name"".equals(it.name)) {
                                    clz.innerName = (String) it.value;
                                }
                            }
                        }
                            break;
                        case DexConstants.ANNOTATION_MEMBER_CLASSES_TYPE: {
                            Object ts[] = (Object[]) findAnnotationAttribute(ann, ""value"");
                            for (Object v : ts) {
                                DexType type = (DexType) v;
                                Clz inner = get(classes, type.desc);
                                clz.addInner(inner);
                                inner.enclosingClass = clz;
                            }
                        }
                            break;
                        }
                    }
                }
            }
        }
        return classes;
    }",iterator
i,"{
        if (str.length() < 1) {
            return false;
        }
        if (!Character.isJavaIdentifierStart(str.charAt(0))) {
            return false;
        }
        for (int i = 1; i < str.length(); i++) {
            if (!Character.isJavaIdentifierPart(str.charAt(i))) {
                return false;
            }
        }
        return true;
    }",loop_control
ann,"{
        ClassVisitor cv = cvf.create(toInternalName(classNode.className));
        if (cv == null) {
            return;
        }
        // the default value of static-final field are omitted by dex, fix it
        DexFix.fixStaticFinalFieldValue(classNode);

        String signature = null;
        if (classNode.anns != null) {
            for (DexAnnotationNode ann : classNode.anns) {
                if (ann.visibility == Visibility.SYSTEM) {
                    switch (ann.type) {
                    case DexConstants.ANNOTATION_SIGNATURE_TYPE: {
                        Object[] strs = (Object[]) findAnnotationAttribute(ann, ""value"");
                        if (strs != null) {
                            StringBuilder sb = new StringBuilder();
                            for (Object str : strs) {
                                sb.append(str);
                            }
                            signature = sb.toString();
                        }
                    }
                        break;
                    }
                }
            }
        }
        String interfaceInterNames[] = null;
        if (classNode.interfaceNames != null) {
            interfaceInterNames = new String[classNode.interfaceNames.length];
            for (int i = 0; i < classNode.interfaceNames.length; i++) {
                interfaceInterNames[i] = toInternalName(classNode.interfaceNames[i]);
            }
        }

        Clz clzInfo = classes.get(classNode.className);
        int access = classNode.access;
        boolean isInnerClass = false;
        if (clzInfo != null) {
            isInnerClass = clzInfo.enclosingClass != null || clzInfo.enclosingMethod != null;
        }
        access = clearClassAccess(isInnerClass, access);

        if (isSignatureNotValid(signature, false)) {
            System.err.println(""Applying workaround to class ""
                    + classNode.className
                    + "" with original signature "" + signature
                    + "" by changing its signature to null."");
            signature = null;
        }

        int version = dexVersion >= DexConstants.DEX_037 ? Opcodes.V1_8 : Opcodes.V1_6;
        cv.visit(version, access, toInternalName(classNode.className), signature,
                classNode.superClass == null ? null : toInternalName(classNode.superClass), interfaceInterNames);

        List<InnerClassNode> innerClassNodes = new ArrayList<InnerClassNode>(5);
        if (clzInfo != null) {
            searchInnerClass(clzInfo, innerClassNodes, classNode.className);
        }
        if (isInnerClass) {
            // build Outer Clz
            if (clzInfo.innerName == null) {// anonymous Innerclass
                Method enclosingMethod = clzInfo.enclosingMethod;
                if (enclosingMethod != null) {
                    cv.visitOuterClass(toInternalName(enclosingMethod.getOwner()), enclosingMethod.getName(),
                            enclosingMethod.getDesc());
                } else {
                    Clz enclosingClass = clzInfo.enclosingClass;
                    cv.visitOuterClass(toInternalName(enclosingClass.name), null, null);
                }
            }
            searchEnclosing(clzInfo, innerClassNodes);
        }
        Collections.sort(innerClassNodes, INNER_CLASS_NODE_COMPARATOR);
        for (InnerClassNode icn : innerClassNodes) {
            if (icn.innerName != null && !isJavaIdentifier(icn.innerName)) {
                System.err.println(""WARN: ignored invalid inner class name "" + "", treat as anonymous inner class."");
                icn.innerName = null;
                icn.outerName = null;
            }
            icn.accept(cv);
        }

        accept(classNode.anns, cv);

        if (classNode.fields != null) {
            for (DexFieldNode fieldNode : classNode.fields) {
                convertField(classNode, fieldNode, cv);
            }
        }
        if (classNode.methods != null) {
            ClzCtx clzCtx = new ClzCtx();
            clzCtx.classDescriptor = classNode.className;
            for (DexMethodNode methodNode : classNode.methods) {
                convertMethod(classNode, methodNode, cv, clzCtx);
            }
            if (clzCtx.hexDecodeMethodNamePrefix != null) {
                addHexDecodeMethod(cv, clzCtx.hexDecodeMethodNamePrefix);
            }
        }
        cv.visitEnd();
    }",iterator
str,"{
        ClassVisitor cv = cvf.create(toInternalName(classNode.className));
        if (cv == null) {
            return;
        }
        // the default value of static-final field are omitted by dex, fix it
        DexFix.fixStaticFinalFieldValue(classNode);

        String signature = null;
        if (classNode.anns != null) {
            for (DexAnnotationNode ann : classNode.anns) {
                if (ann.visibility == Visibility.SYSTEM) {
                    switch (ann.type) {
                    case DexConstants.ANNOTATION_SIGNATURE_TYPE: {
                        Object[] strs = (Object[]) findAnnotationAttribute(ann, ""value"");
                        if (strs != null) {
                            StringBuilder sb = new StringBuilder();
                            for (Object str : strs) {
                                sb.append(str);
                            }
                            signature = sb.toString();
                        }
                    }
                        break;
                    }
                }
            }
        }
        String interfaceInterNames[] = null;
        if (classNode.interfaceNames != null) {
            interfaceInterNames = new String[classNode.interfaceNames.length];
            for (int i = 0; i < classNode.interfaceNames.length; i++) {
                interfaceInterNames[i] = toInternalName(classNode.interfaceNames[i]);
            }
        }

        Clz clzInfo = classes.get(classNode.className);
        int access = classNode.access;
        boolean isInnerClass = false;
        if (clzInfo != null) {
            isInnerClass = clzInfo.enclosingClass != null || clzInfo.enclosingMethod != null;
        }
        access = clearClassAccess(isInnerClass, access);

        if (isSignatureNotValid(signature, false)) {
            System.err.println(""Applying workaround to class ""
                    + classNode.className
                    + "" with original signature "" + signature
                    + "" by changing its signature to null."");
            signature = null;
        }

        int version = dexVersion >= DexConstants.DEX_037 ? Opcodes.V1_8 : Opcodes.V1_6;
        cv.visit(version, access, toInternalName(classNode.className), signature,
                classNode.superClass == null ? null : toInternalName(classNode.superClass), interfaceInterNames);

        List<InnerClassNode> innerClassNodes = new ArrayList<InnerClassNode>(5);
        if (clzInfo != null) {
            searchInnerClass(clzInfo, innerClassNodes, classNode.className);
        }
        if (isInnerClass) {
            // build Outer Clz
            if (clzInfo.innerName == null) {// anonymous Innerclass
                Method enclosingMethod = clzInfo.enclosingMethod;
                if (enclosingMethod != null) {
                    cv.visitOuterClass(toInternalName(enclosingMethod.getOwner()), enclosingMethod.getName(),
                            enclosingMethod.getDesc());
                } else {
                    Clz enclosingClass = clzInfo.enclosingClass;
                    cv.visitOuterClass(toInternalName(enclosingClass.name), null, null);
                }
            }
            searchEnclosing(clzInfo, innerClassNodes);
        }
        Collections.sort(innerClassNodes, INNER_CLASS_NODE_COMPARATOR);
        for (InnerClassNode icn : innerClassNodes) {
            if (icn.innerName != null && !isJavaIdentifier(icn.innerName)) {
                System.err.println(""WARN: ignored invalid inner class name "" + "", treat as anonymous inner class."");
                icn.innerName = null;
                icn.outerName = null;
            }
            icn.accept(cv);
        }

        accept(classNode.anns, cv);

        if (classNode.fields != null) {
            for (DexFieldNode fieldNode : classNode.fields) {
                convertField(classNode, fieldNode, cv);
            }
        }
        if (classNode.methods != null) {
            ClzCtx clzCtx = new ClzCtx();
            clzCtx.classDescriptor = classNode.className;
            for (DexMethodNode methodNode : classNode.methods) {
                convertMethod(classNode, methodNode, cv, clzCtx);
            }
            if (clzCtx.hexDecodeMethodNamePrefix != null) {
                addHexDecodeMethod(cv, clzCtx.hexDecodeMethodNamePrefix);
            }
        }
        cv.visitEnd();
    }",iterator
i,"{
        ClassVisitor cv = cvf.create(toInternalName(classNode.className));
        if (cv == null) {
            return;
        }
        // the default value of static-final field are omitted by dex, fix it
        DexFix.fixStaticFinalFieldValue(classNode);

        String signature = null;
        if (classNode.anns != null) {
            for (DexAnnotationNode ann : classNode.anns) {
                if (ann.visibility == Visibility.SYSTEM) {
                    switch (ann.type) {
                    case DexConstants.ANNOTATION_SIGNATURE_TYPE: {
                        Object[] strs = (Object[]) findAnnotationAttribute(ann, ""value"");
                        if (strs != null) {
                            StringBuilder sb = new StringBuilder();
                            for (Object str : strs) {
                                sb.append(str);
                            }
                            signature = sb.toString();
                        }
                    }
                        break;
                    }
                }
            }
        }
        String interfaceInterNames[] = null;
        if (classNode.interfaceNames != null) {
            interfaceInterNames = new String[classNode.interfaceNames.length];
            for (int i = 0; i < classNode.interfaceNames.length; i++) {
                interfaceInterNames[i] = toInternalName(classNode.interfaceNames[i]);
            }
        }

        Clz clzInfo = classes.get(classNode.className);
        int access = classNode.access;
        boolean isInnerClass = false;
        if (clzInfo != null) {
            isInnerClass = clzInfo.enclosingClass != null || clzInfo.enclosingMethod != null;
        }
        access = clearClassAccess(isInnerClass, access);

        if (isSignatureNotValid(signature, false)) {
            System.err.println(""Applying workaround to class ""
                    + classNode.className
                    + "" with original signature "" + signature
                    + "" by changing its signature to null."");
            signature = null;
        }

        int version = dexVersion >= DexConstants.DEX_037 ? Opcodes.V1_8 : Opcodes.V1_6;
        cv.visit(version, access, toInternalName(classNode.className), signature,
                classNode.superClass == null ? null : toInternalName(classNode.superClass), interfaceInterNames);

        List<InnerClassNode> innerClassNodes = new ArrayList<InnerClassNode>(5);
        if (clzInfo != null) {
            searchInnerClass(clzInfo, innerClassNodes, classNode.className);
        }
        if (isInnerClass) {
            // build Outer Clz
            if (clzInfo.innerName == null) {// anonymous Innerclass
                Method enclosingMethod = clzInfo.enclosingMethod;
                if (enclosingMethod != null) {
                    cv.visitOuterClass(toInternalName(enclosingMethod.getOwner()), enclosingMethod.getName(),
                            enclosingMethod.getDesc());
                } else {
                    Clz enclosingClass = clzInfo.enclosingClass;
                    cv.visitOuterClass(toInternalName(enclosingClass.name), null, null);
                }
            }
            searchEnclosing(clzInfo, innerClassNodes);
        }
        Collections.sort(innerClassNodes, INNER_CLASS_NODE_COMPARATOR);
        for (InnerClassNode icn : innerClassNodes) {
            if (icn.innerName != null && !isJavaIdentifier(icn.innerName)) {
                System.err.println(""WARN: ignored invalid inner class name "" + "", treat as anonymous inner class."");
                icn.innerName = null;
                icn.outerName = null;
            }
            icn.accept(cv);
        }

        accept(classNode.anns, cv);

        if (classNode.fields != null) {
            for (DexFieldNode fieldNode : classNode.fields) {
                convertField(classNode, fieldNode, cv);
            }
        }
        if (classNode.methods != null) {
            ClzCtx clzCtx = new ClzCtx();
            clzCtx.classDescriptor = classNode.className;
            for (DexMethodNode methodNode : classNode.methods) {
                convertMethod(classNode, methodNode, cv, clzCtx);
            }
            if (clzCtx.hexDecodeMethodNamePrefix != null) {
                addHexDecodeMethod(cv, clzCtx.hexDecodeMethodNamePrefix);
            }
        }
        cv.visitEnd();
    }",loop_control
icn,"{
        ClassVisitor cv = cvf.create(toInternalName(classNode.className));
        if (cv == null) {
            return;
        }
        // the default value of static-final field are omitted by dex, fix it
        DexFix.fixStaticFinalFieldValue(classNode);

        String signature = null;
        if (classNode.anns != null) {
            for (DexAnnotationNode ann : classNode.anns) {
                if (ann.visibility == Visibility.SYSTEM) {
                    switch (ann.type) {
                    case DexConstants.ANNOTATION_SIGNATURE_TYPE: {
                        Object[] strs = (Object[]) findAnnotationAttribute(ann, ""value"");
                        if (strs != null) {
                            StringBuilder sb = new StringBuilder();
                            for (Object str : strs) {
                                sb.append(str);
                            }
                            signature = sb.toString();
                        }
                    }
                        break;
                    }
                }
            }
        }
        String interfaceInterNames[] = null;
        if (classNode.interfaceNames != null) {
            interfaceInterNames = new String[classNode.interfaceNames.length];
            for (int i = 0; i < classNode.interfaceNames.length; i++) {
                interfaceInterNames[i] = toInternalName(classNode.interfaceNames[i]);
            }
        }

        Clz clzInfo = classes.get(classNode.className);
        int access = classNode.access;
        boolean isInnerClass = false;
        if (clzInfo != null) {
            isInnerClass = clzInfo.enclosingClass != null || clzInfo.enclosingMethod != null;
        }
        access = clearClassAccess(isInnerClass, access);

        if (isSignatureNotValid(signature, false)) {
            System.err.println(""Applying workaround to class ""
                    + classNode.className
                    + "" with original signature "" + signature
                    + "" by changing its signature to null."");
            signature = null;
        }

        int version = dexVersion >= DexConstants.DEX_037 ? Opcodes.V1_8 : Opcodes.V1_6;
        cv.visit(version, access, toInternalName(classNode.className), signature,
                classNode.superClass == null ? null : toInternalName(classNode.superClass), interfaceInterNames);

        List<InnerClassNode> innerClassNodes = new ArrayList<InnerClassNode>(5);
        if (clzInfo != null) {
            searchInnerClass(clzInfo, innerClassNodes, classNode.className);
        }
        if (isInnerClass) {
            // build Outer Clz
            if (clzInfo.innerName == null) {// anonymous Innerclass
                Method enclosingMethod = clzInfo.enclosingMethod;
                if (enclosingMethod != null) {
                    cv.visitOuterClass(toInternalName(enclosingMethod.getOwner()), enclosingMethod.getName(),
                            enclosingMethod.getDesc());
                } else {
                    Clz enclosingClass = clzInfo.enclosingClass;
                    cv.visitOuterClass(toInternalName(enclosingClass.name), null, null);
                }
            }
            searchEnclosing(clzInfo, innerClassNodes);
        }
        Collections.sort(innerClassNodes, INNER_CLASS_NODE_COMPARATOR);
        for (InnerClassNode icn : innerClassNodes) {
            if (icn.innerName != null && !isJavaIdentifier(icn.innerName)) {
                System.err.println(""WARN: ignored invalid inner class name "" + "", treat as anonymous inner class."");
                icn.innerName = null;
                icn.outerName = null;
            }
            icn.accept(cv);
        }

        accept(classNode.anns, cv);

        if (classNode.fields != null) {
            for (DexFieldNode fieldNode : classNode.fields) {
                convertField(classNode, fieldNode, cv);
            }
        }
        if (classNode.methods != null) {
            ClzCtx clzCtx = new ClzCtx();
            clzCtx.classDescriptor = classNode.className;
            for (DexMethodNode methodNode : classNode.methods) {
                convertMethod(classNode, methodNode, cv, clzCtx);
            }
            if (clzCtx.hexDecodeMethodNamePrefix != null) {
                addHexDecodeMethod(cv, clzCtx.hexDecodeMethodNamePrefix);
            }
        }
        cv.visitEnd();
    }",iterator
fieldNode,"{
        ClassVisitor cv = cvf.create(toInternalName(classNode.className));
        if (cv == null) {
            return;
        }
        // the default value of static-final field are omitted by dex, fix it
        DexFix.fixStaticFinalFieldValue(classNode);

        String signature = null;
        if (classNode.anns != null) {
            for (DexAnnotationNode ann : classNode.anns) {
                if (ann.visibility == Visibility.SYSTEM) {
                    switch (ann.type) {
                    case DexConstants.ANNOTATION_SIGNATURE_TYPE: {
                        Object[] strs = (Object[]) findAnnotationAttribute(ann, ""value"");
                        if (strs != null) {
                            StringBuilder sb = new StringBuilder();
                            for (Object str : strs) {
                                sb.append(str);
                            }
                            signature = sb.toString();
                        }
                    }
                        break;
                    }
                }
            }
        }
        String interfaceInterNames[] = null;
        if (classNode.interfaceNames != null) {
            interfaceInterNames = new String[classNode.interfaceNames.length];
            for (int i = 0; i < classNode.interfaceNames.length; i++) {
                interfaceInterNames[i] = toInternalName(classNode.interfaceNames[i]);
            }
        }

        Clz clzInfo = classes.get(classNode.className);
        int access = classNode.access;
        boolean isInnerClass = false;
        if (clzInfo != null) {
            isInnerClass = clzInfo.enclosingClass != null || clzInfo.enclosingMethod != null;
        }
        access = clearClassAccess(isInnerClass, access);

        if (isSignatureNotValid(signature, false)) {
            System.err.println(""Applying workaround to class ""
                    + classNode.className
                    + "" with original signature "" + signature
                    + "" by changing its signature to null."");
            signature = null;
        }

        int version = dexVersion >= DexConstants.DEX_037 ? Opcodes.V1_8 : Opcodes.V1_6;
        cv.visit(version, access, toInternalName(classNode.className), signature,
                classNode.superClass == null ? null : toInternalName(classNode.superClass), interfaceInterNames);

        List<InnerClassNode> innerClassNodes = new ArrayList<InnerClassNode>(5);
        if (clzInfo != null) {
            searchInnerClass(clzInfo, innerClassNodes, classNode.className);
        }
        if (isInnerClass) {
            // build Outer Clz
            if (clzInfo.innerName == null) {// anonymous Innerclass
                Method enclosingMethod = clzInfo.enclosingMethod;
                if (enclosingMethod != null) {
                    cv.visitOuterClass(toInternalName(enclosingMethod.getOwner()), enclosingMethod.getName(),
                            enclosingMethod.getDesc());
                } else {
                    Clz enclosingClass = clzInfo.enclosingClass;
                    cv.visitOuterClass(toInternalName(enclosingClass.name), null, null);
                }
            }
            searchEnclosing(clzInfo, innerClassNodes);
        }
        Collections.sort(innerClassNodes, INNER_CLASS_NODE_COMPARATOR);
        for (InnerClassNode icn : innerClassNodes) {
            if (icn.innerName != null && !isJavaIdentifier(icn.innerName)) {
                System.err.println(""WARN: ignored invalid inner class name "" + "", treat as anonymous inner class."");
                icn.innerName = null;
                icn.outerName = null;
            }
            icn.accept(cv);
        }

        accept(classNode.anns, cv);

        if (classNode.fields != null) {
            for (DexFieldNode fieldNode : classNode.fields) {
                convertField(classNode, fieldNode, cv);
            }
        }
        if (classNode.methods != null) {
            ClzCtx clzCtx = new ClzCtx();
            clzCtx.classDescriptor = classNode.className;
            for (DexMethodNode methodNode : classNode.methods) {
                convertMethod(classNode, methodNode, cv, clzCtx);
            }
            if (clzCtx.hexDecodeMethodNamePrefix != null) {
                addHexDecodeMethod(cv, clzCtx.hexDecodeMethodNamePrefix);
            }
        }
        cv.visitEnd();
    }",iterator
methodNode,"{
        ClassVisitor cv = cvf.create(toInternalName(classNode.className));
        if (cv == null) {
            return;
        }
        // the default value of static-final field are omitted by dex, fix it
        DexFix.fixStaticFinalFieldValue(classNode);

        String signature = null;
        if (classNode.anns != null) {
            for (DexAnnotationNode ann : classNode.anns) {
                if (ann.visibility == Visibility.SYSTEM) {
                    switch (ann.type) {
                    case DexConstants.ANNOTATION_SIGNATURE_TYPE: {
                        Object[] strs = (Object[]) findAnnotationAttribute(ann, ""value"");
                        if (strs != null) {
                            StringBuilder sb = new StringBuilder();
                            for (Object str : strs) {
                                sb.append(str);
                            }
                            signature = sb.toString();
                        }
                    }
                        break;
                    }
                }
            }
        }
        String interfaceInterNames[] = null;
        if (classNode.interfaceNames != null) {
            interfaceInterNames = new String[classNode.interfaceNames.length];
            for (int i = 0; i < classNode.interfaceNames.length; i++) {
                interfaceInterNames[i] = toInternalName(classNode.interfaceNames[i]);
            }
        }

        Clz clzInfo = classes.get(classNode.className);
        int access = classNode.access;
        boolean isInnerClass = false;
        if (clzInfo != null) {
            isInnerClass = clzInfo.enclosingClass != null || clzInfo.enclosingMethod != null;
        }
        access = clearClassAccess(isInnerClass, access);

        if (isSignatureNotValid(signature, false)) {
            System.err.println(""Applying workaround to class ""
                    + classNode.className
                    + "" with original signature "" + signature
                    + "" by changing its signature to null."");
            signature = null;
        }

        int version = dexVersion >= DexConstants.DEX_037 ? Opcodes.V1_8 : Opcodes.V1_6;
        cv.visit(version, access, toInternalName(classNode.className), signature,
                classNode.superClass == null ? null : toInternalName(classNode.superClass), interfaceInterNames);

        List<InnerClassNode> innerClassNodes = new ArrayList<InnerClassNode>(5);
        if (clzInfo != null) {
            searchInnerClass(clzInfo, innerClassNodes, classNode.className);
        }
        if (isInnerClass) {
            // build Outer Clz
            if (clzInfo.innerName == null) {// anonymous Innerclass
                Method enclosingMethod = clzInfo.enclosingMethod;
                if (enclosingMethod != null) {
                    cv.visitOuterClass(toInternalName(enclosingMethod.getOwner()), enclosingMethod.getName(),
                            enclosingMethod.getDesc());
                } else {
                    Clz enclosingClass = clzInfo.enclosingClass;
                    cv.visitOuterClass(toInternalName(enclosingClass.name), null, null);
                }
            }
            searchEnclosing(clzInfo, innerClassNodes);
        }
        Collections.sort(innerClassNodes, INNER_CLASS_NODE_COMPARATOR);
        for (InnerClassNode icn : innerClassNodes) {
            if (icn.innerName != null && !isJavaIdentifier(icn.innerName)) {
                System.err.println(""WARN: ignored invalid inner class name "" + "", treat as anonymous inner class."");
                icn.innerName = null;
                icn.outerName = null;
            }
            icn.accept(cv);
        }

        accept(classNode.anns, cv);

        if (classNode.fields != null) {
            for (DexFieldNode fieldNode : classNode.fields) {
                convertField(classNode, fieldNode, cv);
            }
        }
        if (classNode.methods != null) {
            ClzCtx clzCtx = new ClzCtx();
            clzCtx.classDescriptor = classNode.className;
            for (DexMethodNode methodNode : classNode.methods) {
                convertMethod(classNode, methodNode, cv, clzCtx);
            }
            if (clzCtx.hexDecodeMethodNamePrefix != null) {
                addHexDecodeMethod(cv, clzCtx.hexDecodeMethodNamePrefix);
            }
        }
        cv.visitEnd();
    }",iterator
classNode,"{
        if (fileNode.clzs != null) {
            Map<String, Clz> classes = collectClzInfo(fileNode);
            for (DexClassNode classNode : fileNode.clzs) {
                convertClass(fileNode, classNode, cvf, classes);
            }
        }
    }",iterator
ann,"{
        String signature = null;
        if (fieldNode.anns != null) {
            for (DexAnnotationNode ann : fieldNode.anns) {
                if (ann.visibility == Visibility.SYSTEM) {
                    switch (ann.type) {
                    case DexConstants.ANNOTATION_SIGNATURE_TYPE: {
                        Object[] strs = (Object[]) findAnnotationAttribute(ann, ""value"");
                        if (strs != null) {
                            StringBuilder sb = new StringBuilder();
                            for (Object str : strs) {
                                sb.append(str);
                            }
                            signature = sb.toString();
                        }
                    }
                        break;
                    }
                }
            }
        }
        Object value = convertConstantValue(fieldNode.cst);

        // https://github.com/pxb1988/dex2jar/issues/455
        // try validate signature before call visitField
        if (isSignatureNotValid(signature, true)) {
            System.err.println(""Applying workaround to field ""
                    + fieldNode.field
                    + "" with original signature "" + signature
                    + "" by changing its signature to null."");
            signature = null;
        }


        final int fieldCleanFlag = ~((DexConstants.ACC_DECLARED_SYNCHRONIZED | Opcodes.ACC_SYNTHETIC));
        FieldVisitor fv = cv.visitField(fieldNode.access & fieldCleanFlag, fieldNode.field.getName(),
                    fieldNode.field.getType(), signature, value);

        if (fv == null) {
            return;
        }
        accept(fieldNode.anns, fv);
        fv.visitEnd();
    }",iterator
str,"{
        String signature = null;
        if (fieldNode.anns != null) {
            for (DexAnnotationNode ann : fieldNode.anns) {
                if (ann.visibility == Visibility.SYSTEM) {
                    switch (ann.type) {
                    case DexConstants.ANNOTATION_SIGNATURE_TYPE: {
                        Object[] strs = (Object[]) findAnnotationAttribute(ann, ""value"");
                        if (strs != null) {
                            StringBuilder sb = new StringBuilder();
                            for (Object str : strs) {
                                sb.append(str);
                            }
                            signature = sb.toString();
                        }
                    }
                        break;
                    }
                }
            }
        }
        Object value = convertConstantValue(fieldNode.cst);

        // https://github.com/pxb1988/dex2jar/issues/455
        // try validate signature before call visitField
        if (isSignatureNotValid(signature, true)) {
            System.err.println(""Applying workaround to field ""
                    + fieldNode.field
                    + "" with original signature "" + signature
                    + "" by changing its signature to null."");
            signature = null;
        }


        final int fieldCleanFlag = ~((DexConstants.ACC_DECLARED_SYNCHRONIZED | Opcodes.ACC_SYNTHETIC));
        FieldVisitor fv = cv.visitField(fieldNode.access & fieldCleanFlag, fieldNode.field.getName(),
                    fieldNode.field.getType(), signature, value);

        if (fv == null) {
            return;
        }
        accept(fieldNode.anns, fv);
        fv.visitEnd();
    }",iterator
i,"{
        Object[] copy = Arrays.copyOf(v, v.length);
        for (int i = 0; i < copy.length; i++) {
            Object ele = copy[i];
            ele = convertConstantValue(ele);
            copy[i] = ele;
        }
        return copy;
    }",loop_control
ann,"{

        MethodVisitor mv = collectBasicMethodInfo(methodNode, cv);

        if (mv == null) {
            return;
        }
        if (0 != (classNode.access & DexConstants.ACC_ANNOTATION)) { // its inside an annotation
            Object defaultValue = null;
            if (classNode.anns != null) {
                for (DexAnnotationNode ann : classNode.anns) {
                    if (ann.visibility == Visibility.SYSTEM && ann.type.equals(DexConstants.ANNOTATION_DEFAULT_TYPE)) {
                        DexAnnotationNode node = (DexAnnotationNode) findAnnotationAttribute(ann, ""value"");
                        if (node != null) {
                            defaultValue = findAnnotationAttribute(node, methodNode.method.getName());
                        }
                        break;
                    }
                }
            }
            if (defaultValue != null) {
                AnnotationVisitor av = mv.visitAnnotationDefault();
                if (av != null) {
                    accept(av, null, defaultValue);
                    av.visitEnd();
                }
            }
        }

        accept(methodNode.anns, mv);

        if (methodNode.parameterAnns != null) {
            for (int i = 0; i < methodNode.parameterAnns.length; i++) {
                List<DexAnnotationNode> anns = methodNode.parameterAnns[i];
                if (anns != null) {
                    for (DexAnnotationNode ann : anns) {
                        if (ann.visibility != Visibility.SYSTEM) {
                            acceptParameter(ann, i, mv);
                        }
                    }
                }
            }
        }

        if ((NO_CODE_MASK & methodNode.access) == 0) { // has code
            if (methodNode.codeNode != null) {
                mv.visitCode();
                convertCode(methodNode, mv, clzCtx);
            }
        }

        mv.visitEnd();

    }",iterator
i,"{

        MethodVisitor mv = collectBasicMethodInfo(methodNode, cv);

        if (mv == null) {
            return;
        }
        if (0 != (classNode.access & DexConstants.ACC_ANNOTATION)) { // its inside an annotation
            Object defaultValue = null;
            if (classNode.anns != null) {
                for (DexAnnotationNode ann : classNode.anns) {
                    if (ann.visibility == Visibility.SYSTEM && ann.type.equals(DexConstants.ANNOTATION_DEFAULT_TYPE)) {
                        DexAnnotationNode node = (DexAnnotationNode) findAnnotationAttribute(ann, ""value"");
                        if (node != null) {
                            defaultValue = findAnnotationAttribute(node, methodNode.method.getName());
                        }
                        break;
                    }
                }
            }
            if (defaultValue != null) {
                AnnotationVisitor av = mv.visitAnnotationDefault();
                if (av != null) {
                    accept(av, null, defaultValue);
                    av.visitEnd();
                }
            }
        }

        accept(methodNode.anns, mv);

        if (methodNode.parameterAnns != null) {
            for (int i = 0; i < methodNode.parameterAnns.length; i++) {
                List<DexAnnotationNode> anns = methodNode.parameterAnns[i];
                if (anns != null) {
                    for (DexAnnotationNode ann : anns) {
                        if (ann.visibility != Visibility.SYSTEM) {
                            acceptParameter(ann, i, mv);
                        }
                    }
                }
            }
        }

        if ((NO_CODE_MASK & methodNode.access) == 0) { // has code
            if (methodNode.codeNode != null) {
                mv.visitCode();
                convertCode(methodNode, mv, clzCtx);
            }
        }

        mv.visitEnd();

    }",loop_control
ann,"{

        MethodVisitor mv = collectBasicMethodInfo(methodNode, cv);

        if (mv == null) {
            return;
        }
        if (0 != (classNode.access & DexConstants.ACC_ANNOTATION)) { // its inside an annotation
            Object defaultValue = null;
            if (classNode.anns != null) {
                for (DexAnnotationNode ann : classNode.anns) {
                    if (ann.visibility == Visibility.SYSTEM && ann.type.equals(DexConstants.ANNOTATION_DEFAULT_TYPE)) {
                        DexAnnotationNode node = (DexAnnotationNode) findAnnotationAttribute(ann, ""value"");
                        if (node != null) {
                            defaultValue = findAnnotationAttribute(node, methodNode.method.getName());
                        }
                        break;
                    }
                }
            }
            if (defaultValue != null) {
                AnnotationVisitor av = mv.visitAnnotationDefault();
                if (av != null) {
                    accept(av, null, defaultValue);
                    av.visitEnd();
                }
            }
        }

        accept(methodNode.anns, mv);

        if (methodNode.parameterAnns != null) {
            for (int i = 0; i < methodNode.parameterAnns.length; i++) {
                List<DexAnnotationNode> anns = methodNode.parameterAnns[i];
                if (anns != null) {
                    for (DexAnnotationNode ann : anns) {
                        if (ann.visibility != Visibility.SYSTEM) {
                            acceptParameter(ann, i, mv);
                        }
                    }
                }
            }
        }

        if ((NO_CODE_MASK & methodNode.access) == 0) { // has code
            if (methodNode.codeNode != null) {
                mv.visitCode();
                convertCode(methodNode, mv, clzCtx);
            }
        }

        mv.visitEnd();

    }",iterator
item,"{
        for (DexAnnotationNode.Item item : ann.items) {
            if (item.name.equals(name)) {
                return item.value;
            }
        }
        return null;
    }",iterator
p,"{
        Set<Clz> visitedClz = new HashSet<>();
        for (Clz p = clz; p != null; p = p.enclosingClass) {
            if (!visitedClz.add(p)) { // prevent endless loop
                break;
            }
            Clz enclosingClass = p.enclosingClass;
            if (enclosingClass == null) {
                break;
            }
            if (enclosingClass == clz) {
                // enclosing itself, that is impossible
                break;
            }
            int accessInInner = clearInnerAccess(p.access);
            if (p.innerName != null) {// non-anonymous Innerclass
                innerClassNodes.add(new InnerClassNode(toInternalName(p.name),
                        toInternalName(enclosingClass.name), p.innerName, accessInInner));
            } else {// anonymous Innerclass
                innerClassNodes.add(new InnerClassNode(toInternalName(p.name), null, null, accessInInner));
            }
        }
    }",maybe_loop_control
visitedClz,"{
        Set<Clz> visitedClz = new HashSet<>();
        for (Clz p = clz; p != null; p = p.enclosingClass) {
            if (!visitedClz.add(p)) { // prevent endless loop
                break;
            }
            Clz enclosingClass = p.enclosingClass;
            if (enclosingClass == null) {
                break;
            }
            if (enclosingClass == clz) {
                // enclosing itself, that is impossible
                break;
            }
            int accessInInner = clearInnerAccess(p.access);
            if (p.innerName != null) {// non-anonymous Innerclass
                innerClassNodes.add(new InnerClassNode(toInternalName(p.name),
                        toInternalName(enclosingClass.name), p.innerName, accessInInner));
            } else {// anonymous Innerclass
                innerClassNodes.add(new InnerClassNode(toInternalName(p.name), null, null, accessInInner));
            }
        }
    }",break_loop_control
enclosingClass,"{
        Set<Clz> visitedClz = new HashSet<>();
        for (Clz p = clz; p != null; p = p.enclosingClass) {
            if (!visitedClz.add(p)) { // prevent endless loop
                break;
            }
            Clz enclosingClass = p.enclosingClass;
            if (enclosingClass == null) {
                break;
            }
            if (enclosingClass == clz) {
                // enclosing itself, that is impossible
                break;
            }
            int accessInInner = clearInnerAccess(p.access);
            if (p.innerName != null) {// non-anonymous Innerclass
                innerClassNodes.add(new InnerClassNode(toInternalName(p.name),
                        toInternalName(enclosingClass.name), p.innerName, accessInInner));
            } else {// anonymous Innerclass
                innerClassNodes.add(new InnerClassNode(toInternalName(p.name), null, null, accessInInner));
            }
        }
    }",break_loop_control
stack,"{
        Set<Clz> visited = new HashSet<>();
        Stack<Clz> stack = new Stack<>();
        stack.push(clz);
        while (!stack.empty()) {
            clz = stack.pop();
            if (visited.contains(clz)) {
                continue;
            } else {
                visited.add(clz);
            }
            if (clz.inners != null) {
                for (Clz inner : clz.inners) {
                    if (inner.innerName == null) {// anonymous Innerclass
                        innerClassNodes.add(new InnerClassNode(toInternalName(inner.name), null, null,
                                clearInnerAccess(inner.access)));
                    } else {// non-anonymous Innerclass
                        innerClassNodes.add(new InnerClassNode(toInternalName(inner.name), toInternalName(className),
                                inner.innerName, clearInnerAccess(inner.access)));
                    }
                    stack.push(inner);
                }
            }
        }
    }",maybe_loop_control
inner,"{
        Set<Clz> visited = new HashSet<>();
        Stack<Clz> stack = new Stack<>();
        stack.push(clz);
        while (!stack.empty()) {
            clz = stack.pop();
            if (visited.contains(clz)) {
                continue;
            } else {
                visited.add(clz);
            }
            if (clz.inners != null) {
                for (Clz inner : clz.inners) {
                    if (inner.innerName == null) {// anonymous Innerclass
                        innerClassNodes.add(new InnerClassNode(toInternalName(inner.name), null, null,
                                clearInnerAccess(inner.access)));
                    } else {// non-anonymous Innerclass
                        innerClassNodes.add(new InnerClassNode(toInternalName(inner.name), toInternalName(className),
                                inner.innerName, clearInnerAccess(inner.access)));
                    }
                    stack.push(inner);
                }
            }
        }
    }",iterator
classNode,"{
        if (dex.clzs != null) {
            for (DexClassNode classNode : dex.clzs) {
                fixStaticFinalFieldValue(classNode);
            }
        }
    }",iterator
fn,"{
        if (classNode.fields == null) {
            return;
        }
        final Map<String, DexFieldNode> fs = new HashMap<>();
        final Map<String, DexFieldNode> shouldNotBeAssigned = new HashMap<>();
        for (DexFieldNode fn : classNode.fields) {
            if ((fn.access & ACC_STATIC_FINAL) == ACC_STATIC_FINAL) {
                if (fn.cst == null) {
                    char t = fn.field.getType().charAt(0);
                    if (t == 'L' || t == '[') {
                        // ignore Object
                        continue;
                    }
                    fs.put(fn.field.getName() + "":"" + fn.field.getType(), fn);
                } else if (isPrimitiveZero(fn.field.getType(), fn.cst)) {
                    shouldNotBeAssigned.put(fn.field.getName() + "":"" + fn.field.getType(), fn);
                }
            }
        }
        if (fs.isEmpty() && shouldNotBeAssigned.isEmpty()) {
            return;
        }
        DexMethodNode node = null;
        if (classNode.methods != null) {
            for (DexMethodNode mn : classNode.methods) {
                if (mn.method.getName().equals(""<clinit>"")) {
                    node = mn;
                    break;
                }
            }
        }
        if (node != null) {
            if (node.codeNode != null) {
                node.codeNode.accept(new DexCodeVisitor() {
                    @Override
                    public void visitFieldStmt(Op op, int a, int b, Field field) {
                        switch (op) {
                        case SPUT:
                        case SPUT_BOOLEAN:
                        case SPUT_BYTE:
                        case SPUT_CHAR:
                        case SPUT_OBJECT:
                        case SPUT_SHORT:
                        case SPUT_WIDE:
                            if (field.getOwner().equals(classNode.className)) {
                                String key = field.getName() + "":"" + field.getType();
                                fs.remove(key);
                                DexFieldNode dn = shouldNotBeAssigned.get(key);
                                if (dn != null) {
                                    //System.out.println(field.getName() + "":"" + field.getType());
                                    dn.cst = null;
                                }
                            }
                            break;
                        default:
                            // ignored
                            break;
                        }
                    }
                });
            } else {
                // has init but no code
                return;
            }
        }

        for (DexFieldNode fn : fs.values()) {
            fn.cst = getDefaultValueOfType(fn.field.getType().charAt(0));
        }

    }",iterator
mn,"{
        if (classNode.fields == null) {
            return;
        }
        final Map<String, DexFieldNode> fs = new HashMap<>();
        final Map<String, DexFieldNode> shouldNotBeAssigned = new HashMap<>();
        for (DexFieldNode fn : classNode.fields) {
            if ((fn.access & ACC_STATIC_FINAL) == ACC_STATIC_FINAL) {
                if (fn.cst == null) {
                    char t = fn.field.getType().charAt(0);
                    if (t == 'L' || t == '[') {
                        // ignore Object
                        continue;
                    }
                    fs.put(fn.field.getName() + "":"" + fn.field.getType(), fn);
                } else if (isPrimitiveZero(fn.field.getType(), fn.cst)) {
                    shouldNotBeAssigned.put(fn.field.getName() + "":"" + fn.field.getType(), fn);
                }
            }
        }
        if (fs.isEmpty() && shouldNotBeAssigned.isEmpty()) {
            return;
        }
        DexMethodNode node = null;
        if (classNode.methods != null) {
            for (DexMethodNode mn : classNode.methods) {
                if (mn.method.getName().equals(""<clinit>"")) {
                    node = mn;
                    break;
                }
            }
        }
        if (node != null) {
            if (node.codeNode != null) {
                node.codeNode.accept(new DexCodeVisitor() {
                    @Override
                    public void visitFieldStmt(Op op, int a, int b, Field field) {
                        switch (op) {
                        case SPUT:
                        case SPUT_BOOLEAN:
                        case SPUT_BYTE:
                        case SPUT_CHAR:
                        case SPUT_OBJECT:
                        case SPUT_SHORT:
                        case SPUT_WIDE:
                            if (field.getOwner().equals(classNode.className)) {
                                String key = field.getName() + "":"" + field.getType();
                                fs.remove(key);
                                DexFieldNode dn = shouldNotBeAssigned.get(key);
                                if (dn != null) {
                                    //System.out.println(field.getName() + "":"" + field.getType());
                                    dn.cst = null;
                                }
                            }
                            break;
                        default:
                            // ignored
                            break;
                        }
                    }
                });
            } else {
                // has init but no code
                return;
            }
        }

        for (DexFieldNode fn : fs.values()) {
            fn.cst = getDefaultValueOfType(fn.field.getType().charAt(0));
        }

    }",iterator
mn,"{
        if (classNode.fields == null) {
            return;
        }
        final Map<String, DexFieldNode> fs = new HashMap<>();
        final Map<String, DexFieldNode> shouldNotBeAssigned = new HashMap<>();
        for (DexFieldNode fn : classNode.fields) {
            if ((fn.access & ACC_STATIC_FINAL) == ACC_STATIC_FINAL) {
                if (fn.cst == null) {
                    char t = fn.field.getType().charAt(0);
                    if (t == 'L' || t == '[') {
                        // ignore Object
                        continue;
                    }
                    fs.put(fn.field.getName() + "":"" + fn.field.getType(), fn);
                } else if (isPrimitiveZero(fn.field.getType(), fn.cst)) {
                    shouldNotBeAssigned.put(fn.field.getName() + "":"" + fn.field.getType(), fn);
                }
            }
        }
        if (fs.isEmpty() && shouldNotBeAssigned.isEmpty()) {
            return;
        }
        DexMethodNode node = null;
        if (classNode.methods != null) {
            for (DexMethodNode mn : classNode.methods) {
                if (mn.method.getName().equals(""<clinit>"")) {
                    node = mn;
                    break;
                }
            }
        }
        if (node != null) {
            if (node.codeNode != null) {
                node.codeNode.accept(new DexCodeVisitor() {
                    @Override
                    public void visitFieldStmt(Op op, int a, int b, Field field) {
                        switch (op) {
                        case SPUT:
                        case SPUT_BOOLEAN:
                        case SPUT_BYTE:
                        case SPUT_CHAR:
                        case SPUT_OBJECT:
                        case SPUT_SHORT:
                        case SPUT_WIDE:
                            if (field.getOwner().equals(classNode.className)) {
                                String key = field.getName() + "":"" + field.getType();
                                fs.remove(key);
                                DexFieldNode dn = shouldNotBeAssigned.get(key);
                                if (dn != null) {
                                    //System.out.println(field.getName() + "":"" + field.getType());
                                    dn.cst = null;
                                }
                            }
                            break;
                        default:
                            // ignored
                            break;
                        }
                    }
                });
            } else {
                // has init but no code
                return;
            }
        }

        for (DexFieldNode fn : fs.values()) {
            fn.cst = getDefaultValueOfType(fn.field.getType().charAt(0));
        }

    }",break_loop_control
fn,"{
        if (classNode.fields == null) {
            return;
        }
        final Map<String, DexFieldNode> fs = new HashMap<>();
        final Map<String, DexFieldNode> shouldNotBeAssigned = new HashMap<>();
        for (DexFieldNode fn : classNode.fields) {
            if ((fn.access & ACC_STATIC_FINAL) == ACC_STATIC_FINAL) {
                if (fn.cst == null) {
                    char t = fn.field.getType().charAt(0);
                    if (t == 'L' || t == '[') {
                        // ignore Object
                        continue;
                    }
                    fs.put(fn.field.getName() + "":"" + fn.field.getType(), fn);
                } else if (isPrimitiveZero(fn.field.getType(), fn.cst)) {
                    shouldNotBeAssigned.put(fn.field.getName() + "":"" + fn.field.getType(), fn);
                }
            }
        }
        if (fs.isEmpty() && shouldNotBeAssigned.isEmpty()) {
            return;
        }
        DexMethodNode node = null;
        if (classNode.methods != null) {
            for (DexMethodNode mn : classNode.methods) {
                if (mn.method.getName().equals(""<clinit>"")) {
                    node = mn;
                    break;
                }
            }
        }
        if (node != null) {
            if (node.codeNode != null) {
                node.codeNode.accept(new DexCodeVisitor() {
                    @Override
                    public void visitFieldStmt(Op op, int a, int b, Field field) {
                        switch (op) {
                        case SPUT:
                        case SPUT_BOOLEAN:
                        case SPUT_BYTE:
                        case SPUT_CHAR:
                        case SPUT_OBJECT:
                        case SPUT_SHORT:
                        case SPUT_WIDE:
                            if (field.getOwner().equals(classNode.className)) {
                                String key = field.getName() + "":"" + field.getType();
                                fs.remove(key);
                                DexFieldNode dn = shouldNotBeAssigned.get(key);
                                if (dn != null) {
                                    //System.out.println(field.getName() + "":"" + field.getType());
                                    dn.cst = null;
                                }
                            }
                            break;
                        default:
                            // ignored
                            break;
                        }
                    }
                });
            } else {
                // has init but no code
                return;
            }
        }

        for (DexFieldNode fn : fs.values()) {
            fn.cst = getDefaultValueOfType(fn.field.getType().charAt(0));
        }

    }",iterator
p,"{

        DexFileNode fileNode = new DexFileNode();
        try {
            reader.accept(fileNode, readerConfig | DexFileReader.IGNORE_READ_EXCEPTION);
        } catch (Exception ex) {
            exceptionHandler.handleFileException(ex);
        }
        ClassVisitorFactory cvf = new ClassVisitorFactory() {
            @Override
            public ClassVisitor create(final String name) {
                final ClassWriter cw = new ClassWriter(ClassWriter.COMPUTE_MAXS);
                final LambadaNameSafeClassAdapter rca = new LambadaNameSafeClassAdapter(cw);
                return new ClassVisitor(Opcodes.ASM5, rca) {
                    @Override
                    public void visitEnd() {
                        super.visitEnd();
                        String className = rca.getClassName();
                        byte[] data;
                        try {
                            // FIXME handle 'java.lang.RuntimeException: Method code too large!'
                            data = cw.toByteArray();
                        } catch (Exception ex) {
                            System.err.println(String.format(""ASM fail to generate .class file: %s"", className));
                            exceptionHandler.handleFileException(ex);
                            return;
                        }
                        try {
                            Path dist1 = dist.resolve(className + "".class"");
                            Path parent = dist1.getParent();
                            if (parent != null && !Files.exists(parent)) {
                                Files.createDirectories(parent);
                            }
                            Files.write(dist1, data);
                        } catch (IOException e) {
                            e.printStackTrace(System.err);
                        }
                    }
                };
            }
        };

        new ExDex2Asm(exceptionHandler) {
            public void convertCode(DexMethodNode methodNode, MethodVisitor mv, ClzCtx clzCtx) {
                if ((readerConfig & DexFileReader.SKIP_CODE) != 0 && methodNode.method.getName().equals(""<clinit>"")) {
                    // also skip clinit
                    return;
                }
                super.convertCode(methodNode, mv, clzCtx);
            }

            @Override
            public void optimize(IrMethod irMethod) {
                T_cleanLabel.transform(irMethod);
                if (0 != (v3Config & V3.TOPOLOGICAL_SORT)) {
                    // T_topologicalSort.transform(irMethod);
                }
                T_deadCode.transform(irMethod);
                T_removeLocal.transform(irMethod);
                T_removeConst.transform(irMethod);
                T_zero.transform(irMethod);
                if (T_npe.transformReportChanged(irMethod)) {
                    T_deadCode.transform(irMethod);
                    T_removeLocal.transform(irMethod);
                    T_removeConst.transform(irMethod);
                }
                T_new.transform(irMethod);
                T_fillArray.transform(irMethod);
                T_agg.transform(irMethod);
                T_multiArray.transform(irMethod);
                T_voidInvoke.transform(irMethod);
                if (0 != (v3Config & V3.PRINT_IR)) {
                    int i = 0;
                    for (Stmt p : irMethod.stmts) {
                        if (p.st == Stmt.ST.LABEL) {
                            LabelStmt labelStmt = (LabelStmt) p;
                            labelStmt.displayName = ""L"" + i++;
                        }
                    }
                    System.out.println(irMethod);
                }
                {
                    // https://github.com/pxb1988/dex2jar/issues/477
                    // dead code found in unssa, clean up
                    T_deadCode.transform(irMethod);
                    T_removeLocal.transform(irMethod);
                    T_removeConst.transform(irMethod);
                }
                T_type.transform(irMethod);
                T_unssa.transform(irMethod);
                T_ir2jRegAssign.transform(irMethod);
                T_trimEx.transform(irMethod);
            }

            @Override
            public void ir2j(IrMethod irMethod, MethodVisitor mv, ClzCtx clzCtx) {
                new IR2JConverter()
                        .optimizeSynchronized(0 != (V3.OPTIMIZE_SYNCHRONIZED & v3Config))
                        .clzCtx(clzCtx)
                        .ir(irMethod)
                        .asm(mv)
                        .convert();
            }
        }.convertDex(fileNode, cvf);

    }",iterator
p,"{
        Map<String, Object> env = new HashMap<>();
        env.put(""create"", ""true"");
        Files.deleteIfExists(output);
        Path parent = output.getParent();
        if (parent != null && !Files.exists(parent)) {
            Files.createDirectories(parent);
        }
        for (FileSystemProvider p : FileSystemProvider.installedProviders()) {
            String s = p.getScheme();
            if (""jar"".equals(s) || ""zip"".equalsIgnoreCase(s)) {
                return p.newFileSystem(output, env);
            }
        }
        throw new IOException(""cant find zipfs support"");
    }",iterator
s,"{
        Map<String, Object> env = new HashMap<>();
        env.put(""create"", ""true"");
        Files.deleteIfExists(output);
        Path parent = output.getParent();
        if (parent != null && !Files.exists(parent)) {
            Files.createDirectories(parent);
        }
        for (FileSystemProvider p : FileSystemProvider.installedProviders()) {
            String s = p.getScheme();
            if (""jar"".equals(s) || ""zip"".equalsIgnoreCase(s)) {
                return p.newFileSystem(output, env);
            }
        }
        throw new IOException(""cant find zipfs support"");
    }",break_loop_control
t,"{
        int a = isStatic ? 0 : 1;
        for (String t : m.getParameterTypes()) {
            switch (t.charAt(0)) {
            case 'J':
            case 'D':
                a += 2;
                break;
            default:
                a += 1;
                break;
            }
        }
        return a;
    }",iterator
t,"{
        int a = isStatic ? 0 : 1;
        for (String t : m.getParameterTypes()) {
            switch (t.charAt(0)) {
            case 'J':
            case 'D':
                a += 2;
                break;
            default:
                a += 1;
                break;
            }
        }
        return a;
    }",break_loop_control
i,"{
        Local[] locals = new Local[total];
        this.locals = locals;
        this.tmpLocal = new Local(total);
        for (int i = 0; i < locals.length; i++) {
            locals[i] = new Local(i);
        }
        int nextReg = total - countParameterRegisters(method, isStatic);
        int nextReg0 = nextReg;
        if (!isStatic) {// is not static
            x(Stmts.nIdentity(locals[nextReg], Exprs.nThisRef(method.getOwner())));
            nextReg++;
        }
        String[] args = method.getParameterTypes();
        for (int i = 0; i < args.length; i++) {
            String t = args[i];
            x(Stmts.nIdentity(locals[nextReg], Exprs.nParameterRef(t, i)));
            nextReg++;
            if (t.equals(""J"") || t.equals(""D"")) {
                nextReg++;
            }
        }
        // simple fix for issue 219, init all tmp register to 0 at the start of insn.
        for (int i = 0; i < nextReg0; i++) {
            x(Stmts.nAssign(locals[i], nInt(0)));
        }
        x(Stmts.nAssign(tmpLocal, nInt(0)));
    }",loop_control
i,"{
        Local array = tmpLocal;
        String elem = type.substring(1);
        list.add(nAssign(array, nNewArray(elem, nInt(args.length))));
        for (int i = 0; i < args.length; i++) {
            list.add(nAssign(nArray(array, nInt(i), elem), locals[args[i]]));
        }
    }",loop_control
i,"{
        LabelStmt[] lss = new LabelStmt[cases.length];
        for (int i = 0; i < cases.length; i++) {
            lss[i] = toLabelStmt(labels[i]);
        }
        LabelStmt d = new LabelStmt();
        x(nLookupSwitch(locals[aA], cases, lss, d));
        x(d);
    }",loop_control
t,"{
        Value[] vs;
        if (args.length > 0) {
            int i = 0;
            List<Local> ps = new ArrayList<Local>(args.length);
            if (op == Op.INVOKE_STATIC || op == Op.INVOKE_STATIC_RANGE) {
                ;
            } else {
                ps.add(locals[args[i]]);
                i++;
            }
            for (String t : method.getParameterTypes()) {
                ps.add(locals[args[i]]);
                if (t.equals(""J"") || t.equals(""D"")) {
                    i += 2;
                } else {
                    i++;
                }
            }
            vs = ps.toArray(new Value[ps.size()]);
        } else {
            vs = new Value[0];
        }

        Value invoke = null;
        switch (op) {
        case INVOKE_VIRTUAL_RANGE:
        case INVOKE_VIRTUAL:
            invoke = nInvokeVirtual(vs, method.getOwner(), method.getName(), method.getParameterTypes(),
                    method.getReturnType());
            break;
        case INVOKE_SUPER_RANGE:
        case INVOKE_DIRECT_RANGE:
        case INVOKE_SUPER:
        case INVOKE_DIRECT:
            invoke = nInvokeSpecial(vs, method.getOwner(), method.getName(), method.getParameterTypes(),
                    method.getReturnType());
            break;
        case INVOKE_STATIC_RANGE:
        case INVOKE_STATIC:
            invoke = nInvokeStatic(vs, method.getOwner(), method.getName(), method.getParameterTypes(),
                    method.getReturnType());
            break;
        case INVOKE_INTERFACE_RANGE:
        case INVOKE_INTERFACE:
            invoke = nInvokeInterface(vs, method.getOwner(), method.getName(), method.getParameterTypes(),
                    method.getReturnType());
            break;
        default:
            throw new RuntimeException();
        }
        if (""V"".equals(method.getReturnType())) {
            x(nVoidInvoke(invoke));
        } else {
            x(nAssign(tmpLocal, invoke));
        }
    }",iterator
i,"{
        LabelStmt[] lss = new LabelStmt[labels.length];
        for (int i = 0; i < labels.length; i++) {
            lss[i] = toLabelStmt(labels[i]);
        }
        LabelStmt d = new LabelStmt();
        x(nTableSwitch(locals[aA], first_case, lss, d));
        x(d);
    }",loop_control
i,"{
        LabelStmt xlabelStmts[] = new LabelStmt[types.length];
        for (int i = 0; i < types.length; i++) {
            xlabelStmts[i] = toLabelStmt(handlers[i]);
        }
        irMethod.traps.add(new Trap(toLabelStmt(start), toLabelStmt(end), xlabelStmts, types));
    }",loop_control
n,"{
        if (codeNode.tryStmts != null) {
            for (TryCatchNode n : codeNode.tryStmts) {
                n.accept(this);
            }
        }
        if (codeNode.debugNode != null) {
            DexDebugVisitor ddv = this.visitDebug();
            if (ddv != null) {
                codeNode.debugNode.accept(ddv);
                ddv.visitEnd();
            }
        }
        lastIsInvokeOrFilledNewArray = false;
        if (codeNode.totalRegister >= 0) {
            this.visitRegister(codeNode.totalRegister);
        }
        for (DexStmtNode n : codeNode.stmts) {
            n.accept(this);
            if (n instanceof FilledNewArrayStmtNode) {
                lastIsInvokeOrFilledNewArray = true;
            } else if (n instanceof MethodStmtNode) {
                lastIsInvokeOrFilledNewArray = !((MethodStmtNode) n).method.getReturnType().equals(""V"");
            } else if (!(n instanceof DexLabelStmtNode)) {
                lastIsInvokeOrFilledNewArray = false;
            }
        }

        visitEnd();
        return irMethod;
    }",iterator
p,"{
        for (Stmt p : ir.stmts) {
            if (p.st == ST.LABEL) {
                LabelStmt labelStmt = (LabelStmt) p;
                labelStmt.tag = new Label();
            }
        }
    }",iterator
trap,"{
        for (Trap trap : ir.traps) {
            boolean needAdd = false;
            for (Stmt p = trap.start.getNext(); p != null && p != trap.end; p = p.getNext()) {
                if (p.st != ST.LABEL) {
                    needAdd = true;
                    break;
                }
            }
            if (needAdd) {
                for (int i = 0; i < trap.handlers.length; i++) {
                    String type = trap.types[i];
                    asm.visitTryCatchBlock((Label) trap.start.tag, (Label) trap.end.tag, (Label) trap.handlers[i].tag,
                            type == null ? null : toInternal(type));
                }
            }
        }
    }",iterator
p,"{
        for (Trap trap : ir.traps) {
            boolean needAdd = false;
            for (Stmt p = trap.start.getNext(); p != null && p != trap.end; p = p.getNext()) {
                if (p.st != ST.LABEL) {
                    needAdd = true;
                    break;
                }
            }
            if (needAdd) {
                for (int i = 0; i < trap.handlers.length; i++) {
                    String type = trap.types[i];
                    asm.visitTryCatchBlock((Label) trap.start.tag, (Label) trap.end.tag, (Label) trap.handlers[i].tag,
                            type == null ? null : toInternal(type));
                }
            }
        }
    }",maybe_loop_control
p,"{
        for (Trap trap : ir.traps) {
            boolean needAdd = false;
            for (Stmt p = trap.start.getNext(); p != null && p != trap.end; p = p.getNext()) {
                if (p.st != ST.LABEL) {
                    needAdd = true;
                    break;
                }
            }
            if (needAdd) {
                for (int i = 0; i < trap.handlers.length; i++) {
                    String type = trap.types[i];
                    asm.visitTryCatchBlock((Label) trap.start.tag, (Label) trap.end.tag, (Label) trap.handlers[i].tag,
                            type == null ? null : toInternal(type));
                }
            }
        }
    }",break_loop_control
i,"{
        for (Trap trap : ir.traps) {
            boolean needAdd = false;
            for (Stmt p = trap.start.getNext(); p != null && p != trap.end; p = p.getNext()) {
                if (p.st != ST.LABEL) {
                    needAdd = true;
                    break;
                }
            }
            if (needAdd) {
                for (int i = 0; i < trap.handlers.length; i++) {
                    String type = trap.types[i];
                    asm.visitTryCatchBlock((Label) trap.start.tag, (Label) trap.end.tag, (Label) trap.handlers[i].tag,
                            type == null ? null : toInternal(type));
                }
            }
        }
    }",loop_control
local,"{
        asm = new LdcOptimizeAdapter(asm);
        int maxLocalIndex = 0;
        for (Local local : ir.locals) {
            maxLocalIndex = Math.max(maxLocalIndex, local._ls_index);
        }
        Map<String, Integer> lockMap = new HashMap<String, Integer>();
        for (Stmt st : ir.stmts) {
            switch (st.st) {
            case LABEL:
                LabelStmt labelStmt = (LabelStmt) st;
                Label label = (Label) labelStmt.tag;
                asm.visitLabel(label);
                if (labelStmt.lineNumber >= 0) {
                    asm.visitLineNumber(labelStmt.lineNumber, label);
                }
                break;
            case ASSIGN: {
                E2Stmt e2 = (E2Stmt) st;
                Value v1 = e2.op1;
                Value v2 = e2.op2;
                switch (v1.vt) {
                case LOCAL:

                    Local local = ((Local) v1);
                    int i = local._ls_index;

                    boolean skipOrg = false;
                    if (v2.vt == VT.LOCAL && (i == ((Local) v2)._ls_index)) {// check for a=a
                        skipOrg = true;
                    } else if (v1.valueType.charAt(0) == 'I') {// check for IINC
                        if (v2.vt == VT.ADD) {
                            if (isLocalWithIndex(v2.getOp1(), i) && v2.getOp2().vt == VT.CONSTANT) { // a=a+1;
                                int increment = (Integer) ((Constant) v2.getOp2()).value;
                                if (increment >= Short.MIN_VALUE && increment <= Short.MAX_VALUE) {
                                    asm.visitIincInsn(i, increment);
                                    skipOrg = true;
                                }
                            } else if (isLocalWithIndex(v2.getOp2(), i) && v2.getOp1().vt == VT.CONSTANT) { // a=1+a;
                                int increment = (Integer) ((Constant) v2.getOp1()).value;
                                if (increment >= Short.MIN_VALUE && increment <= Short.MAX_VALUE) {
                                    asm.visitIincInsn(i, increment);
                                    skipOrg = true;
                                }
                            }
                        } else if (v2.vt == VT.SUB) {
                            if (isLocalWithIndex(v2.getOp1(), i) && v2.getOp2().vt == VT.CONSTANT) { // a=a-1;
                                int increment = -(Integer) ((Constant) v2.getOp2()).value;
                                if (increment >= Short.MIN_VALUE && increment <= Short.MAX_VALUE) {
                                    asm.visitIincInsn(i, increment);
                                    skipOrg = true;
                                }
                            }
                        }
                    }
                    if (!skipOrg) {
                        accept(v2, asm);
                        if (i >= 0) {
                            asm.visitVarInsn(getOpcode(v1, ISTORE), i);
                        } else if (!v1.valueType.equals(""V"")) { // skip void type locals
                            switch (v1.valueType.charAt(0)) {
                            case 'J':
                            case 'D':
                                asm.visitInsn(POP2);
                                break;
                            default:
                                asm.visitInsn(POP);
                                break;
                            }
                        }
                    }
                    break;
                case STATIC_FIELD: {
                    StaticFieldExpr fe = (StaticFieldExpr) v1;
                    accept(v2, asm);
                    insertI2x(v2.valueType, fe.type, asm);
                    asm.visitFieldInsn(PUTSTATIC, toInternal(fe.owner), fe.name, fe.type);
                    break;
                }
                case FIELD: {
                    FieldExpr fe = (FieldExpr) v1;
                    accept(fe.op, asm);
                    accept(v2, asm);
                    insertI2x(v2.valueType, fe.type, asm);
                    asm.visitFieldInsn(PUTFIELD, toInternal(fe.owner), fe.name, fe.type);
                    break;
                }
                case ARRAY:
                    ArrayExpr ae = (ArrayExpr) v1;
                    accept(ae.op1, asm);
                    accept(ae.op2, asm);
                    accept(v2, asm);
                    String tp1 = ae.op1.valueType;
                    String tp2 = ae.valueType;
                    if (tp1.charAt(0) == '[') {
                        String arrayElementType = tp1.substring(1);
                        insertI2x(v2.valueType, arrayElementType, asm);
                        asm.visitInsn(getOpcode(arrayElementType, IASTORE));
                    } else {
                        asm.visitInsn(getOpcode(tp2, IASTORE));
                    }
                    break;
                }
            }
                break;
            case IDENTITY: {
                E2Stmt e2 = (E2Stmt) st;
                if (e2.op2.vt == VT.EXCEPTION_REF) {
                    int index = ((Local) e2.op1)._ls_index;
                    if (index >= 0) {
                        asm.visitVarInsn(ASTORE, index);
                    } else {
                        asm.visitInsn(POP);
                    }
                }
            }
                break;

            case FILL_ARRAY_DATA:{
                E2Stmt e2 = (E2Stmt) st;
                if (e2.getOp2().vt == VT.CONSTANT) {
                    Object arrayData = ((Constant) e2.getOp2()).value;
                    int arraySize = Array.getLength(arrayData);
                    String arrayValueType = e2.getOp1().valueType;
                    String elementType;
                    if (arrayValueType.charAt(0) == '[') {
                        elementType = arrayValueType.substring(1);
                    } else {
                        elementType = ""I"";
                    }
                    boolean genBig = false;
                    try {
                        if (this.clzCtx != null
                                && ""BSIJ"".contains(elementType)) {

                            byte[] data = toLittleEndianArray(arrayData);

                            if (data != null && data.length > MAX_FILL_ARRAY_BYTES) {
                                accept(e2.getOp1(), asm);
                                asm.visitLdcInsn(0);
                                constLargeArray(asm, data, elementType);
                                asm.visitLdcInsn(0);
                                asm.visitLdcInsn(arraySize);

                                asm.visitMethodInsn(Opcodes.INVOKESTATIC,
                                        ""java/lang/System"",
                                        ""arraycopy"",
                                        ""(Ljava/lang/Object;ILjava/lang/Object;II)V"",
                                        false
                                );
                                genBig = true;
                            }

                        }
                    } catch (Exception ignore) {
                        // any exception, revert to normal
                    }

                    if (!genBig) {
                        int iastoreOP = getOpcode(elementType, IASTORE);
                        accept(e2.getOp1(), asm);
                        for (int i = 0; i < arraySize; i++) {
                            asm.visitInsn(DUP);
                            asm.visitLdcInsn(i);
                            asm.visitLdcInsn(Array.get(arrayData, i));
                            asm.visitInsn(iastoreOP);
                        }
                        asm.visitInsn(POP);
                    }
                } else {
                    FilledArrayExpr filledArrayExpr = (FilledArrayExpr) e2.getOp2();
                    int arraySize = filledArrayExpr.ops.length;
                    String arrayValueType = e2.getOp1().valueType;
                    String elementType;
                    if (arrayValueType.charAt(0) == '[') {
                        elementType = arrayValueType.substring(1);
                    } else {
                        elementType = ""I"";
                    }

                    boolean genBig = false;
                    try {
                        if (this.clzCtx != null
                                && ""BSIJ"".contains(elementType)
                                && isConstant(filledArrayExpr.ops)) {
                            // create a 500-len byte array, may cause 'Method code too large!'
                            // convert it to a base64 decoding
                            byte[] data = collectDataAsByteArray(filledArrayExpr.ops, elementType);
                            if (data != null && data.length > MAX_FILL_ARRAY_BYTES) {
                                accept(e2.getOp1(), asm);
                                asm.visitLdcInsn(0);
                                constLargeArray(asm, data, elementType);
                                asm.visitLdcInsn(0);
                                asm.visitLdcInsn(arraySize);

                                asm.visitMethodInsn(INVOKESTATIC,
                                        ""java/lang/System"",
                                        ""arraycopy"",
                                        ""(Ljava/lang/Object;ILjava/lang/Object;II)V"",
                                        false
                                );

                                genBig = true;
                            }
                        }
                    } catch (Exception ignore) {
                        // any exception, revert to normal
                    }

                    if (!genBig) {
                        int iastoreOP = getOpcode(elementType, IASTORE);
                        accept(e2.getOp1(), asm);
                        for (int i = 0; i < arraySize; i++) {
                            asm.visitInsn(DUP);
                            asm.visitLdcInsn(i);
                            accept(filledArrayExpr.ops[i], asm);
                            asm.visitInsn(iastoreOP);
                        }
                        asm.visitInsn(POP);
                    }
                }
            }
            break;
            case GOTO:
                asm.visitJumpInsn(GOTO, (Label) ((GotoStmt) st).target.tag);
                break;
            case IF:
                reBuildJumpInstructions((IfStmt) st, asm);
                break;
            case LOCK: {
                Value v = ((UnopStmt) st).op;
                accept(v, asm);
                if (optimizeSynchronized) {
                    switch (v.vt) {
                    case LOCAL:
                        // FIXME do we have to disable local due to OptSyncTest ?
                        // break;
                    case CONSTANT: {
                        String key;
                        if (v.vt == VT.LOCAL) {
                            key = ""L"" + ((Local) v)._ls_index;
                        } else {
                            key = ""C"" + ((Constant) v).value;
                        }
                        Integer integer = lockMap.get(key);
                        int nIndex = integer != null ? integer : ++maxLocalIndex;
                        asm.visitInsn(DUP);
                        asm.visitVarInsn(getOpcode(v, ISTORE), nIndex);
                        lockMap.put(key, nIndex);
                    }
                        break;
                    default:
                        throw new RuntimeException();
                    }
                }
                asm.visitInsn(MONITORENTER);
            }
                break;
            case UNLOCK: {
                Value v = ((UnopStmt) st).op;
                if (optimizeSynchronized) {
                    switch (v.vt) {
                    case LOCAL:
                    case CONSTANT: {
                        String key;
                        if (v.vt == VT.LOCAL) {
                            key = ""L"" + ((Local) v)._ls_index;
                        } else {
                            key = ""C"" + ((Constant) v).value;
                        }
                        Integer integer = lockMap.get(key);
                        if (integer != null) {
                            asm.visitVarInsn(getOpcode(v, ILOAD), integer);
                        } else {
                            accept(v, asm);
                        }
                    }
                        break;
                    // TODO other
                    default: {
                        accept(v, asm);
                        break;
                    }
                    }
                } else {
                    accept(v, asm);
                }
                asm.visitInsn(MONITOREXIT);
            }
                break;
            case NOP:
                break;
            case RETURN: {
                Value v = ((UnopStmt) st).op;
                accept(v, asm);
                insertI2x(v.valueType, ir.ret, asm);
                asm.visitInsn(getOpcode(v, IRETURN));
            }
                break;
            case RETURN_VOID:
                asm.visitInsn(RETURN);
                break;
            case LOOKUP_SWITCH: {
                LookupSwitchStmt lss = (LookupSwitchStmt) st;
                accept(lss.op, asm);
                Label targets[] = new Label[lss.targets.length];
                for (int i = 0; i < targets.length; i++) {
                    targets[i] = (Label) lss.targets[i].tag;
                }
                asm.visitLookupSwitchInsn((Label) lss.defaultTarget.tag, lss.lookupValues, targets);
            }
                break;
            case TABLE_SWITCH: {
                TableSwitchStmt tss = (TableSwitchStmt) st;
                accept(tss.op, asm);
                Label targets[] = new Label[tss.targets.length];
                for (int i = 0; i < targets.length; i++) {
                    targets[i] = (Label) tss.targets[i].tag;
                }
                asm.visitTableSwitchInsn(tss.lowIndex, tss.lowIndex + targets.length - 1,
                        (Label) tss.defaultTarget.tag, targets);
            }
                break;
            case THROW:
                accept(((UnopStmt) st).op, asm);
                asm.visitInsn(ATHROW);
                break;
            case VOID_INVOKE:
                Value op = st.getOp();
                accept(op, asm);

                String ret = op.valueType;
                if (op.vt == VT.INVOKE_NEW) {
                    asm.visitInsn(POP);
                } else if (!""V"".equals(ret)) {
                    switch (ret.charAt(0)) {
                        case 'J':
                        case 'D':
                            asm.visitInsn(POP2);
                            break;
                        default:
                            asm.visitInsn(POP);
                            break;
                    }
                }
                break;
            default:
                throw new RuntimeException(""not support st: "" + st.st);
            }

        }
    }",iterator
i,"{
        asm = new LdcOptimizeAdapter(asm);
        int maxLocalIndex = 0;
        for (Local local : ir.locals) {
            maxLocalIndex = Math.max(maxLocalIndex, local._ls_index);
        }
        Map<String, Integer> lockMap = new HashMap<String, Integer>();
        for (Stmt st : ir.stmts) {
            switch (st.st) {
            case LABEL:
                LabelStmt labelStmt = (LabelStmt) st;
                Label label = (Label) labelStmt.tag;
                asm.visitLabel(label);
                if (labelStmt.lineNumber >= 0) {
                    asm.visitLineNumber(labelStmt.lineNumber, label);
                }
                break;
            case ASSIGN: {
                E2Stmt e2 = (E2Stmt) st;
                Value v1 = e2.op1;
                Value v2 = e2.op2;
                switch (v1.vt) {
                case LOCAL:

                    Local local = ((Local) v1);
                    int i = local._ls_index;

                    boolean skipOrg = false;
                    if (v2.vt == VT.LOCAL && (i == ((Local) v2)._ls_index)) {// check for a=a
                        skipOrg = true;
                    } else if (v1.valueType.charAt(0) == 'I') {// check for IINC
                        if (v2.vt == VT.ADD) {
                            if (isLocalWithIndex(v2.getOp1(), i) && v2.getOp2().vt == VT.CONSTANT) { // a=a+1;
                                int increment = (Integer) ((Constant) v2.getOp2()).value;
                                if (increment >= Short.MIN_VALUE && increment <= Short.MAX_VALUE) {
                                    asm.visitIincInsn(i, increment);
                                    skipOrg = true;
                                }
                            } else if (isLocalWithIndex(v2.getOp2(), i) && v2.getOp1().vt == VT.CONSTANT) { // a=1+a;
                                int increment = (Integer) ((Constant) v2.getOp1()).value;
                                if (increment >= Short.MIN_VALUE && increment <= Short.MAX_VALUE) {
                                    asm.visitIincInsn(i, increment);
                                    skipOrg = true;
                                }
                            }
                        } else if (v2.vt == VT.SUB) {
                            if (isLocalWithIndex(v2.getOp1(), i) && v2.getOp2().vt == VT.CONSTANT) { // a=a-1;
                                int increment = -(Integer) ((Constant) v2.getOp2()).value;
                                if (increment >= Short.MIN_VALUE && increment <= Short.MAX_VALUE) {
                                    asm.visitIincInsn(i, increment);
                                    skipOrg = true;
                                }
                            }
                        }
                    }
                    if (!skipOrg) {
                        accept(v2, asm);
                        if (i >= 0) {
                            asm.visitVarInsn(getOpcode(v1, ISTORE), i);
                        } else if (!v1.valueType.equals(""V"")) { // skip void type locals
                            switch (v1.valueType.charAt(0)) {
                            case 'J':
                            case 'D':
                                asm.visitInsn(POP2);
                                break;
                            default:
                                asm.visitInsn(POP);
                                break;
                            }
                        }
                    }
                    break;
                case STATIC_FIELD: {
                    StaticFieldExpr fe = (StaticFieldExpr) v1;
                    accept(v2, asm);
                    insertI2x(v2.valueType, fe.type, asm);
                    asm.visitFieldInsn(PUTSTATIC, toInternal(fe.owner), fe.name, fe.type);
                    break;
                }
                case FIELD: {
                    FieldExpr fe = (FieldExpr) v1;
                    accept(fe.op, asm);
                    accept(v2, asm);
                    insertI2x(v2.valueType, fe.type, asm);
                    asm.visitFieldInsn(PUTFIELD, toInternal(fe.owner), fe.name, fe.type);
                    break;
                }
                case ARRAY:
                    ArrayExpr ae = (ArrayExpr) v1;
                    accept(ae.op1, asm);
                    accept(ae.op2, asm);
                    accept(v2, asm);
                    String tp1 = ae.op1.valueType;
                    String tp2 = ae.valueType;
                    if (tp1.charAt(0) == '[') {
                        String arrayElementType = tp1.substring(1);
                        insertI2x(v2.valueType, arrayElementType, asm);
                        asm.visitInsn(getOpcode(arrayElementType, IASTORE));
                    } else {
                        asm.visitInsn(getOpcode(tp2, IASTORE));
                    }
                    break;
                }
            }
                break;
            case IDENTITY: {
                E2Stmt e2 = (E2Stmt) st;
                if (e2.op2.vt == VT.EXCEPTION_REF) {
                    int index = ((Local) e2.op1)._ls_index;
                    if (index >= 0) {
                        asm.visitVarInsn(ASTORE, index);
                    } else {
                        asm.visitInsn(POP);
                    }
                }
            }
                break;

            case FILL_ARRAY_DATA:{
                E2Stmt e2 = (E2Stmt) st;
                if (e2.getOp2().vt == VT.CONSTANT) {
                    Object arrayData = ((Constant) e2.getOp2()).value;
                    int arraySize = Array.getLength(arrayData);
                    String arrayValueType = e2.getOp1().valueType;
                    String elementType;
                    if (arrayValueType.charAt(0) == '[') {
                        elementType = arrayValueType.substring(1);
                    } else {
                        elementType = ""I"";
                    }
                    boolean genBig = false;
                    try {
                        if (this.clzCtx != null
                                && ""BSIJ"".contains(elementType)) {

                            byte[] data = toLittleEndianArray(arrayData);

                            if (data != null && data.length > MAX_FILL_ARRAY_BYTES) {
                                accept(e2.getOp1(), asm);
                                asm.visitLdcInsn(0);
                                constLargeArray(asm, data, elementType);
                                asm.visitLdcInsn(0);
                                asm.visitLdcInsn(arraySize);

                                asm.visitMethodInsn(Opcodes.INVOKESTATIC,
                                        ""java/lang/System"",
                                        ""arraycopy"",
                                        ""(Ljava/lang/Object;ILjava/lang/Object;II)V"",
                                        false
                                );
                                genBig = true;
                            }

                        }
                    } catch (Exception ignore) {
                        // any exception, revert to normal
                    }

                    if (!genBig) {
                        int iastoreOP = getOpcode(elementType, IASTORE);
                        accept(e2.getOp1(), asm);
                        for (int i = 0; i < arraySize; i++) {
                            asm.visitInsn(DUP);
                            asm.visitLdcInsn(i);
                            asm.visitLdcInsn(Array.get(arrayData, i));
                            asm.visitInsn(iastoreOP);
                        }
                        asm.visitInsn(POP);
                    }
                } else {
                    FilledArrayExpr filledArrayExpr = (FilledArrayExpr) e2.getOp2();
                    int arraySize = filledArrayExpr.ops.length;
                    String arrayValueType = e2.getOp1().valueType;
                    String elementType;
                    if (arrayValueType.charAt(0) == '[') {
                        elementType = arrayValueType.substring(1);
                    } else {
                        elementType = ""I"";
                    }

                    boolean genBig = false;
                    try {
                        if (this.clzCtx != null
                                && ""BSIJ"".contains(elementType)
                                && isConstant(filledArrayExpr.ops)) {
                            // create a 500-len byte array, may cause 'Method code too large!'
                            // convert it to a base64 decoding
                            byte[] data = collectDataAsByteArray(filledArrayExpr.ops, elementType);
                            if (data != null && data.length > MAX_FILL_ARRAY_BYTES) {
                                accept(e2.getOp1(), asm);
                                asm.visitLdcInsn(0);
                                constLargeArray(asm, data, elementType);
                                asm.visitLdcInsn(0);
                                asm.visitLdcInsn(arraySize);

                                asm.visitMethodInsn(INVOKESTATIC,
                                        ""java/lang/System"",
                                        ""arraycopy"",
                                        ""(Ljava/lang/Object;ILjava/lang/Object;II)V"",
                                        false
                                );

                                genBig = true;
                            }
                        }
                    } catch (Exception ignore) {
                        // any exception, revert to normal
                    }

                    if (!genBig) {
                        int iastoreOP = getOpcode(elementType, IASTORE);
                        accept(e2.getOp1(), asm);
                        for (int i = 0; i < arraySize; i++) {
                            asm.visitInsn(DUP);
                            asm.visitLdcInsn(i);
                            accept(filledArrayExpr.ops[i], asm);
                            asm.visitInsn(iastoreOP);
                        }
                        asm.visitInsn(POP);
                    }
                }
            }
            break;
            case GOTO:
                asm.visitJumpInsn(GOTO, (Label) ((GotoStmt) st).target.tag);
                break;
            case IF:
                reBuildJumpInstructions((IfStmt) st, asm);
                break;
            case LOCK: {
                Value v = ((UnopStmt) st).op;
                accept(v, asm);
                if (optimizeSynchronized) {
                    switch (v.vt) {
                    case LOCAL:
                        // FIXME do we have to disable local due to OptSyncTest ?
                        // break;
                    case CONSTANT: {
                        String key;
                        if (v.vt == VT.LOCAL) {
                            key = ""L"" + ((Local) v)._ls_index;
                        } else {
                            key = ""C"" + ((Constant) v).value;
                        }
                        Integer integer = lockMap.get(key);
                        int nIndex = integer != null ? integer : ++maxLocalIndex;
                        asm.visitInsn(DUP);
                        asm.visitVarInsn(getOpcode(v, ISTORE), nIndex);
                        lockMap.put(key, nIndex);
                    }
                        break;
                    default:
                        throw new RuntimeException();
                    }
                }
                asm.visitInsn(MONITORENTER);
            }
                break;
            case UNLOCK: {
                Value v = ((UnopStmt) st).op;
                if (optimizeSynchronized) {
                    switch (v.vt) {
                    case LOCAL:
                    case CONSTANT: {
                        String key;
                        if (v.vt == VT.LOCAL) {
                            key = ""L"" + ((Local) v)._ls_index;
                        } else {
                            key = ""C"" + ((Constant) v).value;
                        }
                        Integer integer = lockMap.get(key);
                        if (integer != null) {
                            asm.visitVarInsn(getOpcode(v, ILOAD), integer);
                        } else {
                            accept(v, asm);
                        }
                    }
                        break;
                    // TODO other
                    default: {
                        accept(v, asm);
                        break;
                    }
                    }
                } else {
                    accept(v, asm);
                }
                asm.visitInsn(MONITOREXIT);
            }
                break;
            case NOP:
                break;
            case RETURN: {
                Value v = ((UnopStmt) st).op;
                accept(v, asm);
                insertI2x(v.valueType, ir.ret, asm);
                asm.visitInsn(getOpcode(v, IRETURN));
            }
                break;
            case RETURN_VOID:
                asm.visitInsn(RETURN);
                break;
            case LOOKUP_SWITCH: {
                LookupSwitchStmt lss = (LookupSwitchStmt) st;
                accept(lss.op, asm);
                Label targets[] = new Label[lss.targets.length];
                for (int i = 0; i < targets.length; i++) {
                    targets[i] = (Label) lss.targets[i].tag;
                }
                asm.visitLookupSwitchInsn((Label) lss.defaultTarget.tag, lss.lookupValues, targets);
            }
                break;
            case TABLE_SWITCH: {
                TableSwitchStmt tss = (TableSwitchStmt) st;
                accept(tss.op, asm);
                Label targets[] = new Label[tss.targets.length];
                for (int i = 0; i < targets.length; i++) {
                    targets[i] = (Label) tss.targets[i].tag;
                }
                asm.visitTableSwitchInsn(tss.lowIndex, tss.lowIndex + targets.length - 1,
                        (Label) tss.defaultTarget.tag, targets);
            }
                break;
            case THROW:
                accept(((UnopStmt) st).op, asm);
                asm.visitInsn(ATHROW);
                break;
            case VOID_INVOKE:
                Value op = st.getOp();
                accept(op, asm);

                String ret = op.valueType;
                if (op.vt == VT.INVOKE_NEW) {
                    asm.visitInsn(POP);
                } else if (!""V"".equals(ret)) {
                    switch (ret.charAt(0)) {
                        case 'J':
                        case 'D':
                            asm.visitInsn(POP2);
                            break;
                        default:
                            asm.visitInsn(POP);
                            break;
                    }
                }
                break;
            default:
                throw new RuntimeException(""not support st: "" + st.st);
            }

        }
    }",loop_control
i,"{
        String cst = hexEncode(data);
        if (cst.length() > 65535) { // asm have the limit
            asm.visitTypeInsn(Opcodes.NEW, ""java/lang/StringBuilder"");
            asm.visitInsn(Opcodes.DUP);
            asm.visitMethodInsn(Opcodes.INVOKESPECIAL, ""java/lang/StringBuilder"", ""<init>"", ""()V"", false);

            for (int i = 0; i < cst.length(); i += 65500) {
                int a = Math.min(65500, cst.length() - i);
                asm.visitLdcInsn(cst.substring(i, i + a));
                asm.visitMethodInsn(Opcodes.INVOKEVIRTUAL, ""java/lang/StringBuilder"",
                        ""append"",
                        ""(Ljava/lang/String;)Ljava/lang/StringBuilder;"",
                        false
                );
            }
            asm.visitMethodInsn(Opcodes.INVOKEVIRTUAL, ""java/lang/StringBuilder"",
                    ""toString"",
                    ""()Ljava/lang/String;"",
                    false
            );
        } else {
            asm.visitLdcInsn(cst);
        }

        asm.visitMethodInsn(Opcodes.INVOKESTATIC, toInternal(this.clzCtx.classDescriptor),
                this.clzCtx.buildHexDecodeMethodName(elementType), ""(Ljava/lang/String;)["" + elementType, false);
    }",loop_control
b,"{
        StringBuilder sb = new StringBuilder();
        for (byte b : data) {
            sb.append(String.format(""%02x"", b & 0xFF));
        }
        return sb.toString();
    }",iterator
i,"{
        if (value.vt == VT.FILLED_ARRAY) {
            FilledArrayExpr fae = (FilledArrayExpr) value;
            String tp1 = fae.valueType;
            int xastore = IASTORE;
            String elementType = null;
            if (tp1.charAt(0) == '[') {
                elementType = tp1.substring(1);
                xastore = getOpcode(elementType, IASTORE);
            }

            try {
                if (this.clzCtx != null
                        && elementType != null
                        && ""BSIJ"".contains(elementType)
                        && isConstant(fae.ops)) {

                    byte[] data = collectDataAsByteArray(fae.ops, elementType);
                    if (data != null && data.length > MAX_FILL_ARRAY_BYTES) {
                        constLargeArray(asm, data, elementType);
                        return;
                    }
                }
            } catch (Exception ignore) {
                // any exception, revert to normal
            }

            reBuildE1Expression(Exprs.nNewArray(fae.type, Exprs.nInt(fae.ops.length)), asm);


            for (int i = 0; i < fae.ops.length; i++) {
                if (fae.ops[i] == null)
                    continue;
                asm.visitInsn(DUP);
                asm.visitLdcInsn(i);
                accept(fae.ops[i], asm);
                String tp2 = fae.ops[i].valueType;
                if (elementType != null) {
                    insertI2x(tp2, elementType, asm);
                }
                asm.visitInsn(xastore);
            }
            return;
        }

        switch (value.vt) {
        case NEW_MUTI_ARRAY:
            for (Value vb : value.ops) {
                accept(vb, asm);
            }
            NewMutiArrayExpr nmae = (NewMutiArrayExpr) value;
            StringBuilder sb = new StringBuilder();
            for (int i = 0; i < nmae.dimension; i++) {
                sb.append('[');
            }
            sb.append(nmae.baseType);
            asm.visitMultiANewArrayInsn(sb.toString(), value.ops.length);
            break;
        case INVOKE_NEW:
            asm.visitTypeInsn(NEW, toInternal(((InvokeExpr) value).getOwner()));
            asm.visitInsn(DUP);
            // pass through
        case INVOKE_INTERFACE:
        case INVOKE_SPECIAL:
        case INVOKE_STATIC:
        case INVOKE_VIRTUAL: {
            InvokeExpr ie = (InvokeExpr) value;
            int i = 0;
            if (value.vt != VT.INVOKE_STATIC && value.vt != VT.INVOKE_NEW) {
                i = 1;
                accept(value.ops[0], asm);
            }
            for (int j = 0; i < value.ops.length; i++, j++) {
                Value vb = value.ops[i];
                accept(vb, asm);
                insertI2x(vb.valueType, ie.getArgs()[j], asm);
            }

            int opcode;
            switch (value.vt) {
            case INVOKE_VIRTUAL:
                opcode = INVOKEVIRTUAL;
                break;
            case INVOKE_INTERFACE:
                opcode = INVOKEINTERFACE;
                break;
            case INVOKE_NEW:
            case INVOKE_SPECIAL:
                opcode = INVOKESPECIAL;
                break;
            case INVOKE_STATIC:
                opcode = INVOKESTATIC;
                break;
            default:
                opcode = -1;
            }

            Proto p = ie.getProto();
            if (ie.vt == VT.INVOKE_NEW) {
                p = new Proto(p.getParameterTypes(), ""V"");
            }
            asm.visitMethodInsn(opcode, toInternal(ie.getOwner()), ie.getName(), p.getDesc());
        }
        break;
        case INVOKE_CUSTOM: {
            InvokeCustomExpr ice = (InvokeCustomExpr) value;
            String argTypes[] = ice.getProto().getParameterTypes();
            Value[] vbs = ice.getOps();
            if (argTypes.length == vbs.length) {
                for (int i = 0; i < vbs.length; i++) {
                    Value vb = vbs[i];
                    accept(vb, asm);
                    insertI2x(vb.valueType, argTypes[i], asm);
                }
            } else if (argTypes.length + 1 == vbs.length) {
                accept(vbs[0], asm);
                for (int i = 1; i < vbs.length; i++) {
                    Value vb = vbs[i];
                    accept(vb, asm);
                    insertI2x(vb.valueType, argTypes[i - 1], asm);
                }
            } else {
                throw new RuntimeException();
            }
            asm.visitInvokeDynamicInsn(ice.name, ice.proto.getDesc(), (Handle) Dex2Asm.convertConstantValue(ice.handle), Dex2Asm.convertConstantValues(ice.bsmArgs));
        }
        break;
        case INVOKE_POLYMORPHIC: {
            InvokePolymorphicExpr ipe = (InvokePolymorphicExpr) value;
            Method m = ipe.method;
            String argTypes[] = ipe.getProto().getParameterTypes();
            Value[] vbs = ipe.getOps();
            accept(vbs[0], asm);
            for (int i = 1; i < vbs.length; i++) {
                Value vb = vbs[i];
                accept(vb, asm);
                insertI2x(vb.valueType, argTypes[i - 1], asm);
            }
            asm.visitMethodInsn(INVOKEVIRTUAL, toInternal(m.getOwner()), m.getName(), ipe.getProto().getDesc(), false);
        }
        }
    }",loop_control
vb,"{
        if (value.vt == VT.FILLED_ARRAY) {
            FilledArrayExpr fae = (FilledArrayExpr) value;
            String tp1 = fae.valueType;
            int xastore = IASTORE;
            String elementType = null;
            if (tp1.charAt(0) == '[') {
                elementType = tp1.substring(1);
                xastore = getOpcode(elementType, IASTORE);
            }

            try {
                if (this.clzCtx != null
                        && elementType != null
                        && ""BSIJ"".contains(elementType)
                        && isConstant(fae.ops)) {

                    byte[] data = collectDataAsByteArray(fae.ops, elementType);
                    if (data != null && data.length > MAX_FILL_ARRAY_BYTES) {
                        constLargeArray(asm, data, elementType);
                        return;
                    }
                }
            } catch (Exception ignore) {
                // any exception, revert to normal
            }

            reBuildE1Expression(Exprs.nNewArray(fae.type, Exprs.nInt(fae.ops.length)), asm);


            for (int i = 0; i < fae.ops.length; i++) {
                if (fae.ops[i] == null)
                    continue;
                asm.visitInsn(DUP);
                asm.visitLdcInsn(i);
                accept(fae.ops[i], asm);
                String tp2 = fae.ops[i].valueType;
                if (elementType != null) {
                    insertI2x(tp2, elementType, asm);
                }
                asm.visitInsn(xastore);
            }
            return;
        }

        switch (value.vt) {
        case NEW_MUTI_ARRAY:
            for (Value vb : value.ops) {
                accept(vb, asm);
            }
            NewMutiArrayExpr nmae = (NewMutiArrayExpr) value;
            StringBuilder sb = new StringBuilder();
            for (int i = 0; i < nmae.dimension; i++) {
                sb.append('[');
            }
            sb.append(nmae.baseType);
            asm.visitMultiANewArrayInsn(sb.toString(), value.ops.length);
            break;
        case INVOKE_NEW:
            asm.visitTypeInsn(NEW, toInternal(((InvokeExpr) value).getOwner()));
            asm.visitInsn(DUP);
            // pass through
        case INVOKE_INTERFACE:
        case INVOKE_SPECIAL:
        case INVOKE_STATIC:
        case INVOKE_VIRTUAL: {
            InvokeExpr ie = (InvokeExpr) value;
            int i = 0;
            if (value.vt != VT.INVOKE_STATIC && value.vt != VT.INVOKE_NEW) {
                i = 1;
                accept(value.ops[0], asm);
            }
            for (int j = 0; i < value.ops.length; i++, j++) {
                Value vb = value.ops[i];
                accept(vb, asm);
                insertI2x(vb.valueType, ie.getArgs()[j], asm);
            }

            int opcode;
            switch (value.vt) {
            case INVOKE_VIRTUAL:
                opcode = INVOKEVIRTUAL;
                break;
            case INVOKE_INTERFACE:
                opcode = INVOKEINTERFACE;
                break;
            case INVOKE_NEW:
            case INVOKE_SPECIAL:
                opcode = INVOKESPECIAL;
                break;
            case INVOKE_STATIC:
                opcode = INVOKESTATIC;
                break;
            default:
                opcode = -1;
            }

            Proto p = ie.getProto();
            if (ie.vt == VT.INVOKE_NEW) {
                p = new Proto(p.getParameterTypes(), ""V"");
            }
            asm.visitMethodInsn(opcode, toInternal(ie.getOwner()), ie.getName(), p.getDesc());
        }
        break;
        case INVOKE_CUSTOM: {
            InvokeCustomExpr ice = (InvokeCustomExpr) value;
            String argTypes[] = ice.getProto().getParameterTypes();
            Value[] vbs = ice.getOps();
            if (argTypes.length == vbs.length) {
                for (int i = 0; i < vbs.length; i++) {
                    Value vb = vbs[i];
                    accept(vb, asm);
                    insertI2x(vb.valueType, argTypes[i], asm);
                }
            } else if (argTypes.length + 1 == vbs.length) {
                accept(vbs[0], asm);
                for (int i = 1; i < vbs.length; i++) {
                    Value vb = vbs[i];
                    accept(vb, asm);
                    insertI2x(vb.valueType, argTypes[i - 1], asm);
                }
            } else {
                throw new RuntimeException();
            }
            asm.visitInvokeDynamicInsn(ice.name, ice.proto.getDesc(), (Handle) Dex2Asm.convertConstantValue(ice.handle), Dex2Asm.convertConstantValues(ice.bsmArgs));
        }
        break;
        case INVOKE_POLYMORPHIC: {
            InvokePolymorphicExpr ipe = (InvokePolymorphicExpr) value;
            Method m = ipe.method;
            String argTypes[] = ipe.getProto().getParameterTypes();
            Value[] vbs = ipe.getOps();
            accept(vbs[0], asm);
            for (int i = 1; i < vbs.length; i++) {
                Value vb = vbs[i];
                accept(vb, asm);
                insertI2x(vb.valueType, argTypes[i - 1], asm);
            }
            asm.visitMethodInsn(INVOKEVIRTUAL, toInternal(m.getOwner()), m.getName(), ipe.getProto().getDesc(), false);
        }
        }
    }",iterator
j,"{
        if (value.vt == VT.FILLED_ARRAY) {
            FilledArrayExpr fae = (FilledArrayExpr) value;
            String tp1 = fae.valueType;
            int xastore = IASTORE;
            String elementType = null;
            if (tp1.charAt(0) == '[') {
                elementType = tp1.substring(1);
                xastore = getOpcode(elementType, IASTORE);
            }

            try {
                if (this.clzCtx != null
                        && elementType != null
                        && ""BSIJ"".contains(elementType)
                        && isConstant(fae.ops)) {

                    byte[] data = collectDataAsByteArray(fae.ops, elementType);
                    if (data != null && data.length > MAX_FILL_ARRAY_BYTES) {
                        constLargeArray(asm, data, elementType);
                        return;
                    }
                }
            } catch (Exception ignore) {
                // any exception, revert to normal
            }

            reBuildE1Expression(Exprs.nNewArray(fae.type, Exprs.nInt(fae.ops.length)), asm);


            for (int i = 0; i < fae.ops.length; i++) {
                if (fae.ops[i] == null)
                    continue;
                asm.visitInsn(DUP);
                asm.visitLdcInsn(i);
                accept(fae.ops[i], asm);
                String tp2 = fae.ops[i].valueType;
                if (elementType != null) {
                    insertI2x(tp2, elementType, asm);
                }
                asm.visitInsn(xastore);
            }
            return;
        }

        switch (value.vt) {
        case NEW_MUTI_ARRAY:
            for (Value vb : value.ops) {
                accept(vb, asm);
            }
            NewMutiArrayExpr nmae = (NewMutiArrayExpr) value;
            StringBuilder sb = new StringBuilder();
            for (int i = 0; i < nmae.dimension; i++) {
                sb.append('[');
            }
            sb.append(nmae.baseType);
            asm.visitMultiANewArrayInsn(sb.toString(), value.ops.length);
            break;
        case INVOKE_NEW:
            asm.visitTypeInsn(NEW, toInternal(((InvokeExpr) value).getOwner()));
            asm.visitInsn(DUP);
            // pass through
        case INVOKE_INTERFACE:
        case INVOKE_SPECIAL:
        case INVOKE_STATIC:
        case INVOKE_VIRTUAL: {
            InvokeExpr ie = (InvokeExpr) value;
            int i = 0;
            if (value.vt != VT.INVOKE_STATIC && value.vt != VT.INVOKE_NEW) {
                i = 1;
                accept(value.ops[0], asm);
            }
            for (int j = 0; i < value.ops.length; i++, j++) {
                Value vb = value.ops[i];
                accept(vb, asm);
                insertI2x(vb.valueType, ie.getArgs()[j], asm);
            }

            int opcode;
            switch (value.vt) {
            case INVOKE_VIRTUAL:
                opcode = INVOKEVIRTUAL;
                break;
            case INVOKE_INTERFACE:
                opcode = INVOKEINTERFACE;
                break;
            case INVOKE_NEW:
            case INVOKE_SPECIAL:
                opcode = INVOKESPECIAL;
                break;
            case INVOKE_STATIC:
                opcode = INVOKESTATIC;
                break;
            default:
                opcode = -1;
            }

            Proto p = ie.getProto();
            if (ie.vt == VT.INVOKE_NEW) {
                p = new Proto(p.getParameterTypes(), ""V"");
            }
            asm.visitMethodInsn(opcode, toInternal(ie.getOwner()), ie.getName(), p.getDesc());
        }
        break;
        case INVOKE_CUSTOM: {
            InvokeCustomExpr ice = (InvokeCustomExpr) value;
            String argTypes[] = ice.getProto().getParameterTypes();
            Value[] vbs = ice.getOps();
            if (argTypes.length == vbs.length) {
                for (int i = 0; i < vbs.length; i++) {
                    Value vb = vbs[i];
                    accept(vb, asm);
                    insertI2x(vb.valueType, argTypes[i], asm);
                }
            } else if (argTypes.length + 1 == vbs.length) {
                accept(vbs[0], asm);
                for (int i = 1; i < vbs.length; i++) {
                    Value vb = vbs[i];
                    accept(vb, asm);
                    insertI2x(vb.valueType, argTypes[i - 1], asm);
                }
            } else {
                throw new RuntimeException();
            }
            asm.visitInvokeDynamicInsn(ice.name, ice.proto.getDesc(), (Handle) Dex2Asm.convertConstantValue(ice.handle), Dex2Asm.convertConstantValues(ice.bsmArgs));
        }
        break;
        case INVOKE_POLYMORPHIC: {
            InvokePolymorphicExpr ipe = (InvokePolymorphicExpr) value;
            Method m = ipe.method;
            String argTypes[] = ipe.getProto().getParameterTypes();
            Value[] vbs = ipe.getOps();
            accept(vbs[0], asm);
            for (int i = 1; i < vbs.length; i++) {
                Value vb = vbs[i];
                accept(vb, asm);
                insertI2x(vb.valueType, argTypes[i - 1], asm);
            }
            asm.visitMethodInsn(INVOKEVIRTUAL, toInternal(m.getOwner()), m.getName(), ipe.getProto().getDesc(), false);
        }
        }
    }",loop_control
i,"{
        switch (t) {
            case ""B"": {
                byte[] d = new byte[ops.length];
                for (int i = 0, opsLength = ops.length; i < opsLength; i++) {
                    Value op = ops[i];
                    Constant cst = (Constant) op;
                    d[i] = ((Number) cst.value).byteValue();
                }
                return d;
            }
            case ""S"": {
                short[] d = new short[ops.length];
                for (int i = 0, opsLength = ops.length; i < opsLength; i++) {
                    Value op = ops[i];
                    Constant cst = (Constant) op;
                    d[i] = ((Number) cst.value).shortValue();
                }
                return toLittleEndianArray(d);
            }
            case ""I"": {
                int[] d = new int[ops.length];
                for (int i = 0, opsLength = ops.length; i < opsLength; i++) {
                    Value op = ops[i];
                    Constant cst = (Constant) op;
                    d[i] = ((Number) cst.value).intValue();
                }
                return toLittleEndianArray(d);
            }
            case ""J"": {
                long[] d = new long[ops.length];
                for (int i = 0, opsLength = ops.length; i < opsLength; i++) {
                    Value op = ops[i];
                    Constant cst = (Constant) op;
                    d[i] = ((Number) cst.value).longValue();
                }
                return toLittleEndianArray(d);
            }
        }
        return null;
    }",loop_control
op,"{
        for (Value op : ops) {
            if (op.vt != VT.CONSTANT) {
                return false;
            }
        }
        return true;
    }",iterator
s,"{
        int i = 0;
        for (String s : args) {
            i += sizeofType(s);
        }
        return i;
    }",iterator
i,"{
        this.dexCodeNode = dexCodeNode;
        IrMethod irMethod = new IrMethod();
        irMethod.args = method.getParameterTypes();
        irMethod.ret = method.getReturnType();
        irMethod.owner = method.getOwner();
        irMethod.name = method.getName();
        irMethod.isStatic = isStatic;
        target = irMethod;


        insnList = dexCodeNode.stmts;
        for (int i = 0; i < insnList.size(); i++) {
            DexStmtNode stmtNode = insnList.get(i);
            stmtNode.__index = i;
            if (stmtNode instanceof DexLabelStmtNode) {
                DexLabelStmtNode dexLabelStmtNode = (DexLabelStmtNode) stmtNode;
                labelMap.put(dexLabelStmtNode.label, dexLabelStmtNode);
            }
        }

        fixExceptionHandlers();

        BitSet[] exBranch = new BitSet[insnList.size()];
        parentCount = new int[insnList.size()];
        initParentCount(parentCount);

        BitSet handlers = new BitSet(insnList.size());
        initExceptionHandlers(dexCodeNode, exBranch, handlers);

        DvmInterpreter<DvmValue> interpreter = buildInterpreter();
        frames = new Dex2IrFrame[insnList.size()];
        emitStmts = new ArrayList[insnList.size()];
        BitSet access = new BitSet(insnList.size());

        dfs(exBranch, handlers, access, interpreter);


        StmtList stmts = target.stmts;
        stmts.addAll(preEmit);
        for (int i = 0; i < insnList.size(); i++) {
            DexStmtNode p = insnList.get(i);
            if (access.get(i)) {
                List<Stmt> es = emitStmts[i];
                if (es != null) {
                    stmts.addAll(es);
                }
            } else {
                if (p instanceof DexLabelStmtNode) {
                    stmts.add(getLabel(((DexLabelStmtNode) p).label));
                }
            }
        }
        emitStmts = null;


        // https://github.com/pxb1988/dex2jar/issues/501
        // too many Object put to Q, make the object unique in Q
        Queue<DvmValue> queue = new UniqueQueue<>();

        for (int i1 = 0; i1 < frames.length; i1++) {
            Dex2IrFrame frame = frames[i1];
            if (parentCount[i1] > 1 && frame != null && access.get(i1)) {
                for (int j = 0; j < frame.getTotalRegisters(); j++) {
                    DvmValue v = frame.getReg(j);
                    addToQueue(queue, v);
                }
            }

        }

        while (!queue.isEmpty()) {
            DvmValue v = queue.poll();
            getLocal(v);
            if (v.parent != null) {
                if (v.parent.local == null) {
                    queue.add(v.parent);
                }
            }
            if (v.otherParent != null) {
                for (DvmValue v2 : v.otherParent) {
                    if (v2.local == null) {
                        queue.add(v2);
                    }
                }
            }
        }

        Set<com.googlecode.dex2jar.ir.expr.Value> phiValues = new HashSet<>();
        List<LabelStmt> phiLabels = new ArrayList<>();
        for (int i = 0; i < frames.length; i++) {
            Dex2IrFrame frame = frames[i];
            if (parentCount[i] > 1 && frame != null && access.get(i)) {
                DexStmtNode p = insnList.get(i);
                LabelStmt labelStmt = getLabel(((DexLabelStmtNode) p).label);
                List<AssignStmt> phis = new ArrayList<>();
                for (int j = 0; j < frame.getTotalRegisters(); j++) {
                    DvmValue v = frame.getReg(j);
                    addPhi(v, phiValues, phis);
                }

                labelStmt.phis = phis;
                phiLabels.add(labelStmt);
            }
        }
        if (phiLabels.size() > 0) {
            target.phiLabels = phiLabels;
        }

        return target;
    }",loop_control
i1,"{
        this.dexCodeNode = dexCodeNode;
        IrMethod irMethod = new IrMethod();
        irMethod.args = method.getParameterTypes();
        irMethod.ret = method.getReturnType();
        irMethod.owner = method.getOwner();
        irMethod.name = method.getName();
        irMethod.isStatic = isStatic;
        target = irMethod;


        insnList = dexCodeNode.stmts;
        for (int i = 0; i < insnList.size(); i++) {
            DexStmtNode stmtNode = insnList.get(i);
            stmtNode.__index = i;
            if (stmtNode instanceof DexLabelStmtNode) {
                DexLabelStmtNode dexLabelStmtNode = (DexLabelStmtNode) stmtNode;
                labelMap.put(dexLabelStmtNode.label, dexLabelStmtNode);
            }
        }

        fixExceptionHandlers();

        BitSet[] exBranch = new BitSet[insnList.size()];
        parentCount = new int[insnList.size()];
        initParentCount(parentCount);

        BitSet handlers = new BitSet(insnList.size());
        initExceptionHandlers(dexCodeNode, exBranch, handlers);

        DvmInterpreter<DvmValue> interpreter = buildInterpreter();
        frames = new Dex2IrFrame[insnList.size()];
        emitStmts = new ArrayList[insnList.size()];
        BitSet access = new BitSet(insnList.size());

        dfs(exBranch, handlers, access, interpreter);


        StmtList stmts = target.stmts;
        stmts.addAll(preEmit);
        for (int i = 0; i < insnList.size(); i++) {
            DexStmtNode p = insnList.get(i);
            if (access.get(i)) {
                List<Stmt> es = emitStmts[i];
                if (es != null) {
                    stmts.addAll(es);
                }
            } else {
                if (p instanceof DexLabelStmtNode) {
                    stmts.add(getLabel(((DexLabelStmtNode) p).label));
                }
            }
        }
        emitStmts = null;


        // https://github.com/pxb1988/dex2jar/issues/501
        // too many Object put to Q, make the object unique in Q
        Queue<DvmValue> queue = new UniqueQueue<>();

        for (int i1 = 0; i1 < frames.length; i1++) {
            Dex2IrFrame frame = frames[i1];
            if (parentCount[i1] > 1 && frame != null && access.get(i1)) {
                for (int j = 0; j < frame.getTotalRegisters(); j++) {
                    DvmValue v = frame.getReg(j);
                    addToQueue(queue, v);
                }
            }

        }

        while (!queue.isEmpty()) {
            DvmValue v = queue.poll();
            getLocal(v);
            if (v.parent != null) {
                if (v.parent.local == null) {
                    queue.add(v.parent);
                }
            }
            if (v.otherParent != null) {
                for (DvmValue v2 : v.otherParent) {
                    if (v2.local == null) {
                        queue.add(v2);
                    }
                }
            }
        }

        Set<com.googlecode.dex2jar.ir.expr.Value> phiValues = new HashSet<>();
        List<LabelStmt> phiLabels = new ArrayList<>();
        for (int i = 0; i < frames.length; i++) {
            Dex2IrFrame frame = frames[i];
            if (parentCount[i] > 1 && frame != null && access.get(i)) {
                DexStmtNode p = insnList.get(i);
                LabelStmt labelStmt = getLabel(((DexLabelStmtNode) p).label);
                List<AssignStmt> phis = new ArrayList<>();
                for (int j = 0; j < frame.getTotalRegisters(); j++) {
                    DvmValue v = frame.getReg(j);
                    addPhi(v, phiValues, phis);
                }

                labelStmt.phis = phis;
                phiLabels.add(labelStmt);
            }
        }
        if (phiLabels.size() > 0) {
            target.phiLabels = phiLabels;
        }

        return target;
    }",loop_control
j,"{
        this.dexCodeNode = dexCodeNode;
        IrMethod irMethod = new IrMethod();
        irMethod.args = method.getParameterTypes();
        irMethod.ret = method.getReturnType();
        irMethod.owner = method.getOwner();
        irMethod.name = method.getName();
        irMethod.isStatic = isStatic;
        target = irMethod;


        insnList = dexCodeNode.stmts;
        for (int i = 0; i < insnList.size(); i++) {
            DexStmtNode stmtNode = insnList.get(i);
            stmtNode.__index = i;
            if (stmtNode instanceof DexLabelStmtNode) {
                DexLabelStmtNode dexLabelStmtNode = (DexLabelStmtNode) stmtNode;
                labelMap.put(dexLabelStmtNode.label, dexLabelStmtNode);
            }
        }

        fixExceptionHandlers();

        BitSet[] exBranch = new BitSet[insnList.size()];
        parentCount = new int[insnList.size()];
        initParentCount(parentCount);

        BitSet handlers = new BitSet(insnList.size());
        initExceptionHandlers(dexCodeNode, exBranch, handlers);

        DvmInterpreter<DvmValue> interpreter = buildInterpreter();
        frames = new Dex2IrFrame[insnList.size()];
        emitStmts = new ArrayList[insnList.size()];
        BitSet access = new BitSet(insnList.size());

        dfs(exBranch, handlers, access, interpreter);


        StmtList stmts = target.stmts;
        stmts.addAll(preEmit);
        for (int i = 0; i < insnList.size(); i++) {
            DexStmtNode p = insnList.get(i);
            if (access.get(i)) {
                List<Stmt> es = emitStmts[i];
                if (es != null) {
                    stmts.addAll(es);
                }
            } else {
                if (p instanceof DexLabelStmtNode) {
                    stmts.add(getLabel(((DexLabelStmtNode) p).label));
                }
            }
        }
        emitStmts = null;


        // https://github.com/pxb1988/dex2jar/issues/501
        // too many Object put to Q, make the object unique in Q
        Queue<DvmValue> queue = new UniqueQueue<>();

        for (int i1 = 0; i1 < frames.length; i1++) {
            Dex2IrFrame frame = frames[i1];
            if (parentCount[i1] > 1 && frame != null && access.get(i1)) {
                for (int j = 0; j < frame.getTotalRegisters(); j++) {
                    DvmValue v = frame.getReg(j);
                    addToQueue(queue, v);
                }
            }

        }

        while (!queue.isEmpty()) {
            DvmValue v = queue.poll();
            getLocal(v);
            if (v.parent != null) {
                if (v.parent.local == null) {
                    queue.add(v.parent);
                }
            }
            if (v.otherParent != null) {
                for (DvmValue v2 : v.otherParent) {
                    if (v2.local == null) {
                        queue.add(v2);
                    }
                }
            }
        }

        Set<com.googlecode.dex2jar.ir.expr.Value> phiValues = new HashSet<>();
        List<LabelStmt> phiLabels = new ArrayList<>();
        for (int i = 0; i < frames.length; i++) {
            Dex2IrFrame frame = frames[i];
            if (parentCount[i] > 1 && frame != null && access.get(i)) {
                DexStmtNode p = insnList.get(i);
                LabelStmt labelStmt = getLabel(((DexLabelStmtNode) p).label);
                List<AssignStmt> phis = new ArrayList<>();
                for (int j = 0; j < frame.getTotalRegisters(); j++) {
                    DvmValue v = frame.getReg(j);
                    addPhi(v, phiValues, phis);
                }

                labelStmt.phis = phis;
                phiLabels.add(labelStmt);
            }
        }
        if (phiLabels.size() > 0) {
            target.phiLabels = phiLabels;
        }

        return target;
    }",loop_control
tcb,"{
        if (dexCodeNode.tryStmts == null) {
            return;
        }
        Queue<Integer> q = new LinkedList<>();
        Set<Integer> handlers = new TreeSet<>();
        for (TryCatchNode tcb : dexCodeNode.tryStmts) {
            for (DexLabel h : tcb.handler) {
                int index = indexOf(h);
                q.add(index + 1); // add the next insn after label
                handlers.add(index);
            }
        }

        q.add(0);

        Map<Integer, DexLabel> needChange = new HashMap<>();

        BitSet access = new BitSet(insnList.size());
        while (!q.isEmpty()) {
            Integer key = q.poll();
            int index = key;
            if (access.get(index)) {
                continue;
            } else {
                access.set(index);
            }
            if (handlers.contains(key)) { // the cfg goes to a exception handler
                needChange.put(key, null);
            }
            DexStmtNode node = insnList.get(key);
            if (node.op == null) {
                q.add(index + 1);
            } else {
                Op op = node.op;
                if (op.canContinue()) {
                    q.add(index + 1);
                }
                if (op.canBranch()) {
                    JumpStmtNode jump = (JumpStmtNode) node;
                    q.add(indexOf(jump.label));
                }
                if (op.canSwitch()) {
                    for (DexLabel dexLabel : ((BaseSwitchStmtNode) node).labels) {
                        q.add(indexOf(dexLabel));
                    }
                }
            }
        }

        if (needChange.size() > 0) {
            for (TryCatchNode tcb : dexCodeNode.tryStmts) {
                DexLabel[] handler = tcb.handler;
                for (int i = 0; i < handler.length; i++) {
                    DexLabel h = handler[i];
                    int index = indexOf(h);
                    if (needChange.containsKey(index)) {
                        DexLabel n = needChange.get(index);
                        if (n == null) {
                            n = new DexLabel();
                            needChange.put(index, n);
                            DexLabelStmtNode dexStmtNode = new DexLabelStmtNode(n);
                            dexStmtNode.__index = insnList.size();
                            insnList.add(dexStmtNode);
                            labelMap.put(n, dexStmtNode);
                            JumpStmtNode jumpStmtNode = new JumpStmtNode(Op.GOTO, 0, 0, h);
                            jumpStmtNode.__index = insnList.size();
                            insnList.add(jumpStmtNode);
                        }
                        handler[i] = n;
                    }
                }
            }
        }
    }",iterator
h,"{
        if (dexCodeNode.tryStmts == null) {
            return;
        }
        Queue<Integer> q = new LinkedList<>();
        Set<Integer> handlers = new TreeSet<>();
        for (TryCatchNode tcb : dexCodeNode.tryStmts) {
            for (DexLabel h : tcb.handler) {
                int index = indexOf(h);
                q.add(index + 1); // add the next insn after label
                handlers.add(index);
            }
        }

        q.add(0);

        Map<Integer, DexLabel> needChange = new HashMap<>();

        BitSet access = new BitSet(insnList.size());
        while (!q.isEmpty()) {
            Integer key = q.poll();
            int index = key;
            if (access.get(index)) {
                continue;
            } else {
                access.set(index);
            }
            if (handlers.contains(key)) { // the cfg goes to a exception handler
                needChange.put(key, null);
            }
            DexStmtNode node = insnList.get(key);
            if (node.op == null) {
                q.add(index + 1);
            } else {
                Op op = node.op;
                if (op.canContinue()) {
                    q.add(index + 1);
                }
                if (op.canBranch()) {
                    JumpStmtNode jump = (JumpStmtNode) node;
                    q.add(indexOf(jump.label));
                }
                if (op.canSwitch()) {
                    for (DexLabel dexLabel : ((BaseSwitchStmtNode) node).labels) {
                        q.add(indexOf(dexLabel));
                    }
                }
            }
        }

        if (needChange.size() > 0) {
            for (TryCatchNode tcb : dexCodeNode.tryStmts) {
                DexLabel[] handler = tcb.handler;
                for (int i = 0; i < handler.length; i++) {
                    DexLabel h = handler[i];
                    int index = indexOf(h);
                    if (needChange.containsKey(index)) {
                        DexLabel n = needChange.get(index);
                        if (n == null) {
                            n = new DexLabel();
                            needChange.put(index, n);
                            DexLabelStmtNode dexStmtNode = new DexLabelStmtNode(n);
                            dexStmtNode.__index = insnList.size();
                            insnList.add(dexStmtNode);
                            labelMap.put(n, dexStmtNode);
                            JumpStmtNode jumpStmtNode = new JumpStmtNode(Op.GOTO, 0, 0, h);
                            jumpStmtNode.__index = insnList.size();
                            insnList.add(jumpStmtNode);
                        }
                        handler[i] = n;
                    }
                }
            }
        }
    }",iterator
i,"{
        if (dexCodeNode.tryStmts == null) {
            return;
        }
        Queue<Integer> q = new LinkedList<>();
        Set<Integer> handlers = new TreeSet<>();
        for (TryCatchNode tcb : dexCodeNode.tryStmts) {
            for (DexLabel h : tcb.handler) {
                int index = indexOf(h);
                q.add(index + 1); // add the next insn after label
                handlers.add(index);
            }
        }

        q.add(0);

        Map<Integer, DexLabel> needChange = new HashMap<>();

        BitSet access = new BitSet(insnList.size());
        while (!q.isEmpty()) {
            Integer key = q.poll();
            int index = key;
            if (access.get(index)) {
                continue;
            } else {
                access.set(index);
            }
            if (handlers.contains(key)) { // the cfg goes to a exception handler
                needChange.put(key, null);
            }
            DexStmtNode node = insnList.get(key);
            if (node.op == null) {
                q.add(index + 1);
            } else {
                Op op = node.op;
                if (op.canContinue()) {
                    q.add(index + 1);
                }
                if (op.canBranch()) {
                    JumpStmtNode jump = (JumpStmtNode) node;
                    q.add(indexOf(jump.label));
                }
                if (op.canSwitch()) {
                    for (DexLabel dexLabel : ((BaseSwitchStmtNode) node).labels) {
                        q.add(indexOf(dexLabel));
                    }
                }
            }
        }

        if (needChange.size() > 0) {
            for (TryCatchNode tcb : dexCodeNode.tryStmts) {
                DexLabel[] handler = tcb.handler;
                for (int i = 0; i < handler.length; i++) {
                    DexLabel h = handler[i];
                    int index = indexOf(h);
                    if (needChange.containsKey(index)) {
                        DexLabel n = needChange.get(index);
                        if (n == null) {
                            n = new DexLabel();
                            needChange.put(index, n);
                            DexLabelStmtNode dexStmtNode = new DexLabelStmtNode(n);
                            dexStmtNode.__index = insnList.size();
                            insnList.add(dexStmtNode);
                            labelMap.put(n, dexStmtNode);
                            JumpStmtNode jumpStmtNode = new JumpStmtNode(Op.GOTO, 0, 0, h);
                            jumpStmtNode.__index = insnList.size();
                            insnList.add(jumpStmtNode);
                        }
                        handler[i] = n;
                    }
                }
            }
        }
    }",loop_control
q,"{
        if (dexCodeNode.tryStmts == null) {
            return;
        }
        Queue<Integer> q = new LinkedList<>();
        Set<Integer> handlers = new TreeSet<>();
        for (TryCatchNode tcb : dexCodeNode.tryStmts) {
            for (DexLabel h : tcb.handler) {
                int index = indexOf(h);
                q.add(index + 1); // add the next insn after label
                handlers.add(index);
            }
        }

        q.add(0);

        Map<Integer, DexLabel> needChange = new HashMap<>();

        BitSet access = new BitSet(insnList.size());
        while (!q.isEmpty()) {
            Integer key = q.poll();
            int index = key;
            if (access.get(index)) {
                continue;
            } else {
                access.set(index);
            }
            if (handlers.contains(key)) { // the cfg goes to a exception handler
                needChange.put(key, null);
            }
            DexStmtNode node = insnList.get(key);
            if (node.op == null) {
                q.add(index + 1);
            } else {
                Op op = node.op;
                if (op.canContinue()) {
                    q.add(index + 1);
                }
                if (op.canBranch()) {
                    JumpStmtNode jump = (JumpStmtNode) node;
                    q.add(indexOf(jump.label));
                }
                if (op.canSwitch()) {
                    for (DexLabel dexLabel : ((BaseSwitchStmtNode) node).labels) {
                        q.add(indexOf(dexLabel));
                    }
                }
            }
        }

        if (needChange.size() > 0) {
            for (TryCatchNode tcb : dexCodeNode.tryStmts) {
                DexLabel[] handler = tcb.handler;
                for (int i = 0; i < handler.length; i++) {
                    DexLabel h = handler[i];
                    int index = indexOf(h);
                    if (needChange.containsKey(index)) {
                        DexLabel n = needChange.get(index);
                        if (n == null) {
                            n = new DexLabel();
                            needChange.put(index, n);
                            DexLabelStmtNode dexStmtNode = new DexLabelStmtNode(n);
                            dexStmtNode.__index = insnList.size();
                            insnList.add(dexStmtNode);
                            labelMap.put(n, dexStmtNode);
                            JumpStmtNode jumpStmtNode = new JumpStmtNode(Op.GOTO, 0, 0, h);
                            jumpStmtNode.__index = insnList.size();
                            insnList.add(jumpStmtNode);
                        }
                        handler[i] = n;
                    }
                }
            }
        }
    }",maybe_loop_control
h,"{
        if (dexCodeNode.tryStmts != null) {
            for (TryCatchNode tcb : dexCodeNode.tryStmts) {
                for (DexLabel h : tcb.handler) {
                    handlers.set(indexOf(h));
                }
                boolean hasEx = false;
                int endIndex = indexOf(tcb.end);
                for (int p = indexOf(tcb.start) + 1; p < endIndex; p++) {
                    DexStmtNode stmt = insnList.get(p);
                    if (stmt.op != null && stmt.op.canThrow()) {
                        hasEx = true;
                        BitSet x = exBranch[p];
                        if (x == null) {
                            x = exBranch[p] = new BitSet(insnList.size());
                        }
                        for (DexLabel h : tcb.handler) {
                            int hIndex = indexOf(h);
                            x.set(hIndex);
                            parentCount[hIndex]++;
                        }
                    }
                }
                if (hasEx) {
                    target.traps.add(new Trap(getLabel(tcb.start), getLabel(tcb.end), getLabels(tcb.handler),
                            tcb.type));
                }
            }
        }
    }",iterator
tcb,"{
        if (dexCodeNode.tryStmts != null) {
            for (TryCatchNode tcb : dexCodeNode.tryStmts) {
                for (DexLabel h : tcb.handler) {
                    handlers.set(indexOf(h));
                }
                boolean hasEx = false;
                int endIndex = indexOf(tcb.end);
                for (int p = indexOf(tcb.start) + 1; p < endIndex; p++) {
                    DexStmtNode stmt = insnList.get(p);
                    if (stmt.op != null && stmt.op.canThrow()) {
                        hasEx = true;
                        BitSet x = exBranch[p];
                        if (x == null) {
                            x = exBranch[p] = new BitSet(insnList.size());
                        }
                        for (DexLabel h : tcb.handler) {
                            int hIndex = indexOf(h);
                            x.set(hIndex);
                            parentCount[hIndex]++;
                        }
                    }
                }
                if (hasEx) {
                    target.traps.add(new Trap(getLabel(tcb.start), getLabel(tcb.end), getLabels(tcb.handler),
                            tcb.type));
                }
            }
        }
    }",iterator
p,"{
        if (dexCodeNode.tryStmts != null) {
            for (TryCatchNode tcb : dexCodeNode.tryStmts) {
                for (DexLabel h : tcb.handler) {
                    handlers.set(indexOf(h));
                }
                boolean hasEx = false;
                int endIndex = indexOf(tcb.end);
                for (int p = indexOf(tcb.start) + 1; p < endIndex; p++) {
                    DexStmtNode stmt = insnList.get(p);
                    if (stmt.op != null && stmt.op.canThrow()) {
                        hasEx = true;
                        BitSet x = exBranch[p];
                        if (x == null) {
                            x = exBranch[p] = new BitSet(insnList.size());
                        }
                        for (DexLabel h : tcb.handler) {
                            int hIndex = indexOf(h);
                            x.set(hIndex);
                            parentCount[hIndex]++;
                        }
                    }
                }
                if (hasEx) {
                    target.traps.add(new Trap(getLabel(tcb.start), getLabel(tcb.end), getLabels(tcb.handler),
                            tcb.type));
                }
            }
        }
    }",loop_control
v2,"{
        if (v != null) {
            if (v.local != null) {
                if (v.parent != null) {
                    phiValues.add(getLocal(v.parent));
                }
                if (v.otherParent != null) {
                    for (DvmValue v2 : v.otherParent) {
                        phiValues.add(getLocal(v2));
                    }
                }
                if (phiValues.size() > 0) {
                    phis.add(Stmts.nAssign(v.local, Exprs
                            .nPhi(phiValues.toArray(new com.googlecode.dex2jar.ir.expr.Value[phiValues.size()]))));
                    phiValues.clear();
                }
            }
        }
    }",iterator
v,"{
        if (v != null) {
            if (v.local != null) {
                if (v.parent != null) {
                    if (v.parent.local == null) {
                        queue.add(v.parent);
                    }
                }
                if (v.otherParent != null) {
                    for (DvmValue v2 : v.otherParent) {
                        if (v2.local == null) {
                            queue.add(v2);
                        }
                    }
                }
            }
        }
    }",iterator
stack,"{
        currentEmit = preEmit;

        Dex2IrFrame first = initFirstFrame(dexCodeNode, target);
        if (parentCount[0] > 1) {
            merge(first, 0);
        } else {
            frames[0] = first;
        }
        Stack<DexStmtNode> stack = new Stack<>();
        stack.push(insnList.get(0));
        Dex2IrFrame tmp = new Dex2IrFrame(dexCodeNode.totalRegister);


        while (!stack.isEmpty()) {
            DexStmtNode p = stack.pop();
            int index = p.__index;
            if (!access.get(index)) {
                access.set(index);
            } else {
                continue;
            }
            Dex2IrFrame frame = frames[index];
            setCurrentEmit(index);

            if (p instanceof DexLabelStmtNode) {
                emit(getLabel(((DexLabelStmtNode) p).label));
                if (handlers.get(index)) {
                    Local ex = newLocal();
                    emit(Stmts.nIdentity(ex, Exprs.nExceptionRef(""Ljava/lang/Throwable;"")));
                    frame.setTmp(new DvmValue(ex));
                }
            }
            BitSet ex = exBranch[index];
            if (ex != null) {
                for (int i = ex.nextSetBit(0); i >= 0; i = ex.nextSetBit(i + 1)) {
                    merge(frame, i);
                    stack.push(insnList.get(i));
                }
            }

            tmp.init(frame);
            try {
                if (p.op != null) {
                    switch (p.op) {
                        case RETURN_VOID:
                            emit(nReturnVoid());
                            break;
                        case GOTO:
                        case GOTO_16:
                        case GOTO_32:
                            emit(nGoto(getLabel(((JumpStmtNode) p).label)));
                            break;
                        case NOP:
                            emit(nNop());
                            break;
                        case BAD_OP:
                            emit(nThrow(nInvokeNew(new Value[]{nString(""bad dex opcode"")}, new String[]{
                                            ""Ljava/lang/String;""},
                                    ""Ljava/lang/VerifyError;"")));
                            break;
                        default:
                            tmp.execute(p, interpreter);
                            break;
                    }
                }
            } catch (Exception exception) {
                throw new RuntimeException(""Fail on Op "" + p.op + "" index "" + index, exception);
            }


            if (p.op != null) {
                Op op = p.op;
                if (op.canBranch()) {
                    JumpStmtNode jump = (JumpStmtNode) p;
                    int targetIndex = indexOf(jump.label);
                    stack.push(insnList.get(targetIndex));
                    merge(tmp, targetIndex);
                }
                if (op.canSwitch()) {
                    BaseSwitchStmtNode switchStmtNode = (BaseSwitchStmtNode) p;
                    for (DexLabel label : switchStmtNode.labels) {
                        int targetIndex = indexOf(label);
                        stack.push(insnList.get(targetIndex));
                        merge(tmp, targetIndex);
                    }
                }
                if (op.canContinue()) {
                    stack.push(insnList.get(index + 1));
                    merge(tmp, index + 1);
                }
            } else {

                stack.push(insnList.get(index + 1));
                merge(tmp, index + 1);

            }
            // cleanup frame it is useless
            if (parentCount[index] <= 1) {
                frames[index] = null;
            }

        }

    }",maybe_loop_control
i,"{
        currentEmit = preEmit;

        Dex2IrFrame first = initFirstFrame(dexCodeNode, target);
        if (parentCount[0] > 1) {
            merge(first, 0);
        } else {
            frames[0] = first;
        }
        Stack<DexStmtNode> stack = new Stack<>();
        stack.push(insnList.get(0));
        Dex2IrFrame tmp = new Dex2IrFrame(dexCodeNode.totalRegister);


        while (!stack.isEmpty()) {
            DexStmtNode p = stack.pop();
            int index = p.__index;
            if (!access.get(index)) {
                access.set(index);
            } else {
                continue;
            }
            Dex2IrFrame frame = frames[index];
            setCurrentEmit(index);

            if (p instanceof DexLabelStmtNode) {
                emit(getLabel(((DexLabelStmtNode) p).label));
                if (handlers.get(index)) {
                    Local ex = newLocal();
                    emit(Stmts.nIdentity(ex, Exprs.nExceptionRef(""Ljava/lang/Throwable;"")));
                    frame.setTmp(new DvmValue(ex));
                }
            }
            BitSet ex = exBranch[index];
            if (ex != null) {
                for (int i = ex.nextSetBit(0); i >= 0; i = ex.nextSetBit(i + 1)) {
                    merge(frame, i);
                    stack.push(insnList.get(i));
                }
            }

            tmp.init(frame);
            try {
                if (p.op != null) {
                    switch (p.op) {
                        case RETURN_VOID:
                            emit(nReturnVoid());
                            break;
                        case GOTO:
                        case GOTO_16:
                        case GOTO_32:
                            emit(nGoto(getLabel(((JumpStmtNode) p).label)));
                            break;
                        case NOP:
                            emit(nNop());
                            break;
                        case BAD_OP:
                            emit(nThrow(nInvokeNew(new Value[]{nString(""bad dex opcode"")}, new String[]{
                                            ""Ljava/lang/String;""},
                                    ""Ljava/lang/VerifyError;"")));
                            break;
                        default:
                            tmp.execute(p, interpreter);
                            break;
                    }
                }
            } catch (Exception exception) {
                throw new RuntimeException(""Fail on Op "" + p.op + "" index "" + index, exception);
            }


            if (p.op != null) {
                Op op = p.op;
                if (op.canBranch()) {
                    JumpStmtNode jump = (JumpStmtNode) p;
                    int targetIndex = indexOf(jump.label);
                    stack.push(insnList.get(targetIndex));
                    merge(tmp, targetIndex);
                }
                if (op.canSwitch()) {
                    BaseSwitchStmtNode switchStmtNode = (BaseSwitchStmtNode) p;
                    for (DexLabel label : switchStmtNode.labels) {
                        int targetIndex = indexOf(label);
                        stack.push(insnList.get(targetIndex));
                        merge(tmp, targetIndex);
                    }
                }
                if (op.canContinue()) {
                    stack.push(insnList.get(index + 1));
                    merge(tmp, index + 1);
                }
            } else {

                stack.push(insnList.get(index + 1));
                merge(tmp, index + 1);

            }
            // cleanup frame it is useless
            if (parentCount[index] <= 1) {
                frames[index] = null;
            }

        }

    }",loop_control
label,"{
        currentEmit = preEmit;

        Dex2IrFrame first = initFirstFrame(dexCodeNode, target);
        if (parentCount[0] > 1) {
            merge(first, 0);
        } else {
            frames[0] = first;
        }
        Stack<DexStmtNode> stack = new Stack<>();
        stack.push(insnList.get(0));
        Dex2IrFrame tmp = new Dex2IrFrame(dexCodeNode.totalRegister);


        while (!stack.isEmpty()) {
            DexStmtNode p = stack.pop();
            int index = p.__index;
            if (!access.get(index)) {
                access.set(index);
            } else {
                continue;
            }
            Dex2IrFrame frame = frames[index];
            setCurrentEmit(index);

            if (p instanceof DexLabelStmtNode) {
                emit(getLabel(((DexLabelStmtNode) p).label));
                if (handlers.get(index)) {
                    Local ex = newLocal();
                    emit(Stmts.nIdentity(ex, Exprs.nExceptionRef(""Ljava/lang/Throwable;"")));
                    frame.setTmp(new DvmValue(ex));
                }
            }
            BitSet ex = exBranch[index];
            if (ex != null) {
                for (int i = ex.nextSetBit(0); i >= 0; i = ex.nextSetBit(i + 1)) {
                    merge(frame, i);
                    stack.push(insnList.get(i));
                }
            }

            tmp.init(frame);
            try {
                if (p.op != null) {
                    switch (p.op) {
                        case RETURN_VOID:
                            emit(nReturnVoid());
                            break;
                        case GOTO:
                        case GOTO_16:
                        case GOTO_32:
                            emit(nGoto(getLabel(((JumpStmtNode) p).label)));
                            break;
                        case NOP:
                            emit(nNop());
                            break;
                        case BAD_OP:
                            emit(nThrow(nInvokeNew(new Value[]{nString(""bad dex opcode"")}, new String[]{
                                            ""Ljava/lang/String;""},
                                    ""Ljava/lang/VerifyError;"")));
                            break;
                        default:
                            tmp.execute(p, interpreter);
                            break;
                    }
                }
            } catch (Exception exception) {
                throw new RuntimeException(""Fail on Op "" + p.op + "" index "" + index, exception);
            }


            if (p.op != null) {
                Op op = p.op;
                if (op.canBranch()) {
                    JumpStmtNode jump = (JumpStmtNode) p;
                    int targetIndex = indexOf(jump.label);
                    stack.push(insnList.get(targetIndex));
                    merge(tmp, targetIndex);
                }
                if (op.canSwitch()) {
                    BaseSwitchStmtNode switchStmtNode = (BaseSwitchStmtNode) p;
                    for (DexLabel label : switchStmtNode.labels) {
                        int targetIndex = indexOf(label);
                        stack.push(insnList.get(targetIndex));
                        merge(tmp, targetIndex);
                    }
                }
                if (op.canContinue()) {
                    stack.push(insnList.get(index + 1));
                    merge(tmp, index + 1);
                }
            } else {

                stack.push(insnList.get(index + 1));
                merge(tmp, index + 1);

            }
            // cleanup frame it is useless
            if (parentCount[index] <= 1) {
                frames[index] = null;
            }

        }

    }",iterator
i,"{
        Dex2IrFrame distFrame = frames[dst];
        if (distFrame == null) {
            distFrame = frames[dst] = new Dex2IrFrame(dexCodeNode.totalRegister);
        }
        if (parentCount[dst] > 1) {
            for (int i = 0; i < src.getTotalRegisters(); i++) {
                DvmValue p = src.getReg(i);
                DvmValue q = distFrame.getReg(i);
                if (p != null) {
                    if (q == null) {
                        q = new DvmValue();
                        distFrame.setReg(i, q);
                    }
                    relate(p, q);
                }
            }
        } else {
            distFrame.init(src);
        }
    }",loop_control
i,"{
        Dex2IrFrame first = new Dex2IrFrame(methodNode.totalRegister);
        int x = methodNode.totalRegister - methodArgCount(target.args);
        if (!target.isStatic) {// not static
            Local thiz = newLocal();
            emit(Stmts.nIdentity(thiz, Exprs.nThisRef(target.owner)));
            first.setReg(x - 1, new DvmValue(thiz));
        }
        for (int i = 0; i < target.args.length; i++) {
            Local p = newLocal();
            emit(Stmts.nIdentity(p, Exprs.nParameterRef(target.args[i], i)));
            first.setReg(x, new DvmValue(p));
            x += sizeofType(target.args[i]);
        }

        if (initAllToZero) {
            for (int i = 0; i < first.getTotalRegisters(); i++) {
                if (first.getReg(i) == null) {
                    Local p = newLocal();
                    emit(nAssign(p, nInt(0)));
                    first.setReg(i, new DvmValue(p));
                }
            }
        }

        return first;
    }",loop_control
i,"{
        return new DvmInterpreter<DvmValue>() {
            DvmValue b(com.googlecode.dex2jar.ir.expr.Value value) {
                Local local = newLocal();
                emit(Stmts.nAssign(local, value));
                return new DvmValue(local);
            }

            @Override
            public DvmValue newOperation(DexStmtNode insn) {
                switch (insn.op) {
                    case CONST:
                    case CONST_16:
                    case CONST_4:
                    case CONST_HIGH16:
                        return b(nInt((Integer) ((ConstStmtNode) insn).value));
                    case CONST_WIDE:
                    case CONST_WIDE_16:
                    case CONST_WIDE_32:
                    case CONST_WIDE_HIGH16:
                        return b(nLong((Long) ((ConstStmtNode) insn).value));
                    case CONST_CLASS:
                        return b(nType((DexType) ((ConstStmtNode) insn).value));
                    case CONST_STRING:
                    case CONST_STRING_JUMBO:
                        return b(nString((String) ((ConstStmtNode) insn).value));
                    case SGET:
                    case SGET_BOOLEAN:
                    case SGET_BYTE:
                    case SGET_CHAR:
                    case SGET_OBJECT:
                    case SGET_SHORT:
                    case SGET_WIDE:
                        Field field = ((FieldStmtNode) insn).field;
                        return b(nStaticField(field.getOwner(), field.getName(), field.getType()));
                    case NEW_INSTANCE:
                        return b(nNew(((TypeStmtNode) insn).type));
                    default:
                }
                return null;
            }

            @Override
            public DvmValue copyOperation(DexStmtNode insn, DvmValue value) {
                if (value == null) {
                    emitNotFindOperand(insn);
                    return b(nInt(0));
                }
                return b(getLocal(value));
            }

            @Override
            public DvmValue unaryOperation(DexStmtNode insn, DvmValue value) {
                if (value == null) {
                    emitNotFindOperand(insn);
                    return b(nInt(0));
                }
                Local local = getLocal(value);
                switch (insn.op) {
                    case NOT_INT:
                        return b(nNot(local, ""I""));
                    case NOT_LONG:
                        return b(nNot(local, ""J""));

                    case NEG_DOUBLE:
                        return b(nNeg(local, ""D""));

                    case NEG_FLOAT:
                        return b(nNeg(local, ""F""));

                    case NEG_INT:
                        return b(nNeg(local, ""I""));

                    case NEG_LONG:
                        return b(nNeg(local, ""J""));
                    case INT_TO_BYTE:
                        return b(nCast(local, ""I"", ""B""));

                    case INT_TO_CHAR:
                        return b(nCast(local, ""I"", ""C""));

                    case INT_TO_DOUBLE:
                        return b(nCast(local, ""I"", ""D""));

                    case INT_TO_FLOAT:
                        return b(nCast(local, ""I"", ""F""));

                    case INT_TO_LONG:
                        return b(nCast(local, ""I"", ""J""));

                    case INT_TO_SHORT:
                        return b(nCast(local, ""I"", ""S""));

                    case FLOAT_TO_DOUBLE:
                        return b(nCast(local, ""F"", ""D""));

                    case FLOAT_TO_INT:
                        return b(nCast(local, ""F"", ""I""));

                    case FLOAT_TO_LONG:
                        return b(nCast(local, ""F"", ""J""));

                    case DOUBLE_TO_FLOAT:
                        return b(nCast(local, ""D"", ""F""));

                    case DOUBLE_TO_INT:
                        return b(nCast(local, ""D"", ""I""));

                    case DOUBLE_TO_LONG:
                        return b(nCast(local, ""D"", ""J""));

                    case LONG_TO_DOUBLE:
                        return b(nCast(local, ""J"", ""D""));

                    case LONG_TO_FLOAT:
                        return b(nCast(local, ""J"", ""F""));

                    case LONG_TO_INT:
                        return b(nCast(local, ""J"", ""I""));

                    case ARRAY_LENGTH:
                        return b(nLength(local));

                    case IF_EQZ:
                        emit(nIf(Exprs
                                .nEq(local, nInt(0), TypeClass.ZIL.name), getLabel(((JumpStmtNode) insn).label)));
                        return null;

                    case IF_GEZ:
                        emit(nIf(Exprs.nGe(local, nInt(0), ""I""), getLabel(((JumpStmtNode) insn).label)));
                        return null;

                    case IF_GTZ:
                        emit(nIf(Exprs.nGt(local, nInt(0), ""I""), getLabel(((JumpStmtNode) insn).label)));
                        return null;

                    case IF_LEZ:
                        emit(nIf(Exprs.nLe(local, nInt(0), ""I""), getLabel(((JumpStmtNode) insn).label)));
                        return null;

                    case IF_LTZ:
                        emit(nIf(Exprs.nLt(local, nInt(0), ""I""), getLabel(((JumpStmtNode) insn).label)));
                        return null;

                    case IF_NEZ:
                        emit(nIf(Exprs
                                .nNe(local, nInt(0), TypeClass.ZIL.name), getLabel(((JumpStmtNode) insn).label)));
                        return null;

                    case PACKED_SWITCH:
                    case SPARSE_SWITCH:
                        DexLabel[] labels = ((BaseSwitchStmtNode) insn).labels;
                        LabelStmt[] lss = new LabelStmt[labels.length];
                        for (int i = 0; i < labels.length; i++) {
                            lss[i] = getLabel(labels[i]);
                        }
                        LabelStmt d = new LabelStmt();
                        if (insn.op == Op.PACKED_SWITCH) {
                            emit(nTableSwitch(local, ((PackedSwitchStmtNode) insn).first_case, lss, d));
                        } else {
                            emit(nLookupSwitch(local, ((SparseSwitchStmtNode) insn).cases, lss, d));
                        }
                        emit(d);
                        return null;

                    case SPUT:
                    case SPUT_BOOLEAN:
                    case SPUT_BYTE:
                    case SPUT_CHAR:
                    case SPUT_OBJECT:
                    case SPUT_SHORT:
                    case SPUT_WIDE: {
                        Field field = ((FieldStmtNode) insn).field;
                        emit(nAssign(nStaticField(field.getOwner(), field.getName(), field.getType()), local));
                        return null;
                    }
                    case IGET:
                    case IGET_BOOLEAN:
                    case IGET_BYTE:
                    case IGET_CHAR:
                    case IGET_OBJECT:
                    case IGET_SHORT:
                    case IGET_WIDE: {
                        Field field = ((FieldStmtNode) insn).field;
                        return b(nField(local, field.getOwner(), field.getName(), field.getType()));
                    }
                    case INSTANCE_OF:
                        return b(nInstanceOf(local, ((TypeStmtNode) insn).type));

                    case NEW_ARRAY:
                        return b(nNewArray(((TypeStmtNode) insn).type.substring(1), local));

                    case CHECK_CAST:
                        return b(nCheckCast(local, ((TypeStmtNode) insn).type));

                    case MONITOR_ENTER:
                        emit(nLock(local));
                        return null;
                    case MONITOR_EXIT:
                        emit(nUnLock(local));
                        return null;
                    case THROW:
                        emit(nThrow(local));
                        return null;
                    case ADD_INT_LIT16:
                    case ADD_INT_LIT8:
                        return b(nAdd(local, nInt(((Stmt2R1NNode) insn).content), ""I""));

                    case RSUB_INT_LIT8:
                    case RSUB_INT://
                        return b(nSub(nInt(((Stmt2R1NNode) insn).content), local, ""I""));

                    case MUL_INT_LIT8:
                    case MUL_INT_LIT16:
                        return b(nMul(local, nInt(((Stmt2R1NNode) insn).content), ""I""));

                    case DIV_INT_LIT16:
                    case DIV_INT_LIT8:
                        return b(nDiv(local, nInt(((Stmt2R1NNode) insn).content), ""I""));

                    case REM_INT_LIT16:
                    case REM_INT_LIT8:
                        return b(nRem(local, nInt(((Stmt2R1NNode) insn).content), ""I""));

                    case AND_INT_LIT16:
                    case AND_INT_LIT8:
                        return b(nAnd(local, nInt(((Stmt2R1NNode) insn).content), ((Stmt2R1NNode) insn).content < 0 || ((Stmt2R1NNode) insn).content > 1 ? ""I"" : TypeClass.ZI.name));

                    case OR_INT_LIT16:
                    case OR_INT_LIT8:
                        return b(nOr(local, nInt(((Stmt2R1NNode) insn).content), ((Stmt2R1NNode) insn).content < 0 || ((Stmt2R1NNode) insn).content > 1 ? ""I"" : TypeClass.ZI.name));

                    case XOR_INT_LIT16:
                    case XOR_INT_LIT8:
                        return b(nXor(local, nInt(((Stmt2R1NNode) insn).content), ((Stmt2R1NNode) insn).content < 0 || ((Stmt2R1NNode) insn).content > 1 ? ""I"" : TypeClass.ZI.name));

                    case SHL_INT_LIT8:
                        return b(nShl(local, nInt(((Stmt2R1NNode) insn).content), ""I""));

                    case SHR_INT_LIT8:
                        return b(nShr(local, nInt(((Stmt2R1NNode) insn).content), ""I""));

                    case USHR_INT_LIT8:
                        return b(nUshr(local, nInt(((Stmt2R1NNode) insn).content), ""I""));
                    case FILL_ARRAY_DATA:
                        emit(nFillArrayData(local, nArrayValue(((FillArrayDataStmtNode) insn).array)));
                        return null;
                }
                throw new RuntimeException();
            }

            @Override
            public DvmValue binaryOperation(DexStmtNode insn, DvmValue value1, DvmValue value2) {
                if (value1 == null || value2 == null) {
                    emitNotFindOperand(insn);
                    return b(nInt(0));
                }
                Local local1 = getLocal(value1);
                Local local2 = getLocal(value2);
                switch (insn.op) {
                    case AGET:
                        return b(nArray(local1, local2, TypeClass.IF.name));

                    case AGET_BOOLEAN:
                        return b(nArray(local1, local2, ""Z""));

                    case AGET_BYTE:
                        return b(nArray(local1, local2, ""B""));

                    case AGET_CHAR:
                        return b(nArray(local1, local2, ""C""));

                    case AGET_OBJECT:
                        return b(nArray(local1, local2, ""L""));

                    case AGET_SHORT:
                        return b(nArray(local1, local2, ""S""));

                    case AGET_WIDE:
                        return b(nArray(local1, local2, TypeClass.JD.name));

                    case CMP_LONG:
                        return b(nLCmp(local1, local2));

                    case CMPG_DOUBLE:
                        return b(nDCmpg(local1, local2));

                    case CMPG_FLOAT:
                        return b(nFCmpg(local1, local2));

                    case CMPL_DOUBLE:
                        return b(nDCmpl(local1, local2));

                    case CMPL_FLOAT:
                        return b(nFCmpl(local1, local2));

                    case ADD_DOUBLE:
                        return b(nAdd(local1, local2, ""D""));

                    case ADD_FLOAT:
                        return b(nAdd(local1, local2, ""F""));

                    case ADD_INT:
                        return b(nAdd(local1, local2, ""I""));

                    case ADD_LONG:
                        return b(nAdd(local1, local2, ""J""));

                    case SUB_DOUBLE:
                        return b(nSub(local1, local2, ""D""));

                    case SUB_FLOAT:
                        return b(nSub(local1, local2, ""F""));

                    case SUB_INT:
                        return b(nSub(local1, local2, ""I""));

                    case SUB_LONG:
                        return b(nSub(local1, local2, ""J""));

                    case MUL_DOUBLE:
                        return b(nMul(local1, local2, ""D""));

                    case MUL_FLOAT:
                        return b(nMul(local1, local2, ""F""));

                    case MUL_INT:
                        return b(nMul(local1, local2, ""I""));

                    case MUL_LONG:
                        return b(nMul(local1, local2, ""J""));

                    case DIV_DOUBLE:
                        return b(nDiv(local1, local2, ""D""));

                    case DIV_FLOAT:
                        return b(nDiv(local1, local2, ""F""));

                    case DIV_INT:
                        return b(nDiv(local1, local2, ""I""));

                    case DIV_LONG:
                        return b(nDiv(local1, local2, ""J""));

                    case REM_DOUBLE:
                        return b(nRem(local1, local2, ""D""));

                    case REM_FLOAT:
                        return b(nRem(local1, local2, ""F""));

                    case REM_INT:
                        return b(nRem(local1, local2, ""I""));

                    case REM_LONG:
                        return b(nRem(local1, local2, ""J""));

                    case AND_INT:
                        return b(nAnd(local1, local2, TypeClass.ZI.name));

                    case AND_LONG:
                        return b(nAnd(local1, local2, ""J""));

                    case OR_INT:
                        return b(nOr(local1, local2, TypeClass.ZI.name));

                    case OR_LONG:
                        return b(nOr(local1, local2, ""J""));

                    case XOR_INT:
                        return b(nXor(local1, local2, TypeClass.ZI.name));

                    case XOR_LONG:
                        return b(nXor(local1, local2, ""J""));

                    case SHL_INT:
                        return b(nShl(local1, local2, ""I""));

                    case SHL_LONG:
                        return b(nShl(local1, local2, ""J""));

                    case SHR_INT:
                        return b(nShr(local1, local2, ""I""));

                    case SHR_LONG:
                        return b(nShr(local1, local2, ""J""));

                    case USHR_INT:
                        return b(nUshr(local1, local2, ""I""));

                    case USHR_LONG:
                        return b(nUshr(local1, local2, ""J""));

                    case IF_EQ:
                        emit(nIf(Exprs
                                .nEq(local1, local2, TypeClass.ZIL.name), getLabel(((JumpStmtNode) insn).label)));
                        return null;

                    case IF_GE:
                        emit(nIf(Exprs.nGe(local1, local2, ""I""), getLabel(((JumpStmtNode) insn).label)));
                        return null;

                    case IF_GT:
                        emit(nIf(Exprs.nGt(local1, local2, ""I""), getLabel(((JumpStmtNode) insn).label)));
                        return null;

                    case IF_LE:
                        emit(nIf(Exprs.nLe(local1, local2, ""I""), getLabel(((JumpStmtNode) insn).label)));
                        return null;

                    case IF_LT:
                        emit(nIf(Exprs.nLt(local1, local2, ""I""), getLabel(((JumpStmtNode) insn).label)));
                        return null;

                    case IF_NE:
                        emit(nIf(Exprs
                                .nNe(local1, local2, TypeClass.ZIL.name), getLabel(((JumpStmtNode) insn).label)));
                        return null;

                    case IPUT:
                    case IPUT_BOOLEAN:
                    case IPUT_BYTE:
                    case IPUT_CHAR:
                    case IPUT_OBJECT:
                    case IPUT_SHORT:
                    case IPUT_WIDE:
                        Field field = ((FieldStmtNode) insn).field;
                        emit(nAssign(nField(local1, field.getOwner(), field.getName(), field.getType()), local2));
                        return null;

                    case ADD_DOUBLE_2ADDR:
                        return b(nAdd(local1, local2, ""D""));

                    case ADD_FLOAT_2ADDR:
                        return b(nAdd(local1, local2, ""F""));

                    case ADD_INT_2ADDR:
                        return b(nAdd(local1, local2, ""I""));

                    case ADD_LONG_2ADDR:
                        return b(nAdd(local1, local2, ""J""));

                    case SUB_DOUBLE_2ADDR:
                        return b(nSub(local1, local2, ""D""));

                    case SUB_FLOAT_2ADDR:
                        return b(nSub(local1, local2, ""F""));

                    case SUB_INT_2ADDR:
                        return b(nSub(local1, local2, ""I""));

                    case SUB_LONG_2ADDR:
                        return b(nSub(local1, local2, ""J""));

                    case MUL_DOUBLE_2ADDR:
                        return b(nMul(local1, local2, ""D""));

                    case MUL_FLOAT_2ADDR:
                        return b(nMul(local1, local2, ""F""));

                    case MUL_INT_2ADDR:
                        return b(nMul(local1, local2, ""I""));

                    case MUL_LONG_2ADDR:
                        return b(nMul(local1, local2, ""J""));

                    case DIV_DOUBLE_2ADDR:
                        return b(nDiv(local1, local2, ""D""));

                    case DIV_FLOAT_2ADDR:
                        return b(nDiv(local1, local2, ""F""));

                    case DIV_INT_2ADDR:
                        return b(nDiv(local1, local2, ""I""));

                    case DIV_LONG_2ADDR:
                        return b(nDiv(local1, local2, ""J""));

                    case REM_DOUBLE_2ADDR:
                        return b(nRem(local1, local2, ""D""));

                    case REM_FLOAT_2ADDR:
                        return b(nRem(local1, local2, ""F""));

                    case REM_INT_2ADDR:
                        return b(nRem(local1, local2, ""I""));

                    case REM_LONG_2ADDR:
                        return b(nRem(local1, local2, ""J""));

                    case AND_INT_2ADDR:
                        return b(nAnd(local1, local2, TypeClass.ZI.name));

                    case AND_LONG_2ADDR:
                        return b(nAnd(local1, local2, ""J""));

                    case OR_INT_2ADDR:
                        return b(nOr(local1, local2, TypeClass.ZI.name));

                    case OR_LONG_2ADDR:
                        return b(nOr(local1, local2, ""J""));

                    case XOR_INT_2ADDR:
                        return b(nXor(local1, local2, TypeClass.ZI.name));

                    case XOR_LONG_2ADDR:
                        return b(nXor(local1, local2, ""J""));

                    case SHL_INT_2ADDR:
                        return b(nShl(local1, local2, ""I""));

                    case SHL_LONG_2ADDR:
                        return b(nShl(local1, local2, ""J""));

                    case SHR_INT_2ADDR:
                        return b(nShr(local1, local2, ""I""));

                    case SHR_LONG_2ADDR:
                        return b(nShr(local1, local2, ""J""));

                    case USHR_INT_2ADDR:
                        return b(nUshr(local1, local2, ""I""));

                    case USHR_LONG_2ADDR:
                        return b(nUshr(local1, local2, ""J""));

                }
                throw new RuntimeException();
            }

            @Override
            public DvmValue ternaryOperation(DexStmtNode insn, DvmValue value1, DvmValue value2, DvmValue value3) {
                if (value1 == null || value2 == null || value3 == null) {
                    emitNotFindOperand(insn);
                    return b(nInt(0));
                }
                Local localArray = getLocal(value1);
                Local localIndex = getLocal(value2);
                Local localValue = getLocal(value3);
                switch (insn.op) {
                    case APUT:
                        emit(nAssign(nArray(localArray, localIndex, TypeClass.IF.name), localValue));
                        break;
                    case APUT_BOOLEAN:
                        emit(nAssign(nArray(localArray, localIndex, ""Z""), localValue));
                        break;
                    case APUT_BYTE:
                        emit(nAssign(nArray(localArray, localIndex, ""B""), localValue));
                        break;
                    case APUT_CHAR:
                        emit(nAssign(nArray(localArray, localIndex, ""C""), localValue));
                        break;
                    case APUT_OBJECT:
                        emit(nAssign(nArray(localArray, localIndex, ""L""), localValue));
                        break;
                    case APUT_SHORT:
                        emit(nAssign(nArray(localArray, localIndex, ""S""), localValue));
                        break;
                    case APUT_WIDE:
                        emit(nAssign(nArray(localArray, localIndex, TypeClass.JD.name), localValue));
                        break;
                }
                return null;
            }

            @Override
            public DvmValue naryOperation(DexStmtNode insn, List<? extends DvmValue> values) {
                for (DvmValue v : values) {
                    if (v == null) {
                        emitNotFindOperand(insn);
                        return b(nInt(0));
                    }
                }


                switch (insn.op) {
                    case FILLED_NEW_ARRAY:
                    case FILLED_NEW_ARRAY_RANGE:
                        DvmValue value = new DvmValue();
                        FilledNewArrayStmtNode filledNewArrayStmtNode = (FilledNewArrayStmtNode) insn;
                        String type = filledNewArrayStmtNode.type;

                        String elem = type.substring(1);
                        emit(nAssign(getLocal(value), nNewArray(elem, nInt(values.size()))));
                        for (int i = 0; i < values.size(); i++) {
                            emit(nAssign(nArray(getLocal(value), nInt(i), elem), getLocal(values.get(i))));
                        }

                        return value;
                    case INVOKE_CUSTOM:
                    case INVOKE_CUSTOM_RANGE: {
                        Value[] vs = new Value[values.size()];
                        for (int i = 0; i < vs.length; i++) {
                            vs[i] = getLocal(values.get(i));
                        }
                        MethodCustomStmtNode n = (MethodCustomStmtNode) insn;
                        Value invoke = nInvokeCustom(vs, n.name, n.proto, n.bsm, n.bsmArgs);
                        if (""V"".equals(n.getProto().getReturnType())) {
                            emit(nVoidInvoke(invoke));
                            return null;
                        } else {
                            return b(invoke);
                        }
                    }
                    case INVOKE_POLYMORPHIC:
                    case INVOKE_POLYMORPHIC_RANGE: {
                        Value[] vs = new Value[values.size()];
                        for (int i = 0; i < vs.length; i++) {
                            vs[i] = getLocal(values.get(i));
                        }
                        MethodPolymorphicStmtNode n = (MethodPolymorphicStmtNode) insn;
                        Value invoke = nInvokePolymorphic(vs, n.proto, n.method);
                        if (""V"".equals(n.getProto().getReturnType())) {
                            emit(nVoidInvoke(invoke));
                            return null;
                        } else {
                            return b(invoke);
                        }
                    }
                    default:
                        Op op = insn.op;
                        Value[] vs = new Value[values.size()];
                        for (int i = 0; i < vs.length; i++) {
                            vs[i] = getLocal(values.get(i));
                        }

                        Method method = ((MethodStmtNode) insn).method;
                        Value invoke = null;
                        switch (op) {
                            case INVOKE_VIRTUAL_RANGE:
                            case INVOKE_VIRTUAL:
                                invoke = nInvokeVirtual(vs, method.getOwner(), method.getName(), method
                                                .getParameterTypes(),
                                        method.getReturnType());
                                break;
                            case INVOKE_SUPER_RANGE:
                            case INVOKE_DIRECT_RANGE:
                            case INVOKE_SUPER:
                            case INVOKE_DIRECT:
                                invoke = nInvokeSpecial(vs, method.getOwner(), method.getName(), method
                                                .getParameterTypes(),
                                        method.getReturnType());
                                break;
                            case INVOKE_STATIC_RANGE:
                            case INVOKE_STATIC:
                                invoke = nInvokeStatic(vs, method.getOwner(), method.getName(), method
                                                .getParameterTypes(),
                                        method.getReturnType());
                                break;
                            case INVOKE_INTERFACE_RANGE:
                            case INVOKE_INTERFACE:
                                invoke = nInvokeInterface(vs, method.getOwner(), method.getName(), method
                                                .getParameterTypes(),
                                        method.getReturnType());
                                break;
                            default:
                                throw new RuntimeException();
                        }
                        if (""V"".equals(method.getReturnType())) {
                            emit(nVoidInvoke(invoke));
                            return null;
                        } else {
                            return b(invoke);
                        }

                }


            }

            void emitNotFindOperand(DexStmtNode insn) {
                String msg;
                switch (insn.op) {
                    case MOVE_RESULT:
                    case MOVE_RESULT_OBJECT:
                    case MOVE_RESULT_WIDE:
                        msg = ""can't get operand(s) for "" + insn.op + "", wrong position ?"";
                        break;
                    default:
                        msg = ""can't get operand(s) for "" + insn.op + "", out-of-range or not initialized ?"";
                        break;
                }

                System.err.println(""WARN: "" + msg);
                emit(nThrow(nInvokeNew(new Value[]{nString(""d2j: "" + msg)},
                        new String[]{""Ljava/lang/String;""}, ""Ljava/lang/VerifyError;"")));
            }

            @Override
            public void returnOperation(DexStmtNode insn, DvmValue value) {
                if (value == null) {
                    emitNotFindOperand(insn);
                    return;
                }

                emit(nReturn(getLocal(value)));
            }
        };
    }",loop_control
i,"{
        LabelStmt[] ts = new LabelStmt[handler.length];
        for (int i = 0; i < handler.length; i++) {
            ts[i] = getLabel(handler[i]);
        }
        return ts;
    }",loop_control
p,"{
        parentCount[0] = 1; // first stmt always have one parent
        for (DexStmtNode p : insnList) {
            Op op = p.op;
            if (op == null) {
                if (p.__index < parentCount.length - 1) { // not the last label
                    parentCount[p.__index + 1]++;
                }
            } else {
                if (op.canBranch()) {
                    parentCount[indexOf(((JumpStmtNode) p).label)]++;
                }
                if (op.canSwitch()) {
                    BaseSwitchStmtNode switchStmtNode = (BaseSwitchStmtNode) p;
                    for (DexLabel label : switchStmtNode.labels) {
                        parentCount[indexOf(label)]++;
                    }
                }
                if (op.canContinue()) {
                    parentCount[p.__index + 1]++;
                }
            }
        }
    }",iterator
label,"{
        parentCount[0] = 1; // first stmt always have one parent
        for (DexStmtNode p : insnList) {
            Op op = p.op;
            if (op == null) {
                if (p.__index < parentCount.length - 1) { // not the last label
                    parentCount[p.__index + 1]++;
                }
            } else {
                if (op.canBranch()) {
                    parentCount[indexOf(((JumpStmtNode) p).label)]++;
                }
                if (op.canSwitch()) {
                    BaseSwitchStmtNode switchStmtNode = (BaseSwitchStmtNode) p;
                    for (DexLabel label : switchStmtNode.labels) {
                        parentCount[indexOf(label)]++;
                    }
                }
                if (op.canContinue()) {
                    parentCount[p.__index + 1]++;
                }
            }
        }
    }",iterator
i,"{
        IrMethod target = new IrMethod();
        target.name = source.name;
        target.owner = ""L"" + owner + "";"";
        target.ret = Type.getReturnType(source.desc).getDescriptor();
        Type[] args = Type.getArgumentTypes(source.desc);
        String sArgs[] = new String[args.length];
        target.args = sArgs;
        for (int i = 0; i < args.length; i++) {
            sArgs[i] = args[i].getDescriptor();
        }
        target.isStatic = 0 != (source.access & Opcodes.ACC_STATIC);
        return target;
    }",loop_control
tcb,"{
        this.methodNode = methodNode;
        target = populate(owner, methodNode);
        if (methodNode.instructions.size() == 0) {
            return target;
        }

        insnList = methodNode.instructions;
        BitSet[] exBranch = new BitSet[insnList.size()];
        parentCount = new int[insnList.size()];

        initParentCount(parentCount);


        BitSet handlers = new BitSet(insnList.size());
        if (methodNode.tryCatchBlocks != null) {
            for (TryCatchBlockNode tcb : methodNode.tryCatchBlocks) {
                target.traps.add(new Trap(getLabel(tcb.start), getLabel(tcb.end), new LabelStmt[]{getLabel(tcb.handler)},
                        new String[]{tcb.type == null ? null : Type.getObjectType(tcb.type).getDescriptor()}));
                int handlerIdx = insnList.indexOf(tcb.handler);
                handlers.set(handlerIdx);

                for (AbstractInsnNode p = tcb.start.getNext(); p != tcb.end; p = p.getNext()) {

                    BitSet x = exBranch[insnList.indexOf(p)];
                    if (x == null) {
                        x = exBranch[insnList.indexOf(p)] = new BitSet(insnList.size());
                    }
                    x.set(handlerIdx);
                    parentCount[handlerIdx]++;
                }
            }
        }

        Interpreter<JvmValue> interpreter = buildInterpreter();
        frames = new JvmFrame[insnList.size()];
        emitStmts = new ArrayList[insnList.size()];
        BitSet access = new BitSet(insnList.size());

        dfs(exBranch, handlers, access, interpreter);

        StmtList stmts = target.stmts;
        stmts.addAll(preEmit);
        for (int i = 0; i < insnList.size(); i++) {
            AbstractInsnNode p = insnList.get(i);
            if (access.get(i)) {
                List<Stmt> es = emitStmts[i];
                if (es != null) {
                    stmts.addAll(es);
                }
            } else {
                if (p.getType() == AbstractInsnNode.LABEL) {
                    stmts.add(getLabel((LabelNode) p));
                }
            }
        }
        emitStmts = null;


        Queue<JvmValue> queue = new LinkedList<>();

        for (int i1 = 0; i1 < frames.length; i1++) {
            JvmFrame frame = frames[i1];
            if (parentCount[i1] > 1 && frame != null && access.get(i1)) {
                for (int j = 0; j < frame.getLocals(); j++) {
                    JvmValue v = frame.getLocal(j);
                    addToQueue(queue, v);
                }
                for (int j = 0; j < frame.getStackSize(); j++) {
                    addToQueue(queue, frame.getStack(j));
                }
            }

        }

        while (!queue.isEmpty()) {
            JvmValue v = queue.poll();
            getLocal(v);
            if (v.parent != null) {
                if (v.parent.local == null) {
                    queue.add(v.parent);
                }
            }
            if (v.otherParent != null) {
                for (JvmValue v2 : v.otherParent) {
                    if (v2.local == null) {
                        queue.add(v2);
                    }
                }
            }
        }

        Set<com.googlecode.dex2jar.ir.expr.Value> phiValues = new HashSet<>();
        List<LabelStmt> phiLabels = new ArrayList<>();
        for (int i = 0; i < frames.length; i++) {
            JvmFrame frame = frames[i];
            if (parentCount[i] > 1 && frame != null && access.get(i)) {
                AbstractInsnNode p = insnList.get(i);
                LabelStmt labelStmt = getLabel((LabelNode) p);
                List<AssignStmt> phis = new ArrayList<>();
                for (int j = 0; j < frame.getLocals(); j++) {
                    JvmValue v = frame.getLocal(j);
                    addPhi(v, phiValues, phis);
                }
                for (int j = 0; j < frame.getStackSize(); j++) {
                    addPhi(frame.getStack(j), phiValues, phis);
                }
                labelStmt.phis = phis;
                phiLabels.add(labelStmt);
            }
        }
        if (phiLabels.size() > 0) {
            target.phiLabels = phiLabels;
        }

        return target;

    }",iterator
p,"{
        this.methodNode = methodNode;
        target = populate(owner, methodNode);
        if (methodNode.instructions.size() == 0) {
            return target;
        }

        insnList = methodNode.instructions;
        BitSet[] exBranch = new BitSet[insnList.size()];
        parentCount = new int[insnList.size()];

        initParentCount(parentCount);


        BitSet handlers = new BitSet(insnList.size());
        if (methodNode.tryCatchBlocks != null) {
            for (TryCatchBlockNode tcb : methodNode.tryCatchBlocks) {
                target.traps.add(new Trap(getLabel(tcb.start), getLabel(tcb.end), new LabelStmt[]{getLabel(tcb.handler)},
                        new String[]{tcb.type == null ? null : Type.getObjectType(tcb.type).getDescriptor()}));
                int handlerIdx = insnList.indexOf(tcb.handler);
                handlers.set(handlerIdx);

                for (AbstractInsnNode p = tcb.start.getNext(); p != tcb.end; p = p.getNext()) {

                    BitSet x = exBranch[insnList.indexOf(p)];
                    if (x == null) {
                        x = exBranch[insnList.indexOf(p)] = new BitSet(insnList.size());
                    }
                    x.set(handlerIdx);
                    parentCount[handlerIdx]++;
                }
            }
        }

        Interpreter<JvmValue> interpreter = buildInterpreter();
        frames = new JvmFrame[insnList.size()];
        emitStmts = new ArrayList[insnList.size()];
        BitSet access = new BitSet(insnList.size());

        dfs(exBranch, handlers, access, interpreter);

        StmtList stmts = target.stmts;
        stmts.addAll(preEmit);
        for (int i = 0; i < insnList.size(); i++) {
            AbstractInsnNode p = insnList.get(i);
            if (access.get(i)) {
                List<Stmt> es = emitStmts[i];
                if (es != null) {
                    stmts.addAll(es);
                }
            } else {
                if (p.getType() == AbstractInsnNode.LABEL) {
                    stmts.add(getLabel((LabelNode) p));
                }
            }
        }
        emitStmts = null;


        Queue<JvmValue> queue = new LinkedList<>();

        for (int i1 = 0; i1 < frames.length; i1++) {
            JvmFrame frame = frames[i1];
            if (parentCount[i1] > 1 && frame != null && access.get(i1)) {
                for (int j = 0; j < frame.getLocals(); j++) {
                    JvmValue v = frame.getLocal(j);
                    addToQueue(queue, v);
                }
                for (int j = 0; j < frame.getStackSize(); j++) {
                    addToQueue(queue, frame.getStack(j));
                }
            }

        }

        while (!queue.isEmpty()) {
            JvmValue v = queue.poll();
            getLocal(v);
            if (v.parent != null) {
                if (v.parent.local == null) {
                    queue.add(v.parent);
                }
            }
            if (v.otherParent != null) {
                for (JvmValue v2 : v.otherParent) {
                    if (v2.local == null) {
                        queue.add(v2);
                    }
                }
            }
        }

        Set<com.googlecode.dex2jar.ir.expr.Value> phiValues = new HashSet<>();
        List<LabelStmt> phiLabels = new ArrayList<>();
        for (int i = 0; i < frames.length; i++) {
            JvmFrame frame = frames[i];
            if (parentCount[i] > 1 && frame != null && access.get(i)) {
                AbstractInsnNode p = insnList.get(i);
                LabelStmt labelStmt = getLabel((LabelNode) p);
                List<AssignStmt> phis = new ArrayList<>();
                for (int j = 0; j < frame.getLocals(); j++) {
                    JvmValue v = frame.getLocal(j);
                    addPhi(v, phiValues, phis);
                }
                for (int j = 0; j < frame.getStackSize(); j++) {
                    addPhi(frame.getStack(j), phiValues, phis);
                }
                labelStmt.phis = phis;
                phiLabels.add(labelStmt);
            }
        }
        if (phiLabels.size() > 0) {
            target.phiLabels = phiLabels;
        }

        return target;

    }",maybe_loop_control
i,"{
        this.methodNode = methodNode;
        target = populate(owner, methodNode);
        if (methodNode.instructions.size() == 0) {
            return target;
        }

        insnList = methodNode.instructions;
        BitSet[] exBranch = new BitSet[insnList.size()];
        parentCount = new int[insnList.size()];

        initParentCount(parentCount);


        BitSet handlers = new BitSet(insnList.size());
        if (methodNode.tryCatchBlocks != null) {
            for (TryCatchBlockNode tcb : methodNode.tryCatchBlocks) {
                target.traps.add(new Trap(getLabel(tcb.start), getLabel(tcb.end), new LabelStmt[]{getLabel(tcb.handler)},
                        new String[]{tcb.type == null ? null : Type.getObjectType(tcb.type).getDescriptor()}));
                int handlerIdx = insnList.indexOf(tcb.handler);
                handlers.set(handlerIdx);

                for (AbstractInsnNode p = tcb.start.getNext(); p != tcb.end; p = p.getNext()) {

                    BitSet x = exBranch[insnList.indexOf(p)];
                    if (x == null) {
                        x = exBranch[insnList.indexOf(p)] = new BitSet(insnList.size());
                    }
                    x.set(handlerIdx);
                    parentCount[handlerIdx]++;
                }
            }
        }

        Interpreter<JvmValue> interpreter = buildInterpreter();
        frames = new JvmFrame[insnList.size()];
        emitStmts = new ArrayList[insnList.size()];
        BitSet access = new BitSet(insnList.size());

        dfs(exBranch, handlers, access, interpreter);

        StmtList stmts = target.stmts;
        stmts.addAll(preEmit);
        for (int i = 0; i < insnList.size(); i++) {
            AbstractInsnNode p = insnList.get(i);
            if (access.get(i)) {
                List<Stmt> es = emitStmts[i];
                if (es != null) {
                    stmts.addAll(es);
                }
            } else {
                if (p.getType() == AbstractInsnNode.LABEL) {
                    stmts.add(getLabel((LabelNode) p));
                }
            }
        }
        emitStmts = null;


        Queue<JvmValue> queue = new LinkedList<>();

        for (int i1 = 0; i1 < frames.length; i1++) {
            JvmFrame frame = frames[i1];
            if (parentCount[i1] > 1 && frame != null && access.get(i1)) {
                for (int j = 0; j < frame.getLocals(); j++) {
                    JvmValue v = frame.getLocal(j);
                    addToQueue(queue, v);
                }
                for (int j = 0; j < frame.getStackSize(); j++) {
                    addToQueue(queue, frame.getStack(j));
                }
            }

        }

        while (!queue.isEmpty()) {
            JvmValue v = queue.poll();
            getLocal(v);
            if (v.parent != null) {
                if (v.parent.local == null) {
                    queue.add(v.parent);
                }
            }
            if (v.otherParent != null) {
                for (JvmValue v2 : v.otherParent) {
                    if (v2.local == null) {
                        queue.add(v2);
                    }
                }
            }
        }

        Set<com.googlecode.dex2jar.ir.expr.Value> phiValues = new HashSet<>();
        List<LabelStmt> phiLabels = new ArrayList<>();
        for (int i = 0; i < frames.length; i++) {
            JvmFrame frame = frames[i];
            if (parentCount[i] > 1 && frame != null && access.get(i)) {
                AbstractInsnNode p = insnList.get(i);
                LabelStmt labelStmt = getLabel((LabelNode) p);
                List<AssignStmt> phis = new ArrayList<>();
                for (int j = 0; j < frame.getLocals(); j++) {
                    JvmValue v = frame.getLocal(j);
                    addPhi(v, phiValues, phis);
                }
                for (int j = 0; j < frame.getStackSize(); j++) {
                    addPhi(frame.getStack(j), phiValues, phis);
                }
                labelStmt.phis = phis;
                phiLabels.add(labelStmt);
            }
        }
        if (phiLabels.size() > 0) {
            target.phiLabels = phiLabels;
        }

        return target;

    }",loop_control
j,"{
        this.methodNode = methodNode;
        target = populate(owner, methodNode);
        if (methodNode.instructions.size() == 0) {
            return target;
        }

        insnList = methodNode.instructions;
        BitSet[] exBranch = new BitSet[insnList.size()];
        parentCount = new int[insnList.size()];

        initParentCount(parentCount);


        BitSet handlers = new BitSet(insnList.size());
        if (methodNode.tryCatchBlocks != null) {
            for (TryCatchBlockNode tcb : methodNode.tryCatchBlocks) {
                target.traps.add(new Trap(getLabel(tcb.start), getLabel(tcb.end), new LabelStmt[]{getLabel(tcb.handler)},
                        new String[]{tcb.type == null ? null : Type.getObjectType(tcb.type).getDescriptor()}));
                int handlerIdx = insnList.indexOf(tcb.handler);
                handlers.set(handlerIdx);

                for (AbstractInsnNode p = tcb.start.getNext(); p != tcb.end; p = p.getNext()) {

                    BitSet x = exBranch[insnList.indexOf(p)];
                    if (x == null) {
                        x = exBranch[insnList.indexOf(p)] = new BitSet(insnList.size());
                    }
                    x.set(handlerIdx);
                    parentCount[handlerIdx]++;
                }
            }
        }

        Interpreter<JvmValue> interpreter = buildInterpreter();
        frames = new JvmFrame[insnList.size()];
        emitStmts = new ArrayList[insnList.size()];
        BitSet access = new BitSet(insnList.size());

        dfs(exBranch, handlers, access, interpreter);

        StmtList stmts = target.stmts;
        stmts.addAll(preEmit);
        for (int i = 0; i < insnList.size(); i++) {
            AbstractInsnNode p = insnList.get(i);
            if (access.get(i)) {
                List<Stmt> es = emitStmts[i];
                if (es != null) {
                    stmts.addAll(es);
                }
            } else {
                if (p.getType() == AbstractInsnNode.LABEL) {
                    stmts.add(getLabel((LabelNode) p));
                }
            }
        }
        emitStmts = null;


        Queue<JvmValue> queue = new LinkedList<>();

        for (int i1 = 0; i1 < frames.length; i1++) {
            JvmFrame frame = frames[i1];
            if (parentCount[i1] > 1 && frame != null && access.get(i1)) {
                for (int j = 0; j < frame.getLocals(); j++) {
                    JvmValue v = frame.getLocal(j);
                    addToQueue(queue, v);
                }
                for (int j = 0; j < frame.getStackSize(); j++) {
                    addToQueue(queue, frame.getStack(j));
                }
            }

        }

        while (!queue.isEmpty()) {
            JvmValue v = queue.poll();
            getLocal(v);
            if (v.parent != null) {
                if (v.parent.local == null) {
                    queue.add(v.parent);
                }
            }
            if (v.otherParent != null) {
                for (JvmValue v2 : v.otherParent) {
                    if (v2.local == null) {
                        queue.add(v2);
                    }
                }
            }
        }

        Set<com.googlecode.dex2jar.ir.expr.Value> phiValues = new HashSet<>();
        List<LabelStmt> phiLabels = new ArrayList<>();
        for (int i = 0; i < frames.length; i++) {
            JvmFrame frame = frames[i];
            if (parentCount[i] > 1 && frame != null && access.get(i)) {
                AbstractInsnNode p = insnList.get(i);
                LabelStmt labelStmt = getLabel((LabelNode) p);
                List<AssignStmt> phis = new ArrayList<>();
                for (int j = 0; j < frame.getLocals(); j++) {
                    JvmValue v = frame.getLocal(j);
                    addPhi(v, phiValues, phis);
                }
                for (int j = 0; j < frame.getStackSize(); j++) {
                    addPhi(frame.getStack(j), phiValues, phis);
                }
                labelStmt.phis = phis;
                phiLabels.add(labelStmt);
            }
        }
        if (phiLabels.size() > 0) {
            target.phiLabels = phiLabels;
        }

        return target;

    }",loop_control
v2,"{
        if (v != null) {
            if (v.local != null) {
                if (v.parent != null) {
                    phiValues.add(getLocal(v.parent));
                }
                if (v.otherParent != null) {
                    for (JvmValue v2 : v.otherParent) {
                        phiValues.add(getLocal(v2));
                    }
                }
                if (phiValues.size() > 0) {
                    phis.add(Stmts.nAssign(v.local, Exprs.nPhi(phiValues.toArray(new com.googlecode.dex2jar.ir.expr.Value[phiValues.size()]))));
                    phiValues.clear();
                }
            }
        }
    }",iterator
v2,"{
        if (v != null) {
            if (v.local != null) {
                if (v.parent != null) {
                    if (v.parent.local == null) {
                        queue.add(v.parent);
                    }
                }
                if (v.otherParent != null) {
                    for (JvmValue v2 : v.otherParent) {
                        if (v2.local == null) {
                            queue.add(v2);
                        }
                    }
                }
            }
        }
    }",iterator
stack,"{
        currentEmit = preEmit;
        JvmFrame first = initFirstFrame(methodNode, target);
        if (parentCount[0] > 1) {
            merge(first, 0);
        } else {
            frames[0] = first;
        }
        Stack<AbstractInsnNode> stack = new Stack<>();
        stack.push(insnList.getFirst());

        JvmFrame tmp = new JvmFrame(methodNode.maxLocals, methodNode.maxStack);

        while (!stack.isEmpty()) {
            AbstractInsnNode p = stack.pop();
            int index = insnList.indexOf(p);
            if (!access.get(index)) {
                access.set(index);
            } else {
                continue;
            }
            JvmFrame frame = frames[index];
            setCurrentEmit(index);

            if (p.getType() == AbstractInsnNode.LABEL) {
                emit(getLabel((LabelNode) p));
                if (handlers.get(index)) {
                    Local ex = newLocal();
                    emit(Stmts.nIdentity(ex, Exprs.nExceptionRef(""Ljava/lang/Throwable;"")));
                    frame.clearStack();
                    frame.push(new JvmValue(1, ex));
                }
            }
            BitSet ex = exBranch[index];
            if (ex != null) {
                for (int i = ex.nextSetBit(0); i >= 0; i = ex.nextSetBit(i + 1)) {
                    mergeEx(frame, i);
                    stack.push(insnList.get(i));
                }
            }

            tmp.init(frame);
            tmp.execute(p, interpreter);

            int op = p.getOpcode();
            if (p.getType() == AbstractInsnNode.JUMP_INSN) {
                JumpInsnNode jump = (JumpInsnNode) p;
                stack.push(jump.label);
                merge(tmp, insnList.indexOf(jump.label));
            }

            if (op == Opcodes.TABLESWITCH || op == Opcodes.LOOKUPSWITCH) {
                if (op == Opcodes.TABLESWITCH) {
                    TableSwitchInsnNode tsin = (TableSwitchInsnNode) p;
                    for (LabelNode label : tsin.labels) {
                        stack.push(label);
                        merge(tmp, insnList.indexOf(label));
                    }
                    stack.push(tsin.dflt);
                    merge(tmp, insnList.indexOf(tsin.dflt));

                } else {
                    LookupSwitchInsnNode lsin = (LookupSwitchInsnNode) p;
                    for (LabelNode label : lsin.labels) {
                        stack.push(label);
                        merge(tmp, insnList.indexOf(label));
                    }
                    stack.push(lsin.dflt);
                    merge(tmp, insnList.indexOf(lsin.dflt));
                }
            }
            if ((op >= Opcodes.GOTO && op <= Opcodes.RETURN) || op == Opcodes.ATHROW) {
                // can't continue
            } else {
                stack.push(p.getNext());
                merge(tmp, index + 1);
            }

            // cleanup frame it is useless
            if (parentCount[index] <= 1) {
                frames[index] = null;
            }

        }
    }",maybe_loop_control
label,"{
        currentEmit = preEmit;
        JvmFrame first = initFirstFrame(methodNode, target);
        if (parentCount[0] > 1) {
            merge(first, 0);
        } else {
            frames[0] = first;
        }
        Stack<AbstractInsnNode> stack = new Stack<>();
        stack.push(insnList.getFirst());

        JvmFrame tmp = new JvmFrame(methodNode.maxLocals, methodNode.maxStack);

        while (!stack.isEmpty()) {
            AbstractInsnNode p = stack.pop();
            int index = insnList.indexOf(p);
            if (!access.get(index)) {
                access.set(index);
            } else {
                continue;
            }
            JvmFrame frame = frames[index];
            setCurrentEmit(index);

            if (p.getType() == AbstractInsnNode.LABEL) {
                emit(getLabel((LabelNode) p));
                if (handlers.get(index)) {
                    Local ex = newLocal();
                    emit(Stmts.nIdentity(ex, Exprs.nExceptionRef(""Ljava/lang/Throwable;"")));
                    frame.clearStack();
                    frame.push(new JvmValue(1, ex));
                }
            }
            BitSet ex = exBranch[index];
            if (ex != null) {
                for (int i = ex.nextSetBit(0); i >= 0; i = ex.nextSetBit(i + 1)) {
                    mergeEx(frame, i);
                    stack.push(insnList.get(i));
                }
            }

            tmp.init(frame);
            tmp.execute(p, interpreter);

            int op = p.getOpcode();
            if (p.getType() == AbstractInsnNode.JUMP_INSN) {
                JumpInsnNode jump = (JumpInsnNode) p;
                stack.push(jump.label);
                merge(tmp, insnList.indexOf(jump.label));
            }

            if (op == Opcodes.TABLESWITCH || op == Opcodes.LOOKUPSWITCH) {
                if (op == Opcodes.TABLESWITCH) {
                    TableSwitchInsnNode tsin = (TableSwitchInsnNode) p;
                    for (LabelNode label : tsin.labels) {
                        stack.push(label);
                        merge(tmp, insnList.indexOf(label));
                    }
                    stack.push(tsin.dflt);
                    merge(tmp, insnList.indexOf(tsin.dflt));

                } else {
                    LookupSwitchInsnNode lsin = (LookupSwitchInsnNode) p;
                    for (LabelNode label : lsin.labels) {
                        stack.push(label);
                        merge(tmp, insnList.indexOf(label));
                    }
                    stack.push(lsin.dflt);
                    merge(tmp, insnList.indexOf(lsin.dflt));
                }
            }
            if ((op >= Opcodes.GOTO && op <= Opcodes.RETURN) || op == Opcodes.ATHROW) {
                // can't continue
            } else {
                stack.push(p.getNext());
                merge(tmp, index + 1);
            }

            // cleanup frame it is useless
            if (parentCount[index] <= 1) {
                frames[index] = null;
            }

        }
    }",iterator
p,"{
        parentCount[0] = 1;
        for (AbstractInsnNode p = insnList.getFirst(); p != null; p = p.getNext()) {
            if (p.getType() == AbstractInsnNode.JUMP_INSN) {
                JumpInsnNode jump = (JumpInsnNode) p;
                parentCount[insnList.indexOf(jump.label)]++;
            }
            int op = p.getOpcode();
            if (op == Opcodes.TABLESWITCH || op == Opcodes.LOOKUPSWITCH) {
                if (op == Opcodes.TABLESWITCH) {
                    TableSwitchInsnNode tsin = (TableSwitchInsnNode) p;
                    for (LabelNode label : tsin.labels) {
                        parentCount[insnList.indexOf(label)]++;
                    }
                    parentCount[insnList.indexOf(tsin.dflt)]++;
                } else {
                    LookupSwitchInsnNode lsin = (LookupSwitchInsnNode) p;
                    for (LabelNode label : lsin.labels) {
                        parentCount[insnList.indexOf(label)]++;
                    }
                    parentCount[insnList.indexOf(lsin.dflt)]++;
                }
            }
            if ((op >= Opcodes.GOTO && op <= Opcodes.RETURN) || op == Opcodes.ATHROW) {
                // can't continue
            } else {
                AbstractInsnNode next = p.getNext();
                if(next!=null) {
                    parentCount[insnList.indexOf(p.getNext())]++;
                }
            }
        }
    }",maybe_loop_control
label,"{
        parentCount[0] = 1;
        for (AbstractInsnNode p = insnList.getFirst(); p != null; p = p.getNext()) {
            if (p.getType() == AbstractInsnNode.JUMP_INSN) {
                JumpInsnNode jump = (JumpInsnNode) p;
                parentCount[insnList.indexOf(jump.label)]++;
            }
            int op = p.getOpcode();
            if (op == Opcodes.TABLESWITCH || op == Opcodes.LOOKUPSWITCH) {
                if (op == Opcodes.TABLESWITCH) {
                    TableSwitchInsnNode tsin = (TableSwitchInsnNode) p;
                    for (LabelNode label : tsin.labels) {
                        parentCount[insnList.indexOf(label)]++;
                    }
                    parentCount[insnList.indexOf(tsin.dflt)]++;
                } else {
                    LookupSwitchInsnNode lsin = (LookupSwitchInsnNode) p;
                    for (LabelNode label : lsin.labels) {
                        parentCount[insnList.indexOf(label)]++;
                    }
                    parentCount[insnList.indexOf(lsin.dflt)]++;
                }
            }
            if ((op >= Opcodes.GOTO && op <= Opcodes.RETURN) || op == Opcodes.ATHROW) {
                // can't continue
            } else {
                AbstractInsnNode next = p.getNext();
                if(next!=null) {
                    parentCount[insnList.indexOf(p.getNext())]++;
                }
            }
        }
    }",iterator
i,"{
        JvmFrame distFrame = frames[dst];
        if (distFrame == null) {
            distFrame = frames[dst] = new JvmFrame(methodNode.maxLocals, methodNode.maxStack);
        }
        for (int i = 0; i < src.getLocals(); i++) {
            JvmValue p = src.getLocal(i);
            JvmValue q = distFrame.getLocal(i);
            if (p != null) {
                if (q == null) {
                    q = new JvmValue(p.getSize());
                    distFrame.setLocal(i, q);
                }
                relate(p, q);
            }
        }
    }",loop_control
i,"{
        JvmFrame distFrame = frames[dst];
        if (distFrame == null) {
            distFrame = frames[dst] = new JvmFrame(methodNode.maxLocals, methodNode.maxStack);
        }
        if (parentCount[dst] > 1) {
            for (int i = 0; i < src.getLocals(); i++) {
                JvmValue p = src.getLocal(i);
                JvmValue q = distFrame.getLocal(i);
                if (p != null) {
                    if (q == null) {
                        q = new JvmValue(p.getSize());
                        distFrame.setLocal(i, q);
                    }
                    relate(p, q);
                }
            }
            if (src.getStackSize() > 0) {
                if (distFrame.getStackSize() == 0) {
                    for (int i = 0; i < src.getStackSize(); i++) {
                        distFrame.push(new JvmValue(src.getStack(i).getSize()));
                    }
                } else if (distFrame.getStackSize() != src.getStackSize()) {
                    throw new RuntimeException(""stack not balanced"");
                }
                for (int i = 0; i < src.getStackSize(); i++) {
                    JvmValue p = src.getStack(i);
                    JvmValue q = distFrame.getStack(i);
                    relate(p, q);
                }
            }
        } else {
            distFrame.init(src);
        }
    }",loop_control
i,"{
        JvmFrame first = new JvmFrame(methodNode.maxLocals, methodNode.maxStack);
        int x = 0;
        if (!target.isStatic) {// not static
            Local thiz = newLocal();
            emit(Stmts.nIdentity(thiz, Exprs.nThisRef(target.owner)));
            first.setLocal(x++, new JvmValue(1, thiz));
        }
        for (int i = 0; i < target.args.length; i++) {
            Local p = newLocal();
            emit(Stmts.nIdentity(p, Exprs.nParameterRef(target.args[i], i)));
            int sizeOfType = sizeOfType(target.args[i]);
            first.setLocal(x, new JvmValue(sizeOfType, p));
            x += sizeOfType;
        }
        return first;
    }",loop_control
i,"{
        List<String> list = new ArrayList<>(5);
        if (desc == null) {
            return list;
        }
        char[] chars = desc.toCharArray();
        int i = 0;
        while (i < chars.length) {
            switch (chars[i]) {
            case 'V':
            case 'Z':
            case 'C':
            case 'B':
            case 'S':
            case 'I':
            case 'F':
            case 'J':
            case 'D':
                list.add(Character.toString(chars[i]));
                i++;
                break;
            case '[': {
                int count = 1;
                while (chars[i + count] == '[') {
                    count++;
                }
                if (chars[i + count] == 'L') {
                    count++;
                    while (chars[i + count] != ';') {
                        count++;
                    }
                }
                count++;
                list.add(new String(chars, i, count));
                i += count;
                break;
            }
            case 'L': {
                int count = 1;
                while (chars[i + count] != ';') {
                    ++count;
                }
                count++;
                list.add(new String(chars, i, count));
                i += count;
                break;
            }
            default:
                throw new RuntimeException(""can't parse type list: "" + desc);
            }
        }
        return list;
    }",loop_control
at,"{
        int rawLength = signature.length();
        ArrayList<String> pieces = new ArrayList<String>(20);

        for (int at = 0; at < rawLength; /* at */) {
            char c = signature.charAt(at);
            int endAt = at + 1;
            if (c == 'L') {
                // Scan to ';' or '<'. Consume ';' but not '<'.
                while (endAt < rawLength) {
                    c = signature.charAt(endAt);
                    if (c == ';') {
                        endAt++;
                        break;
                    } else if (c == '<') {
                        break;
                    }
                    endAt++;
                }
            } else {
                // Scan to 'L' without consuming it.
                while (endAt < rawLength) {
                    c = signature.charAt(endAt);
                    if (c == 'L') {
                        break;
                    }
                    endAt++;
                }
            }

            pieces.add(signature.substring(at, endAt));
            at = endAt;
        }
        return pieces.toArray(new Object[pieces.size()]);
    }",loop_control
endAt,"{
        int rawLength = signature.length();
        ArrayList<String> pieces = new ArrayList<String>(20);

        for (int at = 0; at < rawLength; /* at */) {
            char c = signature.charAt(at);
            int endAt = at + 1;
            if (c == 'L') {
                // Scan to ';' or '<'. Consume ';' but not '<'.
                while (endAt < rawLength) {
                    c = signature.charAt(endAt);
                    if (c == ';') {
                        endAt++;
                        break;
                    } else if (c == '<') {
                        break;
                    }
                    endAt++;
                }
            } else {
                // Scan to 'L' without consuming it.
                while (endAt < rawLength) {
                    c = signature.charAt(endAt);
                    if (c == 'L') {
                        break;
                    }
                    endAt++;
                }
            }

            pieces.add(signature.substring(at, endAt));
            at = endAt;
        }
        return pieces.toArray(new Object[pieces.size()]);
    }",loop_control
c,"{
        int rawLength = signature.length();
        ArrayList<String> pieces = new ArrayList<String>(20);

        for (int at = 0; at < rawLength; /* at */) {
            char c = signature.charAt(at);
            int endAt = at + 1;
            if (c == 'L') {
                // Scan to ';' or '<'. Consume ';' but not '<'.
                while (endAt < rawLength) {
                    c = signature.charAt(endAt);
                    if (c == ';') {
                        endAt++;
                        break;
                    } else if (c == '<') {
                        break;
                    }
                    endAt++;
                }
            } else {
                // Scan to 'L' without consuming it.
                while (endAt < rawLength) {
                    c = signature.charAt(endAt);
                    if (c == 'L') {
                        break;
                    }
                    endAt++;
                }
            }

            pieces.add(signature.substring(at, endAt));
            at = endAt;
        }
        return pieces.toArray(new Object[pieces.size()]);
    }",break_loop_control
mv,"{
        while (mv != null && !(mv instanceof MethodWriter)) {
            mv = mv.mv;
        }
        return mv;
    }",maybe_loop_control
p,"{
        // mv must be the last element
        ClassWriter cw = mw.cw;
        MethodWriter p = cw.firstMethod;
        if (p == mw) {
            cw.firstMethod = null;
            if (cw.lastMethod == mw) {
                cw.lastMethod = null;
            }
        } else {
            while (p != null) {
                if (p.mv == mw) {
                    p.mv = mw.mv;
                    if (cw.lastMethod == mw) {
                        cw.lastMethod = p;
                    }
                    break;
                } else {
                    p = (MethodWriter) p.mv;
                }
            }
        }
    }",maybe_loop_control
p,"{
        // mv must be the last element
        ClassWriter cw = mw.cw;
        MethodWriter p = cw.firstMethod;
        if (p == mw) {
            cw.firstMethod = null;
            if (cw.lastMethod == mw) {
                cw.lastMethod = null;
            }
        } else {
            while (p != null) {
                if (p.mv == mw) {
                    p.mv = mw.mv;
                    if (cw.lastMethod == mw) {
                        cw.lastMethod = p;
                    }
                    break;
                } else {
                    p = (MethodWriter) p.mv;
                }
            }
        }
    }",break_loop_control
itf,"{
        labelNames.clear();
        pw.print("".bytecode "");
        pw.print(cn.version & 0xFFFF);
        pw.print('.');
        pw.println(cn.version >>> 16);
        println("".source "", cn.sourceFile);
        pw.print("".class"");
        pw.print(access_clz(cn.access));
        pw.print(' ');
        printIdAfterAccess(pw, cn.name);
        pw.println();
        if (cn.superName != null) {
            pw.print("".super "");
            printIdAfterAccess(pw, cn.superName);
            pw.println();
        }
        for (String itf : cn.interfaces) {
            pw.print("".implements "");
            printIdAfterAccess(pw, itf);
            pw.println();
        }
        if (cn.signature != null) {
            println("".signature "", '""' + cn.signature + '""');
        }
        if (cn.outerClass != null) {
            pw.print("".enclosing method "");
            pw.print(cn.outerClass);
            if (cn.outerMethod != null) {
                pw.print('/');
                pw.print(cn.outerMethod);
                pw.println(cn.outerMethodDesc);
            } else {
                pw.println();
            }
        }
        if ((cn.access & Opcodes.ACC_DEPRECATED) != 0) {
            pw.println("".deprecated"");
        }
        if (cn.visibleAnnotations != null) {
            for (AnnotationNode an : cn.visibleAnnotations) {
                printAnnotation(an, 1, -1);
            }
        }
        if (cn.invisibleAnnotations != null) {
            for (AnnotationNode an : cn.invisibleAnnotations) {
                printAnnotation(an, 2, -1);
            }
        }

        println("".debug "", cn.sourceDebug == null ? null : '""' + cn.sourceDebug + '""');

        for (InnerClassNode in : cn.innerClasses) {
            pw.print("".inner class"");
            pw.print(access_clz(in.access & (~Opcodes.ACC_SUPER)));
            if (in.innerName != null) {
                pw.print(' ');
                printIdAfterAccess(pw, in.innerName);
            }
            if (in.name != null) {
                pw.print("" inner "");
                pw.print(in.name);
            }
            if (in.outerName != null) {
                pw.print("" outer "");
                pw.print(in.outerName);
            }
            pw.println();
        }

        for (FieldNode fn : cn.fields) {
            boolean annotations = false;
            if (fn.visibleAnnotations != null && fn.visibleAnnotations.size() > 0) {
                annotations = true;
            }
            if (fn.invisibleAnnotations != null && fn.invisibleAnnotations.size() > 0) {
                annotations = true;
            }
            boolean deprecated = (fn.access & Opcodes.ACC_DEPRECATED) != 0;
            pw.print(""\n.field"");
            pw.print(access_fld(fn.access));
            pw.print(' ');
            printIdAfterAccess(pw,fn.name);
            pw.print(' ');
            pw.print(fn.desc);
            if (fn.value instanceof String) {
                StringBuffer buf = new StringBuffer();
                Printer.appendString(buf, (String) fn.value);
                pw.print("" = "");
                pw.print(buf.toString());
            } else if (fn.value != null) {
                pw.print("" = "");
                print(fn.value);
            }
            pw.println();
            if (fn.signature != null) {
                pw.print("".signature \"""");
                pw.print(fn.signature);
                pw.println(""\"""");
            }
            if (deprecated) {
                pw.println("".deprecated"");
            }
            if (fn.visibleAnnotations != null) {
                for (AnnotationNode an : fn.visibleAnnotations) {
                    printAnnotation(an, 1, -1);
                }
            }
            if (fn.invisibleAnnotations != null) {
                for (AnnotationNode an : fn.invisibleAnnotations) {
                    printAnnotation(an, 2, -1);
                }
            }
            if (fn.signature != null || deprecated || annotations) {
                pw.println("".end field"");
            }
        }

        for (MethodNode mn : cn.methods) {
            pw.print(""\n.method"");
            pw.print(access_mtd(mn.access));
            pw.print(' ');
            printIdAfterAccess(pw, mn.name);
            pw.println(mn.desc);
            if (mn.signature != null) {
                pw.print("".signature \"""");
                pw.print(mn.signature);
                pw.println(""\"""");
            }
            if (mn.annotationDefault != null) {
                pw.println("".annotation default"");
                printAnnotationValue(mn.annotationDefault);
                pw.println("".end annotation"");
            }
            if (mn.visibleAnnotations != null) {
                for (AnnotationNode an : mn.visibleAnnotations) {
                    printAnnotation(an, 1, -1);
                }
            }
            if (mn.invisibleAnnotations != null) {
                for (AnnotationNode an : mn.invisibleAnnotations) {
                    printAnnotation(an, 2, -1);
                }
            }
            if (mn.visibleParameterAnnotations != null) {
                for (int j = 0; j < mn.visibleParameterAnnotations.length; ++j) {
                    List<AnnotationNode> pas = mn.visibleParameterAnnotations[j];
                    if (pas != null) {
                        for (AnnotationNode an : pas) {
                            printAnnotation(an, 1, j + 1);
                        }
                    }
                }
            }
            if (mn.invisibleParameterAnnotations != null) {
                for (int j = 0; j < mn.invisibleParameterAnnotations.length; ++j) {
                    List<AnnotationNode> pas = mn.invisibleParameterAnnotations[j];
                    if (pas != null) {
                        for (AnnotationNode an : pas) {
                            printAnnotation(an, 2, j + 1);
                        }
                    }
                }
            }
            for (String ex : mn.exceptions) {
                println("".throws "", ex);
            }
            if ((mn.access & Opcodes.ACC_DEPRECATED) != 0) {
                pw.println("".deprecated"");
            }
            if (mn.instructions != null && mn.instructions.size() > 0) {
                labelNames.clear();
                if (mn.tryCatchBlocks != null) {
                    for (TryCatchBlockNode tcb : mn.tryCatchBlocks) {
                        pw.print("".catch "");
                        pw.print(tcb.type == null ? ""all"" : ""all"".equals(tcb.type) ? ""\\u0097ll"" : tcb.type);
                        pw.print("" from "");
                        print(tcb.start);
                        pw.print("" to "");
                        print(tcb.end);
                        pw.print("" using "");
                        print(tcb.handler);
                        pw.println();
                    }
                }
                for (int j = 0; j < mn.instructions.size(); ++j) {
                    AbstractInsnNode in = mn.instructions.get(j);
                    if (in.getType() != AbstractInsnNode.LINE && in.getType() != AbstractInsnNode.FRAME) {
                       if(in.getType()==AbstractInsnNode.LABEL){
                           pw.print(""  "");
                       }else {
                           pw.print(""    "");
                       }
                    }
                    in.accept(new MethodVisitor(ASM4) {

                        @Override
                        public void visitInsn(int opcode) {
                            print(opcode);
                            pw.println();
                        }

                        @Override
                        public void visitIntInsn(int opcode, int operand) {
                            print(opcode);
                            if (opcode == Opcodes.NEWARRAY) {
                                switch (operand) {
                                case Opcodes.T_BOOLEAN:
                                    pw.println("" boolean"");
                                    break;
                                case Opcodes.T_CHAR:
                                    pw.println("" char"");
                                    break;
                                case Opcodes.T_FLOAT:
                                    pw.println("" float"");
                                    break;
                                case Opcodes.T_DOUBLE:
                                    pw.println("" double"");
                                    break;
                                case Opcodes.T_BYTE:
                                    pw.println("" byte"");
                                    break;
                                case Opcodes.T_SHORT:
                                    pw.println("" short"");
                                    break;
                                case Opcodes.T_INT:
                                    pw.println("" int"");
                                    break;
                                case Opcodes.T_LONG:
                                default:
                                    pw.println("" long"");
                                    break;
                                }
                            } else {
                                pw.print(' ');
                                pw.println(operand);
                            }
                        }

                        @Override
                        public void visitVarInsn(int opcode, int var) {
                            print(opcode);
                            pw.print(' ');
                            pw.println(var);
                        }

                        @Override
                        public void visitTypeInsn(int opcode, String type) {
                            print(opcode);
                            pw.print(' ');
                            pw.println(type);
                        }

                        @Override
                        public void visitFieldInsn(int opcode, String owner, String name, String desc) {
                            print(opcode);
                            pw.print(' ');
                            pw.print(owner);
                            pw.print('/');
                            pw.print(name);
                            pw.print(' ');
                            pw.println(desc);
                        }

                        @Override
                        public void visitMethodInsn(int opcode, String owner, String name, String desc) {
                            print(opcode);
                            pw.print(' ');
                            pw.print(owner);
                            pw.print('/');
                            pw.print(name);
                            pw.print(desc);
                            if (opcode == Opcodes.INVOKEINTERFACE) {
                                pw.print(' ');
                                pw.print((Type.getArgumentsAndReturnSizes(desc) >> 2) - 1);
                            }
                            pw.println();
                        }

                        @Override
                        public void visitJumpInsn(int opcode, Label label) {
                            print(opcode);
                            pw.print(' ');
                            print(label);
                            pw.println();
                        }

                        @Override
                        public void visitLabel(Label label) {
                            print(label);
                            pw.println(':');
                        }

                        @Override
                        public void visitLdcInsn(Object cst) {

                            if (cst instanceof Integer || cst instanceof Float) {
                                pw.print(""ldc_w "");
                                print(cst);
                            } else if (cst instanceof Long || cst instanceof Double) {
                                pw.print(""ldc2_w "");
                                print(cst);
                            } else {
                                pw.print(""ldc "");
                                if (cst instanceof Type) {
                                    pw.print(((Type) cst).getInternalName());
                                } else {
                                    print(cst);
                                }
                            }
                            pw.println();

                        }

                        @Override
                        public void visitIincInsn(int var, int increment) {
                            pw.print(""iinc "");
                            pw.print(var);
                            pw.print(' ');
                            pw.println(increment);
                        }

                        @Override
                        public void visitTableSwitchInsn(int min, int max, Label dflt, Label... labels) {
                            pw.print(""tableswitch "");
                            pw.println(min);
                            for (Label label : labels) {
                                pw.print(""      "");
                                print(label);
                                pw.println();
                            }
                            pw.print(""      default : "");
                            print(dflt);
                            pw.println();
                        }

                        @Override
                        public void visitLookupSwitchInsn(Label dflt, int[] keys, Label[] labels) {
                            pw.println(""lookupswitch"");
                            for (int i = 0; i < keys.length; ++i) {
                                pw.print(""      "");
                                pw.print(keys[i]);
                                pw.print("" : "");
                                print(labels[i]);
                                pw.println();
                            }
                            pw.print(""      default : "");
                            print(dflt);
                            pw.println();
                        }

                        @Override
                        public void visitMultiANewArrayInsn(String desc, int dims) {
                            pw.print(""multianewarray "");
                            pw.print(desc);
                            pw.print(' ');
                            pw.println(dims);
                        }

                        @Override
                        public void visitLineNumber(int line, Label start) {
                            pw.print("".line "");
                            pw.println(line);
                        }
                    });
                }
                if (mn.localVariables != null) {
                    for (LocalVariableNode lv : mn.localVariables) {
                        pw.print(""  .var "");
                        pw.print(lv.index);
                        pw.print("" is '"");
                        pw.print(lv.name);
                        pw.print(""' "");
                        pw.print(lv.desc);
                        if (lv.signature != null) {
                            pw.print("" signature \"""");
                            pw.print(lv.signature);
                            pw.print(""\"""");
                        }
                        pw.print("" from "");
                        print(lv.start);
                        pw.print("" to "");
                        print(lv.end);
                        pw.println();
                    }
                }
                println(""  .limit locals "", Integer.toString(mn.maxLocals));
                println(""  .limit stack "", Integer.toString(mn.maxStack));
            }
            pw.println("".end method"");
        }
    }",iterator
an,"{
        labelNames.clear();
        pw.print("".bytecode "");
        pw.print(cn.version & 0xFFFF);
        pw.print('.');
        pw.println(cn.version >>> 16);
        println("".source "", cn.sourceFile);
        pw.print("".class"");
        pw.print(access_clz(cn.access));
        pw.print(' ');
        printIdAfterAccess(pw, cn.name);
        pw.println();
        if (cn.superName != null) {
            pw.print("".super "");
            printIdAfterAccess(pw, cn.superName);
            pw.println();
        }
        for (String itf : cn.interfaces) {
            pw.print("".implements "");
            printIdAfterAccess(pw, itf);
            pw.println();
        }
        if (cn.signature != null) {
            println("".signature "", '""' + cn.signature + '""');
        }
        if (cn.outerClass != null) {
            pw.print("".enclosing method "");
            pw.print(cn.outerClass);
            if (cn.outerMethod != null) {
                pw.print('/');
                pw.print(cn.outerMethod);
                pw.println(cn.outerMethodDesc);
            } else {
                pw.println();
            }
        }
        if ((cn.access & Opcodes.ACC_DEPRECATED) != 0) {
            pw.println("".deprecated"");
        }
        if (cn.visibleAnnotations != null) {
            for (AnnotationNode an : cn.visibleAnnotations) {
                printAnnotation(an, 1, -1);
            }
        }
        if (cn.invisibleAnnotations != null) {
            for (AnnotationNode an : cn.invisibleAnnotations) {
                printAnnotation(an, 2, -1);
            }
        }

        println("".debug "", cn.sourceDebug == null ? null : '""' + cn.sourceDebug + '""');

        for (InnerClassNode in : cn.innerClasses) {
            pw.print("".inner class"");
            pw.print(access_clz(in.access & (~Opcodes.ACC_SUPER)));
            if (in.innerName != null) {
                pw.print(' ');
                printIdAfterAccess(pw, in.innerName);
            }
            if (in.name != null) {
                pw.print("" inner "");
                pw.print(in.name);
            }
            if (in.outerName != null) {
                pw.print("" outer "");
                pw.print(in.outerName);
            }
            pw.println();
        }

        for (FieldNode fn : cn.fields) {
            boolean annotations = false;
            if (fn.visibleAnnotations != null && fn.visibleAnnotations.size() > 0) {
                annotations = true;
            }
            if (fn.invisibleAnnotations != null && fn.invisibleAnnotations.size() > 0) {
                annotations = true;
            }
            boolean deprecated = (fn.access & Opcodes.ACC_DEPRECATED) != 0;
            pw.print(""\n.field"");
            pw.print(access_fld(fn.access));
            pw.print(' ');
            printIdAfterAccess(pw,fn.name);
            pw.print(' ');
            pw.print(fn.desc);
            if (fn.value instanceof String) {
                StringBuffer buf = new StringBuffer();
                Printer.appendString(buf, (String) fn.value);
                pw.print("" = "");
                pw.print(buf.toString());
            } else if (fn.value != null) {
                pw.print("" = "");
                print(fn.value);
            }
            pw.println();
            if (fn.signature != null) {
                pw.print("".signature \"""");
                pw.print(fn.signature);
                pw.println(""\"""");
            }
            if (deprecated) {
                pw.println("".deprecated"");
            }
            if (fn.visibleAnnotations != null) {
                for (AnnotationNode an : fn.visibleAnnotations) {
                    printAnnotation(an, 1, -1);
                }
            }
            if (fn.invisibleAnnotations != null) {
                for (AnnotationNode an : fn.invisibleAnnotations) {
                    printAnnotation(an, 2, -1);
                }
            }
            if (fn.signature != null || deprecated || annotations) {
                pw.println("".end field"");
            }
        }

        for (MethodNode mn : cn.methods) {
            pw.print(""\n.method"");
            pw.print(access_mtd(mn.access));
            pw.print(' ');
            printIdAfterAccess(pw, mn.name);
            pw.println(mn.desc);
            if (mn.signature != null) {
                pw.print("".signature \"""");
                pw.print(mn.signature);
                pw.println(""\"""");
            }
            if (mn.annotationDefault != null) {
                pw.println("".annotation default"");
                printAnnotationValue(mn.annotationDefault);
                pw.println("".end annotation"");
            }
            if (mn.visibleAnnotations != null) {
                for (AnnotationNode an : mn.visibleAnnotations) {
                    printAnnotation(an, 1, -1);
                }
            }
            if (mn.invisibleAnnotations != null) {
                for (AnnotationNode an : mn.invisibleAnnotations) {
                    printAnnotation(an, 2, -1);
                }
            }
            if (mn.visibleParameterAnnotations != null) {
                for (int j = 0; j < mn.visibleParameterAnnotations.length; ++j) {
                    List<AnnotationNode> pas = mn.visibleParameterAnnotations[j];
                    if (pas != null) {
                        for (AnnotationNode an : pas) {
                            printAnnotation(an, 1, j + 1);
                        }
                    }
                }
            }
            if (mn.invisibleParameterAnnotations != null) {
                for (int j = 0; j < mn.invisibleParameterAnnotations.length; ++j) {
                    List<AnnotationNode> pas = mn.invisibleParameterAnnotations[j];
                    if (pas != null) {
                        for (AnnotationNode an : pas) {
                            printAnnotation(an, 2, j + 1);
                        }
                    }
                }
            }
            for (String ex : mn.exceptions) {
                println("".throws "", ex);
            }
            if ((mn.access & Opcodes.ACC_DEPRECATED) != 0) {
                pw.println("".deprecated"");
            }
            if (mn.instructions != null && mn.instructions.size() > 0) {
                labelNames.clear();
                if (mn.tryCatchBlocks != null) {
                    for (TryCatchBlockNode tcb : mn.tryCatchBlocks) {
                        pw.print("".catch "");
                        pw.print(tcb.type == null ? ""all"" : ""all"".equals(tcb.type) ? ""\\u0097ll"" : tcb.type);
                        pw.print("" from "");
                        print(tcb.start);
                        pw.print("" to "");
                        print(tcb.end);
                        pw.print("" using "");
                        print(tcb.handler);
                        pw.println();
                    }
                }
                for (int j = 0; j < mn.instructions.size(); ++j) {
                    AbstractInsnNode in = mn.instructions.get(j);
                    if (in.getType() != AbstractInsnNode.LINE && in.getType() != AbstractInsnNode.FRAME) {
                       if(in.getType()==AbstractInsnNode.LABEL){
                           pw.print(""  "");
                       }else {
                           pw.print(""    "");
                       }
                    }
                    in.accept(new MethodVisitor(ASM4) {

                        @Override
                        public void visitInsn(int opcode) {
                            print(opcode);
                            pw.println();
                        }

                        @Override
                        public void visitIntInsn(int opcode, int operand) {
                            print(opcode);
                            if (opcode == Opcodes.NEWARRAY) {
                                switch (operand) {
                                case Opcodes.T_BOOLEAN:
                                    pw.println("" boolean"");
                                    break;
                                case Opcodes.T_CHAR:
                                    pw.println("" char"");
                                    break;
                                case Opcodes.T_FLOAT:
                                    pw.println("" float"");
                                    break;
                                case Opcodes.T_DOUBLE:
                                    pw.println("" double"");
                                    break;
                                case Opcodes.T_BYTE:
                                    pw.println("" byte"");
                                    break;
                                case Opcodes.T_SHORT:
                                    pw.println("" short"");
                                    break;
                                case Opcodes.T_INT:
                                    pw.println("" int"");
                                    break;
                                case Opcodes.T_LONG:
                                default:
                                    pw.println("" long"");
                                    break;
                                }
                            } else {
                                pw.print(' ');
                                pw.println(operand);
                            }
                        }

                        @Override
                        public void visitVarInsn(int opcode, int var) {
                            print(opcode);
                            pw.print(' ');
                            pw.println(var);
                        }

                        @Override
                        public void visitTypeInsn(int opcode, String type) {
                            print(opcode);
                            pw.print(' ');
                            pw.println(type);
                        }

                        @Override
                        public void visitFieldInsn(int opcode, String owner, String name, String desc) {
                            print(opcode);
                            pw.print(' ');
                            pw.print(owner);
                            pw.print('/');
                            pw.print(name);
                            pw.print(' ');
                            pw.println(desc);
                        }

                        @Override
                        public void visitMethodInsn(int opcode, String owner, String name, String desc) {
                            print(opcode);
                            pw.print(' ');
                            pw.print(owner);
                            pw.print('/');
                            pw.print(name);
                            pw.print(desc);
                            if (opcode == Opcodes.INVOKEINTERFACE) {
                                pw.print(' ');
                                pw.print((Type.getArgumentsAndReturnSizes(desc) >> 2) - 1);
                            }
                            pw.println();
                        }

                        @Override
                        public void visitJumpInsn(int opcode, Label label) {
                            print(opcode);
                            pw.print(' ');
                            print(label);
                            pw.println();
                        }

                        @Override
                        public void visitLabel(Label label) {
                            print(label);
                            pw.println(':');
                        }

                        @Override
                        public void visitLdcInsn(Object cst) {

                            if (cst instanceof Integer || cst instanceof Float) {
                                pw.print(""ldc_w "");
                                print(cst);
                            } else if (cst instanceof Long || cst instanceof Double) {
                                pw.print(""ldc2_w "");
                                print(cst);
                            } else {
                                pw.print(""ldc "");
                                if (cst instanceof Type) {
                                    pw.print(((Type) cst).getInternalName());
                                } else {
                                    print(cst);
                                }
                            }
                            pw.println();

                        }

                        @Override
                        public void visitIincInsn(int var, int increment) {
                            pw.print(""iinc "");
                            pw.print(var);
                            pw.print(' ');
                            pw.println(increment);
                        }

                        @Override
                        public void visitTableSwitchInsn(int min, int max, Label dflt, Label... labels) {
                            pw.print(""tableswitch "");
                            pw.println(min);
                            for (Label label : labels) {
                                pw.print(""      "");
                                print(label);
                                pw.println();
                            }
                            pw.print(""      default : "");
                            print(dflt);
                            pw.println();
                        }

                        @Override
                        public void visitLookupSwitchInsn(Label dflt, int[] keys, Label[] labels) {
                            pw.println(""lookupswitch"");
                            for (int i = 0; i < keys.length; ++i) {
                                pw.print(""      "");
                                pw.print(keys[i]);
                                pw.print("" : "");
                                print(labels[i]);
                                pw.println();
                            }
                            pw.print(""      default : "");
                            print(dflt);
                            pw.println();
                        }

                        @Override
                        public void visitMultiANewArrayInsn(String desc, int dims) {
                            pw.print(""multianewarray "");
                            pw.print(desc);
                            pw.print(' ');
                            pw.println(dims);
                        }

                        @Override
                        public void visitLineNumber(int line, Label start) {
                            pw.print("".line "");
                            pw.println(line);
                        }
                    });
                }
                if (mn.localVariables != null) {
                    for (LocalVariableNode lv : mn.localVariables) {
                        pw.print(""  .var "");
                        pw.print(lv.index);
                        pw.print("" is '"");
                        pw.print(lv.name);
                        pw.print(""' "");
                        pw.print(lv.desc);
                        if (lv.signature != null) {
                            pw.print("" signature \"""");
                            pw.print(lv.signature);
                            pw.print(""\"""");
                        }
                        pw.print("" from "");
                        print(lv.start);
                        pw.print("" to "");
                        print(lv.end);
                        pw.println();
                    }
                }
                println(""  .limit locals "", Integer.toString(mn.maxLocals));
                println(""  .limit stack "", Integer.toString(mn.maxStack));
            }
            pw.println("".end method"");
        }
    }",iterator
in,"{
        labelNames.clear();
        pw.print("".bytecode "");
        pw.print(cn.version & 0xFFFF);
        pw.print('.');
        pw.println(cn.version >>> 16);
        println("".source "", cn.sourceFile);
        pw.print("".class"");
        pw.print(access_clz(cn.access));
        pw.print(' ');
        printIdAfterAccess(pw, cn.name);
        pw.println();
        if (cn.superName != null) {
            pw.print("".super "");
            printIdAfterAccess(pw, cn.superName);
            pw.println();
        }
        for (String itf : cn.interfaces) {
            pw.print("".implements "");
            printIdAfterAccess(pw, itf);
            pw.println();
        }
        if (cn.signature != null) {
            println("".signature "", '""' + cn.signature + '""');
        }
        if (cn.outerClass != null) {
            pw.print("".enclosing method "");
            pw.print(cn.outerClass);
            if (cn.outerMethod != null) {
                pw.print('/');
                pw.print(cn.outerMethod);
                pw.println(cn.outerMethodDesc);
            } else {
                pw.println();
            }
        }
        if ((cn.access & Opcodes.ACC_DEPRECATED) != 0) {
            pw.println("".deprecated"");
        }
        if (cn.visibleAnnotations != null) {
            for (AnnotationNode an : cn.visibleAnnotations) {
                printAnnotation(an, 1, -1);
            }
        }
        if (cn.invisibleAnnotations != null) {
            for (AnnotationNode an : cn.invisibleAnnotations) {
                printAnnotation(an, 2, -1);
            }
        }

        println("".debug "", cn.sourceDebug == null ? null : '""' + cn.sourceDebug + '""');

        for (InnerClassNode in : cn.innerClasses) {
            pw.print("".inner class"");
            pw.print(access_clz(in.access & (~Opcodes.ACC_SUPER)));
            if (in.innerName != null) {
                pw.print(' ');
                printIdAfterAccess(pw, in.innerName);
            }
            if (in.name != null) {
                pw.print("" inner "");
                pw.print(in.name);
            }
            if (in.outerName != null) {
                pw.print("" outer "");
                pw.print(in.outerName);
            }
            pw.println();
        }

        for (FieldNode fn : cn.fields) {
            boolean annotations = false;
            if (fn.visibleAnnotations != null && fn.visibleAnnotations.size() > 0) {
                annotations = true;
            }
            if (fn.invisibleAnnotations != null && fn.invisibleAnnotations.size() > 0) {
                annotations = true;
            }
            boolean deprecated = (fn.access & Opcodes.ACC_DEPRECATED) != 0;
            pw.print(""\n.field"");
            pw.print(access_fld(fn.access));
            pw.print(' ');
            printIdAfterAccess(pw,fn.name);
            pw.print(' ');
            pw.print(fn.desc);
            if (fn.value instanceof String) {
                StringBuffer buf = new StringBuffer();
                Printer.appendString(buf, (String) fn.value);
                pw.print("" = "");
                pw.print(buf.toString());
            } else if (fn.value != null) {
                pw.print("" = "");
                print(fn.value);
            }
            pw.println();
            if (fn.signature != null) {
                pw.print("".signature \"""");
                pw.print(fn.signature);
                pw.println(""\"""");
            }
            if (deprecated) {
                pw.println("".deprecated"");
            }
            if (fn.visibleAnnotations != null) {
                for (AnnotationNode an : fn.visibleAnnotations) {
                    printAnnotation(an, 1, -1);
                }
            }
            if (fn.invisibleAnnotations != null) {
                for (AnnotationNode an : fn.invisibleAnnotations) {
                    printAnnotation(an, 2, -1);
                }
            }
            if (fn.signature != null || deprecated || annotations) {
                pw.println("".end field"");
            }
        }

        for (MethodNode mn : cn.methods) {
            pw.print(""\n.method"");
            pw.print(access_mtd(mn.access));
            pw.print(' ');
            printIdAfterAccess(pw, mn.name);
            pw.println(mn.desc);
            if (mn.signature != null) {
                pw.print("".signature \"""");
                pw.print(mn.signature);
                pw.println(""\"""");
            }
            if (mn.annotationDefault != null) {
                pw.println("".annotation default"");
                printAnnotationValue(mn.annotationDefault);
                pw.println("".end annotation"");
            }
            if (mn.visibleAnnotations != null) {
                for (AnnotationNode an : mn.visibleAnnotations) {
                    printAnnotation(an, 1, -1);
                }
            }
            if (mn.invisibleAnnotations != null) {
                for (AnnotationNode an : mn.invisibleAnnotations) {
                    printAnnotation(an, 2, -1);
                }
            }
            if (mn.visibleParameterAnnotations != null) {
                for (int j = 0; j < mn.visibleParameterAnnotations.length; ++j) {
                    List<AnnotationNode> pas = mn.visibleParameterAnnotations[j];
                    if (pas != null) {
                        for (AnnotationNode an : pas) {
                            printAnnotation(an, 1, j + 1);
                        }
                    }
                }
            }
            if (mn.invisibleParameterAnnotations != null) {
                for (int j = 0; j < mn.invisibleParameterAnnotations.length; ++j) {
                    List<AnnotationNode> pas = mn.invisibleParameterAnnotations[j];
                    if (pas != null) {
                        for (AnnotationNode an : pas) {
                            printAnnotation(an, 2, j + 1);
                        }
                    }
                }
            }
            for (String ex : mn.exceptions) {
                println("".throws "", ex);
            }
            if ((mn.access & Opcodes.ACC_DEPRECATED) != 0) {
                pw.println("".deprecated"");
            }
            if (mn.instructions != null && mn.instructions.size() > 0) {
                labelNames.clear();
                if (mn.tryCatchBlocks != null) {
                    for (TryCatchBlockNode tcb : mn.tryCatchBlocks) {
                        pw.print("".catch "");
                        pw.print(tcb.type == null ? ""all"" : ""all"".equals(tcb.type) ? ""\\u0097ll"" : tcb.type);
                        pw.print("" from "");
                        print(tcb.start);
                        pw.print("" to "");
                        print(tcb.end);
                        pw.print("" using "");
                        print(tcb.handler);
                        pw.println();
                    }
                }
                for (int j = 0; j < mn.instructions.size(); ++j) {
                    AbstractInsnNode in = mn.instructions.get(j);
                    if (in.getType() != AbstractInsnNode.LINE && in.getType() != AbstractInsnNode.FRAME) {
                       if(in.getType()==AbstractInsnNode.LABEL){
                           pw.print(""  "");
                       }else {
                           pw.print(""    "");
                       }
                    }
                    in.accept(new MethodVisitor(ASM4) {

                        @Override
                        public void visitInsn(int opcode) {
                            print(opcode);
                            pw.println();
                        }

                        @Override
                        public void visitIntInsn(int opcode, int operand) {
                            print(opcode);
                            if (opcode == Opcodes.NEWARRAY) {
                                switch (operand) {
                                case Opcodes.T_BOOLEAN:
                                    pw.println("" boolean"");
                                    break;
                                case Opcodes.T_CHAR:
                                    pw.println("" char"");
                                    break;
                                case Opcodes.T_FLOAT:
                                    pw.println("" float"");
                                    break;
                                case Opcodes.T_DOUBLE:
                                    pw.println("" double"");
                                    break;
                                case Opcodes.T_BYTE:
                                    pw.println("" byte"");
                                    break;
                                case Opcodes.T_SHORT:
                                    pw.println("" short"");
                                    break;
                                case Opcodes.T_INT:
                                    pw.println("" int"");
                                    break;
                                case Opcodes.T_LONG:
                                default:
                                    pw.println("" long"");
                                    break;
                                }
                            } else {
                                pw.print(' ');
                                pw.println(operand);
                            }
                        }

                        @Override
                        public void visitVarInsn(int opcode, int var) {
                            print(opcode);
                            pw.print(' ');
                            pw.println(var);
                        }

                        @Override
                        public void visitTypeInsn(int opcode, String type) {
                            print(opcode);
                            pw.print(' ');
                            pw.println(type);
                        }

                        @Override
                        public void visitFieldInsn(int opcode, String owner, String name, String desc) {
                            print(opcode);
                            pw.print(' ');
                            pw.print(owner);
                            pw.print('/');
                            pw.print(name);
                            pw.print(' ');
                            pw.println(desc);
                        }

                        @Override
                        public void visitMethodInsn(int opcode, String owner, String name, String desc) {
                            print(opcode);
                            pw.print(' ');
                            pw.print(owner);
                            pw.print('/');
                            pw.print(name);
                            pw.print(desc);
                            if (opcode == Opcodes.INVOKEINTERFACE) {
                                pw.print(' ');
                                pw.print((Type.getArgumentsAndReturnSizes(desc) >> 2) - 1);
                            }
                            pw.println();
                        }

                        @Override
                        public void visitJumpInsn(int opcode, Label label) {
                            print(opcode);
                            pw.print(' ');
                            print(label);
                            pw.println();
                        }

                        @Override
                        public void visitLabel(Label label) {
                            print(label);
                            pw.println(':');
                        }

                        @Override
                        public void visitLdcInsn(Object cst) {

                            if (cst instanceof Integer || cst instanceof Float) {
                                pw.print(""ldc_w "");
                                print(cst);
                            } else if (cst instanceof Long || cst instanceof Double) {
                                pw.print(""ldc2_w "");
                                print(cst);
                            } else {
                                pw.print(""ldc "");
                                if (cst instanceof Type) {
                                    pw.print(((Type) cst).getInternalName());
                                } else {
                                    print(cst);
                                }
                            }
                            pw.println();

                        }

                        @Override
                        public void visitIincInsn(int var, int increment) {
                            pw.print(""iinc "");
                            pw.print(var);
                            pw.print(' ');
                            pw.println(increment);
                        }

                        @Override
                        public void visitTableSwitchInsn(int min, int max, Label dflt, Label... labels) {
                            pw.print(""tableswitch "");
                            pw.println(min);
                            for (Label label : labels) {
                                pw.print(""      "");
                                print(label);
                                pw.println();
                            }
                            pw.print(""      default : "");
                            print(dflt);
                            pw.println();
                        }

                        @Override
                        public void visitLookupSwitchInsn(Label dflt, int[] keys, Label[] labels) {
                            pw.println(""lookupswitch"");
                            for (int i = 0; i < keys.length; ++i) {
                                pw.print(""      "");
                                pw.print(keys[i]);
                                pw.print("" : "");
                                print(labels[i]);
                                pw.println();
                            }
                            pw.print(""      default : "");
                            print(dflt);
                            pw.println();
                        }

                        @Override
                        public void visitMultiANewArrayInsn(String desc, int dims) {
                            pw.print(""multianewarray "");
                            pw.print(desc);
                            pw.print(' ');
                            pw.println(dims);
                        }

                        @Override
                        public void visitLineNumber(int line, Label start) {
                            pw.print("".line "");
                            pw.println(line);
                        }
                    });
                }
                if (mn.localVariables != null) {
                    for (LocalVariableNode lv : mn.localVariables) {
                        pw.print(""  .var "");
                        pw.print(lv.index);
                        pw.print("" is '"");
                        pw.print(lv.name);
                        pw.print(""' "");
                        pw.print(lv.desc);
                        if (lv.signature != null) {
                            pw.print("" signature \"""");
                            pw.print(lv.signature);
                            pw.print(""\"""");
                        }
                        pw.print("" from "");
                        print(lv.start);
                        pw.print("" to "");
                        print(lv.end);
                        pw.println();
                    }
                }
                println(""  .limit locals "", Integer.toString(mn.maxLocals));
                println(""  .limit stack "", Integer.toString(mn.maxStack));
            }
            pw.println("".end method"");
        }
    }",iterator
fn,"{
        labelNames.clear();
        pw.print("".bytecode "");
        pw.print(cn.version & 0xFFFF);
        pw.print('.');
        pw.println(cn.version >>> 16);
        println("".source "", cn.sourceFile);
        pw.print("".class"");
        pw.print(access_clz(cn.access));
        pw.print(' ');
        printIdAfterAccess(pw, cn.name);
        pw.println();
        if (cn.superName != null) {
            pw.print("".super "");
            printIdAfterAccess(pw, cn.superName);
            pw.println();
        }
        for (String itf : cn.interfaces) {
            pw.print("".implements "");
            printIdAfterAccess(pw, itf);
            pw.println();
        }
        if (cn.signature != null) {
            println("".signature "", '""' + cn.signature + '""');
        }
        if (cn.outerClass != null) {
            pw.print("".enclosing method "");
            pw.print(cn.outerClass);
            if (cn.outerMethod != null) {
                pw.print('/');
                pw.print(cn.outerMethod);
                pw.println(cn.outerMethodDesc);
            } else {
                pw.println();
            }
        }
        if ((cn.access & Opcodes.ACC_DEPRECATED) != 0) {
            pw.println("".deprecated"");
        }
        if (cn.visibleAnnotations != null) {
            for (AnnotationNode an : cn.visibleAnnotations) {
                printAnnotation(an, 1, -1);
            }
        }
        if (cn.invisibleAnnotations != null) {
            for (AnnotationNode an : cn.invisibleAnnotations) {
                printAnnotation(an, 2, -1);
            }
        }

        println("".debug "", cn.sourceDebug == null ? null : '""' + cn.sourceDebug + '""');

        for (InnerClassNode in : cn.innerClasses) {
            pw.print("".inner class"");
            pw.print(access_clz(in.access & (~Opcodes.ACC_SUPER)));
            if (in.innerName != null) {
                pw.print(' ');
                printIdAfterAccess(pw, in.innerName);
            }
            if (in.name != null) {
                pw.print("" inner "");
                pw.print(in.name);
            }
            if (in.outerName != null) {
                pw.print("" outer "");
                pw.print(in.outerName);
            }
            pw.println();
        }

        for (FieldNode fn : cn.fields) {
            boolean annotations = false;
            if (fn.visibleAnnotations != null && fn.visibleAnnotations.size() > 0) {
                annotations = true;
            }
            if (fn.invisibleAnnotations != null && fn.invisibleAnnotations.size() > 0) {
                annotations = true;
            }
            boolean deprecated = (fn.access & Opcodes.ACC_DEPRECATED) != 0;
            pw.print(""\n.field"");
            pw.print(access_fld(fn.access));
            pw.print(' ');
            printIdAfterAccess(pw,fn.name);
            pw.print(' ');
            pw.print(fn.desc);
            if (fn.value instanceof String) {
                StringBuffer buf = new StringBuffer();
                Printer.appendString(buf, (String) fn.value);
                pw.print("" = "");
                pw.print(buf.toString());
            } else if (fn.value != null) {
                pw.print("" = "");
                print(fn.value);
            }
            pw.println();
            if (fn.signature != null) {
                pw.print("".signature \"""");
                pw.print(fn.signature);
                pw.println(""\"""");
            }
            if (deprecated) {
                pw.println("".deprecated"");
            }
            if (fn.visibleAnnotations != null) {
                for (AnnotationNode an : fn.visibleAnnotations) {
                    printAnnotation(an, 1, -1);
                }
            }
            if (fn.invisibleAnnotations != null) {
                for (AnnotationNode an : fn.invisibleAnnotations) {
                    printAnnotation(an, 2, -1);
                }
            }
            if (fn.signature != null || deprecated || annotations) {
                pw.println("".end field"");
            }
        }

        for (MethodNode mn : cn.methods) {
            pw.print(""\n.method"");
            pw.print(access_mtd(mn.access));
            pw.print(' ');
            printIdAfterAccess(pw, mn.name);
            pw.println(mn.desc);
            if (mn.signature != null) {
                pw.print("".signature \"""");
                pw.print(mn.signature);
                pw.println(""\"""");
            }
            if (mn.annotationDefault != null) {
                pw.println("".annotation default"");
                printAnnotationValue(mn.annotationDefault);
                pw.println("".end annotation"");
            }
            if (mn.visibleAnnotations != null) {
                for (AnnotationNode an : mn.visibleAnnotations) {
                    printAnnotation(an, 1, -1);
                }
            }
            if (mn.invisibleAnnotations != null) {
                for (AnnotationNode an : mn.invisibleAnnotations) {
                    printAnnotation(an, 2, -1);
                }
            }
            if (mn.visibleParameterAnnotations != null) {
                for (int j = 0; j < mn.visibleParameterAnnotations.length; ++j) {
                    List<AnnotationNode> pas = mn.visibleParameterAnnotations[j];
                    if (pas != null) {
                        for (AnnotationNode an : pas) {
                            printAnnotation(an, 1, j + 1);
                        }
                    }
                }
            }
            if (mn.invisibleParameterAnnotations != null) {
                for (int j = 0; j < mn.invisibleParameterAnnotations.length; ++j) {
                    List<AnnotationNode> pas = mn.invisibleParameterAnnotations[j];
                    if (pas != null) {
                        for (AnnotationNode an : pas) {
                            printAnnotation(an, 2, j + 1);
                        }
                    }
                }
            }
            for (String ex : mn.exceptions) {
                println("".throws "", ex);
            }
            if ((mn.access & Opcodes.ACC_DEPRECATED) != 0) {
                pw.println("".deprecated"");
            }
            if (mn.instructions != null && mn.instructions.size() > 0) {
                labelNames.clear();
                if (mn.tryCatchBlocks != null) {
                    for (TryCatchBlockNode tcb : mn.tryCatchBlocks) {
                        pw.print("".catch "");
                        pw.print(tcb.type == null ? ""all"" : ""all"".equals(tcb.type) ? ""\\u0097ll"" : tcb.type);
                        pw.print("" from "");
                        print(tcb.start);
                        pw.print("" to "");
                        print(tcb.end);
                        pw.print("" using "");
                        print(tcb.handler);
                        pw.println();
                    }
                }
                for (int j = 0; j < mn.instructions.size(); ++j) {
                    AbstractInsnNode in = mn.instructions.get(j);
                    if (in.getType() != AbstractInsnNode.LINE && in.getType() != AbstractInsnNode.FRAME) {
                       if(in.getType()==AbstractInsnNode.LABEL){
                           pw.print(""  "");
                       }else {
                           pw.print(""    "");
                       }
                    }
                    in.accept(new MethodVisitor(ASM4) {

                        @Override
                        public void visitInsn(int opcode) {
                            print(opcode);
                            pw.println();
                        }

                        @Override
                        public void visitIntInsn(int opcode, int operand) {
                            print(opcode);
                            if (opcode == Opcodes.NEWARRAY) {
                                switch (operand) {
                                case Opcodes.T_BOOLEAN:
                                    pw.println("" boolean"");
                                    break;
                                case Opcodes.T_CHAR:
                                    pw.println("" char"");
                                    break;
                                case Opcodes.T_FLOAT:
                                    pw.println("" float"");
                                    break;
                                case Opcodes.T_DOUBLE:
                                    pw.println("" double"");
                                    break;
                                case Opcodes.T_BYTE:
                                    pw.println("" byte"");
                                    break;
                                case Opcodes.T_SHORT:
                                    pw.println("" short"");
                                    break;
                                case Opcodes.T_INT:
                                    pw.println("" int"");
                                    break;
                                case Opcodes.T_LONG:
                                default:
                                    pw.println("" long"");
                                    break;
                                }
                            } else {
                                pw.print(' ');
                                pw.println(operand);
                            }
                        }

                        @Override
                        public void visitVarInsn(int opcode, int var) {
                            print(opcode);
                            pw.print(' ');
                            pw.println(var);
                        }

                        @Override
                        public void visitTypeInsn(int opcode, String type) {
                            print(opcode);
                            pw.print(' ');
                            pw.println(type);
                        }

                        @Override
                        public void visitFieldInsn(int opcode, String owner, String name, String desc) {
                            print(opcode);
                            pw.print(' ');
                            pw.print(owner);
                            pw.print('/');
                            pw.print(name);
                            pw.print(' ');
                            pw.println(desc);
                        }

                        @Override
                        public void visitMethodInsn(int opcode, String owner, String name, String desc) {
                            print(opcode);
                            pw.print(' ');
                            pw.print(owner);
                            pw.print('/');
                            pw.print(name);
                            pw.print(desc);
                            if (opcode == Opcodes.INVOKEINTERFACE) {
                                pw.print(' ');
                                pw.print((Type.getArgumentsAndReturnSizes(desc) >> 2) - 1);
                            }
                            pw.println();
                        }

                        @Override
                        public void visitJumpInsn(int opcode, Label label) {
                            print(opcode);
                            pw.print(' ');
                            print(label);
                            pw.println();
                        }

                        @Override
                        public void visitLabel(Label label) {
                            print(label);
                            pw.println(':');
                        }

                        @Override
                        public void visitLdcInsn(Object cst) {

                            if (cst instanceof Integer || cst instanceof Float) {
                                pw.print(""ldc_w "");
                                print(cst);
                            } else if (cst instanceof Long || cst instanceof Double) {
                                pw.print(""ldc2_w "");
                                print(cst);
                            } else {
                                pw.print(""ldc "");
                                if (cst instanceof Type) {
                                    pw.print(((Type) cst).getInternalName());
                                } else {
                                    print(cst);
                                }
                            }
                            pw.println();

                        }

                        @Override
                        public void visitIincInsn(int var, int increment) {
                            pw.print(""iinc "");
                            pw.print(var);
                            pw.print(' ');
                            pw.println(increment);
                        }

                        @Override
                        public void visitTableSwitchInsn(int min, int max, Label dflt, Label... labels) {
                            pw.print(""tableswitch "");
                            pw.println(min);
                            for (Label label : labels) {
                                pw.print(""      "");
                                print(label);
                                pw.println();
                            }
                            pw.print(""      default : "");
                            print(dflt);
                            pw.println();
                        }

                        @Override
                        public void visitLookupSwitchInsn(Label dflt, int[] keys, Label[] labels) {
                            pw.println(""lookupswitch"");
                            for (int i = 0; i < keys.length; ++i) {
                                pw.print(""      "");
                                pw.print(keys[i]);
                                pw.print("" : "");
                                print(labels[i]);
                                pw.println();
                            }
                            pw.print(""      default : "");
                            print(dflt);
                            pw.println();
                        }

                        @Override
                        public void visitMultiANewArrayInsn(String desc, int dims) {
                            pw.print(""multianewarray "");
                            pw.print(desc);
                            pw.print(' ');
                            pw.println(dims);
                        }

                        @Override
                        public void visitLineNumber(int line, Label start) {
                            pw.print("".line "");
                            pw.println(line);
                        }
                    });
                }
                if (mn.localVariables != null) {
                    for (LocalVariableNode lv : mn.localVariables) {
                        pw.print(""  .var "");
                        pw.print(lv.index);
                        pw.print("" is '"");
                        pw.print(lv.name);
                        pw.print(""' "");
                        pw.print(lv.desc);
                        if (lv.signature != null) {
                            pw.print("" signature \"""");
                            pw.print(lv.signature);
                            pw.print(""\"""");
                        }
                        pw.print("" from "");
                        print(lv.start);
                        pw.print("" to "");
                        print(lv.end);
                        pw.println();
                    }
                }
                println(""  .limit locals "", Integer.toString(mn.maxLocals));
                println(""  .limit stack "", Integer.toString(mn.maxStack));
            }
            pw.println("".end method"");
        }
    }",iterator
mn,"{
        labelNames.clear();
        pw.print("".bytecode "");
        pw.print(cn.version & 0xFFFF);
        pw.print('.');
        pw.println(cn.version >>> 16);
        println("".source "", cn.sourceFile);
        pw.print("".class"");
        pw.print(access_clz(cn.access));
        pw.print(' ');
        printIdAfterAccess(pw, cn.name);
        pw.println();
        if (cn.superName != null) {
            pw.print("".super "");
            printIdAfterAccess(pw, cn.superName);
            pw.println();
        }
        for (String itf : cn.interfaces) {
            pw.print("".implements "");
            printIdAfterAccess(pw, itf);
            pw.println();
        }
        if (cn.signature != null) {
            println("".signature "", '""' + cn.signature + '""');
        }
        if (cn.outerClass != null) {
            pw.print("".enclosing method "");
            pw.print(cn.outerClass);
            if (cn.outerMethod != null) {
                pw.print('/');
                pw.print(cn.outerMethod);
                pw.println(cn.outerMethodDesc);
            } else {
                pw.println();
            }
        }
        if ((cn.access & Opcodes.ACC_DEPRECATED) != 0) {
            pw.println("".deprecated"");
        }
        if (cn.visibleAnnotations != null) {
            for (AnnotationNode an : cn.visibleAnnotations) {
                printAnnotation(an, 1, -1);
            }
        }
        if (cn.invisibleAnnotations != null) {
            for (AnnotationNode an : cn.invisibleAnnotations) {
                printAnnotation(an, 2, -1);
            }
        }

        println("".debug "", cn.sourceDebug == null ? null : '""' + cn.sourceDebug + '""');

        for (InnerClassNode in : cn.innerClasses) {
            pw.print("".inner class"");
            pw.print(access_clz(in.access & (~Opcodes.ACC_SUPER)));
            if (in.innerName != null) {
                pw.print(' ');
                printIdAfterAccess(pw, in.innerName);
            }
            if (in.name != null) {
                pw.print("" inner "");
                pw.print(in.name);
            }
            if (in.outerName != null) {
                pw.print("" outer "");
                pw.print(in.outerName);
            }
            pw.println();
        }

        for (FieldNode fn : cn.fields) {
            boolean annotations = false;
            if (fn.visibleAnnotations != null && fn.visibleAnnotations.size() > 0) {
                annotations = true;
            }
            if (fn.invisibleAnnotations != null && fn.invisibleAnnotations.size() > 0) {
                annotations = true;
            }
            boolean deprecated = (fn.access & Opcodes.ACC_DEPRECATED) != 0;
            pw.print(""\n.field"");
            pw.print(access_fld(fn.access));
            pw.print(' ');
            printIdAfterAccess(pw,fn.name);
            pw.print(' ');
            pw.print(fn.desc);
            if (fn.value instanceof String) {
                StringBuffer buf = new StringBuffer();
                Printer.appendString(buf, (String) fn.value);
                pw.print("" = "");
                pw.print(buf.toString());
            } else if (fn.value != null) {
                pw.print("" = "");
                print(fn.value);
            }
            pw.println();
            if (fn.signature != null) {
                pw.print("".signature \"""");
                pw.print(fn.signature);
                pw.println(""\"""");
            }
            if (deprecated) {
                pw.println("".deprecated"");
            }
            if (fn.visibleAnnotations != null) {
                for (AnnotationNode an : fn.visibleAnnotations) {
                    printAnnotation(an, 1, -1);
                }
            }
            if (fn.invisibleAnnotations != null) {
                for (AnnotationNode an : fn.invisibleAnnotations) {
                    printAnnotation(an, 2, -1);
                }
            }
            if (fn.signature != null || deprecated || annotations) {
                pw.println("".end field"");
            }
        }

        for (MethodNode mn : cn.methods) {
            pw.print(""\n.method"");
            pw.print(access_mtd(mn.access));
            pw.print(' ');
            printIdAfterAccess(pw, mn.name);
            pw.println(mn.desc);
            if (mn.signature != null) {
                pw.print("".signature \"""");
                pw.print(mn.signature);
                pw.println(""\"""");
            }
            if (mn.annotationDefault != null) {
                pw.println("".annotation default"");
                printAnnotationValue(mn.annotationDefault);
                pw.println("".end annotation"");
            }
            if (mn.visibleAnnotations != null) {
                for (AnnotationNode an : mn.visibleAnnotations) {
                    printAnnotation(an, 1, -1);
                }
            }
            if (mn.invisibleAnnotations != null) {
                for (AnnotationNode an : mn.invisibleAnnotations) {
                    printAnnotation(an, 2, -1);
                }
            }
            if (mn.visibleParameterAnnotations != null) {
                for (int j = 0; j < mn.visibleParameterAnnotations.length; ++j) {
                    List<AnnotationNode> pas = mn.visibleParameterAnnotations[j];
                    if (pas != null) {
                        for (AnnotationNode an : pas) {
                            printAnnotation(an, 1, j + 1);
                        }
                    }
                }
            }
            if (mn.invisibleParameterAnnotations != null) {
                for (int j = 0; j < mn.invisibleParameterAnnotations.length; ++j) {
                    List<AnnotationNode> pas = mn.invisibleParameterAnnotations[j];
                    if (pas != null) {
                        for (AnnotationNode an : pas) {
                            printAnnotation(an, 2, j + 1);
                        }
                    }
                }
            }
            for (String ex : mn.exceptions) {
                println("".throws "", ex);
            }
            if ((mn.access & Opcodes.ACC_DEPRECATED) != 0) {
                pw.println("".deprecated"");
            }
            if (mn.instructions != null && mn.instructions.size() > 0) {
                labelNames.clear();
                if (mn.tryCatchBlocks != null) {
                    for (TryCatchBlockNode tcb : mn.tryCatchBlocks) {
                        pw.print("".catch "");
                        pw.print(tcb.type == null ? ""all"" : ""all"".equals(tcb.type) ? ""\\u0097ll"" : tcb.type);
                        pw.print("" from "");
                        print(tcb.start);
                        pw.print("" to "");
                        print(tcb.end);
                        pw.print("" using "");
                        print(tcb.handler);
                        pw.println();
                    }
                }
                for (int j = 0; j < mn.instructions.size(); ++j) {
                    AbstractInsnNode in = mn.instructions.get(j);
                    if (in.getType() != AbstractInsnNode.LINE && in.getType() != AbstractInsnNode.FRAME) {
                       if(in.getType()==AbstractInsnNode.LABEL){
                           pw.print(""  "");
                       }else {
                           pw.print(""    "");
                       }
                    }
                    in.accept(new MethodVisitor(ASM4) {

                        @Override
                        public void visitInsn(int opcode) {
                            print(opcode);
                            pw.println();
                        }

                        @Override
                        public void visitIntInsn(int opcode, int operand) {
                            print(opcode);
                            if (opcode == Opcodes.NEWARRAY) {
                                switch (operand) {
                                case Opcodes.T_BOOLEAN:
                                    pw.println("" boolean"");
                                    break;
                                case Opcodes.T_CHAR:
                                    pw.println("" char"");
                                    break;
                                case Opcodes.T_FLOAT:
                                    pw.println("" float"");
                                    break;
                                case Opcodes.T_DOUBLE:
                                    pw.println("" double"");
                                    break;
                                case Opcodes.T_BYTE:
                                    pw.println("" byte"");
                                    break;
                                case Opcodes.T_SHORT:
                                    pw.println("" short"");
                                    break;
                                case Opcodes.T_INT:
                                    pw.println("" int"");
                                    break;
                                case Opcodes.T_LONG:
                                default:
                                    pw.println("" long"");
                                    break;
                                }
                            } else {
                                pw.print(' ');
                                pw.println(operand);
                            }
                        }

                        @Override
                        public void visitVarInsn(int opcode, int var) {
                            print(opcode);
                            pw.print(' ');
                            pw.println(var);
                        }

                        @Override
                        public void visitTypeInsn(int opcode, String type) {
                            print(opcode);
                            pw.print(' ');
                            pw.println(type);
                        }

                        @Override
                        public void visitFieldInsn(int opcode, String owner, String name, String desc) {
                            print(opcode);
                            pw.print(' ');
                            pw.print(owner);
                            pw.print('/');
                            pw.print(name);
                            pw.print(' ');
                            pw.println(desc);
                        }

                        @Override
                        public void visitMethodInsn(int opcode, String owner, String name, String desc) {
                            print(opcode);
                            pw.print(' ');
                            pw.print(owner);
                            pw.print('/');
                            pw.print(name);
                            pw.print(desc);
                            if (opcode == Opcodes.INVOKEINTERFACE) {
                                pw.print(' ');
                                pw.print((Type.getArgumentsAndReturnSizes(desc) >> 2) - 1);
                            }
                            pw.println();
                        }

                        @Override
                        public void visitJumpInsn(int opcode, Label label) {
                            print(opcode);
                            pw.print(' ');
                            print(label);
                            pw.println();
                        }

                        @Override
                        public void visitLabel(Label label) {
                            print(label);
                            pw.println(':');
                        }

                        @Override
                        public void visitLdcInsn(Object cst) {

                            if (cst instanceof Integer || cst instanceof Float) {
                                pw.print(""ldc_w "");
                                print(cst);
                            } else if (cst instanceof Long || cst instanceof Double) {
                                pw.print(""ldc2_w "");
                                print(cst);
                            } else {
                                pw.print(""ldc "");
                                if (cst instanceof Type) {
                                    pw.print(((Type) cst).getInternalName());
                                } else {
                                    print(cst);
                                }
                            }
                            pw.println();

                        }

                        @Override
                        public void visitIincInsn(int var, int increment) {
                            pw.print(""iinc "");
                            pw.print(var);
                            pw.print(' ');
                            pw.println(increment);
                        }

                        @Override
                        public void visitTableSwitchInsn(int min, int max, Label dflt, Label... labels) {
                            pw.print(""tableswitch "");
                            pw.println(min);
                            for (Label label : labels) {
                                pw.print(""      "");
                                print(label);
                                pw.println();
                            }
                            pw.print(""      default : "");
                            print(dflt);
                            pw.println();
                        }

                        @Override
                        public void visitLookupSwitchInsn(Label dflt, int[] keys, Label[] labels) {
                            pw.println(""lookupswitch"");
                            for (int i = 0; i < keys.length; ++i) {
                                pw.print(""      "");
                                pw.print(keys[i]);
                                pw.print("" : "");
                                print(labels[i]);
                                pw.println();
                            }
                            pw.print(""      default : "");
                            print(dflt);
                            pw.println();
                        }

                        @Override
                        public void visitMultiANewArrayInsn(String desc, int dims) {
                            pw.print(""multianewarray "");
                            pw.print(desc);
                            pw.print(' ');
                            pw.println(dims);
                        }

                        @Override
                        public void visitLineNumber(int line, Label start) {
                            pw.print("".line "");
                            pw.println(line);
                        }
                    });
                }
                if (mn.localVariables != null) {
                    for (LocalVariableNode lv : mn.localVariables) {
                        pw.print(""  .var "");
                        pw.print(lv.index);
                        pw.print("" is '"");
                        pw.print(lv.name);
                        pw.print(""' "");
                        pw.print(lv.desc);
                        if (lv.signature != null) {
                            pw.print("" signature \"""");
                            pw.print(lv.signature);
                            pw.print(""\"""");
                        }
                        pw.print("" from "");
                        print(lv.start);
                        pw.print("" to "");
                        print(lv.end);
                        pw.println();
                    }
                }
                println(""  .limit locals "", Integer.toString(mn.maxLocals));
                println(""  .limit stack "", Integer.toString(mn.maxStack));
            }
            pw.println("".end method"");
        }
    }",iterator
j,"{
        labelNames.clear();
        pw.print("".bytecode "");
        pw.print(cn.version & 0xFFFF);
        pw.print('.');
        pw.println(cn.version >>> 16);
        println("".source "", cn.sourceFile);
        pw.print("".class"");
        pw.print(access_clz(cn.access));
        pw.print(' ');
        printIdAfterAccess(pw, cn.name);
        pw.println();
        if (cn.superName != null) {
            pw.print("".super "");
            printIdAfterAccess(pw, cn.superName);
            pw.println();
        }
        for (String itf : cn.interfaces) {
            pw.print("".implements "");
            printIdAfterAccess(pw, itf);
            pw.println();
        }
        if (cn.signature != null) {
            println("".signature "", '""' + cn.signature + '""');
        }
        if (cn.outerClass != null) {
            pw.print("".enclosing method "");
            pw.print(cn.outerClass);
            if (cn.outerMethod != null) {
                pw.print('/');
                pw.print(cn.outerMethod);
                pw.println(cn.outerMethodDesc);
            } else {
                pw.println();
            }
        }
        if ((cn.access & Opcodes.ACC_DEPRECATED) != 0) {
            pw.println("".deprecated"");
        }
        if (cn.visibleAnnotations != null) {
            for (AnnotationNode an : cn.visibleAnnotations) {
                printAnnotation(an, 1, -1);
            }
        }
        if (cn.invisibleAnnotations != null) {
            for (AnnotationNode an : cn.invisibleAnnotations) {
                printAnnotation(an, 2, -1);
            }
        }

        println("".debug "", cn.sourceDebug == null ? null : '""' + cn.sourceDebug + '""');

        for (InnerClassNode in : cn.innerClasses) {
            pw.print("".inner class"");
            pw.print(access_clz(in.access & (~Opcodes.ACC_SUPER)));
            if (in.innerName != null) {
                pw.print(' ');
                printIdAfterAccess(pw, in.innerName);
            }
            if (in.name != null) {
                pw.print("" inner "");
                pw.print(in.name);
            }
            if (in.outerName != null) {
                pw.print("" outer "");
                pw.print(in.outerName);
            }
            pw.println();
        }

        for (FieldNode fn : cn.fields) {
            boolean annotations = false;
            if (fn.visibleAnnotations != null && fn.visibleAnnotations.size() > 0) {
                annotations = true;
            }
            if (fn.invisibleAnnotations != null && fn.invisibleAnnotations.size() > 0) {
                annotations = true;
            }
            boolean deprecated = (fn.access & Opcodes.ACC_DEPRECATED) != 0;
            pw.print(""\n.field"");
            pw.print(access_fld(fn.access));
            pw.print(' ');
            printIdAfterAccess(pw,fn.name);
            pw.print(' ');
            pw.print(fn.desc);
            if (fn.value instanceof String) {
                StringBuffer buf = new StringBuffer();
                Printer.appendString(buf, (String) fn.value);
                pw.print("" = "");
                pw.print(buf.toString());
            } else if (fn.value != null) {
                pw.print("" = "");
                print(fn.value);
            }
            pw.println();
            if (fn.signature != null) {
                pw.print("".signature \"""");
                pw.print(fn.signature);
                pw.println(""\"""");
            }
            if (deprecated) {
                pw.println("".deprecated"");
            }
            if (fn.visibleAnnotations != null) {
                for (AnnotationNode an : fn.visibleAnnotations) {
                    printAnnotation(an, 1, -1);
                }
            }
            if (fn.invisibleAnnotations != null) {
                for (AnnotationNode an : fn.invisibleAnnotations) {
                    printAnnotation(an, 2, -1);
                }
            }
            if (fn.signature != null || deprecated || annotations) {
                pw.println("".end field"");
            }
        }

        for (MethodNode mn : cn.methods) {
            pw.print(""\n.method"");
            pw.print(access_mtd(mn.access));
            pw.print(' ');
            printIdAfterAccess(pw, mn.name);
            pw.println(mn.desc);
            if (mn.signature != null) {
                pw.print("".signature \"""");
                pw.print(mn.signature);
                pw.println(""\"""");
            }
            if (mn.annotationDefault != null) {
                pw.println("".annotation default"");
                printAnnotationValue(mn.annotationDefault);
                pw.println("".end annotation"");
            }
            if (mn.visibleAnnotations != null) {
                for (AnnotationNode an : mn.visibleAnnotations) {
                    printAnnotation(an, 1, -1);
                }
            }
            if (mn.invisibleAnnotations != null) {
                for (AnnotationNode an : mn.invisibleAnnotations) {
                    printAnnotation(an, 2, -1);
                }
            }
            if (mn.visibleParameterAnnotations != null) {
                for (int j = 0; j < mn.visibleParameterAnnotations.length; ++j) {
                    List<AnnotationNode> pas = mn.visibleParameterAnnotations[j];
                    if (pas != null) {
                        for (AnnotationNode an : pas) {
                            printAnnotation(an, 1, j + 1);
                        }
                    }
                }
            }
            if (mn.invisibleParameterAnnotations != null) {
                for (int j = 0; j < mn.invisibleParameterAnnotations.length; ++j) {
                    List<AnnotationNode> pas = mn.invisibleParameterAnnotations[j];
                    if (pas != null) {
                        for (AnnotationNode an : pas) {
                            printAnnotation(an, 2, j + 1);
                        }
                    }
                }
            }
            for (String ex : mn.exceptions) {
                println("".throws "", ex);
            }
            if ((mn.access & Opcodes.ACC_DEPRECATED) != 0) {
                pw.println("".deprecated"");
            }
            if (mn.instructions != null && mn.instructions.size() > 0) {
                labelNames.clear();
                if (mn.tryCatchBlocks != null) {
                    for (TryCatchBlockNode tcb : mn.tryCatchBlocks) {
                        pw.print("".catch "");
                        pw.print(tcb.type == null ? ""all"" : ""all"".equals(tcb.type) ? ""\\u0097ll"" : tcb.type);
                        pw.print("" from "");
                        print(tcb.start);
                        pw.print("" to "");
                        print(tcb.end);
                        pw.print("" using "");
                        print(tcb.handler);
                        pw.println();
                    }
                }
                for (int j = 0; j < mn.instructions.size(); ++j) {
                    AbstractInsnNode in = mn.instructions.get(j);
                    if (in.getType() != AbstractInsnNode.LINE && in.getType() != AbstractInsnNode.FRAME) {
                       if(in.getType()==AbstractInsnNode.LABEL){
                           pw.print(""  "");
                       }else {
                           pw.print(""    "");
                       }
                    }
                    in.accept(new MethodVisitor(ASM4) {

                        @Override
                        public void visitInsn(int opcode) {
                            print(opcode);
                            pw.println();
                        }

                        @Override
                        public void visitIntInsn(int opcode, int operand) {
                            print(opcode);
                            if (opcode == Opcodes.NEWARRAY) {
                                switch (operand) {
                                case Opcodes.T_BOOLEAN:
                                    pw.println("" boolean"");
                                    break;
                                case Opcodes.T_CHAR:
                                    pw.println("" char"");
                                    break;
                                case Opcodes.T_FLOAT:
                                    pw.println("" float"");
                                    break;
                                case Opcodes.T_DOUBLE:
                                    pw.println("" double"");
                                    break;
                                case Opcodes.T_BYTE:
                                    pw.println("" byte"");
                                    break;
                                case Opcodes.T_SHORT:
                                    pw.println("" short"");
                                    break;
                                case Opcodes.T_INT:
                                    pw.println("" int"");
                                    break;
                                case Opcodes.T_LONG:
                                default:
                                    pw.println("" long"");
                                    break;
                                }
                            } else {
                                pw.print(' ');
                                pw.println(operand);
                            }
                        }

                        @Override
                        public void visitVarInsn(int opcode, int var) {
                            print(opcode);
                            pw.print(' ');
                            pw.println(var);
                        }

                        @Override
                        public void visitTypeInsn(int opcode, String type) {
                            print(opcode);
                            pw.print(' ');
                            pw.println(type);
                        }

                        @Override
                        public void visitFieldInsn(int opcode, String owner, String name, String desc) {
                            print(opcode);
                            pw.print(' ');
                            pw.print(owner);
                            pw.print('/');
                            pw.print(name);
                            pw.print(' ');
                            pw.println(desc);
                        }

                        @Override
                        public void visitMethodInsn(int opcode, String owner, String name, String desc) {
                            print(opcode);
                            pw.print(' ');
                            pw.print(owner);
                            pw.print('/');
                            pw.print(name);
                            pw.print(desc);
                            if (opcode == Opcodes.INVOKEINTERFACE) {
                                pw.print(' ');
                                pw.print((Type.getArgumentsAndReturnSizes(desc) >> 2) - 1);
                            }
                            pw.println();
                        }

                        @Override
                        public void visitJumpInsn(int opcode, Label label) {
                            print(opcode);
                            pw.print(' ');
                            print(label);
                            pw.println();
                        }

                        @Override
                        public void visitLabel(Label label) {
                            print(label);
                            pw.println(':');
                        }

                        @Override
                        public void visitLdcInsn(Object cst) {

                            if (cst instanceof Integer || cst instanceof Float) {
                                pw.print(""ldc_w "");
                                print(cst);
                            } else if (cst instanceof Long || cst instanceof Double) {
                                pw.print(""ldc2_w "");
                                print(cst);
                            } else {
                                pw.print(""ldc "");
                                if (cst instanceof Type) {
                                    pw.print(((Type) cst).getInternalName());
                                } else {
                                    print(cst);
                                }
                            }
                            pw.println();

                        }

                        @Override
                        public void visitIincInsn(int var, int increment) {
                            pw.print(""iinc "");
                            pw.print(var);
                            pw.print(' ');
                            pw.println(increment);
                        }

                        @Override
                        public void visitTableSwitchInsn(int min, int max, Label dflt, Label... labels) {
                            pw.print(""tableswitch "");
                            pw.println(min);
                            for (Label label : labels) {
                                pw.print(""      "");
                                print(label);
                                pw.println();
                            }
                            pw.print(""      default : "");
                            print(dflt);
                            pw.println();
                        }

                        @Override
                        public void visitLookupSwitchInsn(Label dflt, int[] keys, Label[] labels) {
                            pw.println(""lookupswitch"");
                            for (int i = 0; i < keys.length; ++i) {
                                pw.print(""      "");
                                pw.print(keys[i]);
                                pw.print("" : "");
                                print(labels[i]);
                                pw.println();
                            }
                            pw.print(""      default : "");
                            print(dflt);
                            pw.println();
                        }

                        @Override
                        public void visitMultiANewArrayInsn(String desc, int dims) {
                            pw.print(""multianewarray "");
                            pw.print(desc);
                            pw.print(' ');
                            pw.println(dims);
                        }

                        @Override
                        public void visitLineNumber(int line, Label start) {
                            pw.print("".line "");
                            pw.println(line);
                        }
                    });
                }
                if (mn.localVariables != null) {
                    for (LocalVariableNode lv : mn.localVariables) {
                        pw.print(""  .var "");
                        pw.print(lv.index);
                        pw.print("" is '"");
                        pw.print(lv.name);
                        pw.print(""' "");
                        pw.print(lv.desc);
                        if (lv.signature != null) {
                            pw.print("" signature \"""");
                            pw.print(lv.signature);
                            pw.print(""\"""");
                        }
                        pw.print("" from "");
                        print(lv.start);
                        pw.print("" to "");
                        print(lv.end);
                        pw.println();
                    }
                }
                println(""  .limit locals "", Integer.toString(mn.maxLocals));
                println(""  .limit stack "", Integer.toString(mn.maxStack));
            }
            pw.println("".end method"");
        }
    }",loop_control
lv,"{
        labelNames.clear();
        pw.print("".bytecode "");
        pw.print(cn.version & 0xFFFF);
        pw.print('.');
        pw.println(cn.version >>> 16);
        println("".source "", cn.sourceFile);
        pw.print("".class"");
        pw.print(access_clz(cn.access));
        pw.print(' ');
        printIdAfterAccess(pw, cn.name);
        pw.println();
        if (cn.superName != null) {
            pw.print("".super "");
            printIdAfterAccess(pw, cn.superName);
            pw.println();
        }
        for (String itf : cn.interfaces) {
            pw.print("".implements "");
            printIdAfterAccess(pw, itf);
            pw.println();
        }
        if (cn.signature != null) {
            println("".signature "", '""' + cn.signature + '""');
        }
        if (cn.outerClass != null) {
            pw.print("".enclosing method "");
            pw.print(cn.outerClass);
            if (cn.outerMethod != null) {
                pw.print('/');
                pw.print(cn.outerMethod);
                pw.println(cn.outerMethodDesc);
            } else {
                pw.println();
            }
        }
        if ((cn.access & Opcodes.ACC_DEPRECATED) != 0) {
            pw.println("".deprecated"");
        }
        if (cn.visibleAnnotations != null) {
            for (AnnotationNode an : cn.visibleAnnotations) {
                printAnnotation(an, 1, -1);
            }
        }
        if (cn.invisibleAnnotations != null) {
            for (AnnotationNode an : cn.invisibleAnnotations) {
                printAnnotation(an, 2, -1);
            }
        }

        println("".debug "", cn.sourceDebug == null ? null : '""' + cn.sourceDebug + '""');

        for (InnerClassNode in : cn.innerClasses) {
            pw.print("".inner class"");
            pw.print(access_clz(in.access & (~Opcodes.ACC_SUPER)));
            if (in.innerName != null) {
                pw.print(' ');
                printIdAfterAccess(pw, in.innerName);
            }
            if (in.name != null) {
                pw.print("" inner "");
                pw.print(in.name);
            }
            if (in.outerName != null) {
                pw.print("" outer "");
                pw.print(in.outerName);
            }
            pw.println();
        }

        for (FieldNode fn : cn.fields) {
            boolean annotations = false;
            if (fn.visibleAnnotations != null && fn.visibleAnnotations.size() > 0) {
                annotations = true;
            }
            if (fn.invisibleAnnotations != null && fn.invisibleAnnotations.size() > 0) {
                annotations = true;
            }
            boolean deprecated = (fn.access & Opcodes.ACC_DEPRECATED) != 0;
            pw.print(""\n.field"");
            pw.print(access_fld(fn.access));
            pw.print(' ');
            printIdAfterAccess(pw,fn.name);
            pw.print(' ');
            pw.print(fn.desc);
            if (fn.value instanceof String) {
                StringBuffer buf = new StringBuffer();
                Printer.appendString(buf, (String) fn.value);
                pw.print("" = "");
                pw.print(buf.toString());
            } else if (fn.value != null) {
                pw.print("" = "");
                print(fn.value);
            }
            pw.println();
            if (fn.signature != null) {
                pw.print("".signature \"""");
                pw.print(fn.signature);
                pw.println(""\"""");
            }
            if (deprecated) {
                pw.println("".deprecated"");
            }
            if (fn.visibleAnnotations != null) {
                for (AnnotationNode an : fn.visibleAnnotations) {
                    printAnnotation(an, 1, -1);
                }
            }
            if (fn.invisibleAnnotations != null) {
                for (AnnotationNode an : fn.invisibleAnnotations) {
                    printAnnotation(an, 2, -1);
                }
            }
            if (fn.signature != null || deprecated || annotations) {
                pw.println("".end field"");
            }
        }

        for (MethodNode mn : cn.methods) {
            pw.print(""\n.method"");
            pw.print(access_mtd(mn.access));
            pw.print(' ');
            printIdAfterAccess(pw, mn.name);
            pw.println(mn.desc);
            if (mn.signature != null) {
                pw.print("".signature \"""");
                pw.print(mn.signature);
                pw.println(""\"""");
            }
            if (mn.annotationDefault != null) {
                pw.println("".annotation default"");
                printAnnotationValue(mn.annotationDefault);
                pw.println("".end annotation"");
            }
            if (mn.visibleAnnotations != null) {
                for (AnnotationNode an : mn.visibleAnnotations) {
                    printAnnotation(an, 1, -1);
                }
            }
            if (mn.invisibleAnnotations != null) {
                for (AnnotationNode an : mn.invisibleAnnotations) {
                    printAnnotation(an, 2, -1);
                }
            }
            if (mn.visibleParameterAnnotations != null) {
                for (int j = 0; j < mn.visibleParameterAnnotations.length; ++j) {
                    List<AnnotationNode> pas = mn.visibleParameterAnnotations[j];
                    if (pas != null) {
                        for (AnnotationNode an : pas) {
                            printAnnotation(an, 1, j + 1);
                        }
                    }
                }
            }
            if (mn.invisibleParameterAnnotations != null) {
                for (int j = 0; j < mn.invisibleParameterAnnotations.length; ++j) {
                    List<AnnotationNode> pas = mn.invisibleParameterAnnotations[j];
                    if (pas != null) {
                        for (AnnotationNode an : pas) {
                            printAnnotation(an, 2, j + 1);
                        }
                    }
                }
            }
            for (String ex : mn.exceptions) {
                println("".throws "", ex);
            }
            if ((mn.access & Opcodes.ACC_DEPRECATED) != 0) {
                pw.println("".deprecated"");
            }
            if (mn.instructions != null && mn.instructions.size() > 0) {
                labelNames.clear();
                if (mn.tryCatchBlocks != null) {
                    for (TryCatchBlockNode tcb : mn.tryCatchBlocks) {
                        pw.print("".catch "");
                        pw.print(tcb.type == null ? ""all"" : ""all"".equals(tcb.type) ? ""\\u0097ll"" : tcb.type);
                        pw.print("" from "");
                        print(tcb.start);
                        pw.print("" to "");
                        print(tcb.end);
                        pw.print("" using "");
                        print(tcb.handler);
                        pw.println();
                    }
                }
                for (int j = 0; j < mn.instructions.size(); ++j) {
                    AbstractInsnNode in = mn.instructions.get(j);
                    if (in.getType() != AbstractInsnNode.LINE && in.getType() != AbstractInsnNode.FRAME) {
                       if(in.getType()==AbstractInsnNode.LABEL){
                           pw.print(""  "");
                       }else {
                           pw.print(""    "");
                       }
                    }
                    in.accept(new MethodVisitor(ASM4) {

                        @Override
                        public void visitInsn(int opcode) {
                            print(opcode);
                            pw.println();
                        }

                        @Override
                        public void visitIntInsn(int opcode, int operand) {
                            print(opcode);
                            if (opcode == Opcodes.NEWARRAY) {
                                switch (operand) {
                                case Opcodes.T_BOOLEAN:
                                    pw.println("" boolean"");
                                    break;
                                case Opcodes.T_CHAR:
                                    pw.println("" char"");
                                    break;
                                case Opcodes.T_FLOAT:
                                    pw.println("" float"");
                                    break;
                                case Opcodes.T_DOUBLE:
                                    pw.println("" double"");
                                    break;
                                case Opcodes.T_BYTE:
                                    pw.println("" byte"");
                                    break;
                                case Opcodes.T_SHORT:
                                    pw.println("" short"");
                                    break;
                                case Opcodes.T_INT:
                                    pw.println("" int"");
                                    break;
                                case Opcodes.T_LONG:
                                default:
                                    pw.println("" long"");
                                    break;
                                }
                            } else {
                                pw.print(' ');
                                pw.println(operand);
                            }
                        }

                        @Override
                        public void visitVarInsn(int opcode, int var) {
                            print(opcode);
                            pw.print(' ');
                            pw.println(var);
                        }

                        @Override
                        public void visitTypeInsn(int opcode, String type) {
                            print(opcode);
                            pw.print(' ');
                            pw.println(type);
                        }

                        @Override
                        public void visitFieldInsn(int opcode, String owner, String name, String desc) {
                            print(opcode);
                            pw.print(' ');
                            pw.print(owner);
                            pw.print('/');
                            pw.print(name);
                            pw.print(' ');
                            pw.println(desc);
                        }

                        @Override
                        public void visitMethodInsn(int opcode, String owner, String name, String desc) {
                            print(opcode);
                            pw.print(' ');
                            pw.print(owner);
                            pw.print('/');
                            pw.print(name);
                            pw.print(desc);
                            if (opcode == Opcodes.INVOKEINTERFACE) {
                                pw.print(' ');
                                pw.print((Type.getArgumentsAndReturnSizes(desc) >> 2) - 1);
                            }
                            pw.println();
                        }

                        @Override
                        public void visitJumpInsn(int opcode, Label label) {
                            print(opcode);
                            pw.print(' ');
                            print(label);
                            pw.println();
                        }

                        @Override
                        public void visitLabel(Label label) {
                            print(label);
                            pw.println(':');
                        }

                        @Override
                        public void visitLdcInsn(Object cst) {

                            if (cst instanceof Integer || cst instanceof Float) {
                                pw.print(""ldc_w "");
                                print(cst);
                            } else if (cst instanceof Long || cst instanceof Double) {
                                pw.print(""ldc2_w "");
                                print(cst);
                            } else {
                                pw.print(""ldc "");
                                if (cst instanceof Type) {
                                    pw.print(((Type) cst).getInternalName());
                                } else {
                                    print(cst);
                                }
                            }
                            pw.println();

                        }

                        @Override
                        public void visitIincInsn(int var, int increment) {
                            pw.print(""iinc "");
                            pw.print(var);
                            pw.print(' ');
                            pw.println(increment);
                        }

                        @Override
                        public void visitTableSwitchInsn(int min, int max, Label dflt, Label... labels) {
                            pw.print(""tableswitch "");
                            pw.println(min);
                            for (Label label : labels) {
                                pw.print(""      "");
                                print(label);
                                pw.println();
                            }
                            pw.print(""      default : "");
                            print(dflt);
                            pw.println();
                        }

                        @Override
                        public void visitLookupSwitchInsn(Label dflt, int[] keys, Label[] labels) {
                            pw.println(""lookupswitch"");
                            for (int i = 0; i < keys.length; ++i) {
                                pw.print(""      "");
                                pw.print(keys[i]);
                                pw.print("" : "");
                                print(labels[i]);
                                pw.println();
                            }
                            pw.print(""      default : "");
                            print(dflt);
                            pw.println();
                        }

                        @Override
                        public void visitMultiANewArrayInsn(String desc, int dims) {
                            pw.print(""multianewarray "");
                            pw.print(desc);
                            pw.print(' ');
                            pw.println(dims);
                        }

                        @Override
                        public void visitLineNumber(int line, Label start) {
                            pw.print("".line "");
                            pw.println(line);
                        }
                    });
                }
                if (mn.localVariables != null) {
                    for (LocalVariableNode lv : mn.localVariables) {
                        pw.print(""  .var "");
                        pw.print(lv.index);
                        pw.print("" is '"");
                        pw.print(lv.name);
                        pw.print(""' "");
                        pw.print(lv.desc);
                        if (lv.signature != null) {
                            pw.print("" signature \"""");
                            pw.print(lv.signature);
                            pw.print(""\"""");
                        }
                        pw.print("" from "");
                        print(lv.start);
                        pw.print("" to "");
                        print(lv.end);
                        pw.println();
                    }
                }
                println(""  .limit locals "", Integer.toString(mn.maxLocals));
                println(""  .limit stack "", Integer.toString(mn.maxStack));
            }
            pw.println("".end method"");
        }
    }",iterator
tcb,"{
        labelNames.clear();
        pw.print("".bytecode "");
        pw.print(cn.version & 0xFFFF);
        pw.print('.');
        pw.println(cn.version >>> 16);
        println("".source "", cn.sourceFile);
        pw.print("".class"");
        pw.print(access_clz(cn.access));
        pw.print(' ');
        printIdAfterAccess(pw, cn.name);
        pw.println();
        if (cn.superName != null) {
            pw.print("".super "");
            printIdAfterAccess(pw, cn.superName);
            pw.println();
        }
        for (String itf : cn.interfaces) {
            pw.print("".implements "");
            printIdAfterAccess(pw, itf);
            pw.println();
        }
        if (cn.signature != null) {
            println("".signature "", '""' + cn.signature + '""');
        }
        if (cn.outerClass != null) {
            pw.print("".enclosing method "");
            pw.print(cn.outerClass);
            if (cn.outerMethod != null) {
                pw.print('/');
                pw.print(cn.outerMethod);
                pw.println(cn.outerMethodDesc);
            } else {
                pw.println();
            }
        }
        if ((cn.access & Opcodes.ACC_DEPRECATED) != 0) {
            pw.println("".deprecated"");
        }
        if (cn.visibleAnnotations != null) {
            for (AnnotationNode an : cn.visibleAnnotations) {
                printAnnotation(an, 1, -1);
            }
        }
        if (cn.invisibleAnnotations != null) {
            for (AnnotationNode an : cn.invisibleAnnotations) {
                printAnnotation(an, 2, -1);
            }
        }

        println("".debug "", cn.sourceDebug == null ? null : '""' + cn.sourceDebug + '""');

        for (InnerClassNode in : cn.innerClasses) {
            pw.print("".inner class"");
            pw.print(access_clz(in.access & (~Opcodes.ACC_SUPER)));
            if (in.innerName != null) {
                pw.print(' ');
                printIdAfterAccess(pw, in.innerName);
            }
            if (in.name != null) {
                pw.print("" inner "");
                pw.print(in.name);
            }
            if (in.outerName != null) {
                pw.print("" outer "");
                pw.print(in.outerName);
            }
            pw.println();
        }

        for (FieldNode fn : cn.fields) {
            boolean annotations = false;
            if (fn.visibleAnnotations != null && fn.visibleAnnotations.size() > 0) {
                annotations = true;
            }
            if (fn.invisibleAnnotations != null && fn.invisibleAnnotations.size() > 0) {
                annotations = true;
            }
            boolean deprecated = (fn.access & Opcodes.ACC_DEPRECATED) != 0;
            pw.print(""\n.field"");
            pw.print(access_fld(fn.access));
            pw.print(' ');
            printIdAfterAccess(pw,fn.name);
            pw.print(' ');
            pw.print(fn.desc);
            if (fn.value instanceof String) {
                StringBuffer buf = new StringBuffer();
                Printer.appendString(buf, (String) fn.value);
                pw.print("" = "");
                pw.print(buf.toString());
            } else if (fn.value != null) {
                pw.print("" = "");
                print(fn.value);
            }
            pw.println();
            if (fn.signature != null) {
                pw.print("".signature \"""");
                pw.print(fn.signature);
                pw.println(""\"""");
            }
            if (deprecated) {
                pw.println("".deprecated"");
            }
            if (fn.visibleAnnotations != null) {
                for (AnnotationNode an : fn.visibleAnnotations) {
                    printAnnotation(an, 1, -1);
                }
            }
            if (fn.invisibleAnnotations != null) {
                for (AnnotationNode an : fn.invisibleAnnotations) {
                    printAnnotation(an, 2, -1);
                }
            }
            if (fn.signature != null || deprecated || annotations) {
                pw.println("".end field"");
            }
        }

        for (MethodNode mn : cn.methods) {
            pw.print(""\n.method"");
            pw.print(access_mtd(mn.access));
            pw.print(' ');
            printIdAfterAccess(pw, mn.name);
            pw.println(mn.desc);
            if (mn.signature != null) {
                pw.print("".signature \"""");
                pw.print(mn.signature);
                pw.println(""\"""");
            }
            if (mn.annotationDefault != null) {
                pw.println("".annotation default"");
                printAnnotationValue(mn.annotationDefault);
                pw.println("".end annotation"");
            }
            if (mn.visibleAnnotations != null) {
                for (AnnotationNode an : mn.visibleAnnotations) {
                    printAnnotation(an, 1, -1);
                }
            }
            if (mn.invisibleAnnotations != null) {
                for (AnnotationNode an : mn.invisibleAnnotations) {
                    printAnnotation(an, 2, -1);
                }
            }
            if (mn.visibleParameterAnnotations != null) {
                for (int j = 0; j < mn.visibleParameterAnnotations.length; ++j) {
                    List<AnnotationNode> pas = mn.visibleParameterAnnotations[j];
                    if (pas != null) {
                        for (AnnotationNode an : pas) {
                            printAnnotation(an, 1, j + 1);
                        }
                    }
                }
            }
            if (mn.invisibleParameterAnnotations != null) {
                for (int j = 0; j < mn.invisibleParameterAnnotations.length; ++j) {
                    List<AnnotationNode> pas = mn.invisibleParameterAnnotations[j];
                    if (pas != null) {
                        for (AnnotationNode an : pas) {
                            printAnnotation(an, 2, j + 1);
                        }
                    }
                }
            }
            for (String ex : mn.exceptions) {
                println("".throws "", ex);
            }
            if ((mn.access & Opcodes.ACC_DEPRECATED) != 0) {
                pw.println("".deprecated"");
            }
            if (mn.instructions != null && mn.instructions.size() > 0) {
                labelNames.clear();
                if (mn.tryCatchBlocks != null) {
                    for (TryCatchBlockNode tcb : mn.tryCatchBlocks) {
                        pw.print("".catch "");
                        pw.print(tcb.type == null ? ""all"" : ""all"".equals(tcb.type) ? ""\\u0097ll"" : tcb.type);
                        pw.print("" from "");
                        print(tcb.start);
                        pw.print("" to "");
                        print(tcb.end);
                        pw.print("" using "");
                        print(tcb.handler);
                        pw.println();
                    }
                }
                for (int j = 0; j < mn.instructions.size(); ++j) {
                    AbstractInsnNode in = mn.instructions.get(j);
                    if (in.getType() != AbstractInsnNode.LINE && in.getType() != AbstractInsnNode.FRAME) {
                       if(in.getType()==AbstractInsnNode.LABEL){
                           pw.print(""  "");
                       }else {
                           pw.print(""    "");
                       }
                    }
                    in.accept(new MethodVisitor(ASM4) {

                        @Override
                        public void visitInsn(int opcode) {
                            print(opcode);
                            pw.println();
                        }

                        @Override
                        public void visitIntInsn(int opcode, int operand) {
                            print(opcode);
                            if (opcode == Opcodes.NEWARRAY) {
                                switch (operand) {
                                case Opcodes.T_BOOLEAN:
                                    pw.println("" boolean"");
                                    break;
                                case Opcodes.T_CHAR:
                                    pw.println("" char"");
                                    break;
                                case Opcodes.T_FLOAT:
                                    pw.println("" float"");
                                    break;
                                case Opcodes.T_DOUBLE:
                                    pw.println("" double"");
                                    break;
                                case Opcodes.T_BYTE:
                                    pw.println("" byte"");
                                    break;
                                case Opcodes.T_SHORT:
                                    pw.println("" short"");
                                    break;
                                case Opcodes.T_INT:
                                    pw.println("" int"");
                                    break;
                                case Opcodes.T_LONG:
                                default:
                                    pw.println("" long"");
                                    break;
                                }
                            } else {
                                pw.print(' ');
                                pw.println(operand);
                            }
                        }

                        @Override
                        public void visitVarInsn(int opcode, int var) {
                            print(opcode);
                            pw.print(' ');
                            pw.println(var);
                        }

                        @Override
                        public void visitTypeInsn(int opcode, String type) {
                            print(opcode);
                            pw.print(' ');
                            pw.println(type);
                        }

                        @Override
                        public void visitFieldInsn(int opcode, String owner, String name, String desc) {
                            print(opcode);
                            pw.print(' ');
                            pw.print(owner);
                            pw.print('/');
                            pw.print(name);
                            pw.print(' ');
                            pw.println(desc);
                        }

                        @Override
                        public void visitMethodInsn(int opcode, String owner, String name, String desc) {
                            print(opcode);
                            pw.print(' ');
                            pw.print(owner);
                            pw.print('/');
                            pw.print(name);
                            pw.print(desc);
                            if (opcode == Opcodes.INVOKEINTERFACE) {
                                pw.print(' ');
                                pw.print((Type.getArgumentsAndReturnSizes(desc) >> 2) - 1);
                            }
                            pw.println();
                        }

                        @Override
                        public void visitJumpInsn(int opcode, Label label) {
                            print(opcode);
                            pw.print(' ');
                            print(label);
                            pw.println();
                        }

                        @Override
                        public void visitLabel(Label label) {
                            print(label);
                            pw.println(':');
                        }

                        @Override
                        public void visitLdcInsn(Object cst) {

                            if (cst instanceof Integer || cst instanceof Float) {
                                pw.print(""ldc_w "");
                                print(cst);
                            } else if (cst instanceof Long || cst instanceof Double) {
                                pw.print(""ldc2_w "");
                                print(cst);
                            } else {
                                pw.print(""ldc "");
                                if (cst instanceof Type) {
                                    pw.print(((Type) cst).getInternalName());
                                } else {
                                    print(cst);
                                }
                            }
                            pw.println();

                        }

                        @Override
                        public void visitIincInsn(int var, int increment) {
                            pw.print(""iinc "");
                            pw.print(var);
                            pw.print(' ');
                            pw.println(increment);
                        }

                        @Override
                        public void visitTableSwitchInsn(int min, int max, Label dflt, Label... labels) {
                            pw.print(""tableswitch "");
                            pw.println(min);
                            for (Label label : labels) {
                                pw.print(""      "");
                                print(label);
                                pw.println();
                            }
                            pw.print(""      default : "");
                            print(dflt);
                            pw.println();
                        }

                        @Override
                        public void visitLookupSwitchInsn(Label dflt, int[] keys, Label[] labels) {
                            pw.println(""lookupswitch"");
                            for (int i = 0; i < keys.length; ++i) {
                                pw.print(""      "");
                                pw.print(keys[i]);
                                pw.print("" : "");
                                print(labels[i]);
                                pw.println();
                            }
                            pw.print(""      default : "");
                            print(dflt);
                            pw.println();
                        }

                        @Override
                        public void visitMultiANewArrayInsn(String desc, int dims) {
                            pw.print(""multianewarray "");
                            pw.print(desc);
                            pw.print(' ');
                            pw.println(dims);
                        }

                        @Override
                        public void visitLineNumber(int line, Label start) {
                            pw.print("".line "");
                            pw.println(line);
                        }
                    });
                }
                if (mn.localVariables != null) {
                    for (LocalVariableNode lv : mn.localVariables) {
                        pw.print(""  .var "");
                        pw.print(lv.index);
                        pw.print("" is '"");
                        pw.print(lv.name);
                        pw.print(""' "");
                        pw.print(lv.desc);
                        if (lv.signature != null) {
                            pw.print("" signature \"""");
                            pw.print(lv.signature);
                            pw.print(""\"""");
                        }
                        pw.print("" from "");
                        print(lv.start);
                        pw.print("" to "");
                        print(lv.end);
                        pw.println();
                    }
                }
                println(""  .limit locals "", Integer.toString(mn.maxLocals));
                println(""  .limit stack "", Integer.toString(mn.maxStack));
            }
            pw.println("".end method"");
        }
    }",iterator
ex,"{
        labelNames.clear();
        pw.print("".bytecode "");
        pw.print(cn.version & 0xFFFF);
        pw.print('.');
        pw.println(cn.version >>> 16);
        println("".source "", cn.sourceFile);
        pw.print("".class"");
        pw.print(access_clz(cn.access));
        pw.print(' ');
        printIdAfterAccess(pw, cn.name);
        pw.println();
        if (cn.superName != null) {
            pw.print("".super "");
            printIdAfterAccess(pw, cn.superName);
            pw.println();
        }
        for (String itf : cn.interfaces) {
            pw.print("".implements "");
            printIdAfterAccess(pw, itf);
            pw.println();
        }
        if (cn.signature != null) {
            println("".signature "", '""' + cn.signature + '""');
        }
        if (cn.outerClass != null) {
            pw.print("".enclosing method "");
            pw.print(cn.outerClass);
            if (cn.outerMethod != null) {
                pw.print('/');
                pw.print(cn.outerMethod);
                pw.println(cn.outerMethodDesc);
            } else {
                pw.println();
            }
        }
        if ((cn.access & Opcodes.ACC_DEPRECATED) != 0) {
            pw.println("".deprecated"");
        }
        if (cn.visibleAnnotations != null) {
            for (AnnotationNode an : cn.visibleAnnotations) {
                printAnnotation(an, 1, -1);
            }
        }
        if (cn.invisibleAnnotations != null) {
            for (AnnotationNode an : cn.invisibleAnnotations) {
                printAnnotation(an, 2, -1);
            }
        }

        println("".debug "", cn.sourceDebug == null ? null : '""' + cn.sourceDebug + '""');

        for (InnerClassNode in : cn.innerClasses) {
            pw.print("".inner class"");
            pw.print(access_clz(in.access & (~Opcodes.ACC_SUPER)));
            if (in.innerName != null) {
                pw.print(' ');
                printIdAfterAccess(pw, in.innerName);
            }
            if (in.name != null) {
                pw.print("" inner "");
                pw.print(in.name);
            }
            if (in.outerName != null) {
                pw.print("" outer "");
                pw.print(in.outerName);
            }
            pw.println();
        }

        for (FieldNode fn : cn.fields) {
            boolean annotations = false;
            if (fn.visibleAnnotations != null && fn.visibleAnnotations.size() > 0) {
                annotations = true;
            }
            if (fn.invisibleAnnotations != null && fn.invisibleAnnotations.size() > 0) {
                annotations = true;
            }
            boolean deprecated = (fn.access & Opcodes.ACC_DEPRECATED) != 0;
            pw.print(""\n.field"");
            pw.print(access_fld(fn.access));
            pw.print(' ');
            printIdAfterAccess(pw,fn.name);
            pw.print(' ');
            pw.print(fn.desc);
            if (fn.value instanceof String) {
                StringBuffer buf = new StringBuffer();
                Printer.appendString(buf, (String) fn.value);
                pw.print("" = "");
                pw.print(buf.toString());
            } else if (fn.value != null) {
                pw.print("" = "");
                print(fn.value);
            }
            pw.println();
            if (fn.signature != null) {
                pw.print("".signature \"""");
                pw.print(fn.signature);
                pw.println(""\"""");
            }
            if (deprecated) {
                pw.println("".deprecated"");
            }
            if (fn.visibleAnnotations != null) {
                for (AnnotationNode an : fn.visibleAnnotations) {
                    printAnnotation(an, 1, -1);
                }
            }
            if (fn.invisibleAnnotations != null) {
                for (AnnotationNode an : fn.invisibleAnnotations) {
                    printAnnotation(an, 2, -1);
                }
            }
            if (fn.signature != null || deprecated || annotations) {
                pw.println("".end field"");
            }
        }

        for (MethodNode mn : cn.methods) {
            pw.print(""\n.method"");
            pw.print(access_mtd(mn.access));
            pw.print(' ');
            printIdAfterAccess(pw, mn.name);
            pw.println(mn.desc);
            if (mn.signature != null) {
                pw.print("".signature \"""");
                pw.print(mn.signature);
                pw.println(""\"""");
            }
            if (mn.annotationDefault != null) {
                pw.println("".annotation default"");
                printAnnotationValue(mn.annotationDefault);
                pw.println("".end annotation"");
            }
            if (mn.visibleAnnotations != null) {
                for (AnnotationNode an : mn.visibleAnnotations) {
                    printAnnotation(an, 1, -1);
                }
            }
            if (mn.invisibleAnnotations != null) {
                for (AnnotationNode an : mn.invisibleAnnotations) {
                    printAnnotation(an, 2, -1);
                }
            }
            if (mn.visibleParameterAnnotations != null) {
                for (int j = 0; j < mn.visibleParameterAnnotations.length; ++j) {
                    List<AnnotationNode> pas = mn.visibleParameterAnnotations[j];
                    if (pas != null) {
                        for (AnnotationNode an : pas) {
                            printAnnotation(an, 1, j + 1);
                        }
                    }
                }
            }
            if (mn.invisibleParameterAnnotations != null) {
                for (int j = 0; j < mn.invisibleParameterAnnotations.length; ++j) {
                    List<AnnotationNode> pas = mn.invisibleParameterAnnotations[j];
                    if (pas != null) {
                        for (AnnotationNode an : pas) {
                            printAnnotation(an, 2, j + 1);
                        }
                    }
                }
            }
            for (String ex : mn.exceptions) {
                println("".throws "", ex);
            }
            if ((mn.access & Opcodes.ACC_DEPRECATED) != 0) {
                pw.println("".deprecated"");
            }
            if (mn.instructions != null && mn.instructions.size() > 0) {
                labelNames.clear();
                if (mn.tryCatchBlocks != null) {
                    for (TryCatchBlockNode tcb : mn.tryCatchBlocks) {
                        pw.print("".catch "");
                        pw.print(tcb.type == null ? ""all"" : ""all"".equals(tcb.type) ? ""\\u0097ll"" : tcb.type);
                        pw.print("" from "");
                        print(tcb.start);
                        pw.print("" to "");
                        print(tcb.end);
                        pw.print("" using "");
                        print(tcb.handler);
                        pw.println();
                    }
                }
                for (int j = 0; j < mn.instructions.size(); ++j) {
                    AbstractInsnNode in = mn.instructions.get(j);
                    if (in.getType() != AbstractInsnNode.LINE && in.getType() != AbstractInsnNode.FRAME) {
                       if(in.getType()==AbstractInsnNode.LABEL){
                           pw.print(""  "");
                       }else {
                           pw.print(""    "");
                       }
                    }
                    in.accept(new MethodVisitor(ASM4) {

                        @Override
                        public void visitInsn(int opcode) {
                            print(opcode);
                            pw.println();
                        }

                        @Override
                        public void visitIntInsn(int opcode, int operand) {
                            print(opcode);
                            if (opcode == Opcodes.NEWARRAY) {
                                switch (operand) {
                                case Opcodes.T_BOOLEAN:
                                    pw.println("" boolean"");
                                    break;
                                case Opcodes.T_CHAR:
                                    pw.println("" char"");
                                    break;
                                case Opcodes.T_FLOAT:
                                    pw.println("" float"");
                                    break;
                                case Opcodes.T_DOUBLE:
                                    pw.println("" double"");
                                    break;
                                case Opcodes.T_BYTE:
                                    pw.println("" byte"");
                                    break;
                                case Opcodes.T_SHORT:
                                    pw.println("" short"");
                                    break;
                                case Opcodes.T_INT:
                                    pw.println("" int"");
                                    break;
                                case Opcodes.T_LONG:
                                default:
                                    pw.println("" long"");
                                    break;
                                }
                            } else {
                                pw.print(' ');
                                pw.println(operand);
                            }
                        }

                        @Override
                        public void visitVarInsn(int opcode, int var) {
                            print(opcode);
                            pw.print(' ');
                            pw.println(var);
                        }

                        @Override
                        public void visitTypeInsn(int opcode, String type) {
                            print(opcode);
                            pw.print(' ');
                            pw.println(type);
                        }

                        @Override
                        public void visitFieldInsn(int opcode, String owner, String name, String desc) {
                            print(opcode);
                            pw.print(' ');
                            pw.print(owner);
                            pw.print('/');
                            pw.print(name);
                            pw.print(' ');
                            pw.println(desc);
                        }

                        @Override
                        public void visitMethodInsn(int opcode, String owner, String name, String desc) {
                            print(opcode);
                            pw.print(' ');
                            pw.print(owner);
                            pw.print('/');
                            pw.print(name);
                            pw.print(desc);
                            if (opcode == Opcodes.INVOKEINTERFACE) {
                                pw.print(' ');
                                pw.print((Type.getArgumentsAndReturnSizes(desc) >> 2) - 1);
                            }
                            pw.println();
                        }

                        @Override
                        public void visitJumpInsn(int opcode, Label label) {
                            print(opcode);
                            pw.print(' ');
                            print(label);
                            pw.println();
                        }

                        @Override
                        public void visitLabel(Label label) {
                            print(label);
                            pw.println(':');
                        }

                        @Override
                        public void visitLdcInsn(Object cst) {

                            if (cst instanceof Integer || cst instanceof Float) {
                                pw.print(""ldc_w "");
                                print(cst);
                            } else if (cst instanceof Long || cst instanceof Double) {
                                pw.print(""ldc2_w "");
                                print(cst);
                            } else {
                                pw.print(""ldc "");
                                if (cst instanceof Type) {
                                    pw.print(((Type) cst).getInternalName());
                                } else {
                                    print(cst);
                                }
                            }
                            pw.println();

                        }

                        @Override
                        public void visitIincInsn(int var, int increment) {
                            pw.print(""iinc "");
                            pw.print(var);
                            pw.print(' ');
                            pw.println(increment);
                        }

                        @Override
                        public void visitTableSwitchInsn(int min, int max, Label dflt, Label... labels) {
                            pw.print(""tableswitch "");
                            pw.println(min);
                            for (Label label : labels) {
                                pw.print(""      "");
                                print(label);
                                pw.println();
                            }
                            pw.print(""      default : "");
                            print(dflt);
                            pw.println();
                        }

                        @Override
                        public void visitLookupSwitchInsn(Label dflt, int[] keys, Label[] labels) {
                            pw.println(""lookupswitch"");
                            for (int i = 0; i < keys.length; ++i) {
                                pw.print(""      "");
                                pw.print(keys[i]);
                                pw.print("" : "");
                                print(labels[i]);
                                pw.println();
                            }
                            pw.print(""      default : "");
                            print(dflt);
                            pw.println();
                        }

                        @Override
                        public void visitMultiANewArrayInsn(String desc, int dims) {
                            pw.print(""multianewarray "");
                            pw.print(desc);
                            pw.print(' ');
                            pw.println(dims);
                        }

                        @Override
                        public void visitLineNumber(int line, Label start) {
                            pw.print("".line "");
                            pw.println(line);
                        }
                    });
                }
                if (mn.localVariables != null) {
                    for (LocalVariableNode lv : mn.localVariables) {
                        pw.print(""  .var "");
                        pw.print(lv.index);
                        pw.print("" is '"");
                        pw.print(lv.name);
                        pw.print(""' "");
                        pw.print(lv.desc);
                        if (lv.signature != null) {
                            pw.print("" signature \"""");
                            pw.print(lv.signature);
                            pw.print(""\"""");
                        }
                        pw.print("" from "");
                        print(lv.start);
                        pw.print("" to "");
                        print(lv.end);
                        pw.println();
                    }
                }
                println(""  .limit locals "", Integer.toString(mn.maxLocals));
                println(""  .limit stack "", Integer.toString(mn.maxStack));
            }
            pw.println("".end method"");
        }
    }",iterator
i,"{
        pw.print("".annotation "");
        if (visible > 0) {
            if (param == -1) {
                pw.print(visible == 1 ? ""visible "" : ""invisible "");
            } else {
                pw.print(visible == 1 ? ""visibleparam "" : ""invisibleparam "");
                pw.print(param);
                pw.print(' ');
            }
            pw.print(n.desc);
        }
        pw.println();
        if (n.values != null) {
            for (int i = 0; i < n.values.size(); i += 2) {
                pw.print(n.values.get(i));
                pw.print(' ');
                printAnnotationValue(n.values.get(i + 1));
            }
        }
        pw.println("".end annotation"");
    }",loop_control
element,"{
        if (value instanceof String[]) {
            pw.print(""e "");
            pw.print(((String[]) value)[0]);
            pw.print("" = "");
            pw.print(((String[]) value)[1]);
            pw.println();
        } else if (value instanceof AnnotationNode) {
            pw.print(""@ "");
            pw.print(((AnnotationNode) value).desc);
            pw.print("" = "");
            printAnnotation((AnnotationNode) value, 0, -1);
        } else if (value instanceof byte[]) {
            pw.print(""[B = "");
            byte[] v = (byte[]) value;
            for (byte element : v) {
                pw.print(element);
                pw.print(' ');
            }
            pw.println();
        } else if (value instanceof boolean[]) {
            pw.print(""[Z = "");
            boolean[] v = (boolean[]) value;
            for (boolean element : v) {
                pw.print(element ? '1' : '0');
                pw.print(' ');
            }
            pw.println();
        } else if (value instanceof short[]) {
            pw.print(""[S = "");
            short[] v = (short[]) value;
            for (short element : v) {
                pw.print(element);
                pw.print(' ');
            }
            pw.println();
        } else if (value instanceof char[]) {
            pw.print(""[C = "");
            char[] v = (char[]) value;
            for (char element : v) {
                pw.print(new Integer(element));
                pw.print(' ');
            }
            pw.println();
        } else if (value instanceof int[]) {
            pw.print(""[I = "");
            int[] v = (int[]) value;
            for (int element : v) {
                pw.print(element);
                pw.print(' ');
            }
            pw.println();
        } else if (value instanceof long[]) {
            pw.print(""[J = "");
            long[] v = (long[]) value;
            for (long element : v) {
                pw.print(element);
                pw.print(' ');
            }
            pw.println();
        } else if (value instanceof float[]) {
            pw.print(""[F = "");
            float[] v = (float[]) value;
            for (float element : v) {
                print(new Float(element));
                pw.print(' ');
            }
            pw.println();
        } else if (value instanceof double[]) {
            pw.print(""[D = "");
            double[] v = (double[]) value;
            for (double element : v) {
                print(new Double(element));
                pw.print(' ');
            }
            pw.println();
        } else if (value instanceof List) {
            List l = (List) value;
            if (l.size() > 0) {
                Object o = l.get(0);
                if (o instanceof String[]) {
                    pw.print(""[e "");
                    pw.print(((String[]) o)[0]);
                    pw.print("" = "");
                } else if (o instanceof AnnotationNode) {
                    pw.print(""[& "");
                    pw.print(((AnnotationNode) o).desc);
                    pw.print("" = "");
                    pw.print(""[@ = "");
                } else if (o instanceof String) {
                    pw.print(""[s = "");
                } else if (o instanceof Byte) {
                    pw.print(""[B = "");
                } else if (o instanceof Boolean) {
                    pw.print(""[Z = "");
                } else if (o instanceof Character) {
                    pw.print(""[C = "");
                } else if (o instanceof Short) {
                    pw.print(""[S = "");
                } else if (o instanceof Type) {
                    pw.print(""[c = "");
                } else if (o instanceof Integer) {
                    pw.print(""[I = "");
                } else if (o instanceof Float) {
                    pw.print(""[F = "");
                } else if (o instanceof Long) {
                    pw.print(""[J = "");
                } else if (o instanceof Double) {
                    pw.print(""[D = "");
                }
                for (Object aL : l) {
                    printAnnotationArrayValue(aL);
                    pw.print(' ');
                }
            } else {
                pw.print(""; empty array annotation value"");
            }
            pw.println();
        } else if (value instanceof String) {
            pw.print(""s = "");
            print(value);
            pw.println();
        } else if (value instanceof Byte) {
            pw.print(""B = "");
            pw.println(((Byte) value).intValue());
        } else if (value instanceof Boolean) {
            pw.print(""Z = "");
            pw.println(((Boolean) value).booleanValue() ? 1 : 0);
        } else if (value instanceof Character) {
            pw.print(""C = "");
            pw.println(new Integer(((Character) value).charValue()));
        } else if (value instanceof Short) {
            pw.print(""S = "");
            pw.println(((Short) value).intValue());
        } else if (value instanceof Type) {
            pw.print(""c = "");
            pw.println(((Type) value).getDescriptor());
        } else if (value instanceof Integer) {
            pw.print(""I = "");
            print(value);
            pw.println();
        } else if (value instanceof Float) {
            pw.print(""F = "");
            print(value);
            pw.println();
        } else if (value instanceof Long) {
            pw.print(""J = "");
            print(value);
            pw.println();
        } else if (value instanceof Double) {
            pw.print(""D = "");
            print(value);
            pw.println();
        } else {
            throw new RuntimeException();
        }
    }",iterator
p,"{
        Map<String, Object> env = new HashMap<>();
        env.put(""create"", ""true"");
        Files.deleteIfExists(output);

        createParentDirectories(output);

        for (FileSystemProvider p : FileSystemProvider.installedProviders()) {
            String s = p.getScheme();
            if (""jar"".equals(s) || ""zip"".equalsIgnoreCase(s)) {
                return p.newFileSystem(output, env);
            }
        }
        throw new IOException(""cant find zipfs support"");
    }",iterator
s,"{
        Map<String, Object> env = new HashMap<>();
        env.put(""create"", ""true"");
        Files.deleteIfExists(output);

        createParentDirectories(output);

        for (FileSystemProvider p : FileSystemProvider.installedProviders()) {
            String s = p.getScheme();
            if (""jar"".equals(s) || ""zip"".equalsIgnoreCase(s)) {
                return p.newFileSystem(output, env);
            }
        }
        throw new IOException(""cant find zipfs support"");
    }",break_loop_control
p,"{
        for (FileSystemProvider p : FileSystemProvider.installedProviders()) {
            String s = p.getScheme();
            if (""jar"".equals(s) || ""zip"".equalsIgnoreCase(s)) {
                return p.newFileSystem(in, new HashMap<String, Object>());
            }
        }
        throw new IOException(""cant find zipfs support"");
    }",iterator
s,"{
        for (FileSystemProvider p : FileSystemProvider.installedProviders()) {
            String s = p.getScheme();
            if (""jar"".equals(s) || ""zip"".equalsIgnoreCase(s)) {
                return p.newFileSystem(in, new HashMap<String, Object>());
            }
        }
        throw new IOException(""cant find zipfs support"");
    }",break_loop_control
e,"{
        Set<Option> options = new HashSet<Option>();
        for (Map.Entry<String, Option> e : optMap.entrySet()) {
            Option option = e.getValue();
            if (option.required) {
                options.add(option);
            }
        }
        return options;
    }",iterator
f,"{
        if (clz == null) {
            return;
        } else {
            initOptionFromClass(clz.getSuperclass());
        }

        Syntax syntax = clz.getAnnotation(Syntax.class);
        if (syntax != null) {
            this.cmdLineSyntax = syntax.syntax();
            this.cmdName = syntax.cmd();
            this.desc = syntax.desc();
            this.onlineHelp = syntax.onlineHelp();
        }

        Field[] fs = clz.getDeclaredFields();
        for (Field f : fs) {
            Opt opt = f.getAnnotation(Opt.class);
            if (opt != null) {
                f.setAccessible(true);
                Option option = new Option();
                option.field = f;
                option.description = opt.description();
                option.hasArg = opt.hasArg();
                option.required = opt.required();
                if ("""".equals(opt.longOpt()) && """".equals(opt.opt())) {   // into automode
                    option.longOpt = fromCamel(f.getName());
                    if (f.getType().equals(boolean.class)) {
                        option.hasArg=false;
                        try {
                            if (f.getBoolean(this)) {
                                throw new RuntimeException(""the value of "" + f + "" must be false, as it is declared as no args"");
                            }
                        } catch (IllegalAccessException e) {
                            throw new RuntimeException(e);
                        }
                    }
                    checkConflict(option, ""--"" + option.longOpt);
                    continue;
                }
                if (!opt.hasArg()) {
                    if (!f.getType().equals(boolean.class)) {
                        throw new RuntimeException(""the type of "" + f
                                + "" must be boolean, as it is declared as no args"");
                    }

                    try {
                        if (f.getBoolean(this)) {
                            throw new RuntimeException(""the value of "" + f + "" must be false, as it is declared as no args"");
                        }
                    } catch (IllegalAccessException e) {
                        throw new RuntimeException(e);
                    }
                }
                boolean haveLongOpt = false;
                if (!"""".equals(opt.longOpt())) {
                    option.longOpt = opt.longOpt();
                    checkConflict(option, ""--"" + option.longOpt);
                    haveLongOpt = true;
                }
                if (!"""".equals(opt.argName())) {
                    option.argName = opt.argName();
                }
                if (!"""".equals(opt.opt())) {
                    option.opt = opt.opt();
                    checkConflict(option, ""-"" + option.opt);
                } else {
                    if (!haveLongOpt) {
                        throw new RuntimeException(""opt or longOpt is not set in @Opt(...) "" + f);
                    }
                }
            }
        }
    }",iterator
i,"{
        if (name.length() == 0) {
            return """";
        }
        StringBuilder sb = new StringBuilder();
        char[] charArray = name.toCharArray();
        sb.append(Character.toLowerCase(charArray[0]));
        for (int i = 1; i < charArray.length; i++) {
            char c = charArray[i];
            if (Character.isUpperCase(c)) {
                sb.append(""-"").append(Character.toLowerCase(c));
            } else {
                sb.append(c);
            }
        }
        return sb.toString();
    }",loop_control
s,"{
        this.orginalArgs = args;
        List<String> remainsOptions = new ArrayList<String>();
        Set<Option> requiredOpts = collectRequriedOptions(optMap);
        Option needArgOpt = null;
        for (String s : args) {
            if (needArgOpt != null) {
                needArgOpt.field.set(this, convert(s, needArgOpt.field.getType()));
                needArgOpt = null;
            } else if (s.startsWith(""-"")) {// its a short or long option
                Option opt = optMap.get(s);
                requiredOpts.remove(opt);
                if (opt == null) {
                    System.err.println(""ERROR: Unrecognized option: "" + s);
                    throw new HelpException();
                } else {
                    if (opt.hasArg) {
                        needArgOpt = opt;
                    } else {
                        opt.field.set(this, true);
                    }
                }
            } else {
                remainsOptions.add(s);
            }
        }

        if (needArgOpt != null) {
            System.err.println(""ERROR: Option "" + needArgOpt.getOptAndLongOpt() + "" need an argument value"");
            throw new HelpException();
        }
        this.remainingArgs = remainsOptions.toArray(new String[remainsOptions.size()]);
        if (this.printHelp) {
            throw new HelpException();
        }
        if (!requiredOpts.isEmpty()) {
            StringBuilder sb = new StringBuilder();
            sb.append(""ERROR: Options: "");
            boolean first = true;
            for (Option option : requiredOpts) {
                if (first) {
                    first = false;
                } else {
                    sb.append("" and "");
                }
                sb.append(option.getOptAndLongOpt());
            }
            sb.append("" is required"");
            System.err.println(sb.toString());
            throw new HelpException();
        }

    }",iterator
option,"{
        this.orginalArgs = args;
        List<String> remainsOptions = new ArrayList<String>();
        Set<Option> requiredOpts = collectRequriedOptions(optMap);
        Option needArgOpt = null;
        for (String s : args) {
            if (needArgOpt != null) {
                needArgOpt.field.set(this, convert(s, needArgOpt.field.getType()));
                needArgOpt = null;
            } else if (s.startsWith(""-"")) {// its a short or long option
                Option opt = optMap.get(s);
                requiredOpts.remove(opt);
                if (opt == null) {
                    System.err.println(""ERROR: Unrecognized option: "" + s);
                    throw new HelpException();
                } else {
                    if (opt.hasArg) {
                        needArgOpt = opt;
                    } else {
                        opt.field.set(this, true);
                    }
                }
            } else {
                remainsOptions.add(s);
            }
        }

        if (needArgOpt != null) {
            System.err.println(""ERROR: Option "" + needArgOpt.getOptAndLongOpt() + "" need an argument value"");
            throw new HelpException();
        }
        this.remainingArgs = remainsOptions.toArray(new String[remainsOptions.size()]);
        if (this.printHelp) {
            throw new HelpException();
        }
        if (!requiredOpts.isEmpty()) {
            StringBuilder sb = new StringBuilder();
            sb.append(""ERROR: Options: "");
            boolean first = true;
            for (Option option : requiredOpts) {
                if (first) {
                    first = false;
                } else {
                    sb.append("" and "");
                }
                sb.append(option.getOptAndLongOpt());
            }
            sb.append("" is required"");
            System.err.println(sb.toString());
            throw new HelpException();
        }

    }",iterator
option,"{
        PrintWriter out = new PrintWriter(new OutputStreamWriter(System.err, StandardCharsets.UTF_8), true);

        final int maxLength = 80;
        final int maxPaLength = 40;
        out.println(this.cmdName + "" -- "" + desc);
        out.println(""usage: "" + this.cmdName + "" "" + cmdLineSyntax);
        if (this.optMap.size() > 0) {
            out.println(""options:"");
        }
        // [PART.A.........][Part.B
        // .-a,--aa.<arg>...desc1
        // .................desc2
        // .-b,--bb
        TreeSet<Option> options = new TreeSet<Option>(this.optMap.values());
        int palength = -1;
        for (Option option : options) {
            int pa = 4 + option.getOptAndLongOpt().length();
            if (option.hasArg) {
                pa += 3 + option.argName.length();
            }
            if (pa < maxPaLength) {
                if (pa > palength) {
                    palength = pa;
                }
            }
        }
        int pblength = maxLength - palength;

        StringBuilder sb = new StringBuilder();
        for (Option option : options) {
            sb.setLength(0);
            sb.append("" "").append(option.getOptAndLongOpt());
            if (option.hasArg) {
                sb.append("" <"").append(option.argName).append("">"");
            }
            String desc = option.description;
            if (desc == null || desc.length() == 0) {// no description
                out.println(sb);
            } else {
                for (int i = palength - sb.length(); i > 0; i--) {
                    sb.append(' ');
                }
                if (sb.length() > maxPaLength) {// to huge part A
                    out.println(sb);
                    sb.setLength(0);
                    for (int i = 0; i < palength; i++) {
                        sb.append(' ');
                    }
                }
                int nextStart = 0;
                while (nextStart < desc.length()) {
                    if (desc.length() - nextStart < pblength) {// can put in one line
                        sb.append(desc.substring(nextStart));
                        out.println(sb);
                        nextStart = desc.length();
                        sb.setLength(0);
                    } else {
                        sb.append(desc.substring(nextStart, nextStart + pblength));
                        out.println(sb);
                        nextStart += pblength;
                        sb.setLength(0);
                        if (nextStart < desc.length()) {
                            for (int i = 0; i < palength; i++) {
                                sb.append(' ');
                            }
                        }
                    }
                }
                if (sb.length() > 0) {
                    out.println(sb);
                    sb.setLength(0);
                }
            }
        }
        String ver = getVersionString();
        if (ver != null && !"""".equals(ver)) {
            out.println(""version: "" + ver);
        }
        if (onlineHelp != null && !"""".equals(onlineHelp)) {
            if (onlineHelp.length() + ""online help: "".length() > maxLength) {
                out.println(""online help: "");
                out.println(onlineHelp);
            } else {
                out.println(""online help: "" + onlineHelp);
            }
        }
        out.flush();
    }",iterator
i,"{
        PrintWriter out = new PrintWriter(new OutputStreamWriter(System.err, StandardCharsets.UTF_8), true);

        final int maxLength = 80;
        final int maxPaLength = 40;
        out.println(this.cmdName + "" -- "" + desc);
        out.println(""usage: "" + this.cmdName + "" "" + cmdLineSyntax);
        if (this.optMap.size() > 0) {
            out.println(""options:"");
        }
        // [PART.A.........][Part.B
        // .-a,--aa.<arg>...desc1
        // .................desc2
        // .-b,--bb
        TreeSet<Option> options = new TreeSet<Option>(this.optMap.values());
        int palength = -1;
        for (Option option : options) {
            int pa = 4 + option.getOptAndLongOpt().length();
            if (option.hasArg) {
                pa += 3 + option.argName.length();
            }
            if (pa < maxPaLength) {
                if (pa > palength) {
                    palength = pa;
                }
            }
        }
        int pblength = maxLength - palength;

        StringBuilder sb = new StringBuilder();
        for (Option option : options) {
            sb.setLength(0);
            sb.append("" "").append(option.getOptAndLongOpt());
            if (option.hasArg) {
                sb.append("" <"").append(option.argName).append("">"");
            }
            String desc = option.description;
            if (desc == null || desc.length() == 0) {// no description
                out.println(sb);
            } else {
                for (int i = palength - sb.length(); i > 0; i--) {
                    sb.append(' ');
                }
                if (sb.length() > maxPaLength) {// to huge part A
                    out.println(sb);
                    sb.setLength(0);
                    for (int i = 0; i < palength; i++) {
                        sb.append(' ');
                    }
                }
                int nextStart = 0;
                while (nextStart < desc.length()) {
                    if (desc.length() - nextStart < pblength) {// can put in one line
                        sb.append(desc.substring(nextStart));
                        out.println(sb);
                        nextStart = desc.length();
                        sb.setLength(0);
                    } else {
                        sb.append(desc.substring(nextStart, nextStart + pblength));
                        out.println(sb);
                        nextStart += pblength;
                        sb.setLength(0);
                        if (nextStart < desc.length()) {
                            for (int i = 0; i < palength; i++) {
                                sb.append(' ');
                            }
                        }
                    }
                }
                if (sb.length() > 0) {
                    out.println(sb);
                    sb.setLength(0);
                }
            }
        }
        String ver = getVersionString();
        if (ver != null && !"""".equals(ver)) {
            out.println(""version: "" + ver);
        }
        if (onlineHelp != null && !"""".equals(onlineHelp)) {
            if (onlineHelp.length() + ""online help: "".length() > maxLength) {
                out.println(""online help: "");
                out.println(onlineHelp);
            } else {
                out.println(""online help: "" + onlineHelp);
            }
        }
        out.flush();
    }",loop_control
nextStart,"{
        PrintWriter out = new PrintWriter(new OutputStreamWriter(System.err, StandardCharsets.UTF_8), true);

        final int maxLength = 80;
        final int maxPaLength = 40;
        out.println(this.cmdName + "" -- "" + desc);
        out.println(""usage: "" + this.cmdName + "" "" + cmdLineSyntax);
        if (this.optMap.size() > 0) {
            out.println(""options:"");
        }
        // [PART.A.........][Part.B
        // .-a,--aa.<arg>...desc1
        // .................desc2
        // .-b,--bb
        TreeSet<Option> options = new TreeSet<Option>(this.optMap.values());
        int palength = -1;
        for (Option option : options) {
            int pa = 4 + option.getOptAndLongOpt().length();
            if (option.hasArg) {
                pa += 3 + option.argName.length();
            }
            if (pa < maxPaLength) {
                if (pa > palength) {
                    palength = pa;
                }
            }
        }
        int pblength = maxLength - palength;

        StringBuilder sb = new StringBuilder();
        for (Option option : options) {
            sb.setLength(0);
            sb.append("" "").append(option.getOptAndLongOpt());
            if (option.hasArg) {
                sb.append("" <"").append(option.argName).append("">"");
            }
            String desc = option.description;
            if (desc == null || desc.length() == 0) {// no description
                out.println(sb);
            } else {
                for (int i = palength - sb.length(); i > 0; i--) {
                    sb.append(' ');
                }
                if (sb.length() > maxPaLength) {// to huge part A
                    out.println(sb);
                    sb.setLength(0);
                    for (int i = 0; i < palength; i++) {
                        sb.append(' ');
                    }
                }
                int nextStart = 0;
                while (nextStart < desc.length()) {
                    if (desc.length() - nextStart < pblength) {// can put in one line
                        sb.append(desc.substring(nextStart));
                        out.println(sb);
                        nextStart = desc.length();
                        sb.setLength(0);
                    } else {
                        sb.append(desc.substring(nextStart, nextStart + pblength));
                        out.println(sb);
                        nextStart += pblength;
                        sb.setLength(0);
                        if (nextStart < desc.length()) {
                            for (int i = 0; i < palength; i++) {
                                sb.append(' ');
                            }
                        }
                    }
                }
                if (sb.length() > 0) {
                    out.println(sb);
                    sb.setLength(0);
                }
            }
        }
        String ver = getVersionString();
        if (ver != null && !"""".equals(ver)) {
            out.println(""version: "" + ver);
        }
        if (onlineHelp != null && !"""".equals(onlineHelp)) {
            if (onlineHelp.length() + ""online help: "".length() > maxLength) {
                out.println(""online help: "");
                out.println(onlineHelp);
            } else {
                out.println(""online help: "" + onlineHelp);
            }
        }
        out.flush();
    }",loop_control
t,"{
        if (desc == null) {
            StringBuilder ps = new StringBuilder(""("");
            if (parameterTypes != null) {
                for (String t : parameterTypes) {
                    ps.append(t);
                }
            }
            ps.append("")"").append(returnType);
            desc = ps.toString();
        }
        return desc;
    }",iterator
parameterName,"{
        if (parameterNames == null) {
            parameterNames = new ArrayList<>();
        }
        while (parameterNames.size() <= parameterIndex) {
            parameterNames.add(null);
        }
        parameterNames.set(parameterIndex, name);
    }",maybe_loop_control
i,"{
        if (parameterNames != null) {
            for (int i = 0; i < parameterNames.size(); i++) {
                String name = parameterNames.get(i);
                if (name != null) {
                    v.visitParameterName(i, name);
                }
            }
        }
        if (debugNodes != null) {
            for (DexDebugOpNode n : debugNodes) {
                n.accept(v);
            }
        }
        if (fineName != null) {
            v.visitSetFile(fineName);
        }
    }",loop_control
n,"{
        if (parameterNames != null) {
            for (int i = 0; i < parameterNames.size(); i++) {
                String name = parameterNames.get(i);
                if (name != null) {
                    v.visitParameterName(i, name);
                }
            }
        }
        if (debugNodes != null) {
            for (DexDebugOpNode n : debugNodes) {
                n.accept(v);
            }
        }
        if (fineName != null) {
            v.visitSetFile(fineName);
        }
    }",iterator
ann,"{
        if (anns != null) {
            for (DexAnnotationNode ann : anns) {
                ann.accept(fv);
            }
        }
    }",iterator
cn,"{
        for (DexClassNode cn : clzs) {
            cn.accept(dcv);
        }
    }",iterator
cn,"{
        for (DexClassNode cn : clzs) {
            cn.accept(dfv);
        }
    }",iterator
ann,"{
        if (anns != null) {
            for (DexAnnotationNode ann : anns) {
                ann.accept(dcv);
            }
        }
        if (methods != null) {
            for (DexMethodNode m : methods) {
                m.accept(dcv);
            }
        }
        if (fields != null) {
            for (DexFieldNode f : fields) {
                f.accept(dcv);
            }
        }
        if (source != null) {
            dcv.visitSource(source);
        }
    }",iterator
m,"{
        if (anns != null) {
            for (DexAnnotationNode ann : anns) {
                ann.accept(dcv);
            }
        }
        if (methods != null) {
            for (DexMethodNode m : methods) {
                m.accept(dcv);
            }
        }
        if (fields != null) {
            for (DexFieldNode f : fields) {
                f.accept(dcv);
            }
        }
        if (source != null) {
            dcv.visitSource(source);
        }
    }",iterator
f,"{
        if (anns != null) {
            for (DexAnnotationNode ann : anns) {
                ann.accept(dcv);
            }
        }
        if (methods != null) {
            for (DexMethodNode m : methods) {
                m.accept(dcv);
            }
        }
        if (fields != null) {
            for (DexFieldNode f : fields) {
                f.accept(dcv);
            }
        }
        if (source != null) {
            dcv.visitSource(source);
        }
    }",iterator
i,"{
        if (anns != null) {
            for (DexAnnotationNode ann : anns) {
                ann.accept(mv);
            }
        }

        if (parameterAnns != null) {
            for (int i = 0; i < parameterAnns.length; i++) {
                List<DexAnnotationNode> ps = parameterAnns[i];
                if (ps != null) {
                    DexAnnotationAble av = mv.visitParameterAnnotation(i);
                    if (av != null) {
                        for (DexAnnotationNode p : ps) {
                            p.accept(av);
                        }
                    }
                }
            }
        }
        if (codeNode != null) {
            codeNode.accept(mv);
        }
    }",loop_control
ann,"{
        if (anns != null) {
            for (DexAnnotationNode ann : anns) {
                ann.accept(mv);
            }
        }

        if (parameterAnns != null) {
            for (int i = 0; i < parameterAnns.length; i++) {
                List<DexAnnotationNode> ps = parameterAnns[i];
                if (ps != null) {
                    DexAnnotationAble av = mv.visitParameterAnnotation(i);
                    if (av != null) {
                        for (DexAnnotationNode p : ps) {
                            p.accept(av);
                        }
                    }
                }
            }
        }
        if (codeNode != null) {
            codeNode.accept(mv);
        }
    }",iterator
p,"{
        if (anns != null) {
            for (DexAnnotationNode ann : anns) {
                ann.accept(mv);
            }
        }

        if (parameterAnns != null) {
            for (int i = 0; i < parameterAnns.length; i++) {
                List<DexAnnotationNode> ps = parameterAnns[i];
                if (ps != null) {
                    DexAnnotationAble av = mv.visitParameterAnnotation(i);
                    if (av != null) {
                        for (DexAnnotationNode p : ps) {
                            p.accept(av);
                        }
                    }
                }
            }
        }
        if (codeNode != null) {
            codeNode.accept(mv);
        }
    }",iterator
n,"{
        if (tryStmts != null) {
            for (TryCatchNode n : tryStmts) {
                n.accept(v);
            }
        }
        if (debugNode != null) {
            DexDebugVisitor ddv = v.visitDebug();
            if (ddv != null) {
                debugNode.accept(ddv);
                ddv.visitEnd();
            }
        }
        if (totalRegister >= 0) {
            v.visitRegister(this.totalRegister);
        }
        for (DexStmtNode n : stmts) {
            n.accept(v);
        }
    }",iterator
e,"{
        if (o instanceof Object[]) {
            DexAnnotationVisitor arrayVisitor = dav.visitArray(name);
            if (arrayVisitor != null) {
                Object[] array = (Object[]) o;
                for (Object e : array) {
                    acceptAnnotationItem(arrayVisitor, null, e);
                }
                arrayVisitor.visitEnd();
            }
        } else if (o instanceof DexAnnotationNode) {
            DexAnnotationNode ann = (DexAnnotationNode) o;
            DexAnnotationVisitor av = dav.visitAnnotation(name, ann.type);
            if (av != null) {
                for (DexAnnotationNode.Item item : ann.items) {
                    acceptAnnotationItem(av, item.name, item.value);
                }
                av.visitEnd();
            }
        } else if (o instanceof Field) {
            Field f = (Field) o;
            dav.visitEnum(name, f.getType(), f.getName());
        } else {
            dav.visit(name, o);
        }
    }",iterator
item,"{
        DexAnnotationVisitor av1 = av.visitAnnotation(type, visibility);
        if (av1 != null) {
            for (Item item : items) {
                acceptAnnotationItem(av1, item.name, item.value);
            }
            av1.visitEnd();
        }
    }",iterator
i,"{
        if (insn.op == null) {// label or others
            return;
        }
        switch (insn.op) {
            case CONST:
            case CONST_4:
            case CONST_16:
            case CONST_HIGH16:
            case CONST_WIDE:
            case CONST_WIDE_16:
            case CONST_WIDE_32:
            case CONST_WIDE_HIGH16:
            case CONST_STRING:
            case CONST_STRING_JUMBO:
            case CONST_CLASS:
                setReg(((ConstStmtNode) insn).a, interpreter.newOperation(insn));
                setTmp(null);
                break;
            case SGET:
            case SGET_BOOLEAN:
            case SGET_BYTE:
            case SGET_CHAR:
            case SGET_OBJECT:
            case SGET_SHORT:
            case SGET_WIDE:
                setReg(((FieldStmtNode) insn).a, interpreter.newOperation(insn));
                setTmp(null);
                break;
            case NEW_INSTANCE:
                setReg(((TypeStmtNode) insn).a, interpreter.newOperation(insn));
                setTmp(null);
                break;
            case MOVE:
            case MOVE_16:
            case MOVE_FROM16:
            case MOVE_OBJECT:
            case MOVE_OBJECT_16:
            case MOVE_OBJECT_FROM16:
            case MOVE_WIDE:
            case MOVE_WIDE_FROM16:
            case MOVE_WIDE_16:
                Stmt2RNode stmt2RNode = (Stmt2RNode) insn;
                setReg(stmt2RNode.a, interpreter.copyOperation(insn, getReg(stmt2RNode.b)));
                setTmp(null);
                break;
            case MOVE_RESULT:
            case MOVE_RESULT_WIDE:
            case MOVE_RESULT_OBJECT:
            case MOVE_EXCEPTION:
                setReg(((Stmt1RNode) insn).a, interpreter.copyOperation(insn, getTmp()));
                setTmp(null);
                break;
            case NOT_INT:
            case NOT_LONG:
            case NEG_DOUBLE:
            case NEG_FLOAT:
            case NEG_INT:
            case NEG_LONG:
            case INT_TO_BYTE:
            case INT_TO_CHAR:
            case INT_TO_DOUBLE:
            case INT_TO_FLOAT:
            case INT_TO_LONG:
            case INT_TO_SHORT:
            case FLOAT_TO_DOUBLE:
            case FLOAT_TO_INT:
            case FLOAT_TO_LONG:
            case DOUBLE_TO_FLOAT:
            case DOUBLE_TO_INT:
            case DOUBLE_TO_LONG:
            case LONG_TO_DOUBLE:
            case LONG_TO_FLOAT:
            case LONG_TO_INT:
            case ARRAY_LENGTH:
                Stmt2RNode stmt2RNode1 = (Stmt2RNode) insn;
                setReg(stmt2RNode1.a, interpreter.unaryOperation(insn, getReg(stmt2RNode1.b)));
                setTmp(null);
                break;
            case IF_EQZ:
            case IF_GEZ:
            case IF_GTZ:
            case IF_LEZ:
            case IF_LTZ:
            case IF_NEZ:
                interpreter.unaryOperation(insn, getReg(((JumpStmtNode) insn).a));
                setTmp(null);
                break;
            case SPARSE_SWITCH:
                interpreter.unaryOperation(insn, getReg(((SparseSwitchStmtNode) insn).a));
                setTmp(null);
                break;
            case PACKED_SWITCH:
                interpreter.unaryOperation(insn, getReg(((PackedSwitchStmtNode) insn).a));
                setTmp(null);
                break;
            case SPUT:
            case SPUT_BOOLEAN:
            case SPUT_BYTE:
            case SPUT_CHAR:
            case SPUT_OBJECT:
            case SPUT_SHORT:
            case SPUT_WIDE:
                interpreter.unaryOperation(insn, getReg(((FieldStmtNode) insn).a));
                setTmp(null);
                break;
            case IGET:
            case IGET_BOOLEAN:
            case IGET_BYTE:
            case IGET_CHAR:
            case IGET_OBJECT:
            case IGET_SHORT:
            case IGET_WIDE:
                FieldStmtNode fieldStmtNode = (FieldStmtNode) insn;
                setReg(fieldStmtNode.a, interpreter.unaryOperation(insn, getReg(fieldStmtNode.b)));
                setTmp(null);
                break;
            case NEW_ARRAY:
            case INSTANCE_OF: {
                TypeStmtNode typeStmtNode = (TypeStmtNode) insn;
                setReg(typeStmtNode.a, interpreter.unaryOperation(insn, getReg(typeStmtNode.b)));
                setTmp(null);
            }
            break;
            case CHECK_CAST: {
                TypeStmtNode typeStmtNode = (TypeStmtNode) insn;
                setReg(typeStmtNode.a, interpreter.unaryOperation(insn, getReg(typeStmtNode.a)));
                setTmp(null);
            }
            break;
            case MONITOR_ENTER:
            case MONITOR_EXIT:
            case THROW:
                interpreter.unaryOperation(insn, getReg(((Stmt1RNode) insn).a));
                setTmp(null);
                break;
            case RETURN:
            case RETURN_WIDE:
            case RETURN_OBJECT:
                interpreter.returnOperation(insn, getReg(((Stmt1RNode) insn).a));
                setTmp(null);
                break;
            case AGET:
            case AGET_BOOLEAN:
            case AGET_BYTE:
            case AGET_CHAR:
            case AGET_OBJECT:
            case AGET_SHORT:
            case AGET_WIDE:
            case CMP_LONG:
            case CMPG_DOUBLE:
            case CMPG_FLOAT:
            case CMPL_DOUBLE:
            case CMPL_FLOAT:
            case ADD_DOUBLE:
            case ADD_FLOAT:
            case ADD_INT:
            case ADD_LONG:
            case SUB_DOUBLE:
            case SUB_FLOAT:
            case SUB_INT:
            case SUB_LONG:
            case MUL_DOUBLE:
            case MUL_FLOAT:
            case MUL_INT:
            case MUL_LONG:
            case DIV_DOUBLE:
            case DIV_FLOAT:
            case DIV_INT:
            case DIV_LONG:
            case REM_DOUBLE:
            case REM_FLOAT:
            case REM_INT:
            case REM_LONG:
            case AND_INT:
            case AND_LONG:
            case OR_INT:
            case OR_LONG:
            case XOR_INT:
            case XOR_LONG:
            case SHL_INT:
            case SHL_LONG:
            case SHR_INT:
            case SHR_LONG:
            case USHR_INT:
            case USHR_LONG:
                Stmt3RNode stmt3RNode = (Stmt3RNode) insn;
                setReg(stmt3RNode.a, interpreter.binaryOperation(insn, getReg(stmt3RNode.b), getReg(stmt3RNode.c)));
                setTmp(null);
                break;
            case IF_EQ:
            case IF_GE:
            case IF_GT:
            case IF_LE:
            case IF_LT:
            case IF_NE:
                JumpStmtNode jumpStmtNode = (JumpStmtNode) insn;
                interpreter.binaryOperation(insn, getReg(jumpStmtNode.a), getReg(jumpStmtNode.b));
                setTmp(null);
                break;
            case IPUT:
            case IPUT_BOOLEAN:
            case IPUT_BYTE:
            case IPUT_CHAR:
            case IPUT_OBJECT:
            case IPUT_SHORT:
            case IPUT_WIDE:
                FieldStmtNode fieldStmtNode1 = (FieldStmtNode) insn;
                interpreter.binaryOperation(insn, getReg(fieldStmtNode1.b), getReg(fieldStmtNode1.a));
                setTmp(null);
                break;
            case APUT:
            case APUT_BOOLEAN:
            case APUT_BYTE:
            case APUT_CHAR:
            case APUT_OBJECT:
            case APUT_SHORT:
            case APUT_WIDE:
                Stmt3RNode stmt3RNode1 = (Stmt3RNode) insn;
                interpreter.ternaryOperation(insn, getReg(stmt3RNode1.b), getReg(stmt3RNode1.c), getReg(stmt3RNode1.a));
                setTmp(null);
                break;
            case INVOKE_VIRTUAL_RANGE:
            case INVOKE_VIRTUAL:
            case INVOKE_SUPER_RANGE:
            case INVOKE_DIRECT_RANGE:
            case INVOKE_SUPER:
            case INVOKE_DIRECT:
            case INVOKE_STATIC_RANGE:
            case INVOKE_STATIC:
            case INVOKE_INTERFACE_RANGE:
            case INVOKE_INTERFACE:
            case INVOKE_CUSTOM:
            case INVOKE_CUSTOM_RANGE:
            case INVOKE_POLYMORPHIC:
            case INVOKE_POLYMORPHIC_RANGE: {
                int i = 0;
                AbstractMethodStmtNode methodStmtNode = (AbstractMethodStmtNode) insn;
                List<V> v;
                Proto proto = methodStmtNode.getProto();
                boolean isStatic = false;
                if (insn.op == Op.INVOKE_STATIC || insn.op == Op.INVOKE_STATIC_RANGE) {
                    isStatic = true;
                } else if (insn.op == Op.INVOKE_CUSTOM || insn.op == Op.INVOKE_CUSTOM_RANGE) {
                    isStatic = true;
                }
                if (isStatic) {
                    v = new ArrayList<>(proto.getParameterTypes().length);
                } else {
                    v = new ArrayList<>(proto.getParameterTypes().length + 1);
                    v.add(getReg(methodStmtNode.args[i++]));
                }

                for (String type : proto.getParameterTypes()) {
                    v.add(getReg(methodStmtNode.args[i]));
                    char t = type.charAt(0);
                    if (t == 'J' || t == 'D') {
                        i += 2;
                    } else {
                        i += 1;
                    }
                }
                setTmp(interpreter.naryOperation(insn, v));
            }
            break;
            case FILLED_NEW_ARRAY:
            case FILLED_NEW_ARRAY_RANGE: {
                FilledNewArrayStmtNode filledNewArrayStmtNode = (FilledNewArrayStmtNode) insn;
                List<V> v = new ArrayList<>(filledNewArrayStmtNode.args.length);
                for (int i = 0; i < filledNewArrayStmtNode.args.length; i++) {
                    v.add(getReg(filledNewArrayStmtNode.args[i]));
                }
                setTmp(interpreter.naryOperation(insn, v));
            }
            break;


            case ADD_DOUBLE_2ADDR:
            case ADD_FLOAT_2ADDR:
            case ADD_INT_2ADDR:
            case ADD_LONG_2ADDR:
            case SUB_DOUBLE_2ADDR:
            case SUB_FLOAT_2ADDR:
            case SUB_INT_2ADDR:
            case SUB_LONG_2ADDR:
            case MUL_DOUBLE_2ADDR:
            case MUL_FLOAT_2ADDR:
            case MUL_INT_2ADDR:
            case MUL_LONG_2ADDR:
            case DIV_DOUBLE_2ADDR:
            case DIV_FLOAT_2ADDR:
            case DIV_INT_2ADDR:
            case DIV_LONG_2ADDR:
            case REM_DOUBLE_2ADDR:
            case REM_FLOAT_2ADDR:
            case REM_INT_2ADDR:
            case REM_LONG_2ADDR:
            case AND_INT_2ADDR:
            case AND_LONG_2ADDR:
            case OR_INT_2ADDR:
            case OR_LONG_2ADDR:
            case XOR_INT_2ADDR:
            case XOR_LONG_2ADDR:
            case SHL_INT_2ADDR:
            case SHL_LONG_2ADDR:
            case SHR_INT_2ADDR:
            case SHR_LONG_2ADDR:
            case USHR_INT_2ADDR:
            case USHR_LONG_2ADDR:
                Stmt2RNode stmt2RNode2 = (Stmt2RNode) insn;
                setReg(stmt2RNode2.a, interpreter.binaryOperation(insn, getReg(stmt2RNode2.a), getReg(stmt2RNode2.b)));
                setTmp(null);
                break;
            case ADD_INT_LIT16:
            case ADD_INT_LIT8:
            case RSUB_INT_LIT8:
            case RSUB_INT:
            case MUL_INT_LIT8:
            case MUL_INT_LIT16:
            case DIV_INT_LIT16:
            case DIV_INT_LIT8:
            case REM_INT_LIT16:
            case REM_INT_LIT8:
            case AND_INT_LIT16:
            case AND_INT_LIT8:
            case OR_INT_LIT16:
            case OR_INT_LIT8:
            case XOR_INT_LIT16:
            case XOR_INT_LIT8:
            case SHL_INT_LIT8:
            case SHR_INT_LIT8:
            case USHR_INT_LIT8:
                Stmt2R1NNode stmt2R1NNode = (Stmt2R1NNode) insn;
                setReg(stmt2R1NNode.distReg, interpreter.unaryOperation(insn, getReg(stmt2R1NNode.srcReg)));
                setTmp(null);
                break;
            case FILL_ARRAY_DATA:
                interpreter.unaryOperation(insn,getReg(((FillArrayDataStmtNode)insn).ra));
                setTmp(null);
                break;
            case GOTO:
            case GOTO_16:
            case GOTO_32:
            case RETURN_VOID:
            case BAD_OP:
                setTmp(null);
                break;
            default:
                throw new RuntimeException();
        }
    }",loop_control
type,"{
        if (insn.op == null) {// label or others
            return;
        }
        switch (insn.op) {
            case CONST:
            case CONST_4:
            case CONST_16:
            case CONST_HIGH16:
            case CONST_WIDE:
            case CONST_WIDE_16:
            case CONST_WIDE_32:
            case CONST_WIDE_HIGH16:
            case CONST_STRING:
            case CONST_STRING_JUMBO:
            case CONST_CLASS:
                setReg(((ConstStmtNode) insn).a, interpreter.newOperation(insn));
                setTmp(null);
                break;
            case SGET:
            case SGET_BOOLEAN:
            case SGET_BYTE:
            case SGET_CHAR:
            case SGET_OBJECT:
            case SGET_SHORT:
            case SGET_WIDE:
                setReg(((FieldStmtNode) insn).a, interpreter.newOperation(insn));
                setTmp(null);
                break;
            case NEW_INSTANCE:
                setReg(((TypeStmtNode) insn).a, interpreter.newOperation(insn));
                setTmp(null);
                break;
            case MOVE:
            case MOVE_16:
            case MOVE_FROM16:
            case MOVE_OBJECT:
            case MOVE_OBJECT_16:
            case MOVE_OBJECT_FROM16:
            case MOVE_WIDE:
            case MOVE_WIDE_FROM16:
            case MOVE_WIDE_16:
                Stmt2RNode stmt2RNode = (Stmt2RNode) insn;
                setReg(stmt2RNode.a, interpreter.copyOperation(insn, getReg(stmt2RNode.b)));
                setTmp(null);
                break;
            case MOVE_RESULT:
            case MOVE_RESULT_WIDE:
            case MOVE_RESULT_OBJECT:
            case MOVE_EXCEPTION:
                setReg(((Stmt1RNode) insn).a, interpreter.copyOperation(insn, getTmp()));
                setTmp(null);
                break;
            case NOT_INT:
            case NOT_LONG:
            case NEG_DOUBLE:
            case NEG_FLOAT:
            case NEG_INT:
            case NEG_LONG:
            case INT_TO_BYTE:
            case INT_TO_CHAR:
            case INT_TO_DOUBLE:
            case INT_TO_FLOAT:
            case INT_TO_LONG:
            case INT_TO_SHORT:
            case FLOAT_TO_DOUBLE:
            case FLOAT_TO_INT:
            case FLOAT_TO_LONG:
            case DOUBLE_TO_FLOAT:
            case DOUBLE_TO_INT:
            case DOUBLE_TO_LONG:
            case LONG_TO_DOUBLE:
            case LONG_TO_FLOAT:
            case LONG_TO_INT:
            case ARRAY_LENGTH:
                Stmt2RNode stmt2RNode1 = (Stmt2RNode) insn;
                setReg(stmt2RNode1.a, interpreter.unaryOperation(insn, getReg(stmt2RNode1.b)));
                setTmp(null);
                break;
            case IF_EQZ:
            case IF_GEZ:
            case IF_GTZ:
            case IF_LEZ:
            case IF_LTZ:
            case IF_NEZ:
                interpreter.unaryOperation(insn, getReg(((JumpStmtNode) insn).a));
                setTmp(null);
                break;
            case SPARSE_SWITCH:
                interpreter.unaryOperation(insn, getReg(((SparseSwitchStmtNode) insn).a));
                setTmp(null);
                break;
            case PACKED_SWITCH:
                interpreter.unaryOperation(insn, getReg(((PackedSwitchStmtNode) insn).a));
                setTmp(null);
                break;
            case SPUT:
            case SPUT_BOOLEAN:
            case SPUT_BYTE:
            case SPUT_CHAR:
            case SPUT_OBJECT:
            case SPUT_SHORT:
            case SPUT_WIDE:
                interpreter.unaryOperation(insn, getReg(((FieldStmtNode) insn).a));
                setTmp(null);
                break;
            case IGET:
            case IGET_BOOLEAN:
            case IGET_BYTE:
            case IGET_CHAR:
            case IGET_OBJECT:
            case IGET_SHORT:
            case IGET_WIDE:
                FieldStmtNode fieldStmtNode = (FieldStmtNode) insn;
                setReg(fieldStmtNode.a, interpreter.unaryOperation(insn, getReg(fieldStmtNode.b)));
                setTmp(null);
                break;
            case NEW_ARRAY:
            case INSTANCE_OF: {
                TypeStmtNode typeStmtNode = (TypeStmtNode) insn;
                setReg(typeStmtNode.a, interpreter.unaryOperation(insn, getReg(typeStmtNode.b)));
                setTmp(null);
            }
            break;
            case CHECK_CAST: {
                TypeStmtNode typeStmtNode = (TypeStmtNode) insn;
                setReg(typeStmtNode.a, interpreter.unaryOperation(insn, getReg(typeStmtNode.a)));
                setTmp(null);
            }
            break;
            case MONITOR_ENTER:
            case MONITOR_EXIT:
            case THROW:
                interpreter.unaryOperation(insn, getReg(((Stmt1RNode) insn).a));
                setTmp(null);
                break;
            case RETURN:
            case RETURN_WIDE:
            case RETURN_OBJECT:
                interpreter.returnOperation(insn, getReg(((Stmt1RNode) insn).a));
                setTmp(null);
                break;
            case AGET:
            case AGET_BOOLEAN:
            case AGET_BYTE:
            case AGET_CHAR:
            case AGET_OBJECT:
            case AGET_SHORT:
            case AGET_WIDE:
            case CMP_LONG:
            case CMPG_DOUBLE:
            case CMPG_FLOAT:
            case CMPL_DOUBLE:
            case CMPL_FLOAT:
            case ADD_DOUBLE:
            case ADD_FLOAT:
            case ADD_INT:
            case ADD_LONG:
            case SUB_DOUBLE:
            case SUB_FLOAT:
            case SUB_INT:
            case SUB_LONG:
            case MUL_DOUBLE:
            case MUL_FLOAT:
            case MUL_INT:
            case MUL_LONG:
            case DIV_DOUBLE:
            case DIV_FLOAT:
            case DIV_INT:
            case DIV_LONG:
            case REM_DOUBLE:
            case REM_FLOAT:
            case REM_INT:
            case REM_LONG:
            case AND_INT:
            case AND_LONG:
            case OR_INT:
            case OR_LONG:
            case XOR_INT:
            case XOR_LONG:
            case SHL_INT:
            case SHL_LONG:
            case SHR_INT:
            case SHR_LONG:
            case USHR_INT:
            case USHR_LONG:
                Stmt3RNode stmt3RNode = (Stmt3RNode) insn;
                setReg(stmt3RNode.a, interpreter.binaryOperation(insn, getReg(stmt3RNode.b), getReg(stmt3RNode.c)));
                setTmp(null);
                break;
            case IF_EQ:
            case IF_GE:
            case IF_GT:
            case IF_LE:
            case IF_LT:
            case IF_NE:
                JumpStmtNode jumpStmtNode = (JumpStmtNode) insn;
                interpreter.binaryOperation(insn, getReg(jumpStmtNode.a), getReg(jumpStmtNode.b));
                setTmp(null);
                break;
            case IPUT:
            case IPUT_BOOLEAN:
            case IPUT_BYTE:
            case IPUT_CHAR:
            case IPUT_OBJECT:
            case IPUT_SHORT:
            case IPUT_WIDE:
                FieldStmtNode fieldStmtNode1 = (FieldStmtNode) insn;
                interpreter.binaryOperation(insn, getReg(fieldStmtNode1.b), getReg(fieldStmtNode1.a));
                setTmp(null);
                break;
            case APUT:
            case APUT_BOOLEAN:
            case APUT_BYTE:
            case APUT_CHAR:
            case APUT_OBJECT:
            case APUT_SHORT:
            case APUT_WIDE:
                Stmt3RNode stmt3RNode1 = (Stmt3RNode) insn;
                interpreter.ternaryOperation(insn, getReg(stmt3RNode1.b), getReg(stmt3RNode1.c), getReg(stmt3RNode1.a));
                setTmp(null);
                break;
            case INVOKE_VIRTUAL_RANGE:
            case INVOKE_VIRTUAL:
            case INVOKE_SUPER_RANGE:
            case INVOKE_DIRECT_RANGE:
            case INVOKE_SUPER:
            case INVOKE_DIRECT:
            case INVOKE_STATIC_RANGE:
            case INVOKE_STATIC:
            case INVOKE_INTERFACE_RANGE:
            case INVOKE_INTERFACE:
            case INVOKE_CUSTOM:
            case INVOKE_CUSTOM_RANGE:
            case INVOKE_POLYMORPHIC:
            case INVOKE_POLYMORPHIC_RANGE: {
                int i = 0;
                AbstractMethodStmtNode methodStmtNode = (AbstractMethodStmtNode) insn;
                List<V> v;
                Proto proto = methodStmtNode.getProto();
                boolean isStatic = false;
                if (insn.op == Op.INVOKE_STATIC || insn.op == Op.INVOKE_STATIC_RANGE) {
                    isStatic = true;
                } else if (insn.op == Op.INVOKE_CUSTOM || insn.op == Op.INVOKE_CUSTOM_RANGE) {
                    isStatic = true;
                }
                if (isStatic) {
                    v = new ArrayList<>(proto.getParameterTypes().length);
                } else {
                    v = new ArrayList<>(proto.getParameterTypes().length + 1);
                    v.add(getReg(methodStmtNode.args[i++]));
                }

                for (String type : proto.getParameterTypes()) {
                    v.add(getReg(methodStmtNode.args[i]));
                    char t = type.charAt(0);
                    if (t == 'J' || t == 'D') {
                        i += 2;
                    } else {
                        i += 1;
                    }
                }
                setTmp(interpreter.naryOperation(insn, v));
            }
            break;
            case FILLED_NEW_ARRAY:
            case FILLED_NEW_ARRAY_RANGE: {
                FilledNewArrayStmtNode filledNewArrayStmtNode = (FilledNewArrayStmtNode) insn;
                List<V> v = new ArrayList<>(filledNewArrayStmtNode.args.length);
                for (int i = 0; i < filledNewArrayStmtNode.args.length; i++) {
                    v.add(getReg(filledNewArrayStmtNode.args[i]));
                }
                setTmp(interpreter.naryOperation(insn, v));
            }
            break;


            case ADD_DOUBLE_2ADDR:
            case ADD_FLOAT_2ADDR:
            case ADD_INT_2ADDR:
            case ADD_LONG_2ADDR:
            case SUB_DOUBLE_2ADDR:
            case SUB_FLOAT_2ADDR:
            case SUB_INT_2ADDR:
            case SUB_LONG_2ADDR:
            case MUL_DOUBLE_2ADDR:
            case MUL_FLOAT_2ADDR:
            case MUL_INT_2ADDR:
            case MUL_LONG_2ADDR:
            case DIV_DOUBLE_2ADDR:
            case DIV_FLOAT_2ADDR:
            case DIV_INT_2ADDR:
            case DIV_LONG_2ADDR:
            case REM_DOUBLE_2ADDR:
            case REM_FLOAT_2ADDR:
            case REM_INT_2ADDR:
            case REM_LONG_2ADDR:
            case AND_INT_2ADDR:
            case AND_LONG_2ADDR:
            case OR_INT_2ADDR:
            case OR_LONG_2ADDR:
            case XOR_INT_2ADDR:
            case XOR_LONG_2ADDR:
            case SHL_INT_2ADDR:
            case SHL_LONG_2ADDR:
            case SHR_INT_2ADDR:
            case SHR_LONG_2ADDR:
            case USHR_INT_2ADDR:
            case USHR_LONG_2ADDR:
                Stmt2RNode stmt2RNode2 = (Stmt2RNode) insn;
                setReg(stmt2RNode2.a, interpreter.binaryOperation(insn, getReg(stmt2RNode2.a), getReg(stmt2RNode2.b)));
                setTmp(null);
                break;
            case ADD_INT_LIT16:
            case ADD_INT_LIT8:
            case RSUB_INT_LIT8:
            case RSUB_INT:
            case MUL_INT_LIT8:
            case MUL_INT_LIT16:
            case DIV_INT_LIT16:
            case DIV_INT_LIT8:
            case REM_INT_LIT16:
            case REM_INT_LIT8:
            case AND_INT_LIT16:
            case AND_INT_LIT8:
            case OR_INT_LIT16:
            case OR_INT_LIT8:
            case XOR_INT_LIT16:
            case XOR_INT_LIT8:
            case SHL_INT_LIT8:
            case SHR_INT_LIT8:
            case USHR_INT_LIT8:
                Stmt2R1NNode stmt2R1NNode = (Stmt2R1NNode) insn;
                setReg(stmt2R1NNode.distReg, interpreter.unaryOperation(insn, getReg(stmt2R1NNode.srcReg)));
                setTmp(null);
                break;
            case FILL_ARRAY_DATA:
                interpreter.unaryOperation(insn,getReg(((FillArrayDataStmtNode)insn).ra));
                setTmp(null);
                break;
            case GOTO:
            case GOTO_16:
            case GOTO_32:
            case RETURN_VOID:
            case BAD_OP:
                setTmp(null);
                break;
            default:
                throw new RuntimeException();
        }
    }",iterator
op,"{
        Op[] ops = Op.ops;
        for (Op op : Op.values()) {
            if (op.opcode >= 0) {
                ops[op.opcode] = op;
            }
        }
    }",iterator
i,"{
        for (int i = 0; i < 2000; i++) {
            Local b = addLocal(""a"");
            addStmt(nAssign(b, nString(""123"")));
        }
        Local b = addLocal(""a"");
        for (int i = 0; i < 20000; i++) {
            addStmt(nAssign(b, nString(""123"")));
        }
        addStmt(nReturn(b));
        transform();
    }",loop_control
trap,"{
        IrMethod n = new IrMethod();
        LabelAndLocalMapper mapper = new LabelAndLocalMapper();
        n.name = name;
        n.args = args;
        n.isStatic = isStatic;
        n.owner = owner;
        n.ret = ret;
        n.stmts = stmts.clone(mapper);
        for (Trap trap : traps) {
            n.traps.add(trap.clone(mapper));
        }
        for (LocalVar var : vars) {
            n.vars.add(var.clone(mapper));
        }
        if (phiLabels != null) {
            List<LabelStmt> nPhiLabels = new ArrayList<>(phiLabels.size());
            for (LabelStmt labelStmt : phiLabels) {
                nPhiLabels.add(labelStmt.clone(mapper));
            }
            n.phiLabels = nPhiLabels;
        }
        for(Local local:locals){
            n.locals.add((Local) local.clone(mapper));
        }
        return n;
    }",iterator
var,"{
        IrMethod n = new IrMethod();
        LabelAndLocalMapper mapper = new LabelAndLocalMapper();
        n.name = name;
        n.args = args;
        n.isStatic = isStatic;
        n.owner = owner;
        n.ret = ret;
        n.stmts = stmts.clone(mapper);
        for (Trap trap : traps) {
            n.traps.add(trap.clone(mapper));
        }
        for (LocalVar var : vars) {
            n.vars.add(var.clone(mapper));
        }
        if (phiLabels != null) {
            List<LabelStmt> nPhiLabels = new ArrayList<>(phiLabels.size());
            for (LabelStmt labelStmt : phiLabels) {
                nPhiLabels.add(labelStmt.clone(mapper));
            }
            n.phiLabels = nPhiLabels;
        }
        for(Local local:locals){
            n.locals.add((Local) local.clone(mapper));
        }
        return n;
    }",iterator
labelStmt,"{
        IrMethod n = new IrMethod();
        LabelAndLocalMapper mapper = new LabelAndLocalMapper();
        n.name = name;
        n.args = args;
        n.isStatic = isStatic;
        n.owner = owner;
        n.ret = ret;
        n.stmts = stmts.clone(mapper);
        for (Trap trap : traps) {
            n.traps.add(trap.clone(mapper));
        }
        for (LocalVar var : vars) {
            n.vars.add(var.clone(mapper));
        }
        if (phiLabels != null) {
            List<LabelStmt> nPhiLabels = new ArrayList<>(phiLabels.size());
            for (LabelStmt labelStmt : phiLabels) {
                nPhiLabels.add(labelStmt.clone(mapper));
            }
            n.phiLabels = nPhiLabels;
        }
        for(Local local:locals){
            n.locals.add((Local) local.clone(mapper));
        }
        return n;
    }",iterator
arg,"{
        StringBuilder sb = new StringBuilder();
        sb.append(""// "").append(this.owner).append(""\n"");
        if (isStatic) {
            sb.append("" static "");
        }
        sb.append(ret == null ? null : Util.toShortClassName(ret)).append(' ').append(this.name).append('(');
        if (args != null) {
            boolean first = true;
            for (String arg : args) {
                if (first) {
                    first = false;
                } else {
                    sb.append(',');
                }
                sb.append(Util.toShortClassName(arg));
            }
        }
        sb.append("") {\n\n"").append(stmts).append(""\n"");
        if (traps.size() > 0 || vars.size() > 0) {
            sb.append(""=============\n"");
            for (Trap trap : traps) {
                sb.append(trap).append('\n');
            }
            for (LocalVar var : vars) {
                sb.append(var).append('\n');
            }
        }
        sb.append(""}"");
        return sb.toString();
    }",iterator
trap,"{
        StringBuilder sb = new StringBuilder();
        sb.append(""// "").append(this.owner).append(""\n"");
        if (isStatic) {
            sb.append("" static "");
        }
        sb.append(ret == null ? null : Util.toShortClassName(ret)).append(' ').append(this.name).append('(');
        if (args != null) {
            boolean first = true;
            for (String arg : args) {
                if (first) {
                    first = false;
                } else {
                    sb.append(',');
                }
                sb.append(Util.toShortClassName(arg));
            }
        }
        sb.append("") {\n\n"").append(stmts).append(""\n"");
        if (traps.size() > 0 || vars.size() > 0) {
            sb.append(""=============\n"");
            for (Trap trap : traps) {
                sb.append(trap).append('\n');
            }
            for (LocalVar var : vars) {
                sb.append(var).append('\n');
            }
        }
        sb.append(""}"");
        return sb.toString();
    }",iterator
var,"{
        StringBuilder sb = new StringBuilder();
        sb.append(""// "").append(this.owner).append(""\n"");
        if (isStatic) {
            sb.append("" static "");
        }
        sb.append(ret == null ? null : Util.toShortClassName(ret)).append(' ').append(this.name).append('(');
        if (args != null) {
            boolean first = true;
            for (String arg : args) {
                if (first) {
                    first = false;
                } else {
                    sb.append(',');
                }
                sb.append(Util.toShortClassName(arg));
            }
        }
        sb.append("") {\n\n"").append(stmts).append(""\n"");
        if (traps.size() > 0 || vars.size() > 0) {
            sb.append(""=============\n"");
            for (Trap trap : traps) {
                sb.append(trap).append('\n');
            }
            for (LocalVar var : vars) {
                sb.append(var).append('\n');
            }
        }
        sb.append(""}"");
        return sb.toString();
    }",iterator
i,"{
        int size = handlers.length;
        LabelStmt[] cloneHandlers = new LabelStmt[size];
        String[] cloneTypes = new String[size];
        for (int i = 0; i < size; i++) {
            cloneHandlers[i] = handlers[i].clone(mapper);
            cloneTypes[i] = types[i];
        }
        return new Trap(start.clone(mapper), end.clone(mapper), cloneHandlers, cloneTypes);
    }",loop_control
i,"{
        StringBuilder sb = new StringBuilder(String.format("".catch %s - %s : "", start.getDisplayName(),
                end.getDisplayName()));
        for (int i = 0; i < handlers.length; i++) {
            sb.append(types[i] == null ? ""all"" : types[i]).append("" > "").append(handlers[i].getDisplayName())
                    .append("","");
        }
        return sb.toString();
    }",loop_control
i,"{
        List<String> list = new ArrayList<String>(5);
        char[] chars = desc.toCharArray();
        int i = 0;
        while (i < chars.length) {
            switch (chars[i]) {
            case 'V':
            case 'Z':
            case 'C':
            case 'B':
            case 'S':
            case 'I':
            case 'F':
            case 'J':
            case 'D':
                list.add(Character.toString(chars[i]));
                i++;
                break;
            case '[': {
                int count = 1;
                while (chars[i + count] == '[') {
                    count++;
                }
                if (chars[i + count] == 'L') {
                    count++;
                    while (chars[i + count] != ';') {
                        count++;
                    }
                }
                count++;
                list.add(new String(chars, i, count));
                i += count + 1;
                break;
            }
            case 'L': {
                int count = 1;
                while (chars[i + count] != ';') {
                    ++count;
                }
                count++;
                list.add(new String(chars, i, count));
                i += count + 1;
                break;
            }
            default:
            }
        }
        return list;
    }",loop_control
count,"{
        List<String> list = new ArrayList<String>(5);
        char[] chars = desc.toCharArray();
        int i = 0;
        while (i < chars.length) {
            switch (chars[i]) {
            case 'V':
            case 'Z':
            case 'C':
            case 'B':
            case 'S':
            case 'I':
            case 'F':
            case 'J':
            case 'D':
                list.add(Character.toString(chars[i]));
                i++;
                break;
            case '[': {
                int count = 1;
                while (chars[i + count] == '[') {
                    count++;
                }
                if (chars[i + count] == 'L') {
                    count++;
                    while (chars[i + count] != ';') {
                        count++;
                    }
                }
                count++;
                list.add(new String(chars, i, count));
                i += count + 1;
                break;
            }
            case 'L': {
                int count = 1;
                while (chars[i + count] != ';') {
                    ++count;
                }
                count++;
                list.add(new String(chars, i, count));
                i += count + 1;
                break;
            }
            default:
            }
        }
        return list;
    }",loop_control
d,"{
        switch (desc.charAt(0)) {
        case 'Z':
            return ""boolean"";
        case 'B':
            return ""byte"";
        case 'C':
            return ""char"";
        case 'S':
            return ""short"";
        case 'I':
            return ""int"";
        case 'J':
            return ""long"";
        case 'F':
            return ""float"";
        case 'D':
            return ""double"";
        case 'V':
            return ""void"";
        case 'L': {
            int i = desc.lastIndexOf('/');
            return desc.substring(i < 0 ? 1 : i + 1, desc.length() - 1);
        }
        case '[':
            int d = 1;
            for (; d < desc.length(); d++) {
                if (desc.charAt(d) != '[') {
                    break;
                }
            }
            StringBuilder sb = new StringBuilder().append(toShortClassName(desc.substring(d)));
            for (int t = 0; t < d; t++) {
                sb.append(""[]"");
            }
            return sb.toString();
        }
        throw new UnsupportedOperationException();
    }",loop_control
t,"{
        switch (desc.charAt(0)) {
        case 'Z':
            return ""boolean"";
        case 'B':
            return ""byte"";
        case 'C':
            return ""char"";
        case 'S':
            return ""short"";
        case 'I':
            return ""int"";
        case 'J':
            return ""long"";
        case 'F':
            return ""float"";
        case 'D':
            return ""double"";
        case 'V':
            return ""void"";
        case 'L': {
            int i = desc.lastIndexOf('/');
            return desc.substring(i < 0 ? 1 : i + 1, desc.length() - 1);
        }
        case '[':
            int d = 1;
            for (; d < desc.length(); d++) {
                if (desc.charAt(d) != '[') {
                    break;
                }
            }
            StringBuilder sb = new StringBuilder().append(toShortClassName(desc.substring(d)));
            for (int t = 0; t < d; t++) {
                sb.append(""[]"");
            }
            return sb.toString();
        }
        throw new UnsupportedOperationException();
    }",loop_control
desc,"{
        switch (desc.charAt(0)) {
        case 'Z':
            return ""boolean"";
        case 'B':
            return ""byte"";
        case 'C':
            return ""char"";
        case 'S':
            return ""short"";
        case 'I':
            return ""int"";
        case 'J':
            return ""long"";
        case 'F':
            return ""float"";
        case 'D':
            return ""double"";
        case 'V':
            return ""void"";
        case 'L': {
            int i = desc.lastIndexOf('/');
            return desc.substring(i < 0 ? 1 : i + 1, desc.length() - 1);
        }
        case '[':
            int d = 1;
            for (; d < desc.length(); d++) {
                if (desc.charAt(d) != '[') {
                    break;
                }
            }
            StringBuilder sb = new StringBuilder().append(toShortClassName(desc.substring(d)));
            for (int t = 0; t < d; t++) {
                sb.append(""[]"");
            }
            return sb.toString();
        }
        throw new UnsupportedOperationException();
    }",break_loop_control
it,"{
        for (Iterator<Stmt> it = stmts.iterator(); it.hasNext(); ) {
            Stmt stmt = it.next();
            Stmt n = travel(stmt);
            if (n != stmt) {
                stmts.insertBefore(stmt, n);
                it.remove();
            }
        }
    }",iterator
i,"{
        switch (stmt.et) {
            case E0:
                break;
            case E1:
                stmt.setOp(travel(stmt.getOp()));
                break;
            case E2:
                stmt.setOp1(travel(stmt.getOp1()));
                stmt.setOp2(travel(stmt.getOp2()));
                break;
            case En:
                Value[] ops = stmt.getOps();
                for (int i = 0; i < ops.length; i++) {
                    ops[i] = travel(ops[i]);
                }
                break;
        }
        return stmt;
    }",loop_control
i,"{
        switch (op.et) {
            case E0:
                break;
            case E1:
                op.setOp(travel(op.getOp()));
                break;
            case E2:
                op.setOp1(travel(op.getOp1()));
                op.setOp2(travel(op.getOp2()));
                break;
            case En:
                Value[] ops = op.getOps();
                for (int i = 0; i < ops.length; i++) {
                    ops[i] = travel(ops[i]);
                }
                break;
        }

        return op;
    }",loop_control
stmt,"{
        for (Stmt stmt : stmts) {
            travel(stmt);
        }
    }",iterator
op,"{
        switch (stmt.et) {
            case E0:
                break;
            case E1:
               travel(stmt.getOp());
                break;
            case E2:
                travel(stmt.getOp1());
                travel(stmt.getOp2());
                break;
            case En:
                Value[] ops = stmt.getOps();
                for (Value op : ops) {
                    travel(op);
                }
                break;
        }
    }",iterator
op1,"{
        switch (op.et) {
            case E0:
                break;
            case E1:
                travel(op.getOp());
                break;
            case E2:
                travel(op.getOp1());
                travel(op.getOp2());
                break;
            case En:
                Value[] ops = op.getOps();
                for (Value op1 : ops) {
                    travel(op1);
                }
                break;
        }
    }",iterator
trap,"{
        for (Trap trap : new ArrayList<Trap>(irMethod.traps)) {// copy the list and we can remove one from original list
            LabelStmt start = null;
            boolean removeTrap = true;
            for (Stmt p = trap.start.getNext(); p != null && p != trap.end;) {
                boolean notThrow = Cfg.notThrow(p);
                if (!notThrow) {
                    start = null;
                    p = p.getNext();
                    removeTrap = false;
                    continue;
                }
                switch (p.st) {
                case LABEL:
                    if (start != null) {
                        move4Label(irMethod.stmts, start, p.getPre(), (LabelStmt) p);
                    }
                    start = (LabelStmt) p;
                    p = p.getNext();

                    break;
                case GOTO:
                case RETURN:
                case RETURN_VOID:
                    if (start != null) {
                        Stmt tmp = p.getNext();
                        move4End(irMethod.stmts, start, p);
                        start = null;
                        p = tmp;
                    } else {
                        p = p.getNext();
                    }
                    break;
                default:
                    p = p.getNext();
                }
            }
            if (removeTrap) {
                irMethod.traps.remove(trap);
            }
        }
        StmtList stmts = irMethod.stmts;
        for (Stmt p = stmts.getFirst(); p != null; p = p.getNext()) {
            if (p.st == ST.GOTO) {
                LabelStmt target = ((GotoStmt) p).target;
                Stmt next = target.getNext();
                if (next != null && (next.st == ST.RETURN || next.st == ST.RETURN_VOID)) {
                    Stmt nnext = next.clone(keepLocal);
                    stmts.insertAfter(p, nnext);
                    stmts.remove(p);
                    p = nnext;
                }
            }
        }

    }",iterator
p,"{
        for (Trap trap : new ArrayList<Trap>(irMethod.traps)) {// copy the list and we can remove one from original list
            LabelStmt start = null;
            boolean removeTrap = true;
            for (Stmt p = trap.start.getNext(); p != null && p != trap.end;) {
                boolean notThrow = Cfg.notThrow(p);
                if (!notThrow) {
                    start = null;
                    p = p.getNext();
                    removeTrap = false;
                    continue;
                }
                switch (p.st) {
                case LABEL:
                    if (start != null) {
                        move4Label(irMethod.stmts, start, p.getPre(), (LabelStmt) p);
                    }
                    start = (LabelStmt) p;
                    p = p.getNext();

                    break;
                case GOTO:
                case RETURN:
                case RETURN_VOID:
                    if (start != null) {
                        Stmt tmp = p.getNext();
                        move4End(irMethod.stmts, start, p);
                        start = null;
                        p = tmp;
                    } else {
                        p = p.getNext();
                    }
                    break;
                default:
                    p = p.getNext();
                }
            }
            if (removeTrap) {
                irMethod.traps.remove(trap);
            }
        }
        StmtList stmts = irMethod.stmts;
        for (Stmt p = stmts.getFirst(); p != null; p = p.getNext()) {
            if (p.st == ST.GOTO) {
                LabelStmt target = ((GotoStmt) p).target;
                Stmt next = target.getNext();
                if (next != null && (next.st == ST.RETURN || next.st == ST.RETURN_VOID)) {
                    Stmt nnext = next.clone(keepLocal);
                    stmts.insertAfter(p, nnext);
                    stmts.remove(p);
                    p = nnext;
                }
            }
        }

    }",maybe_loop_control
p,"{
        for (Trap trap : new ArrayList<Trap>(irMethod.traps)) {// copy the list and we can remove one from original list
            LabelStmt start = null;
            boolean removeTrap = true;
            for (Stmt p = trap.start.getNext(); p != null && p != trap.end;) {
                boolean notThrow = Cfg.notThrow(p);
                if (!notThrow) {
                    start = null;
                    p = p.getNext();
                    removeTrap = false;
                    continue;
                }
                switch (p.st) {
                case LABEL:
                    if (start != null) {
                        move4Label(irMethod.stmts, start, p.getPre(), (LabelStmt) p);
                    }
                    start = (LabelStmt) p;
                    p = p.getNext();

                    break;
                case GOTO:
                case RETURN:
                case RETURN_VOID:
                    if (start != null) {
                        Stmt tmp = p.getNext();
                        move4End(irMethod.stmts, start, p);
                        start = null;
                        p = tmp;
                    } else {
                        p = p.getNext();
                    }
                    break;
                default:
                    p = p.getNext();
                }
            }
            if (removeTrap) {
                irMethod.traps.remove(trap);
            }
        }
        StmtList stmts = irMethod.stmts;
        for (Stmt p = stmts.getFirst(); p != null; p = p.getNext()) {
            if (p.st == ST.GOTO) {
                LabelStmt target = ((GotoStmt) p).target;
                Stmt next = target.getNext();
                if (next != null && (next.st == ST.RETURN || next.st == ST.RETURN_VOID)) {
                    Stmt nnext = next.clone(keepLocal);
                    stmts.insertAfter(p, nnext);
                    stmts.remove(p);
                    p = nnext;
                }
            }
        }

    }",maybe_loop_control
last,"{
        Stmt g1 = Stmts.nGoto(start);
        stmts.insertBefore(start, g1);
        Stmt last = stmts.getLast();
        while (last.st == ST.GOTO && ((GotoStmt) last).target == start) {
            stmts.remove(last);
            last = stmts.getLast();
        }
        stmts.move(start, end, last);

    }",maybe_loop_control
p,"{
        boolean changed = false;
        List<AssignStmt> assignStmtList = new ArrayList<>();

        for (Stmt p = method.stmts.getFirst(); p != null; p = p.getNext()) {
            if (p.st == Stmt.ST.ASSIGN) {
                AssignStmt as = (AssignStmt) p;
                if (as.getOp1().vt == Value.VT.LOCAL && as.getOp2().vt == Value.VT.CONSTANT) {
                    Constant cst = (Constant) as.getOp2();
                    Object value = cst.value;
                    if (value instanceof Number && !((value instanceof Long) || (value instanceof Double))) {
                        int v = ((Number) value).intValue();
                        if (v == 0 || v == 1) {
                            assignStmtList.add(as);
                        }
                    }
                }
            }
        }
        if (assignStmtList.size() == 0) {
            return false;
        }
        List<LabelStmt> phiLabels = method.phiLabels;
        if (phiLabels != null) {
            for (AssignStmt as : assignStmtList) {
                Local local = (Local) as.getOp1();
                boolean first = true;
                for (LabelStmt labelStmt : phiLabels) {
                    for (AssignStmt phi : labelStmt.phis) {
                        Value[] vs = phi.getOp2().getOps();
                        for (int i = 0; i < vs.length; i++) {
                            Value v = vs[i];
                            if (v == local) {
                                if (first) {
                                    first = false;
                                } else {
                                    Local nLocal = Exprs.nLocal(-1);
                                    method.locals.add(nLocal);
                                    changed = true;
                                    method.stmts.insertBefore(as, Stmts.nAssign(nLocal, as.getOp2().clone()));
                                    vs[i] = nLocal;
                                }
                            }
                        }
                    }
                }
            }
        }
        return changed;
    }",maybe_loop_control
as,"{
        boolean changed = false;
        List<AssignStmt> assignStmtList = new ArrayList<>();

        for (Stmt p = method.stmts.getFirst(); p != null; p = p.getNext()) {
            if (p.st == Stmt.ST.ASSIGN) {
                AssignStmt as = (AssignStmt) p;
                if (as.getOp1().vt == Value.VT.LOCAL && as.getOp2().vt == Value.VT.CONSTANT) {
                    Constant cst = (Constant) as.getOp2();
                    Object value = cst.value;
                    if (value instanceof Number && !((value instanceof Long) || (value instanceof Double))) {
                        int v = ((Number) value).intValue();
                        if (v == 0 || v == 1) {
                            assignStmtList.add(as);
                        }
                    }
                }
            }
        }
        if (assignStmtList.size() == 0) {
            return false;
        }
        List<LabelStmt> phiLabels = method.phiLabels;
        if (phiLabels != null) {
            for (AssignStmt as : assignStmtList) {
                Local local = (Local) as.getOp1();
                boolean first = true;
                for (LabelStmt labelStmt : phiLabels) {
                    for (AssignStmt phi : labelStmt.phis) {
                        Value[] vs = phi.getOp2().getOps();
                        for (int i = 0; i < vs.length; i++) {
                            Value v = vs[i];
                            if (v == local) {
                                if (first) {
                                    first = false;
                                } else {
                                    Local nLocal = Exprs.nLocal(-1);
                                    method.locals.add(nLocal);
                                    changed = true;
                                    method.stmts.insertBefore(as, Stmts.nAssign(nLocal, as.getOp2().clone()));
                                    vs[i] = nLocal;
                                }
                            }
                        }
                    }
                }
            }
        }
        return changed;
    }",iterator
labelStmt,"{
        boolean changed = false;
        List<AssignStmt> assignStmtList = new ArrayList<>();

        for (Stmt p = method.stmts.getFirst(); p != null; p = p.getNext()) {
            if (p.st == Stmt.ST.ASSIGN) {
                AssignStmt as = (AssignStmt) p;
                if (as.getOp1().vt == Value.VT.LOCAL && as.getOp2().vt == Value.VT.CONSTANT) {
                    Constant cst = (Constant) as.getOp2();
                    Object value = cst.value;
                    if (value instanceof Number && !((value instanceof Long) || (value instanceof Double))) {
                        int v = ((Number) value).intValue();
                        if (v == 0 || v == 1) {
                            assignStmtList.add(as);
                        }
                    }
                }
            }
        }
        if (assignStmtList.size() == 0) {
            return false;
        }
        List<LabelStmt> phiLabels = method.phiLabels;
        if (phiLabels != null) {
            for (AssignStmt as : assignStmtList) {
                Local local = (Local) as.getOp1();
                boolean first = true;
                for (LabelStmt labelStmt : phiLabels) {
                    for (AssignStmt phi : labelStmt.phis) {
                        Value[] vs = phi.getOp2().getOps();
                        for (int i = 0; i < vs.length; i++) {
                            Value v = vs[i];
                            if (v == local) {
                                if (first) {
                                    first = false;
                                } else {
                                    Local nLocal = Exprs.nLocal(-1);
                                    method.locals.add(nLocal);
                                    changed = true;
                                    method.stmts.insertBefore(as, Stmts.nAssign(nLocal, as.getOp2().clone()));
                                    vs[i] = nLocal;
                                }
                            }
                        }
                    }
                }
            }
        }
        return changed;
    }",iterator
phi,"{
        boolean changed = false;
        List<AssignStmt> assignStmtList = new ArrayList<>();

        for (Stmt p = method.stmts.getFirst(); p != null; p = p.getNext()) {
            if (p.st == Stmt.ST.ASSIGN) {
                AssignStmt as = (AssignStmt) p;
                if (as.getOp1().vt == Value.VT.LOCAL && as.getOp2().vt == Value.VT.CONSTANT) {
                    Constant cst = (Constant) as.getOp2();
                    Object value = cst.value;
                    if (value instanceof Number && !((value instanceof Long) || (value instanceof Double))) {
                        int v = ((Number) value).intValue();
                        if (v == 0 || v == 1) {
                            assignStmtList.add(as);
                        }
                    }
                }
            }
        }
        if (assignStmtList.size() == 0) {
            return false;
        }
        List<LabelStmt> phiLabels = method.phiLabels;
        if (phiLabels != null) {
            for (AssignStmt as : assignStmtList) {
                Local local = (Local) as.getOp1();
                boolean first = true;
                for (LabelStmt labelStmt : phiLabels) {
                    for (AssignStmt phi : labelStmt.phis) {
                        Value[] vs = phi.getOp2().getOps();
                        for (int i = 0; i < vs.length; i++) {
                            Value v = vs[i];
                            if (v == local) {
                                if (first) {
                                    first = false;
                                } else {
                                    Local nLocal = Exprs.nLocal(-1);
                                    method.locals.add(nLocal);
                                    changed = true;
                                    method.stmts.insertBefore(as, Stmts.nAssign(nLocal, as.getOp2().clone()));
                                    vs[i] = nLocal;
                                }
                            }
                        }
                    }
                }
            }
        }
        return changed;
    }",iterator
i,"{
        boolean changed = false;
        List<AssignStmt> assignStmtList = new ArrayList<>();

        for (Stmt p = method.stmts.getFirst(); p != null; p = p.getNext()) {
            if (p.st == Stmt.ST.ASSIGN) {
                AssignStmt as = (AssignStmt) p;
                if (as.getOp1().vt == Value.VT.LOCAL && as.getOp2().vt == Value.VT.CONSTANT) {
                    Constant cst = (Constant) as.getOp2();
                    Object value = cst.value;
                    if (value instanceof Number && !((value instanceof Long) || (value instanceof Double))) {
                        int v = ((Number) value).intValue();
                        if (v == 0 || v == 1) {
                            assignStmtList.add(as);
                        }
                    }
                }
            }
        }
        if (assignStmtList.size() == 0) {
            return false;
        }
        List<LabelStmt> phiLabels = method.phiLabels;
        if (phiLabels != null) {
            for (AssignStmt as : assignStmtList) {
                Local local = (Local) as.getOp1();
                boolean first = true;
                for (LabelStmt labelStmt : phiLabels) {
                    for (AssignStmt phi : labelStmt.phis) {
                        Value[] vs = phi.getOp2().getOps();
                        for (int i = 0; i < vs.length; i++) {
                            Value v = vs[i];
                            if (v == local) {
                                if (first) {
                                    first = false;
                                } else {
                                    Local nLocal = Exprs.nLocal(-1);
                                    method.locals.add(nLocal);
                                    changed = true;
                                    method.stmts.insertBefore(as, Stmts.nAssign(nLocal, as.getOp2().clone()));
                                    vs[i] = nLocal;
                                }
                            }
                        }
                    }
                }
            }
        }
        return changed;
    }",loop_control
local,"{
        int i = 0;
        for (Local local : method.locals) {
            local.tag = null;
            local._ls_index = i++;
        }
    }",iterator
it,"{
        for (Iterator<Stmt> it = method.stmts.iterator(); it.hasNext(); ) {
            Stmt stmt = it.next();
            if (!stmt.visited && stmt.st != ST.LABEL) {
                it.remove();
            }
        }
    }",iterator
p,"{
        final List<Local> locals = method.locals;
        locals.clear();
        StmtList stmts = method.stmts;

        TravelCallBack tcb = new TravelCallBack() {

            @Override
            public Value onAssign(Local a, AssignStmt as) {
                if (a._ls_index < 0) {
                    locals.add(a);
                    return a;
                }
                SSAValue lsv = (SSAValue) a.tag;
                Local b = lsv.local;
                locals.add(b);
                return b;
            }

            @Override
            public Value onUse(Local a) {
                if (a._ls_index < 0) {
                    return a;
                }
                SSAValue lsv = (SSAValue) a.tag;
                Local b = lsv.local;
                return b;
            }

        };
        Set<Value> froms = new HashSet<>();
        List<LabelStmt> phiLabels = new ArrayList<>();
        // 2. we are looking for Phis and insert Phi node to the code
        for (Stmt p = stmts.getFirst(); p != null; p = p.getNext()) {
            if (p.st == ST.LABEL) {
                LabelStmt labelStmt = (LabelStmt) p;
                List<AssignStmt> phis = null;
                SSAValue[] frame = (SSAValue[]) p.frame;
                if (frame != null) {
                    for (SSAValue v : frame) {
                        if (v == null || !v.used) {
                            continue;
                        }
                        if (v.parent != null) {
                            froms.add(v.parent.local);
                        }
                        if (v.otherParents != null) {
                            for (SSAValue parent : v.otherParents) {
                                froms.add(parent.local);
                            }
                        }
                        froms.remove(v.local);
                        if (phis == null) {
                            phis = new ArrayList<>();
                        }
                        locals.add(v.local);
                        phis.add(Stmts.nAssign(v.local, Exprs.nPhi(froms.toArray(new Value[froms.size()]))));
                        froms.clear();
                    }
                }
                labelStmt.phis = phis;
                if (phis != null) {
                    phiLabels.add(labelStmt);
                }
            } else {
                Cfg.travelMod(p, tcb, true);
            }
            p.frame = null;
        }
        if (phiLabels.size() > 0) {
            method.phiLabels = phiLabels;
        }
    }",maybe_loop_control
v,"{
        final List<Local> locals = method.locals;
        locals.clear();
        StmtList stmts = method.stmts;

        TravelCallBack tcb = new TravelCallBack() {

            @Override
            public Value onAssign(Local a, AssignStmt as) {
                if (a._ls_index < 0) {
                    locals.add(a);
                    return a;
                }
                SSAValue lsv = (SSAValue) a.tag;
                Local b = lsv.local;
                locals.add(b);
                return b;
            }

            @Override
            public Value onUse(Local a) {
                if (a._ls_index < 0) {
                    return a;
                }
                SSAValue lsv = (SSAValue) a.tag;
                Local b = lsv.local;
                return b;
            }

        };
        Set<Value> froms = new HashSet<>();
        List<LabelStmt> phiLabels = new ArrayList<>();
        // 2. we are looking for Phis and insert Phi node to the code
        for (Stmt p = stmts.getFirst(); p != null; p = p.getNext()) {
            if (p.st == ST.LABEL) {
                LabelStmt labelStmt = (LabelStmt) p;
                List<AssignStmt> phis = null;
                SSAValue[] frame = (SSAValue[]) p.frame;
                if (frame != null) {
                    for (SSAValue v : frame) {
                        if (v == null || !v.used) {
                            continue;
                        }
                        if (v.parent != null) {
                            froms.add(v.parent.local);
                        }
                        if (v.otherParents != null) {
                            for (SSAValue parent : v.otherParents) {
                                froms.add(parent.local);
                            }
                        }
                        froms.remove(v.local);
                        if (phis == null) {
                            phis = new ArrayList<>();
                        }
                        locals.add(v.local);
                        phis.add(Stmts.nAssign(v.local, Exprs.nPhi(froms.toArray(new Value[froms.size()]))));
                        froms.clear();
                    }
                }
                labelStmt.phis = phis;
                if (phis != null) {
                    phiLabels.add(labelStmt);
                }
            } else {
                Cfg.travelMod(p, tcb, true);
            }
            p.frame = null;
        }
        if (phiLabels.size() > 0) {
            method.phiLabels = phiLabels;
        }
    }",iterator
local,"{
        int index = Cfg.reIndexLocal(method);

        final int readCounts[] = new int[index];
        final int writeCounts[] = new int[index];
        Cfg.travel(method.stmts, new TravelCallBack() {
            @Override
            public Value onAssign(Local v, AssignStmt as) {
                writeCounts[v._ls_index]++;
                return v;
            }

            @Override
            public Value onUse(Local v) {
                readCounts[v._ls_index]++;
                return v;
            }
        }, true);

        boolean needTravel = false;
        boolean needSSAAnalyze = false;
        index = 0;
        List<Local> oldLocals = method.locals;
        List<Local> locals = new ArrayList<>(oldLocals);
        oldLocals.clear();

        for (Local local : locals) {
            int idx = local._ls_index;
            int read = readCounts[idx];
            int write = writeCounts[idx];
            if (read > 0 && write == 0) {
                // TODO if we need throw exception ?
                // or the code is dead?
            }

            if (read == 0 && write == 0) {
                // ignore the local
            } else {
                if (write <= 1) {
                    // no phi require
                    local._ls_index = -1;
                    oldLocals.add(local);
                } else if (read == 0) {
                    local._ls_index = -2;
                    needTravel = true;
                    // we are going to duplicate each usage of the local and add to method.locals,
                    // so not add the original local to method.locals
                } else {
                    needSSAAnalyze = true;
                    local._ls_index = index++;
                    oldLocals.add(local);
                }
            }
        }
        if (needSSAAnalyze || needTravel) {
            Cfg.travelMod(method.stmts, new TravelCallBack() {

                @Override
                public Value onAssign(Local v, AssignStmt as) {
                    if (v._ls_index == -1) {
                        return v;
                    } else if (v._ls_index == -2) {
                        Local n = (Local) v.clone();
                        method.locals.add(n);
                        return n;
                    }
                    // others
                    return v.clone();
                }

                @Override
                public Value onUse(Local v) {
                    if (v._ls_index == -1) {
                        return v;
                    }
                    return v.clone();
                }
            }, true);
        }
        return needSSAAnalyze;
    }",iterator
v0,"{
            Set<SSAValue> set = markUsed();
            aValues.clear();
            aValues = null;
            if (DEBUG) {
                clearLsEmptyValueFromFrame();
            }
            for (SSAValue v0 : set) {
                SSAValue v = v0;
                if (v.used && v.local == null) {
                    v.local = new Local(nextIndex++);
                }
            }
        }",iterator
p,"{
            for (Stmt p = method.stmts.getFirst(); p != null; p = p.getNext()) {
                SSAValue[] frame = (SSAValue[]) p.frame;
                if (frame != null) {
                    for (int i = 0; i < frame.length; i++) {
                        SSAValue r = frame[i];
                        if (r != null && !r.used) {
                            frame[i] = null;
                        }
                    }
                }
            }
        }",maybe_loop_control
q,"{
            Set<SSAValue> used = new HashSet<SSAValue>(aValues.size() / 2);
            Queue<SSAValue> q = new UniqueQueue<>();
            q.addAll(aValues);
            while (!q.isEmpty()) {
                SSAValue v = q.poll();
                if (v.used) {
                    used.add(v);
                    {
                        SSAValue p = v.parent;
                        if (p != null) {
                            if (!p.used) {
                                p.used = true;
                                q.add(p);
                            }
                        }
                    }
                    if (v.otherParents != null) {
                        for (SSAValue p : v.otherParents) {
                            if (!p.used) {
                                p.used = true;
                                q.add(p);
                            }
                        }
                    }

                }
            }
            return used;
        }",maybe_loop_control
p,"{
            Set<SSAValue> used = new HashSet<SSAValue>(aValues.size() / 2);
            Queue<SSAValue> q = new UniqueQueue<>();
            q.addAll(aValues);
            while (!q.isEmpty()) {
                SSAValue v = q.poll();
                if (v.used) {
                    used.add(v);
                    {
                        SSAValue p = v.parent;
                        if (p != null) {
                            if (!p.used) {
                                p.used = true;
                                q.add(p);
                            }
                        }
                    }
                    if (v.otherParents != null) {
                        for (SSAValue p : v.otherParents) {
                            if (!p.used) {
                                p.used = true;
                                q.add(p);
                            }
                        }
                    }

                }
            }
            return used;
        }",iterator
i,"{
            for (int i = 0; i < localSize; i++) {
                SSAValue srcValue = (SSAValue) frame[i];
                if (srcValue != null) {
                    SSAValue distValue = (SSAValue) distFrame[i];
                    if (distValue == null) {
                        if (!dist.visited) {
                            distValue = newValue();
                            aValues.add(distValue);
                            distFrame[i] = distValue;
                            linkParentChildren(srcValue, distValue);
                        }
                    } else {
                        linkParentChildren(srcValue, distValue);
                    }
                }
            }
        }",loop_control
labelStmt,"{
        for (LabelStmt labelStmt : phiLabels) {
            List<AssignStmt> phis = (List<AssignStmt>) labelStmt.phis;

            for (AssignStmt phi : phis) {

                Local a = (Local) phi.getOp1();
                PhiExpr b = (PhiExpr) phi.getOp2();
                boolean introduceNewLocal = false;
                RegAssign aReg = (RegAssign) a.tag;
                for (Value op : b.getOps()) {
                    RegAssign bReg = (RegAssign) ((Local) op).tag;
                    if (aReg.excludes.contains(bReg)) {
                        introduceNewLocal = true;
                        break;
                    }
                }
                if (introduceNewLocal) {
                    Local newLocal = (Local) a.clone();
                    if (DEBUG) {
                        newLocal.debugName = ""x"" + method.locals.size();
                    }
                    phi.op1 = newLocal;
                    RegAssign newRegAssign = new RegAssign();
                    newLocal.tag = newRegAssign;

                    method.locals.add(newLocal);
                    Stmt newAssigStmt = Stmts.nAssign(a, newLocal);
                    Stmt next = labelStmt.getNext();
                    if (next != null && next.st == ST.IDENTITY && next.getOp2().vt == VT.EXCEPTION_REF) {
                        // it's a handler, insert after the exception ref
                        method.stmts.insertAfter(next, newAssigStmt);
                    } else {
                        method.stmts.insertAfter(labelStmt, newAssigStmt);
                    }
                    LiveV[] frame = (LiveV[]) labelStmt.frame;
                    if (DEBUG) {
                        LiveV[] copy = frame.clone();
                        LiveV n = new LiveV();
                        n.local = a;
                        n.used = true;
                        copy[a._ls_index] = new LiveV();
                        newAssigStmt.frame = copy;
                    }
                    LiveV thePhi = frame[a._ls_index];
                    thePhi.local = newLocal;
                    for (LiveV v : frame) {
                        if (v != null && v.used) {
                            RegAssign s = (RegAssign) v.local.tag;
                            s.excludes.add(newRegAssign);
                            newRegAssign.excludes.add(s);
                        }
                    }

                }
            }
        }
    }",iterator
phi,"{
        for (LabelStmt labelStmt : phiLabels) {
            List<AssignStmt> phis = (List<AssignStmt>) labelStmt.phis;

            for (AssignStmt phi : phis) {

                Local a = (Local) phi.getOp1();
                PhiExpr b = (PhiExpr) phi.getOp2();
                boolean introduceNewLocal = false;
                RegAssign aReg = (RegAssign) a.tag;
                for (Value op : b.getOps()) {
                    RegAssign bReg = (RegAssign) ((Local) op).tag;
                    if (aReg.excludes.contains(bReg)) {
                        introduceNewLocal = true;
                        break;
                    }
                }
                if (introduceNewLocal) {
                    Local newLocal = (Local) a.clone();
                    if (DEBUG) {
                        newLocal.debugName = ""x"" + method.locals.size();
                    }
                    phi.op1 = newLocal;
                    RegAssign newRegAssign = new RegAssign();
                    newLocal.tag = newRegAssign;

                    method.locals.add(newLocal);
                    Stmt newAssigStmt = Stmts.nAssign(a, newLocal);
                    Stmt next = labelStmt.getNext();
                    if (next != null && next.st == ST.IDENTITY && next.getOp2().vt == VT.EXCEPTION_REF) {
                        // it's a handler, insert after the exception ref
                        method.stmts.insertAfter(next, newAssigStmt);
                    } else {
                        method.stmts.insertAfter(labelStmt, newAssigStmt);
                    }
                    LiveV[] frame = (LiveV[]) labelStmt.frame;
                    if (DEBUG) {
                        LiveV[] copy = frame.clone();
                        LiveV n = new LiveV();
                        n.local = a;
                        n.used = true;
                        copy[a._ls_index] = new LiveV();
                        newAssigStmt.frame = copy;
                    }
                    LiveV thePhi = frame[a._ls_index];
                    thePhi.local = newLocal;
                    for (LiveV v : frame) {
                        if (v != null && v.used) {
                            RegAssign s = (RegAssign) v.local.tag;
                            s.excludes.add(newRegAssign);
                            newRegAssign.excludes.add(s);
                        }
                    }

                }
            }
        }
    }",iterator
op,"{
        for (LabelStmt labelStmt : phiLabels) {
            List<AssignStmt> phis = (List<AssignStmt>) labelStmt.phis;

            for (AssignStmt phi : phis) {

                Local a = (Local) phi.getOp1();
                PhiExpr b = (PhiExpr) phi.getOp2();
                boolean introduceNewLocal = false;
                RegAssign aReg = (RegAssign) a.tag;
                for (Value op : b.getOps()) {
                    RegAssign bReg = (RegAssign) ((Local) op).tag;
                    if (aReg.excludes.contains(bReg)) {
                        introduceNewLocal = true;
                        break;
                    }
                }
                if (introduceNewLocal) {
                    Local newLocal = (Local) a.clone();
                    if (DEBUG) {
                        newLocal.debugName = ""x"" + method.locals.size();
                    }
                    phi.op1 = newLocal;
                    RegAssign newRegAssign = new RegAssign();
                    newLocal.tag = newRegAssign;

                    method.locals.add(newLocal);
                    Stmt newAssigStmt = Stmts.nAssign(a, newLocal);
                    Stmt next = labelStmt.getNext();
                    if (next != null && next.st == ST.IDENTITY && next.getOp2().vt == VT.EXCEPTION_REF) {
                        // it's a handler, insert after the exception ref
                        method.stmts.insertAfter(next, newAssigStmt);
                    } else {
                        method.stmts.insertAfter(labelStmt, newAssigStmt);
                    }
                    LiveV[] frame = (LiveV[]) labelStmt.frame;
                    if (DEBUG) {
                        LiveV[] copy = frame.clone();
                        LiveV n = new LiveV();
                        n.local = a;
                        n.used = true;
                        copy[a._ls_index] = new LiveV();
                        newAssigStmt.frame = copy;
                    }
                    LiveV thePhi = frame[a._ls_index];
                    thePhi.local = newLocal;
                    for (LiveV v : frame) {
                        if (v != null && v.used) {
                            RegAssign s = (RegAssign) v.local.tag;
                            s.excludes.add(newRegAssign);
                            newRegAssign.excludes.add(s);
                        }
                    }

                }
            }
        }
    }",iterator
aReg,"{
        for (LabelStmt labelStmt : phiLabels) {
            List<AssignStmt> phis = (List<AssignStmt>) labelStmt.phis;

            for (AssignStmt phi : phis) {

                Local a = (Local) phi.getOp1();
                PhiExpr b = (PhiExpr) phi.getOp2();
                boolean introduceNewLocal = false;
                RegAssign aReg = (RegAssign) a.tag;
                for (Value op : b.getOps()) {
                    RegAssign bReg = (RegAssign) ((Local) op).tag;
                    if (aReg.excludes.contains(bReg)) {
                        introduceNewLocal = true;
                        break;
                    }
                }
                if (introduceNewLocal) {
                    Local newLocal = (Local) a.clone();
                    if (DEBUG) {
                        newLocal.debugName = ""x"" + method.locals.size();
                    }
                    phi.op1 = newLocal;
                    RegAssign newRegAssign = new RegAssign();
                    newLocal.tag = newRegAssign;

                    method.locals.add(newLocal);
                    Stmt newAssigStmt = Stmts.nAssign(a, newLocal);
                    Stmt next = labelStmt.getNext();
                    if (next != null && next.st == ST.IDENTITY && next.getOp2().vt == VT.EXCEPTION_REF) {
                        // it's a handler, insert after the exception ref
                        method.stmts.insertAfter(next, newAssigStmt);
                    } else {
                        method.stmts.insertAfter(labelStmt, newAssigStmt);
                    }
                    LiveV[] frame = (LiveV[]) labelStmt.frame;
                    if (DEBUG) {
                        LiveV[] copy = frame.clone();
                        LiveV n = new LiveV();
                        n.local = a;
                        n.used = true;
                        copy[a._ls_index] = new LiveV();
                        newAssigStmt.frame = copy;
                    }
                    LiveV thePhi = frame[a._ls_index];
                    thePhi.local = newLocal;
                    for (LiveV v : frame) {
                        if (v != null && v.used) {
                            RegAssign s = (RegAssign) v.local.tag;
                            s.excludes.add(newRegAssign);
                            newRegAssign.excludes.add(s);
                        }
                    }

                }
            }
        }
    }",break_loop_control
v,"{
        for (LabelStmt labelStmt : phiLabels) {
            List<AssignStmt> phis = (List<AssignStmt>) labelStmt.phis;

            for (AssignStmt phi : phis) {

                Local a = (Local) phi.getOp1();
                PhiExpr b = (PhiExpr) phi.getOp2();
                boolean introduceNewLocal = false;
                RegAssign aReg = (RegAssign) a.tag;
                for (Value op : b.getOps()) {
                    RegAssign bReg = (RegAssign) ((Local) op).tag;
                    if (aReg.excludes.contains(bReg)) {
                        introduceNewLocal = true;
                        break;
                    }
                }
                if (introduceNewLocal) {
                    Local newLocal = (Local) a.clone();
                    if (DEBUG) {
                        newLocal.debugName = ""x"" + method.locals.size();
                    }
                    phi.op1 = newLocal;
                    RegAssign newRegAssign = new RegAssign();
                    newLocal.tag = newRegAssign;

                    method.locals.add(newLocal);
                    Stmt newAssigStmt = Stmts.nAssign(a, newLocal);
                    Stmt next = labelStmt.getNext();
                    if (next != null && next.st == ST.IDENTITY && next.getOp2().vt == VT.EXCEPTION_REF) {
                        // it's a handler, insert after the exception ref
                        method.stmts.insertAfter(next, newAssigStmt);
                    } else {
                        method.stmts.insertAfter(labelStmt, newAssigStmt);
                    }
                    LiveV[] frame = (LiveV[]) labelStmt.frame;
                    if (DEBUG) {
                        LiveV[] copy = frame.clone();
                        LiveV n = new LiveV();
                        n.local = a;
                        n.used = true;
                        copy[a._ls_index] = new LiveV();
                        newAssigStmt.frame = copy;
                    }
                    LiveV thePhi = frame[a._ls_index];
                    thePhi.local = newLocal;
                    for (LiveV v : frame) {
                        if (v != null && v.used) {
                            RegAssign s = (RegAssign) v.local.tag;
                            s.excludes.add(newRegAssign);
                            newRegAssign.excludes.add(s);
                        }
                    }

                }
            }
        }
    }",loop_control
labelStmt,"{
        // FIXME the phi in Exception handler is buggy
        List<AssignStmt> buff = new ArrayList<>();
        for (LabelStmt labelStmt : phiLabels) {
            List<AssignStmt> phis = (List<AssignStmt>) labelStmt.phis;
            LiveV[] frame = (LiveV[]) labelStmt.frame;
            for (Stmt from : labelStmt._cfg_froms) {
                if (from.visited) { // at lease it is reached by cfg
                    for (AssignStmt phi : phis) {
                        Local a = (Local) phi.getOp1();
                        LiveV v = frame[a._ls_index];
                        Local local = v.stmt2regMap.get(from);
                        if (local != a) {
                            buff.add(Stmts.nAssign(a, local));
                        }
                    }
                    insertAssignPath(method.stmts, from, labelStmt, buff);
                    buff.clear();
                }
            }
        }
    }",iterator
from,"{
        // FIXME the phi in Exception handler is buggy
        List<AssignStmt> buff = new ArrayList<>();
        for (LabelStmt labelStmt : phiLabels) {
            List<AssignStmt> phis = (List<AssignStmt>) labelStmt.phis;
            LiveV[] frame = (LiveV[]) labelStmt.frame;
            for (Stmt from : labelStmt._cfg_froms) {
                if (from.visited) { // at lease it is reached by cfg
                    for (AssignStmt phi : phis) {
                        Local a = (Local) phi.getOp1();
                        LiveV v = frame[a._ls_index];
                        Local local = v.stmt2regMap.get(from);
                        if (local != a) {
                            buff.add(Stmts.nAssign(a, local));
                        }
                    }
                    insertAssignPath(method.stmts, from, labelStmt, buff);
                    buff.clear();
                }
            }
        }
    }",iterator
phi,"{
        // FIXME the phi in Exception handler is buggy
        List<AssignStmt> buff = new ArrayList<>();
        for (LabelStmt labelStmt : phiLabels) {
            List<AssignStmt> phis = (List<AssignStmt>) labelStmt.phis;
            LiveV[] frame = (LiveV[]) labelStmt.frame;
            for (Stmt from : labelStmt._cfg_froms) {
                if (from.visited) { // at lease it is reached by cfg
                    for (AssignStmt phi : phis) {
                        Local a = (Local) phi.getOp1();
                        LiveV v = frame[a._ls_index];
                        Local local = v.stmt2regMap.get(from);
                        if (local != a) {
                            buff.add(Stmts.nAssign(a, local));
                        }
                    }
                    insertAssignPath(method.stmts, from, labelStmt, buff);
                    buff.clear();
                }
            }
        }
    }",iterator
as,"{
        boolean insertBeforeFromStmt;
        if (from.exceptionHandlers != null && from.exceptionHandlers.contains(labelStmt)) {
            insertBeforeFromStmt = true;
        } else {
            switch (from.st) {
            case GOTO:
            case IF:
                JumpStmt jumpStmt = (JumpStmt) from;
                insertBeforeFromStmt = jumpStmt.getTarget().equals(labelStmt); //
                break;
            case TABLE_SWITCH:
            case LOOKUP_SWITCH:
                insertBeforeFromStmt = true;
                break;
            default:
                insertBeforeFromStmt = false;
                break;
            }
        }
        if (insertBeforeFromStmt) {
            for (AssignStmt as : buff) {
                stmts.insertBefore(from, as);
            }
        } else {
            for (AssignStmt as : buff) {
                stmts.insertAfter(from, as);
            }
        }
        LiveV[] frame = (LiveV[]) from.frame;
        List<LiveV> newLiveVs = new ArrayList<>(buff.size());
        for (AssignStmt as : buff) {
            Local left = (Local) as.getOp1();
            {
                LiveV liveV = new LiveV();
                liveV.local = left;
                liveV.used = true;
                newLiveVs.add(liveV);
            }
            RegAssign leftRegAssign = (RegAssign) left.tag;
            Local right = (Local) as.getOp2();
            int toSkip = right._ls_index;
            for (int i = 0; i < frame.length; i++) {
                if (i == toSkip) {
                    continue;
                }
                LiveV v = frame[i];
                if (v != null && v.used) {
                    RegAssign assign = (RegAssign) v.local.tag;
                    assign.excludes.add(leftRegAssign);
                    leftRegAssign.excludes.add(assign);
                }
            }
            for (AssignStmt as2 : buff) {
                RegAssign assign = (RegAssign) ((Local) as2.getOp1()).tag;
                assign.excludes.add(leftRegAssign);
                leftRegAssign.excludes.add(assign);
            }
        }

        LiveV[] newFrame = new LiveV[frame.length + newLiveVs.size()];
        System.arraycopy(frame, 0, newFrame, 0, frame.length);
        for (int i = 0; i < newLiveVs.size(); i++) {
            newFrame[i + frame.length] = newLiveVs.get(i);
        }

    }",iterator
i,"{
        boolean insertBeforeFromStmt;
        if (from.exceptionHandlers != null && from.exceptionHandlers.contains(labelStmt)) {
            insertBeforeFromStmt = true;
        } else {
            switch (from.st) {
            case GOTO:
            case IF:
                JumpStmt jumpStmt = (JumpStmt) from;
                insertBeforeFromStmt = jumpStmt.getTarget().equals(labelStmt); //
                break;
            case TABLE_SWITCH:
            case LOOKUP_SWITCH:
                insertBeforeFromStmt = true;
                break;
            default:
                insertBeforeFromStmt = false;
                break;
            }
        }
        if (insertBeforeFromStmt) {
            for (AssignStmt as : buff) {
                stmts.insertBefore(from, as);
            }
        } else {
            for (AssignStmt as : buff) {
                stmts.insertAfter(from, as);
            }
        }
        LiveV[] frame = (LiveV[]) from.frame;
        List<LiveV> newLiveVs = new ArrayList<>(buff.size());
        for (AssignStmt as : buff) {
            Local left = (Local) as.getOp1();
            {
                LiveV liveV = new LiveV();
                liveV.local = left;
                liveV.used = true;
                newLiveVs.add(liveV);
            }
            RegAssign leftRegAssign = (RegAssign) left.tag;
            Local right = (Local) as.getOp2();
            int toSkip = right._ls_index;
            for (int i = 0; i < frame.length; i++) {
                if (i == toSkip) {
                    continue;
                }
                LiveV v = frame[i];
                if (v != null && v.used) {
                    RegAssign assign = (RegAssign) v.local.tag;
                    assign.excludes.add(leftRegAssign);
                    leftRegAssign.excludes.add(assign);
                }
            }
            for (AssignStmt as2 : buff) {
                RegAssign assign = (RegAssign) ((Local) as2.getOp1()).tag;
                assign.excludes.add(leftRegAssign);
                leftRegAssign.excludes.add(assign);
            }
        }

        LiveV[] newFrame = new LiveV[frame.length + newLiveVs.size()];
        System.arraycopy(frame, 0, newFrame, 0, frame.length);
        for (int i = 0; i < newLiveVs.size(); i++) {
            newFrame[i + frame.length] = newLiveVs.get(i);
        }

    }",loop_control
as2,"{
        boolean insertBeforeFromStmt;
        if (from.exceptionHandlers != null && from.exceptionHandlers.contains(labelStmt)) {
            insertBeforeFromStmt = true;
        } else {
            switch (from.st) {
            case GOTO:
            case IF:
                JumpStmt jumpStmt = (JumpStmt) from;
                insertBeforeFromStmt = jumpStmt.getTarget().equals(labelStmt); //
                break;
            case TABLE_SWITCH:
            case LOOKUP_SWITCH:
                insertBeforeFromStmt = true;
                break;
            default:
                insertBeforeFromStmt = false;
                break;
            }
        }
        if (insertBeforeFromStmt) {
            for (AssignStmt as : buff) {
                stmts.insertBefore(from, as);
            }
        } else {
            for (AssignStmt as : buff) {
                stmts.insertAfter(from, as);
            }
        }
        LiveV[] frame = (LiveV[]) from.frame;
        List<LiveV> newLiveVs = new ArrayList<>(buff.size());
        for (AssignStmt as : buff) {
            Local left = (Local) as.getOp1();
            {
                LiveV liveV = new LiveV();
                liveV.local = left;
                liveV.used = true;
                newLiveVs.add(liveV);
            }
            RegAssign leftRegAssign = (RegAssign) left.tag;
            Local right = (Local) as.getOp2();
            int toSkip = right._ls_index;
            for (int i = 0; i < frame.length; i++) {
                if (i == toSkip) {
                    continue;
                }
                LiveV v = frame[i];
                if (v != null && v.used) {
                    RegAssign assign = (RegAssign) v.local.tag;
                    assign.excludes.add(leftRegAssign);
                    leftRegAssign.excludes.add(assign);
                }
            }
            for (AssignStmt as2 : buff) {
                RegAssign assign = (RegAssign) ((Local) as2.getOp1()).tag;
                assign.excludes.add(leftRegAssign);
                leftRegAssign.excludes.add(assign);
            }
        }

        LiveV[] newFrame = new LiveV[frame.length + newLiveVs.size()];
        System.arraycopy(frame, 0, newFrame, 0, frame.length);
        for (int i = 0; i < newLiveVs.size(); i++) {
            newFrame[i + frame.length] = newLiveVs.get(i);
        }

    }",iterator
phiLabel,"{
        if (method.phiLabels == null || method.phiLabels.size() == 0) {
            return;
        }

        // fix issue in github 186
        // .?.....?.?.?.x?x.x..?x.?.??.x.... | L24e82f43: // [a15 = φ(a4, a23), a17 = φ(a5, a20)]
        // .?x....?.?.?.x?x.x..?x.?.??.x.... | L16e1a441: // [a2 = φ(a4, a15)]
        // the local a15 is fixed to x15 in fixPhi
        // .?.....?.?.?.x?x.x..?x.?.??.x.... | L24e82f43: // [x15 = φ(a4, a23), a17 = φ(a5, a20)]
        //                                   | a15 = x15
        // .?x....?.?.?.x?x.x..?x.?.??.x.... | L16e1a441: // [a2 = φ(a4, a15)]
        //  after that, when demote a2, it is inserted after L24e82f43, which will cause a15 undefined
        // .?.....?.?.?.x?x.x..?x.?.??.x.... | L24e82f43: // [x15 = φ(a4, a23), a17 = φ(a5, a20)]
        //                                   | a2 = a15
        //                                   | a15 = x15
        // .?x....?.?.?.x?x.x..?x.?.??.x.... | L16e1a441: // [a2 = φ(a4, a15)]

        // this is simple fix to github 186
        // insert a Nop between two LabelStmt if both have phis
        for (LabelStmt phiLabel : method.phiLabels) {
            Stmt stmt = phiLabel.getNext();
            if (stmt.st == ST.LABEL) {
                LabelStmt labelStmt2 = (LabelStmt) stmt;
                if (labelStmt2.phis != null && labelStmt2.phis.size() > 0) {
                    method.stmts.insertAfter(phiLabel, Stmts.nNop());
                }
            }
        }

        // 1. Live analyze the method,
        // a. remove Phi,
        // b. record parameter reference
        LiveA liveA = new LiveA(method);
        liveA.analyze();

        genRegGraph(method, liveA);

        // 2. insert x=y
        fixPhi(method, method.phiLabels);
        insertAssignPath(method, method.phiLabels);

        // 4. clean up
        for (Local local : method.locals) {
            local.tag = null;
        }
        for (Stmt stmt : method.stmts) {
            stmt.frame = null;
        }
        for (LabelStmt labelStmt : method.phiLabels) {
            labelStmt.phis = null;
        }
        method.phiLabels = null;
    }",iterator
local,"{
        if (method.phiLabels == null || method.phiLabels.size() == 0) {
            return;
        }

        // fix issue in github 186
        // .?.....?.?.?.x?x.x..?x.?.??.x.... | L24e82f43: // [a15 = φ(a4, a23), a17 = φ(a5, a20)]
        // .?x....?.?.?.x?x.x..?x.?.??.x.... | L16e1a441: // [a2 = φ(a4, a15)]
        // the local a15 is fixed to x15 in fixPhi
        // .?.....?.?.?.x?x.x..?x.?.??.x.... | L24e82f43: // [x15 = φ(a4, a23), a17 = φ(a5, a20)]
        //                                   | a15 = x15
        // .?x....?.?.?.x?x.x..?x.?.??.x.... | L16e1a441: // [a2 = φ(a4, a15)]
        //  after that, when demote a2, it is inserted after L24e82f43, which will cause a15 undefined
        // .?.....?.?.?.x?x.x..?x.?.??.x.... | L24e82f43: // [x15 = φ(a4, a23), a17 = φ(a5, a20)]
        //                                   | a2 = a15
        //                                   | a15 = x15
        // .?x....?.?.?.x?x.x..?x.?.??.x.... | L16e1a441: // [a2 = φ(a4, a15)]

        // this is simple fix to github 186
        // insert a Nop between two LabelStmt if both have phis
        for (LabelStmt phiLabel : method.phiLabels) {
            Stmt stmt = phiLabel.getNext();
            if (stmt.st == ST.LABEL) {
                LabelStmt labelStmt2 = (LabelStmt) stmt;
                if (labelStmt2.phis != null && labelStmt2.phis.size() > 0) {
                    method.stmts.insertAfter(phiLabel, Stmts.nNop());
                }
            }
        }

        // 1. Live analyze the method,
        // a. remove Phi,
        // b. record parameter reference
        LiveA liveA = new LiveA(method);
        liveA.analyze();

        genRegGraph(method, liveA);

        // 2. insert x=y
        fixPhi(method, method.phiLabels);
        insertAssignPath(method, method.phiLabels);

        // 4. clean up
        for (Local local : method.locals) {
            local.tag = null;
        }
        for (Stmt stmt : method.stmts) {
            stmt.frame = null;
        }
        for (LabelStmt labelStmt : method.phiLabels) {
            labelStmt.phis = null;
        }
        method.phiLabels = null;
    }",iterator
stmt,"{
        if (method.phiLabels == null || method.phiLabels.size() == 0) {
            return;
        }

        // fix issue in github 186
        // .?.....?.?.?.x?x.x..?x.?.??.x.... | L24e82f43: // [a15 = φ(a4, a23), a17 = φ(a5, a20)]
        // .?x....?.?.?.x?x.x..?x.?.??.x.... | L16e1a441: // [a2 = φ(a4, a15)]
        // the local a15 is fixed to x15 in fixPhi
        // .?.....?.?.?.x?x.x..?x.?.??.x.... | L24e82f43: // [x15 = φ(a4, a23), a17 = φ(a5, a20)]
        //                                   | a15 = x15
        // .?x....?.?.?.x?x.x..?x.?.??.x.... | L16e1a441: // [a2 = φ(a4, a15)]
        //  after that, when demote a2, it is inserted after L24e82f43, which will cause a15 undefined
        // .?.....?.?.?.x?x.x..?x.?.??.x.... | L24e82f43: // [x15 = φ(a4, a23), a17 = φ(a5, a20)]
        //                                   | a2 = a15
        //                                   | a15 = x15
        // .?x....?.?.?.x?x.x..?x.?.??.x.... | L16e1a441: // [a2 = φ(a4, a15)]

        // this is simple fix to github 186
        // insert a Nop between two LabelStmt if both have phis
        for (LabelStmt phiLabel : method.phiLabels) {
            Stmt stmt = phiLabel.getNext();
            if (stmt.st == ST.LABEL) {
                LabelStmt labelStmt2 = (LabelStmt) stmt;
                if (labelStmt2.phis != null && labelStmt2.phis.size() > 0) {
                    method.stmts.insertAfter(phiLabel, Stmts.nNop());
                }
            }
        }

        // 1. Live analyze the method,
        // a. remove Phi,
        // b. record parameter reference
        LiveA liveA = new LiveA(method);
        liveA.analyze();

        genRegGraph(method, liveA);

        // 2. insert x=y
        fixPhi(method, method.phiLabels);
        insertAssignPath(method, method.phiLabels);

        // 4. clean up
        for (Local local : method.locals) {
            local.tag = null;
        }
        for (Stmt stmt : method.stmts) {
            stmt.frame = null;
        }
        for (LabelStmt labelStmt : method.phiLabels) {
            labelStmt.phis = null;
        }
        method.phiLabels = null;
    }",iterator
labelStmt,"{
        if (method.phiLabels == null || method.phiLabels.size() == 0) {
            return;
        }

        // fix issue in github 186
        // .?.....?.?.?.x?x.x..?x.?.??.x.... | L24e82f43: // [a15 = φ(a4, a23), a17 = φ(a5, a20)]
        // .?x....?.?.?.x?x.x..?x.?.??.x.... | L16e1a441: // [a2 = φ(a4, a15)]
        // the local a15 is fixed to x15 in fixPhi
        // .?.....?.?.?.x?x.x..?x.?.??.x.... | L24e82f43: // [x15 = φ(a4, a23), a17 = φ(a5, a20)]
        //                                   | a15 = x15
        // .?x....?.?.?.x?x.x..?x.?.??.x.... | L16e1a441: // [a2 = φ(a4, a15)]
        //  after that, when demote a2, it is inserted after L24e82f43, which will cause a15 undefined
        // .?.....?.?.?.x?x.x..?x.?.??.x.... | L24e82f43: // [x15 = φ(a4, a23), a17 = φ(a5, a20)]
        //                                   | a2 = a15
        //                                   | a15 = x15
        // .?x....?.?.?.x?x.x..?x.?.??.x.... | L16e1a441: // [a2 = φ(a4, a15)]

        // this is simple fix to github 186
        // insert a Nop between two LabelStmt if both have phis
        for (LabelStmt phiLabel : method.phiLabels) {
            Stmt stmt = phiLabel.getNext();
            if (stmt.st == ST.LABEL) {
                LabelStmt labelStmt2 = (LabelStmt) stmt;
                if (labelStmt2.phis != null && labelStmt2.phis.size() > 0) {
                    method.stmts.insertAfter(phiLabel, Stmts.nNop());
                }
            }
        }

        // 1. Live analyze the method,
        // a. remove Phi,
        // b. record parameter reference
        LiveA liveA = new LiveA(method);
        liveA.analyze();

        genRegGraph(method, liveA);

        // 2. insert x=y
        fixPhi(method, method.phiLabels);
        insertAssignPath(method, method.phiLabels);

        // 4. clean up
        for (Local local : method.locals) {
            local.tag = null;
        }
        for (Stmt stmt : method.stmts) {
            stmt.frame = null;
        }
        for (LabelStmt labelStmt : method.phiLabels) {
            labelStmt.phis = null;
        }
        method.phiLabels = null;
    }",iterator
local,"{
        for (Local local : method.locals) {
            local.tag = new RegAssign();
        }

        Set<Stmt> tos = new HashSet<>();
        for (Stmt stmt : method.stmts) {
            if ((stmt.st == ST.ASSIGN || stmt.st == ST.IDENTITY) && stmt.getOp1().vt == VT.LOCAL) {
                Local localAssignTo = (Local) stmt.getOp1();
                RegAssign regAssignTo = (RegAssign) localAssignTo.tag;
                Set<Integer> excludeIdx = new HashSet<>();
                Cfg.collectTos(stmt, tos);
                for (Stmt target : tos) {
                    LiveV frame[] = (LiveV[]) target.frame;
                    if (frame == null) {
                        continue;
                    }
                    // exclude thisReg and phiReg
                    excludeIdx.clear();
                    excludeIdx.add(localAssignTo._ls_index);
                    if (target.st == ST.LABEL) {
                        LabelStmt label = (LabelStmt) target;
                        if (label.phis != null) {
                            for (AssignStmt phiAssignStmt : (List<AssignStmt>) label.phis) {
                                Local phiLocal = (Local) phiAssignStmt.getOp1();
                                excludeIdx.add(phiLocal._ls_index);
                            }
                        }
                    }
                    for (int i = 0; i < frame.length; i++) {
                        if (excludeIdx.contains(i)) {
                            continue;
                        }
                        LiveV v = frame[i];
                        if (v != null && v.used) {
                            RegAssign b = (RegAssign) v.local.tag;
                            regAssignTo.excludes.add(b);
                            b.excludes.add(regAssignTo);
                        }
                    }
                }
                tos.clear();
            } else if (stmt.st == ST.LABEL) { //
                // https://github.com/pxb1988/dex2jar/issues/477
                // the exception handler is dead and stmt.frame is null
                LabelStmt label = (LabelStmt) stmt;
                if (label.phis != null && stmt.frame != null) {
                    for (AssignStmt phiAssignStmt : (List<AssignStmt>) label.phis) {
                        Local phiLocal = (Local) phiAssignStmt.getOp1();
                        RegAssign a = (RegAssign) phiLocal.tag;
                        LiveV frame[] = (LiveV[]) stmt.frame;
                        for (LiveV v : frame) {
                            if (v != null && v.used) {
                                RegAssign b = (RegAssign) v.local.tag;
                                a.excludes.add(b);
                                b.excludes.add(a);
                            }
                        }
                    }
                }
            }
        }
        if (DEBUG) {
            System.out.println(liveA.toString());
        }
    }",iterator
stmt,"{
        for (Local local : method.locals) {
            local.tag = new RegAssign();
        }

        Set<Stmt> tos = new HashSet<>();
        for (Stmt stmt : method.stmts) {
            if ((stmt.st == ST.ASSIGN || stmt.st == ST.IDENTITY) && stmt.getOp1().vt == VT.LOCAL) {
                Local localAssignTo = (Local) stmt.getOp1();
                RegAssign regAssignTo = (RegAssign) localAssignTo.tag;
                Set<Integer> excludeIdx = new HashSet<>();
                Cfg.collectTos(stmt, tos);
                for (Stmt target : tos) {
                    LiveV frame[] = (LiveV[]) target.frame;
                    if (frame == null) {
                        continue;
                    }
                    // exclude thisReg and phiReg
                    excludeIdx.clear();
                    excludeIdx.add(localAssignTo._ls_index);
                    if (target.st == ST.LABEL) {
                        LabelStmt label = (LabelStmt) target;
                        if (label.phis != null) {
                            for (AssignStmt phiAssignStmt : (List<AssignStmt>) label.phis) {
                                Local phiLocal = (Local) phiAssignStmt.getOp1();
                                excludeIdx.add(phiLocal._ls_index);
                            }
                        }
                    }
                    for (int i = 0; i < frame.length; i++) {
                        if (excludeIdx.contains(i)) {
                            continue;
                        }
                        LiveV v = frame[i];
                        if (v != null && v.used) {
                            RegAssign b = (RegAssign) v.local.tag;
                            regAssignTo.excludes.add(b);
                            b.excludes.add(regAssignTo);
                        }
                    }
                }
                tos.clear();
            } else if (stmt.st == ST.LABEL) { //
                // https://github.com/pxb1988/dex2jar/issues/477
                // the exception handler is dead and stmt.frame is null
                LabelStmt label = (LabelStmt) stmt;
                if (label.phis != null && stmt.frame != null) {
                    for (AssignStmt phiAssignStmt : (List<AssignStmt>) label.phis) {
                        Local phiLocal = (Local) phiAssignStmt.getOp1();
                        RegAssign a = (RegAssign) phiLocal.tag;
                        LiveV frame[] = (LiveV[]) stmt.frame;
                        for (LiveV v : frame) {
                            if (v != null && v.used) {
                                RegAssign b = (RegAssign) v.local.tag;
                                a.excludes.add(b);
                                b.excludes.add(a);
                            }
                        }
                    }
                }
            }
        }
        if (DEBUG) {
            System.out.println(liveA.toString());
        }
    }",iterator
target,"{
        for (Local local : method.locals) {
            local.tag = new RegAssign();
        }

        Set<Stmt> tos = new HashSet<>();
        for (Stmt stmt : method.stmts) {
            if ((stmt.st == ST.ASSIGN || stmt.st == ST.IDENTITY) && stmt.getOp1().vt == VT.LOCAL) {
                Local localAssignTo = (Local) stmt.getOp1();
                RegAssign regAssignTo = (RegAssign) localAssignTo.tag;
                Set<Integer> excludeIdx = new HashSet<>();
                Cfg.collectTos(stmt, tos);
                for (Stmt target : tos) {
                    LiveV frame[] = (LiveV[]) target.frame;
                    if (frame == null) {
                        continue;
                    }
                    // exclude thisReg and phiReg
                    excludeIdx.clear();
                    excludeIdx.add(localAssignTo._ls_index);
                    if (target.st == ST.LABEL) {
                        LabelStmt label = (LabelStmt) target;
                        if (label.phis != null) {
                            for (AssignStmt phiAssignStmt : (List<AssignStmt>) label.phis) {
                                Local phiLocal = (Local) phiAssignStmt.getOp1();
                                excludeIdx.add(phiLocal._ls_index);
                            }
                        }
                    }
                    for (int i = 0; i < frame.length; i++) {
                        if (excludeIdx.contains(i)) {
                            continue;
                        }
                        LiveV v = frame[i];
                        if (v != null && v.used) {
                            RegAssign b = (RegAssign) v.local.tag;
                            regAssignTo.excludes.add(b);
                            b.excludes.add(regAssignTo);
                        }
                    }
                }
                tos.clear();
            } else if (stmt.st == ST.LABEL) { //
                // https://github.com/pxb1988/dex2jar/issues/477
                // the exception handler is dead and stmt.frame is null
                LabelStmt label = (LabelStmt) stmt;
                if (label.phis != null && stmt.frame != null) {
                    for (AssignStmt phiAssignStmt : (List<AssignStmt>) label.phis) {
                        Local phiLocal = (Local) phiAssignStmt.getOp1();
                        RegAssign a = (RegAssign) phiLocal.tag;
                        LiveV frame[] = (LiveV[]) stmt.frame;
                        for (LiveV v : frame) {
                            if (v != null && v.used) {
                                RegAssign b = (RegAssign) v.local.tag;
                                a.excludes.add(b);
                                b.excludes.add(a);
                            }
                        }
                    }
                }
            }
        }
        if (DEBUG) {
            System.out.println(liveA.toString());
        }
    }",iterator
phiAssignStmt,"{
        for (Local local : method.locals) {
            local.tag = new RegAssign();
        }

        Set<Stmt> tos = new HashSet<>();
        for (Stmt stmt : method.stmts) {
            if ((stmt.st == ST.ASSIGN || stmt.st == ST.IDENTITY) && stmt.getOp1().vt == VT.LOCAL) {
                Local localAssignTo = (Local) stmt.getOp1();
                RegAssign regAssignTo = (RegAssign) localAssignTo.tag;
                Set<Integer> excludeIdx = new HashSet<>();
                Cfg.collectTos(stmt, tos);
                for (Stmt target : tos) {
                    LiveV frame[] = (LiveV[]) target.frame;
                    if (frame == null) {
                        continue;
                    }
                    // exclude thisReg and phiReg
                    excludeIdx.clear();
                    excludeIdx.add(localAssignTo._ls_index);
                    if (target.st == ST.LABEL) {
                        LabelStmt label = (LabelStmt) target;
                        if (label.phis != null) {
                            for (AssignStmt phiAssignStmt : (List<AssignStmt>) label.phis) {
                                Local phiLocal = (Local) phiAssignStmt.getOp1();
                                excludeIdx.add(phiLocal._ls_index);
                            }
                        }
                    }
                    for (int i = 0; i < frame.length; i++) {
                        if (excludeIdx.contains(i)) {
                            continue;
                        }
                        LiveV v = frame[i];
                        if (v != null && v.used) {
                            RegAssign b = (RegAssign) v.local.tag;
                            regAssignTo.excludes.add(b);
                            b.excludes.add(regAssignTo);
                        }
                    }
                }
                tos.clear();
            } else if (stmt.st == ST.LABEL) { //
                // https://github.com/pxb1988/dex2jar/issues/477
                // the exception handler is dead and stmt.frame is null
                LabelStmt label = (LabelStmt) stmt;
                if (label.phis != null && stmt.frame != null) {
                    for (AssignStmt phiAssignStmt : (List<AssignStmt>) label.phis) {
                        Local phiLocal = (Local) phiAssignStmt.getOp1();
                        RegAssign a = (RegAssign) phiLocal.tag;
                        LiveV frame[] = (LiveV[]) stmt.frame;
                        for (LiveV v : frame) {
                            if (v != null && v.used) {
                                RegAssign b = (RegAssign) v.local.tag;
                                a.excludes.add(b);
                                b.excludes.add(a);
                            }
                        }
                    }
                }
            }
        }
        if (DEBUG) {
            System.out.println(liveA.toString());
        }
    }",iterator
p,"{
            for (Stmt p = method.stmts.getFirst(); p != null; p = p.getNext()) {
                LiveV[] frame = (LiveV[]) p.frame;
                if (frame != null) {
                    for (int i = 0; i < frame.length; i++) {
                        LiveV r = frame[i];
                        if (r != null) {
                            if (!r.used) {
                                frame[i] = null;
                            }
                        }
                    }
                }
            }
        }",maybe_loop_control
i,"{
            for (Stmt p = method.stmts.getFirst(); p != null; p = p.getNext()) {
                LiveV[] frame = (LiveV[]) p.frame;
                if (frame != null) {
                    for (int i = 0; i < frame.length; i++) {
                        LiveV r = frame[i];
                        if (r != null) {
                            if (!r.used) {
                                frame[i] = null;
                            }
                        }
                    }
                }
            }
        }",loop_control
q,"{
            Set<LiveV> used = new HashSet<LiveV>(aValues.size() / 2);
            Queue<LiveV> q = new UniqueQueue<>();
            q.addAll(aValues);

            while (!q.isEmpty()) {
                LiveV v = q.poll();
                if (v.used) {
                    if (used.contains(v)) {
                        continue;
                    }
                    used.add(v);
                    {
                        LiveV parent = v.parent;
                        if (parent != null && !parent.used) {
                            parent.used = true;
                            q.add(parent);
                        }
                    }
                    {
                        List<LiveV> otherParent = v.otherParents;
                        if (otherParent != null && otherParent.size() > 0) {
                            for (LiveV parent : otherParent) {
                                if (parent != null && !parent.used) {
                                    parent.used = true;
                                    q.add(parent);
                                }
                            }
                            v.otherParents = null;
                        }
                    }
                }
            }
            for (LiveV v : aValues) {
                v.parent = null;
            }
            aValues = null;

            return used;
        }",maybe_loop_control
parent,"{
            Set<LiveV> used = new HashSet<LiveV>(aValues.size() / 2);
            Queue<LiveV> q = new UniqueQueue<>();
            q.addAll(aValues);

            while (!q.isEmpty()) {
                LiveV v = q.poll();
                if (v.used) {
                    if (used.contains(v)) {
                        continue;
                    }
                    used.add(v);
                    {
                        LiveV parent = v.parent;
                        if (parent != null && !parent.used) {
                            parent.used = true;
                            q.add(parent);
                        }
                    }
                    {
                        List<LiveV> otherParent = v.otherParents;
                        if (otherParent != null && otherParent.size() > 0) {
                            for (LiveV parent : otherParent) {
                                if (parent != null && !parent.used) {
                                    parent.used = true;
                                    q.add(parent);
                                }
                            }
                            v.otherParents = null;
                        }
                    }
                }
            }
            for (LiveV v : aValues) {
                v.parent = null;
            }
            aValues = null;

            return used;
        }",iterator
v,"{
            Set<LiveV> used = new HashSet<LiveV>(aValues.size() / 2);
            Queue<LiveV> q = new UniqueQueue<>();
            q.addAll(aValues);

            while (!q.isEmpty()) {
                LiveV v = q.poll();
                if (v.used) {
                    if (used.contains(v)) {
                        continue;
                    }
                    used.add(v);
                    {
                        LiveV parent = v.parent;
                        if (parent != null && !parent.used) {
                            parent.used = true;
                            q.add(parent);
                        }
                    }
                    {
                        List<LiveV> otherParent = v.otherParents;
                        if (otherParent != null && otherParent.size() > 0) {
                            for (LiveV parent : otherParent) {
                                if (parent != null && !parent.used) {
                                    parent.used = true;
                                    q.add(parent);
                                }
                            }
                            v.otherParents = null;
                        }
                    }
                }
            }
            for (LiveV v : aValues) {
                v.parent = null;
            }
            aValues = null;

            return used;
        }",iterator
phiAssignStmt,"{

            Map<Integer, AssignStmt> phiLives = new HashMap<>();
            if (dist.st == ST.LABEL) {
                LabelStmt label = (LabelStmt) dist;
                if (label.phis != null) {// we got phis here
                    // travel each phi assignment, find where the phiLocal from
                    for (AssignStmt phiAssignStmt : (List<AssignStmt>) label.phis) {
                        Local phiLocal = (Local) phiAssignStmt.getOp1();
                        phiLives.put(phiLocal._ls_index, phiAssignStmt);
                    }
                }
            }
            // relationship
            boolean firstMerge = false;
            if (distFrame == null) { // distFrame is not visited
                distFrame = newFrame(); // init the distFrame
                firstMerge = true;

                // merge each value to distFrame if value is not null;
                for (int i = 0; i < distFrame.length; i++) {
                    if (phiLives.containsKey(i)) { // skip phi
                        continue;
                    }
                    LiveV srcV = srcFrame[i];
                    if (srcV != null) {
                        LiveV distV = newValue();
                        aValues.add(distV);
                        distV.parent = srcV;
                        distV.hops = srcV.hops + 1;
                        distV.local = srcV.local;
                        distFrame[i] = distV;
                    }
                }
            }

            if (!firstMerge) {
                // skip merge phi
                for (int i = 0; i < distFrame.length; i++) {
                    if (phiLives.containsKey(i)) {
                        continue;
                    }
                    LiveV srcV = srcFrame[i];
                    LiveV distV = distFrame[i];
                    if (srcV != null && distV != null) {
                        if (distV.otherParents == null) {
                            distV.otherParents = new ArrayList(5);
                        }
                        distV.otherParents.add(srcV);
                    }
                }
            }

            // deal with phi
            for (AssignStmt phiAssignStmt : phiLives.values()) {
                Local phiLocal = (Local) phiAssignStmt.getOp1();

                LiveV distValue;
                if (firstMerge) {
                    distValue = new LiveV();
                    distValue.local = phiLocal;
                    distValue.stmt2regMap = new HashMap<>();
                    distFrame[phiLocal._ls_index] = distValue;
                } else {
                    distValue = distFrame[phiLocal._ls_index];
                }

                List<LiveV> liveVs = new ArrayList();

                LiveV possiblePhiLocal = srcFrame[phiLocal._ls_index];
                if (possiblePhiLocal != null) {
                    liveVs.add(possiblePhiLocal);
                }

                for (Value p0 : phiAssignStmt.getOp2().getOps()) {
                    Local srcLocal = (Local) p0;
                    LiveV s = srcFrame[srcLocal._ls_index];
                    if (s != null) {
                        liveVs.add(s);
                    }
                }
                Collections.sort(liveVs, sortByHopsASC);
                LiveV a = liveVs.get(0); // this value assign to
                                         // phiLocal in srcFrame
                a.used = true;
                distValue.stmt2regMap.put(src, a.local);
            }
            return distFrame;
        }",iterator
p0,"{

            Map<Integer, AssignStmt> phiLives = new HashMap<>();
            if (dist.st == ST.LABEL) {
                LabelStmt label = (LabelStmt) dist;
                if (label.phis != null) {// we got phis here
                    // travel each phi assignment, find where the phiLocal from
                    for (AssignStmt phiAssignStmt : (List<AssignStmt>) label.phis) {
                        Local phiLocal = (Local) phiAssignStmt.getOp1();
                        phiLives.put(phiLocal._ls_index, phiAssignStmt);
                    }
                }
            }
            // relationship
            boolean firstMerge = false;
            if (distFrame == null) { // distFrame is not visited
                distFrame = newFrame(); // init the distFrame
                firstMerge = true;

                // merge each value to distFrame if value is not null;
                for (int i = 0; i < distFrame.length; i++) {
                    if (phiLives.containsKey(i)) { // skip phi
                        continue;
                    }
                    LiveV srcV = srcFrame[i];
                    if (srcV != null) {
                        LiveV distV = newValue();
                        aValues.add(distV);
                        distV.parent = srcV;
                        distV.hops = srcV.hops + 1;
                        distV.local = srcV.local;
                        distFrame[i] = distV;
                    }
                }
            }

            if (!firstMerge) {
                // skip merge phi
                for (int i = 0; i < distFrame.length; i++) {
                    if (phiLives.containsKey(i)) {
                        continue;
                    }
                    LiveV srcV = srcFrame[i];
                    LiveV distV = distFrame[i];
                    if (srcV != null && distV != null) {
                        if (distV.otherParents == null) {
                            distV.otherParents = new ArrayList(5);
                        }
                        distV.otherParents.add(srcV);
                    }
                }
            }

            // deal with phi
            for (AssignStmt phiAssignStmt : phiLives.values()) {
                Local phiLocal = (Local) phiAssignStmt.getOp1();

                LiveV distValue;
                if (firstMerge) {
                    distValue = new LiveV();
                    distValue.local = phiLocal;
                    distValue.stmt2regMap = new HashMap<>();
                    distFrame[phiLocal._ls_index] = distValue;
                } else {
                    distValue = distFrame[phiLocal._ls_index];
                }

                List<LiveV> liveVs = new ArrayList();

                LiveV possiblePhiLocal = srcFrame[phiLocal._ls_index];
                if (possiblePhiLocal != null) {
                    liveVs.add(possiblePhiLocal);
                }

                for (Value p0 : phiAssignStmt.getOp2().getOps()) {
                    Local srcLocal = (Local) p0;
                    LiveV s = srcFrame[srcLocal._ls_index];
                    if (s != null) {
                        liveVs.add(s);
                    }
                }
                Collections.sort(liveVs, sortByHopsASC);
                LiveV a = liveVs.get(0); // this value assign to
                                         // phiLocal in srcFrame
                a.used = true;
                distValue.stmt2regMap.put(src, a.local);
            }
            return distFrame;
        }",iterator
i,"{

            Map<Integer, AssignStmt> phiLives = new HashMap<>();
            if (dist.st == ST.LABEL) {
                LabelStmt label = (LabelStmt) dist;
                if (label.phis != null) {// we got phis here
                    // travel each phi assignment, find where the phiLocal from
                    for (AssignStmt phiAssignStmt : (List<AssignStmt>) label.phis) {
                        Local phiLocal = (Local) phiAssignStmt.getOp1();
                        phiLives.put(phiLocal._ls_index, phiAssignStmt);
                    }
                }
            }
            // relationship
            boolean firstMerge = false;
            if (distFrame == null) { // distFrame is not visited
                distFrame = newFrame(); // init the distFrame
                firstMerge = true;

                // merge each value to distFrame if value is not null;
                for (int i = 0; i < distFrame.length; i++) {
                    if (phiLives.containsKey(i)) { // skip phi
                        continue;
                    }
                    LiveV srcV = srcFrame[i];
                    if (srcV != null) {
                        LiveV distV = newValue();
                        aValues.add(distV);
                        distV.parent = srcV;
                        distV.hops = srcV.hops + 1;
                        distV.local = srcV.local;
                        distFrame[i] = distV;
                    }
                }
            }

            if (!firstMerge) {
                // skip merge phi
                for (int i = 0; i < distFrame.length; i++) {
                    if (phiLives.containsKey(i)) {
                        continue;
                    }
                    LiveV srcV = srcFrame[i];
                    LiveV distV = distFrame[i];
                    if (srcV != null && distV != null) {
                        if (distV.otherParents == null) {
                            distV.otherParents = new ArrayList(5);
                        }
                        distV.otherParents.add(srcV);
                    }
                }
            }

            // deal with phi
            for (AssignStmt phiAssignStmt : phiLives.values()) {
                Local phiLocal = (Local) phiAssignStmt.getOp1();

                LiveV distValue;
                if (firstMerge) {
                    distValue = new LiveV();
                    distValue.local = phiLocal;
                    distValue.stmt2regMap = new HashMap<>();
                    distFrame[phiLocal._ls_index] = distValue;
                } else {
                    distValue = distFrame[phiLocal._ls_index];
                }

                List<LiveV> liveVs = new ArrayList();

                LiveV possiblePhiLocal = srcFrame[phiLocal._ls_index];
                if (possiblePhiLocal != null) {
                    liveVs.add(possiblePhiLocal);
                }

                for (Value p0 : phiAssignStmt.getOp2().getOps()) {
                    Local srcLocal = (Local) p0;
                    LiveV s = srcFrame[srcLocal._ls_index];
                    if (s != null) {
                        liveVs.add(s);
                    }
                }
                Collections.sort(liveVs, sortByHopsASC);
                LiveV a = liveVs.get(0); // this value assign to
                                         // phiLocal in srcFrame
                a.used = true;
                distValue.stmt2regMap.put(src, a.local);
            }
            return distFrame;
        }",loop_control
local,"{
        for (Local local : m.locals) {
            local.tag = null;
        }
    }",iterator
local,"{
        for (Local local : m.locals) {
            ConstAnalyzeValue cav = (ConstAnalyzeValue) local.tag;
            if (Boolean.TRUE.equals(cav.isConst)) {
                boolean allTosAreCst = true;
                for (ConstAnalyzeValue c : cav.assignTo) {
                    if (!Boolean.TRUE.equals(c.isConst)) {
                        allTosAreCst = false;
                        break;
                    }
                }
                if (allTosAreCst) {
                    cav.replacable = true;
                }
            }
        }
    }",iterator
c,"{
        for (Local local : m.locals) {
            ConstAnalyzeValue cav = (ConstAnalyzeValue) local.tag;
            if (Boolean.TRUE.equals(cav.isConst)) {
                boolean allTosAreCst = true;
                for (ConstAnalyzeValue c : cav.assignTo) {
                    if (!Boolean.TRUE.equals(c.isConst)) {
                        allTosAreCst = false;
                        break;
                    }
                }
                if (allTosAreCst) {
                    cav.replacable = true;
                }
            }
        }
    }",iterator
c,"{
        for (Local local : m.locals) {
            ConstAnalyzeValue cav = (ConstAnalyzeValue) local.tag;
            if (Boolean.TRUE.equals(cav.isConst)) {
                boolean allTosAreCst = true;
                for (ConstAnalyzeValue c : cav.assignTo) {
                    if (!Boolean.TRUE.equals(c.isConst)) {
                        allTosAreCst = false;
                        break;
                    }
                }
                if (allTosAreCst) {
                    cav.replacable = true;
                }
            }
        }
    }",break_loop_control
queue,"{
        Queue<Local> queue = new UniqueQueue<>();
        queue.addAll(m.locals);
        while (!queue.isEmpty()) {
            ConstAnalyzeValue cav = (ConstAnalyzeValue) queue.poll().tag;

            Object cst = cav.cst;

            if (cav.isConst == null) {
                if (cst != null) {// we have a cst
                    boolean allCstEquals = true;
                    for (ConstAnalyzeValue p0 : cav.assignFrom) {
                        if (!cst.equals(p0.cst)) {
                            allCstEquals = false;
                            break;
                        }
                    }
                    if (allCstEquals) {
                        cav.isConst = true;

                    }
                }
            }

            if (cst != null || Boolean.TRUE.equals(cav.isConst)) {
                for (ConstAnalyzeValue p0 : cav.assignTo) {
                    if (p0.isConst == null) {
                        if (p0.cst == null) {
                            p0.cst = cst;
                        }
                        queue.add(p0.local);
                    }
                }
            }

            if (Boolean.FALSE.equals(cav.isConst)) {
                cav.cst = null;
                for (ConstAnalyzeValue c : cav.assignTo) {
                    if (!Boolean.FALSE.equals(c.isConst)) {
                        c.cst = null;
                        c.isConst = false;
                        queue.add(c.local);
                    }
                }
            }
        }
    }",maybe_loop_control
p0,"{
        Queue<Local> queue = new UniqueQueue<>();
        queue.addAll(m.locals);
        while (!queue.isEmpty()) {
            ConstAnalyzeValue cav = (ConstAnalyzeValue) queue.poll().tag;

            Object cst = cav.cst;

            if (cav.isConst == null) {
                if (cst != null) {// we have a cst
                    boolean allCstEquals = true;
                    for (ConstAnalyzeValue p0 : cav.assignFrom) {
                        if (!cst.equals(p0.cst)) {
                            allCstEquals = false;
                            break;
                        }
                    }
                    if (allCstEquals) {
                        cav.isConst = true;

                    }
                }
            }

            if (cst != null || Boolean.TRUE.equals(cav.isConst)) {
                for (ConstAnalyzeValue p0 : cav.assignTo) {
                    if (p0.isConst == null) {
                        if (p0.cst == null) {
                            p0.cst = cst;
                        }
                        queue.add(p0.local);
                    }
                }
            }

            if (Boolean.FALSE.equals(cav.isConst)) {
                cav.cst = null;
                for (ConstAnalyzeValue c : cav.assignTo) {
                    if (!Boolean.FALSE.equals(c.isConst)) {
                        c.cst = null;
                        c.isConst = false;
                        queue.add(c.local);
                    }
                }
            }
        }
    }",iterator
c,"{
        Queue<Local> queue = new UniqueQueue<>();
        queue.addAll(m.locals);
        while (!queue.isEmpty()) {
            ConstAnalyzeValue cav = (ConstAnalyzeValue) queue.poll().tag;

            Object cst = cav.cst;

            if (cav.isConst == null) {
                if (cst != null) {// we have a cst
                    boolean allCstEquals = true;
                    for (ConstAnalyzeValue p0 : cav.assignFrom) {
                        if (!cst.equals(p0.cst)) {
                            allCstEquals = false;
                            break;
                        }
                    }
                    if (allCstEquals) {
                        cav.isConst = true;

                    }
                }
            }

            if (cst != null || Boolean.TRUE.equals(cav.isConst)) {
                for (ConstAnalyzeValue p0 : cav.assignTo) {
                    if (p0.isConst == null) {
                        if (p0.cst == null) {
                            p0.cst = cst;
                        }
                        queue.add(p0.local);
                    }
                }
            }

            if (Boolean.FALSE.equals(cav.isConst)) {
                cav.cst = null;
                for (ConstAnalyzeValue c : cav.assignTo) {
                    if (!Boolean.FALSE.equals(c.isConst)) {
                        c.cst = null;
                        c.isConst = false;
                        queue.add(c.local);
                    }
                }
            }
        }
    }",iterator
p0,"{
        Queue<Local> queue = new UniqueQueue<>();
        queue.addAll(m.locals);
        while (!queue.isEmpty()) {
            ConstAnalyzeValue cav = (ConstAnalyzeValue) queue.poll().tag;

            Object cst = cav.cst;

            if (cav.isConst == null) {
                if (cst != null) {// we have a cst
                    boolean allCstEquals = true;
                    for (ConstAnalyzeValue p0 : cav.assignFrom) {
                        if (!cst.equals(p0.cst)) {
                            allCstEquals = false;
                            break;
                        }
                    }
                    if (allCstEquals) {
                        cav.isConst = true;

                    }
                }
            }

            if (cst != null || Boolean.TRUE.equals(cav.isConst)) {
                for (ConstAnalyzeValue p0 : cav.assignTo) {
                    if (p0.isConst == null) {
                        if (p0.cst == null) {
                            p0.cst = cst;
                        }
                        queue.add(p0.local);
                    }
                }
            }

            if (Boolean.FALSE.equals(cav.isConst)) {
                cav.cst = null;
                for (ConstAnalyzeValue c : cav.assignTo) {
                    if (!Boolean.FALSE.equals(c.isConst)) {
                        c.cst = null;
                        c.isConst = false;
                        queue.add(c.local);
                    }
                }
            }
        }
    }",break_loop_control
cst,"{
        Queue<Local> queue = new UniqueQueue<>();
        queue.addAll(m.locals);
        while (!queue.isEmpty()) {
            ConstAnalyzeValue cav = (ConstAnalyzeValue) queue.poll().tag;

            Object cst = cav.cst;

            if (cav.isConst == null) {
                if (cst != null) {// we have a cst
                    boolean allCstEquals = true;
                    for (ConstAnalyzeValue p0 : cav.assignFrom) {
                        if (!cst.equals(p0.cst)) {
                            allCstEquals = false;
                            break;
                        }
                    }
                    if (allCstEquals) {
                        cav.isConst = true;

                    }
                }
            }

            if (cst != null || Boolean.TRUE.equals(cav.isConst)) {
                for (ConstAnalyzeValue p0 : cav.assignTo) {
                    if (p0.isConst == null) {
                        if (p0.cst == null) {
                            p0.cst = cst;
                        }
                        queue.add(p0.local);
                    }
                }
            }

            if (Boolean.FALSE.equals(cav.isConst)) {
                cav.cst = null;
                for (ConstAnalyzeValue c : cav.assignTo) {
                    if (!Boolean.FALSE.equals(c.isConst)) {
                        c.cst = null;
                        c.isConst = false;
                        queue.add(c.local);
                    }
                }
            }
        }
    }",break_loop_control
p,"{
        for (Stmt p = m.stmts.getFirst(); p != null; p = p.getNext()) {
            if (p.st == ST.ASSIGN || p.st == ST.IDENTITY) {
                E2Stmt e2 = (E2Stmt) p;
                Value op1 = e2.op1.trim();
                Value op2 = e2.op2.trim();
                if (op1.vt == VT.LOCAL) {
                    ConstAnalyzeValue cav = (ConstAnalyzeValue) ((Local) op1).tag;
                    if (op2.vt == VT.CONSTANT) {
                        Constant c = (Constant) op2;
                        cav.isConst = true;
                        cav.cst = c.value;
                    } else if (op2.vt == VT.LOCAL) {
                        Local local2 = (Local) op2;
                        ConstAnalyzeValue zaf2 = (ConstAnalyzeValue) local2.tag;
                        cav.assignFrom.add(zaf2);
                        zaf2.assignTo.add(cav);
                    } else if (op2.vt == VT.PHI) {
                        PhiExpr pe = (PhiExpr) op2;
                        for (Value v : pe.ops) {
                            ConstAnalyzeValue zaf2 = (ConstAnalyzeValue) ((Local) v.trim()).tag;
                            cav.assignFrom.add(zaf2);
                            zaf2.assignTo.add(cav);
                        }
                    } else {
                        cav.isConst = Boolean.FALSE;
                    }
                }
            }
        }
    }",maybe_loop_control
local,"{
        for (Local local : m.locals) {
            local.tag = new ConstAnalyzeValue(local);
        }
    }",iterator
var,"{
        int i = 0;
        for (LocalVar var : irMethod.vars) {
            if (var.reg.trim().vt != VT.LOCAL) {
                if (var.reg.trim().vt == VT.CONSTANT) {
                    Local n = new Local(i++);
                    Value old = var.reg.trim();
                    irMethod.stmts.insertBefore(var.start, Stmts.nAssign(n, old));
                    var.reg = n;
                    irMethod.locals.add(n);
                } else {
                    // throw new DexExcpeption(""not support"");
                }
            }
        }
    }",iterator
p,"{
        boolean changed = false;
        List<AssignStmt> assignStmtList = new ArrayList<>();
        Map<Local, Object> cstMap = new HashMap<>();
        for (Stmt p = method.stmts.getFirst(); p != null; p = p.getNext()) {
            if (p.st == Stmt.ST.ASSIGN) {
                AssignStmt as = (AssignStmt) p;
                if (as.getOp1().vt == Value.VT.LOCAL) {
                    if (as.getOp2().vt == Value.VT.CONSTANT) {
                        assignStmtList.add(as);
                        cstMap.put((Local) as.getOp1(), ((Constant) as.getOp2()).value);
                    } else if (as.getOp2().vt == Value.VT.LOCAL) {
                        cstMap.put((Local) as.getOp1(), as.getOp2());
                    }
                }
            }
        }
        if (assignStmtList.size() == 0) {
            return false;
        }
        RemoveLocalFromSSA.fixReplace(cstMap);
        final Map<Local, Value> toReplace = new HashMap<>();
        Set<Value> usedInPhi = new HashSet<>();
        List<LabelStmt> phiLabels = method.phiLabels;
        if (phiLabels != null) {
            boolean loopAgain = true;
            while (loopAgain) {
                loopAgain = false;
                usedInPhi.clear();
                for (Iterator<LabelStmt> it = phiLabels.iterator(); it.hasNext();) {
                    LabelStmt labelStmt = it.next();
                    if (labelStmt.phis != null) {
                        for (Iterator<AssignStmt> it2 = labelStmt.phis.iterator(); it2.hasNext();) {
                            AssignStmt phi = it2.next();
                            Value[] vs = phi.getOp2().getOps();
                            Object sameCst = null;
                            boolean allEqual = true;
                            for (Value p : vs) {
                                Object cst = cstMap.get(p);
                                if (cst == null) {
                                    allEqual = false;
                                    break;
                                }
                                if (sameCst == null) {
                                    sameCst = cst;
                                } else if (!sameCst.equals(cst)) {
                                    allEqual = false;
                                    break;
                                }
                            }
                            if (allEqual) { // all are same constant
                                cstMap.put((Local) phi.getOp1(), sameCst);
                                if (sameCst instanceof Local) {
                                    phi.setOp2((Value) sameCst);
                                } else {
                                    phi.setOp2(Exprs.nConstant(sameCst));
                                    assignStmtList.add(phi);
                                }
                                it2.remove();
                                method.stmts.insertAfter(labelStmt, phi);
                                changed = true;
                                loopAgain = true; // loop again
                            } else {
                                usedInPhi.addAll(Arrays.asList(phi.getOp2().getOps()));
                            }
                        }
                        if (labelStmt.phis.size() == 0) {
                            it.remove();
                        }
                    }
                }
            }
        }

        for (Iterator<AssignStmt> it = assignStmtList.iterator(); it.hasNext();) {
            AssignStmt as = it.next();
            if (!usedInPhi.contains(as.getOp1())) {
                it.remove();
                method.stmts.remove(as);
                method.locals.remove(as.getOp1());
                changed = true;
            }
            toReplace.put((Local) as.getOp1(), as.getOp2());

        }

        Cfg.travelMod(method.stmts, new Cfg.TravelCallBack() {
            @Override
            public Value onAssign(Local v, AssignStmt as) {
                return v;
            }

            @Override
            public Value onUse(Local v) {
                Value n = toReplace.get(v);
                return n == null ? v : n.clone();
            }
        }, false);
        return changed;
    }",maybe_loop_control
loopAgain,"{
        boolean changed = false;
        List<AssignStmt> assignStmtList = new ArrayList<>();
        Map<Local, Object> cstMap = new HashMap<>();
        for (Stmt p = method.stmts.getFirst(); p != null; p = p.getNext()) {
            if (p.st == Stmt.ST.ASSIGN) {
                AssignStmt as = (AssignStmt) p;
                if (as.getOp1().vt == Value.VT.LOCAL) {
                    if (as.getOp2().vt == Value.VT.CONSTANT) {
                        assignStmtList.add(as);
                        cstMap.put((Local) as.getOp1(), ((Constant) as.getOp2()).value);
                    } else if (as.getOp2().vt == Value.VT.LOCAL) {
                        cstMap.put((Local) as.getOp1(), as.getOp2());
                    }
                }
            }
        }
        if (assignStmtList.size() == 0) {
            return false;
        }
        RemoveLocalFromSSA.fixReplace(cstMap);
        final Map<Local, Value> toReplace = new HashMap<>();
        Set<Value> usedInPhi = new HashSet<>();
        List<LabelStmt> phiLabels = method.phiLabels;
        if (phiLabels != null) {
            boolean loopAgain = true;
            while (loopAgain) {
                loopAgain = false;
                usedInPhi.clear();
                for (Iterator<LabelStmt> it = phiLabels.iterator(); it.hasNext();) {
                    LabelStmt labelStmt = it.next();
                    if (labelStmt.phis != null) {
                        for (Iterator<AssignStmt> it2 = labelStmt.phis.iterator(); it2.hasNext();) {
                            AssignStmt phi = it2.next();
                            Value[] vs = phi.getOp2().getOps();
                            Object sameCst = null;
                            boolean allEqual = true;
                            for (Value p : vs) {
                                Object cst = cstMap.get(p);
                                if (cst == null) {
                                    allEqual = false;
                                    break;
                                }
                                if (sameCst == null) {
                                    sameCst = cst;
                                } else if (!sameCst.equals(cst)) {
                                    allEqual = false;
                                    break;
                                }
                            }
                            if (allEqual) { // all are same constant
                                cstMap.put((Local) phi.getOp1(), sameCst);
                                if (sameCst instanceof Local) {
                                    phi.setOp2((Value) sameCst);
                                } else {
                                    phi.setOp2(Exprs.nConstant(sameCst));
                                    assignStmtList.add(phi);
                                }
                                it2.remove();
                                method.stmts.insertAfter(labelStmt, phi);
                                changed = true;
                                loopAgain = true; // loop again
                            } else {
                                usedInPhi.addAll(Arrays.asList(phi.getOp2().getOps()));
                            }
                        }
                        if (labelStmt.phis.size() == 0) {
                            it.remove();
                        }
                    }
                }
            }
        }

        for (Iterator<AssignStmt> it = assignStmtList.iterator(); it.hasNext();) {
            AssignStmt as = it.next();
            if (!usedInPhi.contains(as.getOp1())) {
                it.remove();
                method.stmts.remove(as);
                method.locals.remove(as.getOp1());
                changed = true;
            }
            toReplace.put((Local) as.getOp1(), as.getOp2());

        }

        Cfg.travelMod(method.stmts, new Cfg.TravelCallBack() {
            @Override
            public Value onAssign(Local v, AssignStmt as) {
                return v;
            }

            @Override
            public Value onUse(Local v) {
                Value n = toReplace.get(v);
                return n == null ? v : n.clone();
            }
        }, false);
        return changed;
    }",maybe_loop_control
it,"{
        boolean changed = false;
        List<AssignStmt> assignStmtList = new ArrayList<>();
        Map<Local, Object> cstMap = new HashMap<>();
        for (Stmt p = method.stmts.getFirst(); p != null; p = p.getNext()) {
            if (p.st == Stmt.ST.ASSIGN) {
                AssignStmt as = (AssignStmt) p;
                if (as.getOp1().vt == Value.VT.LOCAL) {
                    if (as.getOp2().vt == Value.VT.CONSTANT) {
                        assignStmtList.add(as);
                        cstMap.put((Local) as.getOp1(), ((Constant) as.getOp2()).value);
                    } else if (as.getOp2().vt == Value.VT.LOCAL) {
                        cstMap.put((Local) as.getOp1(), as.getOp2());
                    }
                }
            }
        }
        if (assignStmtList.size() == 0) {
            return false;
        }
        RemoveLocalFromSSA.fixReplace(cstMap);
        final Map<Local, Value> toReplace = new HashMap<>();
        Set<Value> usedInPhi = new HashSet<>();
        List<LabelStmt> phiLabels = method.phiLabels;
        if (phiLabels != null) {
            boolean loopAgain = true;
            while (loopAgain) {
                loopAgain = false;
                usedInPhi.clear();
                for (Iterator<LabelStmt> it = phiLabels.iterator(); it.hasNext();) {
                    LabelStmt labelStmt = it.next();
                    if (labelStmt.phis != null) {
                        for (Iterator<AssignStmt> it2 = labelStmt.phis.iterator(); it2.hasNext();) {
                            AssignStmt phi = it2.next();
                            Value[] vs = phi.getOp2().getOps();
                            Object sameCst = null;
                            boolean allEqual = true;
                            for (Value p : vs) {
                                Object cst = cstMap.get(p);
                                if (cst == null) {
                                    allEqual = false;
                                    break;
                                }
                                if (sameCst == null) {
                                    sameCst = cst;
                                } else if (!sameCst.equals(cst)) {
                                    allEqual = false;
                                    break;
                                }
                            }
                            if (allEqual) { // all are same constant
                                cstMap.put((Local) phi.getOp1(), sameCst);
                                if (sameCst instanceof Local) {
                                    phi.setOp2((Value) sameCst);
                                } else {
                                    phi.setOp2(Exprs.nConstant(sameCst));
                                    assignStmtList.add(phi);
                                }
                                it2.remove();
                                method.stmts.insertAfter(labelStmt, phi);
                                changed = true;
                                loopAgain = true; // loop again
                            } else {
                                usedInPhi.addAll(Arrays.asList(phi.getOp2().getOps()));
                            }
                        }
                        if (labelStmt.phis.size() == 0) {
                            it.remove();
                        }
                    }
                }
            }
        }

        for (Iterator<AssignStmt> it = assignStmtList.iterator(); it.hasNext();) {
            AssignStmt as = it.next();
            if (!usedInPhi.contains(as.getOp1())) {
                it.remove();
                method.stmts.remove(as);
                method.locals.remove(as.getOp1());
                changed = true;
            }
            toReplace.put((Local) as.getOp1(), as.getOp2());

        }

        Cfg.travelMod(method.stmts, new Cfg.TravelCallBack() {
            @Override
            public Value onAssign(Local v, AssignStmt as) {
                return v;
            }

            @Override
            public Value onUse(Local v) {
                Value n = toReplace.get(v);
                return n == null ? v : n.clone();
            }
        }, false);
        return changed;
    }",iterator
it2,"{
        boolean changed = false;
        List<AssignStmt> assignStmtList = new ArrayList<>();
        Map<Local, Object> cstMap = new HashMap<>();
        for (Stmt p = method.stmts.getFirst(); p != null; p = p.getNext()) {
            if (p.st == Stmt.ST.ASSIGN) {
                AssignStmt as = (AssignStmt) p;
                if (as.getOp1().vt == Value.VT.LOCAL) {
                    if (as.getOp2().vt == Value.VT.CONSTANT) {
                        assignStmtList.add(as);
                        cstMap.put((Local) as.getOp1(), ((Constant) as.getOp2()).value);
                    } else if (as.getOp2().vt == Value.VT.LOCAL) {
                        cstMap.put((Local) as.getOp1(), as.getOp2());
                    }
                }
            }
        }
        if (assignStmtList.size() == 0) {
            return false;
        }
        RemoveLocalFromSSA.fixReplace(cstMap);
        final Map<Local, Value> toReplace = new HashMap<>();
        Set<Value> usedInPhi = new HashSet<>();
        List<LabelStmt> phiLabels = method.phiLabels;
        if (phiLabels != null) {
            boolean loopAgain = true;
            while (loopAgain) {
                loopAgain = false;
                usedInPhi.clear();
                for (Iterator<LabelStmt> it = phiLabels.iterator(); it.hasNext();) {
                    LabelStmt labelStmt = it.next();
                    if (labelStmt.phis != null) {
                        for (Iterator<AssignStmt> it2 = labelStmt.phis.iterator(); it2.hasNext();) {
                            AssignStmt phi = it2.next();
                            Value[] vs = phi.getOp2().getOps();
                            Object sameCst = null;
                            boolean allEqual = true;
                            for (Value p : vs) {
                                Object cst = cstMap.get(p);
                                if (cst == null) {
                                    allEqual = false;
                                    break;
                                }
                                if (sameCst == null) {
                                    sameCst = cst;
                                } else if (!sameCst.equals(cst)) {
                                    allEqual = false;
                                    break;
                                }
                            }
                            if (allEqual) { // all are same constant
                                cstMap.put((Local) phi.getOp1(), sameCst);
                                if (sameCst instanceof Local) {
                                    phi.setOp2((Value) sameCst);
                                } else {
                                    phi.setOp2(Exprs.nConstant(sameCst));
                                    assignStmtList.add(phi);
                                }
                                it2.remove();
                                method.stmts.insertAfter(labelStmt, phi);
                                changed = true;
                                loopAgain = true; // loop again
                            } else {
                                usedInPhi.addAll(Arrays.asList(phi.getOp2().getOps()));
                            }
                        }
                        if (labelStmt.phis.size() == 0) {
                            it.remove();
                        }
                    }
                }
            }
        }

        for (Iterator<AssignStmt> it = assignStmtList.iterator(); it.hasNext();) {
            AssignStmt as = it.next();
            if (!usedInPhi.contains(as.getOp1())) {
                it.remove();
                method.stmts.remove(as);
                method.locals.remove(as.getOp1());
                changed = true;
            }
            toReplace.put((Local) as.getOp1(), as.getOp2());

        }

        Cfg.travelMod(method.stmts, new Cfg.TravelCallBack() {
            @Override
            public Value onAssign(Local v, AssignStmt as) {
                return v;
            }

            @Override
            public Value onUse(Local v) {
                Value n = toReplace.get(v);
                return n == null ? v : n.clone();
            }
        }, false);
        return changed;
    }",iterator
p,"{
        boolean changed = false;
        List<AssignStmt> assignStmtList = new ArrayList<>();
        Map<Local, Object> cstMap = new HashMap<>();
        for (Stmt p = method.stmts.getFirst(); p != null; p = p.getNext()) {
            if (p.st == Stmt.ST.ASSIGN) {
                AssignStmt as = (AssignStmt) p;
                if (as.getOp1().vt == Value.VT.LOCAL) {
                    if (as.getOp2().vt == Value.VT.CONSTANT) {
                        assignStmtList.add(as);
                        cstMap.put((Local) as.getOp1(), ((Constant) as.getOp2()).value);
                    } else if (as.getOp2().vt == Value.VT.LOCAL) {
                        cstMap.put((Local) as.getOp1(), as.getOp2());
                    }
                }
            }
        }
        if (assignStmtList.size() == 0) {
            return false;
        }
        RemoveLocalFromSSA.fixReplace(cstMap);
        final Map<Local, Value> toReplace = new HashMap<>();
        Set<Value> usedInPhi = new HashSet<>();
        List<LabelStmt> phiLabels = method.phiLabels;
        if (phiLabels != null) {
            boolean loopAgain = true;
            while (loopAgain) {
                loopAgain = false;
                usedInPhi.clear();
                for (Iterator<LabelStmt> it = phiLabels.iterator(); it.hasNext();) {
                    LabelStmt labelStmt = it.next();
                    if (labelStmt.phis != null) {
                        for (Iterator<AssignStmt> it2 = labelStmt.phis.iterator(); it2.hasNext();) {
                            AssignStmt phi = it2.next();
                            Value[] vs = phi.getOp2().getOps();
                            Object sameCst = null;
                            boolean allEqual = true;
                            for (Value p : vs) {
                                Object cst = cstMap.get(p);
                                if (cst == null) {
                                    allEqual = false;
                                    break;
                                }
                                if (sameCst == null) {
                                    sameCst = cst;
                                } else if (!sameCst.equals(cst)) {
                                    allEqual = false;
                                    break;
                                }
                            }
                            if (allEqual) { // all are same constant
                                cstMap.put((Local) phi.getOp1(), sameCst);
                                if (sameCst instanceof Local) {
                                    phi.setOp2((Value) sameCst);
                                } else {
                                    phi.setOp2(Exprs.nConstant(sameCst));
                                    assignStmtList.add(phi);
                                }
                                it2.remove();
                                method.stmts.insertAfter(labelStmt, phi);
                                changed = true;
                                loopAgain = true; // loop again
                            } else {
                                usedInPhi.addAll(Arrays.asList(phi.getOp2().getOps()));
                            }
                        }
                        if (labelStmt.phis.size() == 0) {
                            it.remove();
                        }
                    }
                }
            }
        }

        for (Iterator<AssignStmt> it = assignStmtList.iterator(); it.hasNext();) {
            AssignStmt as = it.next();
            if (!usedInPhi.contains(as.getOp1())) {
                it.remove();
                method.stmts.remove(as);
                method.locals.remove(as.getOp1());
                changed = true;
            }
            toReplace.put((Local) as.getOp1(), as.getOp2());

        }

        Cfg.travelMod(method.stmts, new Cfg.TravelCallBack() {
            @Override
            public Value onAssign(Local v, AssignStmt as) {
                return v;
            }

            @Override
            public Value onUse(Local v) {
                Value n = toReplace.get(v);
                return n == null ? v : n.clone();
            }
        }, false);
        return changed;
    }",iterator
sameCst,"{
        boolean changed = false;
        List<AssignStmt> assignStmtList = new ArrayList<>();
        Map<Local, Object> cstMap = new HashMap<>();
        for (Stmt p = method.stmts.getFirst(); p != null; p = p.getNext()) {
            if (p.st == Stmt.ST.ASSIGN) {
                AssignStmt as = (AssignStmt) p;
                if (as.getOp1().vt == Value.VT.LOCAL) {
                    if (as.getOp2().vt == Value.VT.CONSTANT) {
                        assignStmtList.add(as);
                        cstMap.put((Local) as.getOp1(), ((Constant) as.getOp2()).value);
                    } else if (as.getOp2().vt == Value.VT.LOCAL) {
                        cstMap.put((Local) as.getOp1(), as.getOp2());
                    }
                }
            }
        }
        if (assignStmtList.size() == 0) {
            return false;
        }
        RemoveLocalFromSSA.fixReplace(cstMap);
        final Map<Local, Value> toReplace = new HashMap<>();
        Set<Value> usedInPhi = new HashSet<>();
        List<LabelStmt> phiLabels = method.phiLabels;
        if (phiLabels != null) {
            boolean loopAgain = true;
            while (loopAgain) {
                loopAgain = false;
                usedInPhi.clear();
                for (Iterator<LabelStmt> it = phiLabels.iterator(); it.hasNext();) {
                    LabelStmt labelStmt = it.next();
                    if (labelStmt.phis != null) {
                        for (Iterator<AssignStmt> it2 = labelStmt.phis.iterator(); it2.hasNext();) {
                            AssignStmt phi = it2.next();
                            Value[] vs = phi.getOp2().getOps();
                            Object sameCst = null;
                            boolean allEqual = true;
                            for (Value p : vs) {
                                Object cst = cstMap.get(p);
                                if (cst == null) {
                                    allEqual = false;
                                    break;
                                }
                                if (sameCst == null) {
                                    sameCst = cst;
                                } else if (!sameCst.equals(cst)) {
                                    allEqual = false;
                                    break;
                                }
                            }
                            if (allEqual) { // all are same constant
                                cstMap.put((Local) phi.getOp1(), sameCst);
                                if (sameCst instanceof Local) {
                                    phi.setOp2((Value) sameCst);
                                } else {
                                    phi.setOp2(Exprs.nConstant(sameCst));
                                    assignStmtList.add(phi);
                                }
                                it2.remove();
                                method.stmts.insertAfter(labelStmt, phi);
                                changed = true;
                                loopAgain = true; // loop again
                            } else {
                                usedInPhi.addAll(Arrays.asList(phi.getOp2().getOps()));
                            }
                        }
                        if (labelStmt.phis.size() == 0) {
                            it.remove();
                        }
                    }
                }
            }
        }

        for (Iterator<AssignStmt> it = assignStmtList.iterator(); it.hasNext();) {
            AssignStmt as = it.next();
            if (!usedInPhi.contains(as.getOp1())) {
                it.remove();
                method.stmts.remove(as);
                method.locals.remove(as.getOp1());
                changed = true;
            }
            toReplace.put((Local) as.getOp1(), as.getOp2());

        }

        Cfg.travelMod(method.stmts, new Cfg.TravelCallBack() {
            @Override
            public Value onAssign(Local v, AssignStmt as) {
                return v;
            }

            @Override
            public Value onUse(Local v) {
                Value n = toReplace.get(v);
                return n == null ? v : n.clone();
            }
        }, false);
        return changed;
    }",break_loop_control
as,"{
        for (AssignStmt as : assignStmtList) {
            Value right = as.getOp2();
            T to = toReplace.get(right);
            if (to != null) {
                as.setOp2(to);
            }
        }
    }",iterator
labelStmt,"{
        Set<Value> usedInPhi = new HashSet<>();
        if (phiLabels != null) {
            for (LabelStmt labelStmt : phiLabels) {
                for (AssignStmt phi : labelStmt.phis) {
                    usedInPhi.addAll(Arrays.asList(phi.getOp2().getOps()));
                }
            }
        }
        boolean changed = false;
        for (Iterator<AssignStmt> it = assignStmtList.iterator(); it.hasNext(); ) {
            AssignStmt as = it.next();
            if (!usedInPhi.contains(as.getOp1())) {
                it.remove();
                stmts.remove(as);
                toReplace.put((Local) as.getOp1(), (Local) as.getOp2());
                changed = true;
            }
        }

        return changed;
    }",iterator
it,"{
        Set<Value> usedInPhi = new HashSet<>();
        if (phiLabels != null) {
            for (LabelStmt labelStmt : phiLabels) {
                for (AssignStmt phi : labelStmt.phis) {
                    usedInPhi.addAll(Arrays.asList(phi.getOp2().getOps()));
                }
            }
        }
        boolean changed = false;
        for (Iterator<AssignStmt> it = assignStmtList.iterator(); it.hasNext(); ) {
            AssignStmt as = it.next();
            if (!usedInPhi.contains(as.getOp1())) {
                it.remove();
                stmts.remove(as);
                toReplace.put((Local) as.getOp1(), (Local) as.getOp2());
                changed = true;
            }
        }

        return changed;
    }",iterator
labelStmt,"{
        if (phiLabels != null) {
            for (LabelStmt labelStmt : phiLabels) {
                for (AssignStmt phi : labelStmt.phis) {
                    Value[] ops = phi.getOp2().getOps();
                    for (Value op : ops) {
                        Value n = toReplace.get(op);
                        if (n != null) {
                            set.add(n);
                        } else {
                            set.add(op);
                        }
                    }
                    set.remove(phi.getOp1());
                    phi.getOp2().setOps(set.toArray(new Value[set.size()]));
                    set.clear();
                }
            }
        }
    }",iterator
phi,"{
        if (phiLabels != null) {
            for (LabelStmt labelStmt : phiLabels) {
                for (AssignStmt phi : labelStmt.phis) {
                    Value[] ops = phi.getOp2().getOps();
                    for (Value op : ops) {
                        Value n = toReplace.get(op);
                        if (n != null) {
                            set.add(n);
                        } else {
                            set.add(op);
                        }
                    }
                    set.remove(phi.getOp1());
                    phi.getOp2().setOps(set.toArray(new Value[set.size()]));
                    set.clear();
                }
            }
        }
    }",iterator
op,"{
        if (phiLabels != null) {
            for (LabelStmt labelStmt : phiLabels) {
                for (AssignStmt phi : labelStmt.phis) {
                    Value[] ops = phi.getOp2().getOps();
                    for (Value op : ops) {
                        Value n = toReplace.get(op);
                        if (n != null) {
                            set.add(n);
                        } else {
                            set.add(op);
                        }
                    }
                    set.remove(phi.getOp1());
                    phi.getOp2().setOps(set.toArray(new Value[set.size()]));
                    set.clear();
                }
            }
        }
    }",iterator
itLabel,"{
        boolean changed = false;
        if (phiLabels != null) {
            for (Iterator<LabelStmt> itLabel = phiLabels.iterator(); itLabel.hasNext(); ) {
                LabelStmt labelStmt = itLabel.next();
                for (Iterator<AssignStmt> it = labelStmt.phis.iterator(); it.hasNext(); ) {
                    AssignStmt phi = it.next();
                    set.addAll(Arrays.asList(phi.getOp2().getOps()));
                    set.remove(phi.getOp1());
                    if (set.size() == 1) {
                        it.remove();
                        changed = true;
                        toReplace.put((Local) phi.getOp1(), (Local) set.iterator().next());
                    }
                    set.clear();
                }
                if (labelStmt.phis.size() == 0) {
                    labelStmt.phis = null;
                    itLabel.remove();
                }
            }
        }
        return changed;
    }",iterator
it,"{
        boolean changed = false;
        if (phiLabels != null) {
            for (Iterator<LabelStmt> itLabel = phiLabels.iterator(); itLabel.hasNext(); ) {
                LabelStmt labelStmt = itLabel.next();
                for (Iterator<AssignStmt> it = labelStmt.phis.iterator(); it.hasNext(); ) {
                    AssignStmt phi = it.next();
                    set.addAll(Arrays.asList(phi.getOp2().getOps()));
                    set.remove(phi.getOp1());
                    if (set.size() == 1) {
                        it.remove();
                        changed = true;
                        toReplace.put((Local) phi.getOp1(), (Local) set.iterator().next());
                    }
                    set.clear();
                }
                if (labelStmt.phis.size() == 0) {
                    labelStmt.phis = null;
                    itLabel.remove();
                }
            }
        }
        return changed;
    }",iterator
q,"{
        boolean changed = false;
        if (phiLabels != null) {
            Set<Local> toDeletePhiAssign = new HashSet<>();
            Map<Local, PhiObject> phis;
            // detect loop init in phi
            phis = collectPhiObjects(phiLabels);
            Queue<PhiObject> q = new UniqueQueue<>();
            q.addAll(phis.values());
            while (!q.isEmpty()) {
                PhiObject po = q.poll();
                for (PhiObject child : po.children) {
                    if (child.isInitByPhi) {
                        if (child.parent.addAll(po.parent)) {
                            q.add(child);
                        }
                    }
                }
            }
            for (PhiObject po : phis.values()) {
                if (po.isInitByPhi) {
                    Local local = null;
                    for (PhiObject p : po.parent) {
                        if (!p.isInitByPhi) {
                            if (local == null) { // the first non-phi value
                                local = p.local;
                            } else {
                                local = null;
                                break;
                            }
                        }
                    }
                    if (local != null) {
                        toReplace.put(po.local, local);
                        toDeletePhiAssign.add(po.local);
                        changed = true;
                    }
                }
            }
            for (Iterator<LabelStmt> itLabel = phiLabels.iterator(); itLabel.hasNext(); ) {
                LabelStmt labelStmt = itLabel.next();
                for (Iterator<AssignStmt> it = labelStmt.phis.iterator(); it.hasNext(); ) {
                    AssignStmt phi = it.next();
                    if (toDeletePhiAssign.contains(phi.getOp1())) {
                        it.remove();
                    }
                }
                if (labelStmt.phis.size() == 0) {
                    labelStmt.phis = null;
                    itLabel.remove();
                }
            }
        }
        return changed;
    }",maybe_loop_control
child,"{
        boolean changed = false;
        if (phiLabels != null) {
            Set<Local> toDeletePhiAssign = new HashSet<>();
            Map<Local, PhiObject> phis;
            // detect loop init in phi
            phis = collectPhiObjects(phiLabels);
            Queue<PhiObject> q = new UniqueQueue<>();
            q.addAll(phis.values());
            while (!q.isEmpty()) {
                PhiObject po = q.poll();
                for (PhiObject child : po.children) {
                    if (child.isInitByPhi) {
                        if (child.parent.addAll(po.parent)) {
                            q.add(child);
                        }
                    }
                }
            }
            for (PhiObject po : phis.values()) {
                if (po.isInitByPhi) {
                    Local local = null;
                    for (PhiObject p : po.parent) {
                        if (!p.isInitByPhi) {
                            if (local == null) { // the first non-phi value
                                local = p.local;
                            } else {
                                local = null;
                                break;
                            }
                        }
                    }
                    if (local != null) {
                        toReplace.put(po.local, local);
                        toDeletePhiAssign.add(po.local);
                        changed = true;
                    }
                }
            }
            for (Iterator<LabelStmt> itLabel = phiLabels.iterator(); itLabel.hasNext(); ) {
                LabelStmt labelStmt = itLabel.next();
                for (Iterator<AssignStmt> it = labelStmt.phis.iterator(); it.hasNext(); ) {
                    AssignStmt phi = it.next();
                    if (toDeletePhiAssign.contains(phi.getOp1())) {
                        it.remove();
                    }
                }
                if (labelStmt.phis.size() == 0) {
                    labelStmt.phis = null;
                    itLabel.remove();
                }
            }
        }
        return changed;
    }",iterator
po,"{
        boolean changed = false;
        if (phiLabels != null) {
            Set<Local> toDeletePhiAssign = new HashSet<>();
            Map<Local, PhiObject> phis;
            // detect loop init in phi
            phis = collectPhiObjects(phiLabels);
            Queue<PhiObject> q = new UniqueQueue<>();
            q.addAll(phis.values());
            while (!q.isEmpty()) {
                PhiObject po = q.poll();
                for (PhiObject child : po.children) {
                    if (child.isInitByPhi) {
                        if (child.parent.addAll(po.parent)) {
                            q.add(child);
                        }
                    }
                }
            }
            for (PhiObject po : phis.values()) {
                if (po.isInitByPhi) {
                    Local local = null;
                    for (PhiObject p : po.parent) {
                        if (!p.isInitByPhi) {
                            if (local == null) { // the first non-phi value
                                local = p.local;
                            } else {
                                local = null;
                                break;
                            }
                        }
                    }
                    if (local != null) {
                        toReplace.put(po.local, local);
                        toDeletePhiAssign.add(po.local);
                        changed = true;
                    }
                }
            }
            for (Iterator<LabelStmt> itLabel = phiLabels.iterator(); itLabel.hasNext(); ) {
                LabelStmt labelStmt = itLabel.next();
                for (Iterator<AssignStmt> it = labelStmt.phis.iterator(); it.hasNext(); ) {
                    AssignStmt phi = it.next();
                    if (toDeletePhiAssign.contains(phi.getOp1())) {
                        it.remove();
                    }
                }
                if (labelStmt.phis.size() == 0) {
                    labelStmt.phis = null;
                    itLabel.remove();
                }
            }
        }
        return changed;
    }",iterator
p,"{
        boolean changed = false;
        if (phiLabels != null) {
            Set<Local> toDeletePhiAssign = new HashSet<>();
            Map<Local, PhiObject> phis;
            // detect loop init in phi
            phis = collectPhiObjects(phiLabels);
            Queue<PhiObject> q = new UniqueQueue<>();
            q.addAll(phis.values());
            while (!q.isEmpty()) {
                PhiObject po = q.poll();
                for (PhiObject child : po.children) {
                    if (child.isInitByPhi) {
                        if (child.parent.addAll(po.parent)) {
                            q.add(child);
                        }
                    }
                }
            }
            for (PhiObject po : phis.values()) {
                if (po.isInitByPhi) {
                    Local local = null;
                    for (PhiObject p : po.parent) {
                        if (!p.isInitByPhi) {
                            if (local == null) { // the first non-phi value
                                local = p.local;
                            } else {
                                local = null;
                                break;
                            }
                        }
                    }
                    if (local != null) {
                        toReplace.put(po.local, local);
                        toDeletePhiAssign.add(po.local);
                        changed = true;
                    }
                }
            }
            for (Iterator<LabelStmt> itLabel = phiLabels.iterator(); itLabel.hasNext(); ) {
                LabelStmt labelStmt = itLabel.next();
                for (Iterator<AssignStmt> it = labelStmt.phis.iterator(); it.hasNext(); ) {
                    AssignStmt phi = it.next();
                    if (toDeletePhiAssign.contains(phi.getOp1())) {
                        it.remove();
                    }
                }
                if (labelStmt.phis.size() == 0) {
                    labelStmt.phis = null;
                    itLabel.remove();
                }
            }
        }
        return changed;
    }",iterator
itLabel,"{
        boolean changed = false;
        if (phiLabels != null) {
            Set<Local> toDeletePhiAssign = new HashSet<>();
            Map<Local, PhiObject> phis;
            // detect loop init in phi
            phis = collectPhiObjects(phiLabels);
            Queue<PhiObject> q = new UniqueQueue<>();
            q.addAll(phis.values());
            while (!q.isEmpty()) {
                PhiObject po = q.poll();
                for (PhiObject child : po.children) {
                    if (child.isInitByPhi) {
                        if (child.parent.addAll(po.parent)) {
                            q.add(child);
                        }
                    }
                }
            }
            for (PhiObject po : phis.values()) {
                if (po.isInitByPhi) {
                    Local local = null;
                    for (PhiObject p : po.parent) {
                        if (!p.isInitByPhi) {
                            if (local == null) { // the first non-phi value
                                local = p.local;
                            } else {
                                local = null;
                                break;
                            }
                        }
                    }
                    if (local != null) {
                        toReplace.put(po.local, local);
                        toDeletePhiAssign.add(po.local);
                        changed = true;
                    }
                }
            }
            for (Iterator<LabelStmt> itLabel = phiLabels.iterator(); itLabel.hasNext(); ) {
                LabelStmt labelStmt = itLabel.next();
                for (Iterator<AssignStmt> it = labelStmt.phis.iterator(); it.hasNext(); ) {
                    AssignStmt phi = it.next();
                    if (toDeletePhiAssign.contains(phi.getOp1())) {
                        it.remove();
                    }
                }
                if (labelStmt.phis.size() == 0) {
                    labelStmt.phis = null;
                    itLabel.remove();
                }
            }
        }
        return changed;
    }",iterator
it,"{
        boolean changed = false;
        if (phiLabels != null) {
            Set<Local> toDeletePhiAssign = new HashSet<>();
            Map<Local, PhiObject> phis;
            // detect loop init in phi
            phis = collectPhiObjects(phiLabels);
            Queue<PhiObject> q = new UniqueQueue<>();
            q.addAll(phis.values());
            while (!q.isEmpty()) {
                PhiObject po = q.poll();
                for (PhiObject child : po.children) {
                    if (child.isInitByPhi) {
                        if (child.parent.addAll(po.parent)) {
                            q.add(child);
                        }
                    }
                }
            }
            for (PhiObject po : phis.values()) {
                if (po.isInitByPhi) {
                    Local local = null;
                    for (PhiObject p : po.parent) {
                        if (!p.isInitByPhi) {
                            if (local == null) { // the first non-phi value
                                local = p.local;
                            } else {
                                local = null;
                                break;
                            }
                        }
                    }
                    if (local != null) {
                        toReplace.put(po.local, local);
                        toDeletePhiAssign.add(po.local);
                        changed = true;
                    }
                }
            }
            for (Iterator<LabelStmt> itLabel = phiLabels.iterator(); itLabel.hasNext(); ) {
                LabelStmt labelStmt = itLabel.next();
                for (Iterator<AssignStmt> it = labelStmt.phis.iterator(); it.hasNext(); ) {
                    AssignStmt phi = it.next();
                    if (toDeletePhiAssign.contains(phi.getOp1())) {
                        it.remove();
                    }
                }
                if (labelStmt.phis.size() == 0) {
                    labelStmt.phis = null;
                    itLabel.remove();
                }
            }
        }
        return changed;
    }",iterator
labelStmt,"{
        Map<Local, PhiObject> phis;
        phis = new HashMap<>();
        for (LabelStmt labelStmt : phiLabels) {
            for (AssignStmt as : labelStmt.phis) {
                Local local = (Local) as.getOp1();
                PhiObject child = getOrCreate(phis, local);
                child.isInitByPhi = true;
                for (Value op : as.getOp2().getOps()) {
                    if (op == local) {
                        continue;
                    }
                    PhiObject parent = getOrCreate(phis, (Local) op);
                    linkPhiObject(parent, child);
                }
            }
        }
        return phis;
    }",iterator
as,"{
        Map<Local, PhiObject> phis;
        phis = new HashMap<>();
        for (LabelStmt labelStmt : phiLabels) {
            for (AssignStmt as : labelStmt.phis) {
                Local local = (Local) as.getOp1();
                PhiObject child = getOrCreate(phis, local);
                child.isInitByPhi = true;
                for (Value op : as.getOp2().getOps()) {
                    if (op == local) {
                        continue;
                    }
                    PhiObject parent = getOrCreate(phis, (Local) op);
                    linkPhiObject(parent, child);
                }
            }
        }
        return phis;
    }",iterator
op,"{
        Map<Local, PhiObject> phis;
        phis = new HashMap<>();
        for (LabelStmt labelStmt : phiLabels) {
            for (AssignStmt as : labelStmt.phis) {
                Local local = (Local) as.getOp1();
                PhiObject child = getOrCreate(phis, local);
                child.isInitByPhi = true;
                for (Value op : as.getOp2().getOps()) {
                    if (op == local) {
                        continue;
                    }
                    PhiObject parent = getOrCreate(phis, (Local) op);
                    linkPhiObject(parent, child);
                }
            }
        }
        return phis;
    }",iterator
e,"{
        List<Map.Entry<Local, T>> set = new ArrayList<>(toReplace.entrySet());
        Collections.sort(set, new Comparator<Map.Entry<Local, T>>() {
            @Override
            public int compare(Map.Entry<Local, T> localTEntry, Map.Entry<Local, T> t1) {
                return Integer.compare(localTEntry.getKey()._ls_index, t1.getKey()._ls_index);
            }
        });

        boolean changed = true;
        while (changed) {
            changed = false;
            for (Map.Entry<Local, T> e : set) {
                T b = e.getValue();
                if(b instanceof  Local) {
                    T n = toReplace.get(b);
                    if (n != null && b != n) {
                        changed = true;
                        e.setValue(n);
                    }
                }
            }
        }
    }",iterator
changed,"{
        List<Map.Entry<Local, T>> set = new ArrayList<>(toReplace.entrySet());
        Collections.sort(set, new Comparator<Map.Entry<Local, T>>() {
            @Override
            public int compare(Map.Entry<Local, T> localTEntry, Map.Entry<Local, T> t1) {
                return Integer.compare(localTEntry.getKey()._ls_index, t1.getKey()._ls_index);
            }
        });

        boolean changed = true;
        while (changed) {
            changed = false;
            for (Map.Entry<Local, T> e : set) {
                T b = e.getValue();
                if(b instanceof  Local) {
                    T n = toReplace.get(b);
                    if (n != null && b != n) {
                        changed = true;
                        e.setValue(n);
                    }
                }
            }
        }
    }",maybe_loop_control
p,"{
        boolean irChanged = false;
        List<AssignStmt> assignStmtList = new ArrayList<>();
        List<LabelStmt> phiLabels = method.phiLabels;
        for (Stmt p = method.stmts.getFirst(); p != null; p = p.getNext()) {
            if (p.st == Stmt.ST.ASSIGN) {
                AssignStmt as = (AssignStmt) p;
                if (as.getOp1().vt == Value.VT.LOCAL && as.getOp2().vt == Value.VT.LOCAL) {
                    assignStmtList.add(as);
                }
            }
        }
        final Map<Local, Local> toReplace = new HashMap<>();
        Set<Value> set = new HashSet<>();
        boolean changed = true;
        while (changed) {
            changed = false;

            if (removeLoopFromPhi(phiLabels, toReplace)) {
                fixReplace(toReplace);
                replacePhi(phiLabels, toReplace, set);
            }

            while (simplePhi(phiLabels, toReplace, set)) {// remove a = phi(b)
                fixReplace(toReplace);
                replacePhi(phiLabels, toReplace, set);
            }
            while (simpleAssign(phiLabels, assignStmtList, toReplace, method.stmts)) {// remove a=b
                fixReplace(toReplace);
                replaceAssign(assignStmtList, toReplace);
                changed = true;
                irChanged = true;
            }
            replacePhi(phiLabels, toReplace, set);
        }

        for (Local local : toReplace.keySet()) {
            method.locals.remove(local);
            irChanged = true;
        }
        if (toReplace.size() > 0) {
            Cfg.travelMod(method.stmts, new Cfg.TravelCallBack() {
                @Override
                public Value onAssign(Local v, AssignStmt as) {
                    return v;
                }

                @Override
                public Value onUse(Local v) {
                    Local n = toReplace.get(v);
                    return n == null ? v : n;
                }
            }, true);
        }
        return irChanged;
    }",maybe_loop_control
changed,"{
        boolean irChanged = false;
        List<AssignStmt> assignStmtList = new ArrayList<>();
        List<LabelStmt> phiLabels = method.phiLabels;
        for (Stmt p = method.stmts.getFirst(); p != null; p = p.getNext()) {
            if (p.st == Stmt.ST.ASSIGN) {
                AssignStmt as = (AssignStmt) p;
                if (as.getOp1().vt == Value.VT.LOCAL && as.getOp2().vt == Value.VT.LOCAL) {
                    assignStmtList.add(as);
                }
            }
        }
        final Map<Local, Local> toReplace = new HashMap<>();
        Set<Value> set = new HashSet<>();
        boolean changed = true;
        while (changed) {
            changed = false;

            if (removeLoopFromPhi(phiLabels, toReplace)) {
                fixReplace(toReplace);
                replacePhi(phiLabels, toReplace, set);
            }

            while (simplePhi(phiLabels, toReplace, set)) {// remove a = phi(b)
                fixReplace(toReplace);
                replacePhi(phiLabels, toReplace, set);
            }
            while (simpleAssign(phiLabels, assignStmtList, toReplace, method.stmts)) {// remove a=b
                fixReplace(toReplace);
                replaceAssign(assignStmtList, toReplace);
                changed = true;
                irChanged = true;
            }
            replacePhi(phiLabels, toReplace, set);
        }

        for (Local local : toReplace.keySet()) {
            method.locals.remove(local);
            irChanged = true;
        }
        if (toReplace.size() > 0) {
            Cfg.travelMod(method.stmts, new Cfg.TravelCallBack() {
                @Override
                public Value onAssign(Local v, AssignStmt as) {
                    return v;
                }

                @Override
                public Value onUse(Local v) {
                    Local n = toReplace.get(v);
                    return n == null ? v : n;
                }
            }, true);
        }
        return irChanged;
    }",maybe_loop_control
local,"{
        boolean irChanged = false;
        List<AssignStmt> assignStmtList = new ArrayList<>();
        List<LabelStmt> phiLabels = method.phiLabels;
        for (Stmt p = method.stmts.getFirst(); p != null; p = p.getNext()) {
            if (p.st == Stmt.ST.ASSIGN) {
                AssignStmt as = (AssignStmt) p;
                if (as.getOp1().vt == Value.VT.LOCAL && as.getOp2().vt == Value.VT.LOCAL) {
                    assignStmtList.add(as);
                }
            }
        }
        final Map<Local, Local> toReplace = new HashMap<>();
        Set<Value> set = new HashSet<>();
        boolean changed = true;
        while (changed) {
            changed = false;

            if (removeLoopFromPhi(phiLabels, toReplace)) {
                fixReplace(toReplace);
                replacePhi(phiLabels, toReplace, set);
            }

            while (simplePhi(phiLabels, toReplace, set)) {// remove a = phi(b)
                fixReplace(toReplace);
                replacePhi(phiLabels, toReplace, set);
            }
            while (simpleAssign(phiLabels, assignStmtList, toReplace, method.stmts)) {// remove a=b
                fixReplace(toReplace);
                replaceAssign(assignStmtList, toReplace);
                changed = true;
                irChanged = true;
            }
            replacePhi(phiLabels, toReplace, set);
        }

        for (Local local : toReplace.keySet()) {
            method.locals.remove(local);
            irChanged = true;
        }
        if (toReplace.size() > 0) {
            Cfg.travelMod(method.stmts, new Cfg.TravelCallBack() {
                @Override
                public Value onAssign(Local v, AssignStmt as) {
                    return v;
                }

                @Override
                public Value onUse(Local v) {
                    Local n = toReplace.get(v);
                    return n == null ? v : n;
                }
            }, true);
        }
        return irChanged;
    }",iterator
var,"{
        if (vars != null) {
            for (LocalVar var : vars) {
                uselabels.add(var.start);
                uselabels.add(var.end);
            }
        }

    }",iterator
p,"{
        for (Stmt p = stmts.getFirst(); p != null;) {
            if (p.st == ST.LABEL) {
                if (!uselabels.contains(p)) {
                    Stmt q = p.getNext();
                    stmts.remove(p);
                    p = q;
                    continue;
                }
            }
            p = p.getNext();
        }
    }",maybe_loop_control
p,"{
        for (Stmt p = stmts.getFirst(); p != null; p = p.getNext()) {
            if (p instanceof JumpStmt) {
                labels.add(((JumpStmt) p).getTarget());
            } else if (p instanceof BaseSwitchStmt) {
                BaseSwitchStmt stmt = (BaseSwitchStmt) p;
                labels.add(stmt.defaultTarget);
                for (LabelStmt t : stmt.targets) {
                    labels.add(t);
                }
            }
        }
    }",maybe_loop_control
t,"{
        for (Stmt p = stmts.getFirst(); p != null; p = p.getNext()) {
            if (p instanceof JumpStmt) {
                labels.add(((JumpStmt) p).getTarget());
            } else if (p instanceof BaseSwitchStmt) {
                BaseSwitchStmt stmt = (BaseSwitchStmt) p;
                labels.add(stmt.defaultTarget);
                for (LabelStmt t : stmt.targets) {
                    labels.add(t);
                }
            }
        }
    }",iterator
trap,"{
        if (traps != null) {
            for (Trap trap : traps) {
                labels.add(trap.start);
                labels.add(trap.end);
                for (LabelStmt h : trap.handlers) {
                    labels.add(h);
                }
            }
        }
    }",iterator
h,"{
        if (traps != null) {
            for (Trap trap : traps) {
                labels.add(trap.start);
                labels.add(trap.end);
                for (LabelStmt h : trap.handlers) {
                    labels.add(h);
                }
            }
        }
    }",iterator
d1,"{
        final boolean changed[] = {false};
        new StmtTraveler() {
            @Override
            public Value travel(Value op) {
                if (op.vt == Value.VT.CHECK_CAST) {
                    TypeExpr te = (TypeExpr) op;
                    if (te.op.vt == Value.VT.CHECK_CAST) {
                        TypeExpr te2 = (TypeExpr) te.op;
                        if (te.type.equals(te2.type)) {
                            op = te2;
                        }
                    }
                }
                op = super.travel(op);


                if (op.vt == Value.VT.CHECK_CAST) {
                    TypeExpr te = (TypeExpr) op;
                    if (te.type.charAt(0) == '[') {
                        Value from = te.getOp();
                        if (from.vt == Value.VT.INVOKE_STATIC) {
                            InvokeExpr invokeExpr = (InvokeExpr) from;
                            if (invokeExpr.getName().equals(""newInstance"")
                                    && invokeExpr.getOwner().equals(""Ljava/lang/reflect/Array;"")
                                    && invokeExpr.getArgs().length == 2
                                    && invokeExpr.getArgs()[0].equals(""Ljava/lang/Class;"")) {
                                Value arg0 = invokeExpr.getOps()[0];
                                String elementType = null;
                                if (arg0.vt == Value.VT.CONSTANT) {
                                    elementType = ((DexType) ((Constant) invokeExpr.getOps()[0]).value).desc;
                                } else {
                                    if (arg0.vt == Value.VT.STATIC_FIELD) {
                                        StaticFieldExpr sfe = (StaticFieldExpr) arg0;
                                        if (sfe.owner.startsWith(""Ljava/lang/"") && sfe.name.equals(""TYPE"")) {
                                            switch (sfe.owner) {
                                                case ""Ljava/lang/Boolean;"":
                                                    elementType = ""Z"";
                                                    break;
                                                case ""Ljava/lang/Byte;"":
                                                    elementType = ""B"";
                                                    break;
                                                case ""Ljava/lang/Short;"":
                                                    elementType = ""S"";
                                                    break;
                                                case ""Ljava/lang/Character;"":
                                                    elementType = ""C"";
                                                    break;
                                                case ""Ljava/lang/Integer;"":
                                                    elementType = ""I"";
                                                    break;
                                                case ""Ljava/lang/Long;"":
                                                    elementType = ""J"";
                                                    break;
                                                case ""Ljava/lang/Float;"":
                                                    elementType = ""F"";
                                                    break;
                                                case ""Ljava/lang/Double;"":
                                                    elementType = ""D"";
                                                    break;
                                                case ""Ljava/lang/Void;"":
                                                    elementType = ""V"";
                                                    break;
                                                default:
                                            }
                                        }
                                    }
                                }
                                if (elementType != null) {
                                    Value dt = invokeExpr.getOps()[1];
                                    if (invokeExpr.getArgs()[1].equals(""I"")) {
                                        if (te.type.equals(""["" + elementType)) {
                                            int d = 0;
                                            while (elementType.charAt(d) == '[') {
                                                d++;
                                            }
                                            changed[0] = true;
                                            if (d > 0) {
                                                return Exprs.nNewMutiArray(elementType.substring(d), d + 1, new Value[]{dt});
                                            } else {
                                                return Exprs.nNewArray(elementType, dt);
                                            }
                                        }
                                    } else {// [I
                                        if (dt.vt == Value.VT.FILLED_ARRAY) {
                                            FilledArrayExpr filledArrayExpr = (FilledArrayExpr) dt;
                                            int d = filledArrayExpr.getOps().length;
                                            if (te.type.length() > d && te.type.substring(d).equals(elementType)) {
                                                int d1 = 0;
                                                while (elementType.charAt(d1) == '[') {
                                                    d1++;
                                                }
                                                changed[0] = true;
                                                return Exprs.nNewMutiArray(elementType.substring(d1), d1 + d, filledArrayExpr.getOps());
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
                return op;
            }
        }.travel(method);

        return changed[0];
    }",loop_control
elementType,"{
        final boolean changed[] = {false};
        new StmtTraveler() {
            @Override
            public Value travel(Value op) {
                if (op.vt == Value.VT.CHECK_CAST) {
                    TypeExpr te = (TypeExpr) op;
                    if (te.op.vt == Value.VT.CHECK_CAST) {
                        TypeExpr te2 = (TypeExpr) te.op;
                        if (te.type.equals(te2.type)) {
                            op = te2;
                        }
                    }
                }
                op = super.travel(op);


                if (op.vt == Value.VT.CHECK_CAST) {
                    TypeExpr te = (TypeExpr) op;
                    if (te.type.charAt(0) == '[') {
                        Value from = te.getOp();
                        if (from.vt == Value.VT.INVOKE_STATIC) {
                            InvokeExpr invokeExpr = (InvokeExpr) from;
                            if (invokeExpr.getName().equals(""newInstance"")
                                    && invokeExpr.getOwner().equals(""Ljava/lang/reflect/Array;"")
                                    && invokeExpr.getArgs().length == 2
                                    && invokeExpr.getArgs()[0].equals(""Ljava/lang/Class;"")) {
                                Value arg0 = invokeExpr.getOps()[0];
                                String elementType = null;
                                if (arg0.vt == Value.VT.CONSTANT) {
                                    elementType = ((DexType) ((Constant) invokeExpr.getOps()[0]).value).desc;
                                } else {
                                    if (arg0.vt == Value.VT.STATIC_FIELD) {
                                        StaticFieldExpr sfe = (StaticFieldExpr) arg0;
                                        if (sfe.owner.startsWith(""Ljava/lang/"") && sfe.name.equals(""TYPE"")) {
                                            switch (sfe.owner) {
                                                case ""Ljava/lang/Boolean;"":
                                                    elementType = ""Z"";
                                                    break;
                                                case ""Ljava/lang/Byte;"":
                                                    elementType = ""B"";
                                                    break;
                                                case ""Ljava/lang/Short;"":
                                                    elementType = ""S"";
                                                    break;
                                                case ""Ljava/lang/Character;"":
                                                    elementType = ""C"";
                                                    break;
                                                case ""Ljava/lang/Integer;"":
                                                    elementType = ""I"";
                                                    break;
                                                case ""Ljava/lang/Long;"":
                                                    elementType = ""J"";
                                                    break;
                                                case ""Ljava/lang/Float;"":
                                                    elementType = ""F"";
                                                    break;
                                                case ""Ljava/lang/Double;"":
                                                    elementType = ""D"";
                                                    break;
                                                case ""Ljava/lang/Void;"":
                                                    elementType = ""V"";
                                                    break;
                                                default:
                                            }
                                        }
                                    }
                                }
                                if (elementType != null) {
                                    Value dt = invokeExpr.getOps()[1];
                                    if (invokeExpr.getArgs()[1].equals(""I"")) {
                                        if (te.type.equals(""["" + elementType)) {
                                            int d = 0;
                                            while (elementType.charAt(d) == '[') {
                                                d++;
                                            }
                                            changed[0] = true;
                                            if (d > 0) {
                                                return Exprs.nNewMutiArray(elementType.substring(d), d + 1, new Value[]{dt});
                                            } else {
                                                return Exprs.nNewArray(elementType, dt);
                                            }
                                        }
                                    } else {// [I
                                        if (dt.vt == Value.VT.FILLED_ARRAY) {
                                            FilledArrayExpr filledArrayExpr = (FilledArrayExpr) dt;
                                            int d = filledArrayExpr.getOps().length;
                                            if (te.type.length() > d && te.type.substring(d).equals(elementType)) {
                                                int d1 = 0;
                                                while (elementType.charAt(d1) == '[') {
                                                    d1++;
                                                }
                                                changed[0] = true;
                                                return Exprs.nNewMutiArray(elementType.substring(d1), d1 + d, filledArrayExpr.getOps());
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
                return op;
            }
        }.travel(method);

        return changed[0];
    }",maybe_loop_control
p,"{
        List<Stmt> tmp = new ArrayList<>();
        N n = new N(tmp, method.locals);
        for (Stmt p = method.stmts.getFirst(); p != null; p = p.getNext()) {
            tmp.clear();
            convertStmt(p, n);
            for (Stmt t : tmp) {
                method.stmts.insertBefore(p, t);
            }

        }
    }",maybe_loop_control
t,"{
        List<Stmt> tmp = new ArrayList<>();
        N n = new N(tmp, method.locals);
        for (Stmt p = method.stmts.getFirst(); p != null; p = p.getNext()) {
            tmp.clear();
            convertStmt(p, n);
            for (Stmt t : tmp) {
                method.stmts.insertBefore(p, t);
            }

        }
    }",iterator
i,"{
        switch (x.et) {
        case E0:
            if (!keep) {
                switch (x.vt) {
                case CONSTANT:
                    Constant cst = (Constant) x;
                    if (cst.value instanceof String || cst.value instanceof DexType
                            || cst.value.getClass().isArray()) {
                        return tmp.newAssign(x);
                    }
                    break;
                case NEW:
                case STATIC_FIELD:
                    return tmp.newAssign(x);
                default:
                }
            }
            break;
        case E1:
            x.setOp(convertExpr(x.getOp(), false, tmp));
            if (!keep) {
                return tmp.newAssign(x);
            }
            break;
        case E2:
            x.setOp1(convertExpr(x.getOp1(), false, tmp));
            x.setOp2(convertExpr(x.getOp2(), false, tmp));
            if (!keep) {
                return tmp.newAssign(x);
            }
            break;
        case En:
            Value[] ops = x.getOps();
            for (int i = 0; i < ops.length; i++) {
                ops[i] = convertExpr(ops[i], false, tmp);
            }
            if (!keep) {
                return tmp.newAssign(x);
            }
            break;
        }

        return x;
    }",loop_control
i,"{
        switch (p.et) {
        case E0:
            return;
        case E1:
            boolean keep;
            switch (p.st) {
            case LOOKUP_SWITCH:
            case TABLE_SWITCH:
            case RETURN:
            case THROW:
                keep = false;
                break;
            default:
                keep = true;
                break;
            }
            p.setOp(convertExpr(p.getOp(), keep, tmp));
            break;
        case E2:
            if (p.st == ST.IDENTITY) {
                return;
            } else if (p.st == ST.FILL_ARRAY_DATA) {
                p.setOp1(convertExpr(p.getOp1(), false, tmp));
                p.setOp2(convertExpr(p.getOp2(), true, tmp));
            } else {
                p.setOp1(convertExpr(p.getOp1(), true, tmp));
                p.setOp2(convertExpr(p.getOp2(), p.getOp1().vt == VT.LOCAL, tmp));
            }
            break;
        case En:
            Value[] ops = p.getOps();
            for (int i = 0; i < ops.length; i++) {
                ops[i] = convertExpr(ops[i], true, tmp);
            }
            break;
        }
    }",loop_control
t,"{
        boolean result = false;
        for (T t : c) {
            if (add(t)) {
                result = true;
            }
        }
        return result;

    }",loop_control
it,"{
        Cfg.createCFG(method);
        Cfg.dfsVisit(method, null);
        if (method.traps != null) {
            for (Iterator<Trap> it = method.traps.iterator(); it.hasNext();) {
                Trap t = it.next();
                boolean allNotThrow = true;
                for (Stmt p = t.start; p != t.end; p = p.getNext()) {
                    if (p.visited && Cfg.isThrow(p)) {
                        allNotThrow = false;
                        break;
                    }
                }
                if (allNotThrow) {
                    it.remove();
                    continue;
                }

                boolean allNotVisited = true;
                boolean allVisited = true;
                for (LabelStmt labelStmt : t.handlers) {
                    if (labelStmt.visited) {
                        allNotVisited = false;
                    } else {
                        allVisited = false;
                    }
                }
                if (allNotVisited) {
                    it.remove();
                } else {
                    // keep start and end
                    t.start.visited = true;
                    t.end.visited = true;
                    if (!allVisited) { // part visited
                        List<String> types = new ArrayList<>(t.handlers.length);
                        List<LabelStmt> labelStmts = new ArrayList<>(t.handlers.length);
                        for (int i = 0; i < t.handlers.length; i++) {
                            labelStmts.add(t.handlers[i]);
                            types.add(t.types[i]);
                        }
                        t.handlers = labelStmts.toArray(new LabelStmt[labelStmts.size()]);
                        t.types = types.toArray(new String[types.size()]);
                    }
                }
            }
        }
        Set<Local> definedLocals = new HashSet<>();
        for (Iterator<Stmt> it = method.stmts.iterator(); it.hasNext();) {
            Stmt p = it.next();
            if (!p.visited) {
                it.remove();
                continue;
            }
            if (p.st == Stmt.ST.ASSIGN || p.st == Stmt.ST.IDENTITY) {
                if (p.getOp1().vt == Value.VT.LOCAL) {
                    definedLocals.add((Local) p.getOp1());
                }
            }
        }
        if (method.phiLabels != null) {
            for (Iterator<LabelStmt> it = method.phiLabels.iterator(); it.hasNext();) {
                LabelStmt labelStmt = it.next();
                if (!labelStmt.visited) {
                    it.remove();
                    continue;
                }
                if (labelStmt.phis != null) {
                    for (AssignStmt phi : labelStmt.phis) {
                        definedLocals.add((Local) phi.getOp1());
                    }
                }
            }
        }

        method.locals.clear();
        method.locals.addAll(definedLocals);
        Set<Value> tmp = new HashSet<>();
        if (method.phiLabels != null) {
            for (Iterator<LabelStmt> it = method.phiLabels.iterator(); it.hasNext();) {
                LabelStmt labelStmt = it.next();
                if (labelStmt.phis != null) {
                    for (AssignStmt phi : labelStmt.phis) {
                        PhiExpr phiExpr = (PhiExpr) phi.getOp2();
                        boolean needRebuild = false;
                        for (Value v : phiExpr.getOps()) {
                            if (!definedLocals.contains(v)) {
                                needRebuild = true;
                                break;
                            }
                        }
                        if (needRebuild) {
                            for (Value v : phiExpr.getOps()) {
                                if (definedLocals.contains(v)) {
                                    tmp.add(v);
                                }
                            }
                            phiExpr.setOps(tmp.toArray(new Value[tmp.size()]));
                            tmp.clear();
                        }
                    }
                }
            }
        }
    }",iterator
p,"{
        Cfg.createCFG(method);
        Cfg.dfsVisit(method, null);
        if (method.traps != null) {
            for (Iterator<Trap> it = method.traps.iterator(); it.hasNext();) {
                Trap t = it.next();
                boolean allNotThrow = true;
                for (Stmt p = t.start; p != t.end; p = p.getNext()) {
                    if (p.visited && Cfg.isThrow(p)) {
                        allNotThrow = false;
                        break;
                    }
                }
                if (allNotThrow) {
                    it.remove();
                    continue;
                }

                boolean allNotVisited = true;
                boolean allVisited = true;
                for (LabelStmt labelStmt : t.handlers) {
                    if (labelStmt.visited) {
                        allNotVisited = false;
                    } else {
                        allVisited = false;
                    }
                }
                if (allNotVisited) {
                    it.remove();
                } else {
                    // keep start and end
                    t.start.visited = true;
                    t.end.visited = true;
                    if (!allVisited) { // part visited
                        List<String> types = new ArrayList<>(t.handlers.length);
                        List<LabelStmt> labelStmts = new ArrayList<>(t.handlers.length);
                        for (int i = 0; i < t.handlers.length; i++) {
                            labelStmts.add(t.handlers[i]);
                            types.add(t.types[i]);
                        }
                        t.handlers = labelStmts.toArray(new LabelStmt[labelStmts.size()]);
                        t.types = types.toArray(new String[types.size()]);
                    }
                }
            }
        }
        Set<Local> definedLocals = new HashSet<>();
        for (Iterator<Stmt> it = method.stmts.iterator(); it.hasNext();) {
            Stmt p = it.next();
            if (!p.visited) {
                it.remove();
                continue;
            }
            if (p.st == Stmt.ST.ASSIGN || p.st == Stmt.ST.IDENTITY) {
                if (p.getOp1().vt == Value.VT.LOCAL) {
                    definedLocals.add((Local) p.getOp1());
                }
            }
        }
        if (method.phiLabels != null) {
            for (Iterator<LabelStmt> it = method.phiLabels.iterator(); it.hasNext();) {
                LabelStmt labelStmt = it.next();
                if (!labelStmt.visited) {
                    it.remove();
                    continue;
                }
                if (labelStmt.phis != null) {
                    for (AssignStmt phi : labelStmt.phis) {
                        definedLocals.add((Local) phi.getOp1());
                    }
                }
            }
        }

        method.locals.clear();
        method.locals.addAll(definedLocals);
        Set<Value> tmp = new HashSet<>();
        if (method.phiLabels != null) {
            for (Iterator<LabelStmt> it = method.phiLabels.iterator(); it.hasNext();) {
                LabelStmt labelStmt = it.next();
                if (labelStmt.phis != null) {
                    for (AssignStmt phi : labelStmt.phis) {
                        PhiExpr phiExpr = (PhiExpr) phi.getOp2();
                        boolean needRebuild = false;
                        for (Value v : phiExpr.getOps()) {
                            if (!definedLocals.contains(v)) {
                                needRebuild = true;
                                break;
                            }
                        }
                        if (needRebuild) {
                            for (Value v : phiExpr.getOps()) {
                                if (definedLocals.contains(v)) {
                                    tmp.add(v);
                                }
                            }
                            phiExpr.setOps(tmp.toArray(new Value[tmp.size()]));
                            tmp.clear();
                        }
                    }
                }
            }
        }
    }",maybe_loop_control
p,"{
        Cfg.createCFG(method);
        Cfg.dfsVisit(method, null);
        if (method.traps != null) {
            for (Iterator<Trap> it = method.traps.iterator(); it.hasNext();) {
                Trap t = it.next();
                boolean allNotThrow = true;
                for (Stmt p = t.start; p != t.end; p = p.getNext()) {
                    if (p.visited && Cfg.isThrow(p)) {
                        allNotThrow = false;
                        break;
                    }
                }
                if (allNotThrow) {
                    it.remove();
                    continue;
                }

                boolean allNotVisited = true;
                boolean allVisited = true;
                for (LabelStmt labelStmt : t.handlers) {
                    if (labelStmt.visited) {
                        allNotVisited = false;
                    } else {
                        allVisited = false;
                    }
                }
                if (allNotVisited) {
                    it.remove();
                } else {
                    // keep start and end
                    t.start.visited = true;
                    t.end.visited = true;
                    if (!allVisited) { // part visited
                        List<String> types = new ArrayList<>(t.handlers.length);
                        List<LabelStmt> labelStmts = new ArrayList<>(t.handlers.length);
                        for (int i = 0; i < t.handlers.length; i++) {
                            labelStmts.add(t.handlers[i]);
                            types.add(t.types[i]);
                        }
                        t.handlers = labelStmts.toArray(new LabelStmt[labelStmts.size()]);
                        t.types = types.toArray(new String[types.size()]);
                    }
                }
            }
        }
        Set<Local> definedLocals = new HashSet<>();
        for (Iterator<Stmt> it = method.stmts.iterator(); it.hasNext();) {
            Stmt p = it.next();
            if (!p.visited) {
                it.remove();
                continue;
            }
            if (p.st == Stmt.ST.ASSIGN || p.st == Stmt.ST.IDENTITY) {
                if (p.getOp1().vt == Value.VT.LOCAL) {
                    definedLocals.add((Local) p.getOp1());
                }
            }
        }
        if (method.phiLabels != null) {
            for (Iterator<LabelStmt> it = method.phiLabels.iterator(); it.hasNext();) {
                LabelStmt labelStmt = it.next();
                if (!labelStmt.visited) {
                    it.remove();
                    continue;
                }
                if (labelStmt.phis != null) {
                    for (AssignStmt phi : labelStmt.phis) {
                        definedLocals.add((Local) phi.getOp1());
                    }
                }
            }
        }

        method.locals.clear();
        method.locals.addAll(definedLocals);
        Set<Value> tmp = new HashSet<>();
        if (method.phiLabels != null) {
            for (Iterator<LabelStmt> it = method.phiLabels.iterator(); it.hasNext();) {
                LabelStmt labelStmt = it.next();
                if (labelStmt.phis != null) {
                    for (AssignStmt phi : labelStmt.phis) {
                        PhiExpr phiExpr = (PhiExpr) phi.getOp2();
                        boolean needRebuild = false;
                        for (Value v : phiExpr.getOps()) {
                            if (!definedLocals.contains(v)) {
                                needRebuild = true;
                                break;
                            }
                        }
                        if (needRebuild) {
                            for (Value v : phiExpr.getOps()) {
                                if (definedLocals.contains(v)) {
                                    tmp.add(v);
                                }
                            }
                            phiExpr.setOps(tmp.toArray(new Value[tmp.size()]));
                            tmp.clear();
                        }
                    }
                }
            }
        }
    }",break_loop_control
labelStmt,"{
        Cfg.createCFG(method);
        Cfg.dfsVisit(method, null);
        if (method.traps != null) {
            for (Iterator<Trap> it = method.traps.iterator(); it.hasNext();) {
                Trap t = it.next();
                boolean allNotThrow = true;
                for (Stmt p = t.start; p != t.end; p = p.getNext()) {
                    if (p.visited && Cfg.isThrow(p)) {
                        allNotThrow = false;
                        break;
                    }
                }
                if (allNotThrow) {
                    it.remove();
                    continue;
                }

                boolean allNotVisited = true;
                boolean allVisited = true;
                for (LabelStmt labelStmt : t.handlers) {
                    if (labelStmt.visited) {
                        allNotVisited = false;
                    } else {
                        allVisited = false;
                    }
                }
                if (allNotVisited) {
                    it.remove();
                } else {
                    // keep start and end
                    t.start.visited = true;
                    t.end.visited = true;
                    if (!allVisited) { // part visited
                        List<String> types = new ArrayList<>(t.handlers.length);
                        List<LabelStmt> labelStmts = new ArrayList<>(t.handlers.length);
                        for (int i = 0; i < t.handlers.length; i++) {
                            labelStmts.add(t.handlers[i]);
                            types.add(t.types[i]);
                        }
                        t.handlers = labelStmts.toArray(new LabelStmt[labelStmts.size()]);
                        t.types = types.toArray(new String[types.size()]);
                    }
                }
            }
        }
        Set<Local> definedLocals = new HashSet<>();
        for (Iterator<Stmt> it = method.stmts.iterator(); it.hasNext();) {
            Stmt p = it.next();
            if (!p.visited) {
                it.remove();
                continue;
            }
            if (p.st == Stmt.ST.ASSIGN || p.st == Stmt.ST.IDENTITY) {
                if (p.getOp1().vt == Value.VT.LOCAL) {
                    definedLocals.add((Local) p.getOp1());
                }
            }
        }
        if (method.phiLabels != null) {
            for (Iterator<LabelStmt> it = method.phiLabels.iterator(); it.hasNext();) {
                LabelStmt labelStmt = it.next();
                if (!labelStmt.visited) {
                    it.remove();
                    continue;
                }
                if (labelStmt.phis != null) {
                    for (AssignStmt phi : labelStmt.phis) {
                        definedLocals.add((Local) phi.getOp1());
                    }
                }
            }
        }

        method.locals.clear();
        method.locals.addAll(definedLocals);
        Set<Value> tmp = new HashSet<>();
        if (method.phiLabels != null) {
            for (Iterator<LabelStmt> it = method.phiLabels.iterator(); it.hasNext();) {
                LabelStmt labelStmt = it.next();
                if (labelStmt.phis != null) {
                    for (AssignStmt phi : labelStmt.phis) {
                        PhiExpr phiExpr = (PhiExpr) phi.getOp2();
                        boolean needRebuild = false;
                        for (Value v : phiExpr.getOps()) {
                            if (!definedLocals.contains(v)) {
                                needRebuild = true;
                                break;
                            }
                        }
                        if (needRebuild) {
                            for (Value v : phiExpr.getOps()) {
                                if (definedLocals.contains(v)) {
                                    tmp.add(v);
                                }
                            }
                            phiExpr.setOps(tmp.toArray(new Value[tmp.size()]));
                            tmp.clear();
                        }
                    }
                }
            }
        }
    }",iterator
i,"{
        Cfg.createCFG(method);
        Cfg.dfsVisit(method, null);
        if (method.traps != null) {
            for (Iterator<Trap> it = method.traps.iterator(); it.hasNext();) {
                Trap t = it.next();
                boolean allNotThrow = true;
                for (Stmt p = t.start; p != t.end; p = p.getNext()) {
                    if (p.visited && Cfg.isThrow(p)) {
                        allNotThrow = false;
                        break;
                    }
                }
                if (allNotThrow) {
                    it.remove();
                    continue;
                }

                boolean allNotVisited = true;
                boolean allVisited = true;
                for (LabelStmt labelStmt : t.handlers) {
                    if (labelStmt.visited) {
                        allNotVisited = false;
                    } else {
                        allVisited = false;
                    }
                }
                if (allNotVisited) {
                    it.remove();
                } else {
                    // keep start and end
                    t.start.visited = true;
                    t.end.visited = true;
                    if (!allVisited) { // part visited
                        List<String> types = new ArrayList<>(t.handlers.length);
                        List<LabelStmt> labelStmts = new ArrayList<>(t.handlers.length);
                        for (int i = 0; i < t.handlers.length; i++) {
                            labelStmts.add(t.handlers[i]);
                            types.add(t.types[i]);
                        }
                        t.handlers = labelStmts.toArray(new LabelStmt[labelStmts.size()]);
                        t.types = types.toArray(new String[types.size()]);
                    }
                }
            }
        }
        Set<Local> definedLocals = new HashSet<>();
        for (Iterator<Stmt> it = method.stmts.iterator(); it.hasNext();) {
            Stmt p = it.next();
            if (!p.visited) {
                it.remove();
                continue;
            }
            if (p.st == Stmt.ST.ASSIGN || p.st == Stmt.ST.IDENTITY) {
                if (p.getOp1().vt == Value.VT.LOCAL) {
                    definedLocals.add((Local) p.getOp1());
                }
            }
        }
        if (method.phiLabels != null) {
            for (Iterator<LabelStmt> it = method.phiLabels.iterator(); it.hasNext();) {
                LabelStmt labelStmt = it.next();
                if (!labelStmt.visited) {
                    it.remove();
                    continue;
                }
                if (labelStmt.phis != null) {
                    for (AssignStmt phi : labelStmt.phis) {
                        definedLocals.add((Local) phi.getOp1());
                    }
                }
            }
        }

        method.locals.clear();
        method.locals.addAll(definedLocals);
        Set<Value> tmp = new HashSet<>();
        if (method.phiLabels != null) {
            for (Iterator<LabelStmt> it = method.phiLabels.iterator(); it.hasNext();) {
                LabelStmt labelStmt = it.next();
                if (labelStmt.phis != null) {
                    for (AssignStmt phi : labelStmt.phis) {
                        PhiExpr phiExpr = (PhiExpr) phi.getOp2();
                        boolean needRebuild = false;
                        for (Value v : phiExpr.getOps()) {
                            if (!definedLocals.contains(v)) {
                                needRebuild = true;
                                break;
                            }
                        }
                        if (needRebuild) {
                            for (Value v : phiExpr.getOps()) {
                                if (definedLocals.contains(v)) {
                                    tmp.add(v);
                                }
                            }
                            phiExpr.setOps(tmp.toArray(new Value[tmp.size()]));
                            tmp.clear();
                        }
                    }
                }
            }
        }
    }",loop_control
it,"{
        Cfg.createCFG(method);
        Cfg.dfsVisit(method, null);
        if (method.traps != null) {
            for (Iterator<Trap> it = method.traps.iterator(); it.hasNext();) {
                Trap t = it.next();
                boolean allNotThrow = true;
                for (Stmt p = t.start; p != t.end; p = p.getNext()) {
                    if (p.visited && Cfg.isThrow(p)) {
                        allNotThrow = false;
                        break;
                    }
                }
                if (allNotThrow) {
                    it.remove();
                    continue;
                }

                boolean allNotVisited = true;
                boolean allVisited = true;
                for (LabelStmt labelStmt : t.handlers) {
                    if (labelStmt.visited) {
                        allNotVisited = false;
                    } else {
                        allVisited = false;
                    }
                }
                if (allNotVisited) {
                    it.remove();
                } else {
                    // keep start and end
                    t.start.visited = true;
                    t.end.visited = true;
                    if (!allVisited) { // part visited
                        List<String> types = new ArrayList<>(t.handlers.length);
                        List<LabelStmt> labelStmts = new ArrayList<>(t.handlers.length);
                        for (int i = 0; i < t.handlers.length; i++) {
                            labelStmts.add(t.handlers[i]);
                            types.add(t.types[i]);
                        }
                        t.handlers = labelStmts.toArray(new LabelStmt[labelStmts.size()]);
                        t.types = types.toArray(new String[types.size()]);
                    }
                }
            }
        }
        Set<Local> definedLocals = new HashSet<>();
        for (Iterator<Stmt> it = method.stmts.iterator(); it.hasNext();) {
            Stmt p = it.next();
            if (!p.visited) {
                it.remove();
                continue;
            }
            if (p.st == Stmt.ST.ASSIGN || p.st == Stmt.ST.IDENTITY) {
                if (p.getOp1().vt == Value.VT.LOCAL) {
                    definedLocals.add((Local) p.getOp1());
                }
            }
        }
        if (method.phiLabels != null) {
            for (Iterator<LabelStmt> it = method.phiLabels.iterator(); it.hasNext();) {
                LabelStmt labelStmt = it.next();
                if (!labelStmt.visited) {
                    it.remove();
                    continue;
                }
                if (labelStmt.phis != null) {
                    for (AssignStmt phi : labelStmt.phis) {
                        definedLocals.add((Local) phi.getOp1());
                    }
                }
            }
        }

        method.locals.clear();
        method.locals.addAll(definedLocals);
        Set<Value> tmp = new HashSet<>();
        if (method.phiLabels != null) {
            for (Iterator<LabelStmt> it = method.phiLabels.iterator(); it.hasNext();) {
                LabelStmt labelStmt = it.next();
                if (labelStmt.phis != null) {
                    for (AssignStmt phi : labelStmt.phis) {
                        PhiExpr phiExpr = (PhiExpr) phi.getOp2();
                        boolean needRebuild = false;
                        for (Value v : phiExpr.getOps()) {
                            if (!definedLocals.contains(v)) {
                                needRebuild = true;
                                break;
                            }
                        }
                        if (needRebuild) {
                            for (Value v : phiExpr.getOps()) {
                                if (definedLocals.contains(v)) {
                                    tmp.add(v);
                                }
                            }
                            phiExpr.setOps(tmp.toArray(new Value[tmp.size()]));
                            tmp.clear();
                        }
                    }
                }
            }
        }
    }",iterator
p,"{
        if (method.locals.size() == 0) {
            return false;
        }
        int reads[] = Cfg.countLocalReads(method);
        boolean changed = false;
        for (Stmt p = method.stmts.getFirst(); p != null; p = p.getNext()) {
            if (p.st == Stmt.ST.ASSIGN && p.getOp1().vt == Value.VT.LOCAL) {
                Local left = (Local) p.getOp1();
                if (reads[left._ls_index] == 0) {
                    Value op2 = p.getOp2();
                    if (op2 instanceof AbstractInvokeExpr) {
                        method.locals.remove(left);
                        Stmt nVoidInvoke = Stmts.nVoidInvoke(op2);
                        method.stmts.replace(p, nVoidInvoke);
                        p = nVoidInvoke;
                        changed = true;
                    }
                }
            }
        }
        return changed;
    }",maybe_loop_control
ref,"{
        TypeAnalyze ta = new TypeAnalyze(irMethod);
        List<TypeRef> refs = ta.analyze();

        for (TypeRef ref : refs) {
            String type = ref.getType();

            if (type == null) {
                System.err.println(ref);
                continue;
            }

            if (ref.value.vt == VT.CONSTANT) {
                Constant cst = (Constant) ref.value;
                switch (type.charAt(0)) {
                    case '[':
                    case 'L':
                        if (Integer.valueOf(0).equals(cst.value)) {
                            cst.value = Constant.Null;
                        }
                        if (type.equals(""[F"") && cst.value instanceof int[]) {
                            int x[] = (int[]) cst.value;
                            float f[] = new float[x.length];
                            for (int i = 0; i < x.length; i++) {
                                f[i] = Float.intBitsToFloat(x[i]);
                            }
                            cst.value = f;
                        }
                        if (type.equals(""[D"") && cst.value instanceof long[]) {
                            long x[] = (long[]) cst.value;
                            double f[] = new double[x.length];
                            for (int i = 0; i < x.length; i++) {
                                f[i] = Double.longBitsToDouble(x[i]);
                            }
                            cst.value = f;
                        }
                        break;
                    case 'F':
                        if (!(cst.value instanceof Float)) {
                            cst.value = Float.intBitsToFloat(((Number) cst.value).intValue());
                        }
                        break;
                    case 'D':
                        if (!(cst.value instanceof Double)) {
                            cst.value = Double.longBitsToDouble(((Number) cst.value).longValue());
                        }
                        break;
                    default:
                }
            }
            Value value = ref.value;
            value.valueType = type;
            value.tag = null;
            ref.clear();
        }
    }",iterator
x,"{
            TypeRef x = this;
            while (x.next != null) {
                x = x.next;
            }
            if (x != this) {
                this.next = x;
            }
            return x;
        }",maybe_loop_control
t,"{
            TypeRef thiz = getReal();
            TypeClass clz = thiz.clz;
            if (clz == TypeClass.OBJECT) {
                if (thiz.provideDesc.length() == 1) {
                    return ""Ljava/lang/Object;"";
                } else {
                    return thiz.provideDesc;
                }
            }
            if (clz.fixed && clz != TypeClass.INT) {
                if (thiz.provideDesc == null) {
                    throw new RuntimeException();
                }
                return thiz.provideDesc;
            }
            if (clz == TypeClass.JD) { // prefere Long if wide
                return ""J"";
            }
            if (thiz.uses != null) {
                for (String t : possibleIntTypes) {
                    if (thiz.uses.contains(t)) {
                        return t;
                    }
                }
            }

            switch (clz) {
                case ZI:
                    return ""I"";
                case ZIFL:
                case ZIF:
                case ZIL:
                    return ""Z"";
                case INT:
                case IF:
                    return ""I"";
                default:
            }
            throw new RuntimeException();
        }",iterator
ref,"{
            // 1. collect all Array Roots
            Set<TypeRef> arrayRoots = new HashSet<>();
            for (TypeRef ref : refs) {
                ref = ref.getReal();
                if (ref.gArrayValues != null || ref.sArrayValues != null) {
                    arrayRoots.add(ref);
                }
                mergeArrayRelation(ref, Relation.R_gArrayValues);
                mergeArrayRelation(ref, Relation.R_sArrayValues);
                mergeArrayRelation(ref, Relation.R_arrayRoots);
            }

            UniqueQueue<TypeRef> q = new UniqueQueue<>();
            q.addAll(refs);
            while (!q.isEmpty()) {
                // 2. merge provided type to children. merge uses to parent. merge TypeClass to sameValues
                while (!q.isEmpty()) {
                    TypeRef ref = q.poll();
                    copyTypes(q, ref);
                }
                // 3. merge type from Array Roots to Array Values
                for (TypeRef ref : arrayRoots) {
                    ref = ref.getReal();
                    String provideDesc = ref.provideDesc;
                    if (provideDesc != null && provideDesc.charAt(0) == '[') {
                        String ele = provideDesc.substring(1);

                        TypeClass clz = TypeClass.clzOf(ele);
                        if (ref.gArrayValues != null) {
                            for (TypeRef p : ref.gArrayValues) {
                                p = p.getReal();
                                if (p.updateTypeClass(clz)) {
                                    q.add(p);
                                }
                                mergeTypeToArrayGetValue(ele, p, q);
                            }
                        }
                        if (ref.sArrayValues != null) {
                            for (TypeRef p : ref.sArrayValues) {
                                p = p.getReal();
                                if (p.updateTypeClass(clz)) {
                                    q.add(p);
                                }
                                if (p.addUses(ele)) {
                                    q.add(p);
                                }
                            }
                        }
                    }
                }
            }
        }",iterator
q,"{
            // 1. collect all Array Roots
            Set<TypeRef> arrayRoots = new HashSet<>();
            for (TypeRef ref : refs) {
                ref = ref.getReal();
                if (ref.gArrayValues != null || ref.sArrayValues != null) {
                    arrayRoots.add(ref);
                }
                mergeArrayRelation(ref, Relation.R_gArrayValues);
                mergeArrayRelation(ref, Relation.R_sArrayValues);
                mergeArrayRelation(ref, Relation.R_arrayRoots);
            }

            UniqueQueue<TypeRef> q = new UniqueQueue<>();
            q.addAll(refs);
            while (!q.isEmpty()) {
                // 2. merge provided type to children. merge uses to parent. merge TypeClass to sameValues
                while (!q.isEmpty()) {
                    TypeRef ref = q.poll();
                    copyTypes(q, ref);
                }
                // 3. merge type from Array Roots to Array Values
                for (TypeRef ref : arrayRoots) {
                    ref = ref.getReal();
                    String provideDesc = ref.provideDesc;
                    if (provideDesc != null && provideDesc.charAt(0) == '[') {
                        String ele = provideDesc.substring(1);

                        TypeClass clz = TypeClass.clzOf(ele);
                        if (ref.gArrayValues != null) {
                            for (TypeRef p : ref.gArrayValues) {
                                p = p.getReal();
                                if (p.updateTypeClass(clz)) {
                                    q.add(p);
                                }
                                mergeTypeToArrayGetValue(ele, p, q);
                            }
                        }
                        if (ref.sArrayValues != null) {
                            for (TypeRef p : ref.sArrayValues) {
                                p = p.getReal();
                                if (p.updateTypeClass(clz)) {
                                    q.add(p);
                                }
                                if (p.addUses(ele)) {
                                    q.add(p);
                                }
                            }
                        }
                    }
                }
            }
        }",maybe_loop_control
ref,"{
            // 1. collect all Array Roots
            Set<TypeRef> arrayRoots = new HashSet<>();
            for (TypeRef ref : refs) {
                ref = ref.getReal();
                if (ref.gArrayValues != null || ref.sArrayValues != null) {
                    arrayRoots.add(ref);
                }
                mergeArrayRelation(ref, Relation.R_gArrayValues);
                mergeArrayRelation(ref, Relation.R_sArrayValues);
                mergeArrayRelation(ref, Relation.R_arrayRoots);
            }

            UniqueQueue<TypeRef> q = new UniqueQueue<>();
            q.addAll(refs);
            while (!q.isEmpty()) {
                // 2. merge provided type to children. merge uses to parent. merge TypeClass to sameValues
                while (!q.isEmpty()) {
                    TypeRef ref = q.poll();
                    copyTypes(q, ref);
                }
                // 3. merge type from Array Roots to Array Values
                for (TypeRef ref : arrayRoots) {
                    ref = ref.getReal();
                    String provideDesc = ref.provideDesc;
                    if (provideDesc != null && provideDesc.charAt(0) == '[') {
                        String ele = provideDesc.substring(1);

                        TypeClass clz = TypeClass.clzOf(ele);
                        if (ref.gArrayValues != null) {
                            for (TypeRef p : ref.gArrayValues) {
                                p = p.getReal();
                                if (p.updateTypeClass(clz)) {
                                    q.add(p);
                                }
                                mergeTypeToArrayGetValue(ele, p, q);
                            }
                        }
                        if (ref.sArrayValues != null) {
                            for (TypeRef p : ref.sArrayValues) {
                                p = p.getReal();
                                if (p.updateTypeClass(clz)) {
                                    q.add(p);
                                }
                                if (p.addUses(ele)) {
                                    q.add(p);
                                }
                            }
                        }
                    }
                }
            }
        }",iterator
p,"{
            // 1. collect all Array Roots
            Set<TypeRef> arrayRoots = new HashSet<>();
            for (TypeRef ref : refs) {
                ref = ref.getReal();
                if (ref.gArrayValues != null || ref.sArrayValues != null) {
                    arrayRoots.add(ref);
                }
                mergeArrayRelation(ref, Relation.R_gArrayValues);
                mergeArrayRelation(ref, Relation.R_sArrayValues);
                mergeArrayRelation(ref, Relation.R_arrayRoots);
            }

            UniqueQueue<TypeRef> q = new UniqueQueue<>();
            q.addAll(refs);
            while (!q.isEmpty()) {
                // 2. merge provided type to children. merge uses to parent. merge TypeClass to sameValues
                while (!q.isEmpty()) {
                    TypeRef ref = q.poll();
                    copyTypes(q, ref);
                }
                // 3. merge type from Array Roots to Array Values
                for (TypeRef ref : arrayRoots) {
                    ref = ref.getReal();
                    String provideDesc = ref.provideDesc;
                    if (provideDesc != null && provideDesc.charAt(0) == '[') {
                        String ele = provideDesc.substring(1);

                        TypeClass clz = TypeClass.clzOf(ele);
                        if (ref.gArrayValues != null) {
                            for (TypeRef p : ref.gArrayValues) {
                                p = p.getReal();
                                if (p.updateTypeClass(clz)) {
                                    q.add(p);
                                }
                                mergeTypeToArrayGetValue(ele, p, q);
                            }
                        }
                        if (ref.sArrayValues != null) {
                            for (TypeRef p : ref.sArrayValues) {
                                p = p.getReal();
                                if (p.updateTypeClass(clz)) {
                                    q.add(p);
                                }
                                if (p.addUses(ele)) {
                                    q.add(p);
                                }
                            }
                        }
                    }
                }
            }
        }",iterator
i,"{
            Set<TypeRef> v = r.get(ref);
            if (v != null && v.size() > 1) {
                List<TypeRef> copy = new ArrayList<>(v);
                TypeRef mergeTo = copy.get(0).getReal();
                for (int i = 1; i < copy.size(); i++) {
                    mergeTo.merge(copy.get(i));
                }
            }
        }",loop_control
i,"{
            if (a.equals(b)) {
                return a;
            }
            int as = countArrayDim(a);
            int bs = countArrayDim(b);
            if (as > bs) {
                return a;
            } else if (bs > as) {
                return b;
            } else { // as==bs;
                String elementTypeA = a.substring(as);
                String elementTypeB = a.substring(bs);
                TypeClass ta = TypeClass.clzOf(elementTypeA);
                TypeClass tb = TypeClass.clzOf(elementTypeB);
                if (ta.fixed && !tb.fixed) {
                    return a;
                } else if (!ta.fixed && tb.fixed) {
                    return b;
                } else if (ta.fixed && tb.fixed) {
                    if (ta != tb) {
                        if (as == 0) {
                            throw new RuntimeException();
                        }
                        return buildArray(as - 1, ""L"");
                    }
                    if (ta == TypeClass.INT) {
                        String chooseType = ""I"";
                        for (int i = possibleIntTypes.length - 1; i >= 0; i--) {
                            String t = possibleIntTypes[i];
                            if (a.equals(t) || b.equals(t)) {
                                chooseType = t;
                                break;
                            }
                        }
                        return buildArray(as, chooseType);
                    } else {
                        return buildArray(as, ""L"");
                    }
                } else { // !ta.fixed && !tb.fixed
                    return buildArray(as, TypeClass.merge(ta, tb).name);
                }
            }
        }",loop_control
p,"{
            ref = ref.getReal();
            TypeClass clz = ref.clz;

            switch (clz) {
                case BOOLEAN:
                case FLOAT:
                case LONG:
                case DOUBLE:
                case VOID:
                    ref.provideDesc = clz.name;
                    break;
                default:
            }
            String provideDesc = ref.provideDesc;
            if (provideDesc == null && ref.parents != null && ref.parents.size() > 1) {
                if (isAllParentSetted(ref)) {
                    ref.provideDesc = provideDesc = mergeParentType(ref.parents);
                }
            }
            if (ref.parents != null) {
                for (TypeRef p : ref.parents) {
                    p = p.getReal();
                    if (p.updateTypeClass(clz)) {
                        q.add(p);
                    }
                    if (ref.uses != null) {
                        if (p.addAllUses(ref.uses)) {
                            q.add(p);
                        }
                    }
                }
            }
            if (ref.children != null) {
                for (TypeRef p : ref.children) {
                    p = p.getReal();
                    if (p.updateTypeClass(clz)) {
                        q.add(p);
                    }

                    if (provideDesc != null) {
                        mergeTypeToSubRef(provideDesc, p, q);
                    }
                }
            }
            if (ref.sameValues != null) {
                for (TypeRef p : ref.sameValues) {
                    p = p.getReal();
                    if (p.updateTypeClass(clz)) {
                        q.add(p);
                    }
                }
            }
        }",iterator
p,"{
            boolean allAreSet = true;
            for (TypeRef p : ref.parents) {
                if (p.getProvideDesc() == null) {
                    allAreSet = false;
                    break;
                }
            }
            return allAreSet;
        }",iterator
i,"{
            if (a.equals(b)) {
                return a;
            }
            TypeClass ta = TypeClass.clzOf(a);
            TypeClass tb = TypeClass.clzOf(b);
            if (ta.fixed && !tb.fixed) {
                return a;
            } else if (!ta.fixed && tb.fixed) {
                return b;
            } else if (ta.fixed && tb.fixed) {
                // special allow merge of Z and I
                if ((ta == TypeClass.INT && tb == TypeClass.BOOLEAN) || (tb == TypeClass.INT && ta == TypeClass.BOOLEAN)) {
                    return ""I"";
                }
                if (ta != tb) {
                    throw new RuntimeException();
                }
                if (ta == TypeClass.INT) {
                    for (int i = possibleIntTypes.length - 1; i >= 0; i--) {
                        String t = possibleIntTypes[i];
                        if (a.equals(t) || b.equals(t)) {
                            return t;
                        }
                    }
                    return ""I"";
                } else if (ta == TypeClass.OBJECT) {
                    // [[B + [[C = [Ljava/langObject;
                    int as = countArrayDim(a);
                    int bs = countArrayDim(b);
                    if (as == 0 || bs == 0) {
                        return mergeObjectType(a, b);
                    } else {
                        String elementTypeA = a.substring(as);
                        String elementTypeB = b.substring(bs);
                        if (as < bs) {
                            return buildArray(elementTypeB.charAt(0) == 'L' ? bs : bs - 1, ""L"");
                        } else if (as > bs) {
                            return buildArray(elementTypeA.charAt(0) == 'L' ? as : as - 1, ""L"");
                        } else { // as==bs
                            if (elementTypeA.charAt(0) != 'L' || elementTypeB.charAt(0) != 'L') {
                                return buildArray(as - 1, ""L"");
                            } else {
                                return buildArray(as, ""L"");
                            }
                        }
                    }
                } else {
                    throw new RuntimeException();
                }
            } else { // !ta.fixed && !tb.fixed
                return TypeClass.merge(ta, tb).name;
            }
        }",loop_control
i,"{
            if (dim == 0) {
                return s;
            }
            StringBuilder sb = new StringBuilder();
            for (int i = 0; i < dim; i++) {
                sb.append('[');
            }
            sb.append(s);
            return sb.toString();
        }",loop_control
i,"{
            int i = 0;
            while (a.charAt(i) == '[') {
                i++;
            }
            return i;
        }",loop_control
it,"{
            Iterator<TypeRef> it = parents.iterator();
            String a = it.next().getProvideDesc();
            while (it.hasNext()) {
                a = mergeProviderType(a, it.next().getProvideDesc());
            }
            return a;
        }",iterator
i,"{
            Value vbs[] = enExpr.ops;
            switch (enExpr.vt) {
                case INVOKE_NEW:
                case INVOKE_INTERFACE:
                case INVOKE_SPECIAL:
                case INVOKE_STATIC:
                case INVOKE_VIRTUAL:
                case INVOKE_POLYMORPHIC:
                case INVOKE_CUSTOM: {
                    AbstractInvokeExpr ice = (AbstractInvokeExpr) enExpr;
                    String type = ice.getProto().getReturnType();
                    provideAs(enExpr, type);
                    useAs(enExpr, type); // no one else will use it

                    String argTypes[] = ice.getProto().getParameterTypes();
                    if (argTypes.length == vbs.length) {
                        for (int i = 0; i < vbs.length; i++) {
                            useAs(vbs[i], argTypes[i]);
                        }
                    } else if (argTypes.length + 1 == vbs.length) {
                        useAs(vbs[0], ""L"");
                        for (int i = 1; i < vbs.length; i++) {
                            useAs(vbs[i], argTypes[i - 1]);
                        }
                    } else {
                        throw new RuntimeException();
                    }
                }
                break;

                case FILLED_ARRAY:
                    FilledArrayExpr fae = (FilledArrayExpr) enExpr;
                    for (Value vb : vbs) {
                        useAs(vb, fae.type);
                    }
                    provideAs(fae, ""["" + fae.type);
                    break;
                case NEW_MUTI_ARRAY:
                    NewMutiArrayExpr nmae = (NewMutiArrayExpr) enExpr;
                    for (Value vb : vbs) {
                        useAs(vb, ""I"");
                    }
                    StringBuilder sb = new StringBuilder();
                    for (int i = 0; i < nmae.dimension; i++) {
                        sb.append('[');
                    }
                    sb.append(nmae.baseType);
                    provideAs(nmae, sb.toString());
                    break;
                case PHI:
                    for (Value vb : vbs) {
                        linkFromTo(vb, enExpr);
                    }
                    break;
                default:
            }
            for (Value vb : enExpr.ops) {
                exExpr(vb);
            }
        }",loop_control
vb,"{
            Value vbs[] = enExpr.ops;
            switch (enExpr.vt) {
                case INVOKE_NEW:
                case INVOKE_INTERFACE:
                case INVOKE_SPECIAL:
                case INVOKE_STATIC:
                case INVOKE_VIRTUAL:
                case INVOKE_POLYMORPHIC:
                case INVOKE_CUSTOM: {
                    AbstractInvokeExpr ice = (AbstractInvokeExpr) enExpr;
                    String type = ice.getProto().getReturnType();
                    provideAs(enExpr, type);
                    useAs(enExpr, type); // no one else will use it

                    String argTypes[] = ice.getProto().getParameterTypes();
                    if (argTypes.length == vbs.length) {
                        for (int i = 0; i < vbs.length; i++) {
                            useAs(vbs[i], argTypes[i]);
                        }
                    } else if (argTypes.length + 1 == vbs.length) {
                        useAs(vbs[0], ""L"");
                        for (int i = 1; i < vbs.length; i++) {
                            useAs(vbs[i], argTypes[i - 1]);
                        }
                    } else {
                        throw new RuntimeException();
                    }
                }
                break;

                case FILLED_ARRAY:
                    FilledArrayExpr fae = (FilledArrayExpr) enExpr;
                    for (Value vb : vbs) {
                        useAs(vb, fae.type);
                    }
                    provideAs(fae, ""["" + fae.type);
                    break;
                case NEW_MUTI_ARRAY:
                    NewMutiArrayExpr nmae = (NewMutiArrayExpr) enExpr;
                    for (Value vb : vbs) {
                        useAs(vb, ""I"");
                    }
                    StringBuilder sb = new StringBuilder();
                    for (int i = 0; i < nmae.dimension; i++) {
                        sb.append('[');
                    }
                    sb.append(nmae.baseType);
                    provideAs(nmae, sb.toString());
                    break;
                case PHI:
                    for (Value vb : vbs) {
                        linkFromTo(vb, enExpr);
                    }
                    break;
                default:
            }
            for (Value vb : enExpr.ops) {
                exExpr(vb);
            }
        }",iterator
p,"{
            for (Stmt p = method.stmts.getFirst(); p != null; p = p.getNext()) {
                switch (p.et) {
                    case E0:
                        // label, nop and return-void
                        if (p.st == ST.LABEL) {
                            LabelStmt labelStmt = (LabelStmt) p;
                            if (labelStmt.phis != null) {
                                for (AssignStmt phi : labelStmt.phis) {
                                    s2stmt(phi);
                                }
                            }
                        }
                        break;
                    case E1:
                        s1stmt((E1Stmt) p);
                        break;
                    case E2:
                        s2stmt((E2Stmt) p);
                        break;
                    case En:
                        // no stmt yet
                        // enstmt((EnStmt) p, refs, relationRefs);
                        break;
                }
            }
        }",maybe_loop_control
ref,"{
            StringBuilder sb = new StringBuilder();
            for (TypeRef ref : refs) {
                sb.append(ref).append(""\n"");
            }
            return sb.toString();
        }",iterator
q,"{
        boolean changed = false;


        Set<Stmt> locationSensitiveStmts = new HashSet<>();
        // 1. merge location Insensitive stmts
        changed = simpleMergeLocals(method, changed, locationSensitiveStmts);

        if (locationSensitiveStmts.size() == 0) {
            return changed;
        }

        ReplaceX replaceX = new ReplaceX();
        Queue<Stmt> q = new UniqueQueue<>();
        q.addAll(locationSensitiveStmts);

        // 2. merge location sensitive stmts
        while (!q.isEmpty()) {
            Stmt stmt = q.poll();
            Local local = (Local) stmt.getOp1();
            Stmt next = stmt.getNext();

            switch (next.st) {
                case LABEL:
                case GOTO:
                case IDENTITY:
                case FILL_ARRAY_DATA:
                case NOP:
                case RETURN_VOID:
                    continue;
                default:
            }
            try {
                localCanExecFirst(local, next);
                throw new RuntimeException(); // impossible here
            } catch (MergeResult e) {
                if (e == SUCCESS) {
                    replaceX.local = local;
                    replaceX.replaceWith = stmt.getOp2();
                    method.locals.remove(local);
                    method.stmts.remove(stmt);

                    Cfg.travelMod(next, replaceX, false);

                    Stmt pre = next.getPre();
                    if (pre != null && locationSensitiveStmts.contains(pre)) {
                        q.add(pre);
                    }

                }
            }
        }


        return changed;
    }",maybe_loop_control
v,"{
        switch (op.et) {
            case E0:
                if (local.vt == Value.VT.LOCAL) {
                    if (op == local) {
                        throw SUCCESS;
                    }
                }
                break;
            case E1:
                localCanExecFirst(local, op.getOp());
                break;
            case E2:
                localCanExecFirst(local, op.getOp1());
                localCanExecFirst(local, op.getOp2());
                break;
            case En:
                for (Value v : op.getOps()) {
                    localCanExecFirst(local, v);
                }
        }

        boolean shouldExclude = false;
        if (op.vt == Value.VT.INVOKE_STATIC) {
            InvokeExpr ie = (InvokeExpr) op;
            if (ie.getName().equals(""valueOf"") && ie.getOwner().startsWith(""Ljava/lang/"") && ie.getArgs().length == 1 && ie.getArgs()[0].length() == 1) {
                shouldExclude = true;
            }
        }

        if (!isLocationInsensitive(op.vt) && !shouldExclude) {  // this is the first insensitive Value
            throw FAIL;
        }
    }",iterator
it,"{
        if (method.locals.size() == 0) {
            return false;
        }
        final int[] readCounts = Cfg.countLocalReads(method);
        Set<Local> useInPhi = collectLocalUsedInPhi(method);
        final Map<Local, Value> toReplace = new HashMap<>();
        for (Iterator<Stmt> it = method.stmts.iterator(); it.hasNext(); ) {
            Stmt p = it.next();
            if (p.st == Stmt.ST.ASSIGN && p.getOp1().vt == Value.VT.LOCAL) {
                Local local = (Local) p.getOp1();
                if (useInPhi.contains(local)) {
                    continue;
                }
                if (readCounts[local._ls_index] < 2) {
                    Value op2 = p.getOp2();
                    if (isLocationInsensitive(op2)) {
                        method.locals.remove(local);
                        toReplace.put(local, op2);
                        it.remove();
                        changed = true;
                    } else {
                        locationSensitiveStmts.add(p);
                    }
                }
            }
        }
        Cfg.TravelCallBack tcb = new Cfg.TravelCallBack() {
            @Override
            public Value onAssign(Local v, AssignStmt as) {
                return v;
            }

            @Override
            public Value onUse(Local v) {
                Value v2 = toReplace.get(v);
                if (v2 != null) {
                    return v2;
                }
                return v;
            }
        };

        modReplace(toReplace, tcb);

        Cfg.travelMod(method.stmts, tcb, false);
        return changed;
    }",iterator
labelStmt,"{
        Set<Local> useInPhi = new HashSet<>();
        if (method.phiLabels != null) {
            for (LabelStmt labelStmt : method.phiLabels) {
                if (labelStmt.phis != null) {
                    for (AssignStmt phi : labelStmt.phis) {
                        useInPhi.add((Local) phi.getOp1());
                        for (Value op : phi.getOp2().getOps()) {
                            useInPhi.add((Local) op);
                        }
                    }
                }
            }
        }
        return useInPhi;
    }",iterator
phi,"{
        Set<Local> useInPhi = new HashSet<>();
        if (method.phiLabels != null) {
            for (LabelStmt labelStmt : method.phiLabels) {
                if (labelStmt.phis != null) {
                    for (AssignStmt phi : labelStmt.phis) {
                        useInPhi.add((Local) phi.getOp1());
                        for (Value op : phi.getOp2().getOps()) {
                            useInPhi.add((Local) op);
                        }
                    }
                }
            }
        }
        return useInPhi;
    }",iterator
op,"{
        Set<Local> useInPhi = new HashSet<>();
        if (method.phiLabels != null) {
            for (LabelStmt labelStmt : method.phiLabels) {
                if (labelStmt.phis != null) {
                    for (AssignStmt phi : labelStmt.phis) {
                        useInPhi.add((Local) phi.getOp1());
                        for (Value op : phi.getOp2().getOps()) {
                            useInPhi.add((Local) op);
                        }
                    }
                }
            }
        }
        return useInPhi;
    }",iterator
e,"{
        for (Map.Entry<Local, Value> e : toReplace.entrySet()) {
            Value v = e.getValue();
            if (v.vt == Value.VT.LOCAL) {
                while (true) {
                    Value v2 = toReplace.get(v);
                    if (v2 == null) {
                        break;
                    }
                    v = v2;
                    if (v.vt != Value.VT.LOCAL) {
                        break;
                    }
                }
                e.setValue(v);
            } else {
                Cfg.travelMod(v, tcb);
            }
        }
    }",iterator
v2,"{
        for (Map.Entry<Local, Value> e : toReplace.entrySet()) {
            Value v = e.getValue();
            if (v.vt == Value.VT.LOCAL) {
                while (true) {
                    Value v2 = toReplace.get(v);
                    if (v2 == null) {
                        break;
                    }
                    v = v2;
                    if (v.vt != Value.VT.LOCAL) {
                        break;
                    }
                }
                e.setValue(v);
            } else {
                Cfg.travelMod(v, tcb);
            }
        }
    }",break_loop_control
v,"{
        for (Map.Entry<Local, Value> e : toReplace.entrySet()) {
            Value v = e.getValue();
            if (v.vt == Value.VT.LOCAL) {
                while (true) {
                    Value v2 = toReplace.get(v);
                    if (v2 == null) {
                        break;
                    }
                    v = v2;
                    if (v.vt != Value.VT.LOCAL) {
                        break;
                    }
                }
                e.setValue(v);
            } else {
                Cfg.travelMod(v, tcb);
            }
        }
    }",break_loop_control
v,"{
        switch (op.et) {
            case E0:
                return isLocationInsensitive(op.vt);
            case E1:
                return isLocationInsensitive(op.vt) && isLocationInsensitive(op.getOp());
            case E2:
                return isLocationInsensitive(op.vt) && isLocationInsensitive(op.getOp1()) && isLocationInsensitive(op.getOp2());
            case En:
                if (op.vt == Value.VT.INVOKE_STATIC) {
                    InvokeExpr ie = (InvokeExpr) op;
                    if (ie.getName().equals(""valueOf"") && ie.getOwner().startsWith(""Ljava/lang/"") && ie.getArgs().length == 1 && ie.getArgs()[0].length() == 1) {
                        for (Value v : op.getOps()) {
                            if (!isLocationInsensitive(v)) {
                                return false;
                            }
                        }
                        return true;
                    }
                    return false;
                }
                if (isLocationInsensitive(op.vt)) {
                    for (Value v : op.getOps()) {
                        if (!isLocationInsensitive(v)) {
                            return false;
                        }
                    }
                    return true;
                }
                return false;
        }
        return false;
    }",iterator
stmt,"{
        Reg args[];
        if (method.isStatic) {
            args = new Reg[method.args.length];
        } else {
            args = new Reg[method.args.length + 1];
        }

        Set<Stmt> tos = new HashSet<>();
        for (Stmt stmt : method.stmts) {
            if (stmt.st == ST.ASSIGN || stmt.st == ST.IDENTITY) {
                if (stmt.getOp1().vt == VT.LOCAL) {
                    Local left = (Local) stmt.getOp1();
                    Value op2 = stmt.getOp2();
                    int idx = left._ls_index;
                    Reg leftReg = regs[idx];

                    // a new local can't effect next value live in next frame
                    Cfg.collectTos(stmt, tos);
                    for (Stmt next : tos) {
                        SimpleLiveValue[] frame = (SimpleLiveValue[]) next.frame;
                        if (frame == null) {
                            continue;
                        }
                        for (int i = 0; i < frame.length; i++) {
                            if (i == idx) {
                                continue;
                            }
                            SimpleLiveValue v = frame[i];
                            if (v != null && v.used) {
                                Reg rightReg = regs[i];
                                leftReg.excludes.add(rightReg);
                                rightReg.excludes.add(leftReg);
                            }
                        }
                    }
                    tos.clear();

                    // Preferred same reg can save load-store
                    if (op2.vt == VT.LOCAL) {
                        Reg rightReg = regs[((Local) op2)._ls_index];
                        leftReg.prefers.add(rightReg);
                        rightReg.prefers.add(leftReg);
                    }

                    // record @this @parameter_x
                    if (op2.vt == VT.THIS_REF) {
                        args[0] = leftReg;
                    } else if (op2.vt == VT.PARAMETER_REF) {
                        RefExpr refExpr = (RefExpr) op2;
                        if (method.isStatic) {
                            args[refExpr.parameterIndex] = leftReg;
                        } else {
                            args[refExpr.parameterIndex + 1] = leftReg;
                        }
                    }
                }
            }
        }
        // remove the link between itself
        for (Reg reg : regs) {
            reg.excludes.remove(reg);
            reg.prefers.remove(reg);
        }
        return args;
    }",iterator
next,"{
        Reg args[];
        if (method.isStatic) {
            args = new Reg[method.args.length];
        } else {
            args = new Reg[method.args.length + 1];
        }

        Set<Stmt> tos = new HashSet<>();
        for (Stmt stmt : method.stmts) {
            if (stmt.st == ST.ASSIGN || stmt.st == ST.IDENTITY) {
                if (stmt.getOp1().vt == VT.LOCAL) {
                    Local left = (Local) stmt.getOp1();
                    Value op2 = stmt.getOp2();
                    int idx = left._ls_index;
                    Reg leftReg = regs[idx];

                    // a new local can't effect next value live in next frame
                    Cfg.collectTos(stmt, tos);
                    for (Stmt next : tos) {
                        SimpleLiveValue[] frame = (SimpleLiveValue[]) next.frame;
                        if (frame == null) {
                            continue;
                        }
                        for (int i = 0; i < frame.length; i++) {
                            if (i == idx) {
                                continue;
                            }
                            SimpleLiveValue v = frame[i];
                            if (v != null && v.used) {
                                Reg rightReg = regs[i];
                                leftReg.excludes.add(rightReg);
                                rightReg.excludes.add(leftReg);
                            }
                        }
                    }
                    tos.clear();

                    // Preferred same reg can save load-store
                    if (op2.vt == VT.LOCAL) {
                        Reg rightReg = regs[((Local) op2)._ls_index];
                        leftReg.prefers.add(rightReg);
                        rightReg.prefers.add(leftReg);
                    }

                    // record @this @parameter_x
                    if (op2.vt == VT.THIS_REF) {
                        args[0] = leftReg;
                    } else if (op2.vt == VT.PARAMETER_REF) {
                        RefExpr refExpr = (RefExpr) op2;
                        if (method.isStatic) {
                            args[refExpr.parameterIndex] = leftReg;
                        } else {
                            args[refExpr.parameterIndex + 1] = leftReg;
                        }
                    }
                }
            }
        }
        // remove the link between itself
        for (Reg reg : regs) {
            reg.excludes.remove(reg);
            reg.prefers.remove(reg);
        }
        return args;
    }",iterator
i,"{
        Reg args[];
        if (method.isStatic) {
            args = new Reg[method.args.length];
        } else {
            args = new Reg[method.args.length + 1];
        }

        Set<Stmt> tos = new HashSet<>();
        for (Stmt stmt : method.stmts) {
            if (stmt.st == ST.ASSIGN || stmt.st == ST.IDENTITY) {
                if (stmt.getOp1().vt == VT.LOCAL) {
                    Local left = (Local) stmt.getOp1();
                    Value op2 = stmt.getOp2();
                    int idx = left._ls_index;
                    Reg leftReg = regs[idx];

                    // a new local can't effect next value live in next frame
                    Cfg.collectTos(stmt, tos);
                    for (Stmt next : tos) {
                        SimpleLiveValue[] frame = (SimpleLiveValue[]) next.frame;
                        if (frame == null) {
                            continue;
                        }
                        for (int i = 0; i < frame.length; i++) {
                            if (i == idx) {
                                continue;
                            }
                            SimpleLiveValue v = frame[i];
                            if (v != null && v.used) {
                                Reg rightReg = regs[i];
                                leftReg.excludes.add(rightReg);
                                rightReg.excludes.add(leftReg);
                            }
                        }
                    }
                    tos.clear();

                    // Preferred same reg can save load-store
                    if (op2.vt == VT.LOCAL) {
                        Reg rightReg = regs[((Local) op2)._ls_index];
                        leftReg.prefers.add(rightReg);
                        rightReg.prefers.add(leftReg);
                    }

                    // record @this @parameter_x
                    if (op2.vt == VT.THIS_REF) {
                        args[0] = leftReg;
                    } else if (op2.vt == VT.PARAMETER_REF) {
                        RefExpr refExpr = (RefExpr) op2;
                        if (method.isStatic) {
                            args[refExpr.parameterIndex] = leftReg;
                        } else {
                            args[refExpr.parameterIndex + 1] = leftReg;
                        }
                    }
                }
            }
        }
        // remove the link between itself
        for (Reg reg : regs) {
            reg.excludes.remove(reg);
            reg.prefers.remove(reg);
        }
        return args;
    }",loop_control
reg,"{
        Reg args[];
        if (method.isStatic) {
            args = new Reg[method.args.length];
        } else {
            args = new Reg[method.args.length + 1];
        }

        Set<Stmt> tos = new HashSet<>();
        for (Stmt stmt : method.stmts) {
            if (stmt.st == ST.ASSIGN || stmt.st == ST.IDENTITY) {
                if (stmt.getOp1().vt == VT.LOCAL) {
                    Local left = (Local) stmt.getOp1();
                    Value op2 = stmt.getOp2();
                    int idx = left._ls_index;
                    Reg leftReg = regs[idx];

                    // a new local can't effect next value live in next frame
                    Cfg.collectTos(stmt, tos);
                    for (Stmt next : tos) {
                        SimpleLiveValue[] frame = (SimpleLiveValue[]) next.frame;
                        if (frame == null) {
                            continue;
                        }
                        for (int i = 0; i < frame.length; i++) {
                            if (i == idx) {
                                continue;
                            }
                            SimpleLiveValue v = frame[i];
                            if (v != null && v.used) {
                                Reg rightReg = regs[i];
                                leftReg.excludes.add(rightReg);
                                rightReg.excludes.add(leftReg);
                            }
                        }
                    }
                    tos.clear();

                    // Preferred same reg can save load-store
                    if (op2.vt == VT.LOCAL) {
                        Reg rightReg = regs[((Local) op2)._ls_index];
                        leftReg.prefers.add(rightReg);
                        rightReg.prefers.add(leftReg);
                    }

                    // record @this @parameter_x
                    if (op2.vt == VT.THIS_REF) {
                        args[0] = leftReg;
                    } else if (op2.vt == VT.PARAMETER_REF) {
                        RefExpr refExpr = (RefExpr) op2;
                        if (method.isStatic) {
                            args[refExpr.parameterIndex] = leftReg;
                        } else {
                            args[refExpr.parameterIndex + 1] = leftReg;
                        }
                    }
                }
            }
        }
        // remove the link between itself
        for (Reg reg : regs) {
            reg.excludes.remove(reg);
            reg.prefers.remove(reg);
        }
        return args;
    }",iterator
reg,"{
        Map<Character, List<Reg>> groups = new HashMap<>();
        for (Reg reg : regs) {
            char simpleType = reg.type;
            List<Reg> group = groups.get(simpleType);
            if (group == null) {
                group = new ArrayList<>();
                groups.put(simpleType, group);
            }
            group.add(reg);

            for (Iterator<Reg> it = reg.excludes.iterator(); it.hasNext(); ) {
                Reg ex = it.next();
                if (ex.type != reg.type) {
                    it.remove();
                }
            }
            for (Iterator<Reg> it = reg.prefers.iterator(); it.hasNext(); ) {
                Reg ex = it.next();
                if (ex.type != reg.type) {
                    it.remove();
                }
            }
        }
        return groups;
    }",iterator
it,"{
        Map<Character, List<Reg>> groups = new HashMap<>();
        for (Reg reg : regs) {
            char simpleType = reg.type;
            List<Reg> group = groups.get(simpleType);
            if (group == null) {
                group = new ArrayList<>();
                groups.put(simpleType, group);
            }
            group.add(reg);

            for (Iterator<Reg> it = reg.excludes.iterator(); it.hasNext(); ) {
                Reg ex = it.next();
                if (ex.type != reg.type) {
                    it.remove();
                }
            }
            for (Iterator<Reg> it = reg.prefers.iterator(); it.hasNext(); ) {
                Reg ex = it.next();
                if (ex.type != reg.type) {
                    it.remove();
                }
            }
        }
        return groups;
    }",iterator
ex,"{
        excludeColor.clear();
        for (Reg ex : as.excludes) {
            if (ex.reg >= 0) {
                excludeColor.set(ex.reg);
                if (ex.type == 'J' || ex.type == 'D') {
                    excludeColor.set(ex.reg + 1);
                }
            }
        }
    }",iterator
ex,"{
        suggestColor.clear();
        for (Reg ex : as.prefers) {
            if (ex.reg >= 0) {
                suggestColor.set(ex.reg);
            }
        }
    }",iterator
local,"{
        if (method.locals.size() == 0) {
            return;
        }
        SimpleLiveAnalyze sa = new SimpleLiveAnalyze(method, true);
        sa.analyze();

        // init regs
        int maxLocalSize = sa.getLocalSize();
        final Reg regs[] = new Reg[maxLocalSize];
        for (Local local : method.locals) {
            Reg reg = new Reg();
            char type = local.valueType.charAt(0);
            if (type == '[') {
                type = 'L';
            }
            reg.type = type;
            local.tag = reg;
            regs[local._ls_index] = reg;
        }

        // gen graph
        Reg[] args = genGraph(method, regs);

        // fix up the graph, make sure @this is not share index with others
        if (!method.isStatic) {
            Reg atThis = args[0];
            for (Reg reg : regs) {
                if (reg == atThis) {
                    continue;
                }
                reg.excludes.add(atThis);
                atThis.excludes.add(reg);
            }
        }

        { // assgin @this, @parameter_x from index 0
            int i = 0;
            int index = 0;
            if (!method.isStatic) {
                args[i++].reg = index++;
            }
            for (int j = 0; j < method.args.length; j++) {
                Reg reg = args[i++];
                String type = method.args[j];
                if (reg == null) {
                    index++;
                } else {
                    reg.reg = index++;
                }
                if (""J"".equals(type) || ""D"".equals(type)) {
                    index++;
                }
            }
        }

        Map<Character, List<Reg>> groups = groupAndCleanUpByType(regs);
        // type each group
        BitSet excludeColor = new BitSet();
        BitSet suggestColor = new BitSet();
        BitSet globalExcludes = new BitSet();
        BitSet usedInOneType = new BitSet();
        for (Map.Entry<Character, List<Reg>> e : groups.entrySet()) {
            List<Reg> assigns = e.getValue();
            Collections.sort(assigns, OrderRegAssignByPreferredSizeDesc);
            char type = e.getKey();
            boolean doubleOrLong = type == 'J' || type == 'D';
            for (Reg as : assigns) {
                if (as.reg < 0) {// need color

                    initExcludeColor(excludeColor, as);
                    excludeParameters(excludeColor, args, type);

                    excludeColor.or(globalExcludes); // exclude index used by other types

                    initSuggestColor(suggestColor, as);

                    // first find a preferred color
                    for (int i = suggestColor.nextSetBit(0); i >= 0; i = suggestColor.nextSetBit(i + 1)) {
                        if (doubleOrLong) { // need 2
                            if (!excludeColor.get(i) && !excludeColor.get(i + 1)) {
                                as.reg = i;
                                break;
                            }
                        } else {
                            if (!excludeColor.get(i)) {
                                as.reg = i;
                                break;
                            }
                        }
                    }
                    if (as.reg < 0) {
                        if (doubleOrLong) {
                            int reg = -1;
                            do {
                                reg++;
                                reg = excludeColor.nextClearBit(reg);
                            } while (excludeColor.get(reg + 1));
                            as.reg = reg;
                        } else {
                            int reg = excludeColor.nextClearBit(0);
                            as.reg = reg;
                        }
                    }
                }
                usedInOneType.set(as.reg);
                if (doubleOrLong) {
                    usedInOneType.set(as.reg + 1);
                }
            }
            globalExcludes.or(usedInOneType);
            usedInOneType.clear();
        }

        for (Local local : method.locals) {
            Reg as = (Reg) local.tag;
            local._ls_index = as.reg;
            local.tag = null;
        }
        for (Stmt stmt : method.stmts) {
            stmt.frame = null;
        }
    }",iterator
reg,"{
        if (method.locals.size() == 0) {
            return;
        }
        SimpleLiveAnalyze sa = new SimpleLiveAnalyze(method, true);
        sa.analyze();

        // init regs
        int maxLocalSize = sa.getLocalSize();
        final Reg regs[] = new Reg[maxLocalSize];
        for (Local local : method.locals) {
            Reg reg = new Reg();
            char type = local.valueType.charAt(0);
            if (type == '[') {
                type = 'L';
            }
            reg.type = type;
            local.tag = reg;
            regs[local._ls_index] = reg;
        }

        // gen graph
        Reg[] args = genGraph(method, regs);

        // fix up the graph, make sure @this is not share index with others
        if (!method.isStatic) {
            Reg atThis = args[0];
            for (Reg reg : regs) {
                if (reg == atThis) {
                    continue;
                }
                reg.excludes.add(atThis);
                atThis.excludes.add(reg);
            }
        }

        { // assgin @this, @parameter_x from index 0
            int i = 0;
            int index = 0;
            if (!method.isStatic) {
                args[i++].reg = index++;
            }
            for (int j = 0; j < method.args.length; j++) {
                Reg reg = args[i++];
                String type = method.args[j];
                if (reg == null) {
                    index++;
                } else {
                    reg.reg = index++;
                }
                if (""J"".equals(type) || ""D"".equals(type)) {
                    index++;
                }
            }
        }

        Map<Character, List<Reg>> groups = groupAndCleanUpByType(regs);
        // type each group
        BitSet excludeColor = new BitSet();
        BitSet suggestColor = new BitSet();
        BitSet globalExcludes = new BitSet();
        BitSet usedInOneType = new BitSet();
        for (Map.Entry<Character, List<Reg>> e : groups.entrySet()) {
            List<Reg> assigns = e.getValue();
            Collections.sort(assigns, OrderRegAssignByPreferredSizeDesc);
            char type = e.getKey();
            boolean doubleOrLong = type == 'J' || type == 'D';
            for (Reg as : assigns) {
                if (as.reg < 0) {// need color

                    initExcludeColor(excludeColor, as);
                    excludeParameters(excludeColor, args, type);

                    excludeColor.or(globalExcludes); // exclude index used by other types

                    initSuggestColor(suggestColor, as);

                    // first find a preferred color
                    for (int i = suggestColor.nextSetBit(0); i >= 0; i = suggestColor.nextSetBit(i + 1)) {
                        if (doubleOrLong) { // need 2
                            if (!excludeColor.get(i) && !excludeColor.get(i + 1)) {
                                as.reg = i;
                                break;
                            }
                        } else {
                            if (!excludeColor.get(i)) {
                                as.reg = i;
                                break;
                            }
                        }
                    }
                    if (as.reg < 0) {
                        if (doubleOrLong) {
                            int reg = -1;
                            do {
                                reg++;
                                reg = excludeColor.nextClearBit(reg);
                            } while (excludeColor.get(reg + 1));
                            as.reg = reg;
                        } else {
                            int reg = excludeColor.nextClearBit(0);
                            as.reg = reg;
                        }
                    }
                }
                usedInOneType.set(as.reg);
                if (doubleOrLong) {
                    usedInOneType.set(as.reg + 1);
                }
            }
            globalExcludes.or(usedInOneType);
            usedInOneType.clear();
        }

        for (Local local : method.locals) {
            Reg as = (Reg) local.tag;
            local._ls_index = as.reg;
            local.tag = null;
        }
        for (Stmt stmt : method.stmts) {
            stmt.frame = null;
        }
    }",iterator
j,"{
        if (method.locals.size() == 0) {
            return;
        }
        SimpleLiveAnalyze sa = new SimpleLiveAnalyze(method, true);
        sa.analyze();

        // init regs
        int maxLocalSize = sa.getLocalSize();
        final Reg regs[] = new Reg[maxLocalSize];
        for (Local local : method.locals) {
            Reg reg = new Reg();
            char type = local.valueType.charAt(0);
            if (type == '[') {
                type = 'L';
            }
            reg.type = type;
            local.tag = reg;
            regs[local._ls_index] = reg;
        }

        // gen graph
        Reg[] args = genGraph(method, regs);

        // fix up the graph, make sure @this is not share index with others
        if (!method.isStatic) {
            Reg atThis = args[0];
            for (Reg reg : regs) {
                if (reg == atThis) {
                    continue;
                }
                reg.excludes.add(atThis);
                atThis.excludes.add(reg);
            }
        }

        { // assgin @this, @parameter_x from index 0
            int i = 0;
            int index = 0;
            if (!method.isStatic) {
                args[i++].reg = index++;
            }
            for (int j = 0; j < method.args.length; j++) {
                Reg reg = args[i++];
                String type = method.args[j];
                if (reg == null) {
                    index++;
                } else {
                    reg.reg = index++;
                }
                if (""J"".equals(type) || ""D"".equals(type)) {
                    index++;
                }
            }
        }

        Map<Character, List<Reg>> groups = groupAndCleanUpByType(regs);
        // type each group
        BitSet excludeColor = new BitSet();
        BitSet suggestColor = new BitSet();
        BitSet globalExcludes = new BitSet();
        BitSet usedInOneType = new BitSet();
        for (Map.Entry<Character, List<Reg>> e : groups.entrySet()) {
            List<Reg> assigns = e.getValue();
            Collections.sort(assigns, OrderRegAssignByPreferredSizeDesc);
            char type = e.getKey();
            boolean doubleOrLong = type == 'J' || type == 'D';
            for (Reg as : assigns) {
                if (as.reg < 0) {// need color

                    initExcludeColor(excludeColor, as);
                    excludeParameters(excludeColor, args, type);

                    excludeColor.or(globalExcludes); // exclude index used by other types

                    initSuggestColor(suggestColor, as);

                    // first find a preferred color
                    for (int i = suggestColor.nextSetBit(0); i >= 0; i = suggestColor.nextSetBit(i + 1)) {
                        if (doubleOrLong) { // need 2
                            if (!excludeColor.get(i) && !excludeColor.get(i + 1)) {
                                as.reg = i;
                                break;
                            }
                        } else {
                            if (!excludeColor.get(i)) {
                                as.reg = i;
                                break;
                            }
                        }
                    }
                    if (as.reg < 0) {
                        if (doubleOrLong) {
                            int reg = -1;
                            do {
                                reg++;
                                reg = excludeColor.nextClearBit(reg);
                            } while (excludeColor.get(reg + 1));
                            as.reg = reg;
                        } else {
                            int reg = excludeColor.nextClearBit(0);
                            as.reg = reg;
                        }
                    }
                }
                usedInOneType.set(as.reg);
                if (doubleOrLong) {
                    usedInOneType.set(as.reg + 1);
                }
            }
            globalExcludes.or(usedInOneType);
            usedInOneType.clear();
        }

        for (Local local : method.locals) {
            Reg as = (Reg) local.tag;
            local._ls_index = as.reg;
            local.tag = null;
        }
        for (Stmt stmt : method.stmts) {
            stmt.frame = null;
        }
    }",loop_control
e,"{
        if (method.locals.size() == 0) {
            return;
        }
        SimpleLiveAnalyze sa = new SimpleLiveAnalyze(method, true);
        sa.analyze();

        // init regs
        int maxLocalSize = sa.getLocalSize();
        final Reg regs[] = new Reg[maxLocalSize];
        for (Local local : method.locals) {
            Reg reg = new Reg();
            char type = local.valueType.charAt(0);
            if (type == '[') {
                type = 'L';
            }
            reg.type = type;
            local.tag = reg;
            regs[local._ls_index] = reg;
        }

        // gen graph
        Reg[] args = genGraph(method, regs);

        // fix up the graph, make sure @this is not share index with others
        if (!method.isStatic) {
            Reg atThis = args[0];
            for (Reg reg : regs) {
                if (reg == atThis) {
                    continue;
                }
                reg.excludes.add(atThis);
                atThis.excludes.add(reg);
            }
        }

        { // assgin @this, @parameter_x from index 0
            int i = 0;
            int index = 0;
            if (!method.isStatic) {
                args[i++].reg = index++;
            }
            for (int j = 0; j < method.args.length; j++) {
                Reg reg = args[i++];
                String type = method.args[j];
                if (reg == null) {
                    index++;
                } else {
                    reg.reg = index++;
                }
                if (""J"".equals(type) || ""D"".equals(type)) {
                    index++;
                }
            }
        }

        Map<Character, List<Reg>> groups = groupAndCleanUpByType(regs);
        // type each group
        BitSet excludeColor = new BitSet();
        BitSet suggestColor = new BitSet();
        BitSet globalExcludes = new BitSet();
        BitSet usedInOneType = new BitSet();
        for (Map.Entry<Character, List<Reg>> e : groups.entrySet()) {
            List<Reg> assigns = e.getValue();
            Collections.sort(assigns, OrderRegAssignByPreferredSizeDesc);
            char type = e.getKey();
            boolean doubleOrLong = type == 'J' || type == 'D';
            for (Reg as : assigns) {
                if (as.reg < 0) {// need color

                    initExcludeColor(excludeColor, as);
                    excludeParameters(excludeColor, args, type);

                    excludeColor.or(globalExcludes); // exclude index used by other types

                    initSuggestColor(suggestColor, as);

                    // first find a preferred color
                    for (int i = suggestColor.nextSetBit(0); i >= 0; i = suggestColor.nextSetBit(i + 1)) {
                        if (doubleOrLong) { // need 2
                            if (!excludeColor.get(i) && !excludeColor.get(i + 1)) {
                                as.reg = i;
                                break;
                            }
                        } else {
                            if (!excludeColor.get(i)) {
                                as.reg = i;
                                break;
                            }
                        }
                    }
                    if (as.reg < 0) {
                        if (doubleOrLong) {
                            int reg = -1;
                            do {
                                reg++;
                                reg = excludeColor.nextClearBit(reg);
                            } while (excludeColor.get(reg + 1));
                            as.reg = reg;
                        } else {
                            int reg = excludeColor.nextClearBit(0);
                            as.reg = reg;
                        }
                    }
                }
                usedInOneType.set(as.reg);
                if (doubleOrLong) {
                    usedInOneType.set(as.reg + 1);
                }
            }
            globalExcludes.or(usedInOneType);
            usedInOneType.clear();
        }

        for (Local local : method.locals) {
            Reg as = (Reg) local.tag;
            local._ls_index = as.reg;
            local.tag = null;
        }
        for (Stmt stmt : method.stmts) {
            stmt.frame = null;
        }
    }",iterator
as,"{
        if (method.locals.size() == 0) {
            return;
        }
        SimpleLiveAnalyze sa = new SimpleLiveAnalyze(method, true);
        sa.analyze();

        // init regs
        int maxLocalSize = sa.getLocalSize();
        final Reg regs[] = new Reg[maxLocalSize];
        for (Local local : method.locals) {
            Reg reg = new Reg();
            char type = local.valueType.charAt(0);
            if (type == '[') {
                type = 'L';
            }
            reg.type = type;
            local.tag = reg;
            regs[local._ls_index] = reg;
        }

        // gen graph
        Reg[] args = genGraph(method, regs);

        // fix up the graph, make sure @this is not share index with others
        if (!method.isStatic) {
            Reg atThis = args[0];
            for (Reg reg : regs) {
                if (reg == atThis) {
                    continue;
                }
                reg.excludes.add(atThis);
                atThis.excludes.add(reg);
            }
        }

        { // assgin @this, @parameter_x from index 0
            int i = 0;
            int index = 0;
            if (!method.isStatic) {
                args[i++].reg = index++;
            }
            for (int j = 0; j < method.args.length; j++) {
                Reg reg = args[i++];
                String type = method.args[j];
                if (reg == null) {
                    index++;
                } else {
                    reg.reg = index++;
                }
                if (""J"".equals(type) || ""D"".equals(type)) {
                    index++;
                }
            }
        }

        Map<Character, List<Reg>> groups = groupAndCleanUpByType(regs);
        // type each group
        BitSet excludeColor = new BitSet();
        BitSet suggestColor = new BitSet();
        BitSet globalExcludes = new BitSet();
        BitSet usedInOneType = new BitSet();
        for (Map.Entry<Character, List<Reg>> e : groups.entrySet()) {
            List<Reg> assigns = e.getValue();
            Collections.sort(assigns, OrderRegAssignByPreferredSizeDesc);
            char type = e.getKey();
            boolean doubleOrLong = type == 'J' || type == 'D';
            for (Reg as : assigns) {
                if (as.reg < 0) {// need color

                    initExcludeColor(excludeColor, as);
                    excludeParameters(excludeColor, args, type);

                    excludeColor.or(globalExcludes); // exclude index used by other types

                    initSuggestColor(suggestColor, as);

                    // first find a preferred color
                    for (int i = suggestColor.nextSetBit(0); i >= 0; i = suggestColor.nextSetBit(i + 1)) {
                        if (doubleOrLong) { // need 2
                            if (!excludeColor.get(i) && !excludeColor.get(i + 1)) {
                                as.reg = i;
                                break;
                            }
                        } else {
                            if (!excludeColor.get(i)) {
                                as.reg = i;
                                break;
                            }
                        }
                    }
                    if (as.reg < 0) {
                        if (doubleOrLong) {
                            int reg = -1;
                            do {
                                reg++;
                                reg = excludeColor.nextClearBit(reg);
                            } while (excludeColor.get(reg + 1));
                            as.reg = reg;
                        } else {
                            int reg = excludeColor.nextClearBit(0);
                            as.reg = reg;
                        }
                    }
                }
                usedInOneType.set(as.reg);
                if (doubleOrLong) {
                    usedInOneType.set(as.reg + 1);
                }
            }
            globalExcludes.or(usedInOneType);
            usedInOneType.clear();
        }

        for (Local local : method.locals) {
            Reg as = (Reg) local.tag;
            local._ls_index = as.reg;
            local.tag = null;
        }
        for (Stmt stmt : method.stmts) {
            stmt.frame = null;
        }
    }",iterator
i,"{
        if (method.locals.size() == 0) {
            return;
        }
        SimpleLiveAnalyze sa = new SimpleLiveAnalyze(method, true);
        sa.analyze();

        // init regs
        int maxLocalSize = sa.getLocalSize();
        final Reg regs[] = new Reg[maxLocalSize];
        for (Local local : method.locals) {
            Reg reg = new Reg();
            char type = local.valueType.charAt(0);
            if (type == '[') {
                type = 'L';
            }
            reg.type = type;
            local.tag = reg;
            regs[local._ls_index] = reg;
        }

        // gen graph
        Reg[] args = genGraph(method, regs);

        // fix up the graph, make sure @this is not share index with others
        if (!method.isStatic) {
            Reg atThis = args[0];
            for (Reg reg : regs) {
                if (reg == atThis) {
                    continue;
                }
                reg.excludes.add(atThis);
                atThis.excludes.add(reg);
            }
        }

        { // assgin @this, @parameter_x from index 0
            int i = 0;
            int index = 0;
            if (!method.isStatic) {
                args[i++].reg = index++;
            }
            for (int j = 0; j < method.args.length; j++) {
                Reg reg = args[i++];
                String type = method.args[j];
                if (reg == null) {
                    index++;
                } else {
                    reg.reg = index++;
                }
                if (""J"".equals(type) || ""D"".equals(type)) {
                    index++;
                }
            }
        }

        Map<Character, List<Reg>> groups = groupAndCleanUpByType(regs);
        // type each group
        BitSet excludeColor = new BitSet();
        BitSet suggestColor = new BitSet();
        BitSet globalExcludes = new BitSet();
        BitSet usedInOneType = new BitSet();
        for (Map.Entry<Character, List<Reg>> e : groups.entrySet()) {
            List<Reg> assigns = e.getValue();
            Collections.sort(assigns, OrderRegAssignByPreferredSizeDesc);
            char type = e.getKey();
            boolean doubleOrLong = type == 'J' || type == 'D';
            for (Reg as : assigns) {
                if (as.reg < 0) {// need color

                    initExcludeColor(excludeColor, as);
                    excludeParameters(excludeColor, args, type);

                    excludeColor.or(globalExcludes); // exclude index used by other types

                    initSuggestColor(suggestColor, as);

                    // first find a preferred color
                    for (int i = suggestColor.nextSetBit(0); i >= 0; i = suggestColor.nextSetBit(i + 1)) {
                        if (doubleOrLong) { // need 2
                            if (!excludeColor.get(i) && !excludeColor.get(i + 1)) {
                                as.reg = i;
                                break;
                            }
                        } else {
                            if (!excludeColor.get(i)) {
                                as.reg = i;
                                break;
                            }
                        }
                    }
                    if (as.reg < 0) {
                        if (doubleOrLong) {
                            int reg = -1;
                            do {
                                reg++;
                                reg = excludeColor.nextClearBit(reg);
                            } while (excludeColor.get(reg + 1));
                            as.reg = reg;
                        } else {
                            int reg = excludeColor.nextClearBit(0);
                            as.reg = reg;
                        }
                    }
                }
                usedInOneType.set(as.reg);
                if (doubleOrLong) {
                    usedInOneType.set(as.reg + 1);
                }
            }
            globalExcludes.or(usedInOneType);
            usedInOneType.clear();
        }

        for (Local local : method.locals) {
            Reg as = (Reg) local.tag;
            local._ls_index = as.reg;
            local.tag = null;
        }
        for (Stmt stmt : method.stmts) {
            stmt.frame = null;
        }
    }",loop_control
doubleOrLong,"{
        if (method.locals.size() == 0) {
            return;
        }
        SimpleLiveAnalyze sa = new SimpleLiveAnalyze(method, true);
        sa.analyze();

        // init regs
        int maxLocalSize = sa.getLocalSize();
        final Reg regs[] = new Reg[maxLocalSize];
        for (Local local : method.locals) {
            Reg reg = new Reg();
            char type = local.valueType.charAt(0);
            if (type == '[') {
                type = 'L';
            }
            reg.type = type;
            local.tag = reg;
            regs[local._ls_index] = reg;
        }

        // gen graph
        Reg[] args = genGraph(method, regs);

        // fix up the graph, make sure @this is not share index with others
        if (!method.isStatic) {
            Reg atThis = args[0];
            for (Reg reg : regs) {
                if (reg == atThis) {
                    continue;
                }
                reg.excludes.add(atThis);
                atThis.excludes.add(reg);
            }
        }

        { // assgin @this, @parameter_x from index 0
            int i = 0;
            int index = 0;
            if (!method.isStatic) {
                args[i++].reg = index++;
            }
            for (int j = 0; j < method.args.length; j++) {
                Reg reg = args[i++];
                String type = method.args[j];
                if (reg == null) {
                    index++;
                } else {
                    reg.reg = index++;
                }
                if (""J"".equals(type) || ""D"".equals(type)) {
                    index++;
                }
            }
        }

        Map<Character, List<Reg>> groups = groupAndCleanUpByType(regs);
        // type each group
        BitSet excludeColor = new BitSet();
        BitSet suggestColor = new BitSet();
        BitSet globalExcludes = new BitSet();
        BitSet usedInOneType = new BitSet();
        for (Map.Entry<Character, List<Reg>> e : groups.entrySet()) {
            List<Reg> assigns = e.getValue();
            Collections.sort(assigns, OrderRegAssignByPreferredSizeDesc);
            char type = e.getKey();
            boolean doubleOrLong = type == 'J' || type == 'D';
            for (Reg as : assigns) {
                if (as.reg < 0) {// need color

                    initExcludeColor(excludeColor, as);
                    excludeParameters(excludeColor, args, type);

                    excludeColor.or(globalExcludes); // exclude index used by other types

                    initSuggestColor(suggestColor, as);

                    // first find a preferred color
                    for (int i = suggestColor.nextSetBit(0); i >= 0; i = suggestColor.nextSetBit(i + 1)) {
                        if (doubleOrLong) { // need 2
                            if (!excludeColor.get(i) && !excludeColor.get(i + 1)) {
                                as.reg = i;
                                break;
                            }
                        } else {
                            if (!excludeColor.get(i)) {
                                as.reg = i;
                                break;
                            }
                        }
                    }
                    if (as.reg < 0) {
                        if (doubleOrLong) {
                            int reg = -1;
                            do {
                                reg++;
                                reg = excludeColor.nextClearBit(reg);
                            } while (excludeColor.get(reg + 1));
                            as.reg = reg;
                        } else {
                            int reg = excludeColor.nextClearBit(0);
                            as.reg = reg;
                        }
                    }
                }
                usedInOneType.set(as.reg);
                if (doubleOrLong) {
                    usedInOneType.set(as.reg + 1);
                }
            }
            globalExcludes.or(usedInOneType);
            usedInOneType.clear();
        }

        for (Local local : method.locals) {
            Reg as = (Reg) local.tag;
            local._ls_index = as.reg;
            local.tag = null;
        }
        for (Stmt stmt : method.stmts) {
            stmt.frame = null;
        }
    }",break_loop_control
excludeColor,"{
        if (method.locals.size() == 0) {
            return;
        }
        SimpleLiveAnalyze sa = new SimpleLiveAnalyze(method, true);
        sa.analyze();

        // init regs
        int maxLocalSize = sa.getLocalSize();
        final Reg regs[] = new Reg[maxLocalSize];
        for (Local local : method.locals) {
            Reg reg = new Reg();
            char type = local.valueType.charAt(0);
            if (type == '[') {
                type = 'L';
            }
            reg.type = type;
            local.tag = reg;
            regs[local._ls_index] = reg;
        }

        // gen graph
        Reg[] args = genGraph(method, regs);

        // fix up the graph, make sure @this is not share index with others
        if (!method.isStatic) {
            Reg atThis = args[0];
            for (Reg reg : regs) {
                if (reg == atThis) {
                    continue;
                }
                reg.excludes.add(atThis);
                atThis.excludes.add(reg);
            }
        }

        { // assgin @this, @parameter_x from index 0
            int i = 0;
            int index = 0;
            if (!method.isStatic) {
                args[i++].reg = index++;
            }
            for (int j = 0; j < method.args.length; j++) {
                Reg reg = args[i++];
                String type = method.args[j];
                if (reg == null) {
                    index++;
                } else {
                    reg.reg = index++;
                }
                if (""J"".equals(type) || ""D"".equals(type)) {
                    index++;
                }
            }
        }

        Map<Character, List<Reg>> groups = groupAndCleanUpByType(regs);
        // type each group
        BitSet excludeColor = new BitSet();
        BitSet suggestColor = new BitSet();
        BitSet globalExcludes = new BitSet();
        BitSet usedInOneType = new BitSet();
        for (Map.Entry<Character, List<Reg>> e : groups.entrySet()) {
            List<Reg> assigns = e.getValue();
            Collections.sort(assigns, OrderRegAssignByPreferredSizeDesc);
            char type = e.getKey();
            boolean doubleOrLong = type == 'J' || type == 'D';
            for (Reg as : assigns) {
                if (as.reg < 0) {// need color

                    initExcludeColor(excludeColor, as);
                    excludeParameters(excludeColor, args, type);

                    excludeColor.or(globalExcludes); // exclude index used by other types

                    initSuggestColor(suggestColor, as);

                    // first find a preferred color
                    for (int i = suggestColor.nextSetBit(0); i >= 0; i = suggestColor.nextSetBit(i + 1)) {
                        if (doubleOrLong) { // need 2
                            if (!excludeColor.get(i) && !excludeColor.get(i + 1)) {
                                as.reg = i;
                                break;
                            }
                        } else {
                            if (!excludeColor.get(i)) {
                                as.reg = i;
                                break;
                            }
                        }
                    }
                    if (as.reg < 0) {
                        if (doubleOrLong) {
                            int reg = -1;
                            do {
                                reg++;
                                reg = excludeColor.nextClearBit(reg);
                            } while (excludeColor.get(reg + 1));
                            as.reg = reg;
                        } else {
                            int reg = excludeColor.nextClearBit(0);
                            as.reg = reg;
                        }
                    }
                }
                usedInOneType.set(as.reg);
                if (doubleOrLong) {
                    usedInOneType.set(as.reg + 1);
                }
            }
            globalExcludes.or(usedInOneType);
            usedInOneType.clear();
        }

        for (Local local : method.locals) {
            Reg as = (Reg) local.tag;
            local._ls_index = as.reg;
            local.tag = null;
        }
        for (Stmt stmt : method.stmts) {
            stmt.frame = null;
        }
    }",maybe_loop_control
arg,"{
        for (Reg arg : args) {
            if (arg.type != type) {
                excludeColor.set(arg.reg);
                if (arg.type == 'J' || arg.type == 'D') {
                    excludeColor.set(arg.reg + 1);
                }
            }
        }
    }",iterator
stmt,"{
        int i = 0;
        for (Stmt stmt : irMethod.stmts) {
            if (stmt.st == ST.LABEL) {
                ((LabelStmt) stmt).displayName = ""L"" + i++;
            }
        }
    }",iterator
st,"{
        for (Stmt st : jm.stmts) {
            st.frame = null;
            st.exceptionHandlers = null;
            if (st._cfg_froms == null) {
                st._cfg_froms = new TreeSet<>(jm.stmts);
            } else {
                st._cfg_froms.clear();
            }
        }

        for (Stmt st : jm.stmts) {
            if (st.st.canBranch()) {
                link(st, ((JumpStmt) st).getTarget());
            }
            if (st.st.canContinue()) {
                link(st, st.getNext());
            }
            if (st.st.canSwitch()) {
                BaseSwitchStmt bss = (BaseSwitchStmt) st;
                link(st, bss.defaultTarget);
                for (Stmt target : bss.targets) {
                    link(st, target);
                }
            }
        }
    }",iterator
t,"{
        createCfgWithoutEx(jm);
        for (Trap t : jm.traps) {
            for (Stmt s = t.start; s != t.end; s = s.getNext()) {
                if (isThrow(s)) {
                    Set<LabelStmt> hs = s.exceptionHandlers;
                    if (hs == null) {
                        hs = new TreeSet<>(jm.stmts);
                        s.exceptionHandlers = hs;
                    }
                    for (LabelStmt handler : t.handlers) {
                        link(s, handler);
                        hs.add(handler);
                    }
                }
            }
        }

    }",iterator
s,"{
        createCfgWithoutEx(jm);
        for (Trap t : jm.traps) {
            for (Stmt s = t.start; s != t.end; s = s.getNext()) {
                if (isThrow(s)) {
                    Set<LabelStmt> hs = s.exceptionHandlers;
                    if (hs == null) {
                        hs = new TreeSet<>(jm.stmts);
                        s.exceptionHandlers = hs;
                    }
                    for (LabelStmt handler : t.handlers) {
                        link(s, handler);
                        hs.add(handler);
                    }
                }
            }
        }

    }",maybe_loop_control
st,"{
        for (Stmt st : method.stmts) {
            st.visited = false;
        }
        Stack<Stmt> stack = new Stack<>();
        stack.add(method.stmts.getFirst());
        while (!stack.isEmpty()) {
            Stmt currentStmt = stack.pop();
            if (currentStmt.visited) {
                continue;
            } else {
                currentStmt.visited = true;
            }
            if (currentStmt.exceptionHandlers != null) {
                for (LabelStmt labelStmt : currentStmt.exceptionHandlers) {
                    stack.push(labelStmt);
                }
            }
            if (visitor != null) {
                visitor.onVisit(currentStmt);
            }
            if (currentStmt.st.canSwitch()) {
                BaseSwitchStmt bs = (BaseSwitchStmt) currentStmt;
                Collections.addAll(stack, bs.targets);
                LabelStmt target = bs.defaultTarget;
                stack.add(target);
            }
            if (currentStmt.st.canBranch()) {
                Stmt target = ((JumpStmt) currentStmt).getTarget();
                stack.add(target);
            }
            if (currentStmt.st.canContinue()) {
                Stmt target = currentStmt.getNext();
                stack.add(target);
            }
        }
    }",iterator
stack,"{
        for (Stmt st : method.stmts) {
            st.visited = false;
        }
        Stack<Stmt> stack = new Stack<>();
        stack.add(method.stmts.getFirst());
        while (!stack.isEmpty()) {
            Stmt currentStmt = stack.pop();
            if (currentStmt.visited) {
                continue;
            } else {
                currentStmt.visited = true;
            }
            if (currentStmt.exceptionHandlers != null) {
                for (LabelStmt labelStmt : currentStmt.exceptionHandlers) {
                    stack.push(labelStmt);
                }
            }
            if (visitor != null) {
                visitor.onVisit(currentStmt);
            }
            if (currentStmt.st.canSwitch()) {
                BaseSwitchStmt bs = (BaseSwitchStmt) currentStmt;
                Collections.addAll(stack, bs.targets);
                LabelStmt target = bs.defaultTarget;
                stack.add(target);
            }
            if (currentStmt.st.canBranch()) {
                Stmt target = ((JumpStmt) currentStmt).getTarget();
                stack.add(target);
            }
            if (currentStmt.st.canContinue()) {
                Stmt target = currentStmt.getNext();
                stack.add(target);
            }
        }
    }",maybe_loop_control
st,"{
        if (stmts.getSize() == 0) {
            return;
        }
        // clean
        for (Stmt st : stmts) {
            st.visited = false;
            st.frame = null;
        }

        Stack<Stmt> stack = new Stack<Stmt>();
        Stmt first = stmts.getFirst();
        Stmt nop = null;
        if (first.st == ST.LABEL && first._cfg_froms.size() > 0) {
            nop = Stmts.nNop();
            // for
            // L0:
            // ...
            // GOTO L0:
            // make sure the first Label has one more super
            first._cfg_froms.add(nop);
        }
        stack.add(first);
        first.frame = sv.initFirstFrame(first);

        while (!stack.isEmpty()) {
            Stmt currentStmt = stack.pop();
            if (currentStmt == null || currentStmt.visited) {
                continue;
            } else {
                currentStmt.visited = true;
            }

            T beforeExecFrame = (T) currentStmt.frame;
            
            if (currentStmt.exceptionHandlers != null) {
                for (LabelStmt labelStmt : currentStmt.exceptionHandlers) {
                    labelStmt.frame = sv.merge(beforeExecFrame, (T) labelStmt.frame, currentStmt, labelStmt);
                    stack.push(labelStmt);
                }
            }
            
            T afterExecFrame = sv.exec(beforeExecFrame, currentStmt);

            if (currentStmt.st.canSwitch()) {
                BaseSwitchStmt bs = (BaseSwitchStmt) currentStmt;
                for (LabelStmt target : bs.targets) {
                    target.frame = sv.merge(afterExecFrame, (T) target.frame, currentStmt, target);
                    stack.push(target);
                }
                LabelStmt target = bs.defaultTarget;
                target.frame = sv.merge(afterExecFrame, (T) target.frame, currentStmt, target);
                stack.push(target);
            }
            if (currentStmt.st.canBranch()) {
                Stmt target = ((JumpStmt) currentStmt).getTarget();
                target.frame = sv.merge(afterExecFrame, (T) target.frame, currentStmt, target);
                stack.push(target);
            }
            if (currentStmt.st.canContinue()) {
                Stmt target = currentStmt.getNext();
                target.frame = sv.merge(afterExecFrame, (T) target.frame, currentStmt, target);
                stack.push(target);
            }
        }

        if (nop != null) {
            first._cfg_froms.remove(nop);
        }      
    }",iterator
stack,"{
        if (stmts.getSize() == 0) {
            return;
        }
        // clean
        for (Stmt st : stmts) {
            st.visited = false;
            st.frame = null;
        }

        Stack<Stmt> stack = new Stack<Stmt>();
        Stmt first = stmts.getFirst();
        Stmt nop = null;
        if (first.st == ST.LABEL && first._cfg_froms.size() > 0) {
            nop = Stmts.nNop();
            // for
            // L0:
            // ...
            // GOTO L0:
            // make sure the first Label has one more super
            first._cfg_froms.add(nop);
        }
        stack.add(first);
        first.frame = sv.initFirstFrame(first);

        while (!stack.isEmpty()) {
            Stmt currentStmt = stack.pop();
            if (currentStmt == null || currentStmt.visited) {
                continue;
            } else {
                currentStmt.visited = true;
            }

            T beforeExecFrame = (T) currentStmt.frame;
            
            if (currentStmt.exceptionHandlers != null) {
                for (LabelStmt labelStmt : currentStmt.exceptionHandlers) {
                    labelStmt.frame = sv.merge(beforeExecFrame, (T) labelStmt.frame, currentStmt, labelStmt);
                    stack.push(labelStmt);
                }
            }
            
            T afterExecFrame = sv.exec(beforeExecFrame, currentStmt);

            if (currentStmt.st.canSwitch()) {
                BaseSwitchStmt bs = (BaseSwitchStmt) currentStmt;
                for (LabelStmt target : bs.targets) {
                    target.frame = sv.merge(afterExecFrame, (T) target.frame, currentStmt, target);
                    stack.push(target);
                }
                LabelStmt target = bs.defaultTarget;
                target.frame = sv.merge(afterExecFrame, (T) target.frame, currentStmt, target);
                stack.push(target);
            }
            if (currentStmt.st.canBranch()) {
                Stmt target = ((JumpStmt) currentStmt).getTarget();
                target.frame = sv.merge(afterExecFrame, (T) target.frame, currentStmt, target);
                stack.push(target);
            }
            if (currentStmt.st.canContinue()) {
                Stmt target = currentStmt.getNext();
                target.frame = sv.merge(afterExecFrame, (T) target.frame, currentStmt, target);
                stack.push(target);
            }
        }

        if (nop != null) {
            first._cfg_froms.remove(nop);
        }      
    }",maybe_loop_control
labelStmt,"{
        if (stmts.getSize() == 0) {
            return;
        }
        // clean
        for (Stmt st : stmts) {
            st.visited = false;
            st.frame = null;
        }

        Stack<Stmt> stack = new Stack<Stmt>();
        Stmt first = stmts.getFirst();
        Stmt nop = null;
        if (first.st == ST.LABEL && first._cfg_froms.size() > 0) {
            nop = Stmts.nNop();
            // for
            // L0:
            // ...
            // GOTO L0:
            // make sure the first Label has one more super
            first._cfg_froms.add(nop);
        }
        stack.add(first);
        first.frame = sv.initFirstFrame(first);

        while (!stack.isEmpty()) {
            Stmt currentStmt = stack.pop();
            if (currentStmt == null || currentStmt.visited) {
                continue;
            } else {
                currentStmt.visited = true;
            }

            T beforeExecFrame = (T) currentStmt.frame;
            
            if (currentStmt.exceptionHandlers != null) {
                for (LabelStmt labelStmt : currentStmt.exceptionHandlers) {
                    labelStmt.frame = sv.merge(beforeExecFrame, (T) labelStmt.frame, currentStmt, labelStmt);
                    stack.push(labelStmt);
                }
            }
            
            T afterExecFrame = sv.exec(beforeExecFrame, currentStmt);

            if (currentStmt.st.canSwitch()) {
                BaseSwitchStmt bs = (BaseSwitchStmt) currentStmt;
                for (LabelStmt target : bs.targets) {
                    target.frame = sv.merge(afterExecFrame, (T) target.frame, currentStmt, target);
                    stack.push(target);
                }
                LabelStmt target = bs.defaultTarget;
                target.frame = sv.merge(afterExecFrame, (T) target.frame, currentStmt, target);
                stack.push(target);
            }
            if (currentStmt.st.canBranch()) {
                Stmt target = ((JumpStmt) currentStmt).getTarget();
                target.frame = sv.merge(afterExecFrame, (T) target.frame, currentStmt, target);
                stack.push(target);
            }
            if (currentStmt.st.canContinue()) {
                Stmt target = currentStmt.getNext();
                target.frame = sv.merge(afterExecFrame, (T) target.frame, currentStmt, target);
                stack.push(target);
            }
        }

        if (nop != null) {
            first._cfg_froms.remove(nop);
        }      
    }",iterator
target,"{
        if (stmts.getSize() == 0) {
            return;
        }
        // clean
        for (Stmt st : stmts) {
            st.visited = false;
            st.frame = null;
        }

        Stack<Stmt> stack = new Stack<Stmt>();
        Stmt first = stmts.getFirst();
        Stmt nop = null;
        if (first.st == ST.LABEL && first._cfg_froms.size() > 0) {
            nop = Stmts.nNop();
            // for
            // L0:
            // ...
            // GOTO L0:
            // make sure the first Label has one more super
            first._cfg_froms.add(nop);
        }
        stack.add(first);
        first.frame = sv.initFirstFrame(first);

        while (!stack.isEmpty()) {
            Stmt currentStmt = stack.pop();
            if (currentStmt == null || currentStmt.visited) {
                continue;
            } else {
                currentStmt.visited = true;
            }

            T beforeExecFrame = (T) currentStmt.frame;
            
            if (currentStmt.exceptionHandlers != null) {
                for (LabelStmt labelStmt : currentStmt.exceptionHandlers) {
                    labelStmt.frame = sv.merge(beforeExecFrame, (T) labelStmt.frame, currentStmt, labelStmt);
                    stack.push(labelStmt);
                }
            }
            
            T afterExecFrame = sv.exec(beforeExecFrame, currentStmt);

            if (currentStmt.st.canSwitch()) {
                BaseSwitchStmt bs = (BaseSwitchStmt) currentStmt;
                for (LabelStmt target : bs.targets) {
                    target.frame = sv.merge(afterExecFrame, (T) target.frame, currentStmt, target);
                    stack.push(target);
                }
                LabelStmt target = bs.defaultTarget;
                target.frame = sv.merge(afterExecFrame, (T) target.frame, currentStmt, target);
                stack.push(target);
            }
            if (currentStmt.st.canBranch()) {
                Stmt target = ((JumpStmt) currentStmt).getTarget();
                target.frame = sv.merge(afterExecFrame, (T) target.frame, currentStmt, target);
                stack.push(target);
            }
            if (currentStmt.st.canContinue()) {
                Stmt target = currentStmt.getNext();
                target.frame = sv.merge(afterExecFrame, (T) target.frame, currentStmt, target);
                stack.push(target);
            }
        }

        if (nop != null) {
            first._cfg_froms.remove(nop);
        }      
    }",iterator
i,"{
        switch (value.et) {
        case E0:
            if (value.vt == VT.LOCAL) {
                return callback.onUse((Local) value);
            }
            break;
        case E1:
            value.setOp(travelMod(value.getOp(), callback));
            break;
        case E2:
            value.setOp1(travelMod(value.getOp1(), callback));
            value.setOp2(travelMod(value.getOp2(), callback));
            break;
        case En:
            Value ops[] = value.getOps();
            for (int i = 0; i < ops.length; i++) {
                ops[i] = travelMod(ops[i], callback);
            }
            break;
        }
        return value;
    }",loop_control
i,"{
        switch (value.et) {
        case E0:
            if (value.vt == VT.LOCAL) {
                callback.onUse((Local) value);
            }
            break;
        case E1:
            travel(value.getOp(), callback);
            break;
        case E2:
            travel(value.getOp1(), callback);
            travel(value.getOp2(), callback);
            break;
        case En:
            Value ops[] = value.getOps();
            for (int i = 0; i < ops.length; i++) {
                travel(ops[i], callback);
            }
            break;
        }
    }",loop_control
phi,"{
        switch (p.et) {
        case E1:
            p.setOp(travelMod(p.getOp(), callback));
            break;
        case E2:
            Value e2op1 = p.getOp1();
            if (e2op1.vt == VT.LOCAL && (p.st == ST.ASSIGN || p.st == ST.IDENTITY)) {
                p.setOp2(travelMod(p.getOp2(), callback));
                p.setOp1(callback.onAssign((Local) e2op1, (AssignStmt) p));
            } else {
                p.setOp1(travelMod(p.getOp1(), callback));
                p.setOp2(travelMod(p.getOp2(), callback));
            }
            break;
        case En:
        case E0:
            if (travelPhi && p.st == ST.LABEL) {
                LabelStmt labelStmt = (LabelStmt) p;
                if (labelStmt.phis != null) {
                    for (AssignStmt phi : labelStmt.phis) {
                        travelMod(phi, callback, false);
                    }
                }
            }
            break;
        }
    }",iterator
phi,"{
        switch (p.et) {
        case E1:
            travel(p.getOp(), callback);
            break;
        case E2:
            Value e2op1 = p.getOp1();
            if (e2op1.vt == VT.LOCAL && (p.st == ST.ASSIGN || p.st == ST.IDENTITY)) {
                travel(p.getOp2(), callback);
                callback.onAssign((Local) e2op1, (AssignStmt) p);
            } else {
                travel(p.getOp1(), callback);
                travel(p.getOp2(), callback);
            }
            break;
        case En:
        case E0:
            if (travelPhi && p.st == ST.LABEL) {
                LabelStmt labelStmt = (LabelStmt) p;
                if (labelStmt.phis != null) {
                    for (AssignStmt phi : labelStmt.phis) {
                        travel(phi, callback, false);
                    }
                }
            }
            break;
        }
    }",iterator
p,"{
        for (Stmt p = stmts.getFirst(); p != null; p = p.getNext()) {
            travel(p, callback, travelPhi);
        }
    }",maybe_loop_control
p,"{
        for (Stmt p = stmts.getFirst(); p != null; p = p.getNext()) {
            travelMod(p, callback, travelPhi);
        }
    }",maybe_loop_control
local,"{
        int i = 0;
        for (Local local : method.locals) {
            local._ls_index = i++;
        }
        return i;
    }",iterator
target,"{
        if (stmt.st.canBranch()) {
            tos.add(((JumpStmt) stmt).getTarget());
        }
        if (stmt.st.canContinue()) {
            tos.add(stmt.getNext());
        }
        if (stmt.st.canSwitch()) {
            BaseSwitchStmt bss = (BaseSwitchStmt) stmt;
            tos.add(bss.defaultTarget);

            for (Stmt target : bss.targets) {
                tos.add(target);
            }
        }
        if (stmt.exceptionHandlers != null) {
            tos.addAll(stmt.exceptionHandlers);
        }
    }",iterator
trap,"{
        List<Trap> trips = irMethod.traps;
        irMethod.traps = new ArrayList();
        LabelAndLocalMapper map=new LabelAndLocalMapper(){
            @Override
            public LabelStmt map(LabelStmt label) {
                return label;
            }
        };
        for (Trap trap : trips) {
            Trap ntrap = trap.clone(map);
            int status = 0;
            for (Stmt p = trap.start.getNext(); p != trap.end; p = p.getNext()) {
                if (!Cfg.notThrow(p)) {
                    if (status == 0) {
                        Stmt pre = p.getPre();
                        if (pre == null || pre.st != ST.LABEL) {
                            pre = Stmts.nLabel();
                            irMethod.stmts.insertBefore(p, pre);
                        }
                        ntrap.start = (LabelStmt) pre;
                        status = 1;
                    } else if (status == 1) {
                        // continue;
                    }

                } else if (status == 1) {
                    Stmt pre = p.getPre();
                    if (pre == null || pre.st != ST.LABEL) {
                        pre = Stmts.nLabel();
                        irMethod.stmts.insertBefore(p, pre);
                    }

                    ntrap.end = (LabelStmt) pre;
                    irMethod.traps.add(ntrap);
                    status = 0;
                    ntrap = trap.clone(map);
                }
            }
            if (status == 1) {
                ntrap.end = trap.end;
                irMethod.traps.add(ntrap);
                status = 0;
            }
        }
    }",iterator
p,"{
        List<Trap> trips = irMethod.traps;
        irMethod.traps = new ArrayList();
        LabelAndLocalMapper map=new LabelAndLocalMapper(){
            @Override
            public LabelStmt map(LabelStmt label) {
                return label;
            }
        };
        for (Trap trap : trips) {
            Trap ntrap = trap.clone(map);
            int status = 0;
            for (Stmt p = trap.start.getNext(); p != trap.end; p = p.getNext()) {
                if (!Cfg.notThrow(p)) {
                    if (status == 0) {
                        Stmt pre = p.getPre();
                        if (pre == null || pre.st != ST.LABEL) {
                            pre = Stmts.nLabel();
                            irMethod.stmts.insertBefore(p, pre);
                        }
                        ntrap.start = (LabelStmt) pre;
                        status = 1;
                    } else if (status == 1) {
                        // continue;
                    }

                } else if (status == 1) {
                    Stmt pre = p.getPre();
                    if (pre == null || pre.st != ST.LABEL) {
                        pre = Stmts.nLabel();
                        irMethod.stmts.insertBefore(p, pre);
                    }

                    ntrap.end = (LabelStmt) pre;
                    irMethod.traps.add(ntrap);
                    status = 0;
                    ntrap = trap.clone(map);
                }
            }
            if (status == 1) {
                ntrap.end = trap.end;
                irMethod.traps.add(ntrap);
                status = 0;
            }
        }
    }",maybe_loop_control
p,"{
        final Map<Local, TObject> init = new HashMap<>();
        for (Stmt p : method.stmts) {
            if (p.st == ASSIGN && p.getOp1().vt == LOCAL && p.getOp2().vt == NEW) {
                // the stmt is a new assign stmt
                Local local = (Local) p.getOp1();
                init.put(local, new TObject(local, (AssignStmt) p));
            }
        }

        if (init.size() > 0) {
            final int size = Cfg.reIndexLocal(method);
            makeSureUsedBeforeConstructor(method, init, size);
            if (init.size() > 0) {
                replace0(method, init, size);
            }
            for (Stmt stmt : method.stmts) {
                stmt.frame = null;
            }
        }
    }",iterator
stmt,"{
        final Map<Local, TObject> init = new HashMap<>();
        for (Stmt p : method.stmts) {
            if (p.st == ASSIGN && p.getOp1().vt == LOCAL && p.getOp2().vt == NEW) {
                // the stmt is a new assign stmt
                Local local = (Local) p.getOp1();
                init.put(local, new TObject(local, (AssignStmt) p));
            }
        }

        if (init.size() > 0) {
            final int size = Cfg.reIndexLocal(method);
            makeSureUsedBeforeConstructor(method, init, size);
            if (init.size() > 0) {
                replace0(method, init, size);
            }
            for (Stmt stmt : method.stmts) {
                stmt.frame = null;
            }
        }
    }",iterator
it,"{
        for (Iterator<Stmt> it = method.stmts.iterator(); it.hasNext(); ) {
            Stmt p = it.next();

            InvokeExpr ie = findInvokeExpr(p);

            if (ie != null) {
                if (""<init>"".equals(ie.getName()) && ""V"".equals(ie.getRet())) {
                    Value[] orgOps = ie.getOps();
                    if (orgOps[0].vt == NEW) {
                        NewExpr newExpr = (NewExpr) ie.getOps()[0];
                        if (newExpr != null) {
                            Value[] nOps = Arrays.copyOfRange(orgOps, 1, orgOps.length);
                            InvokeExpr invokeNew = Exprs.nInvokeNew(nOps, ie.getArgs(), ie.getOwner());
                            method.stmts.insertBefore(p, Stmts.nVoidInvoke(invokeNew));
                            it.remove();
                        }
                    }
                }
            }
        }
    }",iterator
local,"{
        Set<Local> toDelete = new HashSet<>();

        Local locals[] = new Local[size];
        for (Local local : method.locals) {
            locals[local._ls_index] = local;
        }

        // find all locals to delete
        for (TObject obj : init.values()) {
            Vx[] frame = (Vx[]) obj.invokeStmt.frame;
            for (int i = 0; i < frame.length; i++) {
                Vx s = frame[i];
                if (s != null && s.obj == obj) {
                    toDelete.add(locals[i]);
                }
            }
        }
        // delete the locals
        for (Iterator<Stmt> it = method.stmts.iterator(); it.hasNext(); ) {
            Stmt p = it.next();
            if (p.st == ASSIGN && p.getOp1().vt == LOCAL) {
                if (toDelete.contains((Local) p.getOp1())) {
                    it.remove();
                }
            }
        }
        // add the locals back
        for (TObject obj : init.values()) {
            Vx[] frame = (Vx[]) obj.invokeStmt.frame;
            for (int i = 0; i < frame.length; i++) {
                Vx s = frame[i];
                if (s != null && s.obj == obj) {
                    Local b = locals[i];
                    if (b != obj.local) {
                        method.stmts.insertAfter(obj.invokeStmt, Stmts.nAssign(b, obj.local));
                    }
                }
            }
            InvokeExpr ie = findInvokeExpr(obj.invokeStmt);
            Value[] orgOps = ie.getOps();
            Value[] nOps = Arrays.copyOfRange(orgOps, 1, orgOps.length);
            InvokeExpr invokeNew = Exprs.nInvokeNew(nOps, ie.getArgs(), ie.getOwner());
            method.stmts.replace(obj.invokeStmt, Stmts.nAssign(obj.local, invokeNew));
        }
    }",iterator
obj,"{
        Set<Local> toDelete = new HashSet<>();

        Local locals[] = new Local[size];
        for (Local local : method.locals) {
            locals[local._ls_index] = local;
        }

        // find all locals to delete
        for (TObject obj : init.values()) {
            Vx[] frame = (Vx[]) obj.invokeStmt.frame;
            for (int i = 0; i < frame.length; i++) {
                Vx s = frame[i];
                if (s != null && s.obj == obj) {
                    toDelete.add(locals[i]);
                }
            }
        }
        // delete the locals
        for (Iterator<Stmt> it = method.stmts.iterator(); it.hasNext(); ) {
            Stmt p = it.next();
            if (p.st == ASSIGN && p.getOp1().vt == LOCAL) {
                if (toDelete.contains((Local) p.getOp1())) {
                    it.remove();
                }
            }
        }
        // add the locals back
        for (TObject obj : init.values()) {
            Vx[] frame = (Vx[]) obj.invokeStmt.frame;
            for (int i = 0; i < frame.length; i++) {
                Vx s = frame[i];
                if (s != null && s.obj == obj) {
                    Local b = locals[i];
                    if (b != obj.local) {
                        method.stmts.insertAfter(obj.invokeStmt, Stmts.nAssign(b, obj.local));
                    }
                }
            }
            InvokeExpr ie = findInvokeExpr(obj.invokeStmt);
            Value[] orgOps = ie.getOps();
            Value[] nOps = Arrays.copyOfRange(orgOps, 1, orgOps.length);
            InvokeExpr invokeNew = Exprs.nInvokeNew(nOps, ie.getArgs(), ie.getOwner());
            method.stmts.replace(obj.invokeStmt, Stmts.nAssign(obj.local, invokeNew));
        }
    }",iterator
i,"{
        Set<Local> toDelete = new HashSet<>();

        Local locals[] = new Local[size];
        for (Local local : method.locals) {
            locals[local._ls_index] = local;
        }

        // find all locals to delete
        for (TObject obj : init.values()) {
            Vx[] frame = (Vx[]) obj.invokeStmt.frame;
            for (int i = 0; i < frame.length; i++) {
                Vx s = frame[i];
                if (s != null && s.obj == obj) {
                    toDelete.add(locals[i]);
                }
            }
        }
        // delete the locals
        for (Iterator<Stmt> it = method.stmts.iterator(); it.hasNext(); ) {
            Stmt p = it.next();
            if (p.st == ASSIGN && p.getOp1().vt == LOCAL) {
                if (toDelete.contains((Local) p.getOp1())) {
                    it.remove();
                }
            }
        }
        // add the locals back
        for (TObject obj : init.values()) {
            Vx[] frame = (Vx[]) obj.invokeStmt.frame;
            for (int i = 0; i < frame.length; i++) {
                Vx s = frame[i];
                if (s != null && s.obj == obj) {
                    Local b = locals[i];
                    if (b != obj.local) {
                        method.stmts.insertAfter(obj.invokeStmt, Stmts.nAssign(b, obj.local));
                    }
                }
            }
            InvokeExpr ie = findInvokeExpr(obj.invokeStmt);
            Value[] orgOps = ie.getOps();
            Value[] nOps = Arrays.copyOfRange(orgOps, 1, orgOps.length);
            InvokeExpr invokeNew = Exprs.nInvokeNew(nOps, ie.getArgs(), ie.getOwner());
            method.stmts.replace(obj.invokeStmt, Stmts.nAssign(obj.local, invokeNew));
        }
    }",loop_control
it,"{
        Set<Local> toDelete = new HashSet<>();

        Local locals[] = new Local[size];
        for (Local local : method.locals) {
            locals[local._ls_index] = local;
        }

        // find all locals to delete
        for (TObject obj : init.values()) {
            Vx[] frame = (Vx[]) obj.invokeStmt.frame;
            for (int i = 0; i < frame.length; i++) {
                Vx s = frame[i];
                if (s != null && s.obj == obj) {
                    toDelete.add(locals[i]);
                }
            }
        }
        // delete the locals
        for (Iterator<Stmt> it = method.stmts.iterator(); it.hasNext(); ) {
            Stmt p = it.next();
            if (p.st == ASSIGN && p.getOp1().vt == LOCAL) {
                if (toDelete.contains((Local) p.getOp1())) {
                    it.remove();
                }
            }
        }
        // add the locals back
        for (TObject obj : init.values()) {
            Vx[] frame = (Vx[]) obj.invokeStmt.frame;
            for (int i = 0; i < frame.length; i++) {
                Vx s = frame[i];
                if (s != null && s.obj == obj) {
                    Local b = locals[i];
                    if (b != obj.local) {
                        method.stmts.insertAfter(obj.invokeStmt, Stmts.nAssign(b, obj.local));
                    }
                }
            }
            InvokeExpr ie = findInvokeExpr(obj.invokeStmt);
            Value[] orgOps = ie.getOps();
            Value[] nOps = Arrays.copyOfRange(orgOps, 1, orgOps.length);
            InvokeExpr invokeNew = Exprs.nInvokeNew(nOps, ie.getArgs(), ie.getOwner());
            method.stmts.replace(obj.invokeStmt, Stmts.nAssign(obj.local, invokeNew));
        }
    }",iterator
phi,"{
        Cfg.createCFG(method);
        Cfg.dfs(method.stmts, new Cfg.FrameVisitor<Vx[]>() {

            boolean keepFrame = false;
            Vx[] tmp = new Vx[size];
            StmtTraveler stmtTraveler = new StmtTraveler() {
                Stmt current;

                @Override
                public Stmt travel(Stmt stmt) {

                    this.current = stmt;
                    if (stmt.et == ET.E2) {
                        if (stmt.getOp1().vt == LOCAL) {
                            Local op1 = (Local) stmt.getOp1();
                            if (stmt.getOp2().vt == LOCAL) {
                                Local op2 = (Local) stmt.getOp2();
                                tmp[op1._ls_index] = tmp[op2._ls_index];
                                return stmt;
                            } else if (stmt.getOp2().vt == NEW) {
                                tmp[op1._ls_index] = new Vx(init.get(op1), false);
                                return stmt;
                            } else {
                                travel(stmt.getOp2());
                                tmp[op1._ls_index] = IGNORED;
                                return stmt;
                            }
                        }
                    }
                    if (stmt.st == LABEL) {
                        LabelStmt labelStmt = (LabelStmt) stmt;
                        if (labelStmt.phis != null) {
                            for (AssignStmt phi : labelStmt.phis) {
                                Local local = (Local) phi.getOp1();
                                tmp[local._ls_index] = IGNORED;
                            }
                        }
                        return stmt;
                    }
                    return super.travel(stmt);
                }

                @Override
                public Value travel(Value op) {
                    if (op.vt == INVOKE_SPECIAL) {
                        if (op.getOps().length >= 1) {
                            InvokeExpr ie = (InvokeExpr) op;
                            if (""<init>"".equals(ie.getName())) {
                                Value thiz = op.getOps()[0];
                                if (thiz.vt == LOCAL) {
                                    Local local = (Local) thiz;
                                    Vx vx = tmp[local._ls_index];
                                    TObject object = vx.obj;
                                    if (object != null) {
                                        if (object.invokeStmt != null) {
                                            object.useBeforeInit = true;
                                        } else {
                                            vx.init = true;
                                            object.invokeStmt = current;
                                            for (int i = 0; i < tmp.length; i++) {
                                                Vx s = tmp[i];
                                                if (s != null && s.obj == object) {
                                                    tmp[i] = IGNORED;
                                                }
                                            }
                                            keepFrame = true;
                                        }
                                    }
                                }
                            }
                        }
                    }
                    op = super.travel(op);

                    if (op.vt == LOCAL) {
                        use((Local) op);
                    }

                    return op;
                }
            };

            @Override
            public Vx[] merge(Vx[] srcFrame, Vx[] distFrame, Stmt src, Stmt dist) {
                if (distFrame == null) {
                    distFrame = new Vx[size];
                    System.arraycopy(srcFrame, 0, distFrame, 0, size);
                } else {
                    for (int i = 0; i < size; i++) {
                        Vx s = srcFrame[i];
                        Vx d = distFrame[i];
                        if (s != null) {
                            if (d == null) {
                                distFrame[i] = s;
                            } else {
                                if (s != d) {
                                    TObject obj = s.obj;
                                    if (obj != null) {
                                        obj.useBeforeInit = true;
                                    }
                                    obj = d.obj;
                                    if (obj != null) {
                                        obj.useBeforeInit = true;
                                    }
                                }
                            }
                        }
                    }
                }

                if (dist.st == LABEL) {
                    List<AssignStmt> phis = ((LabelStmt) dist).phis;
                    if (phis != null && phis.size() > 0) {
                        for (AssignStmt phi : phis) {
                            for (Value value : phi.getOp2().getOps()) {
                                Local local = (Local) value;
                                int i = local._ls_index;
                                Vx s = srcFrame[i];
                                Vx d = distFrame[i];
                                if (d != null) {
                                    if (!d.init) {
                                        TObject obj = d.obj;
                                        if (obj != null) {
                                            obj.useBeforeInit = true;
                                        }
                                    }
                                } else if (s != null) {
                                    if (!s.init) {
                                        TObject obj = s.obj;
                                        if (obj != null) {
                                            obj.useBeforeInit = true;
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
                return distFrame;
            }

            @Override
            public Vx[] initFirstFrame(Stmt first) {
                return new Vx[size];
            }

            @Override
            public Vx[] exec(Vx[] frame, Stmt stmt) {
                keepFrame = false;
                System.arraycopy(frame, 0, tmp, 0, size);
                stmtTraveler.travel(stmt);
                if (stmt._cfg_froms.size() > 1) {
                    keepFrame = true;
                }

                if (!keepFrame) {
                    stmt.frame = null;
                }
                return tmp;
            }

            void use(Local local) {
                Vx vx = tmp[local._ls_index];
                if (!vx.init) {
                    TObject object = vx.obj;
                    if (object != null) {
                        object.useBeforeInit = true;
                    }

                    tmp[local._ls_index] = IGNORED;
                }

            }
        });
        for (Iterator<Map.Entry<Local, TObject>> iterator = init.entrySet().iterator(); iterator.hasNext(); ) {
            Map.Entry<Local, TObject> e = iterator.next();
            boolean keep = true;
            TObject obj = e.getValue();
            if (obj.useBeforeInit) {
                keep = false;
            }
            if (obj.invokeStmt == null) {
                keep = false;
            }
            if (!keep) {
                iterator.remove();
            }
        }
    }",iterator
i,"{
        Cfg.createCFG(method);
        Cfg.dfs(method.stmts, new Cfg.FrameVisitor<Vx[]>() {

            boolean keepFrame = false;
            Vx[] tmp = new Vx[size];
            StmtTraveler stmtTraveler = new StmtTraveler() {
                Stmt current;

                @Override
                public Stmt travel(Stmt stmt) {

                    this.current = stmt;
                    if (stmt.et == ET.E2) {
                        if (stmt.getOp1().vt == LOCAL) {
                            Local op1 = (Local) stmt.getOp1();
                            if (stmt.getOp2().vt == LOCAL) {
                                Local op2 = (Local) stmt.getOp2();
                                tmp[op1._ls_index] = tmp[op2._ls_index];
                                return stmt;
                            } else if (stmt.getOp2().vt == NEW) {
                                tmp[op1._ls_index] = new Vx(init.get(op1), false);
                                return stmt;
                            } else {
                                travel(stmt.getOp2());
                                tmp[op1._ls_index] = IGNORED;
                                return stmt;
                            }
                        }
                    }
                    if (stmt.st == LABEL) {
                        LabelStmt labelStmt = (LabelStmt) stmt;
                        if (labelStmt.phis != null) {
                            for (AssignStmt phi : labelStmt.phis) {
                                Local local = (Local) phi.getOp1();
                                tmp[local._ls_index] = IGNORED;
                            }
                        }
                        return stmt;
                    }
                    return super.travel(stmt);
                }

                @Override
                public Value travel(Value op) {
                    if (op.vt == INVOKE_SPECIAL) {
                        if (op.getOps().length >= 1) {
                            InvokeExpr ie = (InvokeExpr) op;
                            if (""<init>"".equals(ie.getName())) {
                                Value thiz = op.getOps()[0];
                                if (thiz.vt == LOCAL) {
                                    Local local = (Local) thiz;
                                    Vx vx = tmp[local._ls_index];
                                    TObject object = vx.obj;
                                    if (object != null) {
                                        if (object.invokeStmt != null) {
                                            object.useBeforeInit = true;
                                        } else {
                                            vx.init = true;
                                            object.invokeStmt = current;
                                            for (int i = 0; i < tmp.length; i++) {
                                                Vx s = tmp[i];
                                                if (s != null && s.obj == object) {
                                                    tmp[i] = IGNORED;
                                                }
                                            }
                                            keepFrame = true;
                                        }
                                    }
                                }
                            }
                        }
                    }
                    op = super.travel(op);

                    if (op.vt == LOCAL) {
                        use((Local) op);
                    }

                    return op;
                }
            };

            @Override
            public Vx[] merge(Vx[] srcFrame, Vx[] distFrame, Stmt src, Stmt dist) {
                if (distFrame == null) {
                    distFrame = new Vx[size];
                    System.arraycopy(srcFrame, 0, distFrame, 0, size);
                } else {
                    for (int i = 0; i < size; i++) {
                        Vx s = srcFrame[i];
                        Vx d = distFrame[i];
                        if (s != null) {
                            if (d == null) {
                                distFrame[i] = s;
                            } else {
                                if (s != d) {
                                    TObject obj = s.obj;
                                    if (obj != null) {
                                        obj.useBeforeInit = true;
                                    }
                                    obj = d.obj;
                                    if (obj != null) {
                                        obj.useBeforeInit = true;
                                    }
                                }
                            }
                        }
                    }
                }

                if (dist.st == LABEL) {
                    List<AssignStmt> phis = ((LabelStmt) dist).phis;
                    if (phis != null && phis.size() > 0) {
                        for (AssignStmt phi : phis) {
                            for (Value value : phi.getOp2().getOps()) {
                                Local local = (Local) value;
                                int i = local._ls_index;
                                Vx s = srcFrame[i];
                                Vx d = distFrame[i];
                                if (d != null) {
                                    if (!d.init) {
                                        TObject obj = d.obj;
                                        if (obj != null) {
                                            obj.useBeforeInit = true;
                                        }
                                    }
                                } else if (s != null) {
                                    if (!s.init) {
                                        TObject obj = s.obj;
                                        if (obj != null) {
                                            obj.useBeforeInit = true;
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
                return distFrame;
            }

            @Override
            public Vx[] initFirstFrame(Stmt first) {
                return new Vx[size];
            }

            @Override
            public Vx[] exec(Vx[] frame, Stmt stmt) {
                keepFrame = false;
                System.arraycopy(frame, 0, tmp, 0, size);
                stmtTraveler.travel(stmt);
                if (stmt._cfg_froms.size() > 1) {
                    keepFrame = true;
                }

                if (!keepFrame) {
                    stmt.frame = null;
                }
                return tmp;
            }

            void use(Local local) {
                Vx vx = tmp[local._ls_index];
                if (!vx.init) {
                    TObject object = vx.obj;
                    if (object != null) {
                        object.useBeforeInit = true;
                    }

                    tmp[local._ls_index] = IGNORED;
                }

            }
        });
        for (Iterator<Map.Entry<Local, TObject>> iterator = init.entrySet().iterator(); iterator.hasNext(); ) {
            Map.Entry<Local, TObject> e = iterator.next();
            boolean keep = true;
            TObject obj = e.getValue();
            if (obj.useBeforeInit) {
                keep = false;
            }
            if (obj.invokeStmt == null) {
                keep = false;
            }
            if (!keep) {
                iterator.remove();
            }
        }
    }",loop_control
iterator,"{
        Cfg.createCFG(method);
        Cfg.dfs(method.stmts, new Cfg.FrameVisitor<Vx[]>() {

            boolean keepFrame = false;
            Vx[] tmp = new Vx[size];
            StmtTraveler stmtTraveler = new StmtTraveler() {
                Stmt current;

                @Override
                public Stmt travel(Stmt stmt) {

                    this.current = stmt;
                    if (stmt.et == ET.E2) {
                        if (stmt.getOp1().vt == LOCAL) {
                            Local op1 = (Local) stmt.getOp1();
                            if (stmt.getOp2().vt == LOCAL) {
                                Local op2 = (Local) stmt.getOp2();
                                tmp[op1._ls_index] = tmp[op2._ls_index];
                                return stmt;
                            } else if (stmt.getOp2().vt == NEW) {
                                tmp[op1._ls_index] = new Vx(init.get(op1), false);
                                return stmt;
                            } else {
                                travel(stmt.getOp2());
                                tmp[op1._ls_index] = IGNORED;
                                return stmt;
                            }
                        }
                    }
                    if (stmt.st == LABEL) {
                        LabelStmt labelStmt = (LabelStmt) stmt;
                        if (labelStmt.phis != null) {
                            for (AssignStmt phi : labelStmt.phis) {
                                Local local = (Local) phi.getOp1();
                                tmp[local._ls_index] = IGNORED;
                            }
                        }
                        return stmt;
                    }
                    return super.travel(stmt);
                }

                @Override
                public Value travel(Value op) {
                    if (op.vt == INVOKE_SPECIAL) {
                        if (op.getOps().length >= 1) {
                            InvokeExpr ie = (InvokeExpr) op;
                            if (""<init>"".equals(ie.getName())) {
                                Value thiz = op.getOps()[0];
                                if (thiz.vt == LOCAL) {
                                    Local local = (Local) thiz;
                                    Vx vx = tmp[local._ls_index];
                                    TObject object = vx.obj;
                                    if (object != null) {
                                        if (object.invokeStmt != null) {
                                            object.useBeforeInit = true;
                                        } else {
                                            vx.init = true;
                                            object.invokeStmt = current;
                                            for (int i = 0; i < tmp.length; i++) {
                                                Vx s = tmp[i];
                                                if (s != null && s.obj == object) {
                                                    tmp[i] = IGNORED;
                                                }
                                            }
                                            keepFrame = true;
                                        }
                                    }
                                }
                            }
                        }
                    }
                    op = super.travel(op);

                    if (op.vt == LOCAL) {
                        use((Local) op);
                    }

                    return op;
                }
            };

            @Override
            public Vx[] merge(Vx[] srcFrame, Vx[] distFrame, Stmt src, Stmt dist) {
                if (distFrame == null) {
                    distFrame = new Vx[size];
                    System.arraycopy(srcFrame, 0, distFrame, 0, size);
                } else {
                    for (int i = 0; i < size; i++) {
                        Vx s = srcFrame[i];
                        Vx d = distFrame[i];
                        if (s != null) {
                            if (d == null) {
                                distFrame[i] = s;
                            } else {
                                if (s != d) {
                                    TObject obj = s.obj;
                                    if (obj != null) {
                                        obj.useBeforeInit = true;
                                    }
                                    obj = d.obj;
                                    if (obj != null) {
                                        obj.useBeforeInit = true;
                                    }
                                }
                            }
                        }
                    }
                }

                if (dist.st == LABEL) {
                    List<AssignStmt> phis = ((LabelStmt) dist).phis;
                    if (phis != null && phis.size() > 0) {
                        for (AssignStmt phi : phis) {
                            for (Value value : phi.getOp2().getOps()) {
                                Local local = (Local) value;
                                int i = local._ls_index;
                                Vx s = srcFrame[i];
                                Vx d = distFrame[i];
                                if (d != null) {
                                    if (!d.init) {
                                        TObject obj = d.obj;
                                        if (obj != null) {
                                            obj.useBeforeInit = true;
                                        }
                                    }
                                } else if (s != null) {
                                    if (!s.init) {
                                        TObject obj = s.obj;
                                        if (obj != null) {
                                            obj.useBeforeInit = true;
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
                return distFrame;
            }

            @Override
            public Vx[] initFirstFrame(Stmt first) {
                return new Vx[size];
            }

            @Override
            public Vx[] exec(Vx[] frame, Stmt stmt) {
                keepFrame = false;
                System.arraycopy(frame, 0, tmp, 0, size);
                stmtTraveler.travel(stmt);
                if (stmt._cfg_froms.size() > 1) {
                    keepFrame = true;
                }

                if (!keepFrame) {
                    stmt.frame = null;
                }
                return tmp;
            }

            void use(Local local) {
                Vx vx = tmp[local._ls_index];
                if (!vx.init) {
                    TObject object = vx.obj;
                    if (object != null) {
                        object.useBeforeInit = true;
                    }

                    tmp[local._ls_index] = IGNORED;
                }

            }
        });
        for (Iterator<Map.Entry<Local, TObject>> iterator = init.entrySet().iterator(); iterator.hasNext(); ) {
            Map.Entry<Local, TObject> e = iterator.next();
            boolean keep = true;
            TObject obj = e.getValue();
            if (obj.useBeforeInit) {
                keep = false;
            }
            if (obj.invokeStmt == null) {
                keep = false;
            }
            if (!keep) {
                iterator.remove();
            }
        }
    }",iterator
size,"{
        boolean changed = false;
        if (method.locals.size() == 0) {
            return false;
        }
        StmtSearcher st = new StmtSearcher() {
            @Override
            public void travel(Stmt stmt) {
                if (stmt.st == Stmt.ST.FILL_ARRAY_DATA) {
                    if (isNull(stmt.getOp1())) {
                        throw NPE;
                    }
                }
                super.travel(stmt);
            }

            @Override
            public void travel(Value op) {
                switch (op.vt) {
                case INVOKE_VIRTUAL:
                case INVOKE_SPECIAL:
                case INVOKE_INTERFACE: {
                    if (isNull(op.getOps()[0])) {
                        throw NPE;
                    }
                }
                    break;
                case ARRAY: {
                    if (isNull(op.getOp1())) {
                        throw NPE;
                    }
                }
                    break;
                case FIELD: {
                    if (isNull(op.getOp())) {
                        throw NPE;
                    }
                }
                    break;
                    case IDIV:
                        if (op.getOp2().vt == Value.VT.CONSTANT) {
                            Constant constant = (Constant) op.getOp2();
                            if (((Number) constant.value).intValue() == 0) {
                                throw DIVE;
                            }
                        }
                        break;
                    case LDIV:
                        if (op.getOp2().vt == Value.VT.CONSTANT) {
                            Constant constant = (Constant) op.getOp2();
                            if (((Number) constant.value).longValue() == 0) {
                                throw DIVE;
                            }
                        }
                        break;
                    case NEW_ARRAY:
                        if (op.getOp().vt == Value.VT.CONSTANT) {
                            Constant constant = (Constant) op.getOp();
                            if (((Number) constant.value).intValue() < 0) {
                                throw NEGATIVE_ARRAY_SIZE;
                            }
                        }
                        break;
                    case NEW_MUTI_ARRAY:
                        for (Value size : op.getOps()) {
                            if (size.vt == Value.VT.CONSTANT) {
                                Constant constant = (Constant) size;
                                if (((Number) constant.value).intValue() < 0) {
                                    throw NEGATIVE_ARRAY_SIZE;
                                }
                            }
                        }
                        break;
                default:
                }
            }

        };
        for (Stmt p = method.stmts.getFirst(); p != null;) {
            try {
                st.travel(p);
                p = p.getNext();
            } catch (MustThrowException e) {
                replace(method, p);
                Stmt q = p.getNext();
                method.stmts.remove(p);
                changed = true;
                p = q;
            }
        }
        return changed;
    }",iterator
p,"{
        boolean changed = false;
        if (method.locals.size() == 0) {
            return false;
        }
        StmtSearcher st = new StmtSearcher() {
            @Override
            public void travel(Stmt stmt) {
                if (stmt.st == Stmt.ST.FILL_ARRAY_DATA) {
                    if (isNull(stmt.getOp1())) {
                        throw NPE;
                    }
                }
                super.travel(stmt);
            }

            @Override
            public void travel(Value op) {
                switch (op.vt) {
                case INVOKE_VIRTUAL:
                case INVOKE_SPECIAL:
                case INVOKE_INTERFACE: {
                    if (isNull(op.getOps()[0])) {
                        throw NPE;
                    }
                }
                    break;
                case ARRAY: {
                    if (isNull(op.getOp1())) {
                        throw NPE;
                    }
                }
                    break;
                case FIELD: {
                    if (isNull(op.getOp())) {
                        throw NPE;
                    }
                }
                    break;
                    case IDIV:
                        if (op.getOp2().vt == Value.VT.CONSTANT) {
                            Constant constant = (Constant) op.getOp2();
                            if (((Number) constant.value).intValue() == 0) {
                                throw DIVE;
                            }
                        }
                        break;
                    case LDIV:
                        if (op.getOp2().vt == Value.VT.CONSTANT) {
                            Constant constant = (Constant) op.getOp2();
                            if (((Number) constant.value).longValue() == 0) {
                                throw DIVE;
                            }
                        }
                        break;
                    case NEW_ARRAY:
                        if (op.getOp().vt == Value.VT.CONSTANT) {
                            Constant constant = (Constant) op.getOp();
                            if (((Number) constant.value).intValue() < 0) {
                                throw NEGATIVE_ARRAY_SIZE;
                            }
                        }
                        break;
                    case NEW_MUTI_ARRAY:
                        for (Value size : op.getOps()) {
                            if (size.vt == Value.VT.CONSTANT) {
                                Constant constant = (Constant) size;
                                if (((Number) constant.value).intValue() < 0) {
                                    throw NEGATIVE_ARRAY_SIZE;
                                }
                            }
                        }
                        break;
                default:
                }
            }

        };
        for (Stmt p = method.stmts.getFirst(); p != null;) {
            try {
                st.travel(p);
                p = p.getNext();
            } catch (MustThrowException e) {
                replace(method, p);
                Stmt q = p.getNext();
                method.stmts.remove(p);
                changed = true;
                p = q;
            }
        }
        return changed;
    }",maybe_loop_control
i,"{
        StmtTraveler traveler = new StmtTraveler() {
            @Override
            public Value travel(Value op) {
                switch (op.vt) {
                case INVOKE_VIRTUAL:
                case INVOKE_SPECIAL:
                case INVOKE_INTERFACE: {
                    Value ops[] = op.getOps();
                    if (isNull(ops[0])) {
                        for (int i = 1; i < ops.length; i++) {
                            travel(ops[i]);
                        }
                        throw NPE;
                    }
                }
                    break;
                case ARRAY: {
                    if (isNull(op.getOp1())) {
                        travel(op.getOp2());
                        throw NPE;
                    }
                }
                    break;
                case FIELD: {
                    if (isNull(op.getOp())) {
                        throw NPE;
                    }
                }
                    break;
                    case IDIV:
                        if (op.getOp2().vt == Value.VT.CONSTANT) {
                            Constant constant = (Constant) op.getOp2();
                            if (((Number) constant.value).intValue() == 0) {
                                travel(op.getOp1());
                                throw DIVE;
                            }
                        }
                        break;
                    case LDIV:
                        if (op.getOp2().vt == Value.VT.CONSTANT) {
                            Constant constant = (Constant) op.getOp2();
                            if (((Number) constant.value).longValue() == 0) {
                                travel(op.getOp1());
                                throw DIVE;
                            }
                        }
                        break;
                    case NEW_ARRAY:
                        if (op.getOp().vt == Value.VT.CONSTANT) {
                            Constant constant = (Constant) op.getOp();
                            if (((Number) constant.value).intValue() < 0) {
                                throw NEGATIVE_ARRAY_SIZE;
                            }
                        }
                        break;
                    case NEW_MUTI_ARRAY:
                        for (Value size : op.getOps()) {
                            if (size.vt == Value.VT.CONSTANT) {
                                Constant constant = (Constant) size;
                                if (((Number) constant.value).intValue() < 0) {
                                    throw NEGATIVE_ARRAY_SIZE;
                                }else {
                                    travel(size);
                                }
                            }
                        }
                        break;
                default:
                }
                Value sop = super.travel(op);
                if (sop.vt == Value.VT.LOCAL || sop.vt == Value.VT.CONSTANT) {
                    return sop;
                } else {
                    Local local = new Local();
                    m.locals.add(local);
                    m.stmts.insertBefore(p, Stmts.nAssign(local, sop));
                    return local;
                }
            }
        };
        try {
            switch (p.et) {
            case E0:
                // impossible
                break;
            case E1:
                traveler.travel(p.getOp());
                break;
            case E2:
                if (p.st == Stmt.ST.ASSIGN) {
                    switch (p.getOp1().vt) {
                    case ARRAY:
                        traveler.travel(p.getOp1().getOp1());
                        traveler.travel(p.getOp1().getOp2());
                        traveler.travel(p.getOp2());
                        break;
                    case FIELD:
                        traveler.travel(p.getOp1().getOp());
                        traveler.travel(p.getOp2());
                        break;
                    case STATIC_FIELD:
                    case LOCAL:
                        traveler.travel(p.getOp2());
                        break;
                    default:
                        // impossible
                    }
                } else if (p.st == Stmt.ST.FILL_ARRAY_DATA) {
                    if (isNull(p.getOp1())) {
                        throw NPE;
                    } else {
                        traveler.travel(p.getOp1());
                    }
                }
                break;
            case En:
            }
        } catch (MustThrowException e) {
            if (e == NPE) {
                m.stmts.insertBefore(p,
                        Stmts.nThrow(Exprs.nInvokeNew(new Value[0], new String[0], ""Ljava/lang/NullPointerException;"")));
            } else if (e == DIVE) {
                m.stmts.insertBefore(p,
                        Stmts.nThrow(Exprs.nInvokeNew(new Value[]{Exprs.nString(""divide by zero"")}, new String[]{""Ljava/lang/String;""}, ""Ljava/lang/ArithmeticException;"")));
            } else if (e == NEGATIVE_ARRAY_SIZE) {
                m.stmts.insertBefore(p,
                        Stmts.nThrow(Exprs.nInvokeNew(new Value[0], new String[0], ""Ljava/lang/NegativeArraySizeException;"")));
            }
        }
    }",loop_control
size,"{
        StmtTraveler traveler = new StmtTraveler() {
            @Override
            public Value travel(Value op) {
                switch (op.vt) {
                case INVOKE_VIRTUAL:
                case INVOKE_SPECIAL:
                case INVOKE_INTERFACE: {
                    Value ops[] = op.getOps();
                    if (isNull(ops[0])) {
                        for (int i = 1; i < ops.length; i++) {
                            travel(ops[i]);
                        }
                        throw NPE;
                    }
                }
                    break;
                case ARRAY: {
                    if (isNull(op.getOp1())) {
                        travel(op.getOp2());
                        throw NPE;
                    }
                }
                    break;
                case FIELD: {
                    if (isNull(op.getOp())) {
                        throw NPE;
                    }
                }
                    break;
                    case IDIV:
                        if (op.getOp2().vt == Value.VT.CONSTANT) {
                            Constant constant = (Constant) op.getOp2();
                            if (((Number) constant.value).intValue() == 0) {
                                travel(op.getOp1());
                                throw DIVE;
                            }
                        }
                        break;
                    case LDIV:
                        if (op.getOp2().vt == Value.VT.CONSTANT) {
                            Constant constant = (Constant) op.getOp2();
                            if (((Number) constant.value).longValue() == 0) {
                                travel(op.getOp1());
                                throw DIVE;
                            }
                        }
                        break;
                    case NEW_ARRAY:
                        if (op.getOp().vt == Value.VT.CONSTANT) {
                            Constant constant = (Constant) op.getOp();
                            if (((Number) constant.value).intValue() < 0) {
                                throw NEGATIVE_ARRAY_SIZE;
                            }
                        }
                        break;
                    case NEW_MUTI_ARRAY:
                        for (Value size : op.getOps()) {
                            if (size.vt == Value.VT.CONSTANT) {
                                Constant constant = (Constant) size;
                                if (((Number) constant.value).intValue() < 0) {
                                    throw NEGATIVE_ARRAY_SIZE;
                                }else {
                                    travel(size);
                                }
                            }
                        }
                        break;
                default:
                }
                Value sop = super.travel(op);
                if (sop.vt == Value.VT.LOCAL || sop.vt == Value.VT.CONSTANT) {
                    return sop;
                } else {
                    Local local = new Local();
                    m.locals.add(local);
                    m.stmts.insertBefore(p, Stmts.nAssign(local, sop));
                    return local;
                }
            }
        };
        try {
            switch (p.et) {
            case E0:
                // impossible
                break;
            case E1:
                traveler.travel(p.getOp());
                break;
            case E2:
                if (p.st == Stmt.ST.ASSIGN) {
                    switch (p.getOp1().vt) {
                    case ARRAY:
                        traveler.travel(p.getOp1().getOp1());
                        traveler.travel(p.getOp1().getOp2());
                        traveler.travel(p.getOp2());
                        break;
                    case FIELD:
                        traveler.travel(p.getOp1().getOp());
                        traveler.travel(p.getOp2());
                        break;
                    case STATIC_FIELD:
                    case LOCAL:
                        traveler.travel(p.getOp2());
                        break;
                    default:
                        // impossible
                    }
                } else if (p.st == Stmt.ST.FILL_ARRAY_DATA) {
                    if (isNull(p.getOp1())) {
                        throw NPE;
                    } else {
                        traveler.travel(p.getOp1());
                    }
                }
                break;
            case En:
            }
        } catch (MustThrowException e) {
            if (e == NPE) {
                m.stmts.insertBefore(p,
                        Stmts.nThrow(Exprs.nInvokeNew(new Value[0], new String[0], ""Ljava/lang/NullPointerException;"")));
            } else if (e == DIVE) {
                m.stmts.insertBefore(p,
                        Stmts.nThrow(Exprs.nInvokeNew(new Value[]{Exprs.nString(""divide by zero"")}, new String[]{""Ljava/lang/String;""}, ""Ljava/lang/ArithmeticException;"")));
            } else if (e == NEGATIVE_ARRAY_SIZE) {
                m.stmts.insertBefore(p,
                        Stmts.nThrow(Exprs.nInvokeNew(new Value[0], new String[0], ""Ljava/lang/NegativeArraySizeException;"")));
            }
        }
    }",iterator
e,"{
        final List<FilledArrayExpr> filledArrayExprs = new ArrayList<>();
        for (Map.Entry<Local, ArrayObject> e : arraySizes.entrySet()) {
            final Local local0 = e.getKey();
            final ArrayObject ao = e.getValue();
            final Value t[] = new Value[ao.size];
            for (Iterator<Stmt> it = ao.putItem.iterator(); it.hasNext();) {
                Stmt p = it.next();
                if (p.st == Stmt.ST.FILL_ARRAY_DATA) {
                    Local local = (Local) p.getOp1();
                    if (local == local0) {
                        Object vs = ((Constant) p.getOp2()).value;
                        int endPos = Array.getLength(vs);
                        for (int j = 0; j < endPos; j++) {
                            t[j] = Exprs.nConstant(Array.get(vs, j));
                        }
                    }
                } else { // ASSIGN
                    ArrayExpr ae = (ArrayExpr) p.getOp1();
                    Local local = (Local) ae.getOp1();
                    if (local == local0) {
                        int idx = ((Number) ((Constant) ae.getOp2()).value).intValue();
                        Value op2 = p.getOp2();
                        if (op2.vt != Value.VT.LOCAL && op2.vt != Value.VT.CONSTANT) {
                            Local n = new Local(-1);
                            method.locals.add(n);
                            method.stmts.insertBefore(p, Stmts.nAssign(n, op2));
                            op2 = n;
                        }
                        t[idx] = op2;
                    }
                }
            }

            // for code
            // b=new Object[1]
            // b[0]=null
            // a =new Object[1]
            // a =b;
            // use(a)
            // if a is replace before b, the code
            // b=new Object[1]
            // b[0]=null
            // use(new Object[]{b})
            // the used stmt of b is outdated, so we have to search pre replaced arrays

            method.locals.remove(local0);
            method.stmts.remove(ao.init);
            for (Stmt p : ao.putItem) {
                method.stmts.remove(p);
            }
            Cfg.TravelCallBack tcb = new Cfg.TravelCallBack() {
                @Override
                public Value onAssign(Local v, AssignStmt as) {
                    return v;
                }

                @Override
                public Value onUse(Local v) {
                    if (local0 == v) {
                        FilledArrayExpr fae = Exprs.nFilledArray(ao.type, t);
                        filledArrayExprs.add(fae);
                        return fae;
                    }
                    return v;
                }
            };

            if (ao.used.size() == 1) {
                Stmt stmt = ao.used.get(0);
                if (method.stmts.contains(stmt)) { // the stmt is not removed by pre array replacement
                    Cfg.travelMod(stmt, tcb, false);
                } else {
                    int size = filledArrayExprs.size();
                    for (int i = 0; i < size; i++) {
                        Cfg.travelMod(filledArrayExprs.get(i), tcb);
                    }
                }
            } else if (ao.used.size() == 0) {
                // the array is never used, ignore
            } else {
                throw new RuntimeException(""array is used multiple times"");
            }
        }
    }",iterator
it,"{
        final List<FilledArrayExpr> filledArrayExprs = new ArrayList<>();
        for (Map.Entry<Local, ArrayObject> e : arraySizes.entrySet()) {
            final Local local0 = e.getKey();
            final ArrayObject ao = e.getValue();
            final Value t[] = new Value[ao.size];
            for (Iterator<Stmt> it = ao.putItem.iterator(); it.hasNext();) {
                Stmt p = it.next();
                if (p.st == Stmt.ST.FILL_ARRAY_DATA) {
                    Local local = (Local) p.getOp1();
                    if (local == local0) {
                        Object vs = ((Constant) p.getOp2()).value;
                        int endPos = Array.getLength(vs);
                        for (int j = 0; j < endPos; j++) {
                            t[j] = Exprs.nConstant(Array.get(vs, j));
                        }
                    }
                } else { // ASSIGN
                    ArrayExpr ae = (ArrayExpr) p.getOp1();
                    Local local = (Local) ae.getOp1();
                    if (local == local0) {
                        int idx = ((Number) ((Constant) ae.getOp2()).value).intValue();
                        Value op2 = p.getOp2();
                        if (op2.vt != Value.VT.LOCAL && op2.vt != Value.VT.CONSTANT) {
                            Local n = new Local(-1);
                            method.locals.add(n);
                            method.stmts.insertBefore(p, Stmts.nAssign(n, op2));
                            op2 = n;
                        }
                        t[idx] = op2;
                    }
                }
            }

            // for code
            // b=new Object[1]
            // b[0]=null
            // a =new Object[1]
            // a =b;
            // use(a)
            // if a is replace before b, the code
            // b=new Object[1]
            // b[0]=null
            // use(new Object[]{b})
            // the used stmt of b is outdated, so we have to search pre replaced arrays

            method.locals.remove(local0);
            method.stmts.remove(ao.init);
            for (Stmt p : ao.putItem) {
                method.stmts.remove(p);
            }
            Cfg.TravelCallBack tcb = new Cfg.TravelCallBack() {
                @Override
                public Value onAssign(Local v, AssignStmt as) {
                    return v;
                }

                @Override
                public Value onUse(Local v) {
                    if (local0 == v) {
                        FilledArrayExpr fae = Exprs.nFilledArray(ao.type, t);
                        filledArrayExprs.add(fae);
                        return fae;
                    }
                    return v;
                }
            };

            if (ao.used.size() == 1) {
                Stmt stmt = ao.used.get(0);
                if (method.stmts.contains(stmt)) { // the stmt is not removed by pre array replacement
                    Cfg.travelMod(stmt, tcb, false);
                } else {
                    int size = filledArrayExprs.size();
                    for (int i = 0; i < size; i++) {
                        Cfg.travelMod(filledArrayExprs.get(i), tcb);
                    }
                }
            } else if (ao.used.size() == 0) {
                // the array is never used, ignore
            } else {
                throw new RuntimeException(""array is used multiple times"");
            }
        }
    }",iterator
j,"{
        final List<FilledArrayExpr> filledArrayExprs = new ArrayList<>();
        for (Map.Entry<Local, ArrayObject> e : arraySizes.entrySet()) {
            final Local local0 = e.getKey();
            final ArrayObject ao = e.getValue();
            final Value t[] = new Value[ao.size];
            for (Iterator<Stmt> it = ao.putItem.iterator(); it.hasNext();) {
                Stmt p = it.next();
                if (p.st == Stmt.ST.FILL_ARRAY_DATA) {
                    Local local = (Local) p.getOp1();
                    if (local == local0) {
                        Object vs = ((Constant) p.getOp2()).value;
                        int endPos = Array.getLength(vs);
                        for (int j = 0; j < endPos; j++) {
                            t[j] = Exprs.nConstant(Array.get(vs, j));
                        }
                    }
                } else { // ASSIGN
                    ArrayExpr ae = (ArrayExpr) p.getOp1();
                    Local local = (Local) ae.getOp1();
                    if (local == local0) {
                        int idx = ((Number) ((Constant) ae.getOp2()).value).intValue();
                        Value op2 = p.getOp2();
                        if (op2.vt != Value.VT.LOCAL && op2.vt != Value.VT.CONSTANT) {
                            Local n = new Local(-1);
                            method.locals.add(n);
                            method.stmts.insertBefore(p, Stmts.nAssign(n, op2));
                            op2 = n;
                        }
                        t[idx] = op2;
                    }
                }
            }

            // for code
            // b=new Object[1]
            // b[0]=null
            // a =new Object[1]
            // a =b;
            // use(a)
            // if a is replace before b, the code
            // b=new Object[1]
            // b[0]=null
            // use(new Object[]{b})
            // the used stmt of b is outdated, so we have to search pre replaced arrays

            method.locals.remove(local0);
            method.stmts.remove(ao.init);
            for (Stmt p : ao.putItem) {
                method.stmts.remove(p);
            }
            Cfg.TravelCallBack tcb = new Cfg.TravelCallBack() {
                @Override
                public Value onAssign(Local v, AssignStmt as) {
                    return v;
                }

                @Override
                public Value onUse(Local v) {
                    if (local0 == v) {
                        FilledArrayExpr fae = Exprs.nFilledArray(ao.type, t);
                        filledArrayExprs.add(fae);
                        return fae;
                    }
                    return v;
                }
            };

            if (ao.used.size() == 1) {
                Stmt stmt = ao.used.get(0);
                if (method.stmts.contains(stmt)) { // the stmt is not removed by pre array replacement
                    Cfg.travelMod(stmt, tcb, false);
                } else {
                    int size = filledArrayExprs.size();
                    for (int i = 0; i < size; i++) {
                        Cfg.travelMod(filledArrayExprs.get(i), tcb);
                    }
                }
            } else if (ao.used.size() == 0) {
                // the array is never used, ignore
            } else {
                throw new RuntimeException(""array is used multiple times"");
            }
        }
    }",loop_control
p,"{
        final List<FilledArrayExpr> filledArrayExprs = new ArrayList<>();
        for (Map.Entry<Local, ArrayObject> e : arraySizes.entrySet()) {
            final Local local0 = e.getKey();
            final ArrayObject ao = e.getValue();
            final Value t[] = new Value[ao.size];
            for (Iterator<Stmt> it = ao.putItem.iterator(); it.hasNext();) {
                Stmt p = it.next();
                if (p.st == Stmt.ST.FILL_ARRAY_DATA) {
                    Local local = (Local) p.getOp1();
                    if (local == local0) {
                        Object vs = ((Constant) p.getOp2()).value;
                        int endPos = Array.getLength(vs);
                        for (int j = 0; j < endPos; j++) {
                            t[j] = Exprs.nConstant(Array.get(vs, j));
                        }
                    }
                } else { // ASSIGN
                    ArrayExpr ae = (ArrayExpr) p.getOp1();
                    Local local = (Local) ae.getOp1();
                    if (local == local0) {
                        int idx = ((Number) ((Constant) ae.getOp2()).value).intValue();
                        Value op2 = p.getOp2();
                        if (op2.vt != Value.VT.LOCAL && op2.vt != Value.VT.CONSTANT) {
                            Local n = new Local(-1);
                            method.locals.add(n);
                            method.stmts.insertBefore(p, Stmts.nAssign(n, op2));
                            op2 = n;
                        }
                        t[idx] = op2;
                    }
                }
            }

            // for code
            // b=new Object[1]
            // b[0]=null
            // a =new Object[1]
            // a =b;
            // use(a)
            // if a is replace before b, the code
            // b=new Object[1]
            // b[0]=null
            // use(new Object[]{b})
            // the used stmt of b is outdated, so we have to search pre replaced arrays

            method.locals.remove(local0);
            method.stmts.remove(ao.init);
            for (Stmt p : ao.putItem) {
                method.stmts.remove(p);
            }
            Cfg.TravelCallBack tcb = new Cfg.TravelCallBack() {
                @Override
                public Value onAssign(Local v, AssignStmt as) {
                    return v;
                }

                @Override
                public Value onUse(Local v) {
                    if (local0 == v) {
                        FilledArrayExpr fae = Exprs.nFilledArray(ao.type, t);
                        filledArrayExprs.add(fae);
                        return fae;
                    }
                    return v;
                }
            };

            if (ao.used.size() == 1) {
                Stmt stmt = ao.used.get(0);
                if (method.stmts.contains(stmt)) { // the stmt is not removed by pre array replacement
                    Cfg.travelMod(stmt, tcb, false);
                } else {
                    int size = filledArrayExprs.size();
                    for (int i = 0; i < size; i++) {
                        Cfg.travelMod(filledArrayExprs.get(i), tcb);
                    }
                }
            } else if (ao.used.size() == 0) {
                // the array is never used, ignore
            } else {
                throw new RuntimeException(""array is used multiple times"");
            }
        }
    }",iterator
local,"{

        for (Local local : method.locals) {
            local._ls_index = -1;
        }
        final int MAX = 50;
        if (arraySizes.size() < MAX) {
            makeSureArrayUsedAfterAllElementAssigned0(method, arraySizes);
        } else {

            // this method consumes too many memory, case 'java.lang.OutOfMemoryError: Java heap space', we have to cut
            // it
            Map<Local, ArrayObject> keptInAll = new HashMap<>();
            Map<Local, ArrayObject> keptInPart = new HashMap<>();
            List<Local> arrays = new ArrayList<>(MAX);

            Iterator<Map.Entry<Local, ArrayObject>> it = arraySizes.entrySet().iterator();
            while (it.hasNext()) {
                for (int i = 0; i < MAX && it.hasNext(); i++) {
                    Map.Entry<Local, ArrayObject> e = it.next();
                    keptInPart.put(e.getKey(), e.getValue());
                    it.remove();
                    arrays.add(e.getKey());
                }
                makeSureArrayUsedAfterAllElementAssigned0(method, keptInPart);
                for (Local local : arrays) {
                    local._ls_index = -1;
                }
                arrays.clear();
                keptInAll.putAll(keptInPart);
                keptInPart.clear();
            }
            arraySizes.putAll(keptInAll);
        }

        Cfg.reIndexLocal(method);

    }",iterator
i,"{

        for (Local local : method.locals) {
            local._ls_index = -1;
        }
        final int MAX = 50;
        if (arraySizes.size() < MAX) {
            makeSureArrayUsedAfterAllElementAssigned0(method, arraySizes);
        } else {

            // this method consumes too many memory, case 'java.lang.OutOfMemoryError: Java heap space', we have to cut
            // it
            Map<Local, ArrayObject> keptInAll = new HashMap<>();
            Map<Local, ArrayObject> keptInPart = new HashMap<>();
            List<Local> arrays = new ArrayList<>(MAX);

            Iterator<Map.Entry<Local, ArrayObject>> it = arraySizes.entrySet().iterator();
            while (it.hasNext()) {
                for (int i = 0; i < MAX && it.hasNext(); i++) {
                    Map.Entry<Local, ArrayObject> e = it.next();
                    keptInPart.put(e.getKey(), e.getValue());
                    it.remove();
                    arrays.add(e.getKey());
                }
                makeSureArrayUsedAfterAllElementAssigned0(method, keptInPart);
                for (Local local : arrays) {
                    local._ls_index = -1;
                }
                arrays.clear();
                keptInAll.putAll(keptInPart);
                keptInPart.clear();
            }
            arraySizes.putAll(keptInAll);
        }

        Cfg.reIndexLocal(method);

    }",loop_control
it,"{

        for (Local local : method.locals) {
            local._ls_index = -1;
        }
        final int MAX = 50;
        if (arraySizes.size() < MAX) {
            makeSureArrayUsedAfterAllElementAssigned0(method, arraySizes);
        } else {

            // this method consumes too many memory, case 'java.lang.OutOfMemoryError: Java heap space', we have to cut
            // it
            Map<Local, ArrayObject> keptInAll = new HashMap<>();
            Map<Local, ArrayObject> keptInPart = new HashMap<>();
            List<Local> arrays = new ArrayList<>(MAX);

            Iterator<Map.Entry<Local, ArrayObject>> it = arraySizes.entrySet().iterator();
            while (it.hasNext()) {
                for (int i = 0; i < MAX && it.hasNext(); i++) {
                    Map.Entry<Local, ArrayObject> e = it.next();
                    keptInPart.put(e.getKey(), e.getValue());
                    it.remove();
                    arrays.add(e.getKey());
                }
                makeSureArrayUsedAfterAllElementAssigned0(method, keptInPart);
                for (Local local : arrays) {
                    local._ls_index = -1;
                }
                arrays.clear();
                keptInAll.putAll(keptInPart);
                keptInPart.clear();
            }
            arraySizes.putAll(keptInAll);
        }

        Cfg.reIndexLocal(method);

    }",iterator
local,"{
        int i = 0;
        for (Local local : arraySizes.keySet()) {
            local._ls_index = i++;
        }

        final int size = i;
        final List<ArrayObjectValue> values = new ArrayList<>();
        Cfg.dfs(method.stmts, new Cfg.FrameVisitor<ArrayObjectValue[]>() {

            @Override
            public ArrayObjectValue[] merge(ArrayObjectValue[] srcFrame, ArrayObjectValue[] distFrame, Stmt src,
                    Stmt dist) {
                if (distFrame == null) {
                    distFrame = new ArrayObjectValue[size];
                    for (int i = 0; i < size; i++) {
                        ArrayObjectValue arc = srcFrame[i];
                        if (arc != null) {
                            ArrayObjectValue aov = new ArrayObjectValue(arc.local);
                            values.add(aov);
                            aov.array = arc.array;
                            aov.parent = arc;
                            aov.pos = (BitSet) arc.pos.clone();
                            distFrame[i] = aov;
                        }
                    }
                } else {
                    for (int i = 0; i < size; i++) {
                        ArrayObjectValue arc = srcFrame[i];
                        ArrayObjectValue aov = distFrame[i];
                        if (arc != null && aov != null) {
                            if (aov.otherParent == null) {
                                aov.otherParent = new HashSet<>();
                            }
                            aov.otherParent.add(arc);
                        }
                    }
                }
                return distFrame;
            }

            @Override
            public ArrayObjectValue[] initFirstFrame(Stmt first) {
                return new ArrayObjectValue[size];
            }

            ArrayObjectValue tmp[] = initFirstFrame(null);
            Stmt currentStmt;

            @Override
            public ArrayObjectValue[] exec(ArrayObjectValue[] frame, Stmt stmt) {
                currentStmt = stmt;
                System.arraycopy(frame, 0, tmp, 0, size);
                if (stmt.st == Stmt.ST.FILL_ARRAY_DATA) {
                    if (stmt.getOp1().vt == Value.VT.LOCAL) {
                        Local local = (Local) stmt.getOp1();
                        if (local._ls_index >= 0) {
                            ArrayObjectValue av = tmp[local._ls_index];
                            Constant cst = (Constant) stmt.getOp2();
                            int endPos = Array.getLength(cst.value);
                            av.pos.set(0, endPos);
                        }
                    } else {
                        use(stmt.getOp1());
                    }
                } else if (stmt.st == Stmt.ST.ASSIGN && stmt.getOp1().vt == Value.VT.ARRAY) {
                    use(stmt.getOp2());
                    ArrayExpr ae = (ArrayExpr) stmt.getOp1();
                    if (ae.getOp1().vt == Value.VT.LOCAL) {
                        Local local = (Local) ae.getOp1();
                        if (local._ls_index >= 0) {
                            int index = ((Number) ((Constant) ae.getOp2()).value).intValue();
                            ArrayObjectValue av = tmp[local._ls_index];
                            av.pos.set(index);
                        } else {
                            use(ae);
                        }
                    } else {
                        use(ae);
                    }
                } else if (stmt.st == Stmt.ST.ASSIGN && stmt.getOp1().vt == Value.VT.LOCAL) {
                    Local local = (Local) stmt.getOp1();
                    use(stmt.getOp2());

                    if (local._ls_index >= 0) {
                        ArrayObjectValue aov = new ArrayObjectValue(local);
                        aov.array = arraySizes.get(local);
                        aov.pos = new BitSet();
                        values.add(aov);
                        tmp[local._ls_index] = aov;
                    }
                } else {
                    switch (stmt.et) {
                    case E0:
                        break;
                    case E1:
                        use(stmt.getOp());
                        break;
                    case E2:
                        use(stmt.getOp1());
                        use(stmt.getOp2());
                        break;
                    case En:
                        throw new RuntimeException();
                    }
                }
                return tmp;
            }

            private void use(Value v) {
                switch (v.et) {
                case E0:
                    if (v.vt == Value.VT.LOCAL) {
                        Local local = (Local) v;
                        if (local._ls_index >= 0) {
                            ArrayObjectValue aov = tmp[local._ls_index];
                            aov.array.used.add(currentStmt);
                            aov.used = true;
                        }
                    }
                    break;
                case E1:
                    use(v.getOp());
                    break;
                case E2:
                    use(v.getOp1());
                    use(v.getOp2());
                    break;
                case En:
                    for (Value op : v.getOps()) {
                        use(op);
                    }
                    break;
                }
            }
        });

        Set<ArrayObjectValue> used = markUsed(values);

        // check if ArrayObjectValue have different parent assignment
        for (ArrayObjectValue avo : used) {
            if (avo.array.used.size() > 1) {
                arraySizes.remove(avo.local);
            } else {
                if (avo.parent != null && avo.otherParent != null) {
                    // BitSet bs = avo.pos;
                    BitSet p = avo.parent.pos;
                    for (ArrayObjectValue ps : avo.otherParent) {
                        if (!p.equals(ps.pos)) {
                            arraySizes.remove(avo.local);
                            break;
                        }
                    }
                }
            }
        }
        // check for un full init array
        for (Iterator<Map.Entry<Local, ArrayObject>> it = arraySizes.entrySet().iterator(); it.hasNext();) {
            Map.Entry<Local, ArrayObject> e = it.next();
            Local local = e.getKey();
            ArrayObject arrayObject = e.getValue();
            for (Stmt use : arrayObject.used) {
                ArrayObjectValue frame[] = (ArrayObjectValue[]) use.frame;
                ArrayObjectValue aov = frame[local._ls_index];
                BitSet pos = aov.pos;
                if (pos.nextClearBit(0) < arrayObject.size || pos.nextSetBit(arrayObject.size) >= 0) {
                    it.remove();
                    break;
                }
            }
        }

        // clean up
        for (Stmt stmt : method.stmts) {
            stmt.frame = null;
        }
    }",iterator
i,"{
        int i = 0;
        for (Local local : arraySizes.keySet()) {
            local._ls_index = i++;
        }

        final int size = i;
        final List<ArrayObjectValue> values = new ArrayList<>();
        Cfg.dfs(method.stmts, new Cfg.FrameVisitor<ArrayObjectValue[]>() {

            @Override
            public ArrayObjectValue[] merge(ArrayObjectValue[] srcFrame, ArrayObjectValue[] distFrame, Stmt src,
                    Stmt dist) {
                if (distFrame == null) {
                    distFrame = new ArrayObjectValue[size];
                    for (int i = 0; i < size; i++) {
                        ArrayObjectValue arc = srcFrame[i];
                        if (arc != null) {
                            ArrayObjectValue aov = new ArrayObjectValue(arc.local);
                            values.add(aov);
                            aov.array = arc.array;
                            aov.parent = arc;
                            aov.pos = (BitSet) arc.pos.clone();
                            distFrame[i] = aov;
                        }
                    }
                } else {
                    for (int i = 0; i < size; i++) {
                        ArrayObjectValue arc = srcFrame[i];
                        ArrayObjectValue aov = distFrame[i];
                        if (arc != null && aov != null) {
                            if (aov.otherParent == null) {
                                aov.otherParent = new HashSet<>();
                            }
                            aov.otherParent.add(arc);
                        }
                    }
                }
                return distFrame;
            }

            @Override
            public ArrayObjectValue[] initFirstFrame(Stmt first) {
                return new ArrayObjectValue[size];
            }

            ArrayObjectValue tmp[] = initFirstFrame(null);
            Stmt currentStmt;

            @Override
            public ArrayObjectValue[] exec(ArrayObjectValue[] frame, Stmt stmt) {
                currentStmt = stmt;
                System.arraycopy(frame, 0, tmp, 0, size);
                if (stmt.st == Stmt.ST.FILL_ARRAY_DATA) {
                    if (stmt.getOp1().vt == Value.VT.LOCAL) {
                        Local local = (Local) stmt.getOp1();
                        if (local._ls_index >= 0) {
                            ArrayObjectValue av = tmp[local._ls_index];
                            Constant cst = (Constant) stmt.getOp2();
                            int endPos = Array.getLength(cst.value);
                            av.pos.set(0, endPos);
                        }
                    } else {
                        use(stmt.getOp1());
                    }
                } else if (stmt.st == Stmt.ST.ASSIGN && stmt.getOp1().vt == Value.VT.ARRAY) {
                    use(stmt.getOp2());
                    ArrayExpr ae = (ArrayExpr) stmt.getOp1();
                    if (ae.getOp1().vt == Value.VT.LOCAL) {
                        Local local = (Local) ae.getOp1();
                        if (local._ls_index >= 0) {
                            int index = ((Number) ((Constant) ae.getOp2()).value).intValue();
                            ArrayObjectValue av = tmp[local._ls_index];
                            av.pos.set(index);
                        } else {
                            use(ae);
                        }
                    } else {
                        use(ae);
                    }
                } else if (stmt.st == Stmt.ST.ASSIGN && stmt.getOp1().vt == Value.VT.LOCAL) {
                    Local local = (Local) stmt.getOp1();
                    use(stmt.getOp2());

                    if (local._ls_index >= 0) {
                        ArrayObjectValue aov = new ArrayObjectValue(local);
                        aov.array = arraySizes.get(local);
                        aov.pos = new BitSet();
                        values.add(aov);
                        tmp[local._ls_index] = aov;
                    }
                } else {
                    switch (stmt.et) {
                    case E0:
                        break;
                    case E1:
                        use(stmt.getOp());
                        break;
                    case E2:
                        use(stmt.getOp1());
                        use(stmt.getOp2());
                        break;
                    case En:
                        throw new RuntimeException();
                    }
                }
                return tmp;
            }

            private void use(Value v) {
                switch (v.et) {
                case E0:
                    if (v.vt == Value.VT.LOCAL) {
                        Local local = (Local) v;
                        if (local._ls_index >= 0) {
                            ArrayObjectValue aov = tmp[local._ls_index];
                            aov.array.used.add(currentStmt);
                            aov.used = true;
                        }
                    }
                    break;
                case E1:
                    use(v.getOp());
                    break;
                case E2:
                    use(v.getOp1());
                    use(v.getOp2());
                    break;
                case En:
                    for (Value op : v.getOps()) {
                        use(op);
                    }
                    break;
                }
            }
        });

        Set<ArrayObjectValue> used = markUsed(values);

        // check if ArrayObjectValue have different parent assignment
        for (ArrayObjectValue avo : used) {
            if (avo.array.used.size() > 1) {
                arraySizes.remove(avo.local);
            } else {
                if (avo.parent != null && avo.otherParent != null) {
                    // BitSet bs = avo.pos;
                    BitSet p = avo.parent.pos;
                    for (ArrayObjectValue ps : avo.otherParent) {
                        if (!p.equals(ps.pos)) {
                            arraySizes.remove(avo.local);
                            break;
                        }
                    }
                }
            }
        }
        // check for un full init array
        for (Iterator<Map.Entry<Local, ArrayObject>> it = arraySizes.entrySet().iterator(); it.hasNext();) {
            Map.Entry<Local, ArrayObject> e = it.next();
            Local local = e.getKey();
            ArrayObject arrayObject = e.getValue();
            for (Stmt use : arrayObject.used) {
                ArrayObjectValue frame[] = (ArrayObjectValue[]) use.frame;
                ArrayObjectValue aov = frame[local._ls_index];
                BitSet pos = aov.pos;
                if (pos.nextClearBit(0) < arrayObject.size || pos.nextSetBit(arrayObject.size) >= 0) {
                    it.remove();
                    break;
                }
            }
        }

        // clean up
        for (Stmt stmt : method.stmts) {
            stmt.frame = null;
        }
    }",loop_control
op,"{
        int i = 0;
        for (Local local : arraySizes.keySet()) {
            local._ls_index = i++;
        }

        final int size = i;
        final List<ArrayObjectValue> values = new ArrayList<>();
        Cfg.dfs(method.stmts, new Cfg.FrameVisitor<ArrayObjectValue[]>() {

            @Override
            public ArrayObjectValue[] merge(ArrayObjectValue[] srcFrame, ArrayObjectValue[] distFrame, Stmt src,
                    Stmt dist) {
                if (distFrame == null) {
                    distFrame = new ArrayObjectValue[size];
                    for (int i = 0; i < size; i++) {
                        ArrayObjectValue arc = srcFrame[i];
                        if (arc != null) {
                            ArrayObjectValue aov = new ArrayObjectValue(arc.local);
                            values.add(aov);
                            aov.array = arc.array;
                            aov.parent = arc;
                            aov.pos = (BitSet) arc.pos.clone();
                            distFrame[i] = aov;
                        }
                    }
                } else {
                    for (int i = 0; i < size; i++) {
                        ArrayObjectValue arc = srcFrame[i];
                        ArrayObjectValue aov = distFrame[i];
                        if (arc != null && aov != null) {
                            if (aov.otherParent == null) {
                                aov.otherParent = new HashSet<>();
                            }
                            aov.otherParent.add(arc);
                        }
                    }
                }
                return distFrame;
            }

            @Override
            public ArrayObjectValue[] initFirstFrame(Stmt first) {
                return new ArrayObjectValue[size];
            }

            ArrayObjectValue tmp[] = initFirstFrame(null);
            Stmt currentStmt;

            @Override
            public ArrayObjectValue[] exec(ArrayObjectValue[] frame, Stmt stmt) {
                currentStmt = stmt;
                System.arraycopy(frame, 0, tmp, 0, size);
                if (stmt.st == Stmt.ST.FILL_ARRAY_DATA) {
                    if (stmt.getOp1().vt == Value.VT.LOCAL) {
                        Local local = (Local) stmt.getOp1();
                        if (local._ls_index >= 0) {
                            ArrayObjectValue av = tmp[local._ls_index];
                            Constant cst = (Constant) stmt.getOp2();
                            int endPos = Array.getLength(cst.value);
                            av.pos.set(0, endPos);
                        }
                    } else {
                        use(stmt.getOp1());
                    }
                } else if (stmt.st == Stmt.ST.ASSIGN && stmt.getOp1().vt == Value.VT.ARRAY) {
                    use(stmt.getOp2());
                    ArrayExpr ae = (ArrayExpr) stmt.getOp1();
                    if (ae.getOp1().vt == Value.VT.LOCAL) {
                        Local local = (Local) ae.getOp1();
                        if (local._ls_index >= 0) {
                            int index = ((Number) ((Constant) ae.getOp2()).value).intValue();
                            ArrayObjectValue av = tmp[local._ls_index];
                            av.pos.set(index);
                        } else {
                            use(ae);
                        }
                    } else {
                        use(ae);
                    }
                } else if (stmt.st == Stmt.ST.ASSIGN && stmt.getOp1().vt == Value.VT.LOCAL) {
                    Local local = (Local) stmt.getOp1();
                    use(stmt.getOp2());

                    if (local._ls_index >= 0) {
                        ArrayObjectValue aov = new ArrayObjectValue(local);
                        aov.array = arraySizes.get(local);
                        aov.pos = new BitSet();
                        values.add(aov);
                        tmp[local._ls_index] = aov;
                    }
                } else {
                    switch (stmt.et) {
                    case E0:
                        break;
                    case E1:
                        use(stmt.getOp());
                        break;
                    case E2:
                        use(stmt.getOp1());
                        use(stmt.getOp2());
                        break;
                    case En:
                        throw new RuntimeException();
                    }
                }
                return tmp;
            }

            private void use(Value v) {
                switch (v.et) {
                case E0:
                    if (v.vt == Value.VT.LOCAL) {
                        Local local = (Local) v;
                        if (local._ls_index >= 0) {
                            ArrayObjectValue aov = tmp[local._ls_index];
                            aov.array.used.add(currentStmt);
                            aov.used = true;
                        }
                    }
                    break;
                case E1:
                    use(v.getOp());
                    break;
                case E2:
                    use(v.getOp1());
                    use(v.getOp2());
                    break;
                case En:
                    for (Value op : v.getOps()) {
                        use(op);
                    }
                    break;
                }
            }
        });

        Set<ArrayObjectValue> used = markUsed(values);

        // check if ArrayObjectValue have different parent assignment
        for (ArrayObjectValue avo : used) {
            if (avo.array.used.size() > 1) {
                arraySizes.remove(avo.local);
            } else {
                if (avo.parent != null && avo.otherParent != null) {
                    // BitSet bs = avo.pos;
                    BitSet p = avo.parent.pos;
                    for (ArrayObjectValue ps : avo.otherParent) {
                        if (!p.equals(ps.pos)) {
                            arraySizes.remove(avo.local);
                            break;
                        }
                    }
                }
            }
        }
        // check for un full init array
        for (Iterator<Map.Entry<Local, ArrayObject>> it = arraySizes.entrySet().iterator(); it.hasNext();) {
            Map.Entry<Local, ArrayObject> e = it.next();
            Local local = e.getKey();
            ArrayObject arrayObject = e.getValue();
            for (Stmt use : arrayObject.used) {
                ArrayObjectValue frame[] = (ArrayObjectValue[]) use.frame;
                ArrayObjectValue aov = frame[local._ls_index];
                BitSet pos = aov.pos;
                if (pos.nextClearBit(0) < arrayObject.size || pos.nextSetBit(arrayObject.size) >= 0) {
                    it.remove();
                    break;
                }
            }
        }

        // clean up
        for (Stmt stmt : method.stmts) {
            stmt.frame = null;
        }
    }",iterator
avo,"{
        int i = 0;
        for (Local local : arraySizes.keySet()) {
            local._ls_index = i++;
        }

        final int size = i;
        final List<ArrayObjectValue> values = new ArrayList<>();
        Cfg.dfs(method.stmts, new Cfg.FrameVisitor<ArrayObjectValue[]>() {

            @Override
            public ArrayObjectValue[] merge(ArrayObjectValue[] srcFrame, ArrayObjectValue[] distFrame, Stmt src,
                    Stmt dist) {
                if (distFrame == null) {
                    distFrame = new ArrayObjectValue[size];
                    for (int i = 0; i < size; i++) {
                        ArrayObjectValue arc = srcFrame[i];
                        if (arc != null) {
                            ArrayObjectValue aov = new ArrayObjectValue(arc.local);
                            values.add(aov);
                            aov.array = arc.array;
                            aov.parent = arc;
                            aov.pos = (BitSet) arc.pos.clone();
                            distFrame[i] = aov;
                        }
                    }
                } else {
                    for (int i = 0; i < size; i++) {
                        ArrayObjectValue arc = srcFrame[i];
                        ArrayObjectValue aov = distFrame[i];
                        if (arc != null && aov != null) {
                            if (aov.otherParent == null) {
                                aov.otherParent = new HashSet<>();
                            }
                            aov.otherParent.add(arc);
                        }
                    }
                }
                return distFrame;
            }

            @Override
            public ArrayObjectValue[] initFirstFrame(Stmt first) {
                return new ArrayObjectValue[size];
            }

            ArrayObjectValue tmp[] = initFirstFrame(null);
            Stmt currentStmt;

            @Override
            public ArrayObjectValue[] exec(ArrayObjectValue[] frame, Stmt stmt) {
                currentStmt = stmt;
                System.arraycopy(frame, 0, tmp, 0, size);
                if (stmt.st == Stmt.ST.FILL_ARRAY_DATA) {
                    if (stmt.getOp1().vt == Value.VT.LOCAL) {
                        Local local = (Local) stmt.getOp1();
                        if (local._ls_index >= 0) {
                            ArrayObjectValue av = tmp[local._ls_index];
                            Constant cst = (Constant) stmt.getOp2();
                            int endPos = Array.getLength(cst.value);
                            av.pos.set(0, endPos);
                        }
                    } else {
                        use(stmt.getOp1());
                    }
                } else if (stmt.st == Stmt.ST.ASSIGN && stmt.getOp1().vt == Value.VT.ARRAY) {
                    use(stmt.getOp2());
                    ArrayExpr ae = (ArrayExpr) stmt.getOp1();
                    if (ae.getOp1().vt == Value.VT.LOCAL) {
                        Local local = (Local) ae.getOp1();
                        if (local._ls_index >= 0) {
                            int index = ((Number) ((Constant) ae.getOp2()).value).intValue();
                            ArrayObjectValue av = tmp[local._ls_index];
                            av.pos.set(index);
                        } else {
                            use(ae);
                        }
                    } else {
                        use(ae);
                    }
                } else if (stmt.st == Stmt.ST.ASSIGN && stmt.getOp1().vt == Value.VT.LOCAL) {
                    Local local = (Local) stmt.getOp1();
                    use(stmt.getOp2());

                    if (local._ls_index >= 0) {
                        ArrayObjectValue aov = new ArrayObjectValue(local);
                        aov.array = arraySizes.get(local);
                        aov.pos = new BitSet();
                        values.add(aov);
                        tmp[local._ls_index] = aov;
                    }
                } else {
                    switch (stmt.et) {
                    case E0:
                        break;
                    case E1:
                        use(stmt.getOp());
                        break;
                    case E2:
                        use(stmt.getOp1());
                        use(stmt.getOp2());
                        break;
                    case En:
                        throw new RuntimeException();
                    }
                }
                return tmp;
            }

            private void use(Value v) {
                switch (v.et) {
                case E0:
                    if (v.vt == Value.VT.LOCAL) {
                        Local local = (Local) v;
                        if (local._ls_index >= 0) {
                            ArrayObjectValue aov = tmp[local._ls_index];
                            aov.array.used.add(currentStmt);
                            aov.used = true;
                        }
                    }
                    break;
                case E1:
                    use(v.getOp());
                    break;
                case E2:
                    use(v.getOp1());
                    use(v.getOp2());
                    break;
                case En:
                    for (Value op : v.getOps()) {
                        use(op);
                    }
                    break;
                }
            }
        });

        Set<ArrayObjectValue> used = markUsed(values);

        // check if ArrayObjectValue have different parent assignment
        for (ArrayObjectValue avo : used) {
            if (avo.array.used.size() > 1) {
                arraySizes.remove(avo.local);
            } else {
                if (avo.parent != null && avo.otherParent != null) {
                    // BitSet bs = avo.pos;
                    BitSet p = avo.parent.pos;
                    for (ArrayObjectValue ps : avo.otherParent) {
                        if (!p.equals(ps.pos)) {
                            arraySizes.remove(avo.local);
                            break;
                        }
                    }
                }
            }
        }
        // check for un full init array
        for (Iterator<Map.Entry<Local, ArrayObject>> it = arraySizes.entrySet().iterator(); it.hasNext();) {
            Map.Entry<Local, ArrayObject> e = it.next();
            Local local = e.getKey();
            ArrayObject arrayObject = e.getValue();
            for (Stmt use : arrayObject.used) {
                ArrayObjectValue frame[] = (ArrayObjectValue[]) use.frame;
                ArrayObjectValue aov = frame[local._ls_index];
                BitSet pos = aov.pos;
                if (pos.nextClearBit(0) < arrayObject.size || pos.nextSetBit(arrayObject.size) >= 0) {
                    it.remove();
                    break;
                }
            }
        }

        // clean up
        for (Stmt stmt : method.stmts) {
            stmt.frame = null;
        }
    }",iterator
ps,"{
        int i = 0;
        for (Local local : arraySizes.keySet()) {
            local._ls_index = i++;
        }

        final int size = i;
        final List<ArrayObjectValue> values = new ArrayList<>();
        Cfg.dfs(method.stmts, new Cfg.FrameVisitor<ArrayObjectValue[]>() {

            @Override
            public ArrayObjectValue[] merge(ArrayObjectValue[] srcFrame, ArrayObjectValue[] distFrame, Stmt src,
                    Stmt dist) {
                if (distFrame == null) {
                    distFrame = new ArrayObjectValue[size];
                    for (int i = 0; i < size; i++) {
                        ArrayObjectValue arc = srcFrame[i];
                        if (arc != null) {
                            ArrayObjectValue aov = new ArrayObjectValue(arc.local);
                            values.add(aov);
                            aov.array = arc.array;
                            aov.parent = arc;
                            aov.pos = (BitSet) arc.pos.clone();
                            distFrame[i] = aov;
                        }
                    }
                } else {
                    for (int i = 0; i < size; i++) {
                        ArrayObjectValue arc = srcFrame[i];
                        ArrayObjectValue aov = distFrame[i];
                        if (arc != null && aov != null) {
                            if (aov.otherParent == null) {
                                aov.otherParent = new HashSet<>();
                            }
                            aov.otherParent.add(arc);
                        }
                    }
                }
                return distFrame;
            }

            @Override
            public ArrayObjectValue[] initFirstFrame(Stmt first) {
                return new ArrayObjectValue[size];
            }

            ArrayObjectValue tmp[] = initFirstFrame(null);
            Stmt currentStmt;

            @Override
            public ArrayObjectValue[] exec(ArrayObjectValue[] frame, Stmt stmt) {
                currentStmt = stmt;
                System.arraycopy(frame, 0, tmp, 0, size);
                if (stmt.st == Stmt.ST.FILL_ARRAY_DATA) {
                    if (stmt.getOp1().vt == Value.VT.LOCAL) {
                        Local local = (Local) stmt.getOp1();
                        if (local._ls_index >= 0) {
                            ArrayObjectValue av = tmp[local._ls_index];
                            Constant cst = (Constant) stmt.getOp2();
                            int endPos = Array.getLength(cst.value);
                            av.pos.set(0, endPos);
                        }
                    } else {
                        use(stmt.getOp1());
                    }
                } else if (stmt.st == Stmt.ST.ASSIGN && stmt.getOp1().vt == Value.VT.ARRAY) {
                    use(stmt.getOp2());
                    ArrayExpr ae = (ArrayExpr) stmt.getOp1();
                    if (ae.getOp1().vt == Value.VT.LOCAL) {
                        Local local = (Local) ae.getOp1();
                        if (local._ls_index >= 0) {
                            int index = ((Number) ((Constant) ae.getOp2()).value).intValue();
                            ArrayObjectValue av = tmp[local._ls_index];
                            av.pos.set(index);
                        } else {
                            use(ae);
                        }
                    } else {
                        use(ae);
                    }
                } else if (stmt.st == Stmt.ST.ASSIGN && stmt.getOp1().vt == Value.VT.LOCAL) {
                    Local local = (Local) stmt.getOp1();
                    use(stmt.getOp2());

                    if (local._ls_index >= 0) {
                        ArrayObjectValue aov = new ArrayObjectValue(local);
                        aov.array = arraySizes.get(local);
                        aov.pos = new BitSet();
                        values.add(aov);
                        tmp[local._ls_index] = aov;
                    }
                } else {
                    switch (stmt.et) {
                    case E0:
                        break;
                    case E1:
                        use(stmt.getOp());
                        break;
                    case E2:
                        use(stmt.getOp1());
                        use(stmt.getOp2());
                        break;
                    case En:
                        throw new RuntimeException();
                    }
                }
                return tmp;
            }

            private void use(Value v) {
                switch (v.et) {
                case E0:
                    if (v.vt == Value.VT.LOCAL) {
                        Local local = (Local) v;
                        if (local._ls_index >= 0) {
                            ArrayObjectValue aov = tmp[local._ls_index];
                            aov.array.used.add(currentStmt);
                            aov.used = true;
                        }
                    }
                    break;
                case E1:
                    use(v.getOp());
                    break;
                case E2:
                    use(v.getOp1());
                    use(v.getOp2());
                    break;
                case En:
                    for (Value op : v.getOps()) {
                        use(op);
                    }
                    break;
                }
            }
        });

        Set<ArrayObjectValue> used = markUsed(values);

        // check if ArrayObjectValue have different parent assignment
        for (ArrayObjectValue avo : used) {
            if (avo.array.used.size() > 1) {
                arraySizes.remove(avo.local);
            } else {
                if (avo.parent != null && avo.otherParent != null) {
                    // BitSet bs = avo.pos;
                    BitSet p = avo.parent.pos;
                    for (ArrayObjectValue ps : avo.otherParent) {
                        if (!p.equals(ps.pos)) {
                            arraySizes.remove(avo.local);
                            break;
                        }
                    }
                }
            }
        }
        // check for un full init array
        for (Iterator<Map.Entry<Local, ArrayObject>> it = arraySizes.entrySet().iterator(); it.hasNext();) {
            Map.Entry<Local, ArrayObject> e = it.next();
            Local local = e.getKey();
            ArrayObject arrayObject = e.getValue();
            for (Stmt use : arrayObject.used) {
                ArrayObjectValue frame[] = (ArrayObjectValue[]) use.frame;
                ArrayObjectValue aov = frame[local._ls_index];
                BitSet pos = aov.pos;
                if (pos.nextClearBit(0) < arrayObject.size || pos.nextSetBit(arrayObject.size) >= 0) {
                    it.remove();
                    break;
                }
            }
        }

        // clean up
        for (Stmt stmt : method.stmts) {
            stmt.frame = null;
        }
    }",iterator
it,"{
        int i = 0;
        for (Local local : arraySizes.keySet()) {
            local._ls_index = i++;
        }

        final int size = i;
        final List<ArrayObjectValue> values = new ArrayList<>();
        Cfg.dfs(method.stmts, new Cfg.FrameVisitor<ArrayObjectValue[]>() {

            @Override
            public ArrayObjectValue[] merge(ArrayObjectValue[] srcFrame, ArrayObjectValue[] distFrame, Stmt src,
                    Stmt dist) {
                if (distFrame == null) {
                    distFrame = new ArrayObjectValue[size];
                    for (int i = 0; i < size; i++) {
                        ArrayObjectValue arc = srcFrame[i];
                        if (arc != null) {
                            ArrayObjectValue aov = new ArrayObjectValue(arc.local);
                            values.add(aov);
                            aov.array = arc.array;
                            aov.parent = arc;
                            aov.pos = (BitSet) arc.pos.clone();
                            distFrame[i] = aov;
                        }
                    }
                } else {
                    for (int i = 0; i < size; i++) {
                        ArrayObjectValue arc = srcFrame[i];
                        ArrayObjectValue aov = distFrame[i];
                        if (arc != null && aov != null) {
                            if (aov.otherParent == null) {
                                aov.otherParent = new HashSet<>();
                            }
                            aov.otherParent.add(arc);
                        }
                    }
                }
                return distFrame;
            }

            @Override
            public ArrayObjectValue[] initFirstFrame(Stmt first) {
                return new ArrayObjectValue[size];
            }

            ArrayObjectValue tmp[] = initFirstFrame(null);
            Stmt currentStmt;

            @Override
            public ArrayObjectValue[] exec(ArrayObjectValue[] frame, Stmt stmt) {
                currentStmt = stmt;
                System.arraycopy(frame, 0, tmp, 0, size);
                if (stmt.st == Stmt.ST.FILL_ARRAY_DATA) {
                    if (stmt.getOp1().vt == Value.VT.LOCAL) {
                        Local local = (Local) stmt.getOp1();
                        if (local._ls_index >= 0) {
                            ArrayObjectValue av = tmp[local._ls_index];
                            Constant cst = (Constant) stmt.getOp2();
                            int endPos = Array.getLength(cst.value);
                            av.pos.set(0, endPos);
                        }
                    } else {
                        use(stmt.getOp1());
                    }
                } else if (stmt.st == Stmt.ST.ASSIGN && stmt.getOp1().vt == Value.VT.ARRAY) {
                    use(stmt.getOp2());
                    ArrayExpr ae = (ArrayExpr) stmt.getOp1();
                    if (ae.getOp1().vt == Value.VT.LOCAL) {
                        Local local = (Local) ae.getOp1();
                        if (local._ls_index >= 0) {
                            int index = ((Number) ((Constant) ae.getOp2()).value).intValue();
                            ArrayObjectValue av = tmp[local._ls_index];
                            av.pos.set(index);
                        } else {
                            use(ae);
                        }
                    } else {
                        use(ae);
                    }
                } else if (stmt.st == Stmt.ST.ASSIGN && stmt.getOp1().vt == Value.VT.LOCAL) {
                    Local local = (Local) stmt.getOp1();
                    use(stmt.getOp2());

                    if (local._ls_index >= 0) {
                        ArrayObjectValue aov = new ArrayObjectValue(local);
                        aov.array = arraySizes.get(local);
                        aov.pos = new BitSet();
                        values.add(aov);
                        tmp[local._ls_index] = aov;
                    }
                } else {
                    switch (stmt.et) {
                    case E0:
                        break;
                    case E1:
                        use(stmt.getOp());
                        break;
                    case E2:
                        use(stmt.getOp1());
                        use(stmt.getOp2());
                        break;
                    case En:
                        throw new RuntimeException();
                    }
                }
                return tmp;
            }

            private void use(Value v) {
                switch (v.et) {
                case E0:
                    if (v.vt == Value.VT.LOCAL) {
                        Local local = (Local) v;
                        if (local._ls_index >= 0) {
                            ArrayObjectValue aov = tmp[local._ls_index];
                            aov.array.used.add(currentStmt);
                            aov.used = true;
                        }
                    }
                    break;
                case E1:
                    use(v.getOp());
                    break;
                case E2:
                    use(v.getOp1());
                    use(v.getOp2());
                    break;
                case En:
                    for (Value op : v.getOps()) {
                        use(op);
                    }
                    break;
                }
            }
        });

        Set<ArrayObjectValue> used = markUsed(values);

        // check if ArrayObjectValue have different parent assignment
        for (ArrayObjectValue avo : used) {
            if (avo.array.used.size() > 1) {
                arraySizes.remove(avo.local);
            } else {
                if (avo.parent != null && avo.otherParent != null) {
                    // BitSet bs = avo.pos;
                    BitSet p = avo.parent.pos;
                    for (ArrayObjectValue ps : avo.otherParent) {
                        if (!p.equals(ps.pos)) {
                            arraySizes.remove(avo.local);
                            break;
                        }
                    }
                }
            }
        }
        // check for un full init array
        for (Iterator<Map.Entry<Local, ArrayObject>> it = arraySizes.entrySet().iterator(); it.hasNext();) {
            Map.Entry<Local, ArrayObject> e = it.next();
            Local local = e.getKey();
            ArrayObject arrayObject = e.getValue();
            for (Stmt use : arrayObject.used) {
                ArrayObjectValue frame[] = (ArrayObjectValue[]) use.frame;
                ArrayObjectValue aov = frame[local._ls_index];
                BitSet pos = aov.pos;
                if (pos.nextClearBit(0) < arrayObject.size || pos.nextSetBit(arrayObject.size) >= 0) {
                    it.remove();
                    break;
                }
            }
        }

        // clean up
        for (Stmt stmt : method.stmts) {
            stmt.frame = null;
        }
    }",iterator
use,"{
        int i = 0;
        for (Local local : arraySizes.keySet()) {
            local._ls_index = i++;
        }

        final int size = i;
        final List<ArrayObjectValue> values = new ArrayList<>();
        Cfg.dfs(method.stmts, new Cfg.FrameVisitor<ArrayObjectValue[]>() {

            @Override
            public ArrayObjectValue[] merge(ArrayObjectValue[] srcFrame, ArrayObjectValue[] distFrame, Stmt src,
                    Stmt dist) {
                if (distFrame == null) {
                    distFrame = new ArrayObjectValue[size];
                    for (int i = 0; i < size; i++) {
                        ArrayObjectValue arc = srcFrame[i];
                        if (arc != null) {
                            ArrayObjectValue aov = new ArrayObjectValue(arc.local);
                            values.add(aov);
                            aov.array = arc.array;
                            aov.parent = arc;
                            aov.pos = (BitSet) arc.pos.clone();
                            distFrame[i] = aov;
                        }
                    }
                } else {
                    for (int i = 0; i < size; i++) {
                        ArrayObjectValue arc = srcFrame[i];
                        ArrayObjectValue aov = distFrame[i];
                        if (arc != null && aov != null) {
                            if (aov.otherParent == null) {
                                aov.otherParent = new HashSet<>();
                            }
                            aov.otherParent.add(arc);
                        }
                    }
                }
                return distFrame;
            }

            @Override
            public ArrayObjectValue[] initFirstFrame(Stmt first) {
                return new ArrayObjectValue[size];
            }

            ArrayObjectValue tmp[] = initFirstFrame(null);
            Stmt currentStmt;

            @Override
            public ArrayObjectValue[] exec(ArrayObjectValue[] frame, Stmt stmt) {
                currentStmt = stmt;
                System.arraycopy(frame, 0, tmp, 0, size);
                if (stmt.st == Stmt.ST.FILL_ARRAY_DATA) {
                    if (stmt.getOp1().vt == Value.VT.LOCAL) {
                        Local local = (Local) stmt.getOp1();
                        if (local._ls_index >= 0) {
                            ArrayObjectValue av = tmp[local._ls_index];
                            Constant cst = (Constant) stmt.getOp2();
                            int endPos = Array.getLength(cst.value);
                            av.pos.set(0, endPos);
                        }
                    } else {
                        use(stmt.getOp1());
                    }
                } else if (stmt.st == Stmt.ST.ASSIGN && stmt.getOp1().vt == Value.VT.ARRAY) {
                    use(stmt.getOp2());
                    ArrayExpr ae = (ArrayExpr) stmt.getOp1();
                    if (ae.getOp1().vt == Value.VT.LOCAL) {
                        Local local = (Local) ae.getOp1();
                        if (local._ls_index >= 0) {
                            int index = ((Number) ((Constant) ae.getOp2()).value).intValue();
                            ArrayObjectValue av = tmp[local._ls_index];
                            av.pos.set(index);
                        } else {
                            use(ae);
                        }
                    } else {
                        use(ae);
                    }
                } else if (stmt.st == Stmt.ST.ASSIGN && stmt.getOp1().vt == Value.VT.LOCAL) {
                    Local local = (Local) stmt.getOp1();
                    use(stmt.getOp2());

                    if (local._ls_index >= 0) {
                        ArrayObjectValue aov = new ArrayObjectValue(local);
                        aov.array = arraySizes.get(local);
                        aov.pos = new BitSet();
                        values.add(aov);
                        tmp[local._ls_index] = aov;
                    }
                } else {
                    switch (stmt.et) {
                    case E0:
                        break;
                    case E1:
                        use(stmt.getOp());
                        break;
                    case E2:
                        use(stmt.getOp1());
                        use(stmt.getOp2());
                        break;
                    case En:
                        throw new RuntimeException();
                    }
                }
                return tmp;
            }

            private void use(Value v) {
                switch (v.et) {
                case E0:
                    if (v.vt == Value.VT.LOCAL) {
                        Local local = (Local) v;
                        if (local._ls_index >= 0) {
                            ArrayObjectValue aov = tmp[local._ls_index];
                            aov.array.used.add(currentStmt);
                            aov.used = true;
                        }
                    }
                    break;
                case E1:
                    use(v.getOp());
                    break;
                case E2:
                    use(v.getOp1());
                    use(v.getOp2());
                    break;
                case En:
                    for (Value op : v.getOps()) {
                        use(op);
                    }
                    break;
                }
            }
        });

        Set<ArrayObjectValue> used = markUsed(values);

        // check if ArrayObjectValue have different parent assignment
        for (ArrayObjectValue avo : used) {
            if (avo.array.used.size() > 1) {
                arraySizes.remove(avo.local);
            } else {
                if (avo.parent != null && avo.otherParent != null) {
                    // BitSet bs = avo.pos;
                    BitSet p = avo.parent.pos;
                    for (ArrayObjectValue ps : avo.otherParent) {
                        if (!p.equals(ps.pos)) {
                            arraySizes.remove(avo.local);
                            break;
                        }
                    }
                }
            }
        }
        // check for un full init array
        for (Iterator<Map.Entry<Local, ArrayObject>> it = arraySizes.entrySet().iterator(); it.hasNext();) {
            Map.Entry<Local, ArrayObject> e = it.next();
            Local local = e.getKey();
            ArrayObject arrayObject = e.getValue();
            for (Stmt use : arrayObject.used) {
                ArrayObjectValue frame[] = (ArrayObjectValue[]) use.frame;
                ArrayObjectValue aov = frame[local._ls_index];
                BitSet pos = aov.pos;
                if (pos.nextClearBit(0) < arrayObject.size || pos.nextSetBit(arrayObject.size) >= 0) {
                    it.remove();
                    break;
                }
            }
        }

        // clean up
        for (Stmt stmt : method.stmts) {
            stmt.frame = null;
        }
    }",iterator
q,"{
        Set<ArrayObjectValue> used = new HashSet<>(values.size() / 2);
        Queue<ArrayObjectValue> q = new UniqueQueue<>();
        q.addAll(values);
        values.clear();
        while (!q.isEmpty()) {
            ArrayObjectValue v = q.poll();
            if (v.used) {
                if (used.contains(v)) {
                    continue;
                }
                used.add(v);
                {
                    ArrayObjectValue p = v.parent;
                    if (p != null) {
                        if (!p.used) {
                            p.used = true;
                            q.add(p);
                        }
                    }
                }
                if (v.otherParent != null) {
                    for (ArrayObjectValue p : v.otherParent) {
                        if (!p.used) {
                            p.used = true;
                            q.add(p);
                        }
                    }
                }
            }
        }

        return used;
    }",maybe_loop_control
p,"{
        Set<ArrayObjectValue> used = new HashSet<>(values.size() / 2);
        Queue<ArrayObjectValue> q = new UniqueQueue<>();
        q.addAll(values);
        values.clear();
        while (!q.isEmpty()) {
            ArrayObjectValue v = q.poll();
            if (v.used) {
                if (used.contains(v)) {
                    continue;
                }
                used.add(v);
                {
                    ArrayObjectValue p = v.parent;
                    if (p != null) {
                        if (!p.used) {
                            p.used = true;
                            q.add(p);
                        }
                    }
                }
                if (v.otherParent != null) {
                    for (ArrayObjectValue p : v.otherParent) {
                        if (!p.used) {
                            p.used = true;
                            q.add(p);
                        }
                    }
                }
            }
        }

        return used;
    }",iterator
it,"{
        BitSet pos = new BitSet();
        for (Iterator<Map.Entry<Local, ArrayObject>> it = arraySizes.entrySet().iterator(); it.hasNext();) {
            Map.Entry<Local, ArrayObject> e = it.next();
            ArrayObject arrayObject = e.getValue();
            boolean needRemove = false;
            for (Stmt p : arrayObject.putItem) {
                if (p.st == Stmt.ST.FILL_ARRAY_DATA) {
                    int endPos = Array.getLength(((Constant) p.getOp2()).value);
                    int next = pos.nextSetBit(0);
                    if (next < 0 || next >= endPos) {// not set in range
                        pos.set(0, endPos);
                    } else {// setted in range
                        needRemove = true;
                        break;
                    }
                } else { // ASSIGN
                    ArrayExpr ae = (ArrayExpr) p.getOp1();
                    int idx = ((Number) ((Constant) ae.getOp2()).value).intValue();
                    if (!pos.get(idx)) {
                        pos.set(idx);
                    } else {
                        needRemove = true;
                        break;
                    }
                }
            }
            if (needRemove || pos.nextClearBit(0) < arrayObject.size || pos.nextSetBit(arrayObject.size) >= 0) {
                it.remove();
            }
            pos.clear();
        }
    }",iterator
p,"{
        BitSet pos = new BitSet();
        for (Iterator<Map.Entry<Local, ArrayObject>> it = arraySizes.entrySet().iterator(); it.hasNext();) {
            Map.Entry<Local, ArrayObject> e = it.next();
            ArrayObject arrayObject = e.getValue();
            boolean needRemove = false;
            for (Stmt p : arrayObject.putItem) {
                if (p.st == Stmt.ST.FILL_ARRAY_DATA) {
                    int endPos = Array.getLength(((Constant) p.getOp2()).value);
                    int next = pos.nextSetBit(0);
                    if (next < 0 || next >= endPos) {// not set in range
                        pos.set(0, endPos);
                    } else {// setted in range
                        needRemove = true;
                        break;
                    }
                } else { // ASSIGN
                    ArrayExpr ae = (ArrayExpr) p.getOp1();
                    int idx = ((Number) ((Constant) ae.getOp2()).value).intValue();
                    if (!pos.get(idx)) {
                        pos.set(idx);
                    } else {
                        needRemove = true;
                        break;
                    }
                }
            }
            if (needRemove || pos.nextClearBit(0) < arrayObject.size || pos.nextSetBit(arrayObject.size) >= 0) {
                it.remove();
            }
            pos.clear();
        }
    }",iterator
labelStmt,"{

        final Map<Local, ArrayObject> arraySizes = new HashMap<>();
        if (method.locals.size() == 0) {
            return arraySizes;
        }
        Cfg.createCFG(method);
        Cfg.dfsVisit(method, new Cfg.DfsVisitor() {
            @Override
            public void onVisit(Stmt p) {
                if (p.st == Stmt.ST.ASSIGN) {
                    if (p.getOp2().vt == Value.VT.NEW_ARRAY && p.getOp1().vt == Value.VT.LOCAL) {
                        TypeExpr ae = (TypeExpr) p.getOp2();
                        if (ae.getOp().vt == Value.VT.CONSTANT) {
                            int size = ((Number) ((Constant) ae.getOp()).value).intValue();

                            // https://bitbucket.org/pxb1988/dex2jar/issues/2/decompiler-error
                            // the following code may used in a java
                            // try{
                            //   new int[-1];
                            // } catch(Exception e) {
                            //   ...
                            // }
                            if (size >= 0) {
                                arraySizes.put((Local) p.getOp1(), new ArrayObject(size, ae.type, (AssignStmt) p));
                            }
                        }
                    } else if (p.getOp1().vt == Value.VT.ARRAY) {
                        ArrayExpr ae = (ArrayExpr) p.getOp1();
                        if (ae.getOp1().vt == Value.VT.LOCAL) {
                            Local local = (Local) ae.getOp1();
                            ArrayObject arrayObject = arraySizes.get(local);
                            if (arrayObject != null) {
                                if (ae.getOp2().vt == Value.VT.CONSTANT) {
                                    arrayObject.putItem.add(p);
                                } else {
                                    arraySizes.remove(local);
                                }
                            }
                        }
                    }
                } else if (p.st == Stmt.ST.FILL_ARRAY_DATA) {
                    if (p.getOp1().vt == Value.VT.LOCAL) {
                        Local local = (Local) p.getOp1();
                        ArrayObject arrayObject = arraySizes.get(local);
                        if (arrayObject != null) {
                            arrayObject.putItem.add(p);
                        }
                    }
                }
            }
        });
        if (arraySizes.size() > 0) {
            Set<Local> set = new HashSet<Local>();
            if (method.phiLabels != null) {
                for (LabelStmt labelStmt : method.phiLabels) {
                    if (labelStmt.phis != null) {
                        for (AssignStmt as : labelStmt.phis) {
                            set.add((Local) as.getOp1());
                            for (Value v : as.getOp2().getOps()) {
                                set.add((Local) v);
                            }
                        }
                    }
                }
            }
            if (set.size() > 0) {
                for (Local local : set) {
                    arraySizes.remove(local);
                }
            }
        }
        return arraySizes;
    }",iterator
as,"{

        final Map<Local, ArrayObject> arraySizes = new HashMap<>();
        if (method.locals.size() == 0) {
            return arraySizes;
        }
        Cfg.createCFG(method);
        Cfg.dfsVisit(method, new Cfg.DfsVisitor() {
            @Override
            public void onVisit(Stmt p) {
                if (p.st == Stmt.ST.ASSIGN) {
                    if (p.getOp2().vt == Value.VT.NEW_ARRAY && p.getOp1().vt == Value.VT.LOCAL) {
                        TypeExpr ae = (TypeExpr) p.getOp2();
                        if (ae.getOp().vt == Value.VT.CONSTANT) {
                            int size = ((Number) ((Constant) ae.getOp()).value).intValue();

                            // https://bitbucket.org/pxb1988/dex2jar/issues/2/decompiler-error
                            // the following code may used in a java
                            // try{
                            //   new int[-1];
                            // } catch(Exception e) {
                            //   ...
                            // }
                            if (size >= 0) {
                                arraySizes.put((Local) p.getOp1(), new ArrayObject(size, ae.type, (AssignStmt) p));
                            }
                        }
                    } else if (p.getOp1().vt == Value.VT.ARRAY) {
                        ArrayExpr ae = (ArrayExpr) p.getOp1();
                        if (ae.getOp1().vt == Value.VT.LOCAL) {
                            Local local = (Local) ae.getOp1();
                            ArrayObject arrayObject = arraySizes.get(local);
                            if (arrayObject != null) {
                                if (ae.getOp2().vt == Value.VT.CONSTANT) {
                                    arrayObject.putItem.add(p);
                                } else {
                                    arraySizes.remove(local);
                                }
                            }
                        }
                    }
                } else if (p.st == Stmt.ST.FILL_ARRAY_DATA) {
                    if (p.getOp1().vt == Value.VT.LOCAL) {
                        Local local = (Local) p.getOp1();
                        ArrayObject arrayObject = arraySizes.get(local);
                        if (arrayObject != null) {
                            arrayObject.putItem.add(p);
                        }
                    }
                }
            }
        });
        if (arraySizes.size() > 0) {
            Set<Local> set = new HashSet<Local>();
            if (method.phiLabels != null) {
                for (LabelStmt labelStmt : method.phiLabels) {
                    if (labelStmt.phis != null) {
                        for (AssignStmt as : labelStmt.phis) {
                            set.add((Local) as.getOp1());
                            for (Value v : as.getOp2().getOps()) {
                                set.add((Local) v);
                            }
                        }
                    }
                }
            }
            if (set.size() > 0) {
                for (Local local : set) {
                    arraySizes.remove(local);
                }
            }
        }
        return arraySizes;
    }",iterator
v,"{

        final Map<Local, ArrayObject> arraySizes = new HashMap<>();
        if (method.locals.size() == 0) {
            return arraySizes;
        }
        Cfg.createCFG(method);
        Cfg.dfsVisit(method, new Cfg.DfsVisitor() {
            @Override
            public void onVisit(Stmt p) {
                if (p.st == Stmt.ST.ASSIGN) {
                    if (p.getOp2().vt == Value.VT.NEW_ARRAY && p.getOp1().vt == Value.VT.LOCAL) {
                        TypeExpr ae = (TypeExpr) p.getOp2();
                        if (ae.getOp().vt == Value.VT.CONSTANT) {
                            int size = ((Number) ((Constant) ae.getOp()).value).intValue();

                            // https://bitbucket.org/pxb1988/dex2jar/issues/2/decompiler-error
                            // the following code may used in a java
                            // try{
                            //   new int[-1];
                            // } catch(Exception e) {
                            //   ...
                            // }
                            if (size >= 0) {
                                arraySizes.put((Local) p.getOp1(), new ArrayObject(size, ae.type, (AssignStmt) p));
                            }
                        }
                    } else if (p.getOp1().vt == Value.VT.ARRAY) {
                        ArrayExpr ae = (ArrayExpr) p.getOp1();
                        if (ae.getOp1().vt == Value.VT.LOCAL) {
                            Local local = (Local) ae.getOp1();
                            ArrayObject arrayObject = arraySizes.get(local);
                            if (arrayObject != null) {
                                if (ae.getOp2().vt == Value.VT.CONSTANT) {
                                    arrayObject.putItem.add(p);
                                } else {
                                    arraySizes.remove(local);
                                }
                            }
                        }
                    }
                } else if (p.st == Stmt.ST.FILL_ARRAY_DATA) {
                    if (p.getOp1().vt == Value.VT.LOCAL) {
                        Local local = (Local) p.getOp1();
                        ArrayObject arrayObject = arraySizes.get(local);
                        if (arrayObject != null) {
                            arrayObject.putItem.add(p);
                        }
                    }
                }
            }
        });
        if (arraySizes.size() > 0) {
            Set<Local> set = new HashSet<Local>();
            if (method.phiLabels != null) {
                for (LabelStmt labelStmt : method.phiLabels) {
                    if (labelStmt.phis != null) {
                        for (AssignStmt as : labelStmt.phis) {
                            set.add((Local) as.getOp1());
                            for (Value v : as.getOp2().getOps()) {
                                set.add((Local) v);
                            }
                        }
                    }
                }
            }
            if (set.size() > 0) {
                for (Local local : set) {
                    arraySizes.remove(local);
                }
            }
        }
        return arraySizes;
    }",iterator
local,"{

        final Map<Local, ArrayObject> arraySizes = new HashMap<>();
        if (method.locals.size() == 0) {
            return arraySizes;
        }
        Cfg.createCFG(method);
        Cfg.dfsVisit(method, new Cfg.DfsVisitor() {
            @Override
            public void onVisit(Stmt p) {
                if (p.st == Stmt.ST.ASSIGN) {
                    if (p.getOp2().vt == Value.VT.NEW_ARRAY && p.getOp1().vt == Value.VT.LOCAL) {
                        TypeExpr ae = (TypeExpr) p.getOp2();
                        if (ae.getOp().vt == Value.VT.CONSTANT) {
                            int size = ((Number) ((Constant) ae.getOp()).value).intValue();

                            // https://bitbucket.org/pxb1988/dex2jar/issues/2/decompiler-error
                            // the following code may used in a java
                            // try{
                            //   new int[-1];
                            // } catch(Exception e) {
                            //   ...
                            // }
                            if (size >= 0) {
                                arraySizes.put((Local) p.getOp1(), new ArrayObject(size, ae.type, (AssignStmt) p));
                            }
                        }
                    } else if (p.getOp1().vt == Value.VT.ARRAY) {
                        ArrayExpr ae = (ArrayExpr) p.getOp1();
                        if (ae.getOp1().vt == Value.VT.LOCAL) {
                            Local local = (Local) ae.getOp1();
                            ArrayObject arrayObject = arraySizes.get(local);
                            if (arrayObject != null) {
                                if (ae.getOp2().vt == Value.VT.CONSTANT) {
                                    arrayObject.putItem.add(p);
                                } else {
                                    arraySizes.remove(local);
                                }
                            }
                        }
                    }
                } else if (p.st == Stmt.ST.FILL_ARRAY_DATA) {
                    if (p.getOp1().vt == Value.VT.LOCAL) {
                        Local local = (Local) p.getOp1();
                        ArrayObject arrayObject = arraySizes.get(local);
                        if (arrayObject != null) {
                            arrayObject.putItem.add(p);
                        }
                    }
                }
            }
        });
        if (arraySizes.size() > 0) {
            Set<Local> set = new HashSet<Local>();
            if (method.phiLabels != null) {
                for (LabelStmt labelStmt : method.phiLabels) {
                    if (labelStmt.phis != null) {
                        for (AssignStmt as : labelStmt.phis) {
                            set.add((Local) as.getOp1());
                            for (Value v : as.getOp2().getOps()) {
                                set.add((Local) v);
                            }
                        }
                    }
                }
            }
            if (set.size() > 0) {
                for (Local local : set) {
                    arraySizes.remove(local);
                }
            }
        }
        return arraySizes;
    }",iterator
p,"{
        for (Stmt p = irMethod.stmts.getFirst(); p != null;) {
            if (arrayNPE(p)) {
                Stmt q = p.getNext();
                replaceNPE(irMethod.stmts, irMethod.locals, p);
                p = q;
                continue;
            }
            p = p.getNext();
        }
    }",maybe_loop_control
value,"{
        List<Value> values = new ArrayList<Value>();
        switch (p.et) {
        case E1:
            tryAdd(((E1Stmt) p).op.trim(), values);
            break;
        case E2:
            E2Stmt e2 = (E2Stmt) p;
            switch (e2.op1.trim().vt) {
            case LOCAL:
                tryAdd(e2.op2.trim(), values);
                break;
            case ARRAY:
                ArrayExpr ae = (ArrayExpr) e2.op1.trim();
                if (tryAdd(ae.op1.trim(), values)) {
                    if (tryAdd(ae.op2.trim(), values)) {
                        tryAdd(e2.op2.trim(), values);
                    }
                }
                break;
            case FIELD:// putfield
                FieldExpr fe = (FieldExpr) e2.op1.trim();
                if (fe.op == null || fe.op.trim() == null || tryAdd(fe.op.trim(), values)) {
                    tryAdd(e2.op2.trim(), values);
                }
                break;
            default:
                if (tryAdd(e2.op2.trim(), values)) {
                    tryAdd(e2.op1.trim(), values);
                }
            }
        default:
        }
        for (Value value : values) {
            switch (value.vt) {
            case CONSTANT:
            case LOCAL:
                break;
            default:
                Local n = Exprs.nLocal(""xxx"");
                locals.add(n);
                stmts.insertBefore(p, Stmts.nAssign(n, value));
            }
        }
        stmts.insertBefore(p,
                Stmts.nThrow(Exprs.nInvokeNew(new Value[0], new String[0], ""Ljava/lang/NullPointerException;"")));
        stmts.remove(p);
    }",iterator
vb,"{
        if (!arrayNPE(value)) {
            values.add(value);
            return true;
        } else {
            switch (value.et) {
            case E0:
                values.add(value);
                break;
            case E1:
                E1Expr e1 = (E1Expr) value;
                if (e1.op == null || e1.op.trim() == null) {
                    return false;
                }
                tryAdd(e1.op.trim(), values);
                break;
            case E2:
                E2Expr e2 = (E2Expr) value;
                if (e2.vt == VT.ARRAY && e2.op1.trim().vt == VT.CONSTANT) {
                    Constant cst = (Constant) e2.op1.trim();
                    if (cst.value.equals(Integer.valueOf(0))) {
                        tryAdd(e2.op2.trim(), values);
                        return false;
                    }
                }
                if (tryAdd(e2.op1.trim(), values)) {
                    tryAdd(e2.op2.trim(), values);
                }

            case En:
                for (Value vb : ((EnExpr) value).ops) {
                    if (!tryAdd(vb.trim(), values)) {
                        break;
                    }
                }
            }
        }
        return false;
    }",iterator
vb,"{
        switch (value.et) {
        case E0:
            return false;
        case E1:
            E1Expr e1 = (E1Expr) value;
            if (e1.op == null || e1.op.trim() == null) {
                return false;
            }
            return arrayNPE(e1.op.trim());
        case E2:
            E2Expr e2 = (E2Expr) value;
            if (e2.vt == VT.ARRAY && e2.op1.trim().vt == VT.CONSTANT) {
                Constant cst = (Constant) e2.op1.trim();
                if (cst.value.equals(Integer.valueOf(0))) {
                    return true;
                }
            }
            return arrayNPE(e2.op1.trim()) || arrayNPE(e2.op2.trim());

        case En:
            for (Value vb : ((EnExpr) value).ops) {
                if (arrayNPE(vb.trim())) {
                    return true;
                }
            }
        }
        return false;
    }",iterator
vb,"{
        switch (value.et) {
        case E0:
            return false;
        case E1:
            E1Expr e1 = (E1Expr) value;
            if (e1.op == null || e1.op.trim() == null) {
                return false;
            }
            return arrayNPE(e1.op.trim());
        case E2:
            E2Expr e2 = (E2Expr) value;
            if (e2.vt == VT.ARRAY && e2.op1.trim().vt == VT.CONSTANT) {
                Constant cst = (Constant) e2.op1.trim();
                if (cst.value.equals(Integer.valueOf(0))) {
                    return true;
                }
            }
            return arrayNPE(e2.op1.trim()) || arrayNPE(e2.op2.trim());

        case En:
            for (Value vb : ((EnExpr) value).ops) {
                if (arrayNPE(vb.trim())) {
                    return true;
                }
            }
        }
        return false;
    }",break_loop_control
local,"{

        Set<Local> arrays = searchForArrayObject(method);
        if (arrays.size() == 0) {
            return false;
        }
        for (Local local : method.locals) {
            local._ls_index = -1;
        }
        int i = 0;
        for (Local local : arrays) {
            local._ls_index = i++;
        }
        final int size = i;
        Cfg.createCFG(method);
        final List<ArrayValue> values = new ArrayList<>();
        final List<Stmt> used = new ArrayList<>();
        Cfg.dfs(method.stmts, new Cfg.FrameVisitor<ArrayValue[]>() {

            Set<Integer> phis = new HashSet<>();

            @Override
            public ArrayValue[] merge(ArrayValue[] srcFrame, ArrayValue[] distFrame, Stmt src, Stmt dist) {
                if (dist.st == Stmt.ST.LABEL) {
                    LabelStmt labelStmt = (LabelStmt) dist;
                    if (labelStmt.phis != null) {
                        for (AssignStmt phi : labelStmt.phis) {
                            int idx = ((Local) phi.getOp1())._ls_index;
                            if (idx >= 0) {
                                phis.add(idx);
                            }
                        }
                    }
                }
                if (distFrame == null) {
                    distFrame = new ArrayValue[size];
                    for (int i = 0; i < size; i++) {
                        if (phis.contains(i)) {
                            ArrayValue aov = new ArrayValue();
                            values.add(aov);
                            aov.s = ArrayValue.S.UNKNOWN;
                            aov.indexType = ArrayValue.IndexType.NONE;
                            aov.stmt = dist;
                            distFrame[i] = aov;
                        } else {
                            ArrayValue arc = srcFrame[i];
                            if (arc != null) {
                                ArrayValue aov = new ArrayValue();
                                values.add(aov);
                                aov.s = ArrayValue.S.INHERIT;
                                aov.indexType = ArrayValue.IndexType.NONE;
                                aov.stmt = dist;
                                aov.parent = arc;
                                distFrame[i] = aov;
                            }
                        }
                    }
                } else {
                    for (int i = 0; i < size; i++) {
                        if (phis.contains(i)) {
                            continue;
                        }
                        ArrayValue arc = srcFrame[i];
                        ArrayValue aov = distFrame[i];
                        if (arc != null && aov != null) {
                            if (aov.parent == null) {
                                aov.parent = arc;
                            } else if (!aov.parent.equals(arc)) {
                                if (aov.otherParents == null) {
                                    aov.otherParents = new HashSet<>();
                                }
                                aov.otherParents.add(arc);
                            }
                        }
                    }
                }
                phis.clear();
                return distFrame;
            }

            @Override
            public ArrayValue[] initFirstFrame(Stmt first) {
                return new ArrayValue[size];
            }

            ArrayValue[] tmp = new ArrayValue[size];
            Stmt currentStmt;


            @Override
            public ArrayValue[] exec(ArrayValue[] frame, Stmt stmt) {
                currentStmt = stmt;
                System.arraycopy(frame, 0, tmp, 0, size);
                if (stmt.st == Stmt.ST.ASSIGN) {
                    // create an array
                    if (stmt.getOp1().vt == Value.VT.LOCAL) {
                        Local local = (Local) stmt.getOp1();
                        use(stmt.getOp2());
                        if (local._ls_index >= 0) {
                            Value op2 = stmt.getOp2();
                            if (op2.vt == Value.VT.NEW_ARRAY) {
                                ArrayValue av = new ArrayValue();
                                av.s = ArrayValue.S.DEFAULT;
                                av.size = op2.getOp();
                                values.add(av);
                                tmp[local._ls_index] = av;
                            } else if (op2.vt == Value.VT.FILLED_ARRAY) {
                                ArrayValue av = new ArrayValue();
                                av.s = ArrayValue.S.DEFAULT;
                                av.indexType = ArrayValue.IndexType.CONST;
                                av.stmt = stmt;
                                FilledArrayExpr fae = (FilledArrayExpr) stmt.getOp2();
                                av.size = Exprs.nInt(fae.getOps().length);
                                Value[] ops = fae.getOps();
                                for (int i = 0; i < ops.length; i++) {
                                    av.elements1.put(i, ops[i]);
                                }
                                values.add(av);
                                tmp[local._ls_index] = av;
                            } else if (op2.vt == Value.VT.CONSTANT) {
                                Object cst = ((Constant) op2).value;
                                if (cst != null && !cst.equals(Constant.Null) && cst.getClass().isArray()) {
                                    ArrayValue av = new ArrayValue();
                                    av.s = ArrayValue.S.DEFAULT;
                                    av.indexType = ArrayValue.IndexType.CONST;
                                    av.stmt = stmt;
                                    int size = Array.getLength(cst);
                                    av.size = Exprs.nInt(size);
                                    for (int i = 0; i < size; i++) {
                                        av.elements1.put(i, Exprs.nConstant(Array.get(cst, size)));
                                    }
                                    values.add(av);
                                    tmp[local._ls_index] = av;
                                } else {
                                    ArrayValue av = new ArrayValue();
                                    values.add(av);
                                    av.s = ArrayValue.S.UNKNOWN;
                                    av.indexType = ArrayValue.IndexType.NONE;
                                    av.stmt = stmt;
                                    tmp[local._ls_index] = av;
                                }
                            } else {
                                ArrayValue av = new ArrayValue();
                                values.add(av);
                                av.s = ArrayValue.S.UNKNOWN;
                                av.indexType = ArrayValue.IndexType.NONE;
                                av.stmt = stmt;
                                tmp[local._ls_index] = av;
                            }
                        }
                        // assign index1
                    } else if (stmt.getOp1().vt == Value.VT.ARRAY) {
                        use(stmt.getOp2());
                        ArrayExpr ae = (ArrayExpr) stmt.getOp1();
                        if (ae.getOp1().vt == Value.VT.LOCAL) {
                            Local local = (Local) ae.getOp1();
                            Value index = ae.getOp2();
                            if (local._ls_index >= 0) {
                                if (index.vt == Value.VT.CONSTANT) {
                                    ArrayValue parent = tmp[local._ls_index];
                                    ArrayValue av = new ArrayValue();
                                    values.add(av);
                                    av.parent = parent;
                                    av.elements1.put(((Number) (((Constant) index).value)).intValue(), stmt.getOp2());
                                    av.indexType = ArrayValue.IndexType.CONST;
                                    av.s = ArrayValue.S.INHERIT;
                                    av.stmt = stmt;
                                    tmp[local._ls_index] = av;
                                } else if (index.vt == Value.VT.LOCAL) {
                                    ArrayValue parent = tmp[local._ls_index];
                                    ArrayValue av = new ArrayValue();
                                    values.add(av);
                                    av.parent = parent;
                                    av.elements1.put(index, stmt.getOp2());
                                    av.indexType = ArrayValue.IndexType.LOCAL;
                                    av.s = ArrayValue.S.INHERIT;
                                    av.stmt = stmt;
                                    tmp[local._ls_index] = av;
                                } else {
                                    ArrayValue av = new ArrayValue();
                                    values.add(av);
                                    av.s = ArrayValue.S.UNKNOWN;
                                    av.indexType = ArrayValue.IndexType.NONE;
                                    av.stmt = stmt;
                                    tmp[local._ls_index] = av;
                                }
                            } else {
                                use(stmt.getOp1());
                            }
                        } else {
                            use(stmt.getOp1());
                        }

                    } else {
                        use(stmt.getOp1());
                        use(stmt.getOp2());
                    }
                    // assign index2
                } else if (stmt.st == Stmt.ST.FILL_ARRAY_DATA) {
                    if (stmt.getOp1().vt == Value.VT.LOCAL) {
                        Local local = (Local) stmt.getOp1();
                        if (local._ls_index >= 0) {
                            Object array = ((Constant) stmt.getOp2()).value;
                            ArrayValue parent = tmp[local._ls_index];
                            ArrayValue av = new ArrayValue();
                            values.add(av);
                            av.parent = parent;
                            int size = Array.getLength(array);
                            av.size = Exprs.nInt(size);
                            for (int i = 0; i < size; i++) {
                                av.elements1.put(i, Exprs.nConstant(Array.get(array, i)));
                            }
                            av.indexType = ArrayValue.IndexType.CONST;
                            av.s = ArrayValue.S.INHERIT;
                            av.stmt = stmt;
                            tmp[local._ls_index] = av;
                        }
                    } else {
                        use(stmt.getOp1());
                    }
                } else {
                    switch (stmt.et) {
                        case E0:
                            break;
                        case E1:
                            use(stmt.getOp());
                            break;
                        case E2:
                            use(stmt.getOp1());
                            use(stmt.getOp2());
                            break;
                        case En:
                            throw new RuntimeException();
                    }
                }

                return tmp;
            }

            private void use(Value v) {
                switch (v.et) {
                    case E0:
                        break;
                    case E1:
                        use(v.getOp());
                        break;
                    case E2:
                        Value op1 = v.getOp1();
                        Value op2 = v.getOp2();
                        use(op1);
                        use(op2);
                        if (v.vt == Value.VT.ARRAY) {
                            if (op1.vt == Value.VT.LOCAL && (op2.vt == Value.VT.LOCAL || op2.vt == Value.VT.CONSTANT)) {
                                Local local = (Local) op1;
                                if (local._ls_index > 0) {
                                    used.add(currentStmt);
                                }
                            }
                        }
                        break;
                    case En:
                        for (Value op : v.getOps()) {
                            use(op);
                        }
                        break;
                }
            }
        });


        // TODO travel stmt to find must-be array element

        for (Stmt p : method.stmts) {

        }
        new StmtTraveler() {
            @Override
            public Value travel(Value op) {
                op = super.travel(op);
                if (op.vt == Value.VT.ARRAY) {

                }
                return op;
            }
        }.travel(method.stmts);

        return false;
    }",iterator
phi,"{

        Set<Local> arrays = searchForArrayObject(method);
        if (arrays.size() == 0) {
            return false;
        }
        for (Local local : method.locals) {
            local._ls_index = -1;
        }
        int i = 0;
        for (Local local : arrays) {
            local._ls_index = i++;
        }
        final int size = i;
        Cfg.createCFG(method);
        final List<ArrayValue> values = new ArrayList<>();
        final List<Stmt> used = new ArrayList<>();
        Cfg.dfs(method.stmts, new Cfg.FrameVisitor<ArrayValue[]>() {

            Set<Integer> phis = new HashSet<>();

            @Override
            public ArrayValue[] merge(ArrayValue[] srcFrame, ArrayValue[] distFrame, Stmt src, Stmt dist) {
                if (dist.st == Stmt.ST.LABEL) {
                    LabelStmt labelStmt = (LabelStmt) dist;
                    if (labelStmt.phis != null) {
                        for (AssignStmt phi : labelStmt.phis) {
                            int idx = ((Local) phi.getOp1())._ls_index;
                            if (idx >= 0) {
                                phis.add(idx);
                            }
                        }
                    }
                }
                if (distFrame == null) {
                    distFrame = new ArrayValue[size];
                    for (int i = 0; i < size; i++) {
                        if (phis.contains(i)) {
                            ArrayValue aov = new ArrayValue();
                            values.add(aov);
                            aov.s = ArrayValue.S.UNKNOWN;
                            aov.indexType = ArrayValue.IndexType.NONE;
                            aov.stmt = dist;
                            distFrame[i] = aov;
                        } else {
                            ArrayValue arc = srcFrame[i];
                            if (arc != null) {
                                ArrayValue aov = new ArrayValue();
                                values.add(aov);
                                aov.s = ArrayValue.S.INHERIT;
                                aov.indexType = ArrayValue.IndexType.NONE;
                                aov.stmt = dist;
                                aov.parent = arc;
                                distFrame[i] = aov;
                            }
                        }
                    }
                } else {
                    for (int i = 0; i < size; i++) {
                        if (phis.contains(i)) {
                            continue;
                        }
                        ArrayValue arc = srcFrame[i];
                        ArrayValue aov = distFrame[i];
                        if (arc != null && aov != null) {
                            if (aov.parent == null) {
                                aov.parent = arc;
                            } else if (!aov.parent.equals(arc)) {
                                if (aov.otherParents == null) {
                                    aov.otherParents = new HashSet<>();
                                }
                                aov.otherParents.add(arc);
                            }
                        }
                    }
                }
                phis.clear();
                return distFrame;
            }

            @Override
            public ArrayValue[] initFirstFrame(Stmt first) {
                return new ArrayValue[size];
            }

            ArrayValue[] tmp = new ArrayValue[size];
            Stmt currentStmt;


            @Override
            public ArrayValue[] exec(ArrayValue[] frame, Stmt stmt) {
                currentStmt = stmt;
                System.arraycopy(frame, 0, tmp, 0, size);
                if (stmt.st == Stmt.ST.ASSIGN) {
                    // create an array
                    if (stmt.getOp1().vt == Value.VT.LOCAL) {
                        Local local = (Local) stmt.getOp1();
                        use(stmt.getOp2());
                        if (local._ls_index >= 0) {
                            Value op2 = stmt.getOp2();
                            if (op2.vt == Value.VT.NEW_ARRAY) {
                                ArrayValue av = new ArrayValue();
                                av.s = ArrayValue.S.DEFAULT;
                                av.size = op2.getOp();
                                values.add(av);
                                tmp[local._ls_index] = av;
                            } else if (op2.vt == Value.VT.FILLED_ARRAY) {
                                ArrayValue av = new ArrayValue();
                                av.s = ArrayValue.S.DEFAULT;
                                av.indexType = ArrayValue.IndexType.CONST;
                                av.stmt = stmt;
                                FilledArrayExpr fae = (FilledArrayExpr) stmt.getOp2();
                                av.size = Exprs.nInt(fae.getOps().length);
                                Value[] ops = fae.getOps();
                                for (int i = 0; i < ops.length; i++) {
                                    av.elements1.put(i, ops[i]);
                                }
                                values.add(av);
                                tmp[local._ls_index] = av;
                            } else if (op2.vt == Value.VT.CONSTANT) {
                                Object cst = ((Constant) op2).value;
                                if (cst != null && !cst.equals(Constant.Null) && cst.getClass().isArray()) {
                                    ArrayValue av = new ArrayValue();
                                    av.s = ArrayValue.S.DEFAULT;
                                    av.indexType = ArrayValue.IndexType.CONST;
                                    av.stmt = stmt;
                                    int size = Array.getLength(cst);
                                    av.size = Exprs.nInt(size);
                                    for (int i = 0; i < size; i++) {
                                        av.elements1.put(i, Exprs.nConstant(Array.get(cst, size)));
                                    }
                                    values.add(av);
                                    tmp[local._ls_index] = av;
                                } else {
                                    ArrayValue av = new ArrayValue();
                                    values.add(av);
                                    av.s = ArrayValue.S.UNKNOWN;
                                    av.indexType = ArrayValue.IndexType.NONE;
                                    av.stmt = stmt;
                                    tmp[local._ls_index] = av;
                                }
                            } else {
                                ArrayValue av = new ArrayValue();
                                values.add(av);
                                av.s = ArrayValue.S.UNKNOWN;
                                av.indexType = ArrayValue.IndexType.NONE;
                                av.stmt = stmt;
                                tmp[local._ls_index] = av;
                            }
                        }
                        // assign index1
                    } else if (stmt.getOp1().vt == Value.VT.ARRAY) {
                        use(stmt.getOp2());
                        ArrayExpr ae = (ArrayExpr) stmt.getOp1();
                        if (ae.getOp1().vt == Value.VT.LOCAL) {
                            Local local = (Local) ae.getOp1();
                            Value index = ae.getOp2();
                            if (local._ls_index >= 0) {
                                if (index.vt == Value.VT.CONSTANT) {
                                    ArrayValue parent = tmp[local._ls_index];
                                    ArrayValue av = new ArrayValue();
                                    values.add(av);
                                    av.parent = parent;
                                    av.elements1.put(((Number) (((Constant) index).value)).intValue(), stmt.getOp2());
                                    av.indexType = ArrayValue.IndexType.CONST;
                                    av.s = ArrayValue.S.INHERIT;
                                    av.stmt = stmt;
                                    tmp[local._ls_index] = av;
                                } else if (index.vt == Value.VT.LOCAL) {
                                    ArrayValue parent = tmp[local._ls_index];
                                    ArrayValue av = new ArrayValue();
                                    values.add(av);
                                    av.parent = parent;
                                    av.elements1.put(index, stmt.getOp2());
                                    av.indexType = ArrayValue.IndexType.LOCAL;
                                    av.s = ArrayValue.S.INHERIT;
                                    av.stmt = stmt;
                                    tmp[local._ls_index] = av;
                                } else {
                                    ArrayValue av = new ArrayValue();
                                    values.add(av);
                                    av.s = ArrayValue.S.UNKNOWN;
                                    av.indexType = ArrayValue.IndexType.NONE;
                                    av.stmt = stmt;
                                    tmp[local._ls_index] = av;
                                }
                            } else {
                                use(stmt.getOp1());
                            }
                        } else {
                            use(stmt.getOp1());
                        }

                    } else {
                        use(stmt.getOp1());
                        use(stmt.getOp2());
                    }
                    // assign index2
                } else if (stmt.st == Stmt.ST.FILL_ARRAY_DATA) {
                    if (stmt.getOp1().vt == Value.VT.LOCAL) {
                        Local local = (Local) stmt.getOp1();
                        if (local._ls_index >= 0) {
                            Object array = ((Constant) stmt.getOp2()).value;
                            ArrayValue parent = tmp[local._ls_index];
                            ArrayValue av = new ArrayValue();
                            values.add(av);
                            av.parent = parent;
                            int size = Array.getLength(array);
                            av.size = Exprs.nInt(size);
                            for (int i = 0; i < size; i++) {
                                av.elements1.put(i, Exprs.nConstant(Array.get(array, i)));
                            }
                            av.indexType = ArrayValue.IndexType.CONST;
                            av.s = ArrayValue.S.INHERIT;
                            av.stmt = stmt;
                            tmp[local._ls_index] = av;
                        }
                    } else {
                        use(stmt.getOp1());
                    }
                } else {
                    switch (stmt.et) {
                        case E0:
                            break;
                        case E1:
                            use(stmt.getOp());
                            break;
                        case E2:
                            use(stmt.getOp1());
                            use(stmt.getOp2());
                            break;
                        case En:
                            throw new RuntimeException();
                    }
                }

                return tmp;
            }

            private void use(Value v) {
                switch (v.et) {
                    case E0:
                        break;
                    case E1:
                        use(v.getOp());
                        break;
                    case E2:
                        Value op1 = v.getOp1();
                        Value op2 = v.getOp2();
                        use(op1);
                        use(op2);
                        if (v.vt == Value.VT.ARRAY) {
                            if (op1.vt == Value.VT.LOCAL && (op2.vt == Value.VT.LOCAL || op2.vt == Value.VT.CONSTANT)) {
                                Local local = (Local) op1;
                                if (local._ls_index > 0) {
                                    used.add(currentStmt);
                                }
                            }
                        }
                        break;
                    case En:
                        for (Value op : v.getOps()) {
                            use(op);
                        }
                        break;
                }
            }
        });


        // TODO travel stmt to find must-be array element

        for (Stmt p : method.stmts) {

        }
        new StmtTraveler() {
            @Override
            public Value travel(Value op) {
                op = super.travel(op);
                if (op.vt == Value.VT.ARRAY) {

                }
                return op;
            }
        }.travel(method.stmts);

        return false;
    }",iterator
i,"{

        Set<Local> arrays = searchForArrayObject(method);
        if (arrays.size() == 0) {
            return false;
        }
        for (Local local : method.locals) {
            local._ls_index = -1;
        }
        int i = 0;
        for (Local local : arrays) {
            local._ls_index = i++;
        }
        final int size = i;
        Cfg.createCFG(method);
        final List<ArrayValue> values = new ArrayList<>();
        final List<Stmt> used = new ArrayList<>();
        Cfg.dfs(method.stmts, new Cfg.FrameVisitor<ArrayValue[]>() {

            Set<Integer> phis = new HashSet<>();

            @Override
            public ArrayValue[] merge(ArrayValue[] srcFrame, ArrayValue[] distFrame, Stmt src, Stmt dist) {
                if (dist.st == Stmt.ST.LABEL) {
                    LabelStmt labelStmt = (LabelStmt) dist;
                    if (labelStmt.phis != null) {
                        for (AssignStmt phi : labelStmt.phis) {
                            int idx = ((Local) phi.getOp1())._ls_index;
                            if (idx >= 0) {
                                phis.add(idx);
                            }
                        }
                    }
                }
                if (distFrame == null) {
                    distFrame = new ArrayValue[size];
                    for (int i = 0; i < size; i++) {
                        if (phis.contains(i)) {
                            ArrayValue aov = new ArrayValue();
                            values.add(aov);
                            aov.s = ArrayValue.S.UNKNOWN;
                            aov.indexType = ArrayValue.IndexType.NONE;
                            aov.stmt = dist;
                            distFrame[i] = aov;
                        } else {
                            ArrayValue arc = srcFrame[i];
                            if (arc != null) {
                                ArrayValue aov = new ArrayValue();
                                values.add(aov);
                                aov.s = ArrayValue.S.INHERIT;
                                aov.indexType = ArrayValue.IndexType.NONE;
                                aov.stmt = dist;
                                aov.parent = arc;
                                distFrame[i] = aov;
                            }
                        }
                    }
                } else {
                    for (int i = 0; i < size; i++) {
                        if (phis.contains(i)) {
                            continue;
                        }
                        ArrayValue arc = srcFrame[i];
                        ArrayValue aov = distFrame[i];
                        if (arc != null && aov != null) {
                            if (aov.parent == null) {
                                aov.parent = arc;
                            } else if (!aov.parent.equals(arc)) {
                                if (aov.otherParents == null) {
                                    aov.otherParents = new HashSet<>();
                                }
                                aov.otherParents.add(arc);
                            }
                        }
                    }
                }
                phis.clear();
                return distFrame;
            }

            @Override
            public ArrayValue[] initFirstFrame(Stmt first) {
                return new ArrayValue[size];
            }

            ArrayValue[] tmp = new ArrayValue[size];
            Stmt currentStmt;


            @Override
            public ArrayValue[] exec(ArrayValue[] frame, Stmt stmt) {
                currentStmt = stmt;
                System.arraycopy(frame, 0, tmp, 0, size);
                if (stmt.st == Stmt.ST.ASSIGN) {
                    // create an array
                    if (stmt.getOp1().vt == Value.VT.LOCAL) {
                        Local local = (Local) stmt.getOp1();
                        use(stmt.getOp2());
                        if (local._ls_index >= 0) {
                            Value op2 = stmt.getOp2();
                            if (op2.vt == Value.VT.NEW_ARRAY) {
                                ArrayValue av = new ArrayValue();
                                av.s = ArrayValue.S.DEFAULT;
                                av.size = op2.getOp();
                                values.add(av);
                                tmp[local._ls_index] = av;
                            } else if (op2.vt == Value.VT.FILLED_ARRAY) {
                                ArrayValue av = new ArrayValue();
                                av.s = ArrayValue.S.DEFAULT;
                                av.indexType = ArrayValue.IndexType.CONST;
                                av.stmt = stmt;
                                FilledArrayExpr fae = (FilledArrayExpr) stmt.getOp2();
                                av.size = Exprs.nInt(fae.getOps().length);
                                Value[] ops = fae.getOps();
                                for (int i = 0; i < ops.length; i++) {
                                    av.elements1.put(i, ops[i]);
                                }
                                values.add(av);
                                tmp[local._ls_index] = av;
                            } else if (op2.vt == Value.VT.CONSTANT) {
                                Object cst = ((Constant) op2).value;
                                if (cst != null && !cst.equals(Constant.Null) && cst.getClass().isArray()) {
                                    ArrayValue av = new ArrayValue();
                                    av.s = ArrayValue.S.DEFAULT;
                                    av.indexType = ArrayValue.IndexType.CONST;
                                    av.stmt = stmt;
                                    int size = Array.getLength(cst);
                                    av.size = Exprs.nInt(size);
                                    for (int i = 0; i < size; i++) {
                                        av.elements1.put(i, Exprs.nConstant(Array.get(cst, size)));
                                    }
                                    values.add(av);
                                    tmp[local._ls_index] = av;
                                } else {
                                    ArrayValue av = new ArrayValue();
                                    values.add(av);
                                    av.s = ArrayValue.S.UNKNOWN;
                                    av.indexType = ArrayValue.IndexType.NONE;
                                    av.stmt = stmt;
                                    tmp[local._ls_index] = av;
                                }
                            } else {
                                ArrayValue av = new ArrayValue();
                                values.add(av);
                                av.s = ArrayValue.S.UNKNOWN;
                                av.indexType = ArrayValue.IndexType.NONE;
                                av.stmt = stmt;
                                tmp[local._ls_index] = av;
                            }
                        }
                        // assign index1
                    } else if (stmt.getOp1().vt == Value.VT.ARRAY) {
                        use(stmt.getOp2());
                        ArrayExpr ae = (ArrayExpr) stmt.getOp1();
                        if (ae.getOp1().vt == Value.VT.LOCAL) {
                            Local local = (Local) ae.getOp1();
                            Value index = ae.getOp2();
                            if (local._ls_index >= 0) {
                                if (index.vt == Value.VT.CONSTANT) {
                                    ArrayValue parent = tmp[local._ls_index];
                                    ArrayValue av = new ArrayValue();
                                    values.add(av);
                                    av.parent = parent;
                                    av.elements1.put(((Number) (((Constant) index).value)).intValue(), stmt.getOp2());
                                    av.indexType = ArrayValue.IndexType.CONST;
                                    av.s = ArrayValue.S.INHERIT;
                                    av.stmt = stmt;
                                    tmp[local._ls_index] = av;
                                } else if (index.vt == Value.VT.LOCAL) {
                                    ArrayValue parent = tmp[local._ls_index];
                                    ArrayValue av = new ArrayValue();
                                    values.add(av);
                                    av.parent = parent;
                                    av.elements1.put(index, stmt.getOp2());
                                    av.indexType = ArrayValue.IndexType.LOCAL;
                                    av.s = ArrayValue.S.INHERIT;
                                    av.stmt = stmt;
                                    tmp[local._ls_index] = av;
                                } else {
                                    ArrayValue av = new ArrayValue();
                                    values.add(av);
                                    av.s = ArrayValue.S.UNKNOWN;
                                    av.indexType = ArrayValue.IndexType.NONE;
                                    av.stmt = stmt;
                                    tmp[local._ls_index] = av;
                                }
                            } else {
                                use(stmt.getOp1());
                            }
                        } else {
                            use(stmt.getOp1());
                        }

                    } else {
                        use(stmt.getOp1());
                        use(stmt.getOp2());
                    }
                    // assign index2
                } else if (stmt.st == Stmt.ST.FILL_ARRAY_DATA) {
                    if (stmt.getOp1().vt == Value.VT.LOCAL) {
                        Local local = (Local) stmt.getOp1();
                        if (local._ls_index >= 0) {
                            Object array = ((Constant) stmt.getOp2()).value;
                            ArrayValue parent = tmp[local._ls_index];
                            ArrayValue av = new ArrayValue();
                            values.add(av);
                            av.parent = parent;
                            int size = Array.getLength(array);
                            av.size = Exprs.nInt(size);
                            for (int i = 0; i < size; i++) {
                                av.elements1.put(i, Exprs.nConstant(Array.get(array, i)));
                            }
                            av.indexType = ArrayValue.IndexType.CONST;
                            av.s = ArrayValue.S.INHERIT;
                            av.stmt = stmt;
                            tmp[local._ls_index] = av;
                        }
                    } else {
                        use(stmt.getOp1());
                    }
                } else {
                    switch (stmt.et) {
                        case E0:
                            break;
                        case E1:
                            use(stmt.getOp());
                            break;
                        case E2:
                            use(stmt.getOp1());
                            use(stmt.getOp2());
                            break;
                        case En:
                            throw new RuntimeException();
                    }
                }

                return tmp;
            }

            private void use(Value v) {
                switch (v.et) {
                    case E0:
                        break;
                    case E1:
                        use(v.getOp());
                        break;
                    case E2:
                        Value op1 = v.getOp1();
                        Value op2 = v.getOp2();
                        use(op1);
                        use(op2);
                        if (v.vt == Value.VT.ARRAY) {
                            if (op1.vt == Value.VT.LOCAL && (op2.vt == Value.VT.LOCAL || op2.vt == Value.VT.CONSTANT)) {
                                Local local = (Local) op1;
                                if (local._ls_index > 0) {
                                    used.add(currentStmt);
                                }
                            }
                        }
                        break;
                    case En:
                        for (Value op : v.getOps()) {
                            use(op);
                        }
                        break;
                }
            }
        });


        // TODO travel stmt to find must-be array element

        for (Stmt p : method.stmts) {

        }
        new StmtTraveler() {
            @Override
            public Value travel(Value op) {
                op = super.travel(op);
                if (op.vt == Value.VT.ARRAY) {

                }
                return op;
            }
        }.travel(method.stmts);

        return false;
    }",loop_control
op,"{

        Set<Local> arrays = searchForArrayObject(method);
        if (arrays.size() == 0) {
            return false;
        }
        for (Local local : method.locals) {
            local._ls_index = -1;
        }
        int i = 0;
        for (Local local : arrays) {
            local._ls_index = i++;
        }
        final int size = i;
        Cfg.createCFG(method);
        final List<ArrayValue> values = new ArrayList<>();
        final List<Stmt> used = new ArrayList<>();
        Cfg.dfs(method.stmts, new Cfg.FrameVisitor<ArrayValue[]>() {

            Set<Integer> phis = new HashSet<>();

            @Override
            public ArrayValue[] merge(ArrayValue[] srcFrame, ArrayValue[] distFrame, Stmt src, Stmt dist) {
                if (dist.st == Stmt.ST.LABEL) {
                    LabelStmt labelStmt = (LabelStmt) dist;
                    if (labelStmt.phis != null) {
                        for (AssignStmt phi : labelStmt.phis) {
                            int idx = ((Local) phi.getOp1())._ls_index;
                            if (idx >= 0) {
                                phis.add(idx);
                            }
                        }
                    }
                }
                if (distFrame == null) {
                    distFrame = new ArrayValue[size];
                    for (int i = 0; i < size; i++) {
                        if (phis.contains(i)) {
                            ArrayValue aov = new ArrayValue();
                            values.add(aov);
                            aov.s = ArrayValue.S.UNKNOWN;
                            aov.indexType = ArrayValue.IndexType.NONE;
                            aov.stmt = dist;
                            distFrame[i] = aov;
                        } else {
                            ArrayValue arc = srcFrame[i];
                            if (arc != null) {
                                ArrayValue aov = new ArrayValue();
                                values.add(aov);
                                aov.s = ArrayValue.S.INHERIT;
                                aov.indexType = ArrayValue.IndexType.NONE;
                                aov.stmt = dist;
                                aov.parent = arc;
                                distFrame[i] = aov;
                            }
                        }
                    }
                } else {
                    for (int i = 0; i < size; i++) {
                        if (phis.contains(i)) {
                            continue;
                        }
                        ArrayValue arc = srcFrame[i];
                        ArrayValue aov = distFrame[i];
                        if (arc != null && aov != null) {
                            if (aov.parent == null) {
                                aov.parent = arc;
                            } else if (!aov.parent.equals(arc)) {
                                if (aov.otherParents == null) {
                                    aov.otherParents = new HashSet<>();
                                }
                                aov.otherParents.add(arc);
                            }
                        }
                    }
                }
                phis.clear();
                return distFrame;
            }

            @Override
            public ArrayValue[] initFirstFrame(Stmt first) {
                return new ArrayValue[size];
            }

            ArrayValue[] tmp = new ArrayValue[size];
            Stmt currentStmt;


            @Override
            public ArrayValue[] exec(ArrayValue[] frame, Stmt stmt) {
                currentStmt = stmt;
                System.arraycopy(frame, 0, tmp, 0, size);
                if (stmt.st == Stmt.ST.ASSIGN) {
                    // create an array
                    if (stmt.getOp1().vt == Value.VT.LOCAL) {
                        Local local = (Local) stmt.getOp1();
                        use(stmt.getOp2());
                        if (local._ls_index >= 0) {
                            Value op2 = stmt.getOp2();
                            if (op2.vt == Value.VT.NEW_ARRAY) {
                                ArrayValue av = new ArrayValue();
                                av.s = ArrayValue.S.DEFAULT;
                                av.size = op2.getOp();
                                values.add(av);
                                tmp[local._ls_index] = av;
                            } else if (op2.vt == Value.VT.FILLED_ARRAY) {
                                ArrayValue av = new ArrayValue();
                                av.s = ArrayValue.S.DEFAULT;
                                av.indexType = ArrayValue.IndexType.CONST;
                                av.stmt = stmt;
                                FilledArrayExpr fae = (FilledArrayExpr) stmt.getOp2();
                                av.size = Exprs.nInt(fae.getOps().length);
                                Value[] ops = fae.getOps();
                                for (int i = 0; i < ops.length; i++) {
                                    av.elements1.put(i, ops[i]);
                                }
                                values.add(av);
                                tmp[local._ls_index] = av;
                            } else if (op2.vt == Value.VT.CONSTANT) {
                                Object cst = ((Constant) op2).value;
                                if (cst != null && !cst.equals(Constant.Null) && cst.getClass().isArray()) {
                                    ArrayValue av = new ArrayValue();
                                    av.s = ArrayValue.S.DEFAULT;
                                    av.indexType = ArrayValue.IndexType.CONST;
                                    av.stmt = stmt;
                                    int size = Array.getLength(cst);
                                    av.size = Exprs.nInt(size);
                                    for (int i = 0; i < size; i++) {
                                        av.elements1.put(i, Exprs.nConstant(Array.get(cst, size)));
                                    }
                                    values.add(av);
                                    tmp[local._ls_index] = av;
                                } else {
                                    ArrayValue av = new ArrayValue();
                                    values.add(av);
                                    av.s = ArrayValue.S.UNKNOWN;
                                    av.indexType = ArrayValue.IndexType.NONE;
                                    av.stmt = stmt;
                                    tmp[local._ls_index] = av;
                                }
                            } else {
                                ArrayValue av = new ArrayValue();
                                values.add(av);
                                av.s = ArrayValue.S.UNKNOWN;
                                av.indexType = ArrayValue.IndexType.NONE;
                                av.stmt = stmt;
                                tmp[local._ls_index] = av;
                            }
                        }
                        // assign index1
                    } else if (stmt.getOp1().vt == Value.VT.ARRAY) {
                        use(stmt.getOp2());
                        ArrayExpr ae = (ArrayExpr) stmt.getOp1();
                        if (ae.getOp1().vt == Value.VT.LOCAL) {
                            Local local = (Local) ae.getOp1();
                            Value index = ae.getOp2();
                            if (local._ls_index >= 0) {
                                if (index.vt == Value.VT.CONSTANT) {
                                    ArrayValue parent = tmp[local._ls_index];
                                    ArrayValue av = new ArrayValue();
                                    values.add(av);
                                    av.parent = parent;
                                    av.elements1.put(((Number) (((Constant) index).value)).intValue(), stmt.getOp2());
                                    av.indexType = ArrayValue.IndexType.CONST;
                                    av.s = ArrayValue.S.INHERIT;
                                    av.stmt = stmt;
                                    tmp[local._ls_index] = av;
                                } else if (index.vt == Value.VT.LOCAL) {
                                    ArrayValue parent = tmp[local._ls_index];
                                    ArrayValue av = new ArrayValue();
                                    values.add(av);
                                    av.parent = parent;
                                    av.elements1.put(index, stmt.getOp2());
                                    av.indexType = ArrayValue.IndexType.LOCAL;
                                    av.s = ArrayValue.S.INHERIT;
                                    av.stmt = stmt;
                                    tmp[local._ls_index] = av;
                                } else {
                                    ArrayValue av = new ArrayValue();
                                    values.add(av);
                                    av.s = ArrayValue.S.UNKNOWN;
                                    av.indexType = ArrayValue.IndexType.NONE;
                                    av.stmt = stmt;
                                    tmp[local._ls_index] = av;
                                }
                            } else {
                                use(stmt.getOp1());
                            }
                        } else {
                            use(stmt.getOp1());
                        }

                    } else {
                        use(stmt.getOp1());
                        use(stmt.getOp2());
                    }
                    // assign index2
                } else if (stmt.st == Stmt.ST.FILL_ARRAY_DATA) {
                    if (stmt.getOp1().vt == Value.VT.LOCAL) {
                        Local local = (Local) stmt.getOp1();
                        if (local._ls_index >= 0) {
                            Object array = ((Constant) stmt.getOp2()).value;
                            ArrayValue parent = tmp[local._ls_index];
                            ArrayValue av = new ArrayValue();
                            values.add(av);
                            av.parent = parent;
                            int size = Array.getLength(array);
                            av.size = Exprs.nInt(size);
                            for (int i = 0; i < size; i++) {
                                av.elements1.put(i, Exprs.nConstant(Array.get(array, i)));
                            }
                            av.indexType = ArrayValue.IndexType.CONST;
                            av.s = ArrayValue.S.INHERIT;
                            av.stmt = stmt;
                            tmp[local._ls_index] = av;
                        }
                    } else {
                        use(stmt.getOp1());
                    }
                } else {
                    switch (stmt.et) {
                        case E0:
                            break;
                        case E1:
                            use(stmt.getOp());
                            break;
                        case E2:
                            use(stmt.getOp1());
                            use(stmt.getOp2());
                            break;
                        case En:
                            throw new RuntimeException();
                    }
                }

                return tmp;
            }

            private void use(Value v) {
                switch (v.et) {
                    case E0:
                        break;
                    case E1:
                        use(v.getOp());
                        break;
                    case E2:
                        Value op1 = v.getOp1();
                        Value op2 = v.getOp2();
                        use(op1);
                        use(op2);
                        if (v.vt == Value.VT.ARRAY) {
                            if (op1.vt == Value.VT.LOCAL && (op2.vt == Value.VT.LOCAL || op2.vt == Value.VT.CONSTANT)) {
                                Local local = (Local) op1;
                                if (local._ls_index > 0) {
                                    used.add(currentStmt);
                                }
                            }
                        }
                        break;
                    case En:
                        for (Value op : v.getOps()) {
                            use(op);
                        }
                        break;
                }
            }
        });


        // TODO travel stmt to find must-be array element

        for (Stmt p : method.stmts) {

        }
        new StmtTraveler() {
            @Override
            public Value travel(Value op) {
                op = super.travel(op);
                if (op.vt == Value.VT.ARRAY) {

                }
                return op;
            }
        }.travel(method.stmts);

        return false;
    }",iterator
stmt,"{
        final Set<Local> arrays = new HashSet<>();
        for (Stmt stmt : method.stmts) {
            if (stmt.st == Stmt.ST.ASSIGN) {
                // create an array
                if (stmt.getOp1().vt == Value.VT.LOCAL) {
                    Local local = (Local) stmt.getOp1();
                    if (stmt.getOp2().vt == Value.VT.NEW_ARRAY || stmt.getOp2().vt == Value.VT.FILLED_ARRAY) {
                        arrays.add(local);
                    }
                    // assign index1
                } else if (stmt.getOp1().vt == Value.VT.ARRAY) {
                    ArrayExpr ae = (ArrayExpr) stmt.getOp1();
                    if (ae.getOp1().vt == Value.VT.LOCAL) {
                        Local local = (Local) ae.getOp1();
                        arrays.add(local);
                    }

                }
                // assign index2
            } else if (stmt.st == Stmt.ST.FILL_ARRAY_DATA) {
                if (stmt.getOp1().vt == Value.VT.LOCAL) {
                    Local local = (Local) stmt.getOp1();
                    arrays.add(local);
                }
            }
        }
        return arrays;
    }",iterator
sv,"{
        Set<SimpleLiveValue> used = new HashSet<SimpleLiveValue>(aValues.size() / 2);
        Queue<SimpleLiveValue> q = new UniqueQueue<>();
        for (SimpleLiveValue sv : aValues) {
            if (sv.used) {
                q.add(sv);
                while (!q.isEmpty()) {
                    SimpleLiveValue v = q.poll();
                    if (v.used) {
                        if (used.contains(v)) {
                            continue;
                        }
                        used.add(v);
                        {
                            SimpleLiveValue p = v.parent;
                            if (p != null) {
                                if (!p.used) {
                                    p.used = true;
                                    q.add(p);
                                }
                            }
                        }
                        if (v.otherParents != null) {
                            for (SimpleLiveValue p : v.otherParents) {
                                if (!p.used) {
                                    p.used = true;
                                    q.add(p);
                                }
                            }
                            v.otherParents = null;
                        }
                    }
                }
            }
        }

        return used;
    }",iterator
q,"{
        Set<SimpleLiveValue> used = new HashSet<SimpleLiveValue>(aValues.size() / 2);
        Queue<SimpleLiveValue> q = new UniqueQueue<>();
        for (SimpleLiveValue sv : aValues) {
            if (sv.used) {
                q.add(sv);
                while (!q.isEmpty()) {
                    SimpleLiveValue v = q.poll();
                    if (v.used) {
                        if (used.contains(v)) {
                            continue;
                        }
                        used.add(v);
                        {
                            SimpleLiveValue p = v.parent;
                            if (p != null) {
                                if (!p.used) {
                                    p.used = true;
                                    q.add(p);
                                }
                            }
                        }
                        if (v.otherParents != null) {
                            for (SimpleLiveValue p : v.otherParents) {
                                if (!p.used) {
                                    p.used = true;
                                    q.add(p);
                                }
                            }
                            v.otherParents = null;
                        }
                    }
                }
            }
        }

        return used;
    }",maybe_loop_control
p,"{
        Set<SimpleLiveValue> used = new HashSet<SimpleLiveValue>(aValues.size() / 2);
        Queue<SimpleLiveValue> q = new UniqueQueue<>();
        for (SimpleLiveValue sv : aValues) {
            if (sv.used) {
                q.add(sv);
                while (!q.isEmpty()) {
                    SimpleLiveValue v = q.poll();
                    if (v.used) {
                        if (used.contains(v)) {
                            continue;
                        }
                        used.add(v);
                        {
                            SimpleLiveValue p = v.parent;
                            if (p != null) {
                                if (!p.used) {
                                    p.used = true;
                                    q.add(p);
                                }
                            }
                        }
                        if (v.otherParents != null) {
                            for (SimpleLiveValue p : v.otherParents) {
                                if (!p.used) {
                                    p.used = true;
                                    q.add(p);
                                }
                            }
                            v.otherParents = null;
                        }
                    }
                }
            }
        }

        return used;
    }",iterator
i,"{
        if (distFrame == null) {
            distFrame = new SimpleLiveValue[this.localSize];
            for (int i = 0; i < srcFrame.length; i++) {
                SimpleLiveValue sV = srcFrame[i];
                if (sV != null) {
                    SimpleLiveValue dV = new SimpleLiveValue();
                    aValues.add(dV);
                    dV.parent = sV;
                    distFrame[i] = dV;
                }
            }
        } else {
            for (int i = 0; i < srcFrame.length; i++) {
                SimpleLiveValue sV = srcFrame[i];
                SimpleLiveValue dV = distFrame[i];
                if (sV != null && dV != null) {
                    List<SimpleLiveValue> ps = dV.otherParents;
                    if (ps == null) {
                        dV.otherParents = ps = new ArrayList<>(3);
                    }
                    ps.add(sV);
                }
            }
        }
        return distFrame;
    }",loop_control
local,"{
        super();
        this.method = method;
        if (!reindexLocal) {
            // override the localSize value to the max local index+1
            int maxReg = -1;
            for (Local local : method.locals) {
                if (local._ls_index > maxReg) {
                    maxReg = local._ls_index;
                }
            }
            this.localSize = maxReg + 1;
        } else {
            this.localSize = method.locals.size();
        }
        this.reindexLocal = reindexLocal;
    }",iterator
local,"{
        if (reindexLocal) {
            int index = 0;
            for (Local local : method.locals) {
                local._ls_index = index;
                index++;
            }
        }
        if (DEBUG) {
            int idx = 0;
            for (Stmt s : method.stmts) {
                if (s.st == Stmt.ST.LABEL) {
                    LabelStmt label = (LabelStmt) s;
                    label.displayName = ""L"" + idx++;
                }
            }
        }
        initCFG();
    }",iterator
s,"{
        if (reindexLocal) {
            int index = 0;
            for (Local local : method.locals) {
                local._ls_index = index;
                index++;
            }
        }
        if (DEBUG) {
            int idx = 0;
            for (Stmt s : method.stmts) {
                if (s.st == Stmt.ST.LABEL) {
                    LabelStmt label = (LabelStmt) s;
                    label.displayName = ""L"" + idx++;
                }
            }
        }
        initCFG();
    }",iterator
stmt,"{
        StringBuilder sb = new StringBuilder();
        for (Stmt stmt = method.stmts.getFirst(); stmt != null; stmt = stmt.getNext()) {
            T[] frame = (T[]) stmt.frame;
            if (frame != null) {
                for (T p : frame) {
                    if (p == null) {
                        sb.append('.');
                    } else {
                        sb.append(p.toRsp());
                    }
                }
                sb.append("" | "");
            }
            sb.append(stmt.toString()).append('\n');
        }
        return sb.toString();
    }",maybe_loop_control
p,"{
        StringBuilder sb = new StringBuilder();
        for (Stmt stmt = method.stmts.getFirst(); stmt != null; stmt = stmt.getNext()) {
            T[] frame = (T[]) stmt.frame;
            if (frame != null) {
                for (T p : frame) {
                    if (p == null) {
                        sb.append('.');
                    } else {
                        sb.append(p.toRsp());
                    }
                }
                sb.append("" | "");
            }
            sb.append(stmt.toString()).append('\n');
        }
        return sb.toString();
    }",iterator
i,"{
        if (v == null) {
            return new Value[0];
        }
        Value vb[] = new Value[v.length];
        for (int i = 0; i < v.length; i++) {
            vb[i] = v[i].trim();
        }
        return vb;
    }",loop_control
i,"{
        StringBuilder sb = new StringBuilder().append(""new "").append(Util.toShortClassName(type)).append(""[]{"");
        for (int i = 0; i < ops.length; i++) {
            sb.append(ops[i]).append("", "");
        }
        if (ops.length > 0) {
            sb.setLength(sb.length() - 2); // remove tail "", ""
        }
        sb.append('}');
        return sb.toString();
    }",loop_control
i,"{
        StringBuilder sb = new StringBuilder();
        int i = 0;
        sb.append(ops[i++]).append('.').append(this.method.getName());
        String[] argTypes = getProto().getParameterTypes();
        sb.append('(');
        int j = 0;
        boolean first = true;
        for (; i < ops.length; i++) {
            if (first) {
                first = false;
            } else {
                sb.append(',');
            }
            sb.append(""("").append(Util.toShortClassName(argTypes[j++])).append("")"").append(ops[i]);
        }
        sb.append(')');

        return sb.toString();
    }",loop_control
i,"{
        StringBuilder sb = new StringBuilder();

        int i = 0;
        if (super.vt == VT.INVOKE_NEW) {
            sb.append(""new "").append(Util.toShortClassName(method.getOwner()));
        } else if (super.vt == VT.INVOKE_STATIC) {
            sb.append(Util.toShortClassName(method.getOwner())).append('.')
                    .append(this.method.getName());
        } else {
            sb.append(ops[i++]).append('.').append(this.method.getName());
        }
        sb.append('(');
        boolean first = true;
        for (; i < ops.length; i++) {
            if (first) {
                first = false;
            } else {
                sb.append(',');
            }
            sb.append(ops[i]);
        }
        sb.append(')');
        return sb.toString();
    }",loop_control
i,"{
            Value[] nOps = new Value[ops.length];
            for (int i = 0; i < nOps.length; i++) {
                nOps[i] = ops[i].trim().clone();
            }
            return nOps;
        }",loop_control
i,"{
            Value[] nOps = new Value[ops.length];
            for (int i = 0; i < nOps.length; i++) {
                nOps[i] = ops[i].clone(mapper);
            }
            return nOps;
        }",loop_control
a,"{
        Value a = this;
        while (a.next != null) {
            Value b = a.next;
            a.next = b;
            a = b;
        }
        return a;
    }",maybe_loop_control
dimension,"{
        switch (super.vt) {
        case CHECK_CAST:
            return ""(("" + Util.toShortClassName(type) + "")"" + op + "")"";
        case INSTANCE_OF:
            return ""("" + op + "" instanceof "" + Util.toShortClassName(type) + "")"";
        case NEW_ARRAY:
            if (type.charAt(0) == '[') {
                int dimension = 1;
                while (type.charAt(dimension) == '[') {
                    dimension++;
                }
                StringBuilder sb = new StringBuilder(""new "")
                        .append(Util.toShortClassName(type.substring(dimension))).append(""["").append(op)
                        .append(""]"");
                for (int i = 0; i < dimension; i++) {
                    sb.append(""[]"");
                }
                return sb.toString();
            }
            return ""new "" + Util.toShortClassName(type) + ""["" + op + ""]"";
        default:
        }
        return ""UNKNOW"";
    }",loop_control
i,"{
        switch (super.vt) {
        case CHECK_CAST:
            return ""(("" + Util.toShortClassName(type) + "")"" + op + "")"";
        case INSTANCE_OF:
            return ""("" + op + "" instanceof "" + Util.toShortClassName(type) + "")"";
        case NEW_ARRAY:
            if (type.charAt(0) == '[') {
                int dimension = 1;
                while (type.charAt(dimension) == '[') {
                    dimension++;
                }
                StringBuilder sb = new StringBuilder(""new "")
                        .append(Util.toShortClassName(type.substring(dimension))).append(""["").append(op)
                        .append(""]"");
                for (int i = 0; i < dimension; i++) {
                    sb.append(""[]"");
                }
                return sb.toString();
            }
            return ""new "" + Util.toShortClassName(type) + ""["" + op + ""]"";
        default:
        }
        return ""UNKNOW"";
    }",loop_control
i,"{
        if (Null == value) {
            return ""null"";
        } else if (value == null) {
            return ""NULL"";
        } else if (value instanceof Number) {
            if (value instanceof Float) {
                return value.toString() + ""F"";
            }
            if (value instanceof Long) {
                return value.toString() + ""L"";
            }
            return value.toString();
        } else if (value instanceof String) {
            StringBuffer buf = new StringBuffer();
            Util.appendString(buf, (String) value);
            return buf.toString();
        } else if (value instanceof DexType) {
            return Util.toShortClassName(((DexType) value).desc) + "".class"";
        } else if (value.getClass().isArray()) {
            StringBuilder sb = new StringBuilder();
            sb.append(""["");
            int size = Array.getLength(value);
            for (int i = 0; i < size; i++) {
                sb.append(Array.get(value, i)).append("","");
            }
            if (size > 0) {
                sb.setLength(sb.length() - 1);
            }
            sb.append(""]"");
            return sb.toString();
        }
        return """" + value;
    }",loop_control
vb,"{
        StringBuilder sb = new StringBuilder(""φ("");
        boolean first = true;
        for (Value vb : ops) {
            if (first) {
                first = false;
            } else {
                sb.append("", "");
            }
            sb.append(vb);
        }
        sb.append("")"");
        return sb.toString();
    }",iterator
op,"{
        StringBuilder sb = new StringBuilder();
        sb.append(""new "").append(Util.toShortClassName(baseType));
        for (Value op : ops) {
            sb.append('[').append(op).append(']');
        }
        for (int i = ops.length; i < dimension; i++) {
            sb.append(""[]"");
        }
        return sb.toString();
    }",iterator
i,"{
        StringBuilder sb = new StringBuilder();
        sb.append(""new "").append(Util.toShortClassName(baseType));
        for (Value op : ops) {
            sb.append('[').append(op).append(']');
        }
        for (int i = ops.length; i < dimension; i++) {
            sb.append(""[]"");
        }
        return sb.toString();
    }",loop_control
stmt,"{
        for (Stmt stmt : list) {
            insertLast(stmt);
        }
    }",iterator
stmt,"{
        StmtList nList = new StmtList();
        for (Stmt stmt : this) {
            nList.add(stmt.clone(mapper));
        }
        return nList;
    }",iterator
s,"{
        if (this.size == 0) {
            return ""[Empty]"";
        }
        StringBuilder sb = new StringBuilder();
        for (Stmt s : this) {
            if (s.st == ST.LABEL) {
                sb.append(""\n"");
            }
            sb.append(s).append(""\n"");
        }
        return sb.toString();
    }",iterator
i,"{
        LabelStmt[] nTargets = new LabelStmt[targets.length];
        for (int i = 0; i < nTargets.length; i++) {
            nTargets[i] = mapper.map(targets[i]);
        }
        return new TableSwitchStmt(op.clone(mapper), lowIndex, nTargets, mapper.map(defaultTarget));
    }",loop_control
i,"{
        StringBuilder sb = new StringBuilder(""switch("").append(op).append("") {"");

        for (int i = 0; i < targets.length; i++) {
            sb.append(""\n case "").append(lowIndex + i).append("": GOTO "").append(targets[i].getDisplayName())
                    .append("";"");
        }
        sb.append(""\n default : GOTO "").append(defaultTarget.getDisplayName()).append("";"");
        sb.append(""\n}"");
        return sb.toString();
    }",loop_control
i,"{
        LabelStmt[] nTargets = new LabelStmt[targets.length];
        for (int i = 0; i < nTargets.length; i++) {
            nTargets[i] = mapper.map(targets[i]);
        }
        int nLookupValues[] = new int[lookupValues.length];
        System.arraycopy(lookupValues, 0, nLookupValues, 0, nLookupValues.length);

        return new LookupSwitchStmt(op.clone(mapper), nLookupValues, nTargets, mapper.map(defaultTarget));
    }",loop_control
i,"{
        StringBuilder sb = new StringBuilder(""switch("").append(op).append("") {"");

        for (int i = 0; i < lookupValues.length; i++) {
            sb.append(""\n case "").append(lookupValues[i]).append("": GOTO "").append(targets[i].getDisplayName())
                    .append("";"");
        }
        sb.append(""\n default : GOTO "").append(defaultTarget.getDisplayName()).append("";"");
        sb.append(""\n}"");
        return sb.toString();
    }",loop_control
phi,"{
        LabelStmt labelStmt = mapper.map(this);
        if (phis != null && labelStmt.phis == null) {
            labelStmt.phis = new ArrayList<>(phis.size());
            for (AssignStmt phi : phis) {
                labelStmt.phis.add((AssignStmt) phi.clone(mapper));
            }
        }
        return labelStmt;
    }",iterator
v,"{
    ConstPool cp;
    List<AnnotationElement> elements;

    public AnnotationWriter(List<AnnotationElement> elements, ConstPool cp) {
        this.elements = elements;
        this.cp = cp;
    }

    AnnotationElement newAnnotationElement(String name) {
        AnnotationElement ae = new AnnotationElement();
        ae.name = cp.uniqString(name);
        elements.add(ae);
        return ae;
    }

    // int,int long
    public void visit(String name, Object value) {
        if (value instanceof Object[]) {
            DexAnnotationVisitor s = visitArray(name);
            if (s != null) {
                for (Object v : (Object[]) value) {
                    s.visit(null, v);
                }
                s.visitEnd();
            }
        } else {
            AnnotationElement ae = newAnnotationElement(name);
            ae.value = EncodedValue.wrap(cp.wrapEncodedItem(value));
        }
    }

    @Override
    public DexAnnotationVisitor visitAnnotation(String name, String desc) {
        EncodedValue encodedValue;
        EncodedAnnotation encodedAnnotation = new EncodedAnnotation();
        encodedAnnotation.type = cp.uniqType(desc);
        encodedValue = new EncodedValue(EncodedValue.VALUE_ANNOTATION,
                encodedAnnotation);
        AnnotationElement ae = newAnnotationElement(name);
        ae.value = encodedValue;
        return new AnnotationWriter(encodedAnnotation.elements, cp);
    }

    @Override
    public DexAnnotationVisitor visitArray(String name) {
        AnnotationElement ae = newAnnotationElement(name);
        final EncodedArray encodedArray = new EncodedArray();
        ae.value = new EncodedValue(EncodedValue.VALUE_ARRAY, encodedArray);
        return new EncodedArrayAnnWriter(encodedArray);
    }

    @Override
    public void visitEnum(String name, String fower, String fname) {
        AnnotationElement ae = newAnnotationElement(name);
        ae.value = new EncodedValue(EncodedValue.VALUE_ENUM, cp.uniqField(
                fower, fname, fower));
    }

    class EncodedArrayAnnWriter extends DexAnnotationVisitor {
        final EncodedArray encodedArray;

        public EncodedArrayAnnWriter(EncodedArray encodedArray) {
            super();
            this.encodedArray = encodedArray;
        }

        @Override
        public void visit(String name, Object value) {
            EncodedValue encodedValue;
            if (value instanceof String) {
                encodedValue = new EncodedValue(EncodedValue.VALUE_STRING,
                        cp.uniqString((String) value));
            } else if (value instanceof DexType) {
                encodedValue = new EncodedValue(EncodedValue.VALUE_TYPE,
                        cp.uniqType(((DexType) value).desc));
            } else {
                encodedValue = EncodedValue.wrap(value);
            }
            encodedArray.values.add(encodedValue);
        }

        @Override
        public DexAnnotationVisitor visitAnnotation(String name, String desc) {
            EncodedValue encodedValue;
            EncodedAnnotation encodedAnnotation = new EncodedAnnotation();
            encodedAnnotation.type = cp.uniqType(desc);
            encodedValue = new EncodedValue(EncodedValue.VALUE_ANNOTATION,
                    encodedAnnotation);
            encodedArray.values.add(encodedValue);
            return new AnnotationWriter(encodedAnnotation.elements, cp);
        }

        @Override
        public DexAnnotationVisitor visitArray(String name) {
            EncodedValue encodedValue;
            encodedValue = new EncodedValue(EncodedValue.VALUE_ARRAY,
                    encodedArray);
            encodedArray.values.add(encodedValue);
            return new EncodedArrayAnnWriter(encodedArray);
        }

        @Override
        public void visitEnum(String name, String fower, String fname) {
            EncodedValue encodedValue;
            encodedValue = new EncodedValue(EncodedValue.VALUE_ENUM,
                    cp.uniqField(fower, fname, fower));
            encodedArray.values.add(encodedValue);
        }

    }
}",iterator
s,"{
        this.encodedMethod = encodedMethod;
        this.codeItem = codeItem;
        this.owner = owner;
        int in_reg_size = 0;
        if (!isStatic) {
            in_reg_size++;
        }
        for (String s : owner.getParameterTypes()) {
            switch (s.charAt(0)) {
            case 'J':
            case 'D':
                in_reg_size += 2;
                break;
            default:
                in_reg_size++;
                break;
            }
        }
        this.in_reg_size = in_reg_size;
        this.cp = cp;
    }",iterator
s,"{

        ByteBuffer b;

        if (value instanceof byte[]) {
            byte[] data = (byte[]) value;
            int size = data.length;
            int element_width = 1;
            b = ByteBuffer.allocate(((size * element_width + 1) / 2 + 4) * 2).order(ByteOrder.LITTLE_ENDIAN);
            b.putShort((short) 0x0300);
            b.putShort((short) element_width);
            b.putInt(size);
            b.put(data);
        } else if (value instanceof short[]) {
            short[] data = (short[]) value;
            int size = data.length;
            int element_width = 2;
            b = ByteBuffer.allocate(((size * element_width + 1) / 2 + 4) * 2).order(ByteOrder.LITTLE_ENDIAN);
            b.putShort((short) 0x0300);
            b.putShort((short) element_width);
            b.putInt(size);
            for (short s : data) {
                b.putShort(s);
            }
        } else if (value instanceof int[]) {
            int[] data = (int[]) value;
            int size = data.length;
            int element_width = 4;
            b = ByteBuffer.allocate(((size * element_width + 1) / 2 + 4) * 2).order(ByteOrder.LITTLE_ENDIAN);
            b.putShort((short) 0x0300);
            b.putShort((short) element_width);
            b.putInt(size);
            for (int s : data) {
                b.putInt(s);
            }
        } else if (value instanceof float[]) {
            float[] data = (float[]) value;
            int size = data.length;
            int element_width = 4;
            b = ByteBuffer.allocate(((size * element_width + 1) / 2 + 4) * 2).order(ByteOrder.LITTLE_ENDIAN);
            b.putShort((short) 0x0300);
            b.putShort((short) element_width);
            b.putInt(size);
            for (float s : data) {
                b.putInt(Float.floatToIntBits(s));
            }
        } else if (value instanceof long[]) {
            long[] data = (long[]) value;
            int size = data.length;
            int element_width = 8;
            b = ByteBuffer.allocate(((size * element_width + 1) / 2 + 4) * 2).order(ByteOrder.LITTLE_ENDIAN);
            b.putShort((short) 0x0300);
            b.putShort((short) element_width);
            b.putInt(size);
            for (long s : data) {
                b.putLong(s);
            }
        } else if (value instanceof double[]) {
            double[] data = (double[]) value;
            int size = data.length;
            int element_width = 8;
            b = ByteBuffer.allocate(((size * element_width + 1) / 2 + 4) * 2).order(ByteOrder.LITTLE_ENDIAN);
            b.putShort((short) 0x0300);
            b.putShort((short) element_width);
            b.putInt(size);
            for (double s : data) {
                b.putLong(Double.doubleToLongBits(s));
            }
        } else {
            throw new RuntimeException();
        }
        Label d = new Label();
        ops.add(new JumpOp(op, ra, 0, d));

        tailOps.add(d);
        tailOps.add(new PreBuildInsn(b.array()));

    }",iterator
i,"{
        Label switch_data_location = new Label();
        final JumpOp jumpOp = new JumpOp(op, aA, 0, switch_data_location);
        ops.add(jumpOp);

        tailOps.add(switch_data_location);
        tailOps.add(new Insn() {

            @Override
            public int getCodeUnitSize() {
                return (labels.length * 2) + 4;
            }

            @Override
            public void write(ByteBuffer out) {
                out.putShort((short) 0x0100).putShort((short) labels.length).putInt(first_case);

                for (int i = 0; i < labels.length; i++) {
                    out.putInt(getLabel(labels[i]).offset - jumpOp.offset);
                }
            }
        });
    }",loop_control
i,"{
        Label switch_data_location = new Label();
        final JumpOp jumpOp = new JumpOp(op, ra, 0, switch_data_location);
        ops.add(jumpOp);

        tailOps.add(switch_data_location);
        tailOps.add(new Insn() {

            @Override
            public int getCodeUnitSize() {
                return (cases.length * 4) + 2;
            }

            @Override
            public void write(ByteBuffer out) {
                out.putShort((short) 0x0200).putShort((short) cases.length);
                for (int i = 0; i < cases.length; i++) {
                    out.putInt(cases[i]);
                }
                for (int i = 0; i < cases.length; i++) {
                    out.putInt(getLabel(labels[i]).offset - jumpOp.offset);
                }
            }
        });

    }",loop_control
i,"{
        CodeItem.TryItem tryItem = new CodeItem.TryItem();
        tryItem.start = getLabel(start);
        tryItem.end = getLabel(end);
        CodeItem.EncodedCatchHandler ech = new CodeItem.EncodedCatchHandler();
        tryItem.handler = ech;
        tryItems.add(tryItem);
        ech.addPairs = new ArrayList<>(types.length);
        for (int i = 0; i < types.length; i++) {
            String type = types[i];
            Label label = getLabel(handlers[i]);
            if (type == null) {
                ech.catchAll = label;
            } else {
                ech.addPairs.add(new CodeItem.EncodedCatchHandler.AddrPair(cp.uniqType(type), label));
            }
        }
    }",loop_control
i,"{
            super(op);
            this.item = item;
            length = args.length;
            checkContentUByte(op, ""AA"", length);
            if (length > 0) {
                start = args[0];
                checkContentUShort(op, ""CCCC"", start);
                for (int i = 1; i < args.length; i++) {
                    if (start + i != args[i]) {
                        throw new CantNotFixContentException(op, ""a"", args[i]);
                    }
                }
            } else {
                start = 0;
            }

        }",loop_control
i,"{
        return (DataOut) Proxy.newProxyInstance(
                DexFileWriter.class.getClassLoader(),
                new Class[]{DataOut.class}, new InvocationHandler() {
            int indent = 0;

            @Override
            public Object invoke(Object proxy, Method method,
                                 Object[] args) throws Throwable {

                if (method.getParameterTypes().length > 0
                        && method.getParameterTypes()[0]
                        .equals(String.class)) {
                    StringBuilder sb = new StringBuilder();
                    for (int i = 0; i < indent; i++) {
                        sb.append(""  "");
                    }
                    sb.append(String.format(""%05d "", out0.offset()));
                    sb.append(method.getName() + "" ["");
                    for (Object arg : args) {
                        if (arg instanceof byte[]) {
                            byte[] data = (byte[]) arg;
                            sb.append(""0x["");
                            int start = 0;
                            int size = data.length;
                            if (args.length > 2) {
                                start = (Integer) args[2];
                                size = (Integer) args[3];
                            }
                            for (int i = 0; i < size; i++) {
                                sb.append(String.format(""%02x"",
                                        data[start + i] & 0xff));
                                if (i != size - 1) {
                                    sb.append("", "");
                                }
                            }

                            sb.append(""], "");
                        } else {
                            sb.append(arg).append("", "");
                        }

                    }
                    sb.append(""]"");
                    System.out.println(sb);
                }
                if (method.getName().equals(""begin"")) {
                    indent++;
                }
                if (method.getName().equals(""end"")) {
                    indent--;
                }
                return method.invoke(out0, args);
            }
        });

    }",loop_control
arg,"{
        return (DataOut) Proxy.newProxyInstance(
                DexFileWriter.class.getClassLoader(),
                new Class[]{DataOut.class}, new InvocationHandler() {
            int indent = 0;

            @Override
            public Object invoke(Object proxy, Method method,
                                 Object[] args) throws Throwable {

                if (method.getParameterTypes().length > 0
                        && method.getParameterTypes()[0]
                        .equals(String.class)) {
                    StringBuilder sb = new StringBuilder();
                    for (int i = 0; i < indent; i++) {
                        sb.append(""  "");
                    }
                    sb.append(String.format(""%05d "", out0.offset()));
                    sb.append(method.getName() + "" ["");
                    for (Object arg : args) {
                        if (arg instanceof byte[]) {
                            byte[] data = (byte[]) arg;
                            sb.append(""0x["");
                            int start = 0;
                            int size = data.length;
                            if (args.length > 2) {
                                start = (Integer) args[2];
                                size = (Integer) args[3];
                            }
                            for (int i = 0; i < size; i++) {
                                sb.append(String.format(""%02x"",
                                        data[start + i] & 0xff));
                                if (i != size - 1) {
                                    sb.append("", "");
                                }
                            }

                            sb.append(""], "");
                        } else {
                            sb.append(arg).append("", "");
                        }

                    }
                    sb.append(""]"");
                    System.out.println(sb);
                }
                if (method.getName().equals(""begin"")) {
                    indent++;
                }
                if (method.getName().equals(""end"")) {
                    indent--;
                }
                return method.invoke(out0, args);
            }
        });

    }",iterator
i,"{
        List<SectionItem<?>> list = new ArrayList<>(mapItem.items);
        // mapItem is useless now
        this.mapItem = null;
        for (int i = 0; i < list.size(); i++) {
            SectionItem<?> section = list.get(i);
            list.set(i, null);
            BaseItem.addPadding(out, out.offset(),
                    section.sectionType.alignment);
            if (out.offset() != section.offset) {
                throw new RuntimeException(section.sectionType
                        + "" start with different position, planned:""
                        + section.offset + "", but is:"" + out.offset());
            }
            section.write(out);
        }
    }",loop_control
section,"{
        // 2. order
        mapItem.cleanZeroSizeEntry();

        // 3. place
        int offset = 0;
        // int index = 0;
        for (SectionItem<?> section : mapItem.items) {

            offset = BaseItem.padding(offset, section.sectionType.alignment);
            section.offset = offset;
            // section.index = index;
            // index++;
            offset = section.place(offset);
        }
        int size = offset;
        { // fix size
            headItem.fileSize = size;
            // headItem is useless now
            this.headItem = null;
        }
        return size;
    }",iterator
ae,"{
        offset += BaseItem.lengthOfUleb128(type.index);
        offset += BaseItem.lengthOfUleb128(elements.size());
        for (AnnotationElement ae : elements) {
            offset += BaseItem.lengthOfUleb128(ae.name.index);
            offset = ae.value.place(offset);
        }
        return offset;
    }",iterator
ae,"{
        out.uleb128(""type_idx"", type.index);
        out.uleb128(""size"", elements.size());
        for (AnnotationElement ae : elements) {
            out.uleb128(""name_idx"", ae.name.index);
            ae.value.write(out);
        }
    }",iterator
i,"{
        value >>= 64 - (requiredBytes * 8);
        byte[] s = new byte[requiredBytes];
        for (int i = 0; i < requiredBytes; i++) {
            s[i] = ((byte) value);
            value >>= 8;
        }
        return s;
    }",loop_control
ev,"{
        offset += BaseItem.lengthOfUleb128(values.size());
        for (EncodedValue ev : values) {
            offset = ev.place(offset);
        }
        return offset;
    }",iterator
ev,"{
        out.uleb128(""size"", values.size());
        for (EncodedValue ev : values) {
            ev.write(out);
        }
    }",iterator
remaining,"{
        int remaining = value >>> 7;

        while (remaining != 0) {
            buffer.put((byte) ((value & 0x7f) | 0x80));
            value = remaining;
            remaining >>>= 7;
        }

        buffer.put((byte) (value & 0x7f));
    }",loop_control
hasMore,"{
        int remaining = value >> 7;
        boolean hasMore = true;
        int end = ((value & Integer.MIN_VALUE) == 0) ? 0 : -1;

        while (hasMore) {
            hasMore = (remaining != end)
                    || ((remaining & 1) != ((value >> 6) & 1));

            buffer.put((byte) ((value & 0x7f) | (hasMore ? 0x80 : 0)));
            value = remaining;
            remaining >>= 7;
        }

    }",maybe_loop_control
s,"{
        StringBuilder sb = new StringBuilder();
        if (ret.length() == 1) {
            sb.append(ret);
        } else {
            sb.append(""L"");
        }
        for (String s : types2) {
            if (s.length() == 1) {
                sb.append(s);
            } else {
                sb.append(""L"");
            }
        }
        return sb.toString();
    }",iterator
c,"{
        List<ClassDefItem> added = new ArrayList<>();
        Stack<PE> stack1 = new Stack<>();
        Set<ClassDefItem> children = new HashSet<>();

        for (ClassDefItem c : classDefs.values()) {
            if (added.contains(c)) {
                continue;
            }
            children.add(c);
            stack1.push(iterateParent(c));

            while (!stack1.empty()) {
                PE e = stack1.peek();
                boolean canPop = true;
                while (e.it.hasNext()) {
                    TypeIdItem tid = e.it.next();
                    if (tid == null) {
                        continue;
                    }
                    ClassDefItem superDef = classDefs.get(tid);
                    if (superDef != null && !added.contains(superDef)) {
                        if (children.contains(superDef)) {
                            System.err.println(""WARN: dep-loop "" + e.owner.clazz.descriptor.stringData.string + "" -> ""
                                    + superDef.clazz.descriptor.stringData.string);
                        } else {
                            canPop = false;
                            children.add(superDef);
                            stack1.push(iterateParent(superDef));
                            break;
                        }
                    }
                }
                if (canPop) {
                    stack1.pop();
                    added.add(e.owner);
                    children.remove(e.owner);
                }
            }
            children.clear();
        }
        return added;
    }",iterator
stack1,"{
        List<ClassDefItem> added = new ArrayList<>();
        Stack<PE> stack1 = new Stack<>();
        Set<ClassDefItem> children = new HashSet<>();

        for (ClassDefItem c : classDefs.values()) {
            if (added.contains(c)) {
                continue;
            }
            children.add(c);
            stack1.push(iterateParent(c));

            while (!stack1.empty()) {
                PE e = stack1.peek();
                boolean canPop = true;
                while (e.it.hasNext()) {
                    TypeIdItem tid = e.it.next();
                    if (tid == null) {
                        continue;
                    }
                    ClassDefItem superDef = classDefs.get(tid);
                    if (superDef != null && !added.contains(superDef)) {
                        if (children.contains(superDef)) {
                            System.err.println(""WARN: dep-loop "" + e.owner.clazz.descriptor.stringData.string + "" -> ""
                                    + superDef.clazz.descriptor.stringData.string);
                        } else {
                            canPop = false;
                            children.add(superDef);
                            stack1.push(iterateParent(superDef));
                            break;
                        }
                    }
                }
                if (canPop) {
                    stack1.pop();
                    added.add(e.owner);
                    children.remove(e.owner);
                }
            }
            children.clear();
        }
        return added;
    }",maybe_loop_control
e,"{
        List<ClassDefItem> added = new ArrayList<>();
        Stack<PE> stack1 = new Stack<>();
        Set<ClassDefItem> children = new HashSet<>();

        for (ClassDefItem c : classDefs.values()) {
            if (added.contains(c)) {
                continue;
            }
            children.add(c);
            stack1.push(iterateParent(c));

            while (!stack1.empty()) {
                PE e = stack1.peek();
                boolean canPop = true;
                while (e.it.hasNext()) {
                    TypeIdItem tid = e.it.next();
                    if (tid == null) {
                        continue;
                    }
                    ClassDefItem superDef = classDefs.get(tid);
                    if (superDef != null && !added.contains(superDef)) {
                        if (children.contains(superDef)) {
                            System.err.println(""WARN: dep-loop "" + e.owner.clazz.descriptor.stringData.string + "" -> ""
                                    + superDef.clazz.descriptor.stringData.string);
                        } else {
                            canPop = false;
                            children.add(superDef);
                            stack1.push(iterateParent(superDef));
                            break;
                        }
                    }
                }
                if (canPop) {
                    stack1.pop();
                    added.add(e.owner);
                    children.remove(e.owner);
                }
            }
            children.clear();
        }
        return added;
    }",maybe_loop_control
s,"{
        if (subList.length == 0) {
            return ZERO_SIZE_TYPE_LIST;
        }
        List<TypeIdItem> idItems = new ArrayList<>(subList.length);
        for (String s : subList) {
            idItems.add(uniqType(s));
        }
        TypeListItem key = new TypeListItem(idItems);
        TypeListItem item = typeLists.get(key);
        if (item != null) {
            return item;
        }
        typeLists.put(key, key);
        return key;
    }",iterator
s,"{
        if (subList.size() == 0) {
            return ZERO_SIZE_TYPE_LIST;
        }
        List<TypeIdItem> idItems = new ArrayList<>(subList.size());
        for (String s : subList) {
            idItems.add(uniqType(s));
        }
        TypeListItem key = new TypeListItem(idItems);
        TypeListItem item = typeLists.get(key);
        if (item != null) {
            return item;
        }
        typeLists.put(key, key);
        return key;
    }",iterator
annotationItem,"{
        List<AnnotationItem> copy = new ArrayList<AnnotationItem>(key.annotations);
        key.annotations.clear();
        for (AnnotationItem annotationItem : copy) {
            key.annotations.add(uniqAnnotationItem(annotationItem));
        }
        AnnotationSetItem v = annotationSetItems.get(key);
        if (v != null) {
            return v;
        }
        annotationSetItems.put(key, key);
        return key;
    }",iterator
i,"{
        for (int i = 0; i < key.annotationSets.length; i++) {
            AnnotationSetItem anno = key.annotationSets[i];
            if (anno != null) {
                key.annotationSets[i] = uniqAnnotationSetItem(anno);
            }
        }
        AnnotationSetRefListItem v = annotationSetRefListItems.get(key);
        if (v == null) {
            annotationSetRefListItems.put(key, key);
            return key;
        }
        return v;
    }",loop_control
item,"{
        out.uint(""size"", annotationSets.length);
        for (AnnotationSetItem item : annotationSets) {
            out.uint(""annotations_off"", item == null ? 0 : item.offset);
        }
    }",iterator
s,"{
        offset += lengthOfUleb128(firstLine);
        if (parameterNames == null) {
            offset += lengthOfUleb128(0);
        } else {
            offset += lengthOfUleb128(parameterNames.length);
            for (StringIdItem s : parameterNames) {
                offset += lengthOfUleb128(1 + (s == null ? -1 : s.index));
            }

        }
        int line = firstLine;
        int addr = 0;

        if (fileName != null) {
            offset += 1;
            offset += lengthOfUleb128(fileName.index + 1);
        }
        for (DNode opNode : debugNodes) {
            switch (opNode.op) {
            case DBG_START_LOCAL_EXTENDED:
                offset += lengthOfUleb128(opNode.sig.index + 1);
                // through;
            case DBG_START_LOCAL: {
                int pcData = opNode.label.offset - addr;
                if (pcData < 0) {
                    throw new RuntimeException();
                } else if (pcData > 0) {
                    // add an addvance_PC
                    offset += 1;
                    offset += lengthOfUleb128(pcData);
                }
                addr = opNode.label.offset;
            }
                offset += 1;// op;
                offset += lengthOfUleb128(opNode.reg);
                offset += lengthOfUleb128(opNode.name.index + 1);
                offset += lengthOfUleb128(opNode.type.index + 1);
                break;
            case DBG_RESTART_LOCAL:
            case DBG_END_LOCAL: {
                int pcData = opNode.label.offset - addr;
                if (pcData < 0) {
                    throw new RuntimeException();
                } else if (pcData > 0) {
                    // add an addvance_PC
                    offset += 1;
                    offset += lengthOfUleb128(pcData);
                }
                addr = opNode.label.offset;
            }
                offset += 1;// op;
                offset += lengthOfUleb128(opNode.reg);
                break;
            case DBG_SET_EPILOGUE_BEGIN:
            case DBG_SET_PROLOGUE_END:
                offset += 1;
                break;
            case DBG_SET_FILE:
                throw new RuntimeException();
            default:
                int lineDelta = opNode.line - line;
                int addrDelta = opNode.label.offset - addr;
                if (addrDelta < 0) {
                    throw new RuntimeException();
                }
                if (opNode.label.offset == 0 && lineDelta == 0 && addrDelta == 0) { // first line;
                    break;
                }
                if ((lineDelta >= -4 && lineDelta <= 10) && addrDelta <= 15) {
                    // do nothing
                } else {
                    if (addrDelta > 15) { // pc not ok, add addvance_PC
                        offset += 1;
                        offset += lengthOfUleb128(addrDelta);
                        addrDelta = 0;
                    }
                    if (lineDelta < -4 || lineDelta > 10) { // line not ok, add DBG_ADVANCE_LINE
                        offset += 1;
                        offset += lengthOfSleb128(lineDelta);
                        lineDelta = 0;
                    }
                }
                // int op = lineDelta + 4 + addrDelta * DBG_LINE_RANGE + DBG_FIRST_SPECIAL;
                offset += 1;
                line = opNode.line;
                addr = opNode.label.offset;
                break;
            }

        }
        offset += 1;// end sequence;

        return offset;
    }",iterator
opNode,"{
        offset += lengthOfUleb128(firstLine);
        if (parameterNames == null) {
            offset += lengthOfUleb128(0);
        } else {
            offset += lengthOfUleb128(parameterNames.length);
            for (StringIdItem s : parameterNames) {
                offset += lengthOfUleb128(1 + (s == null ? -1 : s.index));
            }

        }
        int line = firstLine;
        int addr = 0;

        if (fileName != null) {
            offset += 1;
            offset += lengthOfUleb128(fileName.index + 1);
        }
        for (DNode opNode : debugNodes) {
            switch (opNode.op) {
            case DBG_START_LOCAL_EXTENDED:
                offset += lengthOfUleb128(opNode.sig.index + 1);
                // through;
            case DBG_START_LOCAL: {
                int pcData = opNode.label.offset - addr;
                if (pcData < 0) {
                    throw new RuntimeException();
                } else if (pcData > 0) {
                    // add an addvance_PC
                    offset += 1;
                    offset += lengthOfUleb128(pcData);
                }
                addr = opNode.label.offset;
            }
                offset += 1;// op;
                offset += lengthOfUleb128(opNode.reg);
                offset += lengthOfUleb128(opNode.name.index + 1);
                offset += lengthOfUleb128(opNode.type.index + 1);
                break;
            case DBG_RESTART_LOCAL:
            case DBG_END_LOCAL: {
                int pcData = opNode.label.offset - addr;
                if (pcData < 0) {
                    throw new RuntimeException();
                } else if (pcData > 0) {
                    // add an addvance_PC
                    offset += 1;
                    offset += lengthOfUleb128(pcData);
                }
                addr = opNode.label.offset;
            }
                offset += 1;// op;
                offset += lengthOfUleb128(opNode.reg);
                break;
            case DBG_SET_EPILOGUE_BEGIN:
            case DBG_SET_PROLOGUE_END:
                offset += 1;
                break;
            case DBG_SET_FILE:
                throw new RuntimeException();
            default:
                int lineDelta = opNode.line - line;
                int addrDelta = opNode.label.offset - addr;
                if (addrDelta < 0) {
                    throw new RuntimeException();
                }
                if (opNode.label.offset == 0 && lineDelta == 0 && addrDelta == 0) { // first line;
                    break;
                }
                if ((lineDelta >= -4 && lineDelta <= 10) && addrDelta <= 15) {
                    // do nothing
                } else {
                    if (addrDelta > 15) { // pc not ok, add addvance_PC
                        offset += 1;
                        offset += lengthOfUleb128(addrDelta);
                        addrDelta = 0;
                    }
                    if (lineDelta < -4 || lineDelta > 10) { // line not ok, add DBG_ADVANCE_LINE
                        offset += 1;
                        offset += lengthOfSleb128(lineDelta);
                        lineDelta = 0;
                    }
                }
                // int op = lineDelta + 4 + addrDelta * DBG_LINE_RANGE + DBG_FIRST_SPECIAL;
                offset += 1;
                line = opNode.line;
                addr = opNode.label.offset;
                break;
            }

        }
        offset += 1;// end sequence;

        return offset;
    }",iterator
opNode,"{
        out.uleb128(""startline"", firstLine);
        if (parameterNames == null) {
            out.uleb128(""szParams"", 0);
        } else {
            out.uleb128(""szParams"", parameterNames.length);
            for (StringIdItem s : parameterNames) {
                out.uleb128p1(""param_name_index"", s == null ? -1 : s.index);
            }
        }
        int line = firstLine;
        int addr = 0;

        if (fileName != null) {
            out.sbyte(""DBG_SET_FILE"", DBG_SET_FILE);
            out.uleb128p1(""filename"", fileName.index);
        }
        for (DNode opNode : debugNodes) {
            switch (opNode.op) {
            case DBG_START_LOCAL_EXTENDED: {
                int pcDelta = opNode.label.offset - addr;
                if (pcDelta < 0) {
                    throw new RuntimeException();
                } else if (pcDelta > 0) {
                    addAdvancePC(out, pcDelta);
                }
                addr = opNode.label.offset;
            }
                out.sbyte(""DBG_START_LOCAL_EXTENDED"", DBG_START_LOCAL_EXTENDED);
                out.uleb128(""reg"", opNode.reg);
                out.uleb128p1(""name"", opNode.name.index);
                out.uleb128p1(""type"", opNode.type.index);
                out.uleb128p1(""sig"", opNode.sig.index);
                break;
            case DBG_START_LOCAL: {
                int pcDelta = opNode.label.offset - addr;
                if (pcDelta < 0) {
                    throw new RuntimeException();
                } else if (pcDelta > 0) {
                    addAdvancePC(out, pcDelta);
                }
                addr = opNode.label.offset;
            }
                out.sbyte(""DBG_START_LOCAL"", DBG_START_LOCAL);
                out.uleb128(""reg"", opNode.reg);
                out.uleb128p1(""name"", opNode.name.index);
                out.uleb128p1(""type"", opNode.type.index);

                break;
            case DBG_RESTART_LOCAL: {
                int pcDelta = opNode.label.offset - addr;
                if (pcDelta < 0) {
                    throw new RuntimeException();
                } else if (pcDelta > 0) {
                    addAdvancePC(out, pcDelta);
                }
                addr = opNode.label.offset;
            }

                out.sbyte(""DBG_RESTART_LOCAL"", DBG_RESTART_LOCAL);
                out.uleb128(""reg"", opNode.reg);
                break;
            case DBG_END_LOCAL: {
                int pcDelta = opNode.label.offset - addr;
                if (pcDelta < 0) {
                    throw new RuntimeException();
                } else if (pcDelta > 0) {
                    addAdvancePC(out, pcDelta);
                }
                addr = opNode.label.offset;
            }

                out.sbyte(""DBG_END_LOCAL"", DBG_END_LOCAL);
                out.uleb128(""reg"", opNode.reg);
                break;
            case DBG_SET_EPILOGUE_BEGIN:
                out.sbyte(""DBG_SET_EPILOGUE_BEGIN"", DBG_SET_EPILOGUE_BEGIN);
                break;
            case DBG_SET_PROLOGUE_END:
                out.sbyte(""DBG_SET_PROLOGUE_END"", DBG_SET_PROLOGUE_END);
                break;
            case DBG_SET_FILE:
                throw new RuntimeException();
            default:
                int lineDelta = opNode.line - line;
                int addrDelta = opNode.label.offset - addr;
                if (addrDelta < 0) {
                    throw new RuntimeException();
                }
                if (opNode.label.offset == 0 && lineDelta == 0 && addrDelta == 0) { // first line;
                    break;
                }
                if ((lineDelta >= -4 && lineDelta <= 10) && addrDelta <= 15) {
                    // do nothing
                } else {
                    if (addrDelta > 15) { // pc not ok, add addvance_PC
                        addAdvancePC(out, addrDelta);
                        addrDelta = 0;
                    }
                    if (lineDelta < -4 || lineDelta > 10) { // line not ok, add DBG_ADVANCE_LINE
                        addAdvanceLine(out, lineDelta);
                        lineDelta = 0;
                    }
                }
                int op = lineDelta + 4 + addrDelta * DBG_LINE_RANGE + DBG_FIRST_SPECIAL;
                out.sbyte(""DEBUG_OP_X"", op);
                line = opNode.line;
                addr = opNode.label.offset;
                break;
            }
        }
        out.sbyte(""DBG_END_SEQUENCE"", DBG_END_SEQUENCE);
    }",iterator
item,"{
        Collections.sort(annotations, cmp);
        out.uint(""size"", annotations.size());
        for (AnnotationItem item : annotations) {
            out.uint(""annotation_off"", item.offset);
        }
    }",iterator
h,"{
        prepareInsns();
        prepareTries();

        offset += 16 + insn_size * 2;
        if (tries != null && tries.size() > 0) {
            if ((insn_size & 0x01) != 0) {// padding
                offset += 2;
            }
            offset += 8 * tries.size();
            if (handlers.size() > 0) {
                int base = offset;
                offset += lengthOfUleb128(handlers.size());

                for (EncodedCatchHandler h : handlers) {
                    h.handler_off = offset - base;
                    int size = h.addPairs.size();
                    offset += lengthOfSleb128(h.catchAll != null ? -size : size);
                    for (AddrPair ap : h.addPairs) {
                        offset += lengthOfUleb128(ap.type.index) + lengthOfUleb128(ap.addr.offset);
                    }
                    if (h.catchAll != null) {
                        offset += lengthOfUleb128(h.catchAll.offset);
                    }
                }
            }

        }
        return offset;
    }",iterator
ap,"{
        prepareInsns();
        prepareTries();

        offset += 16 + insn_size * 2;
        if (tries != null && tries.size() > 0) {
            if ((insn_size & 0x01) != 0) {// padding
                offset += 2;
            }
            offset += 8 * tries.size();
            if (handlers.size() > 0) {
                int base = offset;
                offset += lengthOfUleb128(handlers.size());

                for (EncodedCatchHandler h : handlers) {
                    h.handler_off = offset - base;
                    int size = h.addPairs.size();
                    offset += lengthOfSleb128(h.catchAll != null ? -size : size);
                    for (AddrPair ap : h.addPairs) {
                        offset += lengthOfUleb128(ap.type.index) + lengthOfUleb128(ap.addr.offset);
                    }
                    if (h.catchAll != null) {
                        offset += lengthOfUleb128(h.catchAll.offset);
                    }
                }
            }

        }
        return offset;
    }",iterator
insn,"{
        out.ushort(""registers_size"", registersSize);
        out.ushort(""ins_size"", insSize);
        out.ushort(""outs_size"", outsSize);
        out.ushort(""tries_size"", tries == null ? 0 : tries.size());
        out.uint(""debug_info_off"", debugInfo == null ? 0 : debugInfo.offset);
        out.uint(""insn_size"", insn_size);
        ByteBuffer b = ByteBuffer.allocate(insn_size * 2).order(ByteOrder.LITTLE_ENDIAN);
        for (Insn insn : insns) {
            insn.write(b);
        }
        out.bytes(""insn"", b.array());
        if (tries != null && tries.size() > 0) {
            if ((insn_size & 0x01) != 0) {// padding
                out.skip(""padding"", 2);
            }
            int lastEnd = 0;
            for (TryItem ti : tries) {
                if (ti.start.offset < lastEnd) {
                    System.err.println(""'Out-of-order try' may throwed by libdex"");
                }
                out.uint(""start_addr"", ti.start.offset);
                out.ushort(""insn_count"", ti.end.offset - ti.start.offset);
                lastEnd = ti.end.offset;
                out.ushort(""handler_off"", ti.handler.handler_off);
            }
            if (handlers.size() > 0) {
                out.uleb128(""size"", handlers.size());
                for (EncodedCatchHandler h : handlers) {

                    int size = h.addPairs.size();
                    out.sleb128(""size"", (h.catchAll != null ? -size : size));
                    for (AddrPair ap : h.addPairs) {
                        out.uleb128(""type_idx"", (ap.type.index));
                        out.uleb128(""addr"", (ap.addr.offset));
                    }
                    if (h.catchAll != null) {
                        out.uleb128(""catch_all_addr"", (h.catchAll.offset));
                    }
                }
            }
        }
    }",iterator
ti,"{
        out.ushort(""registers_size"", registersSize);
        out.ushort(""ins_size"", insSize);
        out.ushort(""outs_size"", outsSize);
        out.ushort(""tries_size"", tries == null ? 0 : tries.size());
        out.uint(""debug_info_off"", debugInfo == null ? 0 : debugInfo.offset);
        out.uint(""insn_size"", insn_size);
        ByteBuffer b = ByteBuffer.allocate(insn_size * 2).order(ByteOrder.LITTLE_ENDIAN);
        for (Insn insn : insns) {
            insn.write(b);
        }
        out.bytes(""insn"", b.array());
        if (tries != null && tries.size() > 0) {
            if ((insn_size & 0x01) != 0) {// padding
                out.skip(""padding"", 2);
            }
            int lastEnd = 0;
            for (TryItem ti : tries) {
                if (ti.start.offset < lastEnd) {
                    System.err.println(""'Out-of-order try' may throwed by libdex"");
                }
                out.uint(""start_addr"", ti.start.offset);
                out.ushort(""insn_count"", ti.end.offset - ti.start.offset);
                lastEnd = ti.end.offset;
                out.ushort(""handler_off"", ti.handler.handler_off);
            }
            if (handlers.size() > 0) {
                out.uleb128(""size"", handlers.size());
                for (EncodedCatchHandler h : handlers) {

                    int size = h.addPairs.size();
                    out.sleb128(""size"", (h.catchAll != null ? -size : size));
                    for (AddrPair ap : h.addPairs) {
                        out.uleb128(""type_idx"", (ap.type.index));
                        out.uleb128(""addr"", (ap.addr.offset));
                    }
                    if (h.catchAll != null) {
                        out.uleb128(""catch_all_addr"", (h.catchAll.offset));
                    }
                }
            }
        }
    }",iterator
h,"{
        out.ushort(""registers_size"", registersSize);
        out.ushort(""ins_size"", insSize);
        out.ushort(""outs_size"", outsSize);
        out.ushort(""tries_size"", tries == null ? 0 : tries.size());
        out.uint(""debug_info_off"", debugInfo == null ? 0 : debugInfo.offset);
        out.uint(""insn_size"", insn_size);
        ByteBuffer b = ByteBuffer.allocate(insn_size * 2).order(ByteOrder.LITTLE_ENDIAN);
        for (Insn insn : insns) {
            insn.write(b);
        }
        out.bytes(""insn"", b.array());
        if (tries != null && tries.size() > 0) {
            if ((insn_size & 0x01) != 0) {// padding
                out.skip(""padding"", 2);
            }
            int lastEnd = 0;
            for (TryItem ti : tries) {
                if (ti.start.offset < lastEnd) {
                    System.err.println(""'Out-of-order try' may throwed by libdex"");
                }
                out.uint(""start_addr"", ti.start.offset);
                out.ushort(""insn_count"", ti.end.offset - ti.start.offset);
                lastEnd = ti.end.offset;
                out.ushort(""handler_off"", ti.handler.handler_off);
            }
            if (handlers.size() > 0) {
                out.uleb128(""size"", handlers.size());
                for (EncodedCatchHandler h : handlers) {

                    int size = h.addPairs.size();
                    out.sleb128(""size"", (h.catchAll != null ? -size : size));
                    for (AddrPair ap : h.addPairs) {
                        out.uleb128(""type_idx"", (ap.type.index));
                        out.uleb128(""addr"", (ap.addr.offset));
                    }
                    if (h.catchAll != null) {
                        out.uleb128(""catch_all_addr"", (h.catchAll.offset));
                    }
                }
            }
        }
    }",iterator
ap,"{
        out.ushort(""registers_size"", registersSize);
        out.ushort(""ins_size"", insSize);
        out.ushort(""outs_size"", outsSize);
        out.ushort(""tries_size"", tries == null ? 0 : tries.size());
        out.uint(""debug_info_off"", debugInfo == null ? 0 : debugInfo.offset);
        out.uint(""insn_size"", insn_size);
        ByteBuffer b = ByteBuffer.allocate(insn_size * 2).order(ByteOrder.LITTLE_ENDIAN);
        for (Insn insn : insns) {
            insn.write(b);
        }
        out.bytes(""insn"", b.array());
        if (tries != null && tries.size() > 0) {
            if ((insn_size & 0x01) != 0) {// padding
                out.skip(""padding"", 2);
            }
            int lastEnd = 0;
            for (TryItem ti : tries) {
                if (ti.start.offset < lastEnd) {
                    System.err.println(""'Out-of-order try' may throwed by libdex"");
                }
                out.uint(""start_addr"", ti.start.offset);
                out.ushort(""insn_count"", ti.end.offset - ti.start.offset);
                lastEnd = ti.end.offset;
                out.ushort(""handler_off"", ti.handler.handler_off);
            }
            if (handlers.size() > 0) {
                out.uleb128(""size"", handlers.size());
                for (EncodedCatchHandler h : handlers) {

                    int size = h.addPairs.size();
                    out.sleb128(""size"", (h.catchAll != null ? -size : size));
                    for (AddrPair ap : h.addPairs) {
                        out.uleb128(""type_idx"", (ap.type.index));
                        out.uleb128(""addr"", (ap.addr.offset));
                    }
                    if (h.catchAll != null) {
                        out.uleb128(""catch_all_addr"", (h.catchAll.offset));
                    }
                }
            }
        }
    }",iterator
tryItem,"{
        if (_tryItems.size() > 0) {
            List<CodeItem.TryItem> uniqTrys = new ArrayList<>();
            { // merge dup trys
                Set<TryItem> set = new HashSet<>();
                for (CodeItem.TryItem tryItem : _tryItems) {
                    if (!set.contains(tryItem)) {
                        uniqTrys.add(tryItem);
                        set.add(tryItem);
                    } else {
                        for (TryItem t : uniqTrys) {
                            if (t.equals(tryItem)) {
                                mergeExceptionHandler(t.handler, tryItem.handler);
                            }
                        }
                    }
                }
                set.clear();
                this.tries = uniqTrys;
                if (uniqTrys.size() > 0) {
                    Collections.sort(uniqTrys, new Comparator<TryItem>() {
                        @Override
                        public int compare(TryItem o1, TryItem o2) {
                            int x = o1.start.offset - o2.start.offset;
                            if (x == 0) {
                                x = o1.end.offset - o2.end.offset;
                            }
                            return x;
                        }
                    });
                }
            }
            { // merge dup handlers
                List<CodeItem.EncodedCatchHandler> uniqHanders = new ArrayList<>();
                Map<EncodedCatchHandler, EncodedCatchHandler> map = new HashMap<>();
                for (CodeItem.TryItem tryItem : uniqTrys) {
                    CodeItem.EncodedCatchHandler d = tryItem.handler;
                    CodeItem.EncodedCatchHandler uH = map.get(d);
                    if (uH != null) {
                        tryItem.handler = uH;
                    } else {
                        uniqHanders.add(d);
                        map.put(d, d);
                    }
                }
                this.handlers = uniqHanders;
                map.clear();
            }

        }
    }",iterator
t,"{
        if (_tryItems.size() > 0) {
            List<CodeItem.TryItem> uniqTrys = new ArrayList<>();
            { // merge dup trys
                Set<TryItem> set = new HashSet<>();
                for (CodeItem.TryItem tryItem : _tryItems) {
                    if (!set.contains(tryItem)) {
                        uniqTrys.add(tryItem);
                        set.add(tryItem);
                    } else {
                        for (TryItem t : uniqTrys) {
                            if (t.equals(tryItem)) {
                                mergeExceptionHandler(t.handler, tryItem.handler);
                            }
                        }
                    }
                }
                set.clear();
                this.tries = uniqTrys;
                if (uniqTrys.size() > 0) {
                    Collections.sort(uniqTrys, new Comparator<TryItem>() {
                        @Override
                        public int compare(TryItem o1, TryItem o2) {
                            int x = o1.start.offset - o2.start.offset;
                            if (x == 0) {
                                x = o1.end.offset - o2.end.offset;
                            }
                            return x;
                        }
                    });
                }
            }
            { // merge dup handlers
                List<CodeItem.EncodedCatchHandler> uniqHanders = new ArrayList<>();
                Map<EncodedCatchHandler, EncodedCatchHandler> map = new HashMap<>();
                for (CodeItem.TryItem tryItem : uniqTrys) {
                    CodeItem.EncodedCatchHandler d = tryItem.handler;
                    CodeItem.EncodedCatchHandler uH = map.get(d);
                    if (uH != null) {
                        tryItem.handler = uH;
                    } else {
                        uniqHanders.add(d);
                        map.put(d, d);
                    }
                }
                this.handlers = uniqHanders;
                map.clear();
            }

        }
    }",iterator
pair,"{
        for (AddrPair pair : from.addPairs) {
            if (!to.addPairs.contains(pair)) {
                to.addPairs.add(pair);
            }
        }
        if (to.catchAll == null) {
            to.catchAll = from.catchAll;
        }
    }",iterator
insn,"{
        List<JumpOp> jumpOps=new ArrayList<>();
        for (Insn insn : _ops) {
            if (insn instanceof CodeWriter.IndexedInsn) {
                ((CodeWriter.IndexedInsn) insn).fit();
            } else  if(insn instanceof JumpOp){
                jumpOps.add((JumpOp)insn);
            }
        }

        int codeSize = 0;
        while (true) {
            for (Insn insn : _ops) {
                insn.offset = codeSize;
                codeSize += insn.getCodeUnitSize();
            }
            boolean allfit = true;
            for (JumpOp jop : jumpOps) {
                if (!jop.fit()) {
                    allfit = false;
                }
            }
            if (allfit) {
                break;
            }
            codeSize = 0;
        }
        for (Insn insn : _tailOps) {
            if ((codeSize & 1) != 0) { // not 32bit alignment
                Insn nop = new PreBuildInsn(new byte[] { (byte) Op.NOP.opcode, 0 }); // f10x
                insn.offset = codeSize;
                codeSize += nop.getCodeUnitSize();
                _ops.add(nop);
            }
            insn.offset = codeSize;
            codeSize += insn.getCodeUnitSize();
            _ops.add(insn);
        }
        _tailOps.clear();
        this.insns = _ops;
        this.insn_size = codeSize;
    }",iterator
jop,"{
        List<JumpOp> jumpOps=new ArrayList<>();
        for (Insn insn : _ops) {
            if (insn instanceof CodeWriter.IndexedInsn) {
                ((CodeWriter.IndexedInsn) insn).fit();
            } else  if(insn instanceof JumpOp){
                jumpOps.add((JumpOp)insn);
            }
        }

        int codeSize = 0;
        while (true) {
            for (Insn insn : _ops) {
                insn.offset = codeSize;
                codeSize += insn.getCodeUnitSize();
            }
            boolean allfit = true;
            for (JumpOp jop : jumpOps) {
                if (!jop.fit()) {
                    allfit = false;
                }
            }
            if (allfit) {
                break;
            }
            codeSize = 0;
        }
        for (Insn insn : _tailOps) {
            if ((codeSize & 1) != 0) { // not 32bit alignment
                Insn nop = new PreBuildInsn(new byte[] { (byte) Op.NOP.opcode, 0 }); // f10x
                insn.offset = codeSize;
                codeSize += nop.getCodeUnitSize();
                _ops.add(nop);
            }
            insn.offset = codeSize;
            codeSize += insn.getCodeUnitSize();
            _ops.add(insn);
        }
        _tailOps.clear();
        this.insns = _ops;
        this.insn_size = codeSize;
    }",iterator
i,"{
        final int length = s.length();
        for (int i = 0; i < length; i++) {
            char ch = s.charAt(i);
            if (ch != 0 && ch <= 127) { // U+0000 uses two bytes.
                out.write(ch);
            } else if (ch <= 2047) {
                out.write((0xc0 | (0x1f & (ch >> 6))));
                out.write((0x80 | (0x3f & ch)));
            } else {
                out.write((0xe0 | (0x0f & (ch >> 12))));
                out.write((0x80 | (0x3f & (ch >> 6))));
                out.write((0x80 | (0x3f & ch)));
            }
        }
    }",loop_control
i,"{
        int result = 0;
        final int length = s.length();
        for (int i = 0; i < length; ++i) {
            char ch = s.charAt(i);
            if (ch != 0 && ch <= 127) { // U+0000 uses two bytes.
                ++result;
            } else if (ch <= 2047) {
                result += 2;
            } else {
                result += 3;
            }
        }
        return result;
    }",loop_control
fe,"{
        out.uint(""class_annotations_off"", classAnnotations == null ? 0 : classAnnotations.offset);
        out.uint(""fields_size"", fieldAnnotations == null ? 0 : fieldAnnotations.size());
        out.uint(""annotated_methods_size"", methodAnnotations == null ? 0 : methodAnnotations.size());
        out.uint(""annotated_parameter_size"", parameterAnnotations == null ? 0 : parameterAnnotations.size());
        if (fieldAnnotations != null) {
            for (Entry<FieldIdItem, AnnotationSetItem> fe : fieldAnnotations.entrySet()) {
                out.uint(""field_idx"", fe.getKey().index);
                out.uint(""annotations_off"", fe.getValue().offset);
            }
        }
        if (methodAnnotations != null) {
            for (Entry<MethodIdItem, AnnotationSetItem> fe : methodAnnotations.entrySet()) {
                out.uint(""method_idx"", fe.getKey().index);
                out.uint(""annotations_off"", fe.getValue().offset);
            }
        }
        if (parameterAnnotations != null) {
            for (Entry<MethodIdItem, AnnotationSetRefListItem> fe : parameterAnnotations.entrySet()) {
                out.uint(""method_idx"", fe.getKey().index);
                out.uint(""annotations_off"", fe.getValue().offset);
            }
        }
    }",iterator
it,"{
        for (Iterator<SectionItem<?>> it = items.iterator(); it.hasNext(); ) {
            SectionItem<?> i = it.next();
            if (i == null || i.items.size() < 1) {
                it.remove();
            }
        }
    }",iterator
t,"{
        out.begin(""map_list"");
        out.uint(""size"", items.size());
        for (SectionItem<?> t : items) {
            writeMapItem(out, t.sectionType.code, t.items.size(), t.offset);
        }
        out.end();
        items.clear();
    }",iterator
hasMore,"{
        int remaining = value >> 7;
        boolean hasMore = true;
        int end = ((value & Integer.MIN_VALUE) == 0) ? 0 : -1;
        int count = 0;
        while (hasMore) {
            hasMore = (remaining != end)
                    || ((remaining & 1) != ((value >> 6) & 1));
            count++;
            value = remaining;
            remaining >>= 7;
        }
        return count;
    }",maybe_loop_control
remaining,"{
        int remaining = value >>> 7;
        int length = 1;
        while (remaining != 0) {
            length++;
            remaining >>>= 7;
        }
        return length;
    }",loop_control
i,"{
        if (classData == null) {
            return;
        }
        List<EncodedField> fs = classData.staticFields;
        int count = -1;
        for (int i = 0; i < fs.size(); i++) {
            EncodedField f = fs.get(i);
            EncodedValue ev = f.staticValue;
            if (ev != null) {
                if (!ev.isDefaultValueForType()) {
                    count = i;
                }
            }
        }

        if (count >= 0) {
            EncodedArrayItem encodedArrayItem = cp.putEnCodedArrayItem();
            EncodedArray array = encodedArrayItem.value;
            for (int i = 0; i <= count; i++) {
                EncodedField f = fs.get(i);
                EncodedValue ev = f.staticValue;
                if (ev == null) {
                    array.values.add(EncodedValue.defaultValueForType(f.field.getTypeString()));
                } else {
                    array.values.add(ev);
                }
            }
            staticValues = encodedArrayItem;
        }
    }",loop_control
m,"{
        for (EncodedMethod m : ms) {
            if (m.annotationSetItem != null) {
                methodAnnotations.put(m.method, cp.uniqAnnotationSetItem(m.annotationSetItem));
            }
            if (m.parameterAnnotation != null) {
                parameterAnnotations.put(m.method, cp.uniqAnnotationSetRefListItem(m.parameterAnnotation));
            }
        }
    }",iterator
f,"{
        for (EncodedField f : fs) {
            if (f.annotationSetItem != null) {
                fieldAnnotations.put(f.field, cp.uniqAnnotationSetItem(f.annotationSetItem));
            }
        }
    }",iterator
idItem,"{
        out.uint(""size"", items.size());
        for (TypeIdItem idItem : items) {
            out.ushort(""type_idx"", idItem.index);
        }
    }",iterator
i,"{
        int min = Math.min(items.size(), o.items.size());
        for (int i = 0; i < min; i++) {
            int x = items.get(i).compareTo(o.items.get(i));
            if (x != 0) {
                return x;
            }
        }
        return (items.size() == o.items.size() ? 0 : (items.size() < o.items.size() ? -1 : 1));
    }",loop_control
x,"{
        int min = Math.min(items.size(), o.items.size());
        for (int i = 0; i < min; i++) {
            int x = items.get(i).compareTo(o.items.get(i));
            if (x != 0) {
                return x;
            }
        }
        return (items.size() == o.items.size() ? 0 : (items.size() < o.items.size() ? -1 : 1));
    }",break_loop_control
f,"{
        for (Field f : SectionItem.class.getFields()) {
            if (f.getType().equals(int.class)) {
                if (0 != (f.getModifiers() & Modifier.STATIC)) {
                    System.out.printf(""%s(0x%04x,0,0),//\n"", f.getName(), f.get(null));
                }
            }
        }
    }",iterator
t,"{
        final int startOffset = offset;
        int index = 0;
        for (T t : items) {
            offset = padding(offset, sectionType.alignment);
            t.offset = offset;
            t.index = index;
            index++;
            offset = t.place(offset);
        }
        size = offset - startOffset;
        return offset;
    }",iterator
i,"{
        out.begin(""Section:"" + sectionType);
        List<T> items = this.items;
        if (sectionType == SectionType.TYPE_STRING_DATA_ITEM) {
            Buffer buff = new Buffer();

            for (int i = 0; i < items.size(); i++) {
                T t = items.get(i);
                items.set(i, null);
                addPadding(out, sectionType.alignment);
                if (out.offset() != t.offset) {
                    throw new RuntimeException();
                }
                StringDataItem stringDataItem = (StringDataItem) t;
                stringDataItem.write(out, buff);
                buff.reset();
            }
        } else {
            for (int i = 0; i < items.size(); i++) {
                T t = items.get(i);
                items.set(i, null);
                addPadding(out, sectionType.alignment);
                if (out.offset() != t.offset) {
                    System.err.println(""Error for type:"" + this.sectionType + "", "" + t.index);
                    throw new RuntimeException();
                }
                t.write(out);
            }
        }
        out.end();
    }",loop_control
f,"{
        if (methods.size() == 0) {
            return offset;
        }
        int lastIdx = 0;
        for (EncodedMethod f : methods) {
            offset += lengthOfUleb128(f.method.index - lastIdx);
            offset += lengthOfUleb128(f.accessFlags);
            offset += lengthOfUleb128(f.code == null ? 0 : f.code.offset);
            lastIdx = f.method.index;
        }
        return offset;
    }",iterator
f,"{
        if (fields.size() == 0) {
            return offset;
        }
        int lastIdx = 0;
        for (EncodedField f : fields) {
            offset += lengthOfUleb128(f.field.index - lastIdx);
            offset += lengthOfUleb128(f.accessFlags);

            lastIdx = f.field.index;
        }
        return offset;
    }",iterator
f,"{
        if (methods == null || methods.size() == 0) {
            return;
        }
        int lastIdx = 0;
        for (EncodedMethod f : methods) {
            out.uleb128(""method_idx_diff"", f.method.index - lastIdx);
            out.uleb128(""access_flags"", f.accessFlags);
            out.uleb128(""code_off"", f.code == null ? 0 : f.code.offset);
            lastIdx = f.method.index;
        }
    }",iterator
f,"{
        if (fields == null || fields.size() == 0) {
            return;
        }
        int lastIdx = 0;
        for (EncodedField f : fields) {
            out.uleb128(""field_idx_diff"", f.field.index - lastIdx);
            out.uleb128(""access_flags"", f.accessFlags);
            lastIdx = f.field.index;
        }
    }",iterator
dcn,"{
        DexFileNode dfn = new DexFileNode();
        try (InputStream is = SmaliTest.class.getResourceAsStream(""/a.smali"")) {
            Smali.smaliFile(""a.smali"", is, dfn);
        }
        for (DexClassNode dcn : dfn.clzs) {
            BufferedWriter w = new BufferedWriter(new OutputStreamWriter(System.out));
            new BaksmaliDumper(true, true).baksmaliClass(dcn, new BaksmaliDumpOut(w));
            w.flush();
        }
    }",iterator
c,"{
        DexFileReader dexFileReader = new DexFileReader(ZipUtil.readDex(path));
        DexFileNode dexFileNode = new DexFileNode();
        dexFileReader.accept(dexFileNode);
        Map<String, DexClassNode> map = new HashMap<>();
        for (DexClassNode c : dexFileNode.clzs) {
            map.put(c.className, c);
        }
        return map;
    }",iterator
f,"{
        File dir = new File(""../dex-translator/src/test/resources/dexes"");
        File[] fs = dir.listFiles();
        if (fs != null) {
            for (File f : fs) {
                if (f.getName().endsWith("".dex"") || f.getName().endsWith("".apk"")) {
                    System.out.println(f.getName());
                    dotest(f);
                }
            }
        }
    }",iterator
def,"{
        DexBackedDexFile dex;
        try {
            dex = DexFileFactory.loadDexFile(dexFile, 14, false);
        } catch (DexBackedDexFile.NotADexFile ex) {
            ex.printStackTrace();
            return;
        }
        Map<String, DexClassNode> map = readDex(dexFile);

        for (DexBackedClassDef def : dex.getClasses()) {
            String type = def.getType();
            System.out.println(type);
            DexClassNode dexClassNode = map.get(type);
            Assert.assertNotNull(dexClassNode);
            String smali = baksmali(def); // original

            Smali.smaliFile2Node(""fake.smali"", smali);

            {
                byte[] data = toDex(dexClassNode);
                DexBackedClassDef def2 = new DexBackedDexFile(new Opcodes(14, false), data).getClasses().iterator().next();
                String baksmali3 = baksmali(def2); // original
                Assert.assertEquals(smali, baksmali3);
            }

            String psmali = pbaksmali(dexClassNode);
            DexClassNode dexClassNode2 = Smali.smaliFile2Node(""fake.smali"", psmali);
            Assert.assertEquals(""cmp smalip"", psmali, pbaksmali(dexClassNode2));

            {
                byte[] data = toDex(dexClassNode2);
                DexBackedClassDef def2 = new DexBackedDexFile(new Opcodes(14, false), data).getClasses().iterator().next();
                String baksmali3 = baksmali(def2); // original
                Assert.assertEquals(smali, baksmali3);
            }
        }
    }",iterator
f,"{
        File dir = new File(""../dex-translator/src/test/resources/dexes"");
        File[] fs = dir.listFiles();
        if (fs != null) {
            for (File f : fs) {
                if (f.getName().endsWith("".dex"") || f.getName().endsWith("".apk"")) {
                    dotest(f.toPath());
                }
            }
        }
    }",iterator
i,"{
        for (int i = 0; i < id.length(); ++i) {
            char c = id.charAt(i);
            escape1(sb, c);
        }
    }",loop_control
i,"{
        for (int i = 0; i < id.length(); ++i) {
            char c = id.charAt(i);
            if (c == '-') {
                sb.append(c);
            } else {
                escape1(sb, c);
            }
        }
    }",loop_control
t,"{
        StringBuilder escapeBuff = new StringBuilder();
        escapeBuff.append(""("");
        for (String t : m.getParameterTypes()) {
            escapeType0(escapeBuff, t);
        }
        escapeBuff.append("")"");
        escapeType0(escapeBuff, m.getReturnType());
        return escapeBuff.toString();
    }",iterator
ann,"{
        for (DexAnnotationNode ann : anns) {
            dumpAnn(ann, out);
        }
    }",iterator
i,"{

        if (o instanceof Object[]) {
            Object[] vs = (Object[]) o;
            if (name != null) {
                out.s(escapeId(name) + "" = {"");
            } else {
                out.s(""{"");
            }
            out.push();
            for (int i = 0; i < vs.length; i++) {
                Object v = vs[i];
                dumpItem(null, v, out, i != vs.length - 1);
            }
            out.pop();
            if (array) {
                out.s(""},"");
            } else {
                out.s(""}"");
            }
        } else if (o instanceof DexAnnotationNode) {
            DexAnnotationNode dexAnnotationNode = (DexAnnotationNode) o;
            if (name != null) {
                out.s(escapeId(name) + "" = .subannotation "" + escapeType(dexAnnotationNode.type));
            } else {
                out.s("".subannotation "" + escapeType(dexAnnotationNode.type));
            }
            out.push();
            for (Item item : dexAnnotationNode.items) {
                dumpItem(item.name, item.value, out, false);
            }
            out.pop();
            if (array) {
                out.s("".end subannotation,"");
            } else {
                out.s("".end subannotation"");
            }
        } else {
            StringBuilder sb = new StringBuilder();
            if (name != null) {
                sb.append(escapeId(name)).append("" = "");
            }
            sb.append(escapeValue(o));
            if (array) {
                sb.append("","");
            }
            out.s(sb.toString());
        }
    }",loop_control
item,"{

        if (o instanceof Object[]) {
            Object[] vs = (Object[]) o;
            if (name != null) {
                out.s(escapeId(name) + "" = {"");
            } else {
                out.s(""{"");
            }
            out.push();
            for (int i = 0; i < vs.length; i++) {
                Object v = vs[i];
                dumpItem(null, v, out, i != vs.length - 1);
            }
            out.pop();
            if (array) {
                out.s(""},"");
            } else {
                out.s(""}"");
            }
        } else if (o instanceof DexAnnotationNode) {
            DexAnnotationNode dexAnnotationNode = (DexAnnotationNode) o;
            if (name != null) {
                out.s(escapeId(name) + "" = .subannotation "" + escapeType(dexAnnotationNode.type));
            } else {
                out.s("".subannotation "" + escapeType(dexAnnotationNode.type));
            }
            out.push();
            for (Item item : dexAnnotationNode.items) {
                dumpItem(item.name, item.value, out, false);
            }
            out.pop();
            if (array) {
                out.s("".end subannotation,"");
            } else {
                out.s("".end subannotation"");
            }
        } else {
            StringBuilder sb = new StringBuilder();
            if (name != null) {
                sb.append(escapeId(name)).append("" = "");
            }
            sb.append(escapeValue(o));
            if (array) {
                sb.append("","");
            }
            out.s(sb.toString());
        }
    }",iterator
item,"{
        out.s("".annotation %s %s"", ann.visibility.displayName(), escapeType(ann.type));
        out.push();
        for (Item item : ann.items) {
            dumpItem(item.name, item.value, out, false);
        }
        out.pop();
        out.s("".end annotation"");
    }",iterator
itf,"{

        buff.setLength(0);
        buff.append("".class "");
        appendAccess(n.access, buff);
        buff.append(escapeType(n.className));
        out.s(buff.toString());
        if (n.superClass != null) {
            out.s("".super %s"", escapeType(n.superClass));
        }
        if (n.interfaceNames != null && n.interfaceNames.length > 0) {
            for (String itf : n.interfaceNames) {
                out.s("".implements %s"", escapeType(itf));
            }
        }
        if (n.source != null) {
            out.s("".source "" + escapeValue(n.source));
        }
        if (n.anns != null) {
            out.s("""");
            dumpAnns(n.anns, out);
        }
        if (n.fields != null) {
            for (DexFieldNode f : n.fields) {
                out.s("""");
                buff.setLength(0);
                buff.append("".field "");
                appendAccess(f.access | ACCESS_FIELD, buff);
                Field field = f.field;
                buff.append(escapeId(f.field.getName())).append("":"").append(escapeType(field.getType()));
                if (f.cst != null) {
                    buff.append("" = "");
                    buff.append(escapeValue(f.cst));
                }
                out.s(buff.toString());

                if (f.anns != null) {
                    out.push();
                    dumpAnns(f.anns, out);
                    out.pop();
                    out.s("".end field"");
                }
            }
        }
        if (n.methods != null) {
            for (DexMethodNode m : n.methods) {
                baksmaliMethod(m, out);
            }
        }
    }",iterator
f,"{

        buff.setLength(0);
        buff.append("".class "");
        appendAccess(n.access, buff);
        buff.append(escapeType(n.className));
        out.s(buff.toString());
        if (n.superClass != null) {
            out.s("".super %s"", escapeType(n.superClass));
        }
        if (n.interfaceNames != null && n.interfaceNames.length > 0) {
            for (String itf : n.interfaceNames) {
                out.s("".implements %s"", escapeType(itf));
            }
        }
        if (n.source != null) {
            out.s("".source "" + escapeValue(n.source));
        }
        if (n.anns != null) {
            out.s("""");
            dumpAnns(n.anns, out);
        }
        if (n.fields != null) {
            for (DexFieldNode f : n.fields) {
                out.s("""");
                buff.setLength(0);
                buff.append("".field "");
                appendAccess(f.access | ACCESS_FIELD, buff);
                Field field = f.field;
                buff.append(escapeId(f.field.getName())).append("":"").append(escapeType(field.getType()));
                if (f.cst != null) {
                    buff.append("" = "");
                    buff.append(escapeValue(f.cst));
                }
                out.s(buff.toString());

                if (f.anns != null) {
                    out.push();
                    dumpAnns(f.anns, out);
                    out.pop();
                    out.s("".end field"");
                }
            }
        }
        if (n.methods != null) {
            for (DexMethodNode m : n.methods) {
                baksmaliMethod(m, out);
            }
        }
    }",iterator
i,"{
        out.s("""");
        buff.setLength(0);
        buff.append("".method "");
        Method method = m.method;
        appendAccess(m.access, buff);
        buff.append(escapeId(method.getName())).append(escapeMethodDesc(method));
        out.s(buff.toString());
        out.push();
        if (m.anns != null) {
            dumpAnns(m.anns, out);
        }

        int paramMax = 0;
        List<String> parameterNames = null;
        if (m.codeNode != null && m.codeNode.debugNode != null) {
            parameterNames = m.codeNode.debugNode.parameterNames;
            if (parameterNames != null) {
                paramMax = parameterNames.size();
            }
        }
        int annoMax = 0;
        if (m.parameterAnns != null) {
            for (int i = 0; i < m.parameterAnns.length; i++) {
                List<DexAnnotationNode> ps = m.parameterAnns[i];
                if (ps != null && ps.size() > 0) {
                    annoMax = i + 1;
                }
            }
        }

        int max = Math.max(paramMax, annoMax);
        for (int i = 0; i < max; i++) {
            String type = method.getParameterTypes()[i];
            String debugName = parameterNames == null ? null : i < parameterNames.size() ? parameterNames.get(i) : null;
            if (debugName != null) {
                out.s("".parameter \"""" + escapeId(debugName) + ""\"" # "" + type);
            } else {
                out.s("".parameter # "" + type);
            }
            List<DexAnnotationNode> ps = m.parameterAnns == null ? null : m.parameterAnns[i];
            if (ps != null && ps.size() != 0) {
                out.push();
                dumpAnns(ps, out);
                out.pop();
                out.s("".end parameter"");
            }
            // FIXME support '.param' REGISTER, STRING
        }

        if (m.codeNode != null) {
            baksmaliCode(m, m.codeNode, out);
        }

        out.pop();
        out.s("".end method"");
    }",loop_control
opNode,"{

        final List<DexLabel> allLabel = new ArrayList<>();
        final Set<DexLabel> usedLabel = new HashSet<>();
        codeNode.accept(new DexCodeVisitor() {
            @Override
            public void visitJumpStmt(Op op, int a, int b, DexLabel label) {
                usedLabel.add(label);
            }

            @Override
            public void visitPackedSwitchStmt(Op op, int aA, int first_case, DexLabel[] labels) {
                usedLabel.addAll(Arrays.asList(labels));
            }

            @Override
            public void visitTryCatch(DexLabel start, DexLabel end, DexLabel[] handler, String[] type) {
                usedLabel.add(start);
                usedLabel.add(end);
                usedLabel.addAll(Arrays.asList(handler));
            }

            @Override
            public void visitLabel(DexLabel label) {
                allLabel.add(label);
            }

            @Override
            public void visitSparseSwitchStmt(Op op, int ra, int[] cases, DexLabel[] labels) {
                usedLabel.addAll(Arrays.asList(labels));
            }
        });
        Map<DexLabel, List<DexDebugNode.DexDebugOpNode>> debugLabelMap = new HashMap<>();
        if (codeNode.debugNode != null) {
            DexDebugNode debugNode = codeNode.debugNode;
            for (DexDebugNode.DexDebugOpNode opNode : debugNode.debugNodes) {
                List<DexDebugNode.DexDebugOpNode> list = debugLabelMap.get(opNode.label);
                if (list == null) {
                    list = new ArrayList<>(3);
                    debugLabelMap.put(opNode.label, list);
                }
                list.add(opNode);
            }
        }
        int nextLabelNumber = 0;
        for (DexLabel label : allLabel) {
            if (usedLabel.contains(label)) {
                label.displayName = ""L"" + nextLabelNumber++;
            }
        }

        int inRegs = Utils.methodIns(methodNode.method, (methodNode.access & ACC_STATIC) != 0);

        DexCodeVisitor dexCodeVisitor = new BaksmaliCodeDumper(out, useParameterRegisters, useLocals, nextLabelNumber,
                codeNode.totalRegister - inRegs, usedLabel, debugLabelMap);
        accept(out, codeNode, dexCodeVisitor);
        dexCodeVisitor.visitEnd();
    }",iterator
label,"{

        final List<DexLabel> allLabel = new ArrayList<>();
        final Set<DexLabel> usedLabel = new HashSet<>();
        codeNode.accept(new DexCodeVisitor() {
            @Override
            public void visitJumpStmt(Op op, int a, int b, DexLabel label) {
                usedLabel.add(label);
            }

            @Override
            public void visitPackedSwitchStmt(Op op, int aA, int first_case, DexLabel[] labels) {
                usedLabel.addAll(Arrays.asList(labels));
            }

            @Override
            public void visitTryCatch(DexLabel start, DexLabel end, DexLabel[] handler, String[] type) {
                usedLabel.add(start);
                usedLabel.add(end);
                usedLabel.addAll(Arrays.asList(handler));
            }

            @Override
            public void visitLabel(DexLabel label) {
                allLabel.add(label);
            }

            @Override
            public void visitSparseSwitchStmt(Op op, int ra, int[] cases, DexLabel[] labels) {
                usedLabel.addAll(Arrays.asList(labels));
            }
        });
        Map<DexLabel, List<DexDebugNode.DexDebugOpNode>> debugLabelMap = new HashMap<>();
        if (codeNode.debugNode != null) {
            DexDebugNode debugNode = codeNode.debugNode;
            for (DexDebugNode.DexDebugOpNode opNode : debugNode.debugNodes) {
                List<DexDebugNode.DexDebugOpNode> list = debugLabelMap.get(opNode.label);
                if (list == null) {
                    list = new ArrayList<>(3);
                    debugLabelMap.put(opNode.label, list);
                }
                list.add(opNode);
            }
        }
        int nextLabelNumber = 0;
        for (DexLabel label : allLabel) {
            if (usedLabel.contains(label)) {
                label.displayName = ""L"" + nextLabelNumber++;
            }
        }

        int inRegs = Utils.methodIns(methodNode.method, (methodNode.access & ACC_STATIC) != 0);

        DexCodeVisitor dexCodeVisitor = new BaksmaliCodeDumper(out, useParameterRegisters, useLocals, nextLabelNumber,
                codeNode.totalRegister - inRegs, usedLabel, debugLabelMap);
        accept(out, codeNode, dexCodeVisitor);
        dexCodeVisitor.visitEnd();
    }",iterator
n,"{
        if (code.tryStmts != null) {
            for (TryCatchNode n : code.tryStmts) {
                n.accept(v);
            }
        }
        if (code.debugNode != null) {
            DexDebugVisitor ddv = v.visitDebug();
            if (ddv != null) {
                code.debugNode.accept(ddv);
                ddv.visitEnd();
            }
        }
        if (code.totalRegister >= 0 && code.stmts.size() > 0) {
            v.visitRegister(code.totalRegister);
        }
        for (DexStmtNode n : code.stmts) {
            if (n instanceof DexLabelStmtNode) {
                n.accept(v);
            } else {
                out.push();
                n.accept(v);
                out.pop();
            }

        }
    }",iterator
i,"{
        int labelIndex = -1;
        for (int i = 0; i < needCareStmts.size(); i++) {
            DexStmtNode s = needCareStmts.get(i);
            if (s instanceof DexLabelStmtNode) {
                DexLabelStmtNode ss = (DexLabelStmtNode) s;
                if (ss.label == label) {
                    labelIndex = i;
                }
            }
        }
        return labelIndex;
    }",loop_control
i,"{
        add(new DexStmtNode(op) {

            @Override
            public void accept(DexCodeVisitor cv) {
                int labelIndex = findLabelIndex(label);
                if (labelIndex < 0 || labelIndex >= needCareStmts.size()) {
                    throw new RuntimeException(""can't find label for "" + op + "" "" + label);
                }

                switch (op) {
                case PACKED_SWITCH:
                    PackedSwitchStmt packedSwitchStmt = (PackedSwitchStmt) needCareStmts.get(labelIndex + 1);
                    cv.visitPackedSwitchStmt(op, reg, packedSwitchStmt.firstCase, packedSwitchStmt.labels);
                    break;
                case SPARSE_SWITCH:
                    SparseSwitchStmt sparseSwitchStmt = (SparseSwitchStmt) needCareStmts.get(labelIndex + 1);
                    cv.visitSparseSwitchStmt(op, reg, sparseSwitchStmt.cases, sparseSwitchStmt.labels);
                    break;
                case FILL_ARRAY_DATA:
                    ArrayDataStmt arrayDataStmt = (ArrayDataStmt) needCareStmts.get(labelIndex + 1);
                    Object v;
                    byte[] vs = arrayDataStmt.objs;
                    switch (arrayDataStmt.length) {
                    case 1: {
                        v = vs;
                    }
                        break;
                    case 2: {
                        short[] vs1 = new short[vs.length / 2];
                        for (int i = 0; i < vs1.length; i++) {
                            vs1[i] = (short) ((vs[i * 2] & 0xFF) | ((vs[i * 2 + 1] & 0xFF) << 8));
                        }
                        v = vs1;
                    }
                        break;
                    case 4: {
                        int[] vs1 = new int[vs.length / 4];
                        for (int i = 0; i < vs1.length; i++) {
                            int base = i * 4;
                            vs1[i] = (vs[base + 0] & 0xFF) | ((vs[base + 1] & 0xFF) << 8)
                                    | ((vs[base + 2] & 0xFF) << 16) | ((vs[base + 3] & 0xFF) << 24);
                        }
                        v = vs1;
                    }
                        break;
                    case 8: {
                        long[] vs1 = new long[vs.length / 8];
                        for (int i = 0; i < vs1.length; i++) {
                            int base = i * 8;
                            int a = ((vs[base + 0] & 0xFF) << 0) | ((vs[base + 1] & 0xFF) << 8)
                                    | ((vs[base + 2] & 0xFF) << 16) | ((vs[base + 3] & 0xFF) << 24);
                            int b = ((vs[base + 4] & 0xFF) << 0) | ((vs[base + 5] & 0xFF) << 8)
                                    | ((vs[base + 6] & 0xFF) << 16) | ((vs[base + 7] & 0xFF) << 24);
                            vs1[i] = (((long) b) << 32) | a;
                        }
                        v = vs1;
                    }
                        break;
                    default:
                        throw new RuntimeException();
                    }
                    cv.visitFillArrayDataStmt(Op.FILL_ARRAY_DATA, reg, v);
                    break;
                default:
                    throw new RuntimeException();
                }
            }
        });
    }",loop_control
s,"{

        if (showVersionThenExits) {
            System.out.println(""smali 1.4.2p (https://sourceforge.net/p/dex2jar)"");
            System.out.println(""Copyright (c) 2009-2013 Panxiaobo (pxb1988@gmail.com)"");
            System.out.println(""Apache license (http://www.apache.org/licenses/LICENSE-2.0)"");
            return;
        }

        if (!readSmaliFromStdin && remainingArgs.length < 1) {
            System.err.println(""ERRPR: no file to process"");
            return;
        }

        if (output == null) {
            output = new File(""out.dex"").toPath();
        }

        Smali smali = new Smali();
        DexFileWriter fw = new DexFileWriter();

        DexFileVisitor fv = new DexFileVisitor(fw) {
            @Override
            public void visitEnd() {// intercept the call to super
            }
        };

        if (readSmaliFromStdin) {
            smali.smaliFile(""<stdin>"", System.in, fv);
            System.err.println(""smali <stdin> -> "" + output);
        }

        for (String s : remainingArgs) {
            Path file = new File(s).toPath();
            if (!Files.exists(file)) {
                System.err.println(""skip "" + file + "", it is not a dir or a file"");
            } else {
                System.err.println(""smali "" + s + "" -> "" + output);
                smali.smali(file, fv);
            }
        }

        fw.visitEnd();
        byte[] data = fw.toByteArray();
        Files.write(output, data);
    }",iterator
i,"{
        DexClassVisitor dexClassVisitor;
        String className = Utils.unEscapeId(ctx.className.getText());
        int access = collectAccess(ctx.sAccList());
        List<SmaliParser.SSuperContext> superContexts = ctx.sSuper();
        String superClass = null;
        if (superContexts.size() > 0) {
            superClass = Utils.unEscapeId(superContexts.get(superContexts.size() - 1).name.getText());
        }
        List<SmaliParser.SInterfaceContext> itfs = ctx.sInterface();
        String[] interfaceNames = null;
        if (itfs.size() > 0) {
            interfaceNames = new String[itfs.size()];
            for (int i = 0; i < itfs.size(); i++) {
                interfaceNames[i] = Utils.unEscapeId(itfs.get(i).name.getText());
            }
        }

        dexClassVisitor = dexFileVisitor.visit(access, className, superClass, interfaceNames);

        List<SmaliParser.SSourceContext> sources = ctx.sSource();
        if (sources.size() > 0) {
            dexClassVisitor.visitSource(
                    Utils.unescapeStr(sources.get(sources.size() - 1).src.getText())
            );
        }
        acceptAnnotations(ctx.sAnnotation(), dexClassVisitor);
        acceptField(ctx.sField(), className, dexClassVisitor);
        acceptMethod(ctx.sMethod(), className, dexClassVisitor);

        dexClassVisitor.visitEnd();
    }",loop_control
ctx,"{
        if (dexClassVisitor == null || sMethodContexts == null || sMethodContexts.size() == 0) {
            return;
        }
        for (SmaliParser.SMethodContext ctx : sMethodContexts) {
            acceptMethod(ctx, className, dexClassVisitor);
        }
    }",iterator
i,"{
            this.locals = totals - ins;
            this.total = totals;
            String paramTypes[] = method.getParameterTypes();
            paramNames = new String[paramTypes.length];
            map = new int[ins];
            int start = 0;
            if (!isStatic) {
                map[start] = -1;
                start++;
            }

            for (int i = 0; i < paramTypes.length; i++) {
                char t = paramTypes[i].charAt(0);
                map[start++] = i;
                if (t == 'J' || t == 'D') {
                    map[start++] = i;
                }
            }
        }",loop_control
instructionContext,"{
        int totalRegisters = -1;
        List<SmaliParser.SInstructionContext> instructionContexts = ctx.sInstruction();
        for (SmaliParser.SInstructionContext instructionContext : instructionContexts) {
            ParserRuleContext parserRuleContext = (ParserRuleContext) instructionContext.getChild(0);
            if (parserRuleContext != null) {
                int ruleIndex = parserRuleContext.getRuleIndex();
                if (ruleIndex == SmaliParser.RULE_fregisters) {
                    totalRegisters = parseInt(((SmaliParser.FregistersContext) parserRuleContext).xregisters.getText());
                    break;
                } else if (ruleIndex == SmaliParser.RULE_flocals) {
                    totalRegisters = ins + parseInt(((SmaliParser.FlocalsContext) parserRuleContext).xlocals.getText());
                    break;
                }
            }
        }
        return totalRegisters;
    }",iterator
ctx,"{
        if (sParameterContexts == null || sParameterContexts.size() == 0 || dexMethodVisitor == null) {
            return;
        }
        boolean hasParam = false;
        boolean hasParamter = false;
        for (SmaliParser.SParameterContext ctx : sParameterContexts) {
            if (ctx.param != null) {
                hasParam = true;
            }
            if (ctx.parameter != null) {
                hasParamter = true;
            }
        }
        if (hasParam && hasParamter) {
            throw new RuntimeException(""cant mix use .param and .parameter on method"");
        }
        for (int i = 0; i < sParameterContexts.size(); i++) {
            SmaliParser.SParameterContext ctx = sParameterContexts.get(i);
            int index;
            if (ctx.param != null) {
                index = m.regToParamIdx(m.pareReg(ctx.r.getText()));
            } else {
                index = i;
            }
            if (ctx.name != null) {
                m.setNameByIdx(index, unescapeStr(ctx.name.getText()));
            }
            List<SmaliParser.SAnnotationContext> annotationContexts = ctx.sAnnotation();
            if (annotationContexts.size() > 0) {
                acceptAnnotations(annotationContexts, dexMethodVisitor.visitParameterAnnotation(index));
            }
        }


    }",iterator
i,"{
        if (sParameterContexts == null || sParameterContexts.size() == 0 || dexMethodVisitor == null) {
            return;
        }
        boolean hasParam = false;
        boolean hasParamter = false;
        for (SmaliParser.SParameterContext ctx : sParameterContexts) {
            if (ctx.param != null) {
                hasParam = true;
            }
            if (ctx.parameter != null) {
                hasParamter = true;
            }
        }
        if (hasParam && hasParamter) {
            throw new RuntimeException(""cant mix use .param and .parameter on method"");
        }
        for (int i = 0; i < sParameterContexts.size(); i++) {
            SmaliParser.SParameterContext ctx = sParameterContexts.get(i);
            int index;
            if (ctx.param != null) {
                index = m.regToParamIdx(m.pareReg(ctx.r.getText()));
            } else {
                index = i;
            }
            if (ctx.name != null) {
                m.setNameByIdx(index, unescapeStr(ctx.name.getText()));
            }
            List<SmaliParser.SAnnotationContext> annotationContexts = ctx.sAnnotation();
            if (annotationContexts.size() > 0) {
                acceptAnnotations(annotationContexts, dexMethodVisitor.visitParameterAnnotation(index));
            }
        }


    }",loop_control
ctx,"{
        if (sFieldContexts == null || sFieldContexts.size() == 0 || dexClassVisitor == null) {
            return;
        }
        for (SmaliParser.SFieldContext ctx : sFieldContexts) {
            acceptField(ctx, className, dexClassVisitor);
        }
    }",iterator
ctx,"{
        if (dexAnnotationAble == null) {
            return;
        }
        if (sAnnotationContexts.size() > 0) {
            for (SmaliParser.SAnnotationContext ctx : sAnnotationContexts) {
                Visibility visibility = Utils.getAnnVisibility(ctx.visibility.getText());
                String type = Utils.unEscapeId(ctx.type.getText());
                DexAnnotationVisitor dexAnnotationVisitor = dexAnnotationAble.visitAnnotation(type, visibility);
                if (dexAnnotationVisitor != null) {
                    List<SmaliParser.SAnnotationKeyNameContext> keys = ctx.sAnnotationKeyName();
                    if (keys.size() > 0) {
                        List<SmaliParser.SAnnotationValueContext> values = ctx.sAnnotationValue();
                        for (int i = 0; i < keys.size(); i++) {
                            acceptAnnotation(dexAnnotationVisitor, Utils.unEscapeId(keys.get(i).getText()), values.get(i));
                        }
                    }
                    dexAnnotationVisitor.visitEnd();
                }
            }
        }
    }",iterator
i,"{
        if (dexAnnotationAble == null) {
            return;
        }
        if (sAnnotationContexts.size() > 0) {
            for (SmaliParser.SAnnotationContext ctx : sAnnotationContexts) {
                Visibility visibility = Utils.getAnnVisibility(ctx.visibility.getText());
                String type = Utils.unEscapeId(ctx.type.getText());
                DexAnnotationVisitor dexAnnotationVisitor = dexAnnotationAble.visitAnnotation(type, visibility);
                if (dexAnnotationVisitor != null) {
                    List<SmaliParser.SAnnotationKeyNameContext> keys = ctx.sAnnotationKeyName();
                    if (keys.size() > 0) {
                        List<SmaliParser.SAnnotationValueContext> values = ctx.sAnnotationValue();
                        for (int i = 0; i < keys.size(); i++) {
                            acceptAnnotation(dexAnnotationVisitor, Utils.unEscapeId(keys.get(i).getText()), values.get(i));
                        }
                    }
                    dexAnnotationVisitor.visitEnd();
                }
            }
        }
    }",loop_control
i,"{
        ParserRuleContext t = (ParserRuleContext) ctx.getChild(0);
        switch (t.getRuleIndex()) {
            case SmaliParser.RULE_sSubannotation: {
                SmaliParser.SSubannotationContext subannotationContext = (SmaliParser.SSubannotationContext) t;
                DexAnnotationVisitor annotationVisitor = dexAnnotationVisitor.visitAnnotation(name, Utils
                        .unEscapeId(subannotationContext.type.getText()));
                if (annotationVisitor != null) {
                    List<SmaliParser.SAnnotationKeyNameContext> keys = subannotationContext.sAnnotationKeyName();
                    if (keys.size() > 0) {
                        List<SmaliParser.SAnnotationValueContext> values = subannotationContext.sAnnotationValue();
                        for (int i = 0; i < keys.size(); i++) {
                            acceptAnnotation(annotationVisitor, Utils.unEscapeId(keys.get(i).getText()), values.get(i));
                        }
                    }
                    annotationVisitor.visitEnd();
                }
                break;
            }
            case SmaliParser.RULE_sArrayValue: {
                SmaliParser.SArrayValueContext arrayValueContext = (SmaliParser.SArrayValueContext) t;
                DexAnnotationVisitor annotationVisitor = dexAnnotationVisitor.visitArray(name);
                if (annotationVisitor != null) {
                    for (SmaliParser.SAnnotationValueContext annotationValueContext : arrayValueContext
                            .sAnnotationValue()) {
                        acceptAnnotation(annotationVisitor, null, annotationValueContext);
                    }
                    annotationVisitor.visitEnd();
                }
                break;
            }
            case SmaliParser.RULE_sBaseValue:
                SmaliParser.SBaseValueContext baseValueContext = (SmaliParser.SBaseValueContext) t;
                Object value = parseBaseValue(baseValueContext);
                dexAnnotationVisitor.visit(name, value);
                break;
        }
    }",loop_control
annotationValueContext,"{
        ParserRuleContext t = (ParserRuleContext) ctx.getChild(0);
        switch (t.getRuleIndex()) {
            case SmaliParser.RULE_sSubannotation: {
                SmaliParser.SSubannotationContext subannotationContext = (SmaliParser.SSubannotationContext) t;
                DexAnnotationVisitor annotationVisitor = dexAnnotationVisitor.visitAnnotation(name, Utils
                        .unEscapeId(subannotationContext.type.getText()));
                if (annotationVisitor != null) {
                    List<SmaliParser.SAnnotationKeyNameContext> keys = subannotationContext.sAnnotationKeyName();
                    if (keys.size() > 0) {
                        List<SmaliParser.SAnnotationValueContext> values = subannotationContext.sAnnotationValue();
                        for (int i = 0; i < keys.size(); i++) {
                            acceptAnnotation(annotationVisitor, Utils.unEscapeId(keys.get(i).getText()), values.get(i));
                        }
                    }
                    annotationVisitor.visitEnd();
                }
                break;
            }
            case SmaliParser.RULE_sArrayValue: {
                SmaliParser.SArrayValueContext arrayValueContext = (SmaliParser.SArrayValueContext) t;
                DexAnnotationVisitor annotationVisitor = dexAnnotationVisitor.visitArray(name);
                if (annotationVisitor != null) {
                    for (SmaliParser.SAnnotationValueContext annotationValueContext : arrayValueContext
                            .sAnnotationValue()) {
                        acceptAnnotation(annotationVisitor, null, annotationValueContext);
                    }
                    annotationVisitor.visitEnd();
                }
                break;
            }
            case SmaliParser.RULE_sBaseValue:
                SmaliParser.SBaseValueContext baseValueContext = (SmaliParser.SBaseValueContext) t;
                Object value = parseBaseValue(baseValueContext);
                dexAnnotationVisitor.visit(name, value);
                break;
        }
    }",iterator
acc,"{
        int access = 0;
        for (TerminalNode acc : ctx.ACC()) {
            access |= Utils.getAcc(acc.getSymbol().getText());
        }
        return access;
    }",iterator
ctx,"{
        SmaliLexer lexer = new SmaliLexer(is);
        CommonTokenStream ts = new CommonTokenStream(lexer);
        SmaliParser parser = new SmaliParser(ts);

        for (SmaliParser.SFileContext ctx : parser.sFiles().sFile()) {
            AntlrSmaliUtil.acceptFile(ctx, dcv);
        }
    }",iterator
i,"{
        try {
            for (int i = 0; i < this.i; i++) {
                writer.append(indent);
            }
            writer.append(s);
            writer.newLine();
        } catch (IOException ex) {
            throw new RuntimeException(ex);
        }
    }",loop_control
i,"{
        try {
            for (int i = 0; i < this.i; i++) {
                writer.append(indent);
            }
            writer.append(String.format(format, arg));
            writer.newLine();
        } catch (IOException ex) {
            throw new RuntimeException(ex);
        }
    }",loop_control
o,"{
        if (value instanceof ArrayList) {
            DexAnnotationVisitor a = dexAnnotationVisitor.visitArray(k);
            for (Object o : (ArrayList) value) {
                doAccept(a, null, o);
            }
            a.visitEnd();
        } else if (value instanceof Ann) {
            Ann ann = (Ann) value;
            DexAnnotationVisitor a = dexAnnotationVisitor.visitAnnotation(k, ann.name);
            for (Map.Entry<String, Object> e : ann.elements) {
                doAccept(a, e.getKey(), e.getValue());
            }
            a.visitEnd();
        } else if (value instanceof Field) {
            Field f = (Field) value;
            dexAnnotationVisitor.visitEnum(k, f.getOwner(), f.getName());
        } else {
            dexAnnotationVisitor.visit(k, value);
        }
    }",iterator
e,"{
        if (value instanceof ArrayList) {
            DexAnnotationVisitor a = dexAnnotationVisitor.visitArray(k);
            for (Object o : (ArrayList) value) {
                doAccept(a, null, o);
            }
            a.visitEnd();
        } else if (value instanceof Ann) {
            Ann ann = (Ann) value;
            DexAnnotationVisitor a = dexAnnotationVisitor.visitAnnotation(k, ann.name);
            for (Map.Entry<String, Object> e : ann.elements) {
                doAccept(a, e.getKey(), e.getValue());
            }
            a.visitEnd();
        } else if (value instanceof Field) {
            Field f = (Field) value;
            dexAnnotationVisitor.visitEnum(k, f.getOwner(), f.getName());
        } else {
            dexAnnotationVisitor.visit(k, value);
        }
    }",iterator
i,"{
        List<String> list = new ArrayList(5);
        if (desc == null) {
            return list;
        }
        char[] chars = desc.toCharArray();
        int i = 0;
        while (i < chars.length) {
            switch (chars[i]) {
                case 'V':
                case 'Z':
                case 'C':
                case 'B':
                case 'S':
                case 'I':
                case 'F':
                case 'J':
                case 'D':
                    list.add(Character.toString(chars[i]));
                    i++;
                    break;
                case '[': {
                    int count = 1;
                    while (chars[i + count] == '[') {
                        count++;
                    }
                    if (chars[i + count] == 'L') {
                        count++;
                        while (chars[i + count] != ';') {
                            count++;
                        }
                    }
                    count++;
                    list.add(new String(chars, i, count));
                    i += count;
                    break;
                }
                case 'L': {
                    int count = 1;
                    while (chars[i + count] != ';') {
                        ++count;
                    }
                    count++;
                    list.add(new String(chars, i, count));
                    i += count;
                    break;
                }
                default:
                    throw new RuntimeException(""can't parse type list: "" + desc);
            }
        }
        return list;
    }",loop_control
count,"{
        List<String> list = new ArrayList(5);
        if (desc == null) {
            return list;
        }
        char[] chars = desc.toCharArray();
        int i = 0;
        while (i < chars.length) {
            switch (chars[i]) {
                case 'V':
                case 'Z':
                case 'C':
                case 'B':
                case 'S':
                case 'I':
                case 'F':
                case 'J':
                case 'D':
                    list.add(Character.toString(chars[i]));
                    i++;
                    break;
                case '[': {
                    int count = 1;
                    while (chars[i + count] == '[') {
                        count++;
                    }
                    if (chars[i + count] == 'L') {
                        count++;
                        while (chars[i + count] != ';') {
                            count++;
                        }
                    }
                    count++;
                    list.add(new String(chars, i, count));
                    i += count;
                    break;
                }
                case 'L': {
                    int count = 1;
                    while (chars[i + count] != ';') {
                        ++count;
                    }
                    count++;
                    list.add(new String(chars, i, count));
                    i += count;
                    break;
                }
                default:
                    throw new RuntimeException(""can't parse type list: "" + desc);
            }
        }
        return list;
    }",loop_control
i,"{
        int vs[] = new int[ss.size()];
        for (int i = 0; i < ss.size(); i++) {
            vs[i] = parseInt(ss.get(i));
        }
        return vs;
    }",loop_control
i,"{
        byte vs[] = new byte[ss.size()];
        for (int i = 0; i < ss.size(); i++) {
            vs[i] = ((Number) (ss.get(i))).byteValue();
        }
        return vs;
    }",loop_control
op,"{
        for (Op op : Op.values()) {
            ops.put(op.displayName, op);
        }
    }",iterator
i,"{
        for (int i = start; i < end; ) {
            char c = str.charAt(i);
            if (c == '\\') {
                char d = str.charAt(i + 1);
                switch (d) {
                    // ('b'|'t'|'n'|'f'|'r'|'\""'|'\''|'\\')
                    case 'b':
                    case 't':
                    case 'n':
                    case 'f':
                    case 'r':
                    case '\""':
                    case '\'':
                    case '\\':
                        i += 2;
                        break;
                    case 'u':
                        String sub = str.substring(i + 2, i + 6);
                        i += 6;
                        break;
                    default:
                        int x = 0;
                        while (x < 3) {
                            char e = str.charAt(i + 1 + x);
                            if (e >= '0' && e <= '7') {
                                x++;
                            } else {
                                break;
                            }
                        }
                        if (x == 0) {
                            throw new RuntimeException(""can't pase string"");
                        }
                        i += 1 + x;
                }

            } else {
                if (c == dEnd) {
                    return i;
                }
                i++;
            }
        }
        return end;
    }",loop_control
x,"{
        for (int i = start; i < end; ) {
            char c = str.charAt(i);
            if (c == '\\') {
                char d = str.charAt(i + 1);
                switch (d) {
                    // ('b'|'t'|'n'|'f'|'r'|'\""'|'\''|'\\')
                    case 'b':
                    case 't':
                    case 'n':
                    case 'f':
                    case 'r':
                    case '\""':
                    case '\'':
                    case '\\':
                        i += 2;
                        break;
                    case 'u':
                        String sub = str.substring(i + 2, i + 6);
                        i += 6;
                        break;
                    default:
                        int x = 0;
                        while (x < 3) {
                            char e = str.charAt(i + 1 + x);
                            if (e >= '0' && e <= '7') {
                                x++;
                            } else {
                                break;
                            }
                        }
                        if (x == 0) {
                            throw new RuntimeException(""can't pase string"");
                        }
                        i += 1 + x;
                }

            } else {
                if (c == dEnd) {
                    return i;
                }
                i++;
            }
        }
        return end;
    }",loop_control
e,"{
        for (int i = start; i < end; ) {
            char c = str.charAt(i);
            if (c == '\\') {
                char d = str.charAt(i + 1);
                switch (d) {
                    // ('b'|'t'|'n'|'f'|'r'|'\""'|'\''|'\\')
                    case 'b':
                    case 't':
                    case 'n':
                    case 'f':
                    case 'r':
                    case '\""':
                    case '\'':
                    case '\\':
                        i += 2;
                        break;
                    case 'u':
                        String sub = str.substring(i + 2, i + 6);
                        i += 6;
                        break;
                    default:
                        int x = 0;
                        while (x < 3) {
                            char e = str.charAt(i + 1 + x);
                            if (e >= '0' && e <= '7') {
                                x++;
                            } else {
                                break;
                            }
                        }
                        if (x == 0) {
                            throw new RuntimeException(""can't pase string"");
                        }
                        i += 1 + x;
                }

            } else {
                if (c == dEnd) {
                    return i;
                }
                i++;
            }
        }
        return end;
    }",break_loop_control
i,"{

        StringBuilder sb = new StringBuilder();
        for (int i = start; i < end; ) {
            char c = str.charAt(i);
            if (c == '\\') {
                char d = str.charAt(i + 1);
                switch (d) {
                    // ('b'|'t'|'n'|'f'|'r'|'\""'|'\''|'\\')
                    case 'b':
                        sb.append('\b');
                        i += 2;
                        break;
                    case 't':
                        sb.append('\t');
                        i += 2;
                        break;
                    case 'n':
                        sb.append('\n');
                        i += 2;
                        break;
                    case 'f':
                        sb.append('\f');
                        i += 2;
                        break;
                    case 'r':
                        sb.append('\r');
                        i += 2;
                        break;
                    case '\""':
                        sb.append('\""');
                        i += 2;
                        break;
                    case '\'':
                        sb.append('\'');
                        i += 2;
                        break;
                    case '\\':
                        sb.append('\\');
                        i += 2;
                        break;
                    case 'u':
                        String sub = str.substring(i + 2, i + 6);
                        sb.append((char) Integer.parseInt(sub, 16));
                        i += 6;
                        break;
                    default:
                        int x = 0;
                        while (x < 3) {
                            char e = str.charAt(i + 1 + x);
                            if (e >= '0' && e <= '7') {
                                x++;
                            } else {
                                break;
                            }
                        }
                        if (x == 0) {
                            throw new RuntimeException(""can't pase string"");
                        }
                        sb.append((char) Integer.parseInt(str.substring(i + 1, i + 1 + x), 8));
                        i += 1 + x;
                }

            } else {
                sb.append(c);
                i++;
            }
        }
        return sb.toString();
    }",loop_control
x,"{

        StringBuilder sb = new StringBuilder();
        for (int i = start; i < end; ) {
            char c = str.charAt(i);
            if (c == '\\') {
                char d = str.charAt(i + 1);
                switch (d) {
                    // ('b'|'t'|'n'|'f'|'r'|'\""'|'\''|'\\')
                    case 'b':
                        sb.append('\b');
                        i += 2;
                        break;
                    case 't':
                        sb.append('\t');
                        i += 2;
                        break;
                    case 'n':
                        sb.append('\n');
                        i += 2;
                        break;
                    case 'f':
                        sb.append('\f');
                        i += 2;
                        break;
                    case 'r':
                        sb.append('\r');
                        i += 2;
                        break;
                    case '\""':
                        sb.append('\""');
                        i += 2;
                        break;
                    case '\'':
                        sb.append('\'');
                        i += 2;
                        break;
                    case '\\':
                        sb.append('\\');
                        i += 2;
                        break;
                    case 'u':
                        String sub = str.substring(i + 2, i + 6);
                        sb.append((char) Integer.parseInt(sub, 16));
                        i += 6;
                        break;
                    default:
                        int x = 0;
                        while (x < 3) {
                            char e = str.charAt(i + 1 + x);
                            if (e >= '0' && e <= '7') {
                                x++;
                            } else {
                                break;
                            }
                        }
                        if (x == 0) {
                            throw new RuntimeException(""can't pase string"");
                        }
                        sb.append((char) Integer.parseInt(str.substring(i + 1, i + 1 + x), 8));
                        i += 1 + x;
                }

            } else {
                sb.append(c);
                i++;
            }
        }
        return sb.toString();
    }",loop_control
t,"{
        int a = isStatic ? 0 : 1;
        for (String t : m.getParameterTypes()) {
            switch (t.charAt(0)) {
                case 'J':
                case 'D':
                    a += 2;
                    break;
                default:
                    a += 1;
                    break;
            }
        }
        return a;
    }",iterator
i,"{
        int x = reg - locals;
        if (x < 0) {
            return -1;
        }
        int a = isStatic ? 0 : 1;
        String[] parameterTypes = m.getParameterTypes();
        for (int i = 0, parameterTypesLength = parameterTypes.length; i < parameterTypesLength; i++) {

            if (x == a) {
                return i;
            }

            String t = parameterTypes[i];
            switch (t.charAt(0)) {
                case 'J':
                case 'D':
                    a += 2;
                    break;
                default:
                    a += 1;
                    break;
            }
        }
        return -1;
    }",loop_control
i,"{
        int x = part.indexOf('(');
        if (x < 0) {
            throw new RuntimeException();
        }
        int y = part.indexOf(')', x);
        if (y < 0) {
            throw new RuntimeException();
        }

        String methodName = unEscapeId(part.substring(0, x));
        String[] params = toTypeList(part.substring(x + 1, y));
        for (int i = 0; i < params.length; i++) {
            params[i] = unEscapeId(params[i]);
        }
        String ret = unEscapeId(part.substring(y + 1));
        return new Method(owner, methodName, params, ret);
    }",loop_control
name,"{
        byte[] buffer = new byte[4096];
        int num;

        Map<String, Attributes> entries = manifest.getEntries();
        List<String> names = new ArrayList<>(entries.keySet());
        Collections.sort(names);
        for (String name : names) {
            JarEntry inEntry = in.getJarEntry(name);
            JarEntry outEntry = null;
            if (inEntry.getMethod() == JarEntry.STORED) {
                // Preserve the STORED method of the input entry.
                outEntry = new JarEntry(inEntry);
            } else {
                // Create a new entry so that the compressed len is recomputed.
                outEntry = new JarEntry(name);
            }
            outEntry.setTime(timestamp);
            out.putNextEntry(outEntry);

            InputStream data = in.getInputStream(inEntry);
            while ((num = data.read(buffer)) > 0) {
                out.write(buffer, 0, num);
            }
            out.flush();
        }
    }",iterator
num,"{
        byte[] buffer = new byte[4096];
        int num;

        Map<String, Attributes> entries = manifest.getEntries();
        List<String> names = new ArrayList<>(entries.keySet());
        Collections.sort(names);
        for (String name : names) {
            JarEntry inEntry = in.getJarEntry(name);
            JarEntry outEntry = null;
            if (inEntry.getMethod() == JarEntry.STORED) {
                // Preserve the STORED method of the input entry.
                outEntry = new JarEntry(inEntry);
            } else {
                // Create a new entry so that the compressed len is recomputed.
                outEntry = new JarEntry(name);
            }
            outEntry.setTime(timestamp);
            out.putNextEntry(outEntry);

            InputStream data = in.getInputStream(inEntry);
            while ((num = data.read(buffer)) > 0) {
                out.write(buffer, 0, num);
            }
            out.flush();
        }
    }",maybe_loop_control
entry,"{
        Manifest input = jar.getManifest();
        Manifest output = new Manifest();
        Attributes main = output.getMainAttributes();
        if (input != null) {
            main.putAll(input.getMainAttributes());
        }
        main.putValue(""Manifest-Version"", ""1.0"");
        main.putValue(""Created-By"", ""1.6.0_21 (d2j-"" + AbstractJarSign.class.getPackage().getImplementationVersion() + "")"");

        MessageDigest md = MessageDigest.getInstance(digestAlg);
        byte[] buffer = new byte[4096];
        int num;

        // We sort the input entries by name, and add them to the
        // output manifest in sorted order. We expect that the output
        // map will be deterministic.

        TreeMap<String, JarEntry> byName = new TreeMap<String, JarEntry>();

        for (Enumeration<JarEntry> e = jar.entries(); e.hasMoreElements();) {
            JarEntry entry = e.nextElement();
            byName.put(entry.getName(), entry);
        }

        String digName = digestAlg + ""-Digest"";
        for (JarEntry entry : byName.values()) {
            String name = entry.getName();
            if (!entry.isDirectory() && !name.equals(JarFile.MANIFEST_NAME) && !stripPattern.matcher(name).matches()) {
                InputStream data = jar.getInputStream(entry);
                while ((num = data.read(buffer)) > 0) {
                    md.update(buffer, 0, num);
                }

                Attributes attr = null;
                if (input != null) {
                    attr = input.getAttributes(name);
                }
                attr = attr != null ? new Attributes(attr) : new Attributes();
                attr.putValue(digName, encodeBase64(md.digest()));
                output.getEntries().put(name, attr);
            }
        }

        return output;
    }",iterator
e,"{
        Manifest input = jar.getManifest();
        Manifest output = new Manifest();
        Attributes main = output.getMainAttributes();
        if (input != null) {
            main.putAll(input.getMainAttributes());
        }
        main.putValue(""Manifest-Version"", ""1.0"");
        main.putValue(""Created-By"", ""1.6.0_21 (d2j-"" + AbstractJarSign.class.getPackage().getImplementationVersion() + "")"");

        MessageDigest md = MessageDigest.getInstance(digestAlg);
        byte[] buffer = new byte[4096];
        int num;

        // We sort the input entries by name, and add them to the
        // output manifest in sorted order. We expect that the output
        // map will be deterministic.

        TreeMap<String, JarEntry> byName = new TreeMap<String, JarEntry>();

        for (Enumeration<JarEntry> e = jar.entries(); e.hasMoreElements();) {
            JarEntry entry = e.nextElement();
            byName.put(entry.getName(), entry);
        }

        String digName = digestAlg + ""-Digest"";
        for (JarEntry entry : byName.values()) {
            String name = entry.getName();
            if (!entry.isDirectory() && !name.equals(JarFile.MANIFEST_NAME) && !stripPattern.matcher(name).matches()) {
                InputStream data = jar.getInputStream(entry);
                while ((num = data.read(buffer)) > 0) {
                    md.update(buffer, 0, num);
                }

                Attributes attr = null;
                if (input != null) {
                    attr = input.getAttributes(name);
                }
                attr = attr != null ? new Attributes(attr) : new Attributes();
                attr.putValue(digName, encodeBase64(md.digest()));
                output.getEntries().put(name, attr);
            }
        }

        return output;
    }",iterator
num,"{
        Manifest input = jar.getManifest();
        Manifest output = new Manifest();
        Attributes main = output.getMainAttributes();
        if (input != null) {
            main.putAll(input.getMainAttributes());
        }
        main.putValue(""Manifest-Version"", ""1.0"");
        main.putValue(""Created-By"", ""1.6.0_21 (d2j-"" + AbstractJarSign.class.getPackage().getImplementationVersion() + "")"");

        MessageDigest md = MessageDigest.getInstance(digestAlg);
        byte[] buffer = new byte[4096];
        int num;

        // We sort the input entries by name, and add them to the
        // output manifest in sorted order. We expect that the output
        // map will be deterministic.

        TreeMap<String, JarEntry> byName = new TreeMap<String, JarEntry>();

        for (Enumeration<JarEntry> e = jar.entries(); e.hasMoreElements();) {
            JarEntry entry = e.nextElement();
            byName.put(entry.getName(), entry);
        }

        String digName = digestAlg + ""-Digest"";
        for (JarEntry entry : byName.values()) {
            String name = entry.getName();
            if (!entry.isDirectory() && !name.equals(JarFile.MANIFEST_NAME) && !stripPattern.matcher(name).matches()) {
                InputStream data = jar.getInputStream(entry);
                while ((num = data.read(buffer)) > 0) {
                    md.update(buffer, 0, num);
                }

                Attributes attr = null;
                if (input != null) {
                    attr = input.getAttributes(name);
                }
                attr = attr != null ? new Attributes(attr) : new Attributes();
                attr.putValue(digName, encodeBase64(md.digest()));
                output.getEntries().put(name, attr);
            }
        }

        return output;
    }",maybe_loop_control
entry,"{
        Manifest sf = new Manifest();
        Attributes main = sf.getMainAttributes();
        main.putValue(""Signature-Version"", ""1.0"");
        main.putValue(""Created-By"", ""1.6.0_21 (d2j-"" + AbstractJarSign.class.getPackage().getImplementationVersion() + "")"");

        MessageDigest md = MessageDigest.getInstance(digestAlg);
        DigestOutputStream print = new DigestOutputStream(new OutputStream() {

            @Override
            public void write(byte[] b) throws IOException {

            }

            @Override
            public void write(byte[] b, int off, int len) throws IOException {

            }

            @Override
            public void write(int b) throws IOException {

            }
        }, md);

        // Digest of the entire manifest
        manifest.write(print);
        print.flush();
        main.putValue(digestAlg + ""-Digest-Manifest"", encodeBase64(md.digest()));

        // digest main attribute
        Manifest m2 = new Manifest();
        m2.getMainAttributes().putAll(manifest.getMainAttributes());
        m2.write(print);
        main.putValue(digestAlg + ""-Digest-Manifest-Main-Attributes"", encodeBase64(md.digest()));

        String digName = digestAlg + ""-Digest"";
        Map<String, Attributes> entries = manifest.getEntries();

        for (Map.Entry<String, Attributes> entry : entries.entrySet()) {
            // Digest of the manifest stanza for this entry.
            print.write(NAMES);
            print.write(entry.getKey().getBytes(StandardCharsets.UTF_8));
            print.write(EOL);
            for (Map.Entry<Object, Object> att : entry.getValue().entrySet()) {
                print.write(att.getKey().toString().getBytes(StandardCharsets.UTF_8));
                print.write(COL);
                print.write(att.getKey().toString().getBytes(StandardCharsets.UTF_8));
                print.write(EOL);
            }
            print.write(EOL);
            print.flush();

            Attributes sfAttr = new Attributes();
            sfAttr.putValue(digName, encodeBase64(md.digest()));
            sf.getEntries().put(entry.getKey(), sfAttr);
        }

        sf.write(out);

        // A bug in the java.util.jar implementation of Android platforms
        // up to version 1.6 will cause a spurious IOException to be thrown
        // if the length of the signature file is a multiple of 1024 bytes.
        // As a workaround, add an extra CRLF in this case.
        if ((out.size() % 1024) == 0) {
            out.write(EOL);
        }
    }",iterator
att,"{
        Manifest sf = new Manifest();
        Attributes main = sf.getMainAttributes();
        main.putValue(""Signature-Version"", ""1.0"");
        main.putValue(""Created-By"", ""1.6.0_21 (d2j-"" + AbstractJarSign.class.getPackage().getImplementationVersion() + "")"");

        MessageDigest md = MessageDigest.getInstance(digestAlg);
        DigestOutputStream print = new DigestOutputStream(new OutputStream() {

            @Override
            public void write(byte[] b) throws IOException {

            }

            @Override
            public void write(byte[] b, int off, int len) throws IOException {

            }

            @Override
            public void write(int b) throws IOException {

            }
        }, md);

        // Digest of the entire manifest
        manifest.write(print);
        print.flush();
        main.putValue(digestAlg + ""-Digest-Manifest"", encodeBase64(md.digest()));

        // digest main attribute
        Manifest m2 = new Manifest();
        m2.getMainAttributes().putAll(manifest.getMainAttributes());
        m2.write(print);
        main.putValue(digestAlg + ""-Digest-Manifest-Main-Attributes"", encodeBase64(md.digest()));

        String digName = digestAlg + ""-Digest"";
        Map<String, Attributes> entries = manifest.getEntries();

        for (Map.Entry<String, Attributes> entry : entries.entrySet()) {
            // Digest of the manifest stanza for this entry.
            print.write(NAMES);
            print.write(entry.getKey().getBytes(StandardCharsets.UTF_8));
            print.write(EOL);
            for (Map.Entry<Object, Object> att : entry.getValue().entrySet()) {
                print.write(att.getKey().toString().getBytes(StandardCharsets.UTF_8));
                print.write(COL);
                print.write(att.getKey().toString().getBytes(StandardCharsets.UTF_8));
                print.write(EOL);
            }
            print.write(EOL);
            print.flush();

            Attributes sfAttr = new Attributes();
            sfAttr.putValue(digName, encodeBase64(md.digest()));
            sf.getEntries().put(entry.getKey(), sfAttr);
        }

        sf.write(out);

        // A bug in the java.util.jar implementation of Android platforms
        // up to version 1.6 will cause a spurious IOException to be thrown
        // if the length of the signature file is a multiple of 1024 bytes.
        // As a workaround, add an extra CRLF in this case.
        if ((out.size() % 1024) == 0) {
            out.write(EOL);
        }
    }",iterator
p,"{
            if (this.state == 6) return false;

            int p = offset;
            len += offset;

            // Using local variables makes the decoder about 12%
            // faster than if we manipulate the member variables in
            // the loop.  (Even alphabet makes a measurable
            // difference, which is somewhat surprising to me since
            // the member variable is final.)
            int state = this.state;
            int value = this.value;
            int op = 0;
            final byte[] output = this.output;
            final int[] alphabet = this.alphabet;

            while (p < len) {
                // Try the fast path:  we're starting a new tuple and the
                // next four bytes of the input stream are all data
                // bytes.  This corresponds to going through states
                // 0-1-2-3-0.  We expect to use this method for most of
                // the data.
                //
                // If any of the next four bytes of input are non-data
                // (whitespace, etc.), value will end up negative.  (All
                // the non-data values in decode are small negative
                // numbers, so shifting any of them up and or'ing them
                // together will result in a value with its top bit set.)
                //
                // You can remove this whole block and the output should
                // be the same, just slower.
                if (state == 0) {
                    while (p+4 <= len &&
                           (value = ((alphabet[input[p] & 0xff] << 18) |
                                     (alphabet[input[p+1] & 0xff] << 12) |
                                     (alphabet[input[p+2] & 0xff] << 6) |
                                     (alphabet[input[p+3] & 0xff]))) >= 0) {
                        output[op+2] = (byte) value;
                        output[op+1] = (byte) (value >> 8);
                        output[op] = (byte) (value >> 16);
                        op += 3;
                        p += 4;
                    }
                    if (p >= len) break;
                }

                // The fast path isn't available -- either we've read a
                // partial tuple, or the next four input bytes aren't all
                // data, or whatever.  Fall back to the slower state
                // machine implementation.

                int d = alphabet[input[p++] & 0xff];

                switch (state) {
                case 0:
                    if (d >= 0) {
                        value = d;
                        ++state;
                    } else if (d != SKIP) {
                        this.state = 6;
                        return false;
                    }
                    break;

                case 1:
                    if (d >= 0) {
                        value = (value << 6) | d;
                        ++state;
                    } else if (d != SKIP) {
                        this.state = 6;
                        return false;
                    }
                    break;

                case 2:
                    if (d >= 0) {
                        value = (value << 6) | d;
                        ++state;
                    } else if (d == EQUALS) {
                        // Emit the last (partial) output tuple;
                        // expect exactly one more padding character.
                        output[op++] = (byte) (value >> 4);
                        state = 4;
                    } else if (d != SKIP) {
                        this.state = 6;
                        return false;
                    }
                    break;

                case 3:
                    if (d >= 0) {
                        // Emit the output triple and return to state 0.
                        value = (value << 6) | d;
                        output[op+2] = (byte) value;
                        output[op+1] = (byte) (value >> 8);
                        output[op] = (byte) (value >> 16);
                        op += 3;
                        state = 0;
                    } else if (d == EQUALS) {
                        // Emit the last (partial) output tuple;
                        // expect no further data or padding characters.
                        output[op+1] = (byte) (value >> 2);
                        output[op] = (byte) (value >> 10);
                        op += 2;
                        state = 5;
                    } else if (d != SKIP) {
                        this.state = 6;
                        return false;
                    }
                    break;

                case 4:
                    if (d == EQUALS) {
                        ++state;
                    } else if (d != SKIP) {
                        this.state = 6;
                        return false;
                    }
                    break;

                case 5:
                    if (d != SKIP) {
                        this.state = 6;
                        return false;
                    }
                    break;
                }
            }

            if (!finish) {
                // We're out of input, but a future call could provide
                // more.
                this.state = state;
                this.value = value;
                this.op = op;
                return true;
            }

            // Done reading input.  Now figure out where we are left in
            // the state machine and finish up.

            switch (state) {
            case 0:
                // Output length is a multiple of three.  Fine.
                break;
            case 1:
                // Read one extra input byte, which isn't enough to
                // make another output byte.  Illegal.
                this.state = 6;
                return false;
            case 2:
                // Read two extra input bytes, enough to emit 1 more
                // output byte.  Fine.
                output[op++] = (byte) (value >> 4);
                break;
            case 3:
                // Read three extra input bytes, enough to emit 2 more
                // output bytes.  Fine.
                output[op++] = (byte) (value >> 10);
                output[op++] = (byte) (value >> 2);
                break;
            case 4:
                // Read one padding '=' when we expected 2.  Illegal.
                this.state = 6;
                return false;
            case 5:
                // Read all the padding '='s we expected and no more.
                // Fine.
                break;
            }

            this.state = state;
            this.op = op;
            return true;
        }",loop_control
value,"{
            if (this.state == 6) return false;

            int p = offset;
            len += offset;

            // Using local variables makes the decoder about 12%
            // faster than if we manipulate the member variables in
            // the loop.  (Even alphabet makes a measurable
            // difference, which is somewhat surprising to me since
            // the member variable is final.)
            int state = this.state;
            int value = this.value;
            int op = 0;
            final byte[] output = this.output;
            final int[] alphabet = this.alphabet;

            while (p < len) {
                // Try the fast path:  we're starting a new tuple and the
                // next four bytes of the input stream are all data
                // bytes.  This corresponds to going through states
                // 0-1-2-3-0.  We expect to use this method for most of
                // the data.
                //
                // If any of the next four bytes of input are non-data
                // (whitespace, etc.), value will end up negative.  (All
                // the non-data values in decode are small negative
                // numbers, so shifting any of them up and or'ing them
                // together will result in a value with its top bit set.)
                //
                // You can remove this whole block and the output should
                // be the same, just slower.
                if (state == 0) {
                    while (p+4 <= len &&
                           (value = ((alphabet[input[p] & 0xff] << 18) |
                                     (alphabet[input[p+1] & 0xff] << 12) |
                                     (alphabet[input[p+2] & 0xff] << 6) |
                                     (alphabet[input[p+3] & 0xff]))) >= 0) {
                        output[op+2] = (byte) value;
                        output[op+1] = (byte) (value >> 8);
                        output[op] = (byte) (value >> 16);
                        op += 3;
                        p += 4;
                    }
                    if (p >= len) break;
                }

                // The fast path isn't available -- either we've read a
                // partial tuple, or the next four input bytes aren't all
                // data, or whatever.  Fall back to the slower state
                // machine implementation.

                int d = alphabet[input[p++] & 0xff];

                switch (state) {
                case 0:
                    if (d >= 0) {
                        value = d;
                        ++state;
                    } else if (d != SKIP) {
                        this.state = 6;
                        return false;
                    }
                    break;

                case 1:
                    if (d >= 0) {
                        value = (value << 6) | d;
                        ++state;
                    } else if (d != SKIP) {
                        this.state = 6;
                        return false;
                    }
                    break;

                case 2:
                    if (d >= 0) {
                        value = (value << 6) | d;
                        ++state;
                    } else if (d == EQUALS) {
                        // Emit the last (partial) output tuple;
                        // expect exactly one more padding character.
                        output[op++] = (byte) (value >> 4);
                        state = 4;
                    } else if (d != SKIP) {
                        this.state = 6;
                        return false;
                    }
                    break;

                case 3:
                    if (d >= 0) {
                        // Emit the output triple and return to state 0.
                        value = (value << 6) | d;
                        output[op+2] = (byte) value;
                        output[op+1] = (byte) (value >> 8);
                        output[op] = (byte) (value >> 16);
                        op += 3;
                        state = 0;
                    } else if (d == EQUALS) {
                        // Emit the last (partial) output tuple;
                        // expect no further data or padding characters.
                        output[op+1] = (byte) (value >> 2);
                        output[op] = (byte) (value >> 10);
                        op += 2;
                        state = 5;
                    } else if (d != SKIP) {
                        this.state = 6;
                        return false;
                    }
                    break;

                case 4:
                    if (d == EQUALS) {
                        ++state;
                    } else if (d != SKIP) {
                        this.state = 6;
                        return false;
                    }
                    break;

                case 5:
                    if (d != SKIP) {
                        this.state = 6;
                        return false;
                    }
                    break;
                }
            }

            if (!finish) {
                // We're out of input, but a future call could provide
                // more.
                this.state = state;
                this.value = value;
                this.op = op;
                return true;
            }

            // Done reading input.  Now figure out where we are left in
            // the state machine and finish up.

            switch (state) {
            case 0:
                // Output length is a multiple of three.  Fine.
                break;
            case 1:
                // Read one extra input byte, which isn't enough to
                // make another output byte.  Illegal.
                this.state = 6;
                return false;
            case 2:
                // Read two extra input bytes, enough to emit 1 more
                // output byte.  Fine.
                output[op++] = (byte) (value >> 4);
                break;
            case 3:
                // Read three extra input bytes, enough to emit 2 more
                // output bytes.  Fine.
                output[op++] = (byte) (value >> 10);
                output[op++] = (byte) (value >> 2);
                break;
            case 4:
                // Read one padding '=' when we expected 2.  Illegal.
                this.state = 6;
                return false;
            case 5:
                // Read all the padding '='s we expected and no more.
                // Fine.
                break;
            }

            this.state = state;
            this.op = op;
            return true;
        }",loop_control
tailLen,"{
            // Using local variables makes the encoder about 9% faster.
            final byte[] alphabet = this.alphabet;
            final byte[] output = this.output;
            int op = 0;
            int count = this.count;

            int p = offset;
            len += offset;
            int v = -1;

            // First we need to concatenate the tail of the previous call
            // with any input bytes available now and see if we can empty
            // the tail.

            switch (tailLen) {
                case 0:
                    // There was no tail.
                    break;

                case 1:
                    if (p+2 <= len) {
                        // A 1-byte tail with at least 2 bytes of
                        // input available now.
                        v = ((tail[0] & 0xff) << 16) |
                            ((input[p++] & 0xff) << 8) |
                            (input[p++] & 0xff);
                        tailLen = 0;
                    };
                    break;

                case 2:
                    if (p+1 <= len) {
                        // A 2-byte tail with at least 1 byte of input.
                        v = ((tail[0] & 0xff) << 16) |
                            ((tail[1] & 0xff) << 8) |
                            (input[p++] & 0xff);
                        tailLen = 0;
                    }
                    break;
            }

            if (v != -1) {
                output[op++] = alphabet[(v >> 18) & 0x3f];
                output[op++] = alphabet[(v >> 12) & 0x3f];
                output[op++] = alphabet[(v >> 6) & 0x3f];
                output[op++] = alphabet[v & 0x3f];
                if (--count == 0) {
                    if (do_cr) output[op++] = '\r';
                    output[op++] = '\n';
                    count = LINE_GROUPS;
                }
            }

            // At this point either there is no tail, or there are fewer
            // than 3 bytes of input available.

            // The main loop, turning 3 input bytes into 4 output bytes on
            // each iteration.
            while (p+3 <= len) {
                v = ((input[p] & 0xff) << 16) |
                    ((input[p+1] & 0xff) << 8) |
                    (input[p+2] & 0xff);
                output[op] = alphabet[(v >> 18) & 0x3f];
                output[op+1] = alphabet[(v >> 12) & 0x3f];
                output[op+2] = alphabet[(v >> 6) & 0x3f];
                output[op+3] = alphabet[v & 0x3f];
                p += 3;
                op += 4;
                if (--count == 0) {
                    if (do_cr) output[op++] = '\r';
                    output[op++] = '\n';
                    count = LINE_GROUPS;
                }
            }

            if (finish) {
                // Finish up the tail of the input.  Note that we need to
                // consume any bytes in tail before any bytes
                // remaining in input; there should be at most two bytes
                // total.

                if (p-tailLen == len-1) {
                    int t = 0;
                    v = ((tailLen > 0 ? tail[t++] : input[p++]) & 0xff) << 4;
                    tailLen -= t;
                    output[op++] = alphabet[(v >> 6) & 0x3f];
                    output[op++] = alphabet[v & 0x3f];
                    if (do_padding) {
                        output[op++] = '=';
                        output[op++] = '=';
                    }
                    if (do_newline) {
                        if (do_cr) output[op++] = '\r';
                        output[op++] = '\n';
                    }
                } else if (p-tailLen == len-2) {
                    int t = 0;
                    v = (((tailLen > 1 ? tail[t++] : input[p++]) & 0xff) << 10) |
                        (((tailLen > 0 ? tail[t++] : input[p++]) & 0xff) << 2);
                    tailLen -= t;
                    output[op++] = alphabet[(v >> 12) & 0x3f];
                    output[op++] = alphabet[(v >> 6) & 0x3f];
                    output[op++] = alphabet[v & 0x3f];
                    if (do_padding) {
                        output[op++] = '=';
                    }
                    if (do_newline) {
                        if (do_cr) output[op++] = '\r';
                        output[op++] = '\n';
                    }
                } else if (do_newline && op > 0 && count != LINE_GROUPS) {
                    if (do_cr) output[op++] = '\r';
                    output[op++] = '\n';
                }

                assert tailLen == 0;
                assert p == len;
            } else {
                // Save the leftovers in tail to be consumed on the next
                // call to encodeInternal.

                if (p == len-1) {
                    tail[tailLen++] = input[p];
                } else if (p == len-2) {
                    tail[tailLen++] = input[p];
                    tail[tailLen++] = input[p+1];
                }
            }

            this.op = op;
            this.count = count;

            return true;
        }",loop_control
p,"{
        final List<ClassInfo> clzList = new ArrayList<ClassInfo>();
        final ClassVisitor collectVisitor = new ClassVisitor(ASM4) {
            private static final String ASSERTION_DISABLED_FIELD_NAME = ""$assertionsDisabled"";
            private static final String ENUM_VALUES_FIELD_NAME = ""ENUM$VALUES"";
            ClassInfo clz;
            boolean isEnum = false;
            Map<String, String> enumFieldMap = new HashMap<String, String>();

            @Override
            public void visitSource(String source, String debug) {
                if (initSourceNames && !clz.name.contains(""$"") && source.endsWith("".java"")) {
                    clz.suggestName = source.substring(0, source.length() - 5);
                }
            }

            @Override
            public MethodVisitor visitMethod(int access, String name, String desc, String signature, String[] exceptions) {
                clz.addMethod(access, name, desc);
                if (initEnumNames && isEnum && name.equals(""<clinit>"")) {
                    final String thisDesc = ""L"" + clz.name + "";"";
                    return new MethodNode(ASM4, access, name, desc, signature, exceptions) {
                        @Override
                        public void visitEnd() {
                            if (this.instructions != null) {
                                int status = 0;
                                String eFieldName = null;
                                for (AbstractInsnNode p = this.instructions.getFirst(); p != null; p = p.getNext()) {
                                    //looking for  NEW,DUP,LDC,PUTSTATUS

                                    if (status == 0) {  // init
                                        if (p.getOpcode() == NEW) {
                                            TypeInsnNode ti = (TypeInsnNode) p;
                                            if (thisDesc.equals(ti.desc)) {
                                                status = 1;
                                            }
                                        }
                                    } else if (status == 1) {  // find NEW
                                        if (p.getOpcode() == DUP) {
                                            status = 2;
                                        } else {
                                            status = 0;
                                        }
                                    } else if (status == 2) {  //find DUP
                                        if (p.getOpcode() == LDC) {
                                            LdcInsnNode ldc = (LdcInsnNode) p;
                                            if (ldc.cst instanceof String) {
                                                eFieldName = (String) ldc.cst;
                                                status = 3;
                                            } else {
                                                status = 0;
                                            }
                                        } else {
                                            status = 0;
                                        }
                                    } else if (status == 3) {  //find LDC
                                        if (p.getOpcode() == PUTSTATIC) {
                                            FieldInsnNode fin = (FieldInsnNode) p;
                                            if (fin.owner.equals(thisDesc) && fin.desc.equals(thisDesc)) {
                                                if (!fin.name.equals(eFieldName)) {
                                                    enumFieldMap.put(fin.name, eFieldName);
                                                }
                                                eFieldName = null;
                                                status = 0;
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    };
                }
                return null;
            }

            @Override
            public FieldVisitor visitField(int access, String name, String desc, String signature, Object value) {
                MemberInfo mi = clz.addField(access, name, desc);
                if (initEnumNames && isEnum
                        && isPrivate(access) && isFinal(access) && isSynthetic(access)
                        && !ENUM_VALUES_FIELD_NAME.equals(name)
                        && (""[L"" + clz.name + "";"").equals(desc)) {
                    mi.suggestName = ENUM_VALUES_FIELD_NAME;
                }
                if (initAssertionNames && isSynthetic(access) && isStatic(access)
                        && !isPrivate(access) && !isPublic(access) && !isProtected(access)
                        && desc.equals(""Z"") && !ASSERTION_DISABLED_FIELD_NAME.equals(name)) {
                    mi.suggestName = ASSERTION_DISABLED_FIELD_NAME;
                }

                return null;
            }

            @Override
            public void visitEnd() {
                if (initEnumNames) {
                    final String thisDesc = ""L"" + clz.name + "";"";
                    for (Map.Entry<String, String> e : enumFieldMap.entrySet()) {
                        String name = e.getKey();
                        String suggestName = e.getValue();
                        for (MemberInfo mi : clz.fields) {
                            if (isFinal(mi.access) && isStatic(mi.access)
                                    && mi.name.equals(name) && mi.desc.equals(thisDesc)) {
                                mi.suggestName = suggestName;
                            }
                        }
                    }
                }
                clzList.add(clz);
                clz = null;
                isEnum = false;
                enumFieldMap.clear();
            }

            @Override
            public void visit(int version, int access, String name, String signature, String superName, String[] interfaces) {
                this.clz = new ClassInfo(name);
                isEnum = isEnum(access);
            }
        };

      try(FileSystem fs = BaseCmd.openZip(file)) {
          BaseCmd.walkJarOrDir(fs.getPath(""/""), new BaseCmd.FileVisitorX() {
              @Override
              public void visitFile(Path file, String relative) throws IOException {
                  if (relative.endsWith("".class"")) {
                      byte data[] = Files.readAllBytes(file);
                      new ClassReader(data).accept(collectVisitor, ClassReader.EXPAND_FRAMES);
                  }
              }
          });
      }
        return clzList;
    }",iterator
e,"{
        final List<ClassInfo> clzList = new ArrayList<ClassInfo>();
        final ClassVisitor collectVisitor = new ClassVisitor(ASM4) {
            private static final String ASSERTION_DISABLED_FIELD_NAME = ""$assertionsDisabled"";
            private static final String ENUM_VALUES_FIELD_NAME = ""ENUM$VALUES"";
            ClassInfo clz;
            boolean isEnum = false;
            Map<String, String> enumFieldMap = new HashMap<String, String>();

            @Override
            public void visitSource(String source, String debug) {
                if (initSourceNames && !clz.name.contains(""$"") && source.endsWith("".java"")) {
                    clz.suggestName = source.substring(0, source.length() - 5);
                }
            }

            @Override
            public MethodVisitor visitMethod(int access, String name, String desc, String signature, String[] exceptions) {
                clz.addMethod(access, name, desc);
                if (initEnumNames && isEnum && name.equals(""<clinit>"")) {
                    final String thisDesc = ""L"" + clz.name + "";"";
                    return new MethodNode(ASM4, access, name, desc, signature, exceptions) {
                        @Override
                        public void visitEnd() {
                            if (this.instructions != null) {
                                int status = 0;
                                String eFieldName = null;
                                for (AbstractInsnNode p = this.instructions.getFirst(); p != null; p = p.getNext()) {
                                    //looking for  NEW,DUP,LDC,PUTSTATUS

                                    if (status == 0) {  // init
                                        if (p.getOpcode() == NEW) {
                                            TypeInsnNode ti = (TypeInsnNode) p;
                                            if (thisDesc.equals(ti.desc)) {
                                                status = 1;
                                            }
                                        }
                                    } else if (status == 1) {  // find NEW
                                        if (p.getOpcode() == DUP) {
                                            status = 2;
                                        } else {
                                            status = 0;
                                        }
                                    } else if (status == 2) {  //find DUP
                                        if (p.getOpcode() == LDC) {
                                            LdcInsnNode ldc = (LdcInsnNode) p;
                                            if (ldc.cst instanceof String) {
                                                eFieldName = (String) ldc.cst;
                                                status = 3;
                                            } else {
                                                status = 0;
                                            }
                                        } else {
                                            status = 0;
                                        }
                                    } else if (status == 3) {  //find LDC
                                        if (p.getOpcode() == PUTSTATIC) {
                                            FieldInsnNode fin = (FieldInsnNode) p;
                                            if (fin.owner.equals(thisDesc) && fin.desc.equals(thisDesc)) {
                                                if (!fin.name.equals(eFieldName)) {
                                                    enumFieldMap.put(fin.name, eFieldName);
                                                }
                                                eFieldName = null;
                                                status = 0;
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    };
                }
                return null;
            }

            @Override
            public FieldVisitor visitField(int access, String name, String desc, String signature, Object value) {
                MemberInfo mi = clz.addField(access, name, desc);
                if (initEnumNames && isEnum
                        && isPrivate(access) && isFinal(access) && isSynthetic(access)
                        && !ENUM_VALUES_FIELD_NAME.equals(name)
                        && (""[L"" + clz.name + "";"").equals(desc)) {
                    mi.suggestName = ENUM_VALUES_FIELD_NAME;
                }
                if (initAssertionNames && isSynthetic(access) && isStatic(access)
                        && !isPrivate(access) && !isPublic(access) && !isProtected(access)
                        && desc.equals(""Z"") && !ASSERTION_DISABLED_FIELD_NAME.equals(name)) {
                    mi.suggestName = ASSERTION_DISABLED_FIELD_NAME;
                }

                return null;
            }

            @Override
            public void visitEnd() {
                if (initEnumNames) {
                    final String thisDesc = ""L"" + clz.name + "";"";
                    for (Map.Entry<String, String> e : enumFieldMap.entrySet()) {
                        String name = e.getKey();
                        String suggestName = e.getValue();
                        for (MemberInfo mi : clz.fields) {
                            if (isFinal(mi.access) && isStatic(mi.access)
                                    && mi.name.equals(name) && mi.desc.equals(thisDesc)) {
                                mi.suggestName = suggestName;
                            }
                        }
                    }
                }
                clzList.add(clz);
                clz = null;
                isEnum = false;
                enumFieldMap.clear();
            }

            @Override
            public void visit(int version, int access, String name, String signature, String superName, String[] interfaces) {
                this.clz = new ClassInfo(name);
                isEnum = isEnum(access);
            }
        };

      try(FileSystem fs = BaseCmd.openZip(file)) {
          BaseCmd.walkJarOrDir(fs.getPath(""/""), new BaseCmd.FileVisitorX() {
              @Override
              public void visitFile(Path file, String relative) throws IOException {
                  if (relative.endsWith("".class"")) {
                      byte data[] = Files.readAllBytes(file);
                      new ClassReader(data).accept(collectVisitor, ClassReader.EXPAND_FRAMES);
                  }
              }
          });
      }
        return clzList;
    }",iterator
mi,"{
        final List<ClassInfo> clzList = new ArrayList<ClassInfo>();
        final ClassVisitor collectVisitor = new ClassVisitor(ASM4) {
            private static final String ASSERTION_DISABLED_FIELD_NAME = ""$assertionsDisabled"";
            private static final String ENUM_VALUES_FIELD_NAME = ""ENUM$VALUES"";
            ClassInfo clz;
            boolean isEnum = false;
            Map<String, String> enumFieldMap = new HashMap<String, String>();

            @Override
            public void visitSource(String source, String debug) {
                if (initSourceNames && !clz.name.contains(""$"") && source.endsWith("".java"")) {
                    clz.suggestName = source.substring(0, source.length() - 5);
                }
            }

            @Override
            public MethodVisitor visitMethod(int access, String name, String desc, String signature, String[] exceptions) {
                clz.addMethod(access, name, desc);
                if (initEnumNames && isEnum && name.equals(""<clinit>"")) {
                    final String thisDesc = ""L"" + clz.name + "";"";
                    return new MethodNode(ASM4, access, name, desc, signature, exceptions) {
                        @Override
                        public void visitEnd() {
                            if (this.instructions != null) {
                                int status = 0;
                                String eFieldName = null;
                                for (AbstractInsnNode p = this.instructions.getFirst(); p != null; p = p.getNext()) {
                                    //looking for  NEW,DUP,LDC,PUTSTATUS

                                    if (status == 0) {  // init
                                        if (p.getOpcode() == NEW) {
                                            TypeInsnNode ti = (TypeInsnNode) p;
                                            if (thisDesc.equals(ti.desc)) {
                                                status = 1;
                                            }
                                        }
                                    } else if (status == 1) {  // find NEW
                                        if (p.getOpcode() == DUP) {
                                            status = 2;
                                        } else {
                                            status = 0;
                                        }
                                    } else if (status == 2) {  //find DUP
                                        if (p.getOpcode() == LDC) {
                                            LdcInsnNode ldc = (LdcInsnNode) p;
                                            if (ldc.cst instanceof String) {
                                                eFieldName = (String) ldc.cst;
                                                status = 3;
                                            } else {
                                                status = 0;
                                            }
                                        } else {
                                            status = 0;
                                        }
                                    } else if (status == 3) {  //find LDC
                                        if (p.getOpcode() == PUTSTATIC) {
                                            FieldInsnNode fin = (FieldInsnNode) p;
                                            if (fin.owner.equals(thisDesc) && fin.desc.equals(thisDesc)) {
                                                if (!fin.name.equals(eFieldName)) {
                                                    enumFieldMap.put(fin.name, eFieldName);
                                                }
                                                eFieldName = null;
                                                status = 0;
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    };
                }
                return null;
            }

            @Override
            public FieldVisitor visitField(int access, String name, String desc, String signature, Object value) {
                MemberInfo mi = clz.addField(access, name, desc);
                if (initEnumNames && isEnum
                        && isPrivate(access) && isFinal(access) && isSynthetic(access)
                        && !ENUM_VALUES_FIELD_NAME.equals(name)
                        && (""[L"" + clz.name + "";"").equals(desc)) {
                    mi.suggestName = ENUM_VALUES_FIELD_NAME;
                }
                if (initAssertionNames && isSynthetic(access) && isStatic(access)
                        && !isPrivate(access) && !isPublic(access) && !isProtected(access)
                        && desc.equals(""Z"") && !ASSERTION_DISABLED_FIELD_NAME.equals(name)) {
                    mi.suggestName = ASSERTION_DISABLED_FIELD_NAME;
                }

                return null;
            }

            @Override
            public void visitEnd() {
                if (initEnumNames) {
                    final String thisDesc = ""L"" + clz.name + "";"";
                    for (Map.Entry<String, String> e : enumFieldMap.entrySet()) {
                        String name = e.getKey();
                        String suggestName = e.getValue();
                        for (MemberInfo mi : clz.fields) {
                            if (isFinal(mi.access) && isStatic(mi.access)
                                    && mi.name.equals(name) && mi.desc.equals(thisDesc)) {
                                mi.suggestName = suggestName;
                            }
                        }
                    }
                }
                clzList.add(clz);
                clz = null;
                isEnum = false;
                enumFieldMap.clear();
            }

            @Override
            public void visit(int version, int access, String name, String signature, String superName, String[] interfaces) {
                this.clz = new ClassInfo(name);
                isEnum = isEnum(access);
            }
        };

      try(FileSystem fs = BaseCmd.openZip(file)) {
          BaseCmd.walkJarOrDir(fs.getPath(""/""), new BaseCmd.FileVisitorX() {
              @Override
              public void visitFile(Path file, String relative) throws IOException {
                  if (relative.endsWith("".class"")) {
                      byte data[] = Files.readAllBytes(file);
                      new ClassReader(data).accept(collectVisitor, ClassReader.EXPAND_FRAMES);
                  }
              }
          });
      }
        return clzList;
    }",iterator
it,"{
        Iterator<MemberInfo> it = members.iterator();
        if (it.hasNext()) {
            MemberInfo current = it.next();
            while (true) {
                if (it.hasNext()) {
                    MemberInfo next = it.next();
                    if (current.name.equals(next.name)) {
                        int x = 1;
                        doMember(owner, current, x++);
                        doMember(owner, next, x++);
                        while (it.hasNext()) {
                            next = it.next();
                            if (current.name.equals(next.name)) {
                                doMember(owner, next, x++);
                            } else {
                                current = next;
                                break;
                            }
                        }
                    } else {
                        doMember(owner, current, 0);
                        current = next;
                    }
                } else {
                    doMember(owner, current, 0);
                    break;
                }
            }
        }
    }",iterator
ci,"{
        MemberInfoComparator comparator = new MemberInfoComparator();
        for (ClassInfo ci : classInfoList) {
            doClass0(ci.name);
            Collections.sort(ci.fields, comparator);
            transformerMember(ci.name, ci.fields);
            Collections.sort(ci.methods, comparator);
            transformerMember(ci.name, ci.methods);
        }

    }",iterator
ln,"{
        try (BufferedReader r = new BufferedReader(new InputStreamReader(is, StandardCharsets.UTF_8))) {
            List<String> list = new ArrayList<>();
            for (String ln = r.readLine(); ln != null; ln = r.readLine()) {
                list.add(ln);
            }
            return withConfig(list);
        }
    }",maybe_loop_control
ln,"{
        for (String ln : lines) {
            withConfig(ln);
        }
        return this;
    }",iterator
i,"{
        return new RemappingClassAdapter(cv, remapper) {
            Map<MtdInfo, MtdInfo> toCreate = new HashMap<MtdInfo, MtdInfo>();
            String clzName;

            private MtdInfo newMethodA(int opcode, MtdInfo t, MtdInfo mapTo) {
                MtdInfo n = toCreate.get(t);
                if (n != null) {
                    return n;
                }
                n = new MtdInfo();
                n.owner = t.owner;
                n.name = buildMethodAName(t.name);
                boolean hasThis = opcode != INVOKESTATIC;

                if (hasThis) {
                    Type[] args = Type.getArgumentTypes(t.desc);
                    Type ret = Type.getReturnType(t.desc);
                    List<Type> ts = new ArrayList<>(args.length + 1);
                    ts.add(Type.getType(t.owner));
                    ts.addAll(Arrays.asList(args));
                    n.desc = Type.getMethodDescriptor(ret, ts.toArray(new Type[ts.size()]));
                } else {
                    n.desc = t.desc;
                }

                toCreate.put(t, n);
                MethodVisitor mv = cv.visitMethod(ACC_SYNTHETIC | ACC_PRIVATE | ACC_STATIC, n.name, n.desc, null, null);
                mv.visitCode();
                genMethodACode(opcode, t, mapTo, mv, t);

                return n;
            }

            private void genMethodACode(int opcode, MtdInfo t, MtdInfo mapTo, MethodVisitor mv, MtdInfo src) {
                boolean hasThis = opcode != INVOKESTATIC;
                Type[] args = Type.getArgumentTypes(t.desc);
                Type ret = Type.getReturnType(t.desc);


                final int start;
                mv.visitTypeInsn(NEW, getCurrentInvocationName());
                mv.visitInsn(DUP);
                if (hasThis) {
                    mv.visitVarInsn(ALOAD, 0);
                    start = 1;
                } else {
                    mv.visitInsn(ACONST_NULL);
                    start = 0;
                }
                if (args.length == 0) {
                    mv.visitInsn(ACONST_NULL);
                } else {
                    mv.visitLdcInsn(args.length);
                    mv.visitTypeInsn(ANEWARRAY, ""java/lang/Object"");
                    for (int i = 0; i < args.length; i++) {
                        mv.visitInsn(DUP);
                        mv.visitLdcInsn(i);
                        mv.visitVarInsn(args[i].getOpcode(ILOAD), i + start);
                        box(args[i], mv);
                        mv.visitInsn(AASTORE);
                    }
                }
                int nextIdx = callbacks.size();
                mv.visitLdcInsn(nextIdx);
                mv.visitMethodInsn(INVOKESPECIAL, getCurrentInvocationName(), ""<init>"",
                        ""(Ljava/lang/Object;[Ljava/lang/Object;I)V"");

                mv.visitMethodInsn(INVOKESTATIC, toInternal(mapTo.owner), mapTo.name, mapTo.desc);
                unBox(ret, Type.getReturnType(mapTo.desc), mv);
                mv.visitInsn(ret.getOpcode(IRETURN));
                mv.visitMaxs(-1, -1);
                mv.visitEnd();

                Callback cb = new Callback();
                cb.idx = nextIdx;
                cb.callback = newMethodCallback(opcode, t);
                cb.target = src;
                cb.isSpecial = opcode == INVOKESPECIAL;
                cb.isStatic = opcode == INVOKESTATIC;
                callbacks.add(cb);
            }

            private MtdInfo newMethodCallback(int opcode, MtdInfo t) {
                MtdInfo n = new MtdInfo();
                n.owner = ""L"" + className + "";"";
                n.name = buildCallbackMethodName(t.name) ;
                if (opcode == INVOKESPECIAL || opcode == INVOKESTATIC) {
                    n.desc = ""([Ljava/lang/Object;)Ljava/lang/Object;"";
                } else {
                    n.desc = ""(Ljava/lang/Object;[Ljava/lang/Object;)Ljava/lang/Object;"";
                }
                MethodVisitor mv = cv.visitMethod(opcode == INVOKESPECIAL ? ACC_PUBLIC : ACC_PUBLIC
                        | ACC_STATIC, n.name, n.desc, null, null);
                mv.visitCode();
                int start;
                if (opcode != INVOKESTATIC) {
                    mv.visitVarInsn(ALOAD, 0);
                    if (opcode != INVOKESPECIAL) {
                        mv.visitTypeInsn(CHECKCAST, toInternal(t.owner));
                    }
                    start = 1;
                } else {
                    start = 0;
                }
                Type[] args = Type.getArgumentTypes(t.desc);

                for (int i = 0; i < args.length; i++) {
                    mv.visitVarInsn(ALOAD, start);
                    mv.visitLdcInsn(i);
                    mv.visitInsn(AALOAD);
                    unBox(args[i], OBJECT_TYPE, mv);
                }
                mv.visitMethodInsn(opcode, toInternal(t.owner), t.name, t.desc);
                Type ret = Type.getReturnType(t.desc);
                box(ret, mv);
                mv.visitInsn(ARETURN);
                mv.visitMaxs(-1, -1);
                mv.visitEnd();
                return n;
            }

            @Override
            public void visit(int version, int access, String name, String signature, String superName,
                              String[] interfaces) {
                super.visit(version, access, name, signature, superName, interfaces);
                clzName = name;
            }

            public MethodVisitor visitMethod(int access, final String name, String desc, String signature,
                                             String[] exceptions) {

                final MethodVisitor superMv = superMethodVisitor(access, name, desc, signature, exceptions);
                final MtdInfo mapTo = findDefinedTargetMethod(""L"" + clzName + "";"", name, desc);
                if (mapTo != null) {
                    final MtdInfo t1 = new MtdInfo();
                    t1.owner = ""L"" + clzName + "";"";
                    t1.name = buildMethodAName(name) ;
                    t1.desc = desc;
                    final MtdInfo t = t1;
                    final MtdInfo src = new MtdInfo();
                    src.owner = t.owner;
                    src.name = name;
                    src.desc = desc;
                    return new MethodNode(Opcodes.ASM4, access, name, desc, signature, exceptions) {
                        @Override
                        public void visitEnd() {

                            InsnList instructions = this.instructions;
                            List<TryCatchBlockNode> tryCatchBlocks = this.tryCatchBlocks;
                            List<LocalVariableNode> localVariables = this.localVariables;

                            this.instructions = new InsnList();
                            this.tryCatchBlocks = new ArrayList<>();
                            this.localVariables = new ArrayList<>();
                            this.maxLocals = -1;
                            this.maxStack = -1;
                            accept(superMv);
                            int opcode;
                            if (Modifier.isStatic(access)) {
                                opcode = Opcodes.INVOKESTATIC;
                            } else {
                                opcode = Opcodes.INVOKEVIRTUAL;
                            }
                            genMethodACode(opcode, t, mapTo, superMv, src);

                            int newAccess = (access & ~(ACC_PRIVATE | ACC_PROTECTED)) | ACC_PUBLIC; // make sure public
                            MethodVisitor rmv = wrap(superMethodVisitor(newAccess, t.name, desc, null, null));
                            if(rmv!=null) {
                                rmv.visitCode();
                                int n, i;
                                n = tryCatchBlocks == null ? 0 : tryCatchBlocks.size();

                                for (i = 0; i < n; ++i) {
                                    tryCatchBlocks.get(i).accept(rmv);
                                }
                                instructions.accept(rmv);
                                n = localVariables == null ? 0 : localVariables.size();

                                for (i = 0; i < n; ++i) {
                                    localVariables.get(i).accept(rmv);
                                }
                                rmv.visitMaxs(-1, -1);
                                rmv.visitEnd();
                            }
                        }
                    };
                } else {
                    return wrap(superMv);
                }
            }

            private MethodVisitor superMethodVisitor(int access, String name, String desc, String signature, String[] exceptions) {
                return super.visitMethod(access, name, desc, signature, exceptions);
            }

            MethodVisitor wrap(MethodVisitor mv){
                return  mv==null?null: new ReplaceMethodVisitor(mv);
            }
            class ReplaceMethodVisitor extends MethodVisitor {
                public ReplaceMethodVisitor(MethodVisitor mv) {
                    super(Opcodes.ASM4, mv);
                }

                @Override
                public void visitMethodInsn(int opcode, String owner, String name, String desc) {
                    MtdInfo mapTo = findTargetMethod(""L"" + owner + "";"", name, desc);
                    if (mapTo != null) {
                        boolean isStatic = opcode == INVOKESTATIC;
                        Type orgRet = Type.getReturnType(desc);
                        Type orgArgs[] = Type.getArgumentTypes(desc);
                        Type nRet = Type.getReturnType(mapTo.desc);
                        Type nArgs[] = Type.getArgumentTypes(mapTo.desc);
                        if (orgRet.getSort() != Type.VOID && nRet.getSort() == Type.VOID) {
                            throw new RuntimeException(""can't cast "" + nRet + "" to "" + orgRet);
                        }

                        if (nArgs.length == 1 && nArgs[0].getDescriptor().equals(invocationInterfaceDesc)) {
                            MtdInfo t = new MtdInfo();
                            t.owner = ""L"" + owner + "";"";
                            t.name = name;
                            t.desc = desc;
                            MtdInfo n = newMethodA(opcode, t, mapTo);
                            super.visitMethodInsn(INVOKESTATIC, clzName, n.name, n.desc);
                        } else { // simple replace
                            // checking for invalid replace
                            if (isStatic) {
                                if (!Arrays.deepEquals(orgArgs, nArgs)) {
                                    throw new RuntimeException(""arguments not equal: "" + owner + ""."" + name + desc
                                            + "" <> "" + mapTo.owner + ""."" + mapTo.name + mapTo.desc);
                                }
                            } else {
                                if (nArgs.length != orgArgs.length + 1) {
                                    throw new RuntimeException(""arguments not equal: "" + owner + ""."" + name + desc
                                            + "" <> "" + mapTo.owner + ""."" + mapTo.name + mapTo.desc);
                                }
                                if (orgArgs.length > 0) {
                                    for (int i = 0; i < orgArgs.length; i++) {
                                        if (!orgArgs[i].equals(nArgs[i + 1])) {
                                            throw new RuntimeException(""arguments not equal: "" + owner + ""."" + name
                                                    + desc + "" <> "" + mapTo.owner + ""."" + mapTo.name + mapTo.desc);
                                        }
                                    }
                                }
                            }
                            // replace it!
                            super.visitMethodInsn(INVOKESTATIC, toInternal(mapTo.owner), mapTo.name, mapTo.desc);
                            unBox(orgRet, nRet, this.mv);
                        }

                    } else {
                        super.visitMethodInsn(opcode, owner, name, desc);
                    }
                }
            }

        };
    }",loop_control
i,"{
        String typeName = getCurrentInvocationName();
        cw.visit(V1_6, ACC_PUBLIC, typeName, null, ""java/lang/Object"", new String[]{
                toInternal(invocationInterfaceDesc)});
        cw.visitField(ACC_PRIVATE | ACC_FINAL, ""thiz"", ""Ljava/lang/Object;"", null, null).visitEnd();
        cw.visitField(ACC_PRIVATE | ACC_FINAL, ""args"", ""[Ljava/lang/Object;"", null, null).visitEnd();
        cw.visitField(ACC_PRIVATE | ACC_FINAL, ""idx"", ""I"", null, null).visitEnd();
        {
            MethodVisitor mv = cw.visitMethod(ACC_PUBLIC, ""<init>"", ""(Ljava/lang/Object;[Ljava/lang/Object;I)V"", null,
                    null);
            mv.visitCode();
            mv.visitVarInsn(ALOAD, 0);
            mv.visitMethodInsn(INVOKESPECIAL, ""java/lang/Object"", ""<init>"", ""()V"");
            mv.visitVarInsn(ALOAD, 0);
            mv.visitVarInsn(ALOAD, 1);
            mv.visitFieldInsn(PUTFIELD, typeName, ""thiz"", ""Ljava/lang/Object;"");
            mv.visitVarInsn(ALOAD, 0);
            mv.visitVarInsn(ALOAD, 2);
            mv.visitFieldInsn(PUTFIELD, typeName, ""args"", ""[Ljava/lang/Object;"");
            mv.visitVarInsn(ALOAD, 0);
            mv.visitVarInsn(ILOAD, 3);
            mv.visitFieldInsn(PUTFIELD, typeName, ""idx"", ""I"");
            mv.visitInsn(RETURN);
            mv.visitMaxs(-1, -1);
            mv.visitEnd();
        }
        {
            genSwitchMethod(cw, typeName, ""getMethodOwner"", new CB() {
                @Override
                public String getKey(MtdInfo mtd) {
                    return toInternal(mtd.owner);
                }
            });
            genSwitchMethod(cw, typeName, ""getMethodName"", new CB() {
                @Override
                public String getKey(MtdInfo mtd) {
                    return mtd.name;
                }
            });
            genSwitchMethod(cw, typeName, ""getMethodDesc"", new CB() {
                @Override
                public String getKey(MtdInfo mtd) {
                    return mtd.desc;
                }
            });
        }
        {
            MethodVisitor mv = cw.visitMethod(ACC_PUBLIC, ""getArguments"", ""()[Ljava/lang/Object;"", null, null);
            mv.visitCode();
            mv.visitVarInsn(ALOAD, 0);
            mv.visitFieldInsn(GETFIELD, typeName, ""args"", ""[Ljava/lang/Object;"");
            mv.visitInsn(ARETURN);
            mv.visitMaxs(-1, -1);
            mv.visitEnd();
        }

        {
            MethodVisitor mv = cw.visitMethod(ACC_PUBLIC, ""getThis"", ""()Ljava/lang/Object;"", null, null);
            mv.visitCode();
            mv.visitVarInsn(ALOAD, 0);
            mv.visitFieldInsn(GETFIELD, typeName, ""thiz"", ""Ljava/lang/Object;"");
            mv.visitInsn(ARETURN);
            mv.visitMaxs(-1, -1);
            mv.visitEnd();
        }

        {
            MethodVisitor mv = cw.visitMethod(ACC_PUBLIC, ""proceed"", ""()Ljava/lang/Object;"", null,
                    new String[]{""java/lang/Throwable""});
            mv.visitCode();
            mv.visitVarInsn(ALOAD, 0);
            mv.visitFieldInsn(GETFIELD, typeName, ""idx"", ""I"");
            Label def = new Label();
            Label[] labels = new Label[callbacks.size()];
            for (int i = 0; i < labels.length; i++) {
                labels[i] = new Label();
            }
            mv.visitTableSwitchInsn(0, callbacks.size() - 1, def, labels);

            for (int i = 0; i < labels.length; i++) {
                mv.visitLabel(labels[i]);
                Callback cb = callbacks.get(i);
                MtdInfo m = (MtdInfo) cb.callback;
                if (cb.isStatic) {
                    mv.visitVarInsn(ALOAD, 0);
                    mv.visitFieldInsn(GETFIELD, typeName, ""args"", ""[Ljava/lang/Object;"");
                    mv.visitMethodInsn(INVOKESTATIC, toInternal(m.owner), m.name, m.desc);
                } else if (cb.isSpecial) {
                    mv.visitVarInsn(ALOAD, 0);
                    mv.visitFieldInsn(GETFIELD, typeName, ""thiz"", ""Ljava/lang/Object;"");
                    mv.visitTypeInsn(CHECKCAST, toInternal(m.owner));
                    mv.visitVarInsn(ALOAD, 0);
                    mv.visitFieldInsn(GETFIELD, typeName, ""args"", ""[Ljava/lang/Object;"");
                    mv.visitMethodInsn(INVOKEVIRTUAL, toInternal(m.owner), m.name, m.desc);
                } else {
                    mv.visitVarInsn(ALOAD, 0);
                    mv.visitFieldInsn(GETFIELD, typeName, ""thiz"", ""Ljava/lang/Object;"");
                    mv.visitVarInsn(ALOAD, 0);
                    mv.visitFieldInsn(GETFIELD, typeName, ""args"", ""[Ljava/lang/Object;"");
                    mv.visitMethodInsn(INVOKESTATIC, toInternal(m.owner), m.name, m.desc);
                }
                Type ret = Type.getReturnType(m.desc);
                box(ret, mv);
                mv.visitInsn(ret.getOpcode(IRETURN));
            }
            mv.visitLabel(def);
            mv.visitTypeInsn(NEW, ""java/lang/RuntimeException"");
            mv.visitInsn(DUP);
            mv.visitLdcInsn(""invalid idx"");
            mv.visitMethodInsn(INVOKESPECIAL, ""java/lang/RuntimeException"", ""<init>"", ""(Ljava/lang/String;)V"");
            mv.visitInsn(ATHROW);
            mv.visitMaxs(-1, -1);
            mv.visitEnd();
        }
        return typeName;
    }",loop_control
i,"{
        MethodVisitor mv = cw.visitMethod(ACC_PUBLIC, methodName, ""()Ljava/lang/String;"", null, null);
        mv.visitCode();
        mv.visitVarInsn(ALOAD, 0);
        mv.visitFieldInsn(GETFIELD, typeName, ""idx"", ""I"");
        Label def = new Label();
        Label[] labels = new Label[callbacks.size()];

        Map<String, Label> strMap = new TreeMap<>();
        for (int i = 0; i < labels.length; i++) {
            Callback cb = callbacks.get(i);
            String key = callback.getKey((MtdInfo) cb.target);
            Label label = strMap.get(key);
            if (label == null) {
                label = new Label();
                strMap.put(key, label);
            }
            labels[i] = label;
        }

        mv.visitTableSwitchInsn(0, callbacks.size() - 1, def, labels);

        for (Map.Entry<String, Label> e : strMap.entrySet()) {
            mv.visitLabel(e.getValue());
            mv.visitLdcInsn(e.getKey());
            mv.visitInsn(ARETURN);
        }
        mv.visitLabel(def);
        mv.visitTypeInsn(NEW, ""java/lang/RuntimeException"");
        mv.visitInsn(DUP);
        mv.visitLdcInsn(""invalid idx"");
        mv.visitMethodInsn(INVOKESPECIAL, ""java/lang/RuntimeException"", ""<init>"", ""(Ljava/lang/String;)V"");
        mv.visitInsn(ATHROW);
        mv.visitMaxs(-1, -1);
        mv.visitEnd();
    }",loop_control
e,"{
        MethodVisitor mv = cw.visitMethod(ACC_PUBLIC, methodName, ""()Ljava/lang/String;"", null, null);
        mv.visitCode();
        mv.visitVarInsn(ALOAD, 0);
        mv.visitFieldInsn(GETFIELD, typeName, ""idx"", ""I"");
        Label def = new Label();
        Label[] labels = new Label[callbacks.size()];

        Map<String, Label> strMap = new TreeMap<>();
        for (int i = 0; i < labels.length; i++) {
            Callback cb = callbacks.get(i);
            String key = callback.getKey((MtdInfo) cb.target);
            Label label = strMap.get(key);
            if (label == null) {
                label = new Label();
                strMap.put(key, label);
            }
            labels[i] = label;
        }

        mv.visitTableSwitchInsn(0, callbacks.size() - 1, def, labels);

        for (Map.Entry<String, Label> e : strMap.entrySet()) {
            mv.visitLabel(e.getValue());
            mv.visitLdcInsn(e.getKey());
            mv.visitInsn(ARETURN);
        }
        mv.visitLabel(def);
        mv.visitTypeInsn(NEW, ""java/lang/RuntimeException"");
        mv.visitInsn(DUP);
        mv.visitLdcInsn(""invalid idx"");
        mv.visitMethodInsn(INVOKESPECIAL, ""java/lang/RuntimeException"", ""<init>"", ""(Ljava/lang/String;)V"");
        mv.visitInsn(ATHROW);
        mv.visitMaxs(-1, -1);
        mv.visitEnd();
    }",iterator
i,"{
        String typeName = getCurrentInvocationName();
        String typeNameDesc = ""L"" + typeName + "";"";
        DexClassVisitor dcv = dfv.visit(DexConstants.ACC_PUBLIC, typeNameDesc, ""Ljava/lang/Object;"", new String[]{
                invocationInterfaceDesc});

        dcv.visitField(DexConstants.ACC_PRIVATE | DexConstants.ACC_FINAL,
                new Field(typeNameDesc, ""thiz"", ""Ljava/lang/Object;""), null).visitEnd();
        dcv.visitField(DexConstants.ACC_PRIVATE | DexConstants.ACC_FINAL, new Field(typeNameDesc, ""args"", ""[Ljava/lang/Object;""), null)
                .visitEnd();
        dcv.visitField(DexConstants.ACC_PRIVATE | DexConstants.ACC_FINAL, new Field(typeNameDesc, ""idx"", ""I""), null)
                .visitEnd();


        {
            DexMethodVisitor mv = dcv
                    .visitMethod(DexConstants.ACC_PUBLIC | DexConstants.ACC_CONSTRUCTOR, new Method(typeNameDesc, ""<init>"", new String[]{
                            ""Ljava/lang/Object;"", ""[Ljava/lang/Object;"", ""I""}, ""V""));
            DexCodeVisitor codeVisitor = mv.visitCode();
            codeVisitor.visitRegister(4);
            codeVisitor.visitFieldStmt(Op.IPUT_OBJECT, 1, 0, new Field(typeNameDesc, ""thiz"", ""Ljava/lang/Object;""));
            codeVisitor.visitFieldStmt(Op.IPUT_OBJECT, 2, 0, new Field(typeNameDesc, ""args"", ""[Ljava/lang/Object;""));
            codeVisitor.visitFieldStmt(Op.IPUT, 3, 0, new Field(typeNameDesc, ""idx"", ""I""));
            codeVisitor.visitStmt0R(Op.RETURN_VOID);
            codeVisitor.visitEnd();
            mv.visitEnd();
        }
        {
            genSwitchMethod(dcv, typeNameDesc, ""getMethodOwner"", new CB() {
                @Override
                public String getKey(Method mtd) {
                    return toInternal(mtd.getOwner());
                }
            });
            genSwitchMethod(dcv, typeNameDesc, ""getMethodName"", new CB() {
                @Override
                public String getKey(Method mtd) {
                    return mtd.getName();
                }
            });
            genSwitchMethod(dcv, typeNameDesc, ""getMethodDesc"", new CB() {
                @Override
                public String getKey(Method mtd) {
                    return mtd.getDesc();
                }
            });
        }

        {
            DexMethodVisitor mv = dcv
                    .visitMethod(DexConstants.ACC_PUBLIC, new Method(typeNameDesc, ""getArguments"", new String[0], ""[Ljava/lang/Object;""));
            DexCodeVisitor code = mv.visitCode();
            code.visitRegister(2);
            code.visitFieldStmt(Op.IGET, 0, 1, new Field(typeNameDesc, ""args"", ""[Ljava/lang/Object;""));
            code.visitStmt1R(Op.RETURN_OBJECT, 0);

            code.visitEnd();
            mv.visitEnd();
        }

        {
            DexMethodVisitor mv = dcv
                    .visitMethod(DexConstants.ACC_PUBLIC, new Method(typeNameDesc, ""getThis"", new String[0], ""Ljava/lang/Object;""));
            DexCodeVisitor code = mv.visitCode();
            code.visitRegister(2);
            code.visitFieldStmt(Op.IGET, 0, 1, new Field(typeNameDesc, ""thiz"", ""Ljava/lang/Object;""));
            code.visitStmt1R(Op.RETURN_OBJECT, 0);
            code.visitEnd();
            mv.visitEnd();
        }
        {
            DexMethodVisitor mv = dcv
                    .visitMethod(DexConstants.ACC_PUBLIC, new Method(typeNameDesc, ""proceed"", new String[0], ""Ljava/lang/Object;""));
            DexCodeVisitor code = mv.visitCode();
            code.visitRegister(4);


            code.visitFieldStmt(Op.IGET, 0, 3, new Field(typeNameDesc, ""thiz"", ""Ljava/lang/Object;""));
            code.visitFieldStmt(Op.IGET, 1, 3, new Field(typeNameDesc, ""args"", ""[Ljava/lang/Object;""));
            code.visitFieldStmt(Op.IGET, 2, 3, new Field(typeNameDesc, ""idx"", ""I""));

            DexLabel labels[] = new DexLabel[callbacks.size()];
            for (int i = 0; i < labels.length; i++) {
                labels[i] = new DexLabel();
            }
            code.visitPackedSwitchStmt(Op.PACKED_SWITCH, 2, 0, labels);
            code.visitTypeStmt(Op.NEW_INSTANCE, 0, 0, ""Ljava/lang/RuntimeException;"");
            code.visitConstStmt(Op.CONST_STRING, 1, ""invalid idx"");
            code.visitMethodStmt(Op.INVOKE_DIRECT, new int[]{0,
                    1}, new Method(""Ljava/lang/RuntimeException;"", ""<init>"", new String[]{""Ljava/lang/String;""}, ""V""));
            code.visitStmt1R(Op.THROW, 0);

            for (int i = 0; i < labels.length; i++) {
                code.visitLabel(labels[i]);
                Callback callback = callbacks.get(i);
                Method mCallback = (Method) callback.callback;
                if (callback.isStatic) {
                    code.visitMethodStmt(Op.INVOKE_STATIC, new int[]{1}, mCallback);
                } else if (callback.isSpecial) {
                    code.visitTypeStmt(Op.CHECK_CAST, 0, -1, mCallback.getOwner());
                    code.visitMethodStmt(Op.INVOKE_VIRTUAL, new int[]{0, 1}, mCallback);
                } else {
                    code.visitMethodStmt(Op.INVOKE_STATIC, new int[]{0, 1}, mCallback);
                }
                code.visitStmt1R(Op.MOVE_RESULT_OBJECT, 0);
                code.visitStmt1R(Op.RETURN_OBJECT, 0);
            }

            code.visitEnd();
            mv.visitEnd();
        }

        dcv.visitEnd();
        return typeName;
    }",loop_control
i,"{
        DexMethodVisitor dmv = dcv
                .visitMethod(DexConstants.ACC_PUBLIC, new Method(typeNameDesc, methodName, new String[0], ""Ljava/lang/String;""));
        DexCodeVisitor code = dmv.visitCode();
        code.visitRegister(3);
        code.visitFieldStmt(Op.IGET, 0, 2, new Field(typeNameDesc, ""idx"", ""I""));

        DexLabel labels[] = new DexLabel[callbacks.size()];

        Map<String, DexLabel> strMap = new TreeMap<>();
        for (int i = 0; i < labels.length; i++) {
            Callback cb = callbacks.get(i);
            String key = callback.getKey((Method) cb.target);
            DexLabel label = strMap.get(key);
            if (label == null) {
                label = new DexLabel();
                strMap.put(key, label);
            }
            labels[i] = label;
        }
        code.visitPackedSwitchStmt(Op.PACKED_SWITCH, 0, 0, labels);
        code.visitTypeStmt(Op.NEW_INSTANCE, 0, 0, ""Ljava/lang/RuntimeException;"");
        code.visitConstStmt(Op.CONST_STRING, 1, ""invalid idx"");
        code.visitMethodStmt(Op.INVOKE_DIRECT, new int[]{0,
                1}, new Method(""Ljava/lang/RuntimeException;"", ""<init>"", new String[]{""Ljava/lang/String;""}, ""V""));
        code.visitStmt1R(Op.THROW, 0);

        for (Map.Entry<String, DexLabel> e : strMap.entrySet()) {
            code.visitLabel(e.getValue());
            code.visitConstStmt(Op.CONST_STRING, 0, e.getKey());
            code.visitStmt1R(Op.RETURN_OBJECT, 0);
        }
        code.visitEnd();
        dmv.visitEnd();
    }",loop_control
e,"{
        DexMethodVisitor dmv = dcv
                .visitMethod(DexConstants.ACC_PUBLIC, new Method(typeNameDesc, methodName, new String[0], ""Ljava/lang/String;""));
        DexCodeVisitor code = dmv.visitCode();
        code.visitRegister(3);
        code.visitFieldStmt(Op.IGET, 0, 2, new Field(typeNameDesc, ""idx"", ""I""));

        DexLabel labels[] = new DexLabel[callbacks.size()];

        Map<String, DexLabel> strMap = new TreeMap<>();
        for (int i = 0; i < labels.length; i++) {
            Callback cb = callbacks.get(i);
            String key = callback.getKey((Method) cb.target);
            DexLabel label = strMap.get(key);
            if (label == null) {
                label = new DexLabel();
                strMap.put(key, label);
            }
            labels[i] = label;
        }
        code.visitPackedSwitchStmt(Op.PACKED_SWITCH, 0, 0, labels);
        code.visitTypeStmt(Op.NEW_INSTANCE, 0, 0, ""Ljava/lang/RuntimeException;"");
        code.visitConstStmt(Op.CONST_STRING, 1, ""invalid idx"");
        code.visitMethodStmt(Op.INVOKE_DIRECT, new int[]{0,
                1}, new Method(""Ljava/lang/RuntimeException;"", ""<init>"", new String[]{""Ljava/lang/String;""}, ""V""));
        code.visitStmt1R(Op.THROW, 0);

        for (Map.Entry<String, DexLabel> e : strMap.entrySet()) {
            code.visitLabel(e.getValue());
            code.visitConstStmt(Op.CONST_STRING, 0, e.getKey());
            code.visitStmt1R(Op.RETURN_OBJECT, 0);
        }
        code.visitEnd();
        dmv.visitEnd();
    }",iterator
i,"{
        Type[] ts = Type.getArgumentTypes(mapTo.desc);
        String ss[] = new String[ts.length];
        for (int i = 0; i < ss.length; i++) {
            ss[i] = ts[i].getDescriptor();
        }
        return new Method(mapTo.owner, mapTo.name, ss, Type.getReturnType(mapTo.desc).getDescriptor());
    }",loop_control
arg,"{
        int i = 0;
        for (String arg : t.getParameterTypes()) {
            char type = arg.charAt(0);
            if (type == 'J' || type == 'D') {
                i += 2;
            } else {
                i += 1;
            }
        }
        return i;
    }",iterator
i,"{
        if (args.length < 2) {
            System.out.println(""webapp pathToWebApp config [ignoreJarConfig]"");
            return;
        }

        File webApp = new File(args[0]);
        File config = new File(args[1]);
        Path jarIgnore = args.length > 2 ? new File(args[2]).toPath() : null;

        Path clz = new File(webApp, ""WEB-INF/classes"").toPath();
        Path tmpClz = new File(webApp, ""WEB-INF/tmp-classes"").toPath();
        final InvocationWeaver ro = (InvocationWeaver) new InvocationWeaver().withConfig(config.toPath());
        Files.deleteIfExists(tmpClz);
        copyDirectory(clz, tmpClz);

        System.out.println(""InvocationWeaver from ["" + tmpClz + ""] to ["" + clz + ""]"");
        ro.wave(tmpClz, clz);
        Files.deleteIfExists(tmpClz);

        final File lib = new File(webApp, ""WEB-INF/lib"");
        Path tmpLib = new File(webApp, ""WEB-INF/Nlib"").toPath();

        final Set<String> ignores = new HashSet<String>();
        if (jarIgnore != null && Files.exists(jarIgnore)) {
            ignores.addAll(Files.readAllLines(jarIgnore, StandardCharsets.UTF_8));
        } else {
            System.out.println(""ignoreJarConfig ignored"");
        }

        Files.deleteIfExists(tmpLib);
        copyDirectory(lib.toPath(), tmpLib);

        Files.walkFileTree(tmpLib, new SimpleFileVisitor<Path>() {
            @Override
            public FileVisitResult visitFile(Path file, BasicFileAttributes attrs) throws IOException {
                if (file.getFileName().toString().endsWith("".jar"")) {
                    final String s = file.getFileName().toString();
                    boolean ignore = false;
                    for (String i : ignores) {
                        if (s.startsWith(i)) {
                            ignore = true;
                            break;
                        }
                    }
                    if (!ignore) {
                        Path nJar = new File(lib, s).toPath();
                        System.out.println(""InvocationWeaver from ["" + file + ""] to ["" + nJar + ""]"");
                        ro.wave(file, nJar);
                    }
                }
                return super.visitFile(file, attrs);
            }
        });
        Files.deleteIfExists(tmpLib);
    }",iterator
key,"{
        if (args.length < 2) {
            System.err.println(""bin-gen cfg-dir out-dir"");
            return;
        }
        final Path cfg = new File(args[0]).toPath();
        final Path out = new File(args[1]).toPath();
        Properties p = new Properties();
        try (InputStream is = Files.newInputStream(cfg.resolve(""class.cfg""))) {
            p.load(is);
        }

        String bat = new String(Files.readAllBytes(cfg.resolve(""bat_template"")), StandardCharsets.UTF_8);

        String sh = new String(Files.readAllBytes(cfg.resolve(""sh_template"")), StandardCharsets.UTF_8);

        Files.walkFileTree(cfg, new SimpleFileVisitor<Path>() {
            @Override
            public FileVisitResult visitFile(Path file, BasicFileAttributes attrs) throws IOException {
                String fileName = file.getFileName().toString();
                if (fileName.endsWith("".sh"") || fileName.endsWith("".bat"")) {
                    Path f = out.resolve(cfg.relativize(file));
                    BaseCmd.createParentDirectories(f);
                    Files.copy(file, f, StandardCopyOption.REPLACE_EXISTING);
                    if (fileName.endsWith("".sh"")) {
                        setExec(f);
                    }
                }
                return super.visitFile(file, attrs);
            }
        });

        for (Object key : p.keySet()) {
            String name = key.toString();
            Path path = out.resolve(key.toString() + "".sh"");
            BaseCmd.createParentDirectories(path);
            try (BufferedWriter bw = Files.newBufferedWriter(path, StandardCharsets.UTF_8, StandardOpenOption.CREATE,
                    StandardOpenOption.WRITE)) {
                String s = sh.replaceAll(""__@class_name@__"", p.getProperty(name));
                bw.append(s);
            }

            setExec(path);

            path = out.resolve(key.toString() + "".bat"");
            BaseCmd.createParentDirectories(path);
            try (BufferedWriter bw = Files.newBufferedWriter(path, StandardCharsets.UTF_8, StandardOpenOption.CREATE,
                    StandardOpenOption.WRITE)) {
                String s = bat.replaceAll(""__@class_name@__"", p.getProperty(name));
                bw.append(s);
            }
        }
    }",iterator
fileIt,"{
        List<String> f = new ArrayList<>();
        f.addAll(Arrays.asList(remainingArgs));
        if (fileList != null) {
            f.addAll(Files.readAllLines(fileList, StandardCharsets.UTF_8));
        }
        if (f.size() < 1) {
            throw new HelpException();
        }

        final ExecutorService executorService = Executors.newFixedThreadPool(multiThread);

        final Iterator<String> fileIt = f.iterator();
        executorService.submit(new Runnable() {
            @Override
            public void run() {
                if (fileIt.hasNext()) {
                    String fileName = fileIt.next();
                    try {
                        run0(fileName, executorService);
                    } catch (Exception e) {
                        e.printStackTrace();
                    } finally {
                        executorService.submit(this); // run this job again
                    }
                } else {
                    executorService.shutdown();
                }
            }
        });
        executorService.awaitTermination(Integer.MAX_VALUE, TimeUnit.SECONDS);
    }",iterator
result,"{
        // long baseTS = System.currentTimeMillis();
        String baseName = getBaseName(new File(fileName).toPath());
        Path currentDir = new File(""."").toPath();
        Path file = currentDir.resolve(baseName + ""-dex2jar.jar"");
        final Path errorFile = currentDir.resolve(baseName + ""-error.zip"");
        System.err.println(""dex2jar "" + fileName + "" -> "" + file);
        final BaksmaliBaseDexExceptionHandler exceptionHandler = new BaksmaliBaseDexExceptionHandler();
        BaseDexFileReader reader = MultiDexFileReader.open(Files.readAllBytes(new File(fileName).toPath()));
        DexFileNode fileNode = new DexFileNode();
        try {
            reader.accept(fileNode, DexFileReader.SKIP_DEBUG | DexFileReader.IGNORE_READ_EXCEPTION);
        } catch (Exception ex) {
            exceptionHandler.handleFileException(ex);
            throw ex;
        }
        final FileSystem fs = createZip(file);
        final Path dist = fs.getPath(""/"");
        ClassVisitorFactory cvf = new ClassVisitorFactory() {
            @Override
            public ClassVisitor create(final String name) {
                final ClassWriter cw = new ClassWriter(ClassWriter.COMPUTE_MAXS);
                final LambadaNameSafeClassAdapter rca = new LambadaNameSafeClassAdapter(cw);
                return new ClassVisitor(Opcodes.ASM4, rca) {
                    @Override
                    public void visitEnd() {
                        super.visitEnd();
                        String className = rca.getClassName();
                        byte[] data;
                        try {
                            // FIXME handle 'java.lang.RuntimeException: Method code too large!'
                            data = cw.toByteArray();
                        } catch (Exception ex) {
                            System.err.println(String.format(""ASM fail to generate .class file: %s"", className));
                            exceptionHandler.handleFileException(ex);
                            return;
                        }
                        try {
                            Path dist1 = dist.resolve(className + "".class"");
                            BaseCmd.createParentDirectories(dist1);
                            Files.write(dist1, data);
                        } catch (IOException e) {
                            exceptionHandler.handleFileException(e);
                        }
                    }
                };
            }
        };

        new ExDex2Asm(exceptionHandler) {

            @Override
            public void convertDex(final DexFileNode fileNode, final ClassVisitorFactory cvf) {
                if (fileNode.clzs != null) {
                    final Map<String, Clz> classes = collectClzInfo(fileNode);
                    final List<Future<?>> results = new ArrayList<>(fileNode.clzs.size());
                    for (final DexClassNode classNode : fileNode.clzs) {
                        results.add(executorService.submit(new Runnable() {
                            @Override
                            public void run() {
                                convertClass(fileNode, classNode, cvf, classes);
                            }
                        }));
                    }
                    executorService.submit(new Runnable() {
                        @Override
                        public void run() {
                            for (Future<?> result : results) {
                                try {
                                    result.get();
                                } catch (InterruptedException | ExecutionException e) {
                                    e.printStackTrace();
                                }
                            }
                            BaksmaliBaseDexExceptionHandler exceptionHandler1 = (BaksmaliBaseDexExceptionHandler) exceptionHandler;
                            if (exceptionHandler1.hasException()) {
                                exceptionHandler1.dump(errorFile, new String[0]);
                            }
                            try {
                                fs.close();
                            } catch (IOException e) {
                                e.printStackTrace();
                            }
                        }
                    });
                }
            }
        }.convertDex(fileNode, cvf);
    }",iterator
ln,"{
        if (remainingArgs.length == 0) {
            throw new HelpException(""no odex"");
        }

        final Map<String, Method> map = new HashMap<>();
        for (String ln : Files.readAllLines(config, StandardCharsets.UTF_8)) {
            if (ln.startsWith(""#"") || ln.length() == 0) {
                continue;
            }
            String[] x = ln.split(""="");
            map.put(x[0], parseMethod(x[1]));
        }

        DexFileWriter out = new DexFileWriter();
        DexFileVisitor fv = new DexFileVisitor(out) {
            @Override
            public DexClassVisitor visit(int access_flags, String className, String superClass, String[] interfaceNames) {
                DexClassVisitor dcv = super.visit(access_flags, className, superClass, interfaceNames);
                if (dcv != null) {
                    return new DexClassVisitor(dcv) {
                        @Override
                        public DexMethodVisitor visitMethod(int accessFlags, Method method) {
                            DexMethodVisitor dmv = super.visitMethod(accessFlags, method);
                            if (dmv != null) {
                                return new DexMethodVisitor(dmv) {
                                    @Override
                                    public DexCodeVisitor visitCode() {
                                        DexCodeVisitor code = super.visitCode();
                                        if (code != null) {
                                            return new DexCodeVisitor(code) {
                                                @Override
                                                public void visitMethodStmt(Op op, int[] args, Method method) {
                                                    Method replaceTo = map.get(method.toString());
                                                    if (replaceTo != null) {
                                                        switch (op) {
                                                        case INVOKE_DIRECT:
                                                        case INVOKE_INTERFACE:
                                                        case INVOKE_STATIC:
                                                        case INVOKE_SUPER:
                                                        case INVOKE_VIRTUAL:
                                                            super.visitMethodStmt(Op.INVOKE_STATIC, args, replaceTo);
                                                            break;
                                                        case INVOKE_DIRECT_RANGE:
                                                        case INVOKE_INTERFACE_RANGE:
                                                        case INVOKE_STATIC_RANGE:
                                                        case INVOKE_SUPER_RANGE:
                                                        case INVOKE_VIRTUAL_RANGE:
                                                            super.visitMethodStmt(Op.INVOKE_STATIC_RANGE, args, replaceTo);
                                                            break;
                                                        default:
                                                            // impossible here
                                                        }
                                                    } else {
                                                        super.visitMethodStmt(op, args, method);
                                                    }
                                                }
                                            };
                                        }
                                        return code;
                                    }
                                };
                            }
                            return dmv;
                        }
                    };
                }
                return dcv;
            }

            @Override
            public void visitEnd() {

            }
        };
        for (String f : remainingArgs) {
            byte[] data = ZipUtil.readDex(new File(f).toPath());
            DexFileReader r = new DexFileReader(data);
            r.accept(fv);
        }
        if (stub != null) {
            byte[] data = ZipUtil.readDex(stub);
            DexFileReader r = new DexFileReader(data);
            r.accept(new DexFileVisitor(out) {
                @Override
                public void visitEnd() {

                }
            });
        }

        out.visitEnd();

        byte[] data = out.toByteArray();
        Files.write(output, data);

    }",iterator
f,"{
        if (remainingArgs.length == 0) {
            throw new HelpException(""no odex"");
        }

        final Map<String, Method> map = new HashMap<>();
        for (String ln : Files.readAllLines(config, StandardCharsets.UTF_8)) {
            if (ln.startsWith(""#"") || ln.length() == 0) {
                continue;
            }
            String[] x = ln.split(""="");
            map.put(x[0], parseMethod(x[1]));
        }

        DexFileWriter out = new DexFileWriter();
        DexFileVisitor fv = new DexFileVisitor(out) {
            @Override
            public DexClassVisitor visit(int access_flags, String className, String superClass, String[] interfaceNames) {
                DexClassVisitor dcv = super.visit(access_flags, className, superClass, interfaceNames);
                if (dcv != null) {
                    return new DexClassVisitor(dcv) {
                        @Override
                        public DexMethodVisitor visitMethod(int accessFlags, Method method) {
                            DexMethodVisitor dmv = super.visitMethod(accessFlags, method);
                            if (dmv != null) {
                                return new DexMethodVisitor(dmv) {
                                    @Override
                                    public DexCodeVisitor visitCode() {
                                        DexCodeVisitor code = super.visitCode();
                                        if (code != null) {
                                            return new DexCodeVisitor(code) {
                                                @Override
                                                public void visitMethodStmt(Op op, int[] args, Method method) {
                                                    Method replaceTo = map.get(method.toString());
                                                    if (replaceTo != null) {
                                                        switch (op) {
                                                        case INVOKE_DIRECT:
                                                        case INVOKE_INTERFACE:
                                                        case INVOKE_STATIC:
                                                        case INVOKE_SUPER:
                                                        case INVOKE_VIRTUAL:
                                                            super.visitMethodStmt(Op.INVOKE_STATIC, args, replaceTo);
                                                            break;
                                                        case INVOKE_DIRECT_RANGE:
                                                        case INVOKE_INTERFACE_RANGE:
                                                        case INVOKE_STATIC_RANGE:
                                                        case INVOKE_SUPER_RANGE:
                                                        case INVOKE_VIRTUAL_RANGE:
                                                            super.visitMethodStmt(Op.INVOKE_STATIC_RANGE, args, replaceTo);
                                                            break;
                                                        default:
                                                            // impossible here
                                                        }
                                                    } else {
                                                        super.visitMethodStmt(op, args, method);
                                                    }
                                                }
                                            };
                                        }
                                        return code;
                                    }
                                };
                            }
                            return dmv;
                        }
                    };
                }
                return dcv;
            }

            @Override
            public void visitEnd() {

            }
        };
        for (String f : remainingArgs) {
            byte[] data = ZipUtil.readDex(new File(f).toPath());
            DexFileReader r = new DexFileReader(data);
            r.accept(fv);
        }
        if (stub != null) {
            byte[] data = ZipUtil.readDex(stub);
            DexFileReader r = new DexFileReader(data);
            r.accept(new DexFileVisitor(out) {
                @Override
                public void visitEnd() {

                }
            });
        }

        out.visitEnd();

        byte[] data = out.toByteArray();
        Files.write(output, data);

    }",iterator
x,"{
        if (remainingArgs.length == 0) {
            throw new HelpException(""No odex"");
        }
        if (output == null) {
            output = new File(""stub.jar"").toPath();
        }

        try (FileSystem fs = createZip(output)) {
            Path out = fs.getPath(""/"");
            for (String x : remainingArgs) {
                System.err.println(""Processing "" + x + "" ..."");
                ByteBuffer bs = ByteBuffer.wrap(Files.readAllBytes(new File(x).toPath()))
                        .order(ByteOrder.LITTLE_ENDIAN);
                int magic = bs.getInt(0) & 0x00FFFFFF;
                if (magic == MAGIC_ODEX) {
                    int offset = bs.getInt(8);
                    int length = bs.getInt(12);
                    bs.position(offset);
                    ByteBuffer n = (ByteBuffer) bs.slice().limit(length);
                    doDex(n, out);
                } else if (magic == MAGIC_DEX) {
                    doDex(bs, out);
                } else {
                    throw new RuntimeException(""File "" + x + "" is not an dex or odex"");
                }

            }
        }
    }",iterator
j,"{
        Frame[] frames = a.getFrames();
        Textifier t = new Textifier();
        TraceMethodVisitor mv = new TraceMethodVisitor(t);
        String format = ""%05d %-"" + (method.maxStack + method.maxLocals + 6) + ""s|%s"";
        for (int j = 0; j < method.instructions.size(); ++j) {
            method.instructions.get(j).accept(mv);

            StringBuffer s = new StringBuffer();
            Frame f = frames[j];
            if (f == null) {
                s.append('?');
            } else {
                for (int k = 0; k < f.getLocals(); ++k) {
                    s.append(getShortName(f.getLocal(k).toString()));
                }
                s.append("" : "");
                for (int k = 0; k < f.getStackSize(); ++k) {
                    s.append(getShortName(f.getStack(k).toString()));
                }
            }
            try {
                pw.printf(format, j, s, buf.get(t)); // mv.text.get(j));
            } catch (IllegalAccessException e) {
                e.printStackTrace();
            }
        }
        for (TryCatchBlockNode tryCatchBlockNode: method.tryCatchBlocks) {
            tryCatchBlockNode.accept(mv);
            try {
                pw.print("" "" + buf.get(t));
            } catch (IllegalAccessException e) {
                e.printStackTrace();
            }
        }
        pw.println();
        pw.flush();
    }",loop_control
k,"{
        Frame[] frames = a.getFrames();
        Textifier t = new Textifier();
        TraceMethodVisitor mv = new TraceMethodVisitor(t);
        String format = ""%05d %-"" + (method.maxStack + method.maxLocals + 6) + ""s|%s"";
        for (int j = 0; j < method.instructions.size(); ++j) {
            method.instructions.get(j).accept(mv);

            StringBuffer s = new StringBuffer();
            Frame f = frames[j];
            if (f == null) {
                s.append('?');
            } else {
                for (int k = 0; k < f.getLocals(); ++k) {
                    s.append(getShortName(f.getLocal(k).toString()));
                }
                s.append("" : "");
                for (int k = 0; k < f.getStackSize(); ++k) {
                    s.append(getShortName(f.getStack(k).toString()));
                }
            }
            try {
                pw.printf(format, j, s, buf.get(t)); // mv.text.get(j));
            } catch (IllegalAccessException e) {
                e.printStackTrace();
            }
        }
        for (TryCatchBlockNode tryCatchBlockNode: method.tryCatchBlocks) {
            tryCatchBlockNode.accept(mv);
            try {
                pw.print("" "" + buf.get(t));
            } catch (IllegalAccessException e) {
                e.printStackTrace();
            }
        }
        pw.println();
        pw.flush();
    }",loop_control
fn,"{
        if (remainingArgs.length < 1) {
            usage();
            return;
        }

        List<Path> files = new ArrayList<>();
        for (String fn : remainingArgs) {
            Path file = new File(fn).toPath();
            if (!Files.exists(file)) {
                System.err.println(fn + "" doesn't exist"");
                usage();
                return;
            }
            files.add(file);
        }

        for (Path file : files) {
            System.out.println(""verify "" + file);
            walkJarOrDir(file, new FileVisitorX() {
                @Override
                public void visitFile(Path file, String relative) throws IOException {
                    if (file.getFileName().toString().endsWith("".class"")) {
                        ClassReader cr = new ClassReader(Files.readAllBytes(file));
                        ClassNode cn = new ClassNode();
                        cr.accept(new CheckClassAdapter(cn, false),
                                ClassReader.SKIP_DEBUG | ClassReader.EXPAND_FRAMES | ClassReader.SKIP_FRAMES);
                        for (MethodNode method : cn.methods) {
                            BasicVerifier verifier = new BasicVerifier();
                            Analyzer<BasicValue> a = new Analyzer<>(verifier);
                            try {
                                a.analyze(cn.name, method);
                            } catch (Exception ex) {
                                System.err.println(""Error verify method "" + cr.getClassName() + ""."" + method.name + "" ""
                                        + method.desc);
                                if (detail) {
                                    ex.printStackTrace(System.err);
                                    printAnalyzerResult(method, a, new PrintWriter(new OutputStreamWriter(System.err, StandardCharsets.UTF_8)));
                                }
                            }
                        }
                    }
                }
            });
        }
    }",iterator
file,"{
        if (remainingArgs.length < 1) {
            usage();
            return;
        }

        List<Path> files = new ArrayList<>();
        for (String fn : remainingArgs) {
            Path file = new File(fn).toPath();
            if (!Files.exists(file)) {
                System.err.println(fn + "" doesn't exist"");
                usage();
                return;
            }
            files.add(file);
        }

        for (Path file : files) {
            System.out.println(""verify "" + file);
            walkJarOrDir(file, new FileVisitorX() {
                @Override
                public void visitFile(Path file, String relative) throws IOException {
                    if (file.getFileName().toString().endsWith("".class"")) {
                        ClassReader cr = new ClassReader(Files.readAllBytes(file));
                        ClassNode cn = new ClassNode();
                        cr.accept(new CheckClassAdapter(cn, false),
                                ClassReader.SKIP_DEBUG | ClassReader.EXPAND_FRAMES | ClassReader.SKIP_FRAMES);
                        for (MethodNode method : cn.methods) {
                            BasicVerifier verifier = new BasicVerifier();
                            Analyzer<BasicValue> a = new Analyzer<>(verifier);
                            try {
                                a.analyze(cn.name, method);
                            } catch (Exception ex) {
                                System.err.println(""Error verify method "" + cr.getClassName() + ""."" + method.name + "" ""
                                        + method.desc);
                                if (detail) {
                                    ex.printStackTrace(System.err);
                                    printAnalyzerResult(method, a, new PrintWriter(new OutputStreamWriter(System.err, StandardCharsets.UTF_8)));
                                }
                            }
                        }
                    }
                }
            });
        }
    }",break_loop_control
method,"{
        if (remainingArgs.length < 1) {
            usage();
            return;
        }

        List<Path> files = new ArrayList<>();
        for (String fn : remainingArgs) {
            Path file = new File(fn).toPath();
            if (!Files.exists(file)) {
                System.err.println(fn + "" doesn't exist"");
                usage();
                return;
            }
            files.add(file);
        }

        for (Path file : files) {
            System.out.println(""verify "" + file);
            walkJarOrDir(file, new FileVisitorX() {
                @Override
                public void visitFile(Path file, String relative) throws IOException {
                    if (file.getFileName().toString().endsWith("".class"")) {
                        ClassReader cr = new ClassReader(Files.readAllBytes(file));
                        ClassNode cn = new ClassNode();
                        cr.accept(new CheckClassAdapter(cn, false),
                                ClassReader.SKIP_DEBUG | ClassReader.EXPAND_FRAMES | ClassReader.SKIP_FRAMES);
                        for (MethodNode method : cn.methods) {
                            BasicVerifier verifier = new BasicVerifier();
                            Analyzer<BasicValue> a = new Analyzer<>(verifier);
                            try {
                                a.analyze(cn.name, method);
                            } catch (Exception ex) {
                                System.err.println(""Error verify method "" + cr.getClassName() + ""."" + method.name + "" ""
                                        + method.desc);
                                if (detail) {
                                    ex.printStackTrace(System.err);
                                    printAnalyzerResult(method, a, new PrintWriter(new OutputStreamWriter(System.err, StandardCharsets.UTF_8)));
                                }
                            }
                        }
                    }
                }
            });
        }
    }",iterator
pos,"{
        int dexIndex = 0;
        ByteBuffer odexHead = ByteBuffer.allocate(0x28).order(ByteOrder.LITTLE_ENDIAN);
        ByteBuffer copyBuff = ByteBuffer.allocate(512 * 1024).order(ByteOrder.LITTLE_ENDIAN);
        final int buffSize = 0x28 + 0x70;
        ByteBuffer head = ByteBuffer.allocate(buffSize).order(ByteOrder.LITTLE_ENDIAN); // odex+dex head
        for (long pos : possibleOdexs) {
            System.err.println(String.format("">> Check for %08x"", pos));
            channel.position(pos);
            head.position(0);
            int c = channel.read(head);
            head.position(0);
            if (c == buffSize) {
                int version = head.getInt(4);
                if (version == 0x00363330 || version == 0x00353330) { // odexVersion
                    int dexOffset = head.getInt(8);
                    int dexLength = head.getInt(12);
                    int depsOffset = head.getInt(16);
                    int depsLength = head.getInt(20);
                    int optOffset = head.getInt(24);
                    int optLength = head.getInt(28);
                    int flags = head.getInt(32);
                    int checksum = head.getInt(36);
                    if (dexOffset != 0x28) {
                        System.err.println(String.format("">>> dex offset is not 0x28""));
                    } else {
                        int dexMagic = head.getInt(dexOffset + 0);
                        int dexVersion = head.getInt(dexOffset + 4);
                        if (dexMagic != 0x0a786564 || !(dexVersion == 0x00363330 || dexVersion == 0x00353330)) {
                            System.err.println(String.format("">>> dex magic is not dex.036 or dex.035: 0x%08x 0x%08x"", dexMagic, dexVersion));
                        } else {
                            int fileSize = head.getInt(dexOffset + 32);
                            if (fileSize != dexLength) {
                                System.err.println(String.format("">>> dex file size is same with dexLength in odex %d vs %d"", fileSize, dexLength));
                            } else {
                                int endian = head.getInt(dexOffset + 40);
                                if (endian != 0x12345678) {
                                    System.err.println(String.format("">>> dex endian is not 0x12345678""));
                                } else {
                                    // find new dex
                                    Path nFile = new File(String.format(""%s-%02d.odex"", namePrefix, dexIndex++)).toPath();
                                    System.out.println(String.format("">>>> extract 0x%08x to %s"", pos, nFile));
                                    try (SeekableByteChannel channel2 = Files.newByteChannel(nFile, StandardOpenOption.CREATE, StandardOpenOption.WRITE);) {

                                        odexHead.rewind();
                                        odexHead.putInt(0x0a796564);// dey
                                        odexHead.putInt(0x00363330);// 036
                                        odexHead.putInt(0x28);
                                        odexHead.putInt(fileSize);
                                        int nDepsOffset = 0x28 + fileSize;
                                        int nDepsPadding = 0;
                                        if (nDepsOffset % 8 != 0) {
                                            nDepsPadding = 8 - (nDepsOffset % 8);
                                            nDepsOffset += nDepsPadding;
                                        }
                                        odexHead.putInt(nDepsOffset);
                                        odexHead.putInt(depsLength);
                                        int nOptOffset = nDepsOffset + depsLength;
                                        int nOptPadding = 0;
                                        if (nOptOffset % 8 != 0) {
                                            nOptPadding = 8 - (nOptOffset % 8);
                                            nOptOffset += nOptPadding;
                                        }
                                        odexHead.putInt(nOptOffset);
                                        odexHead.putInt(optLength);
                                        odexHead.putInt(flags);
                                        odexHead.putInt(checksum);
                                        odexHead.position(0);
                                        channel2.write(odexHead);

                                        // copy dex
                                        channel.position(pos + dexOffset);
                                        copy(channel, channel2, copyBuff, fileSize);

                                        if (nDepsPadding != 0) {
                                            channel2.write(ByteBuffer.allocate(nDepsPadding));
                                        }
                                        // copy deps
                                        channel.position(pos + depsOffset);
                                        copy(channel, channel2, copyBuff, depsLength);

                                        if (nOptPadding != 0) {
                                            channel2.write(ByteBuffer.allocate(nOptPadding));
                                        }
                                        // copy opts
                                        channel.position(pos + optOffset);
                                        copy(channel, channel2, copyBuff, optLength);
                                    }
                                }
                            }
                        }
                    }

                }
            }
        }
    }",iterator
remain,"{
        int remain = fileSize;

        while (remain > 0) {
            copyBuff.rewind();
            copyBuff.limit(Math.min(remain, copyBuff.capacity()));
            int read = channel.read(copyBuff);
            copyBuff.position(0);
            channel2.write(copyBuff);
            remain -= read;
        }

    }",loop_control
count,"{
        ByteBuffer buffer = ByteBuffer.allocate(1024 * 512).order(ByteOrder.LITTLE_ENDIAN);
        IntBuffer intBuffer = buffer.asIntBuffer();
        List<Long> possibleOdexs = new ArrayList<>();
        while (true) {
            long position = channel.position();
            //System.out.printf(""load @%x\n"", position);
            int count = channel.read(buffer);
            if (count <= 0) {
                break;
            }
            int s = count / 4;
            for (int i = 0; i < s; i++) {
                int u4 = intBuffer.get(i);
                if (u4 == 0x0a796564) {// dey
                    if (i + 1 < s) {
                        int v4 = intBuffer.get(i + 1);
                        if (v4 == 0x00363330 || v4 == 0x00353330) {
                            possibleOdexs.add(position + 4 * i);
                            System.err.println(String.format(""> Possible %08x | %08x %08x"", position + i * 4, u4, v4));
                        }
                    } else {
                        possibleOdexs.add(position + 4 * i);
                        System.err.println(String.format(""> Possible %08x | %08x"", position + i * 4, u4));
                    }
                }
            }
            buffer.position(0);
            intBuffer.position(0);
        }
        return possibleOdexs;
    }",break_loop_control
i,"{
        ByteBuffer buffer = ByteBuffer.allocate(1024 * 512).order(ByteOrder.LITTLE_ENDIAN);
        IntBuffer intBuffer = buffer.asIntBuffer();
        List<Long> possibleOdexs = new ArrayList<>();
        while (true) {
            long position = channel.position();
            //System.out.printf(""load @%x\n"", position);
            int count = channel.read(buffer);
            if (count <= 0) {
                break;
            }
            int s = count / 4;
            for (int i = 0; i < s; i++) {
                int u4 = intBuffer.get(i);
                if (u4 == 0x0a796564) {// dey
                    if (i + 1 < s) {
                        int v4 = intBuffer.get(i + 1);
                        if (v4 == 0x00363330 || v4 == 0x00353330) {
                            possibleOdexs.add(position + 4 * i);
                            System.err.println(String.format(""> Possible %08x | %08x %08x"", position + i * 4, u4, v4));
                        }
                    } else {
                        possibleOdexs.add(position + 4 * i);
                        System.err.println(String.format(""> Possible %08x | %08x"", position + i * 4, u4));
                    }
                }
            }
            buffer.position(0);
            intBuffer.position(0);
        }
        return possibleOdexs;
    }",loop_control
e,"{
        if (args.length < 3) {
            System.out.println(""Usage: clz-version-switch version old.jar new.jar"");
            System.exit(1);
        }
        int version = Integer.parseInt(args[0]);
        if (version < 1 || version > 9) {
            throw new RuntimeException(""version not support yet!"");
        }
        File old = new File(args[1]);
        File n = new File(args[2]);
        byte[] buff = new byte[1024 * 50];
        final int jVersion = jVersions[version];
        try (ZipFile zip = new ZipFile(old); ZipOutputStream zos = new ZipOutputStream(new FileOutputStream(n));) {

            for (Enumeration<? extends ZipEntry> e = zip.entries(); e.hasMoreElements(); ) {
                ZipEntry zipEntry = e.nextElement();
                zos.putNextEntry(new ZipEntry(zipEntry.getName()));
                if (!zipEntry.isDirectory()) {
                    try (InputStream is = zip.getInputStream(zipEntry)) {
                        if (zipEntry.getName().endsWith("".class"")) {
                            ClassReader cr = new ClassReader(is);
                            ClassWriter cw = new ClassWriter(0);
                            ClassVisitor cv = new ClassVisitor(Opcodes.ASM4, cw) {
                                @Override
                                public void visit(int version, int access, String name, String signature, String superName, String[] interfaces) {
                                    super.visit(jVersion, access, name, signature, superName, interfaces);
                                }
                            };
                            cr.accept(cv, ClassReader.EXPAND_FRAMES|ClassReader.SKIP_FRAMES);
                            zos.write(cw.toByteArray());
                        } else {
                            for (int c = is.read(buff); c > 0; c = is.read(buff)) {
                                zos.write(buff, 0, c);
                            }
                        }
                    }

                }
                zos.closeEntry();
            }
        }
    }",iterator
c,"{
        if (args.length < 3) {
            System.out.println(""Usage: clz-version-switch version old.jar new.jar"");
            System.exit(1);
        }
        int version = Integer.parseInt(args[0]);
        if (version < 1 || version > 9) {
            throw new RuntimeException(""version not support yet!"");
        }
        File old = new File(args[1]);
        File n = new File(args[2]);
        byte[] buff = new byte[1024 * 50];
        final int jVersion = jVersions[version];
        try (ZipFile zip = new ZipFile(old); ZipOutputStream zos = new ZipOutputStream(new FileOutputStream(n));) {

            for (Enumeration<? extends ZipEntry> e = zip.entries(); e.hasMoreElements(); ) {
                ZipEntry zipEntry = e.nextElement();
                zos.putNextEntry(new ZipEntry(zipEntry.getName()));
                if (!zipEntry.isDirectory()) {
                    try (InputStream is = zip.getInputStream(zipEntry)) {
                        if (zipEntry.getName().endsWith("".class"")) {
                            ClassReader cr = new ClassReader(is);
                            ClassWriter cw = new ClassWriter(0);
                            ClassVisitor cv = new ClassVisitor(Opcodes.ASM4, cw) {
                                @Override
                                public void visit(int version, int access, String name, String signature, String superName, String[] interfaces) {
                                    super.visit(jVersion, access, name, signature, superName, interfaces);
                                }
                            };
                            cr.accept(cv, ClassReader.EXPAND_FRAMES|ClassReader.SKIP_FRAMES);
                            zos.write(cw.toByteArray());
                        } else {
                            for (int c = is.read(buff); c > 0; c = is.read(buff)) {
                                zos.write(buff, 0, c);
                            }
                        }
                    }

                }
                zos.closeEntry();
            }
        }
    }",maybe_loop_control
e,"{
        dumpSummary(originalArgs, writer);
        int i = 0;
        for (Map.Entry<DexMethodNode, Exception> e : exceptionMap.entrySet()) {
            DexMethodNode dexMethodNode = e.getKey();
            Exception ex = e.getValue();
            writer.newLine();
            writer.write(""================= "" + i++ + "" ==================="");
            writer.newLine();
            dumpMethod(writer, dexMethodNode, ex);
        }
    }",iterator
key,"{
        writer.write(""#This file is generated by dex2jar"");
        writer.newLine();
        writer.write(REPORT_MESSAGE);
        writer.newLine();
        writer.newLine();
        if (fileExceptions.size() > 0) {
            writer.append(String.format(""There are %d fails."", fileExceptions.size()));
            writer.newLine();
        }
        if (exceptionMap.size() > 0) {
            writer.append(String.format(""There are %d methods fail to translate."", exceptionMap.size()));
            writer.newLine();
        }
        SimpleDateFormat sdf = new SimpleDateFormat(""yyyy-MM-dd HH:mm:ss z"");
        sdf.setTimeZone(TimeZone.getTimeZone(""UTC""));
        writer.append(sdf.format(new Date()));
        writer.newLine();
        writer.append(""version: "");
        writer.append(getVersionString());
        writer.newLine();
        writer.append(""cmdline: "");
        writer.append(Arrays.asList(originalArgs).toString());
        writer.newLine();

        writer.append(""env:"");
        writer.newLine();
        Properties properties = System.getProperties();
        for (String key : properties.stringPropertyNames()) {
            if (key.startsWith(""java."") && !key.toLowerCase().contains(""pass"")) {
                writer.append(key).append("": "").append(properties.getProperty(key));
                writer.newLine();
            }
        }
        PrintWriter p = new PrintWriter(writer, true);
        for (Exception ex : fileExceptions) {
            ex.printStackTrace(p);
        }
        writer.flush();
    }",iterator
ex,"{
        writer.write(""#This file is generated by dex2jar"");
        writer.newLine();
        writer.write(REPORT_MESSAGE);
        writer.newLine();
        writer.newLine();
        if (fileExceptions.size() > 0) {
            writer.append(String.format(""There are %d fails."", fileExceptions.size()));
            writer.newLine();
        }
        if (exceptionMap.size() > 0) {
            writer.append(String.format(""There are %d methods fail to translate."", exceptionMap.size()));
            writer.newLine();
        }
        SimpleDateFormat sdf = new SimpleDateFormat(""yyyy-MM-dd HH:mm:ss z"");
        sdf.setTimeZone(TimeZone.getTimeZone(""UTC""));
        writer.append(sdf.format(new Date()));
        writer.newLine();
        writer.append(""version: "");
        writer.append(getVersionString());
        writer.newLine();
        writer.append(""cmdline: "");
        writer.append(Arrays.asList(originalArgs).toString());
        writer.newLine();

        writer.append(""env:"");
        writer.newLine();
        Properties properties = System.getProperties();
        for (String key : properties.stringPropertyNames()) {
            if (key.startsWith(""java."") && !key.toLowerCase().contains(""pass"")) {
                writer.append(key).append("": "").append(properties.getProperty(key));
                writer.newLine();
            }
        }
        PrintWriter p = new PrintWriter(writer, true);
        for (Exception ex : fileExceptions) {
            ex.printStackTrace(p);
        }
        writer.flush();
    }",iterator
e,"{
        if (remainingArgs.length < 1) {
            System.err.println(""ERROR: no file to process"");
            return;
        }

        System.err.printf(""fix %s -> %s\n"", remainingArgs[0], output);

        byte[] buffer = new byte[1000];
        try (ZipOutputStream zos = new AutoSTOREDZipOutputStream(Files.newOutputStream(output))) {
            byte[] data = Files.readAllBytes(new File(remainingArgs[0]).toPath());
            try(com.googlecode.d2j.util.zip.ZipFile zipFile = new com.googlecode.d2j.util.zip.ZipFile(data)) {
                for (com.googlecode.d2j.util.zip.ZipEntry e : zipFile.entries()) {
                    ZipEntry nEntry = new ZipEntry(e.getName());

                    nEntry.setMethod(e.getMethod() == com.googlecode.d2j.util.zip.ZipEntry.STORED ? ZipEntry.STORED
                            : ZipEntry.DEFLATED);
                    zos.putNextEntry(nEntry);

                    if (!nEntry.isDirectory()) {
                        try (InputStream is = zipFile.getInputStream(e)) {
                            while (true) {
                                int c = is.read(buffer);
                                if (c < 0) {
                                    break;
                                }
                                zos.write(buffer, 0, c);
                            }
                        }
                    }
                    zos.closeEntry();
                }
            }
            zos.finish();
        }
    }",iterator
c,"{
        if (remainingArgs.length < 1) {
            System.err.println(""ERROR: no file to process"");
            return;
        }

        System.err.printf(""fix %s -> %s\n"", remainingArgs[0], output);

        byte[] buffer = new byte[1000];
        try (ZipOutputStream zos = new AutoSTOREDZipOutputStream(Files.newOutputStream(output))) {
            byte[] data = Files.readAllBytes(new File(remainingArgs[0]).toPath());
            try(com.googlecode.d2j.util.zip.ZipFile zipFile = new com.googlecode.d2j.util.zip.ZipFile(data)) {
                for (com.googlecode.d2j.util.zip.ZipEntry e : zipFile.entries()) {
                    ZipEntry nEntry = new ZipEntry(e.getName());

                    nEntry.setMethod(e.getMethod() == com.googlecode.d2j.util.zip.ZipEntry.STORED ? ZipEntry.STORED
                            : ZipEntry.DEFLATED);
                    zos.putNextEntry(nEntry);

                    if (!nEntry.isDirectory()) {
                        try (InputStream is = zipFile.getInputStream(e)) {
                            while (true) {
                                int c = is.read(buffer);
                                if (c < 0) {
                                    break;
                                }
                                zos.write(buffer, 0, c);
                            }
                        }
                    }
                    zos.closeEntry();
                }
            }
            zos.finish();
        }
    }",break_loop_control
fileName,"{
        if (remainingArgs.length == 0) {
            usage();
            return;
        }

        if ((exceptionFile != null || output != null) && remainingArgs.length != 1) {
            System.err.println(""-e/-o can only used with one file"");
            return;
        }
        if (debugInfo && reuseReg) {
            System.err.println(""-d/-r can not use together"");
            return;
        }

        Path currentDir = new File(""."").toPath();

        if (output != null) {
            if (Files.exists(output) && !forceOverwrite) {
                System.err.println(output + "" exists, use --force to overwrite"");
                return;
            }
        } else {
            for (String fileName : remainingArgs) {
                Path file = currentDir.resolve(getBaseName(new File(fileName).toPath()) + ""-dex2jar.jar"");
                if (Files.exists(file) && !forceOverwrite) {
                    System.err.println(file + "" exists, use --force to overwrite"");
                    return;
                }
            }
        }

        for (String fileName : remainingArgs) {
            // long baseTS = System.currentTimeMillis();
            String baseName = getBaseName(new File(fileName).toPath());
            Path file = output == null ? currentDir.resolve(baseName + ""-dex2jar.jar"") : output;
            System.err.println(""dex2jar "" + fileName + "" -> "" + file);

            BaseDexFileReader reader = MultiDexFileReader.open(Files.readAllBytes(new File(fileName).toPath()));
            BaksmaliBaseDexExceptionHandler handler = notHandleException ? null : new BaksmaliBaseDexExceptionHandler();
            Dex2jar.from(reader).withExceptionHandler(handler).reUseReg(reuseReg).topoLogicalSort()
                    .skipDebug(!debugInfo).optimizeSynchronized(this.optmizeSynchronized).printIR(printIR)
                    .noCode(noCode).skipExceptions(skipExceptions).to(file);

            if (!notHandleException) {
                if (handler.hasException()) {
                    Path errorFile = exceptionFile == null ? currentDir.resolve(baseName + ""-error.zip"")
                            : exceptionFile;
                    System.err.println(""Detail Error Information in File "" + errorFile);
                    System.err.println(BaksmaliBaseDexExceptionHandler.REPORT_MESSAGE);
                    handler.dump(errorFile, orginalArgs);
                }
            }
            // long endTS = System.currentTimeMillis();
            // System.err.println(String.format(""%.2f"", (float) (endTS - baseTS) / 1000));
        }
    }",iterator
file,"{
        if (remainingArgs.length == 0) {
            usage();
            return;
        }

        if ((exceptionFile != null || output != null) && remainingArgs.length != 1) {
            System.err.println(""-e/-o can only used with one file"");
            return;
        }
        if (debugInfo && reuseReg) {
            System.err.println(""-d/-r can not use together"");
            return;
        }

        Path currentDir = new File(""."").toPath();

        if (output != null) {
            if (Files.exists(output) && !forceOverwrite) {
                System.err.println(output + "" exists, use --force to overwrite"");
                return;
            }
        } else {
            for (String fileName : remainingArgs) {
                Path file = currentDir.resolve(getBaseName(new File(fileName).toPath()) + ""-dex2jar.jar"");
                if (Files.exists(file) && !forceOverwrite) {
                    System.err.println(file + "" exists, use --force to overwrite"");
                    return;
                }
            }
        }

        for (String fileName : remainingArgs) {
            // long baseTS = System.currentTimeMillis();
            String baseName = getBaseName(new File(fileName).toPath());
            Path file = output == null ? currentDir.resolve(baseName + ""-dex2jar.jar"") : output;
            System.err.println(""dex2jar "" + fileName + "" -> "" + file);

            BaseDexFileReader reader = MultiDexFileReader.open(Files.readAllBytes(new File(fileName).toPath()));
            BaksmaliBaseDexExceptionHandler handler = notHandleException ? null : new BaksmaliBaseDexExceptionHandler();
            Dex2jar.from(reader).withExceptionHandler(handler).reUseReg(reuseReg).topoLogicalSort()
                    .skipDebug(!debugInfo).optimizeSynchronized(this.optmizeSynchronized).printIR(printIR)
                    .noCode(noCode).skipExceptions(skipExceptions).to(file);

            if (!notHandleException) {
                if (handler.hasException()) {
                    Path errorFile = exceptionFile == null ? currentDir.resolve(baseName + ""-error.zip"")
                            : exceptionFile;
                    System.err.println(""Detail Error Information in File "" + errorFile);
                    System.err.println(BaksmaliBaseDexExceptionHandler.REPORT_MESSAGE);
                    handler.dump(errorFile, orginalArgs);
                }
            }
            // long endTS = System.currentTimeMillis();
            // System.err.println(String.format(""%.2f"", (float) (endTS - baseTS) / 1000));
        }
    }",break_loop_control
forceOverwrite,"{
        if (remainingArgs.length == 0) {
            usage();
            return;
        }

        if ((exceptionFile != null || output != null) && remainingArgs.length != 1) {
            System.err.println(""-e/-o can only used with one file"");
            return;
        }
        if (debugInfo && reuseReg) {
            System.err.println(""-d/-r can not use together"");
            return;
        }

        Path currentDir = new File(""."").toPath();

        if (output != null) {
            if (Files.exists(output) && !forceOverwrite) {
                System.err.println(output + "" exists, use --force to overwrite"");
                return;
            }
        } else {
            for (String fileName : remainingArgs) {
                Path file = currentDir.resolve(getBaseName(new File(fileName).toPath()) + ""-dex2jar.jar"");
                if (Files.exists(file) && !forceOverwrite) {
                    System.err.println(file + "" exists, use --force to overwrite"");
                    return;
                }
            }
        }

        for (String fileName : remainingArgs) {
            // long baseTS = System.currentTimeMillis();
            String baseName = getBaseName(new File(fileName).toPath());
            Path file = output == null ? currentDir.resolve(baseName + ""-dex2jar.jar"") : output;
            System.err.println(""dex2jar "" + fileName + "" -> "" + file);

            BaseDexFileReader reader = MultiDexFileReader.open(Files.readAllBytes(new File(fileName).toPath()));
            BaksmaliBaseDexExceptionHandler handler = notHandleException ? null : new BaksmaliBaseDexExceptionHandler();
            Dex2jar.from(reader).withExceptionHandler(handler).reUseReg(reuseReg).topoLogicalSort()
                    .skipDebug(!debugInfo).optimizeSynchronized(this.optmizeSynchronized).printIR(printIR)
                    .noCode(noCode).skipExceptions(skipExceptions).to(file);

            if (!notHandleException) {
                if (handler.hasException()) {
                    Path errorFile = exceptionFile == null ? currentDir.resolve(baseName + ""-error.zip"")
                            : exceptionFile;
                    System.err.println(""Detail Error Information in File "" + errorFile);
                    System.err.println(BaksmaliBaseDexExceptionHandler.REPORT_MESSAGE);
                    handler.dump(errorFile, orginalArgs);
                }
            }
            // long endTS = System.currentTimeMillis();
            // System.err.println(String.format(""%.2f"", (float) (endTS - baseTS) / 1000));
        }
    }",break_loop_control
str,"{
        if (remainingArgs.length == 0) {
            throw new HelpException(""no jar"");
        }

        InvocationWeaver invocationWeaver = (InvocationWeaver) new InvocationWeaver().withConfig(config);

        try (FileSystem fs = createZip(output)) {
            final Path outRoot = fs.getPath(""/"");
            for (String str : remainingArgs) {
                Path p = new File(str).toPath();
                System.err.println(p + "" -> "" + output);
                if (Files.isDirectory(p)) {
                    invocationWeaver.wave(p, outRoot);
                } else {
                    try (FileSystem fs2 = openZip(p)) {
                        invocationWeaver.wave(fs2.getPath(""/""), outRoot);
                    }
                }
            }
            if (stub != null) {
                System.err.println(stub + "" -> "" + output);
                walkJarOrDir(stub, new FileVisitorX() {
                    @Override
                    public void visitFile(Path file, String relative) throws IOException {
                        Path out = outRoot.resolve(relative);
                        if (Files.exists(out)) {
                            System.err.println(""skip "" + relative + "" in "" + stub);
                        } else {
                            createParentDirectories(out);
                            Files.copy(file, out);
                        }
                    }
                });
            }
        }
    }",iterator
it,"{
        MethodConfig key = this.key;
        boolean changed = false;
        for (Iterator<MethodNode> it = cn.methods.iterator(); it.hasNext(); ) {
            MethodNode m = it.next();
            if (m.instructions == null) {
                continue;
            }
            key.owner = cn.name;
            key.name = m.name;
            key.desc = m.desc;
            if (map.containsKey(key)) {
                if (deleteMethod) {
                    it.remove();
                }
                continue;
            }


            if (false && verbose) {
                System.out.println();
                System.out.println(""==============="");
                System.out.println(""on method "" + cn.name + "";->"" + m.name + m.desc);
            }

            boolean find = false;
            // search for the decrypt method
            for (AbstractInsnNode p = m.instructions.getFirst(); p != null; p = p.getNext()) {
                if (p.getOpcode() == Opcodes.INVOKESTATIC) {
                    MethodInsnNode mn = (MethodInsnNode) p;
                    key.owner = mn.owner;
                    key.name = mn.name;
                    key.desc = mn.desc;
                    MethodConfig config = map.get(key);
                    if (config != null) {
                        find = true;
                    }
                }
            }
            if (find) {
                try {
                    // copy m to m2 for cleanup debug info
                    MethodNode m2 = new MethodNode();
                    m2.tryCatchBlocks = new ArrayList<>();
                    m2.name = m.name;
                    m2.access = m.access;
                    m2.desc = m.desc;
                    m.accept(m2);
                    cleanDebug(m2);
                    // convert m2 to ir
                    IrMethod irMethod = J2IRConverter.convert(cn.name, m2);
                    // opt and decrypt
                    optAndDecrypt(irMethod, map);

                    // convert ir to m3
                    MethodNode m3 = new MethodNode();
                    m3.tryCatchBlocks = new ArrayList<>();
                    new IR2JConverter()
                            .ir(irMethod)
                            .asm(m3)
                            .convert();

                    // copy back m3 to m
                    m.maxLocals = -1;
                    m.maxLocals = -1;
                    m.instructions = m3.instructions;
                    m.tryCatchBlocks = m3.tryCatchBlocks;
                    m.localVariables = null;
                    changed = true;
                } catch (Exception ex) {
                    if(verbose) {
                        ex.printStackTrace();
                    }
                }
            }
        }
        return changed;
    }",iterator
p,"{
        MethodConfig key = this.key;
        boolean changed = false;
        for (Iterator<MethodNode> it = cn.methods.iterator(); it.hasNext(); ) {
            MethodNode m = it.next();
            if (m.instructions == null) {
                continue;
            }
            key.owner = cn.name;
            key.name = m.name;
            key.desc = m.desc;
            if (map.containsKey(key)) {
                if (deleteMethod) {
                    it.remove();
                }
                continue;
            }


            if (false && verbose) {
                System.out.println();
                System.out.println(""==============="");
                System.out.println(""on method "" + cn.name + "";->"" + m.name + m.desc);
            }

            boolean find = false;
            // search for the decrypt method
            for (AbstractInsnNode p = m.instructions.getFirst(); p != null; p = p.getNext()) {
                if (p.getOpcode() == Opcodes.INVOKESTATIC) {
                    MethodInsnNode mn = (MethodInsnNode) p;
                    key.owner = mn.owner;
                    key.name = mn.name;
                    key.desc = mn.desc;
                    MethodConfig config = map.get(key);
                    if (config != null) {
                        find = true;
                    }
                }
            }
            if (find) {
                try {
                    // copy m to m2 for cleanup debug info
                    MethodNode m2 = new MethodNode();
                    m2.tryCatchBlocks = new ArrayList<>();
                    m2.name = m.name;
                    m2.access = m.access;
                    m2.desc = m.desc;
                    m.accept(m2);
                    cleanDebug(m2);
                    // convert m2 to ir
                    IrMethod irMethod = J2IRConverter.convert(cn.name, m2);
                    // opt and decrypt
                    optAndDecrypt(irMethod, map);

                    // convert ir to m3
                    MethodNode m3 = new MethodNode();
                    m3.tryCatchBlocks = new ArrayList<>();
                    new IR2JConverter()
                            .ir(irMethod)
                            .asm(m3)
                            .convert();

                    // copy back m3 to m
                    m.maxLocals = -1;
                    m.maxLocals = -1;
                    m.instructions = m3.instructions;
                    m.tryCatchBlocks = m3.tryCatchBlocks;
                    m.localVariables = null;
                    changed = true;
                } catch (Exception ex) {
                    if(verbose) {
                        ex.printStackTrace();
                    }
                }
            }
        }
        return changed;
    }",maybe_loop_control
it,"{
        MethodConfig key = this.key;
        boolean changed = false;
        for (Iterator<MethodNode> it = cn.methods.iterator(); it.hasNext(); ) {
            MethodNode m = it.next();
            if (m.instructions == null) {
                continue;
            }
            key.owner = cn.name;
            key.name = m.name;
            key.desc = m.desc;
            if (map.containsKey(key)) {
                if (deleteMethod) {
                    it.remove();
                }
                continue;
            }

            if (false && verbose) {
                System.out.println();
                System.out.println(""==============="");
                System.out.println(""on method "" + cn.name + "";->"" + m.name + m.desc);
            }

            AbstractInsnNode p = m.instructions.getFirst();
            while (p != null) {
                if (p.getOpcode() == Opcodes.INVOKESTATIC) {
                    MethodInsnNode mn = (MethodInsnNode) p;
                    key.owner = mn.owner;
                    key.name = mn.name;
                    key.desc = mn.desc;
                    MethodConfig config = map.get(key);
                    if (config != null) {
                        //here we are, given that the decryption method is successfully recognised
                        Method jmethod = config.jmethod;
                        try {
                            int pSize = jmethod.getParameterTypes().length;
                            // arguments' list. each parameter's value is retrieved by reading bytecode backwards, starting from the INVOKESTATIC statement
                            Object[] as = readArgumentValues(mn, jmethod, pSize);
                            if (verbose) {
                                System.out.println("" > calling "" + jmethod + "" with arguments "" + v(as));
                            }
                            //decryption routine invocation
                            String newValue = (String) jmethod.invoke(null, as);
                            if (verbose) {
                                System.out.println(""  -> "" + Escape.v(newValue));
                            }
                            //LDC statement generation
                            LdcInsnNode nLdc = new LdcInsnNode(newValue);
                            //insertion of the decrypted string's LDC statement, after INVOKESTATIC statement
                            m.instructions.insert(mn, nLdc);
                            //removal of INVOKESTATIC and previous push statements
                            removeInsts(m, mn, pSize);
                            p = nLdc;
                            changed = true;
                        } catch (InvocationTargetException ex){
                            if(verbose){
                                ex.getTargetException().printStackTrace();
                            }
                        } catch (Exception ex) {
                            if (verbose) {
                                ex.printStackTrace();
                            }
                        }
                    }
                }
                p = p.getNext();
            }
        }
        return changed;
    }",iterator
p,"{
        MethodConfig key = this.key;
        boolean changed = false;
        for (Iterator<MethodNode> it = cn.methods.iterator(); it.hasNext(); ) {
            MethodNode m = it.next();
            if (m.instructions == null) {
                continue;
            }
            key.owner = cn.name;
            key.name = m.name;
            key.desc = m.desc;
            if (map.containsKey(key)) {
                if (deleteMethod) {
                    it.remove();
                }
                continue;
            }

            if (false && verbose) {
                System.out.println();
                System.out.println(""==============="");
                System.out.println(""on method "" + cn.name + "";->"" + m.name + m.desc);
            }

            AbstractInsnNode p = m.instructions.getFirst();
            while (p != null) {
                if (p.getOpcode() == Opcodes.INVOKESTATIC) {
                    MethodInsnNode mn = (MethodInsnNode) p;
                    key.owner = mn.owner;
                    key.name = mn.name;
                    key.desc = mn.desc;
                    MethodConfig config = map.get(key);
                    if (config != null) {
                        //here we are, given that the decryption method is successfully recognised
                        Method jmethod = config.jmethod;
                        try {
                            int pSize = jmethod.getParameterTypes().length;
                            // arguments' list. each parameter's value is retrieved by reading bytecode backwards, starting from the INVOKESTATIC statement
                            Object[] as = readArgumentValues(mn, jmethod, pSize);
                            if (verbose) {
                                System.out.println("" > calling "" + jmethod + "" with arguments "" + v(as));
                            }
                            //decryption routine invocation
                            String newValue = (String) jmethod.invoke(null, as);
                            if (verbose) {
                                System.out.println(""  -> "" + Escape.v(newValue));
                            }
                            //LDC statement generation
                            LdcInsnNode nLdc = new LdcInsnNode(newValue);
                            //insertion of the decrypted string's LDC statement, after INVOKESTATIC statement
                            m.instructions.insert(mn, nLdc);
                            //removal of INVOKESTATIC and previous push statements
                            removeInsts(m, mn, pSize);
                            p = nLdc;
                            changed = true;
                        } catch (InvocationTargetException ex){
                            if(verbose){
                                ex.getTargetException().printStackTrace();
                            }
                        } catch (Exception ex) {
                            if (verbose) {
                                ex.printStackTrace();
                            }
                        }
                    }
                }
                p = p.getNext();
            }
        }
        return changed;
    }",maybe_loop_control
i,"{
        T_deadCode.transform(irMethod);
        T_cleanLabel.transform(irMethod);
        T_removeLocal.transform(irMethod);
        T_removeConst.transform(irMethod);
        T_zero.transform(irMethod);
        if (T_npe.transformReportChanged(irMethod)) {
            T_deadCode.transform(irMethod);
            T_removeLocal.transform(irMethod);
            T_removeConst.transform(irMethod);
        }
        T_new.transform(irMethod);
        T_fillArray.transform(irMethod);
        T_agg.transform(irMethod);
        T_voidInvoke.transform(irMethod);

        new StmtTraveler() {
            @Override
            public Value travel(Value op) {
                op = super.travel(op);
                if (op.vt == Value.VT.INVOKE_STATIC) {
                    InvokeExpr ie = (InvokeExpr) op;
                    MethodConfig key = DecryptStringCmd.this.key;
                    key.owner = ie.getOwner().substring(1, ie.getOwner().length() - 1);
                    key.name = ie.getName();
                    key.desc = buildMethodDesc(ie.getArgs(), ie.getRet());

                    MethodConfig c = map.get(key);
                    if (c != null) {
                        try {
                            Method jmethod = c.jmethod;
                            if (ie.getArgs().length != jmethod.getParameterTypes().length) {
                                throw new RuntimeException();
                            }

                            Object args[] = new Object[ie.getArgs().length];
                            for (int i = 0; i < args.length; i++) {
                                args[i] = convertIr2Jobj(ie.getOps()[i], ie.getArgs()[i]);
                            }
                            if (verbose) {
                                System.out.println("" > calling "" + jmethod + "" with arguments "" + v(args));
                            }
                            String str = (String) jmethod.invoke(null, args);
                            if (verbose) {
                                System.out.println(""  -> "" + Escape.v(str));
                            }
                            return Exprs.nString(str);
                        } catch (Exception e) {
                            e.printStackTrace();
                        }

                    }
                }
                return op;
            }
        }.travel(irMethod.stmts);

        T_type.transform(irMethod);
        T_unssa.transform(irMethod);
        T_trimEx.transform(irMethod);
        T_ir2jRegAssign.transform(irMethod);
    }",loop_control
obj,"{
        StringBuilder sb = new StringBuilder(""["");
        boolean first = true;
        for (Object obj : vs) {
            if (first) {
                first = false;
            } else {
                sb.append("","");
            }
            if(obj instanceof String) {
                sb.append(Escape.v(obj));
            }else {
                sb.append(obj);
            }
        }
        return sb.append(""]"").toString();
    }",iterator
i,"{
        if (value instanceof Constant) {
            if (Constant.Null.equals(((Constant) value).value)) {
                return null;
            }
        }
        switch (type) {
            case ""Z"": {
                Object obj = ((Constant) value).value;
                return obj instanceof Boolean ? obj : ((Number) obj).intValue() != 0;
            }
            case ""B"": {
                Object obj = ((Constant) value).value;
                return ((Number) obj).byteValue();
            }
            case ""S"": {
                Object obj = ((Constant) value).value;
                return ((Number) obj).shortValue();
            }
            case ""C"": {
                Object obj = ((Constant) value).value;
                return obj instanceof Character ? obj : (char) ((Number) obj).intValue();
            }
            case ""I"": {
                Object obj = ((Constant) value).value;
                return ((Number) obj).intValue();
            }
            case ""J"": {
                Object obj = ((Constant) value).value;
                return ((Number) obj).longValue();
            }
            case ""F"": {
                Object obj = ((Constant) value).value;
                return obj instanceof Float ? obj : Float.intBitsToFloat(((Number) obj).intValue());
            }
            case ""D"": {
                Object obj = ((Constant) value).value;
                return obj instanceof Double ? obj : Double.longBitsToDouble(((Number) obj).longValue());
            }
            case ""Ljava/lang/String;"":
                return (String) ((Constant) value).value;
            case ""[Z"":
                if (value instanceof Constant) {
                    Object obj = ((Constant) value).value;
                    if (obj instanceof boolean[]) {
                        return obj;
                    } else {

                        boolean[] b = new boolean[Array.getLength(obj)];
                        for (int i = 0; i < b.length; i++) {
                            b[i] = ((Number) Array.get(obj, i)).intValue() != 0;
                        }
                        return b;
                    }
                } else if (value instanceof FilledArrayExpr) {
                    boolean b[] = new boolean[value.getOps().length];
                    for (int i = 0; i < b.length; i++) {
                        Object obj = ((Constant) value.getOps()[i]).value;
                        if (obj instanceof Boolean) {
                            b[i] = ((Boolean) obj).booleanValue();
                        } else {
                            b[i] = ((Number) obj).intValue() != 0;
                        }
                    }
                    return b;
                }
                throw new RuntimeException();
            case ""[B"":
                if (value instanceof Constant) {
                    Object obj = ((Constant) value).value;
                    if (obj instanceof byte[]) {
                        return obj;
                    } else {
                        byte[] b = new byte[Array.getLength(obj)];
                        for (int i = 0; i < b.length; i++) {
                            b[i] = ((Number) Array.get(obj, i)).byteValue();
                        }
                        return b;
                    }
                } else if (value instanceof FilledArrayExpr) {
                    byte b[] = new byte[value.getOps().length];
                    for (int i = 0; i < b.length; i++) {
                        Object obj = ((Constant) value.getOps()[i]).value;
                        b[i] = ((Number) obj).byteValue();
                    }
                    return b;
                }
                throw new RuntimeException();
            case ""[S"":
                if (value instanceof Constant) {
                    Object obj = ((Constant) value).value;
                    if (obj instanceof short[]) {
                        return obj;
                    } else {
                        short[] b = new short[Array.getLength(obj)];
                        for (int i = 0; i < b.length; i++) {
                            b[i] = ((Number) Array.get(obj, i)).shortValue();
                        }
                        return b;
                    }
                } else if (value instanceof FilledArrayExpr) {
                    short b[] = new short[value.getOps().length];
                    for (int i = 0; i < b.length; i++) {
                        Object obj = ((Constant) value.getOps()[i]).value;
                        b[i] = ((Number) obj).shortValue();
                    }
                    return b;
                }
                throw new RuntimeException();
            case ""[C"":
                if (value instanceof Constant) {
                    Object obj = ((Constant) value).value;
                    if (obj instanceof char[]) {
                        return obj;
                    } else {
                        char[] b = new char[Array.getLength(obj)];
                        for (int i = 0; i < b.length; i++) {
                            b[i] = (char) ((Number) Array.get(obj, i)).intValue();
                        }
                        return b;
                    }
                } else if (value instanceof FilledArrayExpr) {
                    char b[] = new char[value.getOps().length];
                    for (int i = 0; i < b.length; i++) {
                        Object obj = ((Constant) value.getOps()[i]).value;
                        b[i] = obj instanceof Character ? ((Character) obj).charValue() : (char) ((Number) obj).intValue();
                    }
                    return b;
                }
                throw new RuntimeException();
            case ""[I"":
                if (value instanceof Constant) {
                    Object obj = ((Constant) value).value;
                    if (obj instanceof int[]) {
                        return obj;
                    } else {
                        int[] b = new int[Array.getLength(obj)];
                        for (int i = 0; i < b.length; i++) {
                            b[i] = ((Number) Array.get(obj, i)).intValue();
                        }
                        return b;
                    }
                } else if (value instanceof FilledArrayExpr) {
                    int b[] = new int[value.getOps().length];
                    for (int i = 0; i < b.length; i++) {
                        Object obj = ((Constant) value.getOps()[i]).value;
                        b[i] = ((Number) obj).intValue();
                    }
                    return b;
                }
                throw new RuntimeException();
            case ""[J"":
                if (value instanceof Constant) {
                    Object obj = ((Constant) value).value;
                    if (obj instanceof long[]) {
                        return obj;
                    } else {
                        long[] b = new long[Array.getLength(obj)];
                        for (int i = 0; i < b.length; i++) {
                            b[i] = ((Number) Array.get(obj, i)).longValue();
                        }
                        return b;
                    }
                } else if (value instanceof FilledArrayExpr) {
                    long b[] = new long[value.getOps().length];
                    for (int i = 0; i < b.length; i++) {
                        Object obj = ((Constant) value.getOps()[i]).value;
                        b[i] = ((Number) obj).longValue();
                    }
                    return b;
                }
                throw new RuntimeException();
            case ""[F"":
                if (value instanceof Constant) {
                    Object obj = ((Constant) value).value;
                    if (obj instanceof float[]) {
                        return obj;
                    } else {
                        float[] b = new float[Array.getLength(obj)];
                        for (int i = 0; i < b.length; i++) {
                            b[i] = (char) ((Number) Array.get(obj, i)).intValue();
                        }
                        return b;
                    }
                } else if (value instanceof FilledArrayExpr) {
                    float b[] = new float[value.getOps().length];
                    for (int i = 0; i < b.length; i++) {
                        Object obj = ((Constant) value.getOps()[i]).value;
                        b[i] = obj instanceof Float ? ((Float) obj).floatValue() : Float.intBitsToFloat(((Number) obj).intValue());
                    }
                    return b;
                }
                throw new RuntimeException();
            case ""[D"":
                if (value instanceof Constant) {
                    Object obj = ((Constant) value).value;
                    if (obj instanceof double[]) {
                        return obj;
                    } else {
                        double[] b = new double[Array.getLength(obj)];
                        for (int i = 0; i < b.length; i++) {
                            b[i] = (char) ((Number) Array.get(obj, i)).intValue();
                        }
                        return b;
                    }
                } else if (value instanceof FilledArrayExpr) {
                    double b[] = new double[value.getOps().length];
                    for (int i = 0; i < b.length; i++) {
                        Object obj = ((Constant) value.getOps()[i]).value;
                        b[i] = obj instanceof Double ? ((Double) obj).doubleValue() : Double.longBitsToDouble(((Number) obj).longValue());
                    }
                    return b;
                }
                throw new RuntimeException();
            case ""[Ljava/lang/String;"":
                if (value instanceof Constant) {
                    Object obj = ((Constant) value).value;
                    if (obj instanceof String[]) {
                        return obj;
                    }
                } else if (value instanceof FilledArrayExpr) {
                    String b[] = new String[value.getOps().length];
                    for (int i = 0; i < b.length; i++) {
                        Object obj = ((Constant) value.getOps()[i]).value;
                        if (obj instanceof String) {
                            b[i] = (String) obj;
                        } else if (Constant.Null.equals(obj)) {
                            b[i] = null;
                        } else {
                            throw new RuntimeException();
                        }
                    }
                    return b;
                }
                throw new RuntimeException();
        }
        throw new RuntimeException();
    }",loop_control
s,"{
        StringBuilder sb = new StringBuilder();
        sb.append('(');
        for (String s : args) {
            sb.append(s);
        }
        return sb.append(')').append(ret).toString();
    }",iterator
p,"{
        for (AbstractInsnNode p = mn.instructions.getFirst(); p != null; ) {
            if (p.getType() == AbstractInsnNode.LINE) {
                AbstractInsnNode q = p.getNext();
                mn.instructions.remove(p);
                p = q;
            } else {
                p = p.getNext();
            }
        }
        mn.localVariables = null;
    }",maybe_loop_control
i,"{
        // remove args
        for (int i = 0; i < pSize; i++) {
            m.instructions.remove(mn.getPrevious());
        }
        // remove INVOKESTATIC
        m.instructions.remove(mn);
    }",loop_control
i,"{
        AbstractInsnNode q = mn;
        Object[] as = new Object[pSize];
        for (int i = pSize - 1; i >= 0; i--) {
            q = q.getPrevious();
            Object object = readCst(q);
            as[i] = convert(object, jmethod.getParameterTypes()[i]);
        }
        return as;
    }",loop_control
i,"{
        final Map<MethodConfig, MethodConfig> map = new HashMap<>();
        List<String> list = new ArrayList<>();
        if (classpath != null) {
            list.addAll(Arrays.asList(classpath.split("";|:"")));
        }
        list.add(jar.toAbsolutePath().toString());
        URL[] urls = new URL[list.size()];
        for (int i = 0; i < list.size(); i++) {
            urls[i] = new File(list.get(i)).toURI().toURL();
        }

        URLClassLoader cl = new URLClassLoader(urls);
        for (MethodConfig config : methodConfigs) {
            Method jmethod;
            try {
                Class<?> clz = cl.loadClass(config.owner.replace('/', '.'));
                if (clz == null) {
                    System.err.println(""clz is null:"" + config.owner);
                }
                jmethod = findAnyMethodMatch(clz, config.name,
                        toJavaType(Type.getArgumentTypes(config.desc)));
            } catch (Exception ex) {
                System.err.println(""can't load method: L"" + config.owner + "";->"" + config.name + config.desc);
                throw ex;
            }
            if (jmethod != null) {
                jmethod.setAccessible(true);
                config.jmethod = jmethod;
                map.put(config, config);
            } else {
                throw new NoSuchMethodException(""can't find method "" + config.name + config.desc + "" on class "" + config.owner + "" or its parent"");
            }
        }
        return map;
    }",loop_control
config,"{
        final Map<MethodConfig, MethodConfig> map = new HashMap<>();
        List<String> list = new ArrayList<>();
        if (classpath != null) {
            list.addAll(Arrays.asList(classpath.split("";|:"")));
        }
        list.add(jar.toAbsolutePath().toString());
        URL[] urls = new URL[list.size()];
        for (int i = 0; i < list.size(); i++) {
            urls[i] = new File(list.get(i)).toURI().toURL();
        }

        URLClassLoader cl = new URLClassLoader(urls);
        for (MethodConfig config : methodConfigs) {
            Method jmethod;
            try {
                Class<?> clz = cl.loadClass(config.owner.replace('/', '.'));
                if (clz == null) {
                    System.err.println(""clz is null:"" + config.owner);
                }
                jmethod = findAnyMethodMatch(clz, config.name,
                        toJavaType(Type.getArgumentTypes(config.desc)));
            } catch (Exception ex) {
                System.err.println(""can't load method: L"" + config.owner + "";->"" + config.name + config.desc);
                throw ex;
            }
            if (jmethod != null) {
                jmethod.setAccessible(true);
                config.jmethod = jmethod;
                map.put(config, config);
            } else {
                throw new NoSuchMethodException(""can't find method "" + config.name + config.desc + "" on class "" + config.owner + "" or its parent"");
            }
        }
        return map;
    }",iterator
line,"{
        List<MethodConfig> methodConfigs = new ArrayList<>();
        if (this.method != null) {
            for (String line : Files.readAllLines(this.method, StandardCharsets.UTF_8)) {
                if (line.length() == 0 || line.startsWith(""#"")) {
                    continue;
                }
                methodConfigs.add(this.build(line));
            }
        }
        if (methodOwner != null && methodName != null) {
            if (this.parametersDescriptor != null) {
                methodConfigs.add(this.build(""L"" + methodOwner.replace('.', '/') + "";->"" + methodName + ""(""
                        + this.parametersDescriptor + "")Ljava/lang/String;""));
            } else if (this.parameterJTypes != null) {

                //parameterJTypes is a comma-separated list of the decryption method's parameters
                String[] type_list = parameterJTypes.split("",|;|:"");
                //switch for all the supported types. String is default
                StringBuilder sb = new StringBuilder();
                for (int i = 0; i < type_list.length; i++) {
                    switch (type_list[i]) {
                        case ""boolean"":
                            sb.append(""Z"");
                            break;
                        case ""byte"":
                            sb.append(""B"");
                            break;
                        case ""short"":
                            sb.append(""S"");
                            break;
                        case ""char"":
                            sb.append(""C"");
                            break;
                        case ""int"":
                            sb.append(""I"");
                            break;
                        case ""long"":
                            sb.append(""J"");
                            break;
                        case ""float"":
                            sb.append(""F"");
                            break;
                        case ""double"":
                            sb.append(""D"");
                            break;
                        case ""string"":
                            sb.append(""Ljava/lang/String;"");
                            break;

                        default:
                            throw new RuntimeException(""not support type "" + type_list[i] + "" on -t/--arg-types"");
                    }
                }
                methodConfigs.add(this.build(""L"" + methodOwner.replace('.', '/') + "";->"" + methodName + ""(""
                        + sb + "")Ljava/lang/String;""));
            } else {
                methodConfigs.add(this.build(""L"" + methodOwner.replace('.', '/') + "";->"" + methodName + ""(Ljava/lang/String;)Ljava/lang/String;""));
            }
        }
        return methodConfigs;
    }",iterator
i,"{
        List<MethodConfig> methodConfigs = new ArrayList<>();
        if (this.method != null) {
            for (String line : Files.readAllLines(this.method, StandardCharsets.UTF_8)) {
                if (line.length() == 0 || line.startsWith(""#"")) {
                    continue;
                }
                methodConfigs.add(this.build(line));
            }
        }
        if (methodOwner != null && methodName != null) {
            if (this.parametersDescriptor != null) {
                methodConfigs.add(this.build(""L"" + methodOwner.replace('.', '/') + "";->"" + methodName + ""(""
                        + this.parametersDescriptor + "")Ljava/lang/String;""));
            } else if (this.parameterJTypes != null) {

                //parameterJTypes is a comma-separated list of the decryption method's parameters
                String[] type_list = parameterJTypes.split("",|;|:"");
                //switch for all the supported types. String is default
                StringBuilder sb = new StringBuilder();
                for (int i = 0; i < type_list.length; i++) {
                    switch (type_list[i]) {
                        case ""boolean"":
                            sb.append(""Z"");
                            break;
                        case ""byte"":
                            sb.append(""B"");
                            break;
                        case ""short"":
                            sb.append(""S"");
                            break;
                        case ""char"":
                            sb.append(""C"");
                            break;
                        case ""int"":
                            sb.append(""I"");
                            break;
                        case ""long"":
                            sb.append(""J"");
                            break;
                        case ""float"":
                            sb.append(""F"");
                            break;
                        case ""double"":
                            sb.append(""D"");
                            break;
                        case ""string"":
                            sb.append(""Ljava/lang/String;"");
                            break;

                        default:
                            throw new RuntimeException(""not support type "" + type_list[i] + "" on -t/--arg-types"");
                    }
                }
                methodConfigs.add(this.build(""L"" + methodOwner.replace('.', '/') + "";->"" + methodName + ""(""
                        + sb + "")Ljava/lang/String;""));
            } else {
                methodConfigs.add(this.build(""L"" + methodOwner.replace('.', '/') + "";->"" + methodName + ""(Ljava/lang/String;)Ljava/lang/String;""));
            }
        }
        return methodConfigs;
    }",loop_control
itf,"{
        try {
            Method m = clz.getDeclaredMethod(name, classes);
            if (m != null) {
                return m;
            }
        } catch (NoSuchMethodException ignored) {
            // https://github.com/pxb1988/dex2jar/issues/51
            // mute exception stack
        }
        Class<?> sup = clz.getSuperclass();
        if (sup != null) {
            Method m = findAnyMethodMatch(sup, name, classes);
            if (m != null) {
                return m;
            }
        }
        Class<?>[] itfs = clz.getInterfaces();
        if (itfs != null && itfs.length > 0) {
            for (Class<?> itf : itfs) {
                Method m = findAnyMethodMatch(itf, name, classes);
                if (m != null) {
                    return m;
                }
            }
        }
        return null;
    }",iterator
i,"{
        Class<?> jt[] = new Class<?>[pt.length];
        for (int i = 0; i < pt.length; i++) {
            jt[i] = toJavaType(pt[i]);
        }
        return jt;
    }",loop_control
e,"{
        ZipArchiveInputStream zis = new ZipArchiveInputStream(BadZipEntryFlagTest.class.getResourceAsStream(""/bad.zip""));
        for (ZipArchiveEntry e = zis.getNextZipEntry(); e != null; e = zis.getNextZipEntry()) {
            e.getGeneralPurposeBit().useEncryption(false);
            if (!e.isDirectory()) {
                zis.read();
                System.out.println(e.getName());
            }
        }
    }",maybe_loop_control
e,"{
        byte[] data = ZipUtil.toByteArray(BadZipEntryFlagTest.class.getResourceAsStream(""/bad.zip""));
        try (ZipFile zip = new ZipFile(data)) {
            for (com.googlecode.d2j.util.zip.ZipEntry e : zip.entries()) {
                System.out.println(e);
                if (!e.isDirectory()) {
                    zip.getInputStream(e).read();
                }
            }
        }
    }",iterator
i,"{
        in.position(0);
        in = in.asReadOnlyBuffer().order(ByteOrder.BIG_ENDIAN);
        int magic = in.getInt() & 0xFFFFFF00;

        final int MAGIC_DEX = 0x6465780A & 0xFFFFFF00;// hex for 'dex ', ignore the 0A
        final int MAGIC_ODEX = 0x6465790A & 0xFFFFFF00;// hex for 'dey ', ignore the 0A

        if (magic == MAGIC_DEX) {
            ;
        } else if (magic == MAGIC_ODEX) {
            throw new DexException(""Not support odex"");
        } else {
            throw new DexException(""not support magic."");
        }
        int version = in.getInt() >> 8;
        if (version < 0 || version < DEX_035) {
            throw new DexException(""not support version."");
        }
        this.dex_version = version;
        in.order(ByteOrder.LITTLE_ENDIAN);

        // skip uint checksum
        // and 20 bytes signature
        // and uint file_size
        // and uint header_size 0x70
        skip(in, 4 + 20 + 4 + 4);

        int endian_tag = in.getInt();
        if (endian_tag != ENDIAN_CONSTANT) {
            throw new DexException(""not support endian_tag"");
        }

        // skip uint link_size
        // and uint link_off
        skip(in, 4 + 4);

        int map_off = in.getInt();

        string_ids_size = in.getInt();
        int string_ids_off = in.getInt();
        type_ids_size = in.getInt();
        int type_ids_off = in.getInt();
        proto_ids_size = in.getInt();
        int proto_ids_off = in.getInt();
        field_ids_size = in.getInt();
        int field_ids_off = in.getInt();
        method_ids_size = in.getInt();
        int method_ids_off = in.getInt();
        class_defs_size = in.getInt();
        int class_defs_off = in.getInt();
        // skip uint data_size data_off

        int call_site_ids_off = 0;
        int call_site_ids_size = 0;
        int method_handle_ids_off = 0;
        int method_handle_ids_size = 0;
        if (dex_version > DEX_037) {
            in.position(map_off);
            int size = in.getInt();
            for (int i = 0; i < size; i++) {
                int type = in.getShort() & 0xFFFF;
                in.getShort(); // unused;
                int item_size = in.getInt();
                int item_offset = in.getInt();
                switch (type) {
                case TYPE_CALL_SITE_ID_ITEM:
                    call_site_ids_off = item_offset;
                    call_site_ids_size = item_size;
                    break;
                case TYPE_METHOD_HANDLE_ITEM:
                    method_handle_ids_off = item_offset;
                    method_handle_ids_size = item_size;
                    break;
                default:
                    break;
                }
            }
        }
        this.call_site_ids_size = call_site_ids_size;
        this.method_handle_ids_size = method_handle_ids_size;

        stringIdIn = slice(in, string_ids_off, string_ids_size * 4);
        typeIdIn = slice(in, type_ids_off, type_ids_size * 4);
        protoIdIn = slice(in, proto_ids_off, proto_ids_size * 12);
        fieldIdIn = slice(in, field_ids_off, field_ids_size * 8);
        methoIdIn = slice(in, method_ids_off, method_ids_size * 8);
        classDefIn = slice(in, class_defs_off, class_defs_size * 32);
        callSiteIdIn = slice(in, call_site_ids_off, call_site_ids_size * 4);
        methodHandleIdIn = slice(in, method_handle_ids_off, method_handle_ids_size * 8);

        in.position(0);
        annotationsDirectoryItemIn = in.duplicate().order(ByteOrder.LITTLE_ENDIAN);
        annotationSetItemIn = in.duplicate().order(ByteOrder.LITTLE_ENDIAN);
        annotationItemIn = in.duplicate().order(ByteOrder.LITTLE_ENDIAN);
        annotationSetRefListIn = in.duplicate().order(ByteOrder.LITTLE_ENDIAN);
        classDataIn = in.duplicate().order(ByteOrder.LITTLE_ENDIAN);
        codeItemIn = in.duplicate().order(ByteOrder.LITTLE_ENDIAN);
        stringDataIn = in.duplicate().order(ByteOrder.LITTLE_ENDIAN);
        encodedArrayItemIn = in.duplicate().order(ByteOrder.LITTLE_ENDIAN);
        typeListIn = in.duplicate().order(ByteOrder.LITTLE_ENDIAN);
        debugInfoIn = in.duplicate().order(ByteOrder.LITTLE_ENDIAN);
    }",loop_control
c,"{
        ByteArrayOutputStream out = new ByteArrayOutputStream();
        byte[] buff = new byte[1024];
        for (int c = is.read(buff); c > 0; c = is.read(buff)) {
            out.write(buff, 0, c);
        }
        return out.toByteArray();
    }",maybe_loop_control
i,"{
        StringBuilder sb = new StringBuilder();
        for (int i = 0; i < deep + 1; i++) {
            sb.append(""."");
        }
        sb.append(' ');
        if (t instanceof DexException) {
            sb.append(t.getMessage());
            System.err.println(sb.toString());
            if (t.getCause() != null) {
                niceExceptionMessage(t.getCause(), deep + 1);
            }
        } else {
            if (t != null) {
                System.err.println(sb.append(""ROOT cause:"").toString());
                t.printStackTrace(System.err);
            }
        }
    }",loop_control
j,"{
        int length = ((before >> 5) & 0x7) + 1;
        long value = 0;
        for (int j = 0; j < length; j++) {
            value |= ((long) (0xFF & in.get())) << (j * 8);
        }
        int shift = (8 - length) * 8;
        return value << shift >> shift;
    }",loop_control
j,"{
        int length = ((before >> 5) & 0x7) + 1;
        long value = 0;
        for (int j = 0; j < length; j++) {
            value |= ((long) (0xFF & in.get())) << (j * 8);
        }
        return value;
    }",loop_control
i,"{
        int bytes = ((before >> 5) & 0x7) + 1;
        long result = 0L;
        for (int i = 0; i < bytes; ++i) {
            result |= ((long) (0xFF & in.get())) << (i * 8);
        }
        result <<= (8 - bytes) * 8;
        return result;
    }",loop_control
b,"{
        int value = 0;
        int count = 0;
        int b = in.get();
        while ((b & 0x80) != 0) {
            value |= (b & 0x7f) << count;
            count += 7;
            b = in.get();
        }
        value |= (b & 0x7f) << count;
        return value;
    }",maybe_loop_control
inp,"{
        int bitpos = 0;
        int vln = 0;
        do {
            int inp = in.get();
            vln |= (inp & 0x7F) << bitpos;
            bitpos += 7;
            if ((inp & 0x80) == 0) {
                break;
            }
        } while (true);
        if (((1L << (bitpos - 1)) & vln) != 0) {
            vln -= (1L << bitpos);
        }
        return vln;
    }",break_loop_control
paramType,"{
        ByteBuffer in = debugInfoIn;
        in.position(offset);
        int address = 0;
        int line = readULeb128i(in);
        int szParams = readULeb128i(in);
        LocalEntry lastEntryForReg[] = new LocalEntry[regSize];
        int argsSize = 0;
        for (String paramType : method.getParameterTypes()) {
            if (paramType.equals(""J"") || paramType.equals(""D"")) {
                argsSize += 2;
            } else {
                argsSize += 1;
            }
        }
        int curReg = regSize - argsSize;
        if (!isStatic) {
            // Start off with implicit 'this' entry
            LocalEntry thisEntry = new LocalEntry(""this"", method.getOwner(), null);
            lastEntryForReg[curReg - 1] = thisEntry;
            // dcv.visitParameterName(curReg - 1, ""this"");
            DEBUG_DEBUG(""v%d :%s, %s"", curReg - 1, ""this"", method.getOwner());
        }

        String[] params = method.getParameterTypes();
        for (int i = 0; i < szParams; i++) {
            String paramType = params[i];
            LocalEntry le;

            int nameIdx = readStringIndex(in);
            String name = getString(nameIdx);
            le = new LocalEntry(name, paramType);
            lastEntryForReg[curReg] = le;
            if (name != null) {
                dcv.visitParameterName(i, name);
            }
            DEBUG_DEBUG(""v%d :%s, %s"", curReg, name, paramType);
            curReg += 1;
            if (paramType.equals(""J"") || paramType.equals(""D"")) {
                curReg += 1;
            }
        }

        for (;;) {
            int opcode = in.get() & 0xff;

            switch (opcode) {
            case DBG_START_LOCAL: {
                int reg = readULeb128i(in);
                int nameIdx = readStringIndex(in);
                int typeIdx = readStringIndex(in);
                String name = getString(nameIdx);
                String type = getType(typeIdx);
                DEBUG_DEBUG(""Start: v%d :%s, %s"", reg, name, type);
                LocalEntry le = new LocalEntry(name, type);
                lastEntryForReg[reg] = le;
                order(labelMap, address);
                dcv.visitStartLocal(reg, labelMap.get(address), name, type, null);
            }
                break;

            case DBG_START_LOCAL_EXTENDED: {
                int reg = readULeb128i(in);
                int nameIdx = readStringIndex(in);
                int typeIdx = readStringIndex(in);
                int sigIdx = readStringIndex(in);
                String name = getString(nameIdx);
                String type = getType(typeIdx);
                String signature = getString(sigIdx);
                DEBUG_DEBUG(""Start: v%d :%s, %s // %s"", reg, name, type, signature);
                LocalEntry le = new LocalEntry(name, type, signature);
                order(labelMap, address);
                dcv.visitStartLocal(reg, labelMap.get(address), name, type, signature);
                lastEntryForReg[reg] = le;
            }
                break;

            case DBG_RESTART_LOCAL: {
                int reg = readULeb128i(in);
                LocalEntry le = lastEntryForReg[reg];
                if (le == null) {
                    throw new RuntimeException(""Encountered RESTART_LOCAL on new v"" + reg);
                }
                if (le.signature == null) {
                    DEBUG_DEBUG(""Start: v%d :%s, %s"", reg, le.name, le.type);
                } else {
                    DEBUG_DEBUG(""Start: v%d :%s, %s // %s"", reg, le.name, le.type, le.signature);
                }
                order(labelMap, address);
                dcv.visitRestartLocal(reg, labelMap.get(address));
            }
                break;

            case DBG_END_LOCAL: {
                int reg = readULeb128i(in);
                LocalEntry le = lastEntryForReg[reg];
                if (le == null) {
                    throw new RuntimeException(""Encountered RESTART_LOCAL on new v"" + reg);
                }
                if (le.signature == null) {
                    DEBUG_DEBUG(""End: v%d :%s, %s"", reg, le.name, le.type);
                } else {
                    DEBUG_DEBUG(""End: v%d :%s, %s // %s"", reg, le.name, le.type, le.signature);
                }
                order(labelMap, address);
                dcv.visitEndLocal(reg, labelMap.get(address));
            }
                break;

            case DBG_END_SEQUENCE:
                // all done
                return;

            case DBG_ADVANCE_PC:
                address += readULeb128i(in);
                break;

            case DBG_ADVANCE_LINE:
                line += readLeb128i(in);
                break;

            case DBG_SET_PROLOGUE_END:
                order(labelMap, address);
                dcv.visitPrologue(labelMap.get(address));
                break;
            case DBG_SET_EPILOGUE_BEGIN:
                order(labelMap, address);
                dcv.visitEpiogue(labelMap.get(address));
                break;
            case DBG_SET_FILE:
                // skip
                break;

            default:
                if (opcode < DBG_FIRST_SPECIAL) {
                    throw new RuntimeException(""Invalid extended opcode encountered "" + opcode);
                }

                int adjopcode = opcode - DBG_FIRST_SPECIAL;

                address += adjopcode / DBG_LINE_RANGE;
                line += DBG_LINE_BASE + (adjopcode % DBG_LINE_RANGE);

                order(labelMap, address);
                dcv.visitLineNumber(line, labelMap.get(address));
                break;

            }
        }
    }",iterator
i,"{
        ByteBuffer in = debugInfoIn;
        in.position(offset);
        int address = 0;
        int line = readULeb128i(in);
        int szParams = readULeb128i(in);
        LocalEntry lastEntryForReg[] = new LocalEntry[regSize];
        int argsSize = 0;
        for (String paramType : method.getParameterTypes()) {
            if (paramType.equals(""J"") || paramType.equals(""D"")) {
                argsSize += 2;
            } else {
                argsSize += 1;
            }
        }
        int curReg = regSize - argsSize;
        if (!isStatic) {
            // Start off with implicit 'this' entry
            LocalEntry thisEntry = new LocalEntry(""this"", method.getOwner(), null);
            lastEntryForReg[curReg - 1] = thisEntry;
            // dcv.visitParameterName(curReg - 1, ""this"");
            DEBUG_DEBUG(""v%d :%s, %s"", curReg - 1, ""this"", method.getOwner());
        }

        String[] params = method.getParameterTypes();
        for (int i = 0; i < szParams; i++) {
            String paramType = params[i];
            LocalEntry le;

            int nameIdx = readStringIndex(in);
            String name = getString(nameIdx);
            le = new LocalEntry(name, paramType);
            lastEntryForReg[curReg] = le;
            if (name != null) {
                dcv.visitParameterName(i, name);
            }
            DEBUG_DEBUG(""v%d :%s, %s"", curReg, name, paramType);
            curReg += 1;
            if (paramType.equals(""J"") || paramType.equals(""D"")) {
                curReg += 1;
            }
        }

        for (;;) {
            int opcode = in.get() & 0xff;

            switch (opcode) {
            case DBG_START_LOCAL: {
                int reg = readULeb128i(in);
                int nameIdx = readStringIndex(in);
                int typeIdx = readStringIndex(in);
                String name = getString(nameIdx);
                String type = getType(typeIdx);
                DEBUG_DEBUG(""Start: v%d :%s, %s"", reg, name, type);
                LocalEntry le = new LocalEntry(name, type);
                lastEntryForReg[reg] = le;
                order(labelMap, address);
                dcv.visitStartLocal(reg, labelMap.get(address), name, type, null);
            }
                break;

            case DBG_START_LOCAL_EXTENDED: {
                int reg = readULeb128i(in);
                int nameIdx = readStringIndex(in);
                int typeIdx = readStringIndex(in);
                int sigIdx = readStringIndex(in);
                String name = getString(nameIdx);
                String type = getType(typeIdx);
                String signature = getString(sigIdx);
                DEBUG_DEBUG(""Start: v%d :%s, %s // %s"", reg, name, type, signature);
                LocalEntry le = new LocalEntry(name, type, signature);
                order(labelMap, address);
                dcv.visitStartLocal(reg, labelMap.get(address), name, type, signature);
                lastEntryForReg[reg] = le;
            }
                break;

            case DBG_RESTART_LOCAL: {
                int reg = readULeb128i(in);
                LocalEntry le = lastEntryForReg[reg];
                if (le == null) {
                    throw new RuntimeException(""Encountered RESTART_LOCAL on new v"" + reg);
                }
                if (le.signature == null) {
                    DEBUG_DEBUG(""Start: v%d :%s, %s"", reg, le.name, le.type);
                } else {
                    DEBUG_DEBUG(""Start: v%d :%s, %s // %s"", reg, le.name, le.type, le.signature);
                }
                order(labelMap, address);
                dcv.visitRestartLocal(reg, labelMap.get(address));
            }
                break;

            case DBG_END_LOCAL: {
                int reg = readULeb128i(in);
                LocalEntry le = lastEntryForReg[reg];
                if (le == null) {
                    throw new RuntimeException(""Encountered RESTART_LOCAL on new v"" + reg);
                }
                if (le.signature == null) {
                    DEBUG_DEBUG(""End: v%d :%s, %s"", reg, le.name, le.type);
                } else {
                    DEBUG_DEBUG(""End: v%d :%s, %s // %s"", reg, le.name, le.type, le.signature);
                }
                order(labelMap, address);
                dcv.visitEndLocal(reg, labelMap.get(address));
            }
                break;

            case DBG_END_SEQUENCE:
                // all done
                return;

            case DBG_ADVANCE_PC:
                address += readULeb128i(in);
                break;

            case DBG_ADVANCE_LINE:
                line += readLeb128i(in);
                break;

            case DBG_SET_PROLOGUE_END:
                order(labelMap, address);
                dcv.visitPrologue(labelMap.get(address));
                break;
            case DBG_SET_EPILOGUE_BEGIN:
                order(labelMap, address);
                dcv.visitEpiogue(labelMap.get(address));
                break;
            case DBG_SET_FILE:
                // skip
                break;

            default:
                if (opcode < DBG_FIRST_SPECIAL) {
                    throw new RuntimeException(""Invalid extended opcode encountered "" + opcode);
                }

                int adjopcode = opcode - DBG_FIRST_SPECIAL;

                address += adjopcode / DBG_LINE_RANGE;
                line += DBG_LINE_BASE + (adjopcode % DBG_LINE_RANGE);

                order(labelMap, address);
                dcv.visitLineNumber(line, labelMap.get(address));
                break;

            }
        }
    }",loop_control
cid,"{
        List<String> names = new ArrayList<>(class_defs_size);
        ByteBuffer in = classDefIn;
        for (int cid = 0; cid < class_defs_size; cid++) {
            in.position(cid * 32);
            String className = this.getType(in.getInt());
            names.add(className);
        }
        return names;
    }",loop_control
cid,"{
        dv.visitDexFileVersion(this.dex_version);
        for (int cid = 0; cid < class_defs_size; cid++) {
            accept(dv, cid, config);
        }
        dv.visitEnd();
    }",loop_control
i,"{
        if ((config & SKIP_DEBUG) == 0) {
            // 获取源文件
            if (source_file_idx != -1) {
                dcv.visitSource(this.getString(source_file_idx));
            }
        }

        Map<Integer, Integer> fieldAnnotationPositions;
        Map<Integer, Integer> methodAnnotationPositions;
        Map<Integer, Integer> paramAnnotationPositions;
        if ((config & SKIP_ANNOTATION) == 0) {
            // 获取注解
            fieldAnnotationPositions = new HashMap<Integer, Integer>();
            methodAnnotationPositions = new HashMap<Integer, Integer>();
            paramAnnotationPositions = new HashMap<Integer, Integer>();
            if (annotations_off != 0) { // annotations_directory_item

                annotationsDirectoryItemIn.position(annotations_off);

                int class_annotations_off = annotationsDirectoryItemIn.getInt();
                int field_annotation_size = annotationsDirectoryItemIn.getInt();
                int method_annotation_size = annotationsDirectoryItemIn.getInt();
                int parameter_annotation_size = annotationsDirectoryItemIn.getInt();

                for (int i = 0; i < field_annotation_size; i++) {
                    int field_idx = annotationsDirectoryItemIn.getInt();
                    int field_annotations_offset = annotationsDirectoryItemIn.getInt();
                    fieldAnnotationPositions.put(field_idx, field_annotations_offset);
                }
                for (int i = 0; i < method_annotation_size; i++) {
                    int method_idx = annotationsDirectoryItemIn.getInt();
                    int method_annotation_offset = annotationsDirectoryItemIn.getInt();
                    methodAnnotationPositions.put(method_idx, method_annotation_offset);
                }
                for (int i = 0; i < parameter_annotation_size; i++) {
                    int method_idx = annotationsDirectoryItemIn.getInt();
                    int parameter_annotation_offset = annotationsDirectoryItemIn.getInt();
                    paramAnnotationPositions.put(method_idx, parameter_annotation_offset);
                }

                if (class_annotations_off != 0) {
                    try {
                        read_annotation_set_item(class_annotations_off, dcv);
                    } catch (Exception e) {
                        throw new DexException(""error on reading Annotation of class "", e);
                    }
                }
            }
        } else {
            fieldAnnotationPositions = null;
            methodAnnotationPositions = null;
            paramAnnotationPositions = null;
        }

        if (class_data_off != 0) {
            ByteBuffer in = classDataIn;
            in.position(class_data_off);

            int static_fields = (int) readULeb128i(in);
            int instance_fields = (int) readULeb128i(in);
            int direct_methods = (int) readULeb128i(in);
            int virtual_methods = (int) readULeb128i(in);
            {
                int lastIndex = 0;
                {
                    Object[] constant = null;
                    if ((config & SKIP_FIELD_CONSTANT) == 0) {
                        if (static_values_off != 0) {
                            constant = read_encoded_array_item(static_values_off);
                        }
                    }
                    for (int i = 0; i < static_fields; i++) {
                        Object value = null;
                        if (constant != null && i < constant.length) {
                            value = constant[i];
                        }
                        lastIndex = acceptField(in, lastIndex, dcv, fieldAnnotationPositions, value, config);
                    }
                }
                lastIndex = 0;
                for (int i = 0; i < instance_fields; i++) {
                    lastIndex = acceptField(in, lastIndex, dcv, fieldAnnotationPositions, null, config);
                }
                lastIndex = 0;
                boolean firstMethod = true;
                for (int i = 0; i < direct_methods; i++) {
                    lastIndex = acceptMethod(in, lastIndex, dcv, methodAnnotationPositions, paramAnnotationPositions,
                            config, firstMethod);
                    firstMethod = false;
                }
                lastIndex = 0;
                firstMethod = true;
                for (int i = 0; i < virtual_methods; i++) {
                    lastIndex = acceptMethod(in, lastIndex, dcv, methodAnnotationPositions, paramAnnotationPositions,
                            config, firstMethod);
                    firstMethod = false;
                }
            }

        }
    }",loop_control
i,"{
        int size = readULeb128i(in);
        Object[] constant = new Object[size];
        for (int i = 0; i < size; i++) {
            constant[i] = readEncodedValue(in);
        }
        return constant;
    }",loop_control
j,"{ // annotation_set_item
        ByteBuffer in = annotationSetItemIn;
        in.position(offset);
        int size = in.getInt();
        for (int j = 0; j < size; j++) {
            int annotation_off = in.getInt();
            read_annotation_item(annotation_off, daa);
        }
    }",loop_control
i,"{
        int type_idx = readULeb128i(in);
        int size = readULeb128i(in);
        String _typeString = getType(type_idx);
        DexAnnotationNode ann = new DexAnnotationNode(_typeString, Visibility.RUNTIME);
        for (int i = 0; i < size; i++) {
            int name_idx = readULeb128i(in);
            String nameString = getString(name_idx);
            Object value = readEncodedValue(in);
            ann.items.add(new DexAnnotationNode.Item(nameString, value));
        }
        return ann;
    }",loop_control
i,"{
        if (offset == 0) {
            return new String[0];
        }
        typeListIn.position(offset);
        int size = typeListIn.getInt();
        String[] types = new String[size];
        for (int i = 0; i < size; i++) {
            types[i] = getType(0xFFFF & typeListIn.getShort());
        }
        return types;
    }",loop_control
j,"{
        ByteBuffer in = annotationSetRefListIn;
        in.position(parameter_annotation_offset);

        int size = in.getInt();
        for (int j = 0; j < size; j++) {
            int param_annotation_offset = in.getInt();
            if (param_annotation_offset == 0) {
                continue;
            }
            DexAnnotationAble dpav = dmv.visitParameterAnnotation(j);
            try {
                if (dpav != null) {
                    read_annotation_set_item(param_annotation_offset, dpav);
                }
            } catch (Exception e) {
                throw new DexException(e, ""While accepting parameter annotation in parameter: [%d]"", j);
            }
        }
    }",loop_control
q,"{
        Queue<Integer> q = new LinkedList<Integer>();
        q.add(0);
        q.addAll(handlers);
        handlers.clear();
        while (!q.isEmpty()) {
            int offset = q.poll();
            if (nextBit.get(offset)) {
                continue;
            } else {
                nextBit.set(offset);
            }
            try {
                travelInsn(labelsMap, q, insns, offset);
            } catch (IndexOutOfBoundsException indexOutOfRange){
                badOps.set(offset);
                WARN(""GLITCH: %04x %s | not enough space for reading instruction"", offset, method.toString());
            } catch (BadOpException badOp){
                badOps.set(offset);
                WARN(""GLITCH: %04x %s | %s"", offset, method.toString(), badOp.getMessage());
            }
        }
    }",maybe_loop_control
i,"{
        int u1offset = offset * 2;
        if (u1offset >= insns.length) {
            throw new IndexOutOfBoundsException();
        }
        int opcode = 0xFF & insns[u1offset];
        Op op = null;
        if (opcode < Op.ops.length) {
            op = Op.ops[opcode];
        }
        if (op == null || op.format == null) {
            throw new BadOpException(""zero-width instruction op=0x%02x"", opcode);
        }
        int target;
        boolean canContinue = true;
        if (op.canBranch()) {
            switch (op.format) {
            case kFmt10t:
                target = offset + insns[u1offset + 1];
                if (target < 0 || target * 2 > insns.length ) {
                    throw new BadOpException(""jump out of insns %s -> %04x"", op, target);
                }
                q.add(target);
                order(labelsMap, target);
                break;
            case kFmt20t:
            case kFmt21t:
                target = offset + sshort(insns, u1offset + 2);
                if (target < 0 || target * 2 > insns.length ) {
                    throw new BadOpException(""jump out of insns %s -> %04x"", op, target);
                }
                q.add(target);
                order(labelsMap, target);
                break;
            case kFmt22t:
                target = offset + sshort(insns, u1offset + 2);

                int u = ubyte(insns, u1offset + 1);
                boolean cmpSameReg = (u & 0x0F) == ((u >> 4) & 0x0F);
                boolean skipTarget = false;
                if (cmpSameReg) {
                    switch (op) {
                    case IF_EQ:
                    case IF_GE:
                    case IF_LE:
                        // means always jump, equals to goto
                        canContinue = false;
                        break;
                    case IF_NE:
                    case IF_GT:
                    case IF_LT:
                        // means always not jump
                        skipTarget = true;
                        break;
                    default:
                        break;
                    }
                }
                if (!skipTarget) {
                    if (target < 0 || target * 2 > insns.length ) {
                        throw new BadOpException(""jump out of insns %s -> %04x"", op, target);
                    }
                    q.add(target);
                    order(labelsMap, target);
                }
                break;
            case kFmt30t:
            case kFmt31t:
                target = offset + sint(insns, u1offset + 2);
                if (target < 0 || target * 2 > insns.length ) {
                    throw new BadOpException(""jump out of insns %s -> %04x"", op, target);
                }
                q.add(target);
                order(labelsMap, target);
                break;
            default:
                break;
            }
        }
        if (op.canSwitch()) {
            order(labelsMap, offset + op.format.size);// default
            int u1SwitchData = 2 * (offset + sint(insns, u1offset + 2));
            if (u1SwitchData + 2 < insns.length) {

                    switch (insns[u1SwitchData + 1]) {
                        case 0x01: // packed-switch-data
                        {
                            int size = ushort(insns, u1SwitchData + 2);
                            int b = u1SwitchData + 8;// targets
                            for (int i = 0; i < size; i++) {
                                target = offset + sint(insns, b + i * 4);
                                if (target < 0 || target * 2 > insns.length ) {
                                    throw new BadOpException(""jump out of insns %s -> %04x"", op, target);
                                }
                                q.add(target);
                                order(labelsMap, target);
                            }
                            break;
                        }
                        case 0x02:// sparse-switch-data
                        {
                            int size = ushort(insns, u1SwitchData + 2);
                            int b = u1SwitchData + 4 + 4 * size;// targets
                            for (int i = 0; i < size; i++) {
                                target = offset + sint(insns, b + i * 4);
                                if (target < 0 || target * 2 > insns.length ) {
                                    throw new BadOpException(""jump out of insns %s -> %04x"", op, target);
                                }
                                q.add(target);
                                order(labelsMap, target);
                            }
                            break;
                        }
                        default:
                            throw new BadOpException(""bad payload for %s"", op);
                    }
            } else {
                throw new BadOpException(""bad payload offset for %s"", op);
            }
        }

        if (canContinue) {
            int idx = Integer.MAX_VALUE;
            switch (op.indexType) {
            case kIndexStringRef:
                if (op.format == InstructionFormat.kFmt31c) {
                    idx = uint(insns, u1offset + 2);
                } else {// other
                    idx = ushort(insns, u1offset + 2);
                }
                canContinue = idx >= 0 && idx < string_ids_size;
                break;
            case kIndexTypeRef:
                idx = ushort(insns, u1offset + 2);
                canContinue = idx < type_ids_size;
                break;
            case kIndexMethodRef:
                idx = ushort(insns, u1offset + 2);
                canContinue = idx < method_ids_size;
                break;
            case kIndexFieldRef:
                idx = ushort(insns, u1offset + 2);
                canContinue = idx < field_ids_size;
                break;
            case kIndexCallSiteRef:
                idx = ushort(insns, u1offset + 2);
                canContinue = idx < call_site_ids_size;
                break;
            case kIndexMethodAndProtoRef:
                idx = ushort(insns, u1offset + 2);
                int idx2 = ushort(insns, u1offset + 6);
                canContinue = idx < method_ids_size && idx2 < proto_ids_size;
                break;
            default:
            }
            if (!canContinue) {
                throw new BadOpException(""index-out-of-range for %s index: %d"", op, idx);
            }
        }

        if (canContinue && op.canContinue()) {
            if (op == Op.NOP) {
                switch (insns[u1offset + 1]) {
                case 0x00:
                    q.add(offset + op.format.size);
                    break;
                case 0x01: {
                    int size = ushort(insns, u1offset + 2);
                    q.add(offset + (size * 2) + 4);
                    break;
                }
                case 0x02: {
                    int size = ushort(insns, u1offset + 2);
                    q.add(offset + (size * 4) + 2);
                    break;
                }
                case 0x03: {
                    int element_width = ushort(insns, u1offset + 2);
                    int size = uint(insns, u1offset + 4);
                    q.add(offset + (size * element_width + 1) / 2 + 4);
                    break;
                }
                }
            } else {
                q.add(offset + op.format.size);
            }
        }
    }",loop_control
i,"{
        int encoded_catch_handler_list = in.position() + tries_size * 8;
        ByteBuffer handlerIn = in.duplicate().order(ByteOrder.LITTLE_ENDIAN);
        for (int i = 0; i < tries_size; i++) { // try_item
            int start_addr = in.getInt();
            int insn_count = 0xFFFF & in.getShort();
            int handler_offset = 0xFFFF & in.getShort();
            if (start_addr > insn_size) {
                continue;
            }
            order(labelsMap, start_addr);
            int end = start_addr + insn_count;
            order(labelsMap, end);

            handlerIn.position(encoded_catch_handler_list + handler_offset);// move to encoded_catch_handler

            boolean catchAll = false;
            int listSize = (int) readLeb128i(handlerIn);
            int handlerCount = listSize;
            if (listSize <= 0) {
                listSize = -listSize;
                handlerCount = listSize + 1;
                catchAll = true;
            }
            DexLabel labels[] = new DexLabel[handlerCount];
            String types[] = new String[handlerCount];
            for (int k = 0; k < listSize; k++) {
                int type_id = (int) readULeb128i(handlerIn);
                int handler = (int) readULeb128i(handlerIn);
                order(labelsMap, handler);
                handlers.add(handler);
                types[k] = getType(type_id);
                labels[k] = labelsMap.get(handler);
            }
            if (catchAll) {
                int handler = (int) readULeb128i(handlerIn);
                order(labelsMap, handler);
                handlers.add(handler);
                labels[listSize] = labelsMap.get(handler);
            }
            dcv.visitTryCatch(labelsMap.get(start_addr), labelsMap.get(end), labels, types);
        }
    }",loop_control
k,"{
        int encoded_catch_handler_list = in.position() + tries_size * 8;
        ByteBuffer handlerIn = in.duplicate().order(ByteOrder.LITTLE_ENDIAN);
        for (int i = 0; i < tries_size; i++) { // try_item
            int start_addr = in.getInt();
            int insn_count = 0xFFFF & in.getShort();
            int handler_offset = 0xFFFF & in.getShort();
            if (start_addr > insn_size) {
                continue;
            }
            order(labelsMap, start_addr);
            int end = start_addr + insn_count;
            order(labelsMap, end);

            handlerIn.position(encoded_catch_handler_list + handler_offset);// move to encoded_catch_handler

            boolean catchAll = false;
            int listSize = (int) readLeb128i(handlerIn);
            int handlerCount = listSize;
            if (listSize <= 0) {
                listSize = -listSize;
                handlerCount = listSize + 1;
                catchAll = true;
            }
            DexLabel labels[] = new DexLabel[handlerCount];
            String types[] = new String[handlerCount];
            for (int k = 0; k < listSize; k++) {
                int type_id = (int) readULeb128i(handlerIn);
                int handler = (int) readULeb128i(handlerIn);
                order(labelsMap, handler);
                handlers.add(handler);
                types[k] = getType(type_id);
                labels[k] = labelsMap.get(handler);
            }
            if (catchAll) {
                int handler = (int) readULeb128i(handlerIn);
                order(labelsMap, handler);
                handlers.add(handler);
                labels[listSize] = labelsMap.get(handler);
            }
            dcv.visitTryCatch(labelsMap.get(start_addr), labelsMap.get(end), labels, types);
        }
    }",loop_control
nextLabelOffset,"{
        Iterator<Integer> labelOffsetIterator = labelsMap.keySet().iterator();
        Integer nextLabelOffset = labelOffsetIterator.hasNext() ? labelOffsetIterator.next() : null;
        Op[] values = Op.ops;
        for (int offset = nextInsn.nextSetBit(0); offset >= 0; offset = nextInsn.nextSetBit(offset + 1)) {
            // issue 65, a label may `inside` an instruction
            // visit all label with offset <= currentOffset
            while (nextLabelOffset != null) {
                if (nextLabelOffset <= offset) {
                    dcv.visitLabel(labelsMap.get(nextLabelOffset));
                    nextLabelOffset = labelOffsetIterator.hasNext() ? labelOffsetIterator.next() : null;
                } else {
                    // the label is after this instruction
                    break;
                }
            }

            if(badOps.get(offset)){
                dcv.visitStmt0R(Op.BAD_OP);
                continue;
            }

            int u1offset = offset * 2;
            int opcode = 0xFF & insns[u1offset];

            Op op = values[opcode];

            int a, b, c, target;
            switch (op.format) {
            // case kFmt00x: break;
            case kFmt10x:
                dcv.visitStmt0R(op);
                break;

            case kFmt11x:
                dcv.visitStmt1R(op, 0xFF & insns[u1offset + 1]);
                break;
            case kFmt12x:
                a = ubyte(insns, u1offset + 1);
                dcv.visitStmt2R(op, a & 0xF, a >> 4);
                break;
            // case kFmt20bc:break;
            case kFmt10t:
                target = offset + insns[u1offset + 1];
                dcv.visitJumpStmt(op, -1, -1, labelsMap.get(target));
                break;
            case kFmt20t:
                target = offset + sshort(insns, u1offset + 2);
                dcv.visitJumpStmt(op, -1, -1, labelsMap.get(target));
                break;
            case kFmt21t:
                target = offset + sshort(insns, u1offset + 2);
                dcv.visitJumpStmt(op, ubyte(insns, u1offset + 1), -1, labelsMap.get(target));
                break;
            case kFmt22t:
                target = offset + sshort(insns, u1offset + 2);
                a = ubyte(insns, u1offset + 1);
                b = a & 0x0F;
                c = a >> 4;
                boolean ignore = false;
                if (b == c) {
                    switch (op) {
                    case IF_EQ:
                    case IF_GE:
                    case IF_LE:
                        // means always jump, equals to goto
                        dcv.visitJumpStmt(Op.GOTO, 0, 0, labelsMap.get(target));
                        ignore = true;
                        break;
                    case IF_NE:
                    case IF_GT:
                    case IF_LT:
                        // means always not jump
                        ignore = true;
                        break;
                    default:
                        break;
                    }
                }
                if (!ignore) {
                    dcv.visitJumpStmt(op, b, c, labelsMap.get(target));
                }
                break;
            case kFmt30t:
                target = offset + sint(insns, u1offset + 2);
                dcv.visitJumpStmt(op, -1, -1, labelsMap.get(target));
                break;
            case kFmt31t:
                target = offset + sint(insns, u1offset + 2);
                a = ubyte(insns, u1offset + 1);
                int u1SwitchData = 2 * target;
                if (op == Op.FILL_ARRAY_DATA) {
                    int element_width = ushort(insns, u1SwitchData + 2);
                    int size = uint(insns, u1SwitchData + 4);
                    switch (element_width) {
                    case 1: {
                        byte[] data = new byte[size];
                        System.arraycopy(insns, u1SwitchData + 8, data, 0, size);
                        dcv.visitFillArrayDataStmt(op, a, data);
                    }
                        break;
                    case 2: {
                        short[] data = new short[size];
                        for (int i = 0; i < size; i++) {
                            data[i] = (short) sshort(insns, u1SwitchData + 8 + 2 * i);
                        }
                        dcv.visitFillArrayDataStmt(op, a, data);
                    }
                        break;
                    case 4: {
                        int[] data = new int[size];
                        for (int i = 0; i < size; i++) {
                            data[i] = sint(insns, u1SwitchData + 8 + 4 * i);
                        }
                        dcv.visitFillArrayDataStmt(op, a, data);
                    }
                        break;
                    case 8: {
                        long[] data = new long[size];
                        for (int i = 0; i < size; i++) {
                            int t = u1SwitchData + 8 + 8 * i;
                            long z = 0;
                            z |= ((long) ushort(insns, t + 0)) << 0;
                            z |= ((long) ushort(insns, t + 2)) << 16;
                            z |= ((long) ushort(insns, t + 4)) << 32;
                            z |= ((long) ushort(insns, t + 6)) << 48;
                            data[i] = z;
                        }
                        dcv.visitFillArrayDataStmt(op, a, data);
                    }
                        break;
                    }
                } else if (op == Op.SPARSE_SWITCH) {
                    int size = sshort(insns, u1SwitchData + 2);
                    int keys[] = new int[size];
                    DexLabel labels[] = new DexLabel[size];
                    int z = u1SwitchData + 4;
                    for (int i = 0; i < size; i++) {
                        keys[i] = sint(insns, z + i * 4);
                    }
                    z += size * 4;
                    for (int i = 0; i < size; i++) {
                        labels[i] = labelsMap.get(offset + sint(insns, z + i * 4));
                    }
                    dcv.visitSparseSwitchStmt(op, a, keys, labels);
                } else {
                    int size = sshort(insns, u1SwitchData + 2);
                    int first_key = sint(insns, u1SwitchData + 4);
                    DexLabel labels[] = new DexLabel[size];
                    int z = u1SwitchData + 8;
                    for (int i = 0; i < size; i++) {
                        labels[i] = labelsMap.get(offset + sint(insns, z));
                        z += 4;
                    }
                    dcv.visitPackedSwitchStmt(op, a, first_key, labels);
                }
                break;
            case kFmt21c:
                a = ubyte(insns, u1offset + 1);
                b = ushort(insns, u1offset + 2);
                switch (op.indexType) {
                case kIndexStringRef:
                    dcv.visitConstStmt(op, a, getString(b));
                    break;
                case kIndexFieldRef:
                    dcv.visitFieldStmt(op, a, -1, getField(b));
                    break;
                case kIndexTypeRef:
                    if (op == Op.CONST_CLASS) {
                        dcv.visitConstStmt(op, a, new DexType(getType(b)));
                    } else {
                        dcv.visitTypeStmt(op, a, -1, getType(b));
                    }
                    break;
                default:
                    break;
                }
                break;
            case kFmt22c:
                a = ubyte(insns, u1offset + 1);
                b = ushort(insns, u1offset + 2);
                switch (op.indexType) {
                case kIndexFieldRef:
                    dcv.visitFieldStmt(op, a & 0xF, a >> 4, getField(b));
                    break;
                case kIndexTypeRef:
                    dcv.visitTypeStmt(op, a & 0xF, a >> 4, getType(b));
                    break;
                default:
                    break;
                }
                break;
            case kFmt31c:
                if (op.indexType == InstructionIndexType.kIndexStringRef) {
                    a = ubyte(insns, u1offset + 1);
                    b = uint(insns, u1offset + 2);
                    dcv.visitConstStmt(op, a, getString(b));
                }
                break;
            case kFmt35c: {
                a = ubyte(insns, u1offset + 1);
                b = ushort(insns, u1offset + 2);
                int dc = ubyte(insns, u1offset + 4); // DC
                int fe = ubyte(insns, u1offset + 5); // FE

                int regs[] = new int[a >> 4];
                switch (a >> 4) {
                case 5:
                    regs[4] = a & 0xF;// G
                case 4:
                    regs[3] = 0xF & (fe >> 4);// F
                case 3:
                    regs[2] = 0xF & (fe >> 0);// E
                case 2:
                    regs[1] = 0xF & (dc >> 4);// D
                case 1:
                    regs[0] = 0xF & (dc >> 0);// C
                }
                if (op.indexType == InstructionIndexType.kIndexTypeRef) {
                    dcv.visitFilledNewArrayStmt(op, regs, getType(b));
                } else if (op.indexType == InstructionIndexType.kIndexCallSiteRef) {
                    Object[] callsite = getCallSite(b);
                    Object[] constArgs = Arrays.copyOfRange(callsite, 3, callsite.length);
                    dcv.visitMethodStmt(op, regs, (String) callsite[1], (Proto) callsite[2], (MethodHandle) callsite[0], constArgs);
                } else {
                    dcv.visitMethodStmt(op, regs, getMethod(b));
                }
            }
                break;
            case kFmt3rc: {
                a = ubyte(insns, u1offset + 1);
                b = ushort(insns, u1offset + 2);
                c = ushort(insns, u1offset + 4);
                int regs[] = new int[a];
                for (int i = 0; i < a; i++) {
                    regs[i] = c + i;
                }
                if (op.indexType == InstructionIndexType.kIndexTypeRef) {
                    dcv.visitFilledNewArrayStmt(op, regs, getType(b));
                } else if (op.indexType == InstructionIndexType.kIndexCallSiteRef) {
                    Object[] callsite = getCallSite(b);
                    Object[] constArgs = Arrays.copyOfRange(callsite, 3, callsite.length - 3);
                    dcv.visitMethodStmt(op, regs, (String) callsite[1], (Proto) callsite[2], (MethodHandle) callsite[0], constArgs);
                } else {
                    dcv.visitMethodStmt(op, regs, getMethod(b));
                }
            }
                break;
            case kFmt45cc: {
                a = ubyte(insns, u1offset + 1);
                b = ushort(insns, u1offset + 2);
                int dc = ubyte(insns, u1offset + 4); // DC
                int fe = ubyte(insns, u1offset + 5); // FE
                int h = ushort(insns, u1offset + 6);

                int regs[] = new int[a >> 4];
                switch (a >> 4) {
                case 5:
                    regs[4] = a & 0xF;// G
                case 4:
                    regs[3] = 0xF & (fe >> 4);// F
                case 3:
                    regs[2] = 0xF & (fe >> 0);// E
                case 2:
                    regs[1] = 0xF & (dc >> 4);// D
                case 1:
                    regs[0] = 0xF & (dc >> 0);// C
                }
                dcv.visitMethodStmt(op, regs, getMethod(b), getProto(h));
            }
            break;
            case kFmt4rcc: {
                a = ubyte(insns, u1offset + 1);
                b = ushort(insns, u1offset + 2);
                c = ushort(insns, u1offset + 4);
                int h = ushort(insns, u1offset + 6);
                int regs[] = new int[a];
                for (int i = 0; i < a; i++) {
                    regs[i] = c + i;
                }
                dcv.visitMethodStmt(op, regs, getMethod(b), getProto(h));
            }
            break;
            case kFmt22x:
                a = ubyte(insns, u1offset + 1);
                b = ushort(insns, u1offset + 2);
                dcv.visitStmt2R(op, a, b);
                break;
            case kFmt23x:
                a = ubyte(insns, u1offset + 1);
                b = ubyte(insns, u1offset + 2);
                c = ubyte(insns, u1offset + 3);
                dcv.visitStmt3R(op, a, b, c);
                break;
            case kFmt32x:
                a = ushort(insns, u1offset + 2);
                b = ushort(insns, u1offset + 4);
                dcv.visitStmt2R(op, a, b);
                break;
            case kFmt11n:
                a = insns[u1offset + 1];
                dcv.visitConstStmt(op, a & 0xF, a >> 4);
                break;
            case kFmt21h:
                a = ubyte(insns, u1offset + 1);
                b = sshort(insns, u1offset + 2);
                if (op == Op.CONST_HIGH16) {
                    dcv.visitConstStmt(op, a, b << 16);
                } else {
                    dcv.visitConstStmt(op, a, ((long) b) << 48);
                }
                break;
            case kFmt21s:
                a = ubyte(insns, u1offset + 1);
                b = sshort(insns, u1offset + 2);
                if (op == Op.CONST_16) {
                    dcv.visitConstStmt(op, a, b);
                } else {
                    dcv.visitConstStmt(op, a, (long) b);
                }
                break;
            case kFmt22b:
                a = ubyte(insns, u1offset + 1);
                b = ubyte(insns, u1offset + 2);
                c = sbyte(insns, u1offset + 3);
                dcv.visitStmt2R1N(op, a, b, c);
                break;
            case kFmt22s:
                a = ubyte(insns, u1offset + 1);
                b = sshort(insns, u1offset + 2);
                dcv.visitStmt2R1N(op, a & 0xF, a >> 4, b);
                break;
            // case kFmt22cs:break;
            case kFmt31i:
                a = ubyte(insns, u1offset + 1);
                b = sint(insns, u1offset + 2);
                if (op == Op.CONST) {
                    dcv.visitConstStmt(op, a, b);
                } else {
                    dcv.visitConstStmt(op, a, (long) b);
                }
                break;
            case kFmt51l:
                a = ubyte(insns, u1offset + 1);
                long z = 0;
                z |= ((long) ushort(insns, u1offset + 2)) << 0;
                z |= ((long) ushort(insns, u1offset + 4)) << 16;
                z |= ((long) ushort(insns, u1offset + 6)) << 32;
                z |= ((long) ushort(insns, u1offset + 8)) << 48;
                dcv.visitConstStmt(op, a, z);
                break;
            }
        }

        while (nextLabelOffset != null) {
            dcv.visitLabel(labelsMap.get(nextLabelOffset));
            if (labelOffsetIterator.hasNext()) {
                nextLabelOffset = labelOffsetIterator.next();
            } else {
                break;
            }
        }
    }",maybe_loop_control
nextLabelOffset,"{
        Iterator<Integer> labelOffsetIterator = labelsMap.keySet().iterator();
        Integer nextLabelOffset = labelOffsetIterator.hasNext() ? labelOffsetIterator.next() : null;
        Op[] values = Op.ops;
        for (int offset = nextInsn.nextSetBit(0); offset >= 0; offset = nextInsn.nextSetBit(offset + 1)) {
            // issue 65, a label may `inside` an instruction
            // visit all label with offset <= currentOffset
            while (nextLabelOffset != null) {
                if (nextLabelOffset <= offset) {
                    dcv.visitLabel(labelsMap.get(nextLabelOffset));
                    nextLabelOffset = labelOffsetIterator.hasNext() ? labelOffsetIterator.next() : null;
                } else {
                    // the label is after this instruction
                    break;
                }
            }

            if(badOps.get(offset)){
                dcv.visitStmt0R(Op.BAD_OP);
                continue;
            }

            int u1offset = offset * 2;
            int opcode = 0xFF & insns[u1offset];

            Op op = values[opcode];

            int a, b, c, target;
            switch (op.format) {
            // case kFmt00x: break;
            case kFmt10x:
                dcv.visitStmt0R(op);
                break;

            case kFmt11x:
                dcv.visitStmt1R(op, 0xFF & insns[u1offset + 1]);
                break;
            case kFmt12x:
                a = ubyte(insns, u1offset + 1);
                dcv.visitStmt2R(op, a & 0xF, a >> 4);
                break;
            // case kFmt20bc:break;
            case kFmt10t:
                target = offset + insns[u1offset + 1];
                dcv.visitJumpStmt(op, -1, -1, labelsMap.get(target));
                break;
            case kFmt20t:
                target = offset + sshort(insns, u1offset + 2);
                dcv.visitJumpStmt(op, -1, -1, labelsMap.get(target));
                break;
            case kFmt21t:
                target = offset + sshort(insns, u1offset + 2);
                dcv.visitJumpStmt(op, ubyte(insns, u1offset + 1), -1, labelsMap.get(target));
                break;
            case kFmt22t:
                target = offset + sshort(insns, u1offset + 2);
                a = ubyte(insns, u1offset + 1);
                b = a & 0x0F;
                c = a >> 4;
                boolean ignore = false;
                if (b == c) {
                    switch (op) {
                    case IF_EQ:
                    case IF_GE:
                    case IF_LE:
                        // means always jump, equals to goto
                        dcv.visitJumpStmt(Op.GOTO, 0, 0, labelsMap.get(target));
                        ignore = true;
                        break;
                    case IF_NE:
                    case IF_GT:
                    case IF_LT:
                        // means always not jump
                        ignore = true;
                        break;
                    default:
                        break;
                    }
                }
                if (!ignore) {
                    dcv.visitJumpStmt(op, b, c, labelsMap.get(target));
                }
                break;
            case kFmt30t:
                target = offset + sint(insns, u1offset + 2);
                dcv.visitJumpStmt(op, -1, -1, labelsMap.get(target));
                break;
            case kFmt31t:
                target = offset + sint(insns, u1offset + 2);
                a = ubyte(insns, u1offset + 1);
                int u1SwitchData = 2 * target;
                if (op == Op.FILL_ARRAY_DATA) {
                    int element_width = ushort(insns, u1SwitchData + 2);
                    int size = uint(insns, u1SwitchData + 4);
                    switch (element_width) {
                    case 1: {
                        byte[] data = new byte[size];
                        System.arraycopy(insns, u1SwitchData + 8, data, 0, size);
                        dcv.visitFillArrayDataStmt(op, a, data);
                    }
                        break;
                    case 2: {
                        short[] data = new short[size];
                        for (int i = 0; i < size; i++) {
                            data[i] = (short) sshort(insns, u1SwitchData + 8 + 2 * i);
                        }
                        dcv.visitFillArrayDataStmt(op, a, data);
                    }
                        break;
                    case 4: {
                        int[] data = new int[size];
                        for (int i = 0; i < size; i++) {
                            data[i] = sint(insns, u1SwitchData + 8 + 4 * i);
                        }
                        dcv.visitFillArrayDataStmt(op, a, data);
                    }
                        break;
                    case 8: {
                        long[] data = new long[size];
                        for (int i = 0; i < size; i++) {
                            int t = u1SwitchData + 8 + 8 * i;
                            long z = 0;
                            z |= ((long) ushort(insns, t + 0)) << 0;
                            z |= ((long) ushort(insns, t + 2)) << 16;
                            z |= ((long) ushort(insns, t + 4)) << 32;
                            z |= ((long) ushort(insns, t + 6)) << 48;
                            data[i] = z;
                        }
                        dcv.visitFillArrayDataStmt(op, a, data);
                    }
                        break;
                    }
                } else if (op == Op.SPARSE_SWITCH) {
                    int size = sshort(insns, u1SwitchData + 2);
                    int keys[] = new int[size];
                    DexLabel labels[] = new DexLabel[size];
                    int z = u1SwitchData + 4;
                    for (int i = 0; i < size; i++) {
                        keys[i] = sint(insns, z + i * 4);
                    }
                    z += size * 4;
                    for (int i = 0; i < size; i++) {
                        labels[i] = labelsMap.get(offset + sint(insns, z + i * 4));
                    }
                    dcv.visitSparseSwitchStmt(op, a, keys, labels);
                } else {
                    int size = sshort(insns, u1SwitchData + 2);
                    int first_key = sint(insns, u1SwitchData + 4);
                    DexLabel labels[] = new DexLabel[size];
                    int z = u1SwitchData + 8;
                    for (int i = 0; i < size; i++) {
                        labels[i] = labelsMap.get(offset + sint(insns, z));
                        z += 4;
                    }
                    dcv.visitPackedSwitchStmt(op, a, first_key, labels);
                }
                break;
            case kFmt21c:
                a = ubyte(insns, u1offset + 1);
                b = ushort(insns, u1offset + 2);
                switch (op.indexType) {
                case kIndexStringRef:
                    dcv.visitConstStmt(op, a, getString(b));
                    break;
                case kIndexFieldRef:
                    dcv.visitFieldStmt(op, a, -1, getField(b));
                    break;
                case kIndexTypeRef:
                    if (op == Op.CONST_CLASS) {
                        dcv.visitConstStmt(op, a, new DexType(getType(b)));
                    } else {
                        dcv.visitTypeStmt(op, a, -1, getType(b));
                    }
                    break;
                default:
                    break;
                }
                break;
            case kFmt22c:
                a = ubyte(insns, u1offset + 1);
                b = ushort(insns, u1offset + 2);
                switch (op.indexType) {
                case kIndexFieldRef:
                    dcv.visitFieldStmt(op, a & 0xF, a >> 4, getField(b));
                    break;
                case kIndexTypeRef:
                    dcv.visitTypeStmt(op, a & 0xF, a >> 4, getType(b));
                    break;
                default:
                    break;
                }
                break;
            case kFmt31c:
                if (op.indexType == InstructionIndexType.kIndexStringRef) {
                    a = ubyte(insns, u1offset + 1);
                    b = uint(insns, u1offset + 2);
                    dcv.visitConstStmt(op, a, getString(b));
                }
                break;
            case kFmt35c: {
                a = ubyte(insns, u1offset + 1);
                b = ushort(insns, u1offset + 2);
                int dc = ubyte(insns, u1offset + 4); // DC
                int fe = ubyte(insns, u1offset + 5); // FE

                int regs[] = new int[a >> 4];
                switch (a >> 4) {
                case 5:
                    regs[4] = a & 0xF;// G
                case 4:
                    regs[3] = 0xF & (fe >> 4);// F
                case 3:
                    regs[2] = 0xF & (fe >> 0);// E
                case 2:
                    regs[1] = 0xF & (dc >> 4);// D
                case 1:
                    regs[0] = 0xF & (dc >> 0);// C
                }
                if (op.indexType == InstructionIndexType.kIndexTypeRef) {
                    dcv.visitFilledNewArrayStmt(op, regs, getType(b));
                } else if (op.indexType == InstructionIndexType.kIndexCallSiteRef) {
                    Object[] callsite = getCallSite(b);
                    Object[] constArgs = Arrays.copyOfRange(callsite, 3, callsite.length);
                    dcv.visitMethodStmt(op, regs, (String) callsite[1], (Proto) callsite[2], (MethodHandle) callsite[0], constArgs);
                } else {
                    dcv.visitMethodStmt(op, regs, getMethod(b));
                }
            }
                break;
            case kFmt3rc: {
                a = ubyte(insns, u1offset + 1);
                b = ushort(insns, u1offset + 2);
                c = ushort(insns, u1offset + 4);
                int regs[] = new int[a];
                for (int i = 0; i < a; i++) {
                    regs[i] = c + i;
                }
                if (op.indexType == InstructionIndexType.kIndexTypeRef) {
                    dcv.visitFilledNewArrayStmt(op, regs, getType(b));
                } else if (op.indexType == InstructionIndexType.kIndexCallSiteRef) {
                    Object[] callsite = getCallSite(b);
                    Object[] constArgs = Arrays.copyOfRange(callsite, 3, callsite.length - 3);
                    dcv.visitMethodStmt(op, regs, (String) callsite[1], (Proto) callsite[2], (MethodHandle) callsite[0], constArgs);
                } else {
                    dcv.visitMethodStmt(op, regs, getMethod(b));
                }
            }
                break;
            case kFmt45cc: {
                a = ubyte(insns, u1offset + 1);
                b = ushort(insns, u1offset + 2);
                int dc = ubyte(insns, u1offset + 4); // DC
                int fe = ubyte(insns, u1offset + 5); // FE
                int h = ushort(insns, u1offset + 6);

                int regs[] = new int[a >> 4];
                switch (a >> 4) {
                case 5:
                    regs[4] = a & 0xF;// G
                case 4:
                    regs[3] = 0xF & (fe >> 4);// F
                case 3:
                    regs[2] = 0xF & (fe >> 0);// E
                case 2:
                    regs[1] = 0xF & (dc >> 4);// D
                case 1:
                    regs[0] = 0xF & (dc >> 0);// C
                }
                dcv.visitMethodStmt(op, regs, getMethod(b), getProto(h));
            }
            break;
            case kFmt4rcc: {
                a = ubyte(insns, u1offset + 1);
                b = ushort(insns, u1offset + 2);
                c = ushort(insns, u1offset + 4);
                int h = ushort(insns, u1offset + 6);
                int regs[] = new int[a];
                for (int i = 0; i < a; i++) {
                    regs[i] = c + i;
                }
                dcv.visitMethodStmt(op, regs, getMethod(b), getProto(h));
            }
            break;
            case kFmt22x:
                a = ubyte(insns, u1offset + 1);
                b = ushort(insns, u1offset + 2);
                dcv.visitStmt2R(op, a, b);
                break;
            case kFmt23x:
                a = ubyte(insns, u1offset + 1);
                b = ubyte(insns, u1offset + 2);
                c = ubyte(insns, u1offset + 3);
                dcv.visitStmt3R(op, a, b, c);
                break;
            case kFmt32x:
                a = ushort(insns, u1offset + 2);
                b = ushort(insns, u1offset + 4);
                dcv.visitStmt2R(op, a, b);
                break;
            case kFmt11n:
                a = insns[u1offset + 1];
                dcv.visitConstStmt(op, a & 0xF, a >> 4);
                break;
            case kFmt21h:
                a = ubyte(insns, u1offset + 1);
                b = sshort(insns, u1offset + 2);
                if (op == Op.CONST_HIGH16) {
                    dcv.visitConstStmt(op, a, b << 16);
                } else {
                    dcv.visitConstStmt(op, a, ((long) b) << 48);
                }
                break;
            case kFmt21s:
                a = ubyte(insns, u1offset + 1);
                b = sshort(insns, u1offset + 2);
                if (op == Op.CONST_16) {
                    dcv.visitConstStmt(op, a, b);
                } else {
                    dcv.visitConstStmt(op, a, (long) b);
                }
                break;
            case kFmt22b:
                a = ubyte(insns, u1offset + 1);
                b = ubyte(insns, u1offset + 2);
                c = sbyte(insns, u1offset + 3);
                dcv.visitStmt2R1N(op, a, b, c);
                break;
            case kFmt22s:
                a = ubyte(insns, u1offset + 1);
                b = sshort(insns, u1offset + 2);
                dcv.visitStmt2R1N(op, a & 0xF, a >> 4, b);
                break;
            // case kFmt22cs:break;
            case kFmt31i:
                a = ubyte(insns, u1offset + 1);
                b = sint(insns, u1offset + 2);
                if (op == Op.CONST) {
                    dcv.visitConstStmt(op, a, b);
                } else {
                    dcv.visitConstStmt(op, a, (long) b);
                }
                break;
            case kFmt51l:
                a = ubyte(insns, u1offset + 1);
                long z = 0;
                z |= ((long) ushort(insns, u1offset + 2)) << 0;
                z |= ((long) ushort(insns, u1offset + 4)) << 16;
                z |= ((long) ushort(insns, u1offset + 6)) << 32;
                z |= ((long) ushort(insns, u1offset + 8)) << 48;
                dcv.visitConstStmt(op, a, z);
                break;
            }
        }

        while (nextLabelOffset != null) {
            dcv.visitLabel(labelsMap.get(nextLabelOffset));
            if (labelOffsetIterator.hasNext()) {
                nextLabelOffset = labelOffsetIterator.next();
            } else {
                break;
            }
        }
    }",break_loop_control
i,"{
        Iterator<Integer> labelOffsetIterator = labelsMap.keySet().iterator();
        Integer nextLabelOffset = labelOffsetIterator.hasNext() ? labelOffsetIterator.next() : null;
        Op[] values = Op.ops;
        for (int offset = nextInsn.nextSetBit(0); offset >= 0; offset = nextInsn.nextSetBit(offset + 1)) {
            // issue 65, a label may `inside` an instruction
            // visit all label with offset <= currentOffset
            while (nextLabelOffset != null) {
                if (nextLabelOffset <= offset) {
                    dcv.visitLabel(labelsMap.get(nextLabelOffset));
                    nextLabelOffset = labelOffsetIterator.hasNext() ? labelOffsetIterator.next() : null;
                } else {
                    // the label is after this instruction
                    break;
                }
            }

            if(badOps.get(offset)){
                dcv.visitStmt0R(Op.BAD_OP);
                continue;
            }

            int u1offset = offset * 2;
            int opcode = 0xFF & insns[u1offset];

            Op op = values[opcode];

            int a, b, c, target;
            switch (op.format) {
            // case kFmt00x: break;
            case kFmt10x:
                dcv.visitStmt0R(op);
                break;

            case kFmt11x:
                dcv.visitStmt1R(op, 0xFF & insns[u1offset + 1]);
                break;
            case kFmt12x:
                a = ubyte(insns, u1offset + 1);
                dcv.visitStmt2R(op, a & 0xF, a >> 4);
                break;
            // case kFmt20bc:break;
            case kFmt10t:
                target = offset + insns[u1offset + 1];
                dcv.visitJumpStmt(op, -1, -1, labelsMap.get(target));
                break;
            case kFmt20t:
                target = offset + sshort(insns, u1offset + 2);
                dcv.visitJumpStmt(op, -1, -1, labelsMap.get(target));
                break;
            case kFmt21t:
                target = offset + sshort(insns, u1offset + 2);
                dcv.visitJumpStmt(op, ubyte(insns, u1offset + 1), -1, labelsMap.get(target));
                break;
            case kFmt22t:
                target = offset + sshort(insns, u1offset + 2);
                a = ubyte(insns, u1offset + 1);
                b = a & 0x0F;
                c = a >> 4;
                boolean ignore = false;
                if (b == c) {
                    switch (op) {
                    case IF_EQ:
                    case IF_GE:
                    case IF_LE:
                        // means always jump, equals to goto
                        dcv.visitJumpStmt(Op.GOTO, 0, 0, labelsMap.get(target));
                        ignore = true;
                        break;
                    case IF_NE:
                    case IF_GT:
                    case IF_LT:
                        // means always not jump
                        ignore = true;
                        break;
                    default:
                        break;
                    }
                }
                if (!ignore) {
                    dcv.visitJumpStmt(op, b, c, labelsMap.get(target));
                }
                break;
            case kFmt30t:
                target = offset + sint(insns, u1offset + 2);
                dcv.visitJumpStmt(op, -1, -1, labelsMap.get(target));
                break;
            case kFmt31t:
                target = offset + sint(insns, u1offset + 2);
                a = ubyte(insns, u1offset + 1);
                int u1SwitchData = 2 * target;
                if (op == Op.FILL_ARRAY_DATA) {
                    int element_width = ushort(insns, u1SwitchData + 2);
                    int size = uint(insns, u1SwitchData + 4);
                    switch (element_width) {
                    case 1: {
                        byte[] data = new byte[size];
                        System.arraycopy(insns, u1SwitchData + 8, data, 0, size);
                        dcv.visitFillArrayDataStmt(op, a, data);
                    }
                        break;
                    case 2: {
                        short[] data = new short[size];
                        for (int i = 0; i < size; i++) {
                            data[i] = (short) sshort(insns, u1SwitchData + 8 + 2 * i);
                        }
                        dcv.visitFillArrayDataStmt(op, a, data);
                    }
                        break;
                    case 4: {
                        int[] data = new int[size];
                        for (int i = 0; i < size; i++) {
                            data[i] = sint(insns, u1SwitchData + 8 + 4 * i);
                        }
                        dcv.visitFillArrayDataStmt(op, a, data);
                    }
                        break;
                    case 8: {
                        long[] data = new long[size];
                        for (int i = 0; i < size; i++) {
                            int t = u1SwitchData + 8 + 8 * i;
                            long z = 0;
                            z |= ((long) ushort(insns, t + 0)) << 0;
                            z |= ((long) ushort(insns, t + 2)) << 16;
                            z |= ((long) ushort(insns, t + 4)) << 32;
                            z |= ((long) ushort(insns, t + 6)) << 48;
                            data[i] = z;
                        }
                        dcv.visitFillArrayDataStmt(op, a, data);
                    }
                        break;
                    }
                } else if (op == Op.SPARSE_SWITCH) {
                    int size = sshort(insns, u1SwitchData + 2);
                    int keys[] = new int[size];
                    DexLabel labels[] = new DexLabel[size];
                    int z = u1SwitchData + 4;
                    for (int i = 0; i < size; i++) {
                        keys[i] = sint(insns, z + i * 4);
                    }
                    z += size * 4;
                    for (int i = 0; i < size; i++) {
                        labels[i] = labelsMap.get(offset + sint(insns, z + i * 4));
                    }
                    dcv.visitSparseSwitchStmt(op, a, keys, labels);
                } else {
                    int size = sshort(insns, u1SwitchData + 2);
                    int first_key = sint(insns, u1SwitchData + 4);
                    DexLabel labels[] = new DexLabel[size];
                    int z = u1SwitchData + 8;
                    for (int i = 0; i < size; i++) {
                        labels[i] = labelsMap.get(offset + sint(insns, z));
                        z += 4;
                    }
                    dcv.visitPackedSwitchStmt(op, a, first_key, labels);
                }
                break;
            case kFmt21c:
                a = ubyte(insns, u1offset + 1);
                b = ushort(insns, u1offset + 2);
                switch (op.indexType) {
                case kIndexStringRef:
                    dcv.visitConstStmt(op, a, getString(b));
                    break;
                case kIndexFieldRef:
                    dcv.visitFieldStmt(op, a, -1, getField(b));
                    break;
                case kIndexTypeRef:
                    if (op == Op.CONST_CLASS) {
                        dcv.visitConstStmt(op, a, new DexType(getType(b)));
                    } else {
                        dcv.visitTypeStmt(op, a, -1, getType(b));
                    }
                    break;
                default:
                    break;
                }
                break;
            case kFmt22c:
                a = ubyte(insns, u1offset + 1);
                b = ushort(insns, u1offset + 2);
                switch (op.indexType) {
                case kIndexFieldRef:
                    dcv.visitFieldStmt(op, a & 0xF, a >> 4, getField(b));
                    break;
                case kIndexTypeRef:
                    dcv.visitTypeStmt(op, a & 0xF, a >> 4, getType(b));
                    break;
                default:
                    break;
                }
                break;
            case kFmt31c:
                if (op.indexType == InstructionIndexType.kIndexStringRef) {
                    a = ubyte(insns, u1offset + 1);
                    b = uint(insns, u1offset + 2);
                    dcv.visitConstStmt(op, a, getString(b));
                }
                break;
            case kFmt35c: {
                a = ubyte(insns, u1offset + 1);
                b = ushort(insns, u1offset + 2);
                int dc = ubyte(insns, u1offset + 4); // DC
                int fe = ubyte(insns, u1offset + 5); // FE

                int regs[] = new int[a >> 4];
                switch (a >> 4) {
                case 5:
                    regs[4] = a & 0xF;// G
                case 4:
                    regs[3] = 0xF & (fe >> 4);// F
                case 3:
                    regs[2] = 0xF & (fe >> 0);// E
                case 2:
                    regs[1] = 0xF & (dc >> 4);// D
                case 1:
                    regs[0] = 0xF & (dc >> 0);// C
                }
                if (op.indexType == InstructionIndexType.kIndexTypeRef) {
                    dcv.visitFilledNewArrayStmt(op, regs, getType(b));
                } else if (op.indexType == InstructionIndexType.kIndexCallSiteRef) {
                    Object[] callsite = getCallSite(b);
                    Object[] constArgs = Arrays.copyOfRange(callsite, 3, callsite.length);
                    dcv.visitMethodStmt(op, regs, (String) callsite[1], (Proto) callsite[2], (MethodHandle) callsite[0], constArgs);
                } else {
                    dcv.visitMethodStmt(op, regs, getMethod(b));
                }
            }
                break;
            case kFmt3rc: {
                a = ubyte(insns, u1offset + 1);
                b = ushort(insns, u1offset + 2);
                c = ushort(insns, u1offset + 4);
                int regs[] = new int[a];
                for (int i = 0; i < a; i++) {
                    regs[i] = c + i;
                }
                if (op.indexType == InstructionIndexType.kIndexTypeRef) {
                    dcv.visitFilledNewArrayStmt(op, regs, getType(b));
                } else if (op.indexType == InstructionIndexType.kIndexCallSiteRef) {
                    Object[] callsite = getCallSite(b);
                    Object[] constArgs = Arrays.copyOfRange(callsite, 3, callsite.length - 3);
                    dcv.visitMethodStmt(op, regs, (String) callsite[1], (Proto) callsite[2], (MethodHandle) callsite[0], constArgs);
                } else {
                    dcv.visitMethodStmt(op, regs, getMethod(b));
                }
            }
                break;
            case kFmt45cc: {
                a = ubyte(insns, u1offset + 1);
                b = ushort(insns, u1offset + 2);
                int dc = ubyte(insns, u1offset + 4); // DC
                int fe = ubyte(insns, u1offset + 5); // FE
                int h = ushort(insns, u1offset + 6);

                int regs[] = new int[a >> 4];
                switch (a >> 4) {
                case 5:
                    regs[4] = a & 0xF;// G
                case 4:
                    regs[3] = 0xF & (fe >> 4);// F
                case 3:
                    regs[2] = 0xF & (fe >> 0);// E
                case 2:
                    regs[1] = 0xF & (dc >> 4);// D
                case 1:
                    regs[0] = 0xF & (dc >> 0);// C
                }
                dcv.visitMethodStmt(op, regs, getMethod(b), getProto(h));
            }
            break;
            case kFmt4rcc: {
                a = ubyte(insns, u1offset + 1);
                b = ushort(insns, u1offset + 2);
                c = ushort(insns, u1offset + 4);
                int h = ushort(insns, u1offset + 6);
                int regs[] = new int[a];
                for (int i = 0; i < a; i++) {
                    regs[i] = c + i;
                }
                dcv.visitMethodStmt(op, regs, getMethod(b), getProto(h));
            }
            break;
            case kFmt22x:
                a = ubyte(insns, u1offset + 1);
                b = ushort(insns, u1offset + 2);
                dcv.visitStmt2R(op, a, b);
                break;
            case kFmt23x:
                a = ubyte(insns, u1offset + 1);
                b = ubyte(insns, u1offset + 2);
                c = ubyte(insns, u1offset + 3);
                dcv.visitStmt3R(op, a, b, c);
                break;
            case kFmt32x:
                a = ushort(insns, u1offset + 2);
                b = ushort(insns, u1offset + 4);
                dcv.visitStmt2R(op, a, b);
                break;
            case kFmt11n:
                a = insns[u1offset + 1];
                dcv.visitConstStmt(op, a & 0xF, a >> 4);
                break;
            case kFmt21h:
                a = ubyte(insns, u1offset + 1);
                b = sshort(insns, u1offset + 2);
                if (op == Op.CONST_HIGH16) {
                    dcv.visitConstStmt(op, a, b << 16);
                } else {
                    dcv.visitConstStmt(op, a, ((long) b) << 48);
                }
                break;
            case kFmt21s:
                a = ubyte(insns, u1offset + 1);
                b = sshort(insns, u1offset + 2);
                if (op == Op.CONST_16) {
                    dcv.visitConstStmt(op, a, b);
                } else {
                    dcv.visitConstStmt(op, a, (long) b);
                }
                break;
            case kFmt22b:
                a = ubyte(insns, u1offset + 1);
                b = ubyte(insns, u1offset + 2);
                c = sbyte(insns, u1offset + 3);
                dcv.visitStmt2R1N(op, a, b, c);
                break;
            case kFmt22s:
                a = ubyte(insns, u1offset + 1);
                b = sshort(insns, u1offset + 2);
                dcv.visitStmt2R1N(op, a & 0xF, a >> 4, b);
                break;
            // case kFmt22cs:break;
            case kFmt31i:
                a = ubyte(insns, u1offset + 1);
                b = sint(insns, u1offset + 2);
                if (op == Op.CONST) {
                    dcv.visitConstStmt(op, a, b);
                } else {
                    dcv.visitConstStmt(op, a, (long) b);
                }
                break;
            case kFmt51l:
                a = ubyte(insns, u1offset + 1);
                long z = 0;
                z |= ((long) ushort(insns, u1offset + 2)) << 0;
                z |= ((long) ushort(insns, u1offset + 4)) << 16;
                z |= ((long) ushort(insns, u1offset + 6)) << 32;
                z |= ((long) ushort(insns, u1offset + 8)) << 48;
                dcv.visitConstStmt(op, a, z);
                break;
            }
        }

        while (nextLabelOffset != null) {
            dcv.visitLabel(labelsMap.get(nextLabelOffset));
            if (labelOffsetIterator.hasNext()) {
                nextLabelOffset = labelOffsetIterator.next();
            } else {
                break;
            }
        }
    }",loop_control
labelOffsetIterator,"{
        Iterator<Integer> labelOffsetIterator = labelsMap.keySet().iterator();
        Integer nextLabelOffset = labelOffsetIterator.hasNext() ? labelOffsetIterator.next() : null;
        Op[] values = Op.ops;
        for (int offset = nextInsn.nextSetBit(0); offset >= 0; offset = nextInsn.nextSetBit(offset + 1)) {
            // issue 65, a label may `inside` an instruction
            // visit all label with offset <= currentOffset
            while (nextLabelOffset != null) {
                if (nextLabelOffset <= offset) {
                    dcv.visitLabel(labelsMap.get(nextLabelOffset));
                    nextLabelOffset = labelOffsetIterator.hasNext() ? labelOffsetIterator.next() : null;
                } else {
                    // the label is after this instruction
                    break;
                }
            }

            if(badOps.get(offset)){
                dcv.visitStmt0R(Op.BAD_OP);
                continue;
            }

            int u1offset = offset * 2;
            int opcode = 0xFF & insns[u1offset];

            Op op = values[opcode];

            int a, b, c, target;
            switch (op.format) {
            // case kFmt00x: break;
            case kFmt10x:
                dcv.visitStmt0R(op);
                break;

            case kFmt11x:
                dcv.visitStmt1R(op, 0xFF & insns[u1offset + 1]);
                break;
            case kFmt12x:
                a = ubyte(insns, u1offset + 1);
                dcv.visitStmt2R(op, a & 0xF, a >> 4);
                break;
            // case kFmt20bc:break;
            case kFmt10t:
                target = offset + insns[u1offset + 1];
                dcv.visitJumpStmt(op, -1, -1, labelsMap.get(target));
                break;
            case kFmt20t:
                target = offset + sshort(insns, u1offset + 2);
                dcv.visitJumpStmt(op, -1, -1, labelsMap.get(target));
                break;
            case kFmt21t:
                target = offset + sshort(insns, u1offset + 2);
                dcv.visitJumpStmt(op, ubyte(insns, u1offset + 1), -1, labelsMap.get(target));
                break;
            case kFmt22t:
                target = offset + sshort(insns, u1offset + 2);
                a = ubyte(insns, u1offset + 1);
                b = a & 0x0F;
                c = a >> 4;
                boolean ignore = false;
                if (b == c) {
                    switch (op) {
                    case IF_EQ:
                    case IF_GE:
                    case IF_LE:
                        // means always jump, equals to goto
                        dcv.visitJumpStmt(Op.GOTO, 0, 0, labelsMap.get(target));
                        ignore = true;
                        break;
                    case IF_NE:
                    case IF_GT:
                    case IF_LT:
                        // means always not jump
                        ignore = true;
                        break;
                    default:
                        break;
                    }
                }
                if (!ignore) {
                    dcv.visitJumpStmt(op, b, c, labelsMap.get(target));
                }
                break;
            case kFmt30t:
                target = offset + sint(insns, u1offset + 2);
                dcv.visitJumpStmt(op, -1, -1, labelsMap.get(target));
                break;
            case kFmt31t:
                target = offset + sint(insns, u1offset + 2);
                a = ubyte(insns, u1offset + 1);
                int u1SwitchData = 2 * target;
                if (op == Op.FILL_ARRAY_DATA) {
                    int element_width = ushort(insns, u1SwitchData + 2);
                    int size = uint(insns, u1SwitchData + 4);
                    switch (element_width) {
                    case 1: {
                        byte[] data = new byte[size];
                        System.arraycopy(insns, u1SwitchData + 8, data, 0, size);
                        dcv.visitFillArrayDataStmt(op, a, data);
                    }
                        break;
                    case 2: {
                        short[] data = new short[size];
                        for (int i = 0; i < size; i++) {
                            data[i] = (short) sshort(insns, u1SwitchData + 8 + 2 * i);
                        }
                        dcv.visitFillArrayDataStmt(op, a, data);
                    }
                        break;
                    case 4: {
                        int[] data = new int[size];
                        for (int i = 0; i < size; i++) {
                            data[i] = sint(insns, u1SwitchData + 8 + 4 * i);
                        }
                        dcv.visitFillArrayDataStmt(op, a, data);
                    }
                        break;
                    case 8: {
                        long[] data = new long[size];
                        for (int i = 0; i < size; i++) {
                            int t = u1SwitchData + 8 + 8 * i;
                            long z = 0;
                            z |= ((long) ushort(insns, t + 0)) << 0;
                            z |= ((long) ushort(insns, t + 2)) << 16;
                            z |= ((long) ushort(insns, t + 4)) << 32;
                            z |= ((long) ushort(insns, t + 6)) << 48;
                            data[i] = z;
                        }
                        dcv.visitFillArrayDataStmt(op, a, data);
                    }
                        break;
                    }
                } else if (op == Op.SPARSE_SWITCH) {
                    int size = sshort(insns, u1SwitchData + 2);
                    int keys[] = new int[size];
                    DexLabel labels[] = new DexLabel[size];
                    int z = u1SwitchData + 4;
                    for (int i = 0; i < size; i++) {
                        keys[i] = sint(insns, z + i * 4);
                    }
                    z += size * 4;
                    for (int i = 0; i < size; i++) {
                        labels[i] = labelsMap.get(offset + sint(insns, z + i * 4));
                    }
                    dcv.visitSparseSwitchStmt(op, a, keys, labels);
                } else {
                    int size = sshort(insns, u1SwitchData + 2);
                    int first_key = sint(insns, u1SwitchData + 4);
                    DexLabel labels[] = new DexLabel[size];
                    int z = u1SwitchData + 8;
                    for (int i = 0; i < size; i++) {
                        labels[i] = labelsMap.get(offset + sint(insns, z));
                        z += 4;
                    }
                    dcv.visitPackedSwitchStmt(op, a, first_key, labels);
                }
                break;
            case kFmt21c:
                a = ubyte(insns, u1offset + 1);
                b = ushort(insns, u1offset + 2);
                switch (op.indexType) {
                case kIndexStringRef:
                    dcv.visitConstStmt(op, a, getString(b));
                    break;
                case kIndexFieldRef:
                    dcv.visitFieldStmt(op, a, -1, getField(b));
                    break;
                case kIndexTypeRef:
                    if (op == Op.CONST_CLASS) {
                        dcv.visitConstStmt(op, a, new DexType(getType(b)));
                    } else {
                        dcv.visitTypeStmt(op, a, -1, getType(b));
                    }
                    break;
                default:
                    break;
                }
                break;
            case kFmt22c:
                a = ubyte(insns, u1offset + 1);
                b = ushort(insns, u1offset + 2);
                switch (op.indexType) {
                case kIndexFieldRef:
                    dcv.visitFieldStmt(op, a & 0xF, a >> 4, getField(b));
                    break;
                case kIndexTypeRef:
                    dcv.visitTypeStmt(op, a & 0xF, a >> 4, getType(b));
                    break;
                default:
                    break;
                }
                break;
            case kFmt31c:
                if (op.indexType == InstructionIndexType.kIndexStringRef) {
                    a = ubyte(insns, u1offset + 1);
                    b = uint(insns, u1offset + 2);
                    dcv.visitConstStmt(op, a, getString(b));
                }
                break;
            case kFmt35c: {
                a = ubyte(insns, u1offset + 1);
                b = ushort(insns, u1offset + 2);
                int dc = ubyte(insns, u1offset + 4); // DC
                int fe = ubyte(insns, u1offset + 5); // FE

                int regs[] = new int[a >> 4];
                switch (a >> 4) {
                case 5:
                    regs[4] = a & 0xF;// G
                case 4:
                    regs[3] = 0xF & (fe >> 4);// F
                case 3:
                    regs[2] = 0xF & (fe >> 0);// E
                case 2:
                    regs[1] = 0xF & (dc >> 4);// D
                case 1:
                    regs[0] = 0xF & (dc >> 0);// C
                }
                if (op.indexType == InstructionIndexType.kIndexTypeRef) {
                    dcv.visitFilledNewArrayStmt(op, regs, getType(b));
                } else if (op.indexType == InstructionIndexType.kIndexCallSiteRef) {
                    Object[] callsite = getCallSite(b);
                    Object[] constArgs = Arrays.copyOfRange(callsite, 3, callsite.length);
                    dcv.visitMethodStmt(op, regs, (String) callsite[1], (Proto) callsite[2], (MethodHandle) callsite[0], constArgs);
                } else {
                    dcv.visitMethodStmt(op, regs, getMethod(b));
                }
            }
                break;
            case kFmt3rc: {
                a = ubyte(insns, u1offset + 1);
                b = ushort(insns, u1offset + 2);
                c = ushort(insns, u1offset + 4);
                int regs[] = new int[a];
                for (int i = 0; i < a; i++) {
                    regs[i] = c + i;
                }
                if (op.indexType == InstructionIndexType.kIndexTypeRef) {
                    dcv.visitFilledNewArrayStmt(op, regs, getType(b));
                } else if (op.indexType == InstructionIndexType.kIndexCallSiteRef) {
                    Object[] callsite = getCallSite(b);
                    Object[] constArgs = Arrays.copyOfRange(callsite, 3, callsite.length - 3);
                    dcv.visitMethodStmt(op, regs, (String) callsite[1], (Proto) callsite[2], (MethodHandle) callsite[0], constArgs);
                } else {
                    dcv.visitMethodStmt(op, regs, getMethod(b));
                }
            }
                break;
            case kFmt45cc: {
                a = ubyte(insns, u1offset + 1);
                b = ushort(insns, u1offset + 2);
                int dc = ubyte(insns, u1offset + 4); // DC
                int fe = ubyte(insns, u1offset + 5); // FE
                int h = ushort(insns, u1offset + 6);

                int regs[] = new int[a >> 4];
                switch (a >> 4) {
                case 5:
                    regs[4] = a & 0xF;// G
                case 4:
                    regs[3] = 0xF & (fe >> 4);// F
                case 3:
                    regs[2] = 0xF & (fe >> 0);// E
                case 2:
                    regs[1] = 0xF & (dc >> 4);// D
                case 1:
                    regs[0] = 0xF & (dc >> 0);// C
                }
                dcv.visitMethodStmt(op, regs, getMethod(b), getProto(h));
            }
            break;
            case kFmt4rcc: {
                a = ubyte(insns, u1offset + 1);
                b = ushort(insns, u1offset + 2);
                c = ushort(insns, u1offset + 4);
                int h = ushort(insns, u1offset + 6);
                int regs[] = new int[a];
                for (int i = 0; i < a; i++) {
                    regs[i] = c + i;
                }
                dcv.visitMethodStmt(op, regs, getMethod(b), getProto(h));
            }
            break;
            case kFmt22x:
                a = ubyte(insns, u1offset + 1);
                b = ushort(insns, u1offset + 2);
                dcv.visitStmt2R(op, a, b);
                break;
            case kFmt23x:
                a = ubyte(insns, u1offset + 1);
                b = ubyte(insns, u1offset + 2);
                c = ubyte(insns, u1offset + 3);
                dcv.visitStmt3R(op, a, b, c);
                break;
            case kFmt32x:
                a = ushort(insns, u1offset + 2);
                b = ushort(insns, u1offset + 4);
                dcv.visitStmt2R(op, a, b);
                break;
            case kFmt11n:
                a = insns[u1offset + 1];
                dcv.visitConstStmt(op, a & 0xF, a >> 4);
                break;
            case kFmt21h:
                a = ubyte(insns, u1offset + 1);
                b = sshort(insns, u1offset + 2);
                if (op == Op.CONST_HIGH16) {
                    dcv.visitConstStmt(op, a, b << 16);
                } else {
                    dcv.visitConstStmt(op, a, ((long) b) << 48);
                }
                break;
            case kFmt21s:
                a = ubyte(insns, u1offset + 1);
                b = sshort(insns, u1offset + 2);
                if (op == Op.CONST_16) {
                    dcv.visitConstStmt(op, a, b);
                } else {
                    dcv.visitConstStmt(op, a, (long) b);
                }
                break;
            case kFmt22b:
                a = ubyte(insns, u1offset + 1);
                b = ubyte(insns, u1offset + 2);
                c = sbyte(insns, u1offset + 3);
                dcv.visitStmt2R1N(op, a, b, c);
                break;
            case kFmt22s:
                a = ubyte(insns, u1offset + 1);
                b = sshort(insns, u1offset + 2);
                dcv.visitStmt2R1N(op, a & 0xF, a >> 4, b);
                break;
            // case kFmt22cs:break;
            case kFmt31i:
                a = ubyte(insns, u1offset + 1);
                b = sint(insns, u1offset + 2);
                if (op == Op.CONST) {
                    dcv.visitConstStmt(op, a, b);
                } else {
                    dcv.visitConstStmt(op, a, (long) b);
                }
                break;
            case kFmt51l:
                a = ubyte(insns, u1offset + 1);
                long z = 0;
                z |= ((long) ushort(insns, u1offset + 2)) << 0;
                z |= ((long) ushort(insns, u1offset + 4)) << 16;
                z |= ((long) ushort(insns, u1offset + 6)) << 32;
                z |= ((long) ushort(insns, u1offset + 8)) << 48;
                dcv.visitConstStmt(op, a, z);
                break;
            }
        }

        while (nextLabelOffset != null) {
            dcv.visitLabel(labelsMap.get(nextLabelOffset));
            if (labelOffsetIterator.hasNext()) {
                nextLabelOffset = labelOffsetIterator.next();
            } else {
                break;
            }
        }
    }",iterator
c,"{
        AccessBufByteArrayOutputStream out = new AccessBufByteArrayOutputStream();
        byte[] buff = new byte[1024];
        for (int c = is.read(buff); c > 0; c = is.read(buff)) {
            out.write(buff, 0, c);
        }
        return out.getBuf();
    }",maybe_loop_control
e,"{
        if (data.length < 3) {
            throw new IOException(""File too small to be a dex/zip"");
        }
        if (""dex"".equals(new String(data, 0, 3, StandardCharsets.ISO_8859_1))) {// dex
            return new DexFileReader(data);
        } else if (""PK"".equals(new String(data, 0, 2, StandardCharsets.ISO_8859_1))) {// ZIP
            TreeMap<String, DexFileReader> dexFileReaders = new TreeMap<>();
            try (ZipFile zipFile = new ZipFile(data)) {
                for (ZipEntry e : zipFile.entries()) {
                    String entryName = e.getName();
                    if (entryName.startsWith(""classes"") && entryName.endsWith("".dex"")) {
                        if (!dexFileReaders.containsKey(entryName)) { // only the first one
                            dexFileReaders.put(entryName, new DexFileReader(toByteArray(zipFile.getInputStream(e))));
                        }
                    }
                }
            }
            if (dexFileReaders.size() == 0) {
                throw new IOException(""Can not find classes.dex in zip file"");
            } else if (dexFileReaders.size() == 1) {
                return dexFileReaders.firstEntry().getValue();
            } else {
                return new MultiDexFileReader(dexFileReaders.values());
            }
        }
        throw new IOException(""The source file is not a .dex or .zip file"");
    }",iterator
reader,"{
        Set<String> classes = new HashSet<>();
        for (DexFileReader reader : readers) {
            List<String> classNames = reader.getClassNames();
            for (int i = 0; i < classNames.size(); i++) {
                String className = classNames.get(i);
                if (classes.add(className)) {
                    items.add(new Item(i, reader, className));
                }
            }
        }
    }",iterator
i,"{
        Set<String> classes = new HashSet<>();
        for (DexFileReader reader : readers) {
            List<String> classNames = reader.getClassNames();
            for (int i = 0; i < classNames.size(); i++) {
                String className = classNames.get(i);
                if (classes.add(className)) {
                    items.add(new Item(i, reader, className));
                }
            }
        }
    }",loop_control
r,"{
        int max = DexConstants.DEX_035;
        for (DexFileReader r : readers) {
            int v = r.getDexVersion();
            if (v > max) {
                max = v;
            }
        }
        return max;
    }",iterator
i,"{
        int size = items.size();
        for (int i = 0; i < size; i++) {
            accept(dv, i, config);
        }
    }",loop_control
c,"{
        AccessBufByteArrayOutputStream out = new AccessBufByteArrayOutputStream();
        byte[] buff = new byte[1024];
        for (int c = is.read(buff); c > 0; c = is.read(buff)) {
            out.write(buff, 0, c);
        }
        return out.getBuf();
    }",maybe_loop_control
a,"{
        while (true) {
            char a = (char) (in.get() & 0xff);
            if (a == 0) {
                return sb.toString();
            }

            if (a < '\u0080') {
                sb.append(a);
            } else if ((a & 0xe0) == 0xc0) {
                int b = in.get() & 0xff;
                if ((b & 0xC0) != 0x80) {
                    throw new UTFDataFormatException(""bad second byte"");
                }
                sb.append((char) (((a & 0x1F) << 6) | (b & 0x3F)));
            } else if ((a & 0xf0) == 0xe0) {
                int b = in.get() & 0xff;
                int c = in.get() & 0xff;
                if (((b & 0xC0) != 0x80) || ((c & 0xC0) != 0x80)) {
                    throw new UTFDataFormatException(""bad second or third byte"");
                }
                sb.append((char) (((a & 0x0F) << 12) | ((b & 0x3F) << 6) | (c & 0x3F)));
            } else {
                throw new UTFDataFormatException(""bad byte"");
            }
        }
    }",break_loop_control
i,"{
        long result = 0;
        final int length = s.length();
        for (int i = 0; i < length; ++i) {
            char ch = s.charAt(i);
            if (ch != 0 && ch <= 127) { // U+0000 uses two bytes.
                ++result;
            } else if (ch <= 2047) {
                result += 2;
            } else {
                result += 3;
            }
            if (shortLength && result > 65535) {
                throw new UTFDataFormatException(""String more than 65535 UTF bytes long"");
            }
        }
        return result;
    }",loop_control
i,"{
        final int length = s.length();
        for (int i = 0; i < length; i++) {
            char ch = s.charAt(i);
            if (ch != 0 && ch <= 127) { // U+0000 uses two bytes.
                dst[offset++] = (byte) ch;
            } else if (ch <= 2047) {
                dst[offset++] = (byte) (0xc0 | (0x1f & (ch >> 6)));
                dst[offset++] = (byte) (0x80 | (0x3f & ch));
            } else {
                dst[offset++] = (byte) (0xe0 | (0x0f & (ch >> 12)));
                dst[offset++] = (byte) (0x80 | (0x3f & (ch >> 6)));
                dst[offset++] = (byte) (0x80 | (0x3f & ch));
            }
        }
    }",loop_control
s,"{
        if (args.length < 1) {
            System.out.println(""ASMifier 1.dex 2.dex ... n.dex"");
            return;
        }
        for (String s : args) {
            System.out.println(""asmifier "" + s);
            doFile(new File(s).toPath());
        }
    }",iterator
i,"{
        StringBuilder sb = new StringBuilder();
        List<String> list = new ArrayList<String>(out.array.size());
        for (int i = 0; i < out.array.size(); i++) {
            sb.setLength(0);
            int p = out.is.get(i);
            for (int j = 0; j < p; j++) {
                sb.append(""    "");
            }
            sb.append(out.array.get(i));
            list.add(sb.toString());
        }
        try {
            Path parent = file.getParent();
            if (parent != null && !Files.exists(parent)) {
                Files.createDirectories(parent);
            }
            Files.write(file, list, StandardCharsets.UTF_8);
        } catch (IOException e) {
            e.printStackTrace();
        }
    }",loop_control
j,"{
        StringBuilder sb = new StringBuilder();
        List<String> list = new ArrayList<String>(out.array.size());
        for (int i = 0; i < out.array.size(); i++) {
            sb.setLength(0);
            int p = out.is.get(i);
            for (int j = 0; j < p; j++) {
                sb.append(""    "");
            }
            sb.append(out.array.get(i));
            list.add(sb.toString());
        }
        try {
            Path parent = file.getParent();
            if (parent != null && !Files.exists(parent)) {
                Files.createDirectories(parent);
            }
            Files.write(file, list, StandardCharsets.UTF_8);
        } catch (IOException e) {
            e.printStackTrace();
        }
    }",loop_control
obj,"{
        StringBuilder sb = new StringBuilder(""new int[]{ "");
        boolean first = true;
        for (int obj : vs) {
            if (first) {
                first = false;
            } else {
                sb.append("","");
            }
            sb.append(obj);
        }
        return sb.append(""}"").toString();
    }",iterator
obj,"{
        StringBuilder sb = new StringBuilder(""new byte[]{ "");
        boolean first = true;
        for (byte obj : vs) {
            if (first) {
                first = false;
            } else {
                sb.append("","");
            }
            sb.append(""(byte)"").append(obj);
        }
        return sb.append(""}"").toString();
    }",iterator
obj,"{
        if (vs == null) {
            return ""null"";
        }
        StringBuilder sb = new StringBuilder(""new String[]{ "");
        boolean first = true;
        for (String obj : vs) {
            if (first) {
                first = false;
            } else {
                sb.append("","");
            }
            sb.append(v(obj));
        }
        return sb.append(""}"").toString();
    }",iterator
obj,"{
        StringBuilder sb = new StringBuilder(""new Object[]{ "");
        boolean first = true;
        for (Object obj : vs) {
            if (first) {
                first = false;
            } else {
                sb.append("","");
            }
            sb.append(v(obj));
        }
        return sb.append(""}"").toString();
    }",iterator
i,"{
        if (obj == null) {
            return ""null"";
        }
        if (obj instanceof String) {
            return v((String) obj);
        }

        if (obj instanceof DexType) {
            return v((DexType) obj);
        }

        if (obj instanceof Method) {
            return v((Method) obj);
        }
        if (obj instanceof Field) {
            return v((Field) obj);
        }
        if (obj instanceof Proto) {
            return v((Proto) obj);
        }
        if (obj instanceof MethodHandle) {
            return v((MethodHandle) obj);
        }

        if (obj instanceof Integer) {
            return "" Integer.valueOf("" + obj + "")"";
        }
        if (obj instanceof Long) {
            return ""Long.valueOf("" + obj + ""L)"";
        }
        if (obj instanceof Float) {
            return ""Float.valueOf("" + obj + ""F)"";
        }
        if (obj instanceof Double) {
            return ""Double.valueOf("" + obj + ""D)"";
        }
        if (obj instanceof Short) {
            return ""Short.valueOf((short)"" + obj + "")"";
        }
        if (obj instanceof Byte) {
            return ""Byte.valueOf((byte)"" + obj + "")"";
        }
        if (obj instanceof Character) {
            return ""Character.valueOf('"" + obj + ""')"";
        }
        if (obj instanceof Boolean) {
            return ""Boolean.valueOf("" + obj + "")"";
        }
        if (obj instanceof int[]) {
            StringBuilder sb = new StringBuilder(""new int[]{ "");
            boolean first = true;
            for (int i : (int[]) obj) {
                if (first) {
                    first = false;
                } else {
                    sb.append("","");
                }
                sb.append(i);
            }
            return sb.append(""}"").toString();
        }
        if (obj instanceof short[]) {
            StringBuilder sb = new StringBuilder(""new short[]{ "");
            boolean first = true;
            for (int i : (short[]) obj) {
                if (first) {
                    first = false;
                } else {
                    sb.append("","");
                }
                sb.append(""(short)"").append(i);
            }
            return sb.append(""}"").toString();
        }
        if (obj instanceof long[]) {
            StringBuilder sb = new StringBuilder(""new long[]{ "");
            boolean first = true;
            for (long i : (long[]) obj) {
                if (first) {
                    first = false;
                } else {
                    sb.append("","");
                }
                sb.append(i).append(""L"");
            }
            return sb.append(""}"").toString();
        }
        if (obj instanceof float[]) {
            StringBuilder sb = new StringBuilder(""new float[]{ "");
            boolean first = true;
            for (float i : (float[]) obj) {
                if (first) {
                    first = false;
                } else {
                    sb.append("","");
                }
                sb.append(i).append(""F"");
            }
            return sb.append(""}"").toString();
        }
        return null;
    }",iterator
i,"{
        int len = string.length();
        byte[] bytes = new byte[len * 3]; // Avoid having to reallocate.
        int outAt = 0;

        for (int i = 0; i < len; i++) {
            char c = string.charAt(i);
            if ((c != 0) && (c < 0x80)) {
                bytes[outAt] = (byte) c;
                outAt++;
            } else if (c < 0x800) {
                bytes[outAt] = (byte) (((c >> 6) & 0x1f) | 0xc0);
                bytes[outAt + 1] = (byte) ((c & 0x3f) | 0x80);
                outAt += 2;
            } else {
                bytes[outAt] = (byte) (((c >> 12) & 0x0f) | 0xe0);
                bytes[outAt + 1] = (byte) (((c >> 6) & 0x3f) | 0x80);
                bytes[outAt + 2] = (byte) ((c & 0x3f) | 0x80);
                outAt += 3;
            }
        }

        byte[] result = new byte[outAt];
        System.arraycopy(bytes, 0, result, 0, outAt);
        return result;
    }",loop_control
at,"{
        if (tempBuffer == null || tempBuffer.length < length) {
            tempBuffer = new char[length];
        }
        char[] chars = tempBuffer;
        int outAt = 0;

        for (int at = start; length > 0; /* at */) {
            int v0 = bytes[at] & 0xFF;
            char out;
            switch (v0 >> 4) {
            case 0x00:
            case 0x01:
            case 0x02:
            case 0x03:
            case 0x04:
            case 0x05:
            case 0x06:
            case 0x07: {
                // 0XXXXXXX -- single-byte encoding
                length--;
                if (v0 == 0) {
                    // A single zero byte is illegal.
                    return throwBadUtf8(v0, at);
                }
                out = (char) v0;
                at++;
                break;
            }
            case 0x0c:
            case 0x0d: {
                // 110XXXXX -- two-byte encoding
                length -= 2;
                if (length < 0) {
                    return throwBadUtf8(v0, at);
                }
                int v1 = bytes[at + 1] & 0xFF;
                if ((v1 & 0xc0) != 0x80) {
                    return throwBadUtf8(v1, at + 1);
                }
                int value = ((v0 & 0x1f) << 6) | (v1 & 0x3f);
                if ((value != 0) && (value < 0x80)) {
                    /*
                     * This should have been represented with one-byte encoding.
                     */
                    return throwBadUtf8(v1, at + 1);
                }
                out = (char) value;
                at += 2;
                break;
            }
            case 0x0e: {
                // 1110XXXX -- three-byte encoding
                length -= 3;
                if (length < 0) {
                    return throwBadUtf8(v0, at);
                }
                int v1 = bytes[at + 1] & 0xFF;
                if ((v1 & 0xc0) != 0x80) {
                    return throwBadUtf8(v1, at + 1);
                }
                int v2 = bytes[at + 2] & 0xFF;
                if ((v1 & 0xc0) != 0x80) {
                    return throwBadUtf8(v2, at + 2);
                }
                int value = ((v0 & 0x0f) << 12) | ((v1 & 0x3f) << 6) | (v2 & 0x3f);
                if (value < 0x800) {
                    /*
                     * This should have been represented with one- or two-byte encoding.
                     */
                    return throwBadUtf8(v2, at + 2);
                }
                out = (char) value;
                at += 3;
                break;
            }
            default: {
                // 10XXXXXX, 1111XXXX -- illegal
                return throwBadUtf8(v0, at);
            }
            }
            chars[outAt] = out;
            outAt++;
        }

        return new String(chars, 0, outAt);
    }",maybe_loop_control
length,"{
        if (tempBuffer == null || tempBuffer.length < length) {
            tempBuffer = new char[length];
        }
        char[] chars = tempBuffer;
        int outAt = 0;

        for (int at = start; length > 0; /* at */) {
            int v0 = bytes[at] & 0xFF;
            char out;
            switch (v0 >> 4) {
            case 0x00:
            case 0x01:
            case 0x02:
            case 0x03:
            case 0x04:
            case 0x05:
            case 0x06:
            case 0x07: {
                // 0XXXXXXX -- single-byte encoding
                length--;
                if (v0 == 0) {
                    // A single zero byte is illegal.
                    return throwBadUtf8(v0, at);
                }
                out = (char) v0;
                at++;
                break;
            }
            case 0x0c:
            case 0x0d: {
                // 110XXXXX -- two-byte encoding
                length -= 2;
                if (length < 0) {
                    return throwBadUtf8(v0, at);
                }
                int v1 = bytes[at + 1] & 0xFF;
                if ((v1 & 0xc0) != 0x80) {
                    return throwBadUtf8(v1, at + 1);
                }
                int value = ((v0 & 0x1f) << 6) | (v1 & 0x3f);
                if ((value != 0) && (value < 0x80)) {
                    /*
                     * This should have been represented with one-byte encoding.
                     */
                    return throwBadUtf8(v1, at + 1);
                }
                out = (char) value;
                at += 2;
                break;
            }
            case 0x0e: {
                // 1110XXXX -- three-byte encoding
                length -= 3;
                if (length < 0) {
                    return throwBadUtf8(v0, at);
                }
                int v1 = bytes[at + 1] & 0xFF;
                if ((v1 & 0xc0) != 0x80) {
                    return throwBadUtf8(v1, at + 1);
                }
                int v2 = bytes[at + 2] & 0xFF;
                if ((v1 & 0xc0) != 0x80) {
                    return throwBadUtf8(v2, at + 2);
                }
                int value = ((v0 & 0x0f) << 12) | ((v1 & 0x3f) << 6) | (v2 & 0x3f);
                if (value < 0x800) {
                    /*
                     * This should have been represented with one- or two-byte encoding.
                     */
                    return throwBadUtf8(v2, at + 2);
                }
                out = (char) value;
                at += 3;
                break;
            }
            default: {
                // 10XXXXXX, 1111XXXX -- illegal
                return throwBadUtf8(v0, at);
            }
            }
            chars[outAt] = out;
            outAt++;
        }

        return new String(chars, 0, outAt);
    }",maybe_loop_control
i,"{
        for (int i = 0; i < value.length(); i++) {
            char c = value.charAt(i);

            if ((c >= ' ') && (c < 0x7f)) {
                if ((c == '\'') || (c == '\""') || (c == '\\')) {
                    writer.write('\\');
                }
                writer.write(c);
                continue;
            } else if (c <= 0x7f) {
                switch (c) {
                case '\n':
                    writer.write(""\\n"");
                    continue;
                case '\r':
                    writer.write(""\\r"");
                    continue;
                case '\t':
                    writer.write(""\\t"");
                    continue;
                }
            }

            writer.write(""\\u"");
            writer.write(Character.forDigit(c >> 12, 16));
            writer.write(Character.forDigit((c >> 8) & 0x0f, 16));
            writer.write(Character.forDigit((c >> 4) & 0x0f, 16));
            writer.write(Character.forDigit(c & 0x0f, 16));
        }
    }",loop_control
i,"{
        int len = value.length();
        StringBuilder sb = new StringBuilder(len * 3 / 2);

        for (int i = 0; i < len; i++) {
            char c = value.charAt(i);

            if ((c >= ' ') && (c < 0x7f)) {
                if ((c == '\'') || (c == '\""') || (c == '\\')) {
                    sb.append('\\');
                }
                sb.append(c);
                continue;
            } else if (c <= 0x7f) {
                switch (c) {
                case '\n':
                    sb.append(""\\n"");
                    continue;
                case '\r':
                    sb.append(""\\r"");
                    continue;
                case '\t':
                    sb.append(""\\t"");
                    continue;
                }
            }

            sb.append(""\\u"");
            sb.append(Character.forDigit(c >> 12, 16));
            sb.append(Character.forDigit((c >> 8) & 0x0f, 16));
            sb.append(Character.forDigit((c >> 4) & 0x0f, 16));
            sb.append(Character.forDigit(c & 0x0f, 16));
        }

        return sb.toString();
    }",loop_control
dexLabel,"{
        StringBuilder sb = new StringBuilder(""new DexLabel[]{"");
        boolean first = true;
        for (DexLabel dexLabel : labels) {
            if (first) {
                first = false;
            } else {
                sb.append("","");
            }
            sb.append(v(dexLabel));
        }
        return sb.append(""}"").toString();
    }",iterator
i,"{
        out.pop();
        out.s(""}"");
        for (ArrayOut o : fieldOuts) {
            out.array.addAll(o.array);
            for (int i : o.is) {
                out.is.add(out.i + i);
            }
        }
        fieldOuts = null;
        for (ArrayOut o : methodOuts) {
            out.array.addAll(o.array);
            for (int i : o.is) {
                out.is.add(out.i + i);
            }
        }
        methodOuts = null;
        out.pop();
        out.s(""}"");
    }",iterator
o,"{
        out.pop();
        out.s(""}"");
        for (ArrayOut o : fieldOuts) {
            out.array.addAll(o.array);
            for (int i : o.is) {
                out.is.add(out.i + i);
            }
        }
        fieldOuts = null;
        for (ArrayOut o : methodOuts) {
            out.array.addAll(o.array);
            for (int i : o.is) {
                out.is.add(out.i + i);
            }
        }
        methodOuts = null;
        out.pop();
        out.s(""}"");
    }",iterator
b,"{
        for (byte b : bytes) {
            if (b == 0) {
                return true;
            }
        }
        return false;
    }",iterator
e,"{
        for (ZipEntry e : entries) {
            if (e.getName().equals(entryName)) {
                return e;
            }
        }
        return null;
    }",iterator
e,"{
        for (ZipEntry e : entries) {
            if (e.getName().equals(entryName)) {
                return e;
            }
        }
        return null;
    }",break_loop_control
raf,"{
        ByteBuffer raf = this.raf;
        // Scan back, looking for the End Of Central Directory field. If the zip file doesn't
        // have an overall comment (unrelated to any per-entry comments), we'll hit the EOCD
        // on the first try.
        // No need to synchronize raf here -- we only do this when we first open the zip file.
        long scanOffset = raf.limit() - ENDHDR;
        if (scanOffset < 0) {
            throw new ZipException(""File too short to be a zip file: "" + raf.limit());
        }

        // not check Magic
        // raf.position(0);
        // final int headerMagic = raf.getInt();
        // if (headerMagic != LOCSIG) {
        // throw new ZipException(""Not a zip archive"");
        // }

        long stopOffset = scanOffset - 65536;
        if (stopOffset < 0) {
            stopOffset = 0;
        }

        while (true) {
            raf.position((int) scanOffset);
            if (raf.getInt() == ENDSIG) {
                break;
            }

            scanOffset--;
            if (scanOffset < stopOffset) {
                throw new ZipException(""End Of Central Directory signature not found"");
            }
        }

        // Read the End Of Central Directory. ENDHDR includes the signature bytes,
        // which we've already read.

        // Pull out the information we need.
        int diskNumber = raf.getShort() & 0xffff;
        int diskWithCentralDir = raf.getShort() & 0xffff;
        int numEntries = raf.getShort() & 0xffff;
        int totalNumEntries = raf.getShort() & 0xffff;
        skip(raf, 4); // Ignore centralDirSize.
        long centralDirOffset = ((long) raf.getInt()) & 0xffffffffL;
        int commentLength = raf.getShort() & 0xffff;

        if (numEntries != totalNumEntries || diskNumber != 0 || diskWithCentralDir != 0) {
            throw new ZipException(""Spanned archives not supported"");
        }
        boolean skipCommentsAndExtra = true;

        if (commentLength > 0) {
            if (commentLength > raf.remaining()) {
                System.err.println(""WARN: the zip comment exceed the zip content"");
            } else {
                if (skipCommentsAndExtra) {
                    skip(raf, commentLength);
                } else {
                    byte[] commentBytes = new byte[commentLength];
                    raf.get(commentBytes);
                    comment = new String(commentBytes, 0, commentBytes.length, StandardCharsets.UTF_8);
                }
            }
        }

        // Seek to the first CDE and read all entries.
        // We have to do this now (from the constructor) rather than lazily because the
        // public API doesn't allow us to throw IOException except from the constructor
        // or from getInputStream.
        ByteBuffer buf = (ByteBuffer) raf.duplicate().order(ByteOrder.LITTLE_ENDIAN).position((int) centralDirOffset);
        entries = new ArrayList<>(numEntries);
        for (int i = 0; i < numEntries; ++i) {
            ZipEntry newEntry = new ZipEntry(buf, skipCommentsAndExtra);
            if (newEntry.localHeaderRelOffset >= centralDirOffset) {
                // Ignore the entry
                // throw new ZipException(""Local file header offset is after central directory"");
            } else {
                entries.add(newEntry);
            }
        }
    }",break_loop_control
i,"{
        ByteBuffer raf = this.raf;
        // Scan back, looking for the End Of Central Directory field. If the zip file doesn't
        // have an overall comment (unrelated to any per-entry comments), we'll hit the EOCD
        // on the first try.
        // No need to synchronize raf here -- we only do this when we first open the zip file.
        long scanOffset = raf.limit() - ENDHDR;
        if (scanOffset < 0) {
            throw new ZipException(""File too short to be a zip file: "" + raf.limit());
        }

        // not check Magic
        // raf.position(0);
        // final int headerMagic = raf.getInt();
        // if (headerMagic != LOCSIG) {
        // throw new ZipException(""Not a zip archive"");
        // }

        long stopOffset = scanOffset - 65536;
        if (stopOffset < 0) {
            stopOffset = 0;
        }

        while (true) {
            raf.position((int) scanOffset);
            if (raf.getInt() == ENDSIG) {
                break;
            }

            scanOffset--;
            if (scanOffset < stopOffset) {
                throw new ZipException(""End Of Central Directory signature not found"");
            }
        }

        // Read the End Of Central Directory. ENDHDR includes the signature bytes,
        // which we've already read.

        // Pull out the information we need.
        int diskNumber = raf.getShort() & 0xffff;
        int diskWithCentralDir = raf.getShort() & 0xffff;
        int numEntries = raf.getShort() & 0xffff;
        int totalNumEntries = raf.getShort() & 0xffff;
        skip(raf, 4); // Ignore centralDirSize.
        long centralDirOffset = ((long) raf.getInt()) & 0xffffffffL;
        int commentLength = raf.getShort() & 0xffff;

        if (numEntries != totalNumEntries || diskNumber != 0 || diskWithCentralDir != 0) {
            throw new ZipException(""Spanned archives not supported"");
        }
        boolean skipCommentsAndExtra = true;

        if (commentLength > 0) {
            if (commentLength > raf.remaining()) {
                System.err.println(""WARN: the zip comment exceed the zip content"");
            } else {
                if (skipCommentsAndExtra) {
                    skip(raf, commentLength);
                } else {
                    byte[] commentBytes = new byte[commentLength];
                    raf.get(commentBytes);
                    comment = new String(commentBytes, 0, commentBytes.length, StandardCharsets.UTF_8);
                }
            }
        }

        // Seek to the first CDE and read all entries.
        // We have to do this now (from the constructor) rather than lazily because the
        // public API doesn't allow us to throw IOException except from the constructor
        // or from getInputStream.
        ByteBuffer buf = (ByteBuffer) raf.duplicate().order(ByteOrder.LITTLE_ENDIAN).position((int) centralDirOffset);
        entries = new ArrayList<>(numEntries);
        for (int i = 0; i < numEntries; ++i) {
            ZipEntry newEntry = new ZipEntry(buf, skipCommentsAndExtra);
            if (newEntry.localHeaderRelOffset >= centralDirOffset) {
                // Ignore the entry
                // throw new ZipException(""Local file header offset is after central directory"");
            } else {
                entries.add(newEntry);
            }
        }
    }",loop_control
